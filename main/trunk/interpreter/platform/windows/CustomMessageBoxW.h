/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 1995, 2004 IBM Corporation. All rights reserved.             */
/* Copyright (c) 2005-2026 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* https://www.oorexx.org/license.html                                        */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/


/*
CustomMessageBoxW,
Generated by Claude.ai Sonnet 4.6, with many iterations.

MessageBoxW displays emojis in black and white.

Segoe UI Emoji Font is the primary font responsible for rendering colorful
emojis on Windows.

Segoe UI Emoji cannot be reliably used with MessageBoxW because the Windows GDI
(Graphics Device Interface), which MessageBoxW relies on, does not support color
fonts or advanced OpenType features like those in Segoe UI Emoji.

How CustomMessageBoxW works:
The key insight is that MessageBox always uses the system message font and you
cannot override it. This implementation avoids that by:

1. Building the dialog template in memory (DialogBoxIndirectParamW) â€” no .rc
   file needed, so it's self-contained.
2. Owner-drawing the static text control using Direct2D + DirectWrite via
   a subclassed window procedure (EmojiStaticProc), which intercepts WM_PAINT
   and renders the text using ID2D1HwndRenderTarget with the flag
   D2D1_DRAW_TEXT_OPTIONS_ENABLE_COLOR_FONT.
3. Buttons are created dynamically in WM_INITDIALOG from the MB_OK / MB_YESNO /
   ... flags, so the API is a drop-in replacement.
4. Icons are loaded from the standard IDI_* resources so warning/error/info
   icons still appear correctly.

[Update after tests still showing B&W emojis]

The black-and-white emoji is a known issue: "Segoe UI Emoji" alone is not
enough. Windows uses a font fallback mechanism, and when you call CreateFontW
with "Segoe UI Emoji", GDI sometimes falls back to the old monochrome emoji font
instead of using the color COLR/CPAL glyphs.

The root cause is that GDI itself does not support color fonts.
Color emoji rendering requires DirectWrite or GDI+, not plain GDI.
The WM_SETFONT / GetTextExtentPoint32W / TextOut pipeline is pure GDI and will
always render emoji in monochrome.

The fix is to owner-draw the static text control using Direct2D + DirectWrite,
which does support color fonts.

The critical piece is the flag D2D1_DRAW_TEXT_OPTIONS_ENABLE_COLOR_FONT passed
to DrawTextLayout. This tells Direct2D to use the COLR/CPAL color glyph tables
present in "Segoe UI Emoji" instead of falling back to the monochrome outline
glyphs. This flag requires Direct2D 1.1 (Windows 8.1+) and IDWriteFactory2
(also Windows 8.1+).

The ID2D1HwndRenderTarget renders directly into the static control's HWND, so no
flicker or compositing issues arise. The background is explicitly cleared to
COLOR_3DFACE (the standard dialog gray) to match the rest of the dialog.

[End of update]

[Note about the title]

The emojis in the caption are still displayed in black and white.
It's a consequence of the title bar being rendered entirely by Windows (the
non-client area), so we have no WM_PAINT hook for it. GDI is used by the DWM
(Desktop Window Manager) to draw the caption text, and GDI doesn't support color
fonts.

The only way to get color emoji in the caption is to hide the real title bar and
draw a fake one yourself inside the client area.

This is however a significant amount of work and comes with side effects:

- You have to reimplement dragging the window (handle WM_NCHITTEST returning
  HTCAPTION over the fake title area).
- You have to reimplement the close button (or use WS_SYSMENU carefully).
- The window will look slightly different from a standard dialog on different
  Windows themes.

Decision: to remain as is.

[End of note]

The sizing logic runs entirely inside WM_INITDIALOG, after the dialog and its
fonts exist, so all measurements are accurate:

- Text width is measured line-by-line with DirectWrite (MeasureTextDWrite),
  using IDWriteTextLayout with DWRITE_WORD_WRAPPING_NO_WRAP. Each \n-separated
  line is measured independently and the maximum is taken. A safety margin of
  8px is added to account for emoji cluster rounding in DirectWrite metrics.
- The dialog width is capped at 2/3 of the work area. If the text exceeds that
  width, the height is re-measured with DWRITE_WORD_WRAPPING_WRAP at the capped
  width to get the correct number of wrapped lines.
- Caption width is measured with GDI (MeasureGDITextWidth) using hFontUI, then
  80px are added as an allowance for the system title bar buttons.
- Button bar width is derived from numBtns Ã— BTN_W + gaps, expressed in pixels
  converted from dialog units via the dialog's own base units. This guarantees
  the buttons always fit even if the text is narrow.
- Dialog height is computed from the line count Ã— line height (from TEXTMETRICW
  with hFontEmoji), clamped to at least the icon height, plus fixed padding and
  button row.
- The final window size is computed by adding the non-client area (title bar +
  borders), measured as GetWindowRect âˆ’ GetClientRect, to the computed client
  size. The dialog is then re-centered on the parent window (or the work area if
  there is no parent) via SetWindowPos.


Settings you can adjust:

- Font size â€” the constant at the top of the file:
  const float g_emSize = 11.0f;

- Button width and height â€” the constants in WM_INITDIALOG:
  const int BTN_W = DuToPixX(100, baseX);   // width in dialog units
  const int BTN_H = DuToPixY(12, baseY);    // height in dialog units


Usage (identical signature to MessageBoxW):
int result = CustomMessageBoxW(
    hwndParent,
    L"File saved! ðŸ˜€âœ…ðŸŽ‰",
    L"My App",
    MB_OK | MB_ICONINFORMATION
);

Needs Windows 8.1 minimum.
Windows 10 is the practical minimum for reliable color emoji rendering.

*/

#include <windows.h>
#include <d2d1.h>
#include <dwrite.h>
#include <dwrite_2.h>
#include <wrl/client.h>
#include <cwchar>
#include <cstring>

#pragma comment(lib, "d2d1.lib")
#pragma comment(lib, "dwrite.lib")

using Microsoft::WRL::ComPtr;

const WCHAR *defaultCaption = L"Error";
const float g_emSize = 11.0f;


// -----------------------------------------------------------------------
// Cached Direct2D/DirectWrite resources for the static text control
// Created once, reused on every WM_PAINT, released on WM_DESTROY
// -----------------------------------------------------------------------
struct EmojiPainter
{
    ComPtr<ID2D1Factory>        pD2DFactory;
    ComPtr<IDWriteFactory2>     pDWFactory;
    ComPtr<ID2D1HwndRenderTarget> pRT;
    ComPtr<IDWriteTextFormat>   pFmt;
    ComPtr<IDWriteTextLayout>   pLayout;
    ComPtr<ID2D1SolidColorBrush> pBrush;
    float emSize = 0.0f; // dummy value, will be overwritten by g_emSize

    // Call once after the static control is sized and has its text
    HRESULT Init(HWND hWnd, LPCWSTR text, float emSz)
    {
        emSize = emSz;

        // Factories (cheap to keep alive, expensive to create)
        HRESULT hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED,
                                        IID_PPV_ARGS(&pD2DFactory));
        if (FAILED(hr)) return hr;

        hr = DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED,
                                  __uuidof(IDWriteFactory2),
                                  reinterpret_cast<IUnknown **>(
                                      pDWFactory.GetAddressOf()));
        if (FAILED(hr)) return hr;

        // Text format (font, size, wrapping) â€” never changes
        hr = pDWFactory->CreateTextFormat(
            L"Segoe UI Emoji", nullptr,
            DWRITE_FONT_WEIGHT_NORMAL,
            DWRITE_FONT_STYLE_NORMAL,
            DWRITE_FONT_STRETCH_NORMAL,
            emSize, L"", &pFmt);
        if (FAILED(hr)) return hr;
        pFmt->SetWordWrapping(DWRITE_WORD_WRAPPING_WRAP);

        // Render target + brush + layout
        hr = CreateDeviceResources(hWnd, text);
        return hr;
    }

    // Creates/recreates render target, brush, layout
    // Called from Init and whenever D2DERR_RECREATE_TARGET is returned
    HRESULT CreateDeviceResources(HWND hWnd, LPCWSTR text)
    {
        pRT.Reset();
        pBrush.Reset();
        pLayout.Reset();

        RECT rc;
        GetClientRect(hWnd, &rc);
        float w = (float)(rc.right  - rc.left);
        float h = (float)(rc.bottom - rc.top);
        if (w <= 0 || h <= 0) return S_OK;

        D2D1_RENDER_TARGET_PROPERTIES rtProps =
            D2D1::RenderTargetProperties(
                D2D1_RENDER_TARGET_TYPE_DEFAULT,
                D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN,
                                  D2D1_ALPHA_MODE_PREMULTIPLIED));

        D2D1_HWND_RENDER_TARGET_PROPERTIES hwndProps =
            D2D1::HwndRenderTargetProperties(
                hWnd, D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top));

        HRESULT hr = pD2DFactory->CreateHwndRenderTarget(
                         rtProps, hwndProps, &pRT);
        if (FAILED(hr)) return hr;

        // Brush â€” color from system, recreated with render target
        COLORREF sysText = GetSysColor(COLOR_WINDOWTEXT);
        D2D1_COLOR_F textColor = D2D1::ColorF(
            GetRValue(sysText) / 255.0f,
            GetGValue(sysText) / 255.0f,
            GetBValue(sysText) / 255.0f, 1.0f);
        hr = pRT->CreateSolidColorBrush(textColor, &pBrush);
        if (FAILED(hr)) return hr;

        // Text layout â€” tied to the control's pixel size
        if (text && *text)
        {
            hr = pDWFactory->CreateTextLayout(
                     text, (UINT32)wcslen(text),
                     pFmt.Get(), w, h, &pLayout);
        }
        return hr;
    }

    // Called from WM_PAINT â€” no allocation, just drawing
    void Paint(HWND hWnd, LPCWSTR text)
    {
        if (!pRT || !pBrush) return;

        COLORREF sysBg = GetSysColor(COLOR_3DFACE);
        D2D1_COLOR_F bgColor = D2D1::ColorF(
            GetRValue(sysBg) / 255.0f,
            GetGValue(sysBg) / 255.0f,
            GetBValue(sysBg) / 255.0f, 1.0f);

        pRT->BeginDraw();
        pRT->Clear(bgColor);
        if (pLayout)
        {
            pRT->DrawTextLayout(
                D2D1::Point2F(0.0f, 0.0f),
                pLayout.Get(),
                pBrush.Get(),
                D2D1_DRAW_TEXT_OPTIONS_ENABLE_COLOR_FONT);
        }
        HRESULT hr = pRT->EndDraw();

        // Device lost â€” recreate next paint
        if (hr == D2DERR_RECREATE_TARGET)
            CreateDeviceResources(hWnd, text);
    }
};

// -----------------------------------------------------------------------
// Font helper
// -----------------------------------------------------------------------
static HFONT CreateUIFont(void)
{
    NONCLIENTMETRICSW ncm = { sizeof(ncm) };
    SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);
    return CreateFontIndirectW(&ncm.lfMessageFont);
}

// -----------------------------------------------------------------------
// Convert pixels <-> dialog units
// -----------------------------------------------------------------------
static void GetDlgBaseUnits(HWND hDlg, HFONT hFont, int *pBaseX, int *pBaseY)
{
    HDC hdc  = GetDC(hDlg);
    HFONT hOld = (HFONT)SelectObject(hdc, hFont ? hFont
                                                : GetStockObject(SYSTEM_FONT));
    TEXTMETRICW tm;
    GetTextMetricsW(hdc, &tm);
    SIZE sz;
    GetTextExtentPoint32W(hdc,
        L"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", 52, &sz);
    SelectObject(hdc, hOld);
    ReleaseDC(hDlg, hdc);
    *pBaseX = (sz.cx / 52 + 1) / 2;
    *pBaseY = tm.tmHeight;
}

static int DuToPixX(int du, int baseX)
{
    return MulDiv(du, baseX, 4);
}

static int DuToPixY(int du, int baseY)
{
    return MulDiv(du, baseY, 8);
}

// -----------------------------------------------------------------------
// Measure text width with DirectWrite (no-wrap, line by line)
// -----------------------------------------------------------------------
static int MeasureTextDWrite(LPCWSTR text, float emSize, int *pLineCount)
{
    if (!text || !*text)
    {
        if (pLineCount) *pLineCount = 1;
        return 0;
    }

    // Reuse a shared factory â€” DWriteCreateFactory with SHARED type returns
    // the same factory object each time, so this call is cheap
    ComPtr<IDWriteFactory> pDWF;
    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED,
                        __uuidof(IDWriteFactory),
                        reinterpret_cast<IUnknown **>(pDWF.GetAddressOf()));

    ComPtr<IDWriteTextFormat> pFmt;
    pDWF->CreateTextFormat(L"Segoe UI Emoji", nullptr,
                            DWRITE_FONT_WEIGHT_NORMAL,
                            DWRITE_FONT_STYLE_NORMAL,
                            DWRITE_FONT_STRETCH_NORMAL,
                            emSize, L"", &pFmt);
    pFmt->SetWordWrapping(DWRITE_WORD_WRAPPING_NO_WRAP);

    int maxW = 0, lines = 0;
    const WCHAR *start = text;
    while (*start)
    {
        const WCHAR *end = start;
        while (*end && *end != L'\n') end++;
        int len = (int)(end - start);
        if (len > 0)
        {
            ComPtr<IDWriteTextLayout> pLayout;
            pDWF->CreateTextLayout(start, len, pFmt.Get(),
                                    100000.f, 100000.f, &pLayout);
            DWRITE_TEXT_METRICS m;
            pLayout->GetMetrics(&m);
            int w = (int)(m.widthIncludingTrailingWhitespace + 0.5f);
            if (w > maxW) maxW = w;
        }
        lines++;
        start = (*end == L'\n') ? end + 1 : end;
    }
    if (pLineCount) *pLineCount = lines > 0 ? lines : 1;
    return maxW;
}

static int MeasureGDITextWidth(HWND hWnd, HFONT hFont, LPCWSTR text)
{
    if (!text || !*text) return 0;
    HDC hdc    = GetDC(hWnd);
    HFONT hOld = (HFONT)SelectObject(hdc, hFont);
    SIZE sz    = {0};
    GetTextExtentPoint32W(hdc, text, (int)wcslen(text), &sz);
    SelectObject(hdc, hOld);
    ReleaseDC(hWnd, hdc);
    return sz.cx;
}

// -----------------------------------------------------------------------
// Subclass procedure â€” now only calls painter->Paint(), no allocation
// -----------------------------------------------------------------------

typedef struct
{
    // Inputs (set by caller)
    LPCWSTR      lpText;
    LPCWSTR      lpCaption;
    UINT         uType;

    // State (set by WM_INITDIALOG, used by other handlers)
    WNDPROC      origStaticProc;
    EmojiPainter *painter;
    HFONT        hFontUI;
    int          closeValue;
} MSGBOXPARAMS_CUSTOM;


static LRESULT CALLBACK EmojiStaticProc(HWND hWnd, UINT msg,
                                         WPARAM wParam, LPARAM lParam)
{
    MSGBOXPARAMS_CUSTOM *p = (MSGBOXPARAMS_CUSTOM *)GetWindowLongPtrW(
                                 hWnd, GWLP_USERDATA);

    switch (msg)
    {
        case WM_ERASEBKGND:
            return 1;

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            BeginPaint(hWnd, &ps);
            if (p->painter)
            {
                int len = GetWindowTextLengthW(hWnd);
                WCHAR *buf = new WCHAR[len + 1];
                GetWindowTextW(hWnd, buf, len + 1);
                p->painter->Paint(hWnd, buf);
                delete[] buf;
            }
            EndPaint(hWnd, &ps);
            return 0;
        }
    }

    /*
    CallWindowProcW(origProc, hWnd, msg, wParam, lParam)
    calls the previous window procedure â€” in our case the original static control
    procedure that was in place before we subclassed it. That procedure knows
    everything about how a STATIC control should behave: it handles WM_SETTEXT,
    WM_GETTEXT, WM_ENABLE, STM_SETICON, cursor handling, and many other messages
    correctly.

    DefWindowProcW(hWnd, msg, wParam, lParam)
    calls the default window procedure provided by Windows, which only handles the
    bare minimum that every window needs: WM_NCHITTEST, WM_NCCALCSIZE, WM_CLOSE,
    etc. It knows nothing about STATIC control-specific behavior.

    So in our subclass, for any message we don't handle ourselves (anything other
    than WM_PAINT and WM_ERASEBKGND), we must call CallWindowProcW(origProc, ...)
    to preserve the normal STATIC control behavior. Using DefWindowProcW instead
    would break things like GetWindowTextW (used to retrieve the message text in
    WM_PAINT), icon display, and other STATIC-specific functionality.

    In short:
    - CallWindowProcW â†’ "let the original handler deal with it"
      (correct for subclassing)
    - DefWindowProcW â†’ "let Windows deal with it at the most basic level"
      (too low-level for subclassing)
    */

    WNDPROC origProc = p->origStaticProc;
    return origProc ? CallWindowProcW(origProc, hWnd, msg, wParam, lParam)
                    : DefWindowProcW(hWnd, msg, wParam, lParam);

}

// -----------------------------------------------------------------------
// Dialog procedure
// -----------------------------------------------------------------------
static INT_PTR CALLBACK CustomMsgBoxProc(HWND hDlg, UINT msg,
                                          WPARAM wParam, LPARAM lParam)
{
    // Retrieve params from GWLP_USERDATA for all messages except WM_INITDIALOG
    MSGBOXPARAMS_CUSTOM *p = (MSGBOXPARAMS_CUSTOM *)GetWindowLongPtrW(
                                 hDlg, GWLP_USERDATA);

    switch (msg)
    {
        case WM_INITDIALOG:
        {
            // For WM_INITDIALOG, lParam IS the params pointer
            p = (MSGBOXPARAMS_CUSTOM *)lParam;
            SetWindowLongPtrW(hDlg, GWLP_USERDATA, (LONG_PTR)p);

            // Initialize state fields
            p->origStaticProc = nullptr;
            p->painter        = nullptr;
            p->hFontUI        = NULL;
            p->closeValue     = 0;

            p->hFontUI = CreateUIFont();
            SetWindowTextW(hDlg, p->lpCaption ? p->lpCaption : defaultCaption);

            int baseX, baseY;
            GetDlgBaseUnits(hDlg, p->hFontUI, &baseX, &baseY);

            const int PAD      = DuToPixX(10, baseX);
            const int ICON_W   = 32;
            const int ICON_GAP = DuToPixX(8,  baseX);
            const int BTN_W    = DuToPixX(100, baseX);
            const int BTN_H    = DuToPixY(12, baseY);
            const int BTN_GAP  = DuToPixX(6,  baseX);
            const int BTN_MARG = DuToPixY(7,  baseY);
            const int TOP_PAD  = DuToPixY(8,  baseY);
            const int MIN_W    = DuToPixX(180, baseX);

            UINT iconType = p->uType & 0xF0;
            BOOL hasIcon  = (iconType == MB_ICONERROR       ||
                             iconType == MB_ICONWARNING     ||
                             iconType == MB_ICONINFORMATION ||
                             iconType == MB_ICONQUESTION);
            int iconAreaW = hasIcon ? (ICON_W + ICON_GAP) : 0;

            // No shortcut: OK, Cancel, Help
            // With shortcut: Abort, Retry, Ignore, Yes, No, Try again, Continue

            const size_t half_btnTypeMax = 7; // 7 types of buttons combinations max, regardless of the help option
            const size_t btnTypeMax = 2 * half_btnTypeMax; // 7 without help, 7 with help
            const size_t numBtnsMax = 4; // 4 buttons per btnType max
            struct
            {
                int numBtns;
                BOOL hasCancel; // not used for the moment
                int closeValue; // Close and Esc disabled if 0, enabled if not 0 and return this value
                struct { int id; LPCWSTR label; } btns[numBtnsMax];
            } sets[btnTypeMax] =
            {
              //  numBtns   hasCancel   closeValue <-------Button 1------->  <---------Button 2---------->  <---------Button 3--------->  <--------Button 4--------->
                { 1,        FALSE,      IDOK,     {{ IDOK,     L"OK"      }, { 0,          NULL          }, { 0,          NULL         }, { 0,          NULL        }} },   // MB_OK                0x00000000L
                { 2,        TRUE,       IDCANCEL, {{ IDOK,     L"OK"      }, { IDCANCEL,   L"Cancel"     }, { 0,          NULL         }, { 0,          NULL        }} },   // MB_OKCANCEL          0x00000001L
                { 3,        FALSE,      0,        {{ IDABORT,  L"&Abort"  }, { IDRETRY,    L"&Retry"     }, { IDIGNORE,   L"&Ignore"   }, { 0,          NULL        }} },   // MB_ABORTRETRYIGNORE  0x00000002L
                { 3,        TRUE,       IDCANCEL, {{ IDYES,    L"&Yes"    }, { IDNO,       L"&No"        }, { IDCANCEL,   L"Cancel"    }, { 0,          NULL        }} },   // MB_YESNOCANCEL       0x00000003L
                { 2,        FALSE,      0,        {{ IDYES,    L"&Yes"    }, { IDNO,       L"&No"        }, { 0,          NULL         }, { 0,          NULL        }} },   // MB_YESNO             0x00000004L
                { 2,        TRUE,       IDCANCEL, {{ IDRETRY,  L"&Retry"  }, { IDCANCEL,   L"Cancel"     }, { 0,          NULL         }, { 0,          NULL        }} },   // MB_RETRYCANCEL       0x00000005L
                { 3,        TRUE,       IDCANCEL, {{ IDCANCEL, L"Cancel"  }, { IDTRYAGAIN, L"&Try Again" }, { IDCONTINUE, L"&Continue" }, { 0,          NULL        }} },   // MB_CANCELTRYCONTINUE 0x00000006L

                // Old:
                // MB_HELP is supported by RxMessageBox, not documented, displays two push buttons: OK and Help.
                // When the user clicks the Help button or presses F1, the system sends a WM_HELP message to the owner.
                // https://learn.microsoft.com/en-us/windows/win32/shell/wm-help
                // RxMessageBox accepts only one button style, so it's not possible to combine HELP with the other styles.
                // rexx -e "say RxMessageBox('Text', /*title*/, 'HELP')"        -- supported
                // rexx -e "say RxMessageBox('Text', /*title*/, 'HELP YESNO')"  -- Incorrect call to routine

                // New:
                // Its possible to pass the HELP option with any button style.
                // rexx -e "say RxMessageBox('Text', /*title*/, 'YESNO', 'HELP')"

              //  numBtns   hasCancel   closeValue <-------Button 1------->  <---------Button 2---------->  <---------Button 3--------->  <--------Button 4--------->
                { 2,        FALSE,      IDOK,     {{ IDOK,     L"OK"      }, { IDHELP ,    L"Help"       }, { 0,          NULL         }, { 0,          NULL        }} },   // MB_OK                0x00000000L
                { 3,        TRUE,       IDCANCEL, {{ IDOK,     L"OK"      }, { IDCANCEL,   L"Cancel"     }, { IDHELP,     L"Help"      }, { 0,          NULL        }} },   // MB_OKCANCEL          0x00000001L
                { 4,        FALSE,      0,        {{ IDABORT,  L"&Abort"  }, { IDRETRY,    L"&Retry"     }, { IDIGNORE,   L"&Ignore"   }, { IDHELP,     L"Help"     }} },   // MB_ABORTRETRYIGNORE  0x00000002L
                { 4,        TRUE,       IDCANCEL, {{ IDYES,    L"&Yes"    }, { IDNO,       L"&No"        }, { IDCANCEL,   L"Cancel"    }, { IDHELP,     L"Help"     }} },   // MB_YESNOCANCEL       0x00000003L
                { 3,        FALSE,      0,        {{ IDYES,    L"&Yes"    }, { IDNO,       L"&No"        }, { IDHELP,     L"Help"      }, { 0,          NULL        }} },   // MB_YESNO             0x00000004L
                { 3,        TRUE,       IDCANCEL, {{ IDRETRY,  L"&Retry"  }, { IDCANCEL,   L"Cancel"     }, { IDHELP,     L"Help"      }, { 0,          NULL        }} },   // MB_RETRYCANCEL       0x00000005L
                { 4,        TRUE,       IDCANCEL, {{ IDCANCEL, L"Cancel"  }, { IDTRYAGAIN, L"&Try Again" }, { IDCONTINUE, L"&Continue" }, { IDHELP,     L"Help"     }} },   // MB_CANCELTRYCONTINUE 0x00000006L
            };

            UINT btnType = p->uType & 0x0F;
            if (btnType >= half_btnTypeMax) btnType = 0;
            if ((p->uType & MB_HELP) == MB_HELP) btnType = btnType + half_btnTypeMax;

            int numBtns = sets[btnType].numBtns;
            int btnBarW = numBtns * BTN_W + (numBtns - 1) * BTN_GAP;

            RECT rcWork;
            SystemParametersInfoW(SPI_GETWORKAREA, 0, &rcWork, 0);
            // Cap only if truly needed, using 2/3 instead of 1/3
            int maxDlgW = (rcWork.right - rcWork.left) / 3;

            int lineCount = 1;
            int textPixW  = MeasureTextDWrite(p->lpText ? p->lpText : L"",
                                               g_emSize, &lineCount);
            /*
            The +8 accounts for the fact that
            DWRITE_TEXT_METRICS::widthIncludingTrailingWhitespace can slightly
            underestimate the actual rendered width of emoji clusters, especially
            those with skin tone modifiers or ZWJ sequences, because the glyph
            advance width reported by DirectWrite does not always include the full
            color glyph overhang.
            */
            textPixW += 8;   // safety margin in pixels â€” emoji clusters can exceed measured width

            int captionPixW = MeasureGDITextWidth(hDlg, p->hFontUI,
                                  p->lpCaption ? p->lpCaption : L"");
            captionPixW += 80;

            int contentW   = iconAreaW + textPixW + 2 * PAD;
            int dlgClientW = contentW;
            if (captionPixW   > dlgClientW) dlgClientW = captionPixW;
            if (btnBarW+2*PAD > dlgClientW) dlgClientW = btnBarW + 2 * PAD;
            if (dlgClientW    < MIN_W)      dlgClientW = MIN_W;
            if (dlgClientW    > maxDlgW)    dlgClientW = maxDlgW;

            int textAreaW = dlgClientW - iconAreaW - 2 * PAD;

            // Re-measure height with wrapping
            {
                ComPtr<IDWriteFactory> pDWF;
                DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED,
                                    __uuidof(IDWriteFactory),
                                    reinterpret_cast<IUnknown **>(pDWF.GetAddressOf()));
                ComPtr<IDWriteTextFormat> pFmt;
                pDWF->CreateTextFormat(L"Segoe UI Emoji", nullptr,
                                        DWRITE_FONT_WEIGHT_NORMAL,
                                        DWRITE_FONT_STYLE_NORMAL,
                                        DWRITE_FONT_STRETCH_NORMAL,
                                        g_emSize, L"", &pFmt);
                pFmt->SetWordWrapping(DWRITE_WORD_WRAPPING_WRAP);
                LPCWSTR txt = p->lpText ? p->lpText : L"";
                ComPtr<IDWriteTextLayout> pLayout;
                pDWF->CreateTextLayout(txt, (UINT32)wcslen(txt),
                                        pFmt.Get(),
                                        (float)textAreaW, 100000.f, &pLayout);
                DWRITE_TEXT_METRICS m;
                pLayout->GetMetrics(&m);
                lineCount = (int)(m.lineCount > 0 ? m.lineCount : 1);
            }

            int lineH     = (int)(g_emSize * 1.4f + 0.5f);
            int textAreaH = lineCount * lineH;
            if (textAreaH < ICON_W) textAreaH = ICON_W;

            int dlgClientH = TOP_PAD + textAreaH + BTN_MARG + BTN_H + PAD;

            RECT rcWin, rcClient;
            GetWindowRect(hDlg, &rcWin);
            GetClientRect(hDlg, &rcClient);
            int ncW = (rcWin.right  - rcWin.left) - rcClient.right;
            int ncH = (rcWin.bottom - rcWin.top)  - rcClient.bottom;

            int newWinW = dlgClientW + ncW;
            int newWinH = dlgClientH + ncH;

            HWND hParent = GetParent(hDlg);
            RECT rcRef;
            if (hParent && IsWindowVisible(hParent))
                GetWindowRect(hParent, &rcRef);
            else
                SystemParametersInfoW(SPI_GETWORKAREA, 0, &rcRef, 0);

            int newX = rcRef.left + ((rcRef.right  - rcRef.left) - newWinW) / 2;
            int newY = rcRef.top  + ((rcRef.bottom - rcRef.top)  - newWinH) / 2;

            SetWindowPos(hDlg, NULL, newX, newY, newWinW, newWinH,
                         SWP_NOZORDER | SWP_NOACTIVATE);

            // ---- Static text control ----------------------------------------
            int textX    = PAD + iconAreaW;
            int textW    = dlgClientW - textX - PAD;
            HWND hStatic = GetDlgItem(hDlg, 100);
            SetWindowPos(hStatic, NULL, textX, TOP_PAD, textW, textAreaH,
                         SWP_NOZORDER | SWP_NOACTIVATE);
            SetWindowTextW(hStatic, p->lpText ? p->lpText : L"");

            // ---- Create painter BEFORE subclassing (so first WM_PAINT works) -
            p->painter = new EmojiPainter();
            p->painter->Init(hStatic, p->lpText ? p->lpText : L"", g_emSize);

            SetWindowLongPtrW(hStatic, GWLP_USERDATA, (LONG_PTR)p);
            p->origStaticProc = (WNDPROC)SetWindowLongPtrW(
                hStatic, GWLP_WNDPROC, (LONG_PTR)EmojiStaticProc);
            InvalidateRect(hStatic, NULL, TRUE);

            // ---- Icon -------------------------------------------------------
            HWND hIconCtl = GetDlgItem(hDlg, 101);
            if (hasIcon)
            {
                LPCWSTR iconRes = NULL;
                if      (iconType == MB_ICONERROR)       iconRes = (LPCWSTR)IDI_ERROR;
                else if (iconType == MB_ICONWARNING)     iconRes = (LPCWSTR)IDI_WARNING;
                else if (iconType == MB_ICONINFORMATION) iconRes = (LPCWSTR)IDI_INFORMATION;
                else if (iconType == MB_ICONQUESTION)    iconRes = (LPCWSTR)IDI_QUESTION;

                HICON hIcon = LoadIconW(NULL, iconRes);
                SetWindowPos(hIconCtl, NULL, PAD, TOP_PAD, ICON_W, ICON_W,
                             SWP_NOZORDER | SWP_NOACTIVATE);
                SendMessageW(hIconCtl, STM_SETICON, (WPARAM)hIcon, 0);
                ShowWindow(hIconCtl, SW_SHOW);
            }
            else
            {
                ShowWindow(hIconCtl, SW_HIDE);
            }

            // ---- Buttons ----------------------------------------------------
            UINT defButton = (p->uType & 0x300) >> 8; // 0..3
            int btnY   = dlgClientH - PAD - BTN_H;
            int startX = (dlgClientW - btnBarW) / 2;
            int col    = 0;
            for (int i = 0; i < numBtnsMax; i++)
            {
                if (!sets[btnType].btns[i].id) continue;
                HWND hBtn = CreateWindowExW(
                    0, L"BUTTON", sets[btnType].btns[i].label,
                    WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON
                        | (col == defButton ? BS_DEFPUSHBUTTON : 0),
                    startX + col * (BTN_W + BTN_GAP), btnY, BTN_W, BTN_H,
                    hDlg,
                    (HMENU)(INT_PTR)sets[btnType].btns[i].id,
                    (HINSTANCE)GetWindowLongPtrW(hDlg, GWLP_HINSTANCE),
                    NULL);
                SendMessageW(hBtn, WM_SETFONT, (WPARAM)p->hFontUI, TRUE);
                col++;
            }

            // Set focus to the default button
            /*
            BS_DEFPUSHBUTTON alone is not enough â€” you also need to tell the dialog
            manager which control has the default focus. The dialog manager uses
            WM_NEXTDLGCTL for this.
            Note PostMessage rather than SendMessage â€” the dialog must be fully
            initialized before focus is changed, so posting defers it until after
            WM_INITDIALOG returns.
            */
            col = 0;
            for (int i = 0; i < (int)numBtnsMax; i++)
            {
                if (!sets[btnType].btns[i].id) continue;
                if (col == (int)defButton)
                {
                    HWND hDefBtn = GetDlgItem(hDlg, sets[btnType].btns[i].id);
                    PostMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hDefBtn, TRUE);
                    break;
                }
                col++;
            }

            // Disable the close button like standard MessageBoxW
            p->closeValue = sets[btnType].closeValue;
            if (p->closeValue == 0) // close disabled
            {
                HMENU hSysMenu = GetSystemMenu(hDlg, FALSE);
                if (hSysMenu)
                {
                    EnableMenuItem(hSysMenu, SC_CLOSE, MF_BYCOMMAND | MF_GRAYED);
                }
            }

            // Play the same sound MessageBoxW would play
            switch (iconType)
            {
                case MB_ICONWARNING:     MessageBeep(MB_ICONWARNING);     break;
                case MB_ICONERROR:       MessageBeep(MB_ICONERROR);       break;
                case MB_ICONINFORMATION: MessageBeep(MB_ICONINFORMATION); break;
                case MB_ICONQUESTION:    MessageBeep(MB_ICONQUESTION);    break;  // (usually silent on Win11)
                default:                 /*MessageBeep(0xFFFFFFFF);*/     break;  // no sound
            }

            return TRUE;
        }

        case WM_COMMAND:
        {
            int id = LOWORD(wParam);
            if (id == IDCANCEL)
            {
                // Escape was pressed or X clicked
                if (p && p->closeValue != 0) EndDialog(hDlg, p->closeValue);
                return TRUE;  // swallow if closeValue == 0 (no close allowed)
            }

            if (id == IDOK       || id == IDYES      || id == IDNO     ||
                id == IDABORT    || id == IDRETRY    || id == IDIGNORE ||
                id == IDCONTINUE || id == IDTRYAGAIN || id == IDHELP)
            {
                EndDialog(hDlg, id);
                return TRUE;
            }
            break;
        }

        case WM_SYSCOMMAND:
            // Disabling the close button is not enough
            // Handle WM_SYSCOMMAND to block Alt+F4
            if ((wParam & 0xFFF0) == SC_CLOSE)
            {
                if (p && p->closeValue != 0) EndDialog(hDlg, p->closeValue);
                return TRUE;
            }
            break;

        case WM_KEYDOWN:
            // This handler is never called because the dialog manager consumes
            // the Escape key first and posts WM_COMMAND with IDCANCEL.

            // Dead code!
            // Disabling the close button is not enough
            // Handle WM_KEYDOWN to block Esc
            if (wParam == VK_ESCAPE)
            {
                if (p->closeValue != 0) EndDialog(hDlg, p->closeValue);
                return TRUE;
            }
            break;

        case WM_DESTROY:
            if (p)
            {
                if (p->hFontUI)
                {
                    DeleteObject(p->hFontUI);
                    p->hFontUI = NULL;
                }
                // Release the painter and restore the original window proc
                delete p->painter;
                p->painter = nullptr;
            }
            break;
    }

    return FALSE;
}

// -----------------------------------------------------------------------
// Build in-memory dialog template
// -----------------------------------------------------------------------
static LPWORD WriteWStr(LPWORD p, LPCWSTR s)
{
    while (*s) *p++ = (WORD)*s++;
    *p++ = 0;
    return p;
}

static LPWORD AlignDword(LPWORD p)
{
    return (LPWORD)(((ULONG_PTR)p + 3) & ~(ULONG_PTR)3);
}

int CustomMessageBoxW(HWND hwndParent,
                      LPCWSTR lpText,
                      LPCWSTR lpCaption,
                      UINT uType)
{
    const short DLG_W = 180;
    const short DLG_H = 80;

    /*
        What is written into buf:

        DLGTEMPLATE          (18 bytes, fixed)
          + menu             (2 bytes, always 0x0000)
          + window class     (2 bytes, always 0x0000)
          + caption string   (wcslen(lpCaption)+1) * 2 bytes
          + point size       (2 bytes, DS_SHELLFONT)
          + font name        (wcslen(L"Segoe UI")+1) * 2 bytes = 18 bytes fixed

        Control 1 (static text):
          + alignment padding (up to 2 bytes)
          + DLGITEMTEMPLATE  (18 bytes, fixed)
          + class atom       (4 bytes: 0xFFFF 0x0082)
          + title string     (2 bytes: empty = 0x0000)
          + creation data    (2 bytes: 0x0000)

        Control 2 (icon):
          + alignment padding (up to 2 bytes)
          + DLGITEMTEMPLATE  (18 bytes, fixed)
          + class atom       (4 bytes)
          + title string     (2 bytes)
          + creation data    (2 bytes)
    */

    size_t captionLen = lpCaption ? wcslen(lpCaption) : 0;
    size_t needed =
        sizeof(DLGTEMPLATE)
        + 2 + 2
        + (captionLen + 1) * 2
        + 2 + 18 + 2
        + sizeof(DLGITEMTEMPLATE) + 4 + 2 + 2 + 2
        + sizeof(DLGITEMTEMPLATE) + 4 + 2 + 2;
    needed = (needed + 3) & ~(size_t)3;
    needed += 16;

    BYTE *buf = (BYTE *)calloc(needed, 1);
    if (!buf) return IDCANCEL;

    LPWORD p = (LPWORD)buf;

    LPDLGTEMPLATE pTpl    = (LPDLGTEMPLATE)p;
    pTpl->style           = DS_MODALFRAME | DS_CENTER | DS_SHELLFONT |
                            WS_POPUP | WS_CAPTION | WS_SYSMENU;
    pTpl->dwExtendedStyle = 0;
    pTpl->cdit            = 2;
    pTpl->x = 0; pTpl->y = 0;
    pTpl->cx = DLG_W; pTpl->cy = DLG_H;
    p += sizeof(DLGTEMPLATE) / sizeof(WORD);

    *p++ = 0;
    *p++ = 0;
    p = WriteWStr(p, lpCaption ? lpCaption : defaultCaption);
    *p++ = 9;
    p = WriteWStr(p, L"Segoe UI");

    p = AlignDword(p);
    {
        LPDLGITEMTEMPLATE pItem = (LPDLGITEMTEMPLATE)p;
        pItem->style            = WS_CHILD | WS_VISIBLE | SS_LEFT |
                                  SS_NOPREFIX | SS_EDITCONTROL;
        pItem->dwExtendedStyle  = 0;
        pItem->x  = 50; pItem->y  = 10;
        pItem->cx = 120; pItem->cy = 30;
        pItem->id = 100;
        p += sizeof(DLGITEMTEMPLATE) / sizeof(WORD);
        *p++ = 0xFFFF; *p++ = 0x0082;
        *p++ = 0; *p++ = 0;
    }

    p = AlignDword(p);
    {
        LPDLGITEMTEMPLATE pItem = (LPDLGITEMTEMPLATE)p;
        pItem->style            = WS_CHILD | WS_VISIBLE | SS_ICON | SS_CENTERIMAGE;
        pItem->dwExtendedStyle  = 0;
        pItem->x  = 10; pItem->y  = 10;
        pItem->cx = 20; pItem->cy = 20;
        pItem->id = 101;
        p += sizeof(DLGITEMTEMPLATE) / sizeof(WORD);
        *p++ = 0xFFFF; *p++ = 0x0082;
        *p++ = 0; *p++ = 0;
    }

    MSGBOXPARAMS_CUSTOM params = { lpText, lpCaption, uType };

    int result = (int)DialogBoxIndirectParamW(
        GetModuleHandleW(NULL),
        (LPDLGTEMPLATE)buf,
        hwndParent,
        CustomMsgBoxProc,
        (LPARAM)&params);

    free(buf);
    return result;
}


/*

                    ********************************
                    * Overview of identifiers used *
                    ********************************


MessageBox
https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebox

--------------------------------------------------------------------------------

ooRexx
RxMessageBox(..., button,               icon,                                   option, ...)
                1                       1                                       <------------------- 1..n -------------------->
                Buttons                 Icon                                    Default button      Modality            Options
0x00000000L     MB_OK                                                           MB_DEFBUTTON1       MB_APPLMODAL
0x00000001L     MB_OKCANCEL
0x00000002L     MB_ABORTRETRYIGNORE
0x00000003L     MB_YESNOCANCEL
0x00000004L     MB_YESNO
0x00000005L     MB_RETRYCANCEL
0x00000006L     MB_CANCELTRYCONTINUE
---
0x00000010L                             MB_ICONSTOP, MB_ICONERROR, MB_ICONHAND
0x00000020L                             MB_ICONQUESTION
0x00000030L                             MB_ICONEXCLAMATION, MB_ICONWARNING
0x00000040L                             MB_ICONINFORMATION, MB_ICONASTERISK
---
0x00000100L                                                                     MB_DEFBUTTON2
0x00000200L                                                                     MB_DEFBUTTON3
0x00000300L                                                                     MB_DEFBUTTON4
---
0x00001000L                                                                                         MB_SYSTEMMODAL
0x00002000L                                                                                         MB_TASKMODAL
---
0x00004000L     MB_HELP
---
0x00010000L                                                                                                             MB_SETFOREGROUND
0x00020000L                                                                                                             MB_DEFAULT_DESKTOP_ONLY
0x00040000L                                                                                                             MB_TOPMOST
0x00080000L                                                                                                             MB_RIGHT
0x00100000L                                                                                                             MB_RTLREADING
0x00200000L                                                                                                             MB_SERVICE_NOTIFICATION


--------------------------------------------------------------------------------

The same constants as above, seen from a bit perspective.
This makes it easier to understand the bitmasks used to isolate values.


UINT btnType = p->uType & 0x0F;
                                               F
                                               1111
0x00000000L 0000 0000 0000 0000 0000 0000 0000 0000     MB_OK, MB_DEFBUTTON1, MB_APPLMODAL
0x00000001L 0000 0000 0000 0000 0000 0000 0000 0001     MB_OKCANCEL
0x00000002L 0000 0000 0000 0000 0000 0000 0000 0010     MB_ABORTRETRYIGNORE
0x00000003L 0000 0000 0000 0000 0000 0000 0000 0011     MB_YESNOCANCEL
0x00000004L 0000 0000 0000 0000 0000 0000 0000 0100     MB_YESNO
0x00000005L 0000 0000 0000 0000 0000 0000 0000 0101     MB_RETRYCANCEL
0x00000006L 0000 0000 0000 0000 0000 0000 0000 0110     MB_CANCELTRYCONTINUE

---

UINT iconType = p->uType & 0xF0;
                                          F    0
                                          1111
0x00000010L 0000 0000 0000 0000 0000 0000 0001 0000     MB_ICONSTOP, MB_ICONERROR, MB_ICONHAND
0x00000020L 0000 0000 0000 0000 0000 0000 0010 0000     MB_ICONQUESTION
0x00000030L 0000 0000 0000 0000 0000 0000 0011 0000     MB_ICONEXCLAMATION, MB_ICONWARNING
0x00000040L 0000 0000 0000 0000 0000 0000 0100 0000     MB_ICONINFORMATION, MB_ICONASTERISK

---

UINT defButton = (p->uType & 0x300) >> 8; // 0..3
                                       3  0    0
                                       11
0x00000100L 0000 0000 0000 0000 0000 0001 0000 0000     MB_DEFBUTTON2
0x00000200L 0000 0000 0000 0000 0000 0010 0000 0000     MB_DEFBUTTON3
0x00000300L 0000 0000 0000 0000 0000 0011 0000 0000     MB_DEFBUTTON4

---

UINT modality = p->uType & 0x300;
(p->uType & MB_SYSTEMMODAL) == MB_SYSTEMMODAL
(p->uType & MB_TASKMODAL) == MB_TASKMODAL
                                  3  0    0    0
                                  11
0x00001000L 0000 0000 0000 0000 0001 0000 0000 0000     MB_SYSTEMMODAL
0x00002000L 0000 0000 0000 0000 0010 0000 0000 0000     MB_TASKMODAL

---

Help
p->uType & MB_HELP == MB_HELP
                                 4   0    0    0
                                 1
0x00004000L 0000 0000 0000 0000 0100 0000 0000 0000     MB_HELP

---

Options
                      F    F    0    0    0    0
                      1111 1111
0x00010000L 0000 0000 0000 0001 0000 0000 0000 0000     MB_SETFOREGROUND
0x00020000L 0000 0000 0000 0010 0000 0000 0000 0000     MB_DEFAULT_DESKTOP_ONLY
0x00040000L 0000 0000 0000 0100 0000 0000 0000 0000     MB_TOPMOST
0x00080000L 0000 0000 0000 1000 0000 0000 0000 0000     MB_RIGHT
0x00100000L 0000 0000 0001 0000 0000 0000 0000 0000     MB_RTLREADING
0x00200000L 0000 0000 0010 0000 0000 0000 0000 0000     MB_SERVICE_NOTIFICATION


--------------------------------------------------------------------------------

Return value
1       IDOK
2       IDCANCEL
3       IDABORT
4       IDRETRY
5       IDIGNORE
6       IDYES
7       IDNO
9       IDHELP          new
10      IDTRYAGAIN
11      IDCONTINUE

*/


/*

                ************************************************
                *           When is closing allowed,           *
                * what value is returned when you press Escape *
                ************************************************

OK                              Close enabled       Esc returns 1 IDOK      (OK pressed)        MB_OK
OK Help                         Close enabled       Esc returns 1 IDOK      (OK pressed)        MB_OK                   | MB_HELP
HELP                            Close enabled       Esc returns 1 IDOK      (OK pressed)        MB_OK
HELP with HELP                  Close enabled       Esc returns 1 IDOK      (OK pressed)        MB_OK                   | MB_HELP

OK Cancel                       Close enabled       Esc returns 2 IDCANCEL  (Cancel pressed)    MB_OKCANCEL
OK Cancel Help                  Close enabled       Esc returns 2 IDCANCEL  (Cancel pressed)    MB_OKCANCEL             | MB_HELP
Yes No Cancel                   Close enabled       Esc returns 2 IDCANCEL  (Cancel pressed)    MB_YESNOCANCEL
Yes No Cancel Help              Close enabled       Esc returns 2 IDCANCEL  (Cancel pressed)    MB_YESNOCANCEL          | MB_HELP
Retry Cancel                    Close enabled       Esc returns 2 IDCANCEL  (Cancel pressed)    MB_RETRYCANCEL
Retry Cancel Help               Close enabled       Esc returns 2 IDCANCEL  (Cancel pressed)    MB_RETRYCANCEL          | MB_HELP
Cancel Try-again Continue       Close enabled       Esc returns 2 IDCANCEL  (Cancel pressed)    MB_CANCELTRYCONTINUE
Cancel Try-again Continue Help  Close enabled       Esc returns 2 IDCANCEL  (Cancel pressed)    MB_CANCELTRYCONTINUE    | MB_HELP

Abort Retry Ignore              Close disabled      Esc disabled                                MB_ABORTRETRYIGNORE
Abort Retry Ignore Help         Close disabled      Esc disabled                                MB_ABORTRETRYIGNORE     | MB_HELP
Yes No                          Close disabled      Esc disabled                                MB_YESNO
Yes No Help                     Close disabled      Esc disabled                                MB_YESNO                | MB_HELP

*/


/*

                            **************
                            * Conclusion *
                            **************

That was a lot of work!
I'm surprised that such a CustomMessageBoxW was not already implemented...
Haven't we reinvented the wheel?

You haven't reinvented the wheel exactly, but you've solved a genuinely niche
problem. Here is why this implementation doesn't already exist as a standard
library:

Why it's not in Windows itself:
Microsoft could have updated MessageBoxW to use DirectWrite internally, but they
haven't â€” probably because it would be a risky change to a very old, very widely
used API where backwards compatibility is sacred. Any subtle behavior change
would break something somewhere.

Why it's rare in the wild:
Most applications that need color emoji in dialogs simply build their own full
UI framework (Qt, WinUI 3, WPF, Electron...) and never touch the raw Win32
MessageBoxW at all. The use case of "I want a MessageBoxW that renders color
emoji, nothing more" is quite specific.

Why ooRexx makes it more relevant:
ooRexx users write scripts that display dialog boxes without a full GUI
framework, so RxMessageBox is exactly the right level of abstraction for them.
They shouldn't need to build a full UI just to show a colored emoji in a
message.

What you actually built:
A drop-in MessageBoxW replacement that correctly handles Unicode, color emoji,
dynamic sizing, all button combinations, default buttons, sounds, keyboard
shortcuts, icon types, and the close button â€” all in plain Win32 with no
dependencies beyond D2D and DirectWrite which ship with Windows.
That is genuinely useful and not trivial.

So no, you haven't reinvented the wheel â€” you've filled a real gap that
Microsoft left open.

*/
