#!/usr/bin/rexx
/*
   name:             VALUE.testUnit
   author:           Lee Peedin
   date:             2007/12/14
   version:          1.0

-- line commented lines are ignored, when building the directory of infos from this header
   changed:

   languageLevel:    6.02
   purpose:          Test the VALUE BIF
   remark:           ---

   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

// category needs not to be numbered, importance is given by position (1=most important)
   category1:        ooRexx
   category2:        Base
   category3:        BIF

*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYright HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYright   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/

-------------------------------------------------------------------------------------------
   /* list of array objects, each containing the testUnit class object and an
      optional list of mandatory test case methods name                       */
    mandatoryTestMethods=.list~new   -- no mandatory tests for this testCase class
    testUnitList=.list~of(.array~of(.VALUE.testGroup, mandatoryTestMethods))

-------------------------------------------------------------------------------------------
-- ===> the following code needs not to be individualized                              <===

   -- read top comment, containing infos about this program
    arrLines=.array~new
    do i=1 to 150 until arrLines[i]="*/"
        arrLines[i]=sourceline(i)
    end
      -- supply information for the testClass(es) in this file; the class attribute
      -- "TestCaseInfo" (a directory object, index points to a queue) will store
      -- the parsed infos
    aTestUnitClass=testUnitList~at(testUnitList~first)[1] -- get first testClass

   -- will parse the array lines and store result in class object
    call makeDirTestInfo aTestUnitClass, arrLines
    tmpDir=aTestUnitClass~TestCaseInfo
    parse source s   -- op_sys invocationType fullPathToThisFile
    tmpDir~setentry("test_Case-source", s)
   -- now add this directory to other testCase classes, if any left
    do arr over testUnitList
        if arr[1]=aTestUnitClass then
            iterate  -- already handled
        arr[1]~TestCaseInfo=tmpDir             -- save info in class object
    end

-- if this file is CALLed or REQUIRED then define an entry "bRunTestLocally" in .local
-- and set it to .false; this way the independent local invocation of the tests is inhibited
    if .local~hasentry("bRunTestsLocally")=.false then
        .local~bRunTestsLocally=.true -- if this file is executed directly, then run tests for debugging

    if .bRunTestsLocally=.true then  -- run ALL tests in this test unit
        do
            ts=.testSuite~new             -- create a testSuite
            do arr over testUnitList
                -- create a testSuite for the given test case class, use all its testmethods
                ts~addTest( .testSuite~new(arr[1]))
            end
            -- testResult=.testSuite~new(testUnitClass)~run
            testResult=ts~run       -- now run all the tests

            call simpleFormatTestResults testResult
        end

   /* return list of array objects containing test case classes and
      optionally list of mandatory test methods                      */
return testUnitList

::requires ooRexxUnit.cls     -- load the ooRexxUnit classes

-- class named exactly like file
::class "VALUE.testGroup" subclass TestCase public

::method 'test000'
    .local~sl = 's.'
    .local~su = 'S.'
    .local~cl = 'c.a'
    .local~cu = 'C.A'
    .local~vl = 'war'
    .local~vu = 'WAR'
    .local~zl = 'lowercase garbage'
    .local~zu = 'UPPERCASE GARBAGE'

::method 'test001'
    self~expectSyntax(40.26)
    xre = value('')

::method 'test002'
    self~expectSyntax(40.26)
    xre = value('00'x)

::method 'test003'
    self~assertSame('subTest01','1',value('31'x))

::method 'test004'
    self~assertSame('subTest01','A',value('a'))

::method 'test005'
    self~assertSame('subTest01','A',value('A'))

::method 'test006'
    self~assertSame('subTest01','WAR',value(.vl))

::method 'test007'
    self~assertSame('subTest01','WAR',value(.vu))

::method 'test008'
    self~expectSyntax(40.26)
    xre = value(.zl)

::method 'test009'
    self~expectSyntax(40.26)
    xre = value(.zu)

::method 'test010'
    sl = 's.'
    su = 'S.'
    s. = 'stemmy'
    self~assertSame('subTest01','stemmy',value(.sl))

::method 'test011'
    sl = 's.'
    su = 'S.'
    s. = 'stemmy'
    self~assertSame('subTest01','stemmy',value(.su))

::method 'test012'
    cl = 'c.a'
    cu = 'C.A'
    c.a = 'compoundy'
    self~assertSame('subTest01','compoundy',value(cl))

::method 'test013'
    cl = 'c.a'
    cu = 'C.A'
    c.a = 'compoundy'
    self~assertSame('subTest01','compoundy',value(cu))

::method 'test014'
    sl = 's.'
    self~assertSame('subTest01','S.',value(sl))

::method 'test015'
    su = 'S.'
    self~assertSame('subTest01','S.',value(su))

::method 'test016'
    cl = 'c.a'
    self~assertSame('subTest01','C.A',value(cl))

::method 'test017'
    cu = 'C.A'
    self~assertSame('subTest01','C.A',value(cu))

::method 'test018'
    self~assertSame('subTest01','17',value(17))

::method 'test019'
    a = 'A'
    self~assertSame('subTest01','.A',value(.a))

::method 'test020'
    self~assertSame('subTest01','12E+17',value(12e+17))

::method 'test021'
    self~assertSame('subTest01','1.2E+18',value(+12e+17))

::method 'test022'
    self~expectSyntax(40.26)
    xre = value('+12e+17')

::method 'test023'
    self~expectSyntax(40.26)
    xre = value(-12e+17)

::method 'test024'
    self~assertSame('subTest01','0',value(0))
-- call ver value(0),'0'; R0078:

::method 'test025'
    self~assertSame('subTest01','1E9999999999999',value(1E9999999999999))

::method 'test026'
    self~assertSame('subTest01',copies('Y',240),value('YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY'))

::method 'test027'
    ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ = 'zb'
    self~assertSame('subTest01','zb',value('ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ'))

::method 'test028'
    self~assertSame('subTest01',copies('ZZ',120),value('ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ'))

::method 'test029'
    self~assertSame('subTest01',copies('YY',120),value(YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY))

::method 'test030'
    self~assertSame('subTest01',copies('ZZ',120),value('ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ'))

::method 'test031'
    self~assertSame('subTest01','AB',value('a'||'b'))
-- call ver value('a'||'b'),'AB'; R0094:

::method 'test032'
    ab = 'aabb'
    self~assertSame('subTest01','aabb',value('a'||'b'))

::method 'test033'
    a = ''
    b = 'B'
    c = '.'
    self~assertSame('subTest01','B',value(a||b))

::method 'test034'
    a = ''
    b = 'B'
    c = '.'
    self~assertSame('subTest01','.B',value(c||b))

::method 'test035'
    a = ''
    b = 'B'
    c = '.'
    self~assertSame('subTest01','B.',value(b||c))

::method 'test036'
    a = ''
    b = 'B'
    c = '.'
    self~assertSame('subTest01','B',value((A)(A)(B)))

::method 'test037'
    c. = '0'
    t1 = copies(1,200)
    V2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222 = ''
    self~assertSame('subTest01','0',value('c.t1.V2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222'))
-- call ver value('c.t1.V2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222'),'0'; R0113:

::method 'test038'
    VAR = 'vvvvv'
    self~assertSame('subTest01','VVVVV',value(value('VAR')))
-- call ver value(value('VAR')),'VVVVV'; R0118:

::method 'test039'
    self~assertSame('subTest01','ABCDE',value(xrange('A','E')))
-- call ver value(xrange('A','E')),'ABCDE'; R0120:

::method 'test040'
    self~assertSame('subTest01','ABCDEFGHIJKLMNOPQRSTUVWXYZ',value(xrange('A','Z')))
-- call ver value(xrange('A','Z')),'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; R0121:

::method 'test041'
    self~expectSyntax(43.1)
    xre = value('ABCXYZ'(17+4))

::method 'test042'
    BAD = 'bad data'
    LIT = 'lit data'
    self~assertSame('subTest01','21',value(value((17+4))))
-- call ver value(value((17+4))),'21'; R0127:

::method 'test043'
    stem. = 'V1'
    V1 = 'ABC'
    ABCABC = +23e5
    self~assertSame('subTest01','V1V1',value((stem.v)(stem.)))
-- call ver value((stem.v)(stem.)),'V1V1'; R0132:

::method 'test044'
    bvb = ' V '
    V = ''
    self~expectSyntax(40.26)
    xre = value(bvb)

::method 'test045'
    R.Pucher = 'xxx'
    Name = 'Pucher'
    self~assertSame('subTest01','xxx',value(R.Name))

::method 'test046'
    drop a.3
    j = 3
    j = 3
    i = 'i'
    j.i = 17
    jj = 'j.i'
    self~assertSame('subTest01',3,value('J'))
    self~assertSame('subTest01',3,value('j'))
    self~assertSame('subTest02',17,value(jj))
    self~assertSame('subTest03',17,value(j.i))
    self~assertSame('subTest04',3,value(J))
    self~assertSame('subTest05','A.3',value('a.j'))

::method 'test047'
    self~assertSame('subTest06',2,value(2))

::method 'test048'
    self~expectSyntax(40.26)
    xre = value('*')

::method 'test049'
    drop A3
    A33 = 7
    K = 3
    fred = 'K'

    self~assertSame('subTest01','A3',value('a'k))
    self~assertSame('subTest02',7,value('a'k||k))
    self~assertSame('subTest03','K',value('fred'))
    self~assertSame('subTest04','3',value(fred))

::method 'test050'
    .local~remove(sl)
    .local~remove(su)
    .local~remove(cl)
    .local~remove(cu)
    .local~remove(vl)
    .local~remove(vu)
    .local~remove(zl)
    .local~remove(zu)

::method 'test051'
    v = 17
    ln = copies('a',250)
    lz = copies('A',251)
    la = 'A b C'
    lb = 'AA'||'00'X||'BB'
    lc = 'AA'||'00'X||'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
    n = 'v'
    c = copies('*',100000)

    self~assertSame('subTest01',17,value(n))
    self~assertSame('subTest02',17,value(n,'abc'))
    self~assertSame('subTest03','abc',value(n))
    self~assertSame('subTest04','abc',value(n,'410042'x))
    self~assertSame('subTest05','410042'x,value(n))
    self~assertSame('subTest06',translate(ln),value(ln))
    self~assertSame('subTest07',translate(ln),value(ln,c))
    self~assertSame('subTest08',c,value(ln))




