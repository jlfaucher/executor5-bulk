#!/usr/bin/env rexx
/*
  SVN Revision: $Rev$
  Change Date:  $Date$
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007-2019 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/

  parse source . . s

  group = .TestGroup~new(s)
  group~add(.LINES.testGroup)

  if group~isAutomatedTest then return group

  suite = group~suite
  testResult = suite~execute
  testResult~print("Test of the LINES BIF")

return testResult
-- End of entry point.

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
  Directives, Classes, or Routines.
\* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
::requires 'ooTest.frm'
::requires "FileUtils.cls"

/* class: LINES.testGroup- - - - - - - - - - - - - - - - - - - - - - - - - - -*\

\* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
::class "LINES.testGroup" public subclass ooTestCase

/* disable test, as it fails if there's anything in the type-ahead buffer
  ::method test_stdin_normal

    -- Default stream is stdin, default for omitted second arg should be Normal
    self~assertSame(0, lines(), "Should be no lines available in stdin")

    self~assertSame(0, lines( , "Normal"), 'stdin empty "Normal" is valid')
    self~assertSame(0, lines( , "normal"), 'stdin empty "normal" is valid')
    self~assertSame(0, lines( , "nORmAl"), 'stdin empty "nORmAl" is valid')
    self~assertSame(0, lines( , "NORMAL"), 'stdin empty "NORMAL" is valid')
    self~assertSame(0, lines( , "NORMALLYLONGERTHANNEEDEDSHOULDBEVALID"), 'stdin empty "NORMALLYLONGERTHANNEEDEDSHOULDBEVALID" is valid')
    self~assertSame(0, lines( , "n"), 'stdin empty "n" is valid')
    self~assertSame(0, lines( , "N"), 'stdin empty "N" is valid')
    self~assertSame(0, lines( , "Nor"), 'stdin empty "Nor" is valid')
    self~assertSame(0, lines( , "NIGHTSHADE"), 'stdin empty "NIGHTSHADE" is valid')

    opt = 'n'
    self~assertSame(0, lines( , opt), 'stdin empty use a variable for the option is valid')

    opt = 'N' || 'uncool'~copies(5000)
    self~assertSame(0, lines( , opt), 'stdin empty extremely long string is valid')
*/

/* disable test, as it fails if there's anything in the type-ahead buffer
  ::method  test_stdin_count
    self~assertSame(0, lines(, "Count"), 'stdin empty "Count" is valid')
    self~assertSame(0, lines(, "count"), 'stdin empty "count" is valid')
    self~assertSame(0, lines(, "COUNT"), 'stdin empty "COUNT" is valid')
    self~assertSame(0, lines(, "cOuNt"), 'stdin empty "cOuNt" is valid')

    self~assertSame(0, lines(, "c"), 'stdin empty "c" is valid')
    self~assertSame(0, lines(, "C"), 'stdin empty "C" is valid')
    self~assertSame(0, lines(, "comic"), 'stdin empty "comic" is valid')

    opt = 'c'
    self~assertSame(0, lines(, opt), 'stdin empty use of a variable for "Count" is valid')

    opt = 'C' || "comedian"~copies(1000)
    self~assertSame(0, lines(, opt), 'stdin empty use of a long string for "Count" is valid')
*/

    ::method test_fileStream_normal

      -- Create a temp file with exactly 4 lines in it.
      fileName = createFile(.array~of(1, 2, 3, 4), "delMe_BIF_Lines4")

      -- Assert the file was created ok
      self~assertFalse(fileName == "", 'temp file must be created')

      self~assertSame(1, lines(fileName), 'file has lines, omitted 2nd arg should return 1')
      self~assertSame(1, lines(fileName, 'N'), 'file has lines, "N" for 2nd arg should return 1')
      self~assertSame(1, lines(fileName, 'Normal'), 'file has lines, "Normal" for 2nd arg should return 1')

      -- Read 2 lines, should get same results, because file still has lines.
      do 2
        discard = linein(fileName)
      end
      self~assertSame(1, lines(fileName), 'file has 2 lines, omitted 2nd arg should return 1')
      self~assertSame(1, lines(fileName, 'N'), 'file has 2 lines, "N" for 2nd arg should return 1')
      self~assertSame(1, lines(fileName, 'Normal'), 'file has 2 lines, "Normal" for 2nd arg should return 1')

      -- Read 2 lines, should get 0 for same tests.
      do 2
        discard = linein(fileName)
      end
      self~assertSame(0, lines(fileName), 'file has 0 lines, omitted 2nd arg should return 0')
      self~assertSame(0, lines(fileName, 'N'), 'file has 0 lines, "N" for 2nd arg should return 0')
      self~assertSame(0, lines(fileName, 'Normal'), 'file has 0 lines, "Normal" for 2nd arg should return 0')

      -- Be sure file is closed and delete it.
      j = lineout(fileName)
      j = deleteFile(fileName)


    ::method test_fileStream_count

      -- Create a temp file with exactly 64 lines in it.
      txt = .array~new
      do i = 1 to 64
        txt~append(i)
      end
      fileName = createFile(txt, "delMe_BIF_Lines64")
      self~assertFalse(fileName == "", 'temp file must be created')

      self~assertSame(64, lines(fileName, 'C'), 'file has 64 lines, 2nd arg "C" should return 64')
      self~assertSame(64, lines(fileName, 'c'), 'file has 64 lines, 2nd arg "c" should return 64')
      self~assertSame(64, lines(fileName, "count"), 'file has 64 lines, 2nd arg "count" should return 64')

      -- Read 4 lines, option of count should return 60
      do 4
        discard = linein(fileName)
      end
      self~assertSame(60, lines(fileName, 'C'), '60 lines left, 2nd arg "C" should return 60')
      self~assertSame(60, lines(fileName, 'c'), '60 lines left, 2nd arg "c" should return 60')
      self~assertSame(60, lines(fileName, "count"), '60 lines left, 2nd arg "count" should return 60')

      -- Read down to 0 lines, assert count is correct each time
      j = 60
      do i = 1 to 60
        self~assertSame(j, lines(fileName, 'C'), j 'lines left, count option should return' j)
        discard = linein(fileName)
        j -= 1
      end

      self~assertSame(0, lines(fileName, 'COUNT' ), '0 lines left COUNT option should return 0')

      -- Be sure file is closed and delete it.
      junk = lineout(fileName)
      junk = deleteFile(fileName)

    ::method test_normal_negativeTest1

      self~assertSame(0, lines('bogusZ2ls'), "Non-existent stream, default 2nd arg should return 0")
      self~assertSame(0, lines('b0sokdogusZ2ls', 'N'), "Non-existent stream, 'N' 2nd arg should return 0")
      self~assertSame(0, lines('bklwerj4ogusZ2ls', "NORMAL"), "Non-existent stream, 'NORMAL' 2nd arg should return 0")

/* disable assertion, as it fails if there's anything in the type-ahead buffer
      self~assertSame(0, lines('', "NORMAL"), "Non-existent stream, 'NORMAL' 2nd arg should return 0")
*/

    ::method test_count_negativeTest1

      self~assertSame(0, lines('bogusZ2ls', 'count'), "Non-existent stream, 'count' 2nd arg should return 0")
      self~assertSame(0, lines('b0sokdogusZ2ls', 'C'), "Non-existent stream, 'C' 2nd arg should return 0")
      self~assertSame(0, lines('bklwerj4ogusZ2ls', "cOUn"), "Non-existent stream, 'cOUn' 2nd arg should return 0")

/* disable assertion, as it fails if there's anything in the type-ahead buffer
      self~assertSame(0, lines('', "CCC"), "Non-existent stream, 'CCC' 2nd arg should return 0")
*/

    ::method test_normal_bytes

      -- Create a temp file with some lines.
      fileName = createFile(.array~of('dog', 'cat', 'lion', 'tiger'), "delMe_BIF_LinesBytes")
      self~assertFalse(fileName == "", 'temp file must be created')

      -- See how many bytes in size it is
      bytes = stream(fileName, "C", "QUERY SIZE")

      -- If we read in all the bytes, normal should return 0
      discard = charin(fileName, bytes)
      self~assertSame(0, lines(fileName), 'Read all bytes, 0 lines should remain')

      -- Delete the file and create another one for the next test.
      junk = lineout(fileName)
      junk = deleteFile(fileName)

      -- If we read all the bytes but the last new line chars, lines should
      -- return 1.
      fileName = createFile(.array~of('tom', 'frank', 'john', 'harry'), "delMe_BIF_LinesBytes2")
      self~assertFalse(fileName == "", 'temp file must be created')
      bytes = stream(fileName, "C", "QUERY SIZE")

      -- On Windows the last two chars are the new line chars, on unix-like,
      -- just 1 char.  On MAC it has always been only 1 char, although a
      -- different char on pre MAC OS X.
      if .ooRexxUnit.OSName~abbrev("WIN") then readBytes = bytes - 2
      else readBytes = bytes - 1

      discard = charin(fileName, readBytes)
      self~assertSame(1, lines(fileName), 'Read all bytes but last newline, 1 line should remain')

      -- Delete the file
      junk = lineout(fileName)
      junk = deleteFile(fileName)

    ::method test_count_bytes

      -- This is a repeat of test_normal_bytes, using count, and no comments.
      fileName = createFile(.array~of('dog', 'cat', 'lion', 'tiger'), "delMe_BIF_LinesCountB")
      self~assertFalse(fileName == "", 'temp file must be created')

      bytes = stream(fileName, "C", "QUERY SIZE")
      discard = charin(fileName, bytes)
      self~assertSame(0, lines(fileName, 'C'), 'Read all bytes, use "C" options, 0 lines should remain')

      junk = lineout(fileName)
      junk = deleteFile(fileName)
      fileName = createFile(.array~of('tom', 'frank', 'john', 'harry'), "delMe_BIF_LinesCount2")
      self~assertFalse(fileName == "", 'temp file must be created')
      bytes = stream(fileName, "C", "QUERY SIZE")

      if .ooRexxUnit.OSName~abbrev("WIN") then readBytes = bytes - 2
      else readBytes = bytes - 1

      discard = charin(fileName, readBytes)
      self~assertSame(1, lines(fileName), 'Read all bytes but last newline, "C" option, 1 line should remain')

      -- Delete the file
      junk = lineout(fileName)
      junk = deleteFile(fileName)

    /* The following all test bad syntax options */
    ::method test_bad_opt_stdin
      self~expectSyntax("40.904")
      j = lines(, "Tom")

    ::method test_bad_opt_noFile
      self~expectSyntax("40.904")
      j = lines('bogusFile', "Left")

    ::method test_bad_opt_goodFile
      self~expectSyntax("40.904")
      j = lines('LINES.testGroup', 0)

    ::method test_too_many_opt_goodFile
      self~expectSyntax("40.4")
      j = lines('LINES.testGroup', 'NORMAL', 'COUNT')

    ::method test_too_many_opt_stdin
      self~expectSyntax("40.4")
      j = lines(, 'NORMAL', 'COUNT')

    ::method test_way_too_many_opt_stdin
      self~expectSyntax("40.4")
      j = lines(, 'N', 'C', 1,2,2,3,4,5,6,7,8,9,0,'t','a','b','d')

    ::method test_bad_opt_stdin_nullString
      self~expectSyntax("40.904")
      j = lines(, "")

-- see also [bugs:#1663] CHARS/LINES BIFs inconsistent regarding NOTREADY
::method test_lines_notready_invalid
  signal on notready
  call lines "*"
  self~assertFail("LINES should raise NOTREADY")
  notready:
  self~assertSame("*", condition("additional"))

::method test_lines_notready_directory
  signal on notready
  call lines "/"
  self~assertFail("LINES should raise NOTREADY")
  notready:
  self~assertSame("/", condition("additional"))

::method test_lines_notready_nonexisting
  signal on notready
  call lines "non-existing-file"
  self~assertFail("LINES should raise NOTREADY")
  notready:
  self~assertSame("non-existing-file", condition("additional"))


::options novalue error
