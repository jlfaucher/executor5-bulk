#!/usr/bin/rexx
/*
  SVN Revision: $Rev$
  Change Date:  $Date$
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007-2017 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . fileSpec

  group = .TestGroup~new(fileSpec)
  group~add(.ControlledDo.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult
-- End of entry point.

::requires 'ooTest.frm' -- load the ooRexxUnit classes
::requires 'FileUtils.cls'

::class "ControlledDo.testGroup" subclass ooTestCase public
::method test_controlled_do

  steps = .array~new
  do i = 1 to 3
     steps~append(i)
  end i    -- test control variable also

  self~assertSameList((1, 2, 3), steps)
  self~assertEquals(4, i)

  steps = .array~new
  do i = 1 to 5 by 2
     steps~append(i)
  end

  self~assertSameList((1, 3, 5), steps)
  self~assertEquals(7, i)

  steps = .array~new
  do i = 5 to 1
     steps~append(i)
  end

  self~assertTrue(steps~isEmpty)
  self~assertEquals(5, i)

  steps = .array~new
  do i = 3 by -1 to 1
     steps~append(i)
  end

  self~assertSameList((3, 2, 1), steps)
  self~assertEquals(0, i)

  -- a negative BY value changes the termination test
  steps = .array~new
  do i = 1 by -1 to 3
     steps~append(i)
  end

  self~assertTrue(steps~isEmpty)
  self~assertEquals(1, i)

  steps = .array~new
  do label foo i = 1 to 1
     steps~append(i)
  end foo    -- test control variable also

  self~assertSameList(.array~of(1), steps)
  self~assertEquals(2, i)

  steps = .array~new
  do label foo i = 1 to 1 by -1
     steps~append(i)
  end foo    -- test control variable also

  self~assertSameList(.array~of(1), steps)
  self~assertEquals(0, i)

  steps = .array~new
  do label foo i = 1 to 3 for 2
     steps~append(i)
  end foo    -- test control variable also

  self~assertSameList((1, 2), steps)
  self~assertEquals(3, i)

  steps = .array~new
  do label foo i = 1 to 3 for 0
     steps~append(i)
  end foo    -- test control variable also

  self~assertTrue(steps~isEmpty)
  self~assertEquals(1, i)

  -- verify that test values are determined only once
  steps = .array~new
  toVal = 3
  byVal = 1
  forVal = 2

  do label foo i = 1 to toVal for forVal by byVal
     steps~append(i)
     toVal = 0
     byVal = -1
     forVal = 4
  end foo    -- test control variable also

  self~assertSameList((1, 2), steps)
  self~assertEquals(3, i)

  steps = .array~new

  do i = 1 while i < 3
     steps~append(i)
  end

  self~assertSameList((1, 2), steps)
  self~assertEquals(3, i)

  steps = .array~new

  do i = 1 until i = 2
     steps~append(i)
  end

  self~assertSameList((1, 2), steps)
  -- until test occurs before the control variable is steps
  self~assertEquals(2, i)

  steps = .array~new

  do i = 1 until i > 0
     steps~append(i)
  end

  -- always dos at least once with UNTIL
  self~assertSameList(.array~of(1), steps)
  -- until test occurs before the control variable is steps
  self~assertEquals(1, i)

  steps = .array~new

  do i = 1 while i < 1
     steps~append(i)
  end

  -- control variable set before while test, does not need to loop
  self~assertTrue(steps~isEmpty)
  -- until test occurs before the control variable is steps
  self~assertEquals(1, i)

  -- control variable only...steps starts from increment, steps by 1, no termination
  steps = .array~new

  do i = -.5
     steps~append(i)
     if i > 1 then leave i
  end

  -- control variable set before while test, does not need to loop
  self~assertSameList((-0.5, 0.5, 1.5), steps)
  -- until test occurs before the control variable is steps
  self~assertEquals(1.5, i)

  -- the symbol followed by "=" overrides the keyword nature of things.
  -- a couple of simple variations that prove this.

  steps = .array~new
  do label = 1 to 3
     steps~append(label)
  end label    -- test control variable also

  self~assertSameList((1, 2, 3), steps)

  steps = .array~new
  do forever = 1 to 3
     steps~append(forever)
  end forever    -- test control variable also

  self~assertSameList((1, 2, 3), steps)

  steps = .array~new
  do with = 1 to 3
     steps~append(with)
  end with    -- test control variable also

  self~assertSameList((1, 2, 3), steps)

  steps = .array~new
  do while = 1 to 3
     steps~append(while)
  end while   -- test control variable also

  self~assertSameList((1, 2, 3), steps)

  steps = .array~new
  do until = 1 to 3
     steps~append(until)
  end until   -- test control variable also

  self~assertSameList((1, 2, 3), steps)


::method test_dot_var
  self~assertSyntaxError(31.3, ("do . = 1", "end"))

::method test_num_var
  self~assertSyntaxError(31.2, ("do 1 = 1", "end"))

::method test_env_var
  self~assertSyntaxError(31.3, ("do .a = 1", "end"))

::method test_control_no_expr
  self~assertSyntaxError(35.904, ("do i =", "end"))

::method test_to_no_expr
  self~assertSyntaxError(35.906, ("do i = 1 to", "end"))

::method test_by_no_expr
  self~assertSyntaxError(35.905, ("do i = 1 by", "end"))

::method test_for_no_expr
  self~assertSyntaxError(35.907, ("do i = 1 for", "end"))

::method test_while_no_expr
  self~assertSyntaxError(35.929, ("do i = 1 while", "end"))

::method test_until_no_expr
  self~assertSyntaxError(35.929, ("do i = 1 until", "end"))

::method test_while_missing_expr1
  self~assertSyntaxError(35.929, ("do i = 1 while ,.true", "end"))

::method test_until_missing_expr1
  self~assertSyntaxError(35.929, ("do i = 1 until ,.false", "end"))

::method test_while_missing_expr2
  self~assertSyntaxError(35.929, ("do i = 1 while .true,,.true", "end"))

::method test_until_missing_expr2
  self~assertSyntaxError(35.929, ("do i = 1 until .false,,.false", "end"))

::method test_dup_for
  self~assertSyntaxError(27.902, ("do v = 1 for 3 for 4", "end"))

::method test_dup_to
  self~assertSyntaxError(27.902, ("do v = 1 to 3 to 4", "end"))

::method test_dup_by
  self~assertSyntaxError(27.902, ("do v = 1 by 3 by 4", "end"))

::method test_dup_while
  self~assertSyntaxError(27.1, ("do i = 1 while .true while .false", "end"))

::method test_dup_until
  self~assertSyntaxError(27.1, ("do i = 1 until .true until .false", "end"))

::method test_while_until
  self~assertSyntaxError(27.1, ("do i = 1 until .true while .false", "end"))

::method test_for_negative
  self~expectSyntax(26.3)
  do i = 1 for -1
  end

::method test_for_non_integer
  self~expectSyntax(26.3)
  do i = 1 for 1.1
  end

::method test_for_non_numeric
  self~expectSyntax(26.3)
  do i = 1 for 'a'
  end

::method test_to_non_numeric
  self~expectSyntax(41.1)
  do i = 1 to 'a'
  end

::method test_by_non_numeric
  self~expectSyntax(41.1)
  do i = 1 by 'a'
  end

::method test_control_non_numeric
  self~expectSyntax(41.1)
  do i = 'a'
  end

::method test_while_bad_truth
  self~expectSyntax(34.3)
  do i = 1 while 1.0
  end

::method test_until_bad_truth
  self~expectSyntax(34.4)
  do i = 1 until 1.0
  end

::method test_bad_assignment1
  self~assertSyntaxError(35.1, ("do i == 1", "end"))

::method test_bad_assignment2
  self~assertSyntaxError(35.1, ("do label == 1", "end"))

-- other keywords act as expression terminators for controlled dos.
-- this is a series of tests that verifies this for all keyword combinations.
::method test_no_control_expr1
  self~assertSyntaxError(35.904, ("do i = to", "end"))

::method test_no_control_expr2
  self~assertSyntaxError(35.904, ("do i = by", "end"))

::method test_no_control_expr3
  self~assertSyntaxError(35.904, ("do i = for", "end"))

::method test_no_control_expr4
  self~assertSyntaxError(35.904, ("do i = while", "end"))

::method test_no_control_expr5
  self~assertSyntaxError(35.904, ("do i = until", "end"))

::method test_to_no_expr1
  self~assertSyntaxError(35.906, ("do i = 1 to by", "end"))

::method test_to_no_expr2
  self~assertSyntaxError(35.906, ("do i = 1 to for", "end"))

::method test_to_no_expr3
  self~assertSyntaxError(35.906, ("do i = 1 to until", "end"))

::method test_to_no_expr4
  self~assertSyntaxError(35.906, ("do i = 1 to while", "end"))

::method test_to_no_expr5
  self~assertSyntaxError(35.906, ("do i = 1 to to", "end"))

::method test_by_no_expr1
  self~assertSyntaxError(35.905, ("do i = 1 by by", "end"))

::method test_by_no_expr2
  self~assertSyntaxError(35.905, ("do i = 1 by for", "end"))

::method test_by_no_expr3
  self~assertSyntaxError(35.905, ("do i = 1 by until", "end"))

::method test_by_no_expr4
  self~assertSyntaxError(35.905, ("do i = 1 by while", "end"))

::method test_by_no_expr5
  self~assertSyntaxError(35.905, ("do i = 1 by to", "end"))

::method test_for_no_expr1
  self~assertSyntaxError(35.907, ("do i = 1 for by", "end"))

::method test_for_no_expr2
  self~assertSyntaxError(35.907, ("do i = 1 for for", "end"))

::method test_for_no_expr3
  self~assertSyntaxError(35.907, ("do i = 1 for until", "end"))

::method test_for_no_expr4
  self~assertSyntaxError(35.907, ("do i = 1 for while", "end"))

::method test_for_no_expr5
  self~assertSyntaxError(35.907, ("do i = 1 for to", "end"))

-- while and until are only terminated by those keywords.

::method test_while_no_expr1
  self~assertSyntaxError(35.929, ("do i = 1 while until", "end"))

::method test_while_no_expr2
  self~assertSyntaxError(35.929, ("do i = 1 while while", "end"))

::method test_until_no_expr1
  self~assertSyntaxError(35.929, ("do i = 1 until until", "end"))

::method test_until_no_expr2
  self~assertSyntaxError(35.929, ("do i = 1 until while", "end"))

-- keyword parsing does not carry into subexpressions, so variables can be
-- sub keyword names if they are protected by expressions.  Check all of
-- the keywords against this
::method test_protected_keyword
  to = 1
  by = 0
  for = 0
  while = 0
  until = 0

  steps = .array~new
  do i = (to+by+for+while+until) to 2
     steps~append(i)
  end

  self~assertSameList((1,2), steps)

  steps = .array~new
  do i = 1 to (to+by+for+while+until+1)
     steps~append(i)
  end

  self~assertSameList((1,2), steps)

  steps = .array~new
  do i = 1 to 2 by (to+by+for+while+until)
     steps~append(i)
  end

  self~assertSameList((1,2), steps)

  steps = .array~new
  do i = 1 to 2 for (to+by+for+while+until+1)
     steps~append(i)
  end

  self~assertSameList((1,2), steps)

  steps = .array~new
  do i = 1 to 2 while (to+by+for+while+until)
     steps~append(i)
  end

  self~assertSameList((1,2), steps)

  steps = .array~new
  do i = 1 to 2 until \(to+by+for+while+until)
     steps~append(i)
  end

  self~assertSameList((1,2), steps)


-- test that the keywords are evaluated in the order they appear
::method test_keyword_order

  q = .queue~of(1, 3, 1, 2)

  steps = .array~new
  do i = q~pull to q~pull by q~pull for q~pull
     steps~append(i)
  end

  self~assertSameList((1,2), steps)

  q = .queue~of(1, 2, 1, 3)

  steps = .array~new
  do i = q~pull for q~pull by q~pull to q~pull
     steps~append(i)
  end

  self~assertSameList((1,2), steps)


::options novalue error
