#!/usr/bin/env rexx
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2022 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
parse source . . fileSpec
group = .TestGroup~new(fileSpec)
group~add(.REPLY.testGroup)
if group~isAutomatedTest then
  return group
else
  return group~suite~execute~~print

::requires 'ooTest.frm' -- load the ooRexxUnit classes

::class REPLY.testGroup subclass ooTestCase public

::method test_reply_routine
  self~expectSyntax(99.919) -- REPLY can only be issued in an object method invocation
  call r
  ::routine r
  reply

::method test_reply_procedure
  self~expectSyntax(99.919) -- REPLY can only be issued in an object method invocation
  call r
  r: procedure
  reply

::method test_reply_call
  self~expectSyntax(99.919) -- REPLY can only be issued in an object method invocation
  call r
  r: reply

::method test_reply_interpret
  self~expectSyntax(99.924) -- INTERPRET data must not contain REPLY
  interpret "reply"

-- 98.935 REPLY can be issued only once per method invocation
::method test_reply_twice_replyAssert -- special "replyAssert" handling
  reply
  signal on syntax
  reply
  self~assertFail("98.935 expected")
  return
  syntax:
  self~assertSame("98.935", condition("object")~code)

-- 98.936 RETURN cannot return a value after a REPLY
::method test_reply_return_code_replyAssert -- special "replyAssert" handling
  reply
  signal on syntax
  return 2 -- should raise 98.936
  self~assertFail("98.936 expected")
  syntax:
  self~assertSame("98.936", condition("object")~code)

-- 98.936 RETURN cannot return a value after a REPLY
::method test_reply_return_code_same_replyAssert -- special "replyAssert" handling
  reply .
  signal on syntax
  return . -- should raise 98.936
  self~assertFail("98.936 expected")
  syntax:
  self~assertSame("98.936", condition("object")~code)

-- 98.937 EXIT cannot return a value after a REPLY
::method test_reply_exit_code_replyAssert -- special "replyAssert" handling
  reply
  signal on syntax
  exit "" -- should raise 98.937
  self~assertFail("98.937 expected")
  syntax:
  self~assertSame("98.937", condition("object")~code)

-- after a REPLY the concurrent thread runs at the base of the call stack
::method test_reply_stack_replyAssert -- special "replyAssert" handling
  self~assertTrue(.context~stackframes~items > 1, "we expect more than one stackframe, found" .context~stackframes~items)
  reply
  self~assertSame(1, .context~stackframes~items, "we expect exactly one stackframe for a REPLY thread")

::method test_reply_plain
  reply

::method test_reply_string
  reply "string"

::method test_reply_array
  reply 1, ""

::method test_reply_nil
  reply .nil

::method test_reply_nop
  reply
  nop

::method test_reply__code_return
  reply .
  return

::method test_reply__code_exit
  reply 1
  exit

-- settings variables should not be reset
::method test_reply_same_replyAssert -- special "replyAssert" handling
  expose objectVariable
  self~assertSame(0, time("e"))
  numeric digits 11
  args = arg(1, "a")
  p = .context~package
  objectVariable = "object"
  localVariable = "local"
  reply .
  self~assertSame(11, digits())
  self~assertSame(p, .context~package)
  self~assertSame("object", objectVariable)
  self~assertSame("local", localVariable)
  self~assertSameList(arg(1, "a"), args)
  call SysSleep 0.01
  self~assertTrue(time("e") > 0, "time(e) must be > 0, found" time("e"))

-- the REPLY thread should run concurrently
::method test_reply_concurrent unguarded
  self~assertSame("started", self~read)
  -- wait until the REPLY thread has started filling the data array
  loop 10000 while self~data~items = 0
     call syssleep .1
  end
  -- at this point, the only thing we can reliably test for is > 0
  lines = self~data~items
  self~assertTrue(self~eof) -- guarded method will wait for EOF
  self~assertTrue(lines > 0, lines "should be greater than 0")

::attribute data unguarded
::attribute eof
::method read
  expose data eof
  eof = .false
  data = .Array~new
  reply "started"
  signal on notready
  parse source . . self
  s = .Stream~new(self)
  s~open("read shared")
  loop
    data~append(s~lineIn)
  end
  notready:
  eof = .true
  s~close


::options all syntax
