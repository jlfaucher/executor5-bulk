#!/usr/bin/rexx
/*
  SVN Revision: $Rev$
  Change Date:  $Date$
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . fileSpec

  group = .TestGroup~new(fileSpec)
  group~add(.Package.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult
-- End of entry point.

::requires 'ooTest.frm' -- load the ooRexxUnit classes
::requires "FileUtils.cls"


::class "Package.testGroup" subclass ooTestCase public

::method "test_New01"
  -- just load an empty package file
  -- create the requires file as a temporary file
  file = .TemporaryTestFile~new(self, "testPackage1.rex")
  -- this is just an empty file
  file~create("")

  package = .package~new("testPackage1.rex")

  self~assertTrue(package~isA(.package))
  self~assertEquals(file~fullName, package~name)
  self~assertSame(0, package~classes~items)
  self~assertSame(0, package~publicClasses~items)
  self~assertSame(0, package~routines~items)
  self~assertSame(0, package~publicRoutines~items)
  self~assertSame(0, package~definedmethods~items)
  self~assertSame(0, package~importedClasses~items)
  self~assertSame(0, package~importedRoutines~items)
  self~assertSame(0, package~importedPackages~items)
  self~assertSame(0, package~resources~items)
  self~assertSame(0, package~namespaces~items)
  self~assertSame(0, package~annotations~items)
  -- package settings are extensively tested in the ::options tests,
  -- but this is a good place to test the defaults
  self~assertSame(.rexxinfo~digits, package~digits)
  self~assertSame(.rexxinfo~fuzz, package~fuzz)
  self~assertSame(.rexxinfo~form, package~form)
  -- some source tests
  self~assertSame(1, package~sourceSize)
  self~assertSame("", package~sourceLine(1))

  self~assertSame('N', package~trace)


  file = .TemporaryTestFile~new(self, "testPackage2.rex")
  file~create(".local['TESTING'] = 1")

  -- make sure this entry is cleared
  .local~removeEntry('TESTING')

  -- verify the prolog runs when loaded from a file
  package = .package~new("testPackage2.rex")
  self~assertSame(1, .local['TESTING'])

  -- remove the entry again. Then run some code that requires this
  -- file.  It should not get updated this time.
  .local~removeEntry('TESTING')

  res = self~runDynamicSource(("return 123", "::requires 'testPackage2.rex'"))

  self~assertFalse(.local~hasEntry('TESTING'))

  -- this creates an in-memory package.  It is not available for ::requires usage
  package = .package~new("ROUTINETEST1", ("::routine test1 public", "return 1", "::method method1", "return 2"))

  -- however, we can use it in creating other executables as a parent package
  routine = .routine~new("testing", "return test1()", package)
  self~assertSame(1, routine~call)

  -- this also works using a method or a routine as the third argument
  routine = .routine~new("testing", "return test1()", package~routines~test1)
  self~assertSame(1, routine~call)

  routine = .routine~new("testing", "return test1()", package~definedMethods~method1)
  self~assertSame(1, routine~call)

  -- and a final test to show that the in-memory version is not in the
  -- package table

  self~assertSyntaxError(43.901, ("return test1()", "::requires 'ROUTINETEST1'"))

-- test memory retention of loaded package files
::method testReclaim01

  file = .TemporaryTestFile~new(self, "reclaimPackage.cls")
  file~create(("::routine test1 public", "  return 1"))

  -- this loads the package from a file and adds to the cache
  package = .package~new("reclaimPackage.cls")

  -- delete the file now so this can no longer be loaded from the file
  file~delete

  -- now create some code that references this...should be located in the cache
  routine = .routine~new("testing", ("return test1()", "::requires 'reclaimPackage.cls'"))

  self~assertSame(1, routine~call)

  -- wrap the orginal package in a weak reference
  package = .weakreference~new(package)
  -- drop the referencing routine
  drop routine

  -- now allocate a lot of storage in an attempt to force
  -- a garbage collection event
  i = 1
  loop until package~value == .nil
     loop 100
        x = copies('x', 1000000)
     end
     i += 1
  end

  self~expectSyntax('43.901')
  -- now create some more code that references the file...this should fail.
  routine = .routine~new("testing", ("return test1()", "::requires 'reclaimPackage.cls'"))
  routine~call

-- test creation of classes within a package
::method testClasses01

  package = .package~new("CLASSTEST1", ("::class class1", "::class class2 public"))

  classes = package~classes
  publicClasses = package~publicClasses
  self~assertSame(2, classes~items)
  self~assertTrue(classes['CLASS1']~isA(.class))
  self~assertTrue(classes['CLASS2']~isA(.class))
  self~assertSame(1, publicClasses~items, "Public classes")
  self~assertTrue(publicClasses['CLASS2']~isA(.class))
  self~assertSame(0, package~importedClasses~items)

-- test routines within a package
::method testRoutines01
  package = .package~new("ROUTINETEST2", ("::routine routine1", "::routine routine2 public"))

  routines = package~routines
  publicRoutines = package~publicRoutines
  self~assertSame(2, routines~items)
  self~assertTrue(routines['ROUTINE1']~isA(.routine))
  self~assertTrue(routines['ROUTINE2']~isA(.routine))
  self~assertSame(1, publicRoutines~items, "Public routines")
  self~assertTrue(publicRoutines['ROUTINE2']~isA(.routine))

  self~assertSame(0, package~importedRoutines~items)

::method testMethods01

  package = .package~new("METHODTEST1", ("::method method1", "::method method2", "::class test1", "::method method3"))

  methods = package~definedMethods
  self~assertSame(2, methods~items)
  self~assertTrue(methods['METHOD1']~isA(.method))
  self~assertTrue(methods['METHOD2']~isA(.method))


::method testImportedClasses01
  file = .TemporaryTestFile~new(self, "ImportedClassTest1.cls")
  file~create(("::class class1", "::class class2 public"))

  -- load this package from the file
  package = .package~new("ImportedClassTest1.cls")

  package2 = .package~new("importedtesting1", ("return 12", "::requires 'ImportedClassTest1.cls'"))

  classes = package2~importedclasses
  self~assertSame(1, classes~items)
  self~assertTrue(classes['CLASS2']~isA(.class))

  -- add the orginal package to this created one and test the imports
  package2 = .package~new("importedtesting3", "return 12")
  package2~addPackage(package)

  classes = package2~importedclasses
  self~assertSame(1, classes~items)
  self~assertTrue(classes['CLASS2']~isA(.class))

  self~assertSame(package, package2~importedPackages[1])

  -- now a package with no public classes
  file = .TemporaryTestFile~new(self, "ImportedClassTest2.cls")
  file~create(("::class class1", "::class class2"))

  -- load this package from the file
  package = .package~new("ImportedClassTest2.cls")

  package2 = .package~new("importedtesting2", ("return 12", "::requires 'ImportedClassTest2.cls'"))
  classes = package2~importedclasses
  self~assertSame(0, classes~items)

::method testImportedRoutines01
  file = .TemporaryTestFile~new(self, "ImportedRoutineTest1.cls")
  file~create(("::routine routine1", "::routine routine2 public"))

  -- load this package from the file
  package = .package~new("ImportedRoutineTest1.cls")

  package2 = .package~new("importedtesting1x", ("return 12", "::requires 'ImportedRoutineTest1.cls'"))

  routines = package~publicRoutines

  self~assertSame(1, routines~items)
  self~assertTrue(routines['ROUTINE2']~isA(.routine))

  package2 = .package~new("importedtesting3", "return 12")
  package2~addPackage(package)

  routines = package2~importedroutines
  self~assertSame(1, routines~items)
  self~assertTrue(routines['ROUTINE2']~isA(.routine))

  -- now a package with no public routines
  file = .TemporaryTestFile~new(self, "ImportedRoutineTest2.cls")
  file~create(("::routine routine1" , "::routine routine2"))
  package = .package~new("ImportedRoutineTest2.cls")

  package2 = .package~new("importedtesting2x", ("return 12", "::requires 'ImportedRoutineTest2.cls'"))
  routines = package2~importedroutines
  self~assertSame(0, routines~items)

  self~assertSame(package, package2~importedPackages[1])

::method TestSource01
  src = .array~new()
  src[1] = "::routine routine1"
  src[2] = "::routine routine2 public"

  package = .package~new("SOURCETEST1", src)

  self~assertSame(2, package~sourceSize)
  self~assertSame(src[1], package~sourceLine(1))
  self~assertSame(src[2], package~sourceLine(2))
  self~assertSame("", package~sourceLine(3))
  self~assertEquals(src, package~source)

::method TestAddRoutine01
  src = .array~new()
  src[1] = "::routine routine1"
  src[2] = "  return routine2()"

  package = .package~new("ADDROUTINETEST1", src)

  src = .array~new()
  src[1] = "  return 123"

  routine = .routine~new("TestingAddRoutine", src)

  package~addRoutine("ROUTINE2", routine)

  routines = package~routines
  self~assertSame(2, routines~items)
  self~assertSame(123, routines["ROUTINE1"]~call)
  self~assertSame(routine, package~findroutine("ROUTINE2"))

::method TestAddRoutine02
  src = .array~new()
  src[1] = "::routine routine1"
  src[2] = "  return routine2()"

  package = .package~new("ADDROUTINETEST2", src)

  self~expectSyntax('88.901')
  package~addRoutine

::method TestAddRoutine03
  src = .array~new()
  src[1] = "::routine routine1"
  src[2] = "  return routine2()"

  package = .package~new("ADDROUTINETEST3", src)

  self~expectSyntax('88.901')
  package~addRoutine("TESTING")

::method TestAddRoutine04
  src = .array~new()
  src[1] = "::routine routine1"
  src[2] = "  return routine2()"

  package = .package~new("ADDROUTINETEST4", src)

  self~expectSyntax('88.914')
  package~addRoutine("TESTING", .array)

::method TestAddPublicRoutine01
  src = .array~new()
  src[1] = "::routine routine1"
  src[2] = "  return routine2()"

  package = .package~new("ADDPUBLICROUTINETEST1", src)

  src = .array~new()
  src[1] = "  return 123"

  routine = .routine~new("TestingAddPublicRoutine", src)

  package~addPublicRoutine("ROUTINE2", routine)

  routines = package~routines
  self~assertSame(2, routines~items)
  publicRoutines = package~publicRoutines
  self~assertSame(1, publicRoutines~items)
  self~assertSame(123, routines["ROUTINE1"]~call)
  self~assertSame(routine, package~findroutine("ROUTINE2"))

::method TestAddPublicRoutine02
  src = .array~new()
  src[1] = "::routine routine1"
  src[2] = "  return routine2()"

  package = .package~new("ADDPUBLICROUTINETEST2", src)

  self~expectSyntax('88.901')
  package~addPublicRoutine

::method TestAddPublicRoutine03
  src = .array~new()
  src[1] = "::routine routine1"
  src[2] = "  return routine2()"

  package = .package~new("ADDPUBLICROUTINETEST3", src)

  self~expectSyntax('88.901')
  package~addPublicRoutine("TESTING")

::method TestAddPublicRoutine04
  src = .array~new()
  src[1] = "::routine routine1"
  src[2] = "  return routine2()"

  package = .package~new("ADDPUBLICROUTINETEST4", src)

  self~expectSyntax('88.914')
  package~addPublicRoutine("TESTING", .array)

::method TestAddClass01
  src = .array~new()
  src[1] = "::class class1"

  package = .package~new("ADDCLASSTEST1", src)

  class = .object~subclass("TEST2")

  package~addClass("TEST2", class)

  classes = package~classes
  self~assertSame(2, classes~items)
  self~assertSame(class, classes["TEST2"])
  self~assertSame(0, package~publicClasses~items)
  self~assertSame(class, package~findClass("TEST2"))
  -- should not be found as a public class
  self~assertSame(.nil, package~findPublicClass("TEST2"))
  -- test that find also locates the REXX-defined classes
  self~assertSame(.array, package~findClass("ARRAY"))
  self~assertSame(.array, package~findPublicClass("ARRAY"))

  -- now add a public class
  class = .object~subclass("TEST3")
  package~addPublicClass("TEST3", class)

  self~assertSame(class, package~findClass("TEST3"))
  -- should be found as a public class
  self~assertSame(class, package~findPublicClass("TEST3"))


::method TestAddClass02
  src = .array~new()
  src[1] = "::routine routine1"
  src[2] = "  return routine2()"

  package = .package~new("ADDCLASSTEST2", src)

  self~expectSyntax('88.901')
  package~addClass

::method TestAddClass03
  src = .array~new()
  src[1] = "::routine routine1"
  src[2] = "  return routine2()"

  package = .package~new("ADDCLASSEST3", src)

  self~expectSyntax('88.901')
  package~addClass("TESTING")

::method TestAddClass04
  src = .array~new()
  src[1] = "::routine routine1"
  src[2] = "  return routine2()"

  package = .package~new("ADDCLASSTEST4", src)

  self~expectSyntax('88.914')
  package~addClass("TESTING", "xyz")

::method TestAddPublicClass01
  src = .array~new()
  src[1] = "::class class1"

  package = .package~new("ADDPUBLICCLASSTEST1", src)

  class = .object~subclass("TEST2")

  package~addPublicClass("TEST2", class)

  classes = package~classes
  publicclasses = package~publicclasses

  self~assertSame(2, classes~items)
  self~assertSame(class, classes["TEST2"])
  self~assertSame(1, publicclasses~items)
  self~assertSame(class, publicclasses["TEST2"])
  self~assertSame(class, package~findClass("TEST2"))

::method TestAddPublicClass02
  src = .array~new()
  src[1] = "::routine routine1"
  src[2] = "  return routine2()"

  package = .package~new("ADDPUBLICCLASSTEST2", src)

  self~expectSyntax('88.901')
  package~addPublicClass

::method TestAddPublicClass03
  src = .array~new()
  src[1] = "::routine routine1"
  src[2] = "  return routine2()"

  package = .package~new("ADDPUBLICCLASSEST3", src)

  self~expectSyntax('88.901')
  package~addPublicClass("TESTING")

::method TestAddPublicClass04
  src = .array~new()
  src[1] = "::routine routine1"
  src[2] = "  return routine2()"

  package = .package~new("ADDPUBLICCLASSTEST4", src)

  self~expectSyntax('88.914')
  package~addPublicClass("TESTING", "xyz")

::method TestLoadLibrary01
  package = .context~package
  self~assertTrue(package~loadLibrary("rxmath"))
  self~assertSame(2, rxcalcsqrt(4))
  self~assertFalse(package~loadLibrary("invalid_library_name"))

::method TestLoadLibrary02
  self~expectSyntax('88.901')
  package = .context~package
  package~loadLibrary

::method TestLoadLibrary03
  self~expectSyntax('93.902')
  package = .context~package
  package~loadLibrary("a", "b")
