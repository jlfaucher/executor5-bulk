#!/usr/bin/rexx
/*
  SVN Revision: $Rev$
  Change Date:  $Date$
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007 - 2008 Rexx Language Association. All rights reserved.  */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . s

  group = .TestGroup~new(s)
  group~add(.Stream.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult
-- End of entry point.

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
  Directives, Classes, or Routines.
\* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
::requires 'ooTest.frm'
::requires 'FileUtils.cls'

/* class: Stream.testGroup - - - - - - - - - - - - - - - - - - - - - - - - - -*\

\* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
::class "Stream.testGroup" public subclass ooTestCase

::attribute streamTestingFile
::attribute extraTestingFile

::method setup
  self~streamTestingFile = .nil
  self~extraTestingFile = .nil

::method tearDown
  obj = self~streamTestingFile
  if obj \== .nil then do
    -- Close the file and delete it
    obj~close
    j = deleteFile(obj~qualify)
  end

  fileName = self~extraTestingFile
  if fileName \== .nil then do
    -- Close the file and delete it
    ret = lineout(fileName)
    j = deleteFile(fileName)
  end


::method test_open
  f = 'streamClassTest.delMe'

  obj = .stream~new(f)
  self~streamTestingFile = obj

  self~assertTrue(obj~isA(.Stream))

  ret = obj~open
  self~assertSame("READY:", ret)

  -- Close should return READY: on success (from docs.)
  ret = obj~close
  self~assertSame("READY:", ret)


::method test_simple_lineout

  f = 'streamClassTest.delMe'
  obj = .stream~new(f)
  self~streamTestingFile = obj
  self~assertTrue(obj~isA(.Stream))

  -- Write a single line, close the file, read the file, and compare.
  ret = obj~lineout("line 1")
  self~assertSame(0, ret)

  ret = obj~close
  self~assertSame("READY:", ret)

  -- Linein should reopen the file for us.
  line = obj~linein
  self~assertSame("line 1", line)


::method test_close_twice

  f = "streamCloseTest.delMe"
  obj = .stream~new(f)
  self~streamTestingFile = obj
  self~assertTrue(obj~isA(.Stream))

  -- Lineout should open the file and write the line.
  ret = obj~lineout('line 1')
  self~assertSame(0, ret)

  -- Close the file, return should be READY: and query state should be unknown
  ret = obj~close
  state = obj~state

  self~assertSame("READY:", ret)
  self~assertSame("UNKNOWN", state)

  -- Close it again. This time the return should be the empty string (docs.)
  ret = obj~close
  state = obj~state

  self~assertSame("", ret)
  self~assertSame("UNKNOWN", state)

-- Test new() Note that new() used normally gets heavily tested through out this
-- test group.  These tests are for abnormal use of new()
::method test_new_1

  fileName = directory()
  fsObj = .stream~new(fileName)
  self~assertTrue(fsObj~isA(.stream))

  name = fsObj~qualify
  self~assertSame(directory(), name)

::method test_new_2

  fileName = '00'x || '/' || '00'x
  fsObj = .stream~new(fileName)
  self~assertTrue(fsObj~isA(.stream))


::method test_new_syntax_1

  self~expectSyntax(93.901)
  fsObj = .stream~new()
  self~assertTrue(fsObj~isA(.stream))


::method test_new_syntax_2

  self~expectSyntax(93.902)
  fsObj = .stream~new("tempFile.txt", "binary")
  self~assertTrue(fsObj~isA(.stream))


-- Tests simple arrayin() method
::method test_arrayIn

  src = .array~new(12)
  do i = 1 to 12
    src[i] = 'line' i
  end
  fileName = createFile(src, "delMe.stream.arrayIn")
  self~assertTrue(fileName \== "")

  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  a = fsObj~arrayin
  self~assertTrue(a~isA(.array))
  self~assertSame(12, a~items)

  do i = 1 to 12
    self~assertSame("line" i, a[i])
  end


-- Tests simple arrayin(chars) method
::method test_arrayIn_chars

  fileName = "delMe.stream.arrayIn.chars"
  ret = stream(fileName, 'C', 'open write replace')
  do i = 97 to 122
    j = charout(fileName, i~d2c)
  end
  ret = stream(fileName, 'C', 'close')
  self~assertSame("READY:", ret)

  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  a = fsObj~arrayin("CHARS")
  self~assertTrue(a~isA(.array))
  self~assertSame(26, a~items)

  expected = 'abcdefghijklmnopqrstuvwxyz'
  do i = 1 to 26
    self~assertSame(expected~substr(i, 1), a[i])
  end

-- Tests arrayin abbreviating CHARS or LINES
::method test_arrayIn_abbrev

  fileName = "delMe.stream.arrayIn.s"
  ret = stream(fileName, 'C', 'open write replace')
  do i = 97 to 122
    j = charout(fileName, i~d2c)
  end
  ret = stream(fileName, 'C', 'close')
  self~assertSame("READY:", ret)

  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  a = fsObj~arrayin("C")
  self~assertTrue(a~isA(.array))
  self~assertSame(26, a~items)

  expected = 'abcdefghijklmnopqrstuvwxyz'
  do i = 1 to 26
    self~assertSame(expected~substr(i, 1), a[i])
  end

  fsObj~close
  fsObj~open

  a = fsObj~arrayin("c")
  self~assertTrue(a~isA(.array))
  self~assertSame(26, a~items)

  expected = 'abcdefghijklmnopqrstuvwxyz'
  do i = 1 to 26
    self~assertSame(expected~substr(i, 1), a[i])
  end

  fsObj~close
  fsObj~open

  a = fsObj~arrayin("L")
  self~assertTrue(a~isA(.array))
  self~assertSame(1, a~items)

  expected = 'abcdefghijklmnopqrstuvwxyz'
  self~assertSame(expected, a[1])

  fsObj~close
  fsObj~open

  a = fsObj~arrayin("l")
  self~assertTrue(a~isA(.array))
  self~assertSame(1, a~items)

  expected = 'abcdefghijklmnopqrstuvwxyz'
  self~assertSame(expected, a[1])

  fsObj~close
  fsObj~open

  a = fsObj~arrayin("lIN")
  self~assertTrue(a~isA(.array))
  self~assertSame(1, a~items)

  expected = 'abcdefghijklmnopqrstuvwxyz'
  self~assertSame(expected, a[1])


-- Tests arrayin() syntax
::method test_arrayIn_syntax01

  src = .array~new(12)
  do i = 1 to 12
    src[i] = 'line' i
  end
  fileName = createFile(src, "delMe.stream.syntax_01")
  self~assertTrue(fileName \== "")

  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  self~expectSyntax(93.0)
  a = fsObj~arrayin("words")


::method test_arrayIn_syntax02

  src = .array~new(12)
  do i = 1 to 12
    src[i] = 'line' i
  end
  fileName = createFile(src, "delMe.stream.syntax_02")
  self~assertTrue(fileName \== "")

  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  self~expectSyntax(93.902)
  a = fsObj~arrayin("LINES", "CHARS")


::method test_arrayIn_syntax03

  src = .array~new(12)
  do i = 1 to 12
    src[i] = 'line' i
  end
  fileName = createFile(src, "delMe.stream.syntax_03")
  self~assertTrue(fileName \== "")

  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  -- Omitted arg should be okay, omitted defaults to LINES.
  a = fsObj~arrayin( , )

  self~assertTrue(a~isA(.array))
  self~assertSame(12, a~items)

  do i = 1 to 12
    self~assertSame("line" i, a[i])
  end


::method test_arrayIn_syntax04

  src = .array~new(12)
  do i = 1 to 12
    src[i] = 'line' i
  end
  fileName = createFile(src, "delMe.stream.syntax_02")
  self~assertTrue(fileName \== "")

  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  self~expectSyntax(93.902)
  a = fsObj~arrayin( , "BYTES")


-- Tests arrayin() with empty file, created
::method test_arrayIn_1

  fileName = "delMe.stream.arrayIn_1"
  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  fsObj~open("write replace")
  a = fsObj~arrayin
  self~assertTrue(a~isA(.array))
  self~assertSame(0, a~items)
  self~assertSame(.nil, a[1])


-- Tests arrayin() with empty file, existing
::method test_arrayIn_2

  fileName = "delMe.stream.arrayIn_2"

  ret = charout(fileName, "")
  self~assertSame(0, ret)
  ret = stream(fileName, 'C', "close")
  self~assertSame("READY:", ret)

  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  a = fsObj~arrayin
  self~assertTrue(a~isA(.array))
  self~assertSame(0, a~items)
  self~assertSame(.nil, a[1])


-- Tests arrayin() after some lines have been read
::method test_arrayIn_3

  src = .array~new(12)
  do i = 1 to 12
    src[i] = 'line' i
  end
  fileName = createFile(src, "delMe.stream.arrayIn_4")
  self~assertTrue(fileName \== "")

  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj
  do 3
    discard = fsObj~linein()
  end

  a = fsObj~arrayin
  self~assertSame(9, a~items)

  do i = 4 to 12
    expected = "line" i
    j = i - 3
    self~assertSame(expected, a[j])
  end

  ret = fsObj~close
  self~assertSame("READY:", ret)

  ret = fsObj~seek("=6 read line")
  self~assertSame(6, ret)

  a = fsObj~arrayin
  self~assertSame(7, a~items)

  do i = 6 to 12
    expected = "line" i
    j = i - 5
    self~assertSame(expected, a[j])
  end

  ret = fsObj~close
  self~assertSame("READY:", ret)

  do 2
    fsObj~linein
  end
  ret = fsObj~charin( , 'lin'~length)
  self~assertSame('lin', ret)

  a = fsObj~arrayin
  self~assertSame(10, a~items)

  self~assertSame(src[3]~substr('lin'~length + 1), a[1])
  do i = 4 to 12
    expected = "line" i
    j = i - 2
    self~assertSame(expected, a[j])
  end


-- Tests simple arrayin() method, opened NOBUFFER
::method test_arrayIn_noBuf

  src = .array~new(12)
  do i = 1 to 12
    src[i] = 'line' i
  end
  fileName = createFile(src, "delMe.stream.arrayIn_noBuf")
  self~assertTrue(fileName \== "")

  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  fsObj~open("Both nobuffer")
  a = fsObj~arrayin
  self~assertTrue(a~isA(.array))
  self~assertSame(12, a~items)

  do i = 1 to 12
    self~assertSame("line" i, a[i])
  end


-- Tests arrayin() with empty file, created, opened NOBUFFER
::method test_arrayIn_1_noBuf

  fileName = "delMe.stream.arrayIn_1"
  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  fsObj~open("write replace nobuffer")
  a = fsObj~arrayin
  self~assertTrue(a~isA(.array))
  self~assertSame(0, a~items)
  self~assertSame(.nil, a[1])


-- Tests arrayin() with empty file, existing, opened NOBUFFER
::method test_arrayIn_2_noBuf

  fileName = "delMe.stream.arrayIn_2"
  ret = charout(fileName, "")
  self~assertSame(0, ret)
  ret = stream(fileName, 'C', "close")
  self~assertSame("READY:", ret)

  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  fsObj~open("both shared nobuffer")
  a = fsObj~arrayin
  self~assertTrue(a~isA(.array))
  self~assertSame(0, a~items)
  self~assertSame(.nil, a[1])


-- Tests arrayin() after some lines have been read, opened NOBUFFER
::method test_arrayIn_3_noBuf

  src = .array~new(12)
  do i = 1 to 12
    src[i] = 'line' i
  end
  fileName = createFile(src, "delMe.stream.arrayIn_4")
  self~assertTrue(fileName \== "")

  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  fsObj~open("read shared nobuffer")
  do 3
    discard = fsObj~linein()
  end

  a = fsObj~arrayin
  self~assertSame(9, a~items)

  do i = 4 to 12
    expected = "line" i
    j = i - 3
    self~assertSame(expected, a[j])
  end

  ret = fsObj~close
  self~assertSame("READY:", ret)

  fsObj~open("both shared nobuffer")
  ret = fsObj~seek("=6 read line")
  self~assertSame(6, ret)

  a = fsObj~arrayin
  self~assertSame(7, a~items)

  do i = 6 to 12
    expected = "line" i
    j = i - 5
    self~assertSame(expected, a[j])
  end

  ret = fsObj~close
  self~assertSame("READY:", ret)

  fsObj~open("nobuffer")
  do 2
    fsObj~linein
  end
  ret = fsObj~charin( , 'lin'~length)
  self~assertSame('lin', ret)

  a = fsObj~arrayin
  self~assertSame(10, a~items)

  self~assertSame(src[3]~substr('lin'~length + 1), a[1])
  do i = 4 to 12
    expected = "line" i
    j = i - 2
    self~assertSame(expected, a[j])
  end


-- Tests simple arrayin() method, opened BINARY
::method test_arrayIn_bin

  src = .array~new(12)
  do i = 1 to 12
    tag = i~right(2, 0)
    src[i] = 'line' tag
  end
  fileName = createFile(src, "delMe.stream.arrayIn_bin")
  self~assertTrue(fileName \== "")

  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  recLength = src[1]~length + .endOfLine~length + 2
  fsObj~open("Both BINARY RECLENGTH" recLength)
  a = fsObj~arrayin
  self~assertTrue(a~isA(.array))

  totalLen = (src[1]~length + .endOfLine~length) * 12
  expectedItems = (totalLen % recLength) + 1
  remainder = totalLen // recLength

  self~assertSame(expectedItems, a~items)

  expected = src[1] || .endOfLine || "li"
  self~assertSame(expected, a[1])

  expected = src[2]~substr(3) || .endOfLine || 'line'
  self~assertSame(expected, a[2])

  expected = src[3]~substr(5) || .endOfLine || 'line 0'
  self~assertSame(expected, a[3])

  -- Figure if the first 3 items in the array are correct, and the last item is
  -- correct - that is good enough.
  expected = (src[12] || .endOfLine)~right(remainder)
  self~assertSame(expected, a[expectedItems])


-- Tests arrayin() with empty file, created, opened BINARY
::method test_arrayIn_1_bin

  fileName = "delMe.stream.arrayIn_1"
  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  fsObj~open("write replace binary reclength 1")
  a = fsObj~arrayin
  self~assertTrue(a~isA(.array))
  self~assertSame(0, a~items)
  self~assertSame(.nil, a[1])


-- Tests arrayin() with empty file, existing, opened BINARY
::method test_arrayIn_2_bin

  fileName = "delMe.stream.arrayIn_2"
  ret = charout(fileName, "")
  self~assertSame(0, ret)
  ret = stream(fileName, 'C', "close")
  self~assertSame("READY:", ret)

  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  fsObj~open("both shared binary reclength 1")
  a = fsObj~arrayin
  self~assertTrue(a~isA(.array))
  self~assertSame(0, a~items)
  self~assertSame(.nil, a[1])


-- Tests arrayin() after some lines have been read, opened BINARY
::method test_arrayIn_3_bin

  src = .array~new(12)
  do i = 1 to 12
    src[i] = 'line' i~right(2, 0)
  end
  fileName = createFile(src, "delMe.stream.arrayIn_4")
  self~assertTrue(fileName \== "")

  fsObj = .stream~new(fileName)
  self~streamTestingFile = fsObj

  recLength = src[1]~length + .endOfLine~length
  fsObj~open("read shared binary reclength" recLength)
  do 3
    discard = fsObj~linein()
  end

  a = fsObj~arrayin
  self~assertSame(9, a~items)

  do i = 4 to 12
    expected = "line" i~right(2, 0) || .endOfLine
    j = i - 3
    self~assertSame(expected, a[j])
  end

  ret = fsObj~close
  self~assertSame("READY:", ret)

  fsObj~open("both shared binary reclength" recLength)
  ret = fsObj~seek("=6 read line")
  self~assertSame(6, ret)

  a = fsObj~arrayin
  self~assertSame(7, a~items)

  do i = 6 to 12
    expected = "line" i~right(2, 0) || .endOfLine
    j = i - 5
    self~assertSame(expected, a[j])
  end

  ret = fsObj~close
  self~assertSame("READY:", ret)

  fsObj~open("binary reclength" recLength)
  do 2
    fsObj~linein
  end
  ret = fsObj~charin( , 'lin'~length)
  self~assertSame('lin', ret)

  a = fsObj~arrayin
  self~assertSame(10, a~items)

  expected = src[3]~substr('lin'~length + 1) || .endOfLine
  self~assertSame(expected, a[1])

  do i = 4 to 12
    expected = "line" i~right(2, 0) || .endOfLine
    j = i - 2
    self~assertSame(expected, a[j])
  end


-- Regression test for a bug seen one time.
::method test_flush_on_close

  outFile = 'tmpOutDelMe.txt'
  rexxPrg = 'tmpPrg'
  self~extraTestingFile = rexxPrg || '.rex'

  src = .array~new
  src[1] = 'file = .stream~new("'outFile'")'
  src[2] = "file~lineout('first line') "
  src[3] = "file~lineout('second line')"

  rexxPrg = createRexxPrgFile(src, rexxPrg)
  self~assertNotSame('', rexxPrg)

  outPut = .array~new
  ret = execRexxPrg(rexxPrg, outPut)

  self~assertSame(0, ret)
  self~assertTrue(SysIsFile(outFile))

  fsObj = .stream~new(outFile)
  self~streamTestingFile = fsObj

  text = fsObj~arrayin
  self~assertSame('first line', text[1])
  self~assertSame('second line', text[2])


-- Regression test for bug  2776442
::method test_seek_usedAsCount_2776442

  fileName = createFile(.array~of(1, 2, 3, 4, 5, 6, 7, 8), "delMe.test_stream_seek")
  self~assertTrue(fileName \== "")

  -- The test case file for the original bug had a last line, without a new line
  -- at the end of the file.  To keep this test case as close to that as
  -- possible, we add a last line with no new line at the end of the file.
  ret = charout(fileName, "9")
  self~assertSame(0, ret)
  ret = stream(fileName, 'C', "close")
  self~assertSame("READY:", ret)

  f = .stream~new(fileName)
  self~streamTestingFile = f

  ret = f~open("READ SHAREREAD")
  self~assertSame("READY:", ret)

  ret = f~seek(+99999 "READ LINE")
  self~assertSame(9, ret)

  count = f~seek(-1 "READ LINE") + 1
  self~assertSame(9, count)

  secondCount = f~lines("COUNT")
  self~assertSame(2, secondCount)
  f~close


-- Regression test for bug  2772454
::method test_open_canWrite_2772454

  str = "1234567890"
  fileName = createFile(.array~of(str), "delMe.test_open_bug_2772454")
  self~assertTrue(fileName \== "")
  f = .stream~new(fileName)
  self~streamTestingFile = f

  ret = f~open
  self~assertSame("READY:", ret)

  ret = f~seek("1 read")
  self~assertSame(1, ret)

  bytes = f~charin( , f~chars)
  self~assertSame(str || .endOfLine, bytes)

  ret = f~seek("4 write")
  self~assertSame(4, ret)

  ret = f~charout("xyz")
  self~assertSame(0, ret)

  ret = f~seek("1 read")
  self~assertSame(1, ret)

  expected = str~overlay("xyz", 4) || .endOfLine

  bytes =  f~charin( , f~chars)
  self~assertSame(expected, bytes)


-- Regression test for bug  2721242
::method test_open_canWrite_2721242

  src = .array~new
  src[1] = "1234567890"
  do i = 2 to 12
    src[i] = src[1]
  end
  fileName = createFile(src, "delMe.test_streamObj_2721242")
  self~assertTrue(fileName \== "")

  f = .stream~new(fileName)
  self~streamTestingFile = f

  ret = f~open("READ")
  self~assertSame("READY:", ret)

  ret = f~Position("=100 READ CHAR")
  self~assertSame(100, ret)

  ret = f~Query("POSITION READ CHAR")
  self~assertSame(100, ret)


-- Regression test for bug  2790126
::method test_query_seek_long_2790126

  fileName = "delMe.test_stream_2790126"

  st = .stream~new(fileName)
  self~assertTrue(st~isA(.stream))
  self~streamTestingFile = st

  ret = st~open("write replace")
  self~assertSame("READY:", ret)

  ret = st~query("seek write")
  self~assertSame(1, ret)

  ret = st~charout(1~copies(4096))
  self~assertSame(0, ret)

  ret = st~query("seek write")
  self~assertSame(4097, ret)

  ret = st~charout(1~copies(8192))
  self~assertSame(0, ret)

  ret = st~query("seek write")
  say 'ret:' ret
  self~assertSame(12289, ret)


-- End of class: Stream.testGroup
