#!/usr/bin/rexx
/*
  SVN Revision: $Rev$
  Change Date:  $Date$
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007 - 2008 Rexx Language Association. All rights reserved.  */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . s

  group = .TestGroup~new(s)
  group~add(.Stream.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult
-- End of entry point.

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
  Directives, Classes, or Routines.
\* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
::requires 'ooTest.frm'
::requires 'FileUtils.cls'

/* class: Stream.testGroup - - - - - - - - - - - - - - - - - - - - - - - - - -*\

\* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
::class "Stream.testGroup" public subclass ooTestCase

::attribute streamTestingFile
::attribute extraTestingFile

::method setup
  self~streamTestingFile = .nil
  self~extraTestingFile = .nil

::method tearDown
  fileName = self~streamTestingFile
  if fileName \== .nil then do
    -- Close the file and delete it
    ret = lineout(fileName)
    j = deleteFile(fileName)
  end

  fileName = self~extraTestingFile
  if fileName \== .nil then do
    -- Close the file and delete it
    ret = lineout(fileName)
    j = deleteFile(fileName)
  end


::method test_open

  f = 'streamClassTest.delMe'
  self~streamTestingFile = f

  obj = .stream~new(f)
  self~assertTrue(obj~isA(.Stream))

  ret = obj~open
  self~assertSame("READY:", ret)

  -- We need to close the stream so we can delete the file.

  -- Close should return READY: on success (from docs.)
  ret = obj~close
  self~assertSame("READY:", ret)


::method test_simple_lineout

  f = 'streamClassTest.delMe'
  self~streamTestingFile = f

  obj = .stream~new(f)
  self~assertTrue(obj~isA(.Stream))

  -- Write a single line, close the file, read the file, and compare.
  ret = obj~lineout("line 1")
  self~assertSame(0, ret)

  ret = obj~close
  self~assertSame("READY:", ret)

  -- Linein should reopen the file for us.
  line = obj~linein
  self~assertSame("line 1", line)

  -- Need to close again so we can delete the file.
  ret = obj~close
  self~assertSame("READY:", ret)


::method test_close_twice

  f = "streamCloseTest.delMe"
  self~streamTestingFile = f

  obj = .stream~new(f)
  self~assertTrue(obj~isA(.Stream))

  -- Lineout should open the file and write the line.
  ret = obj~lineout('line 1')
  self~assertSame(0, ret)

  -- Close the file, return should be READY: and query state should be unknown
  ret = obj~close
  state = obj~state

  self~assertSame("READY:", ret)
  self~assertSame("UNKNOWN", state)

  -- Close it again. This time the return should be the empty string (docs.)
  ret = obj~close
  state = obj~state

  self~assertSame("", ret)
  self~assertSame("UNKNOWN", state)


::method test_flush_on_close

  outFile = 'tmpOutDelMe.txt'
  rexxPrg = 'tmpPrg'
  self~streamTestingFile = outFile
  self~extraTestingFile = rexxPrg || '.rex'

  src = .array~new
  src[1] = 'file = .stream~new("'outFile'")'
  src[2] = "file~lineout('first line') "
  src[3] = "file~lineout('second line')"

  rexxPrg = createRexxPrgFile(src, rexxPrg)
  self~assertNotSame('', rexxPrg)

  outPut = .array~new
  ret = execRexxPrg(rexxPrg, outPut)

  self~assertSame(0, ret)
  self~assertTrue(SysIsFile(outFile))

  fsObj = .stream~new(outFile)
  text = fsObj~arrayin
  self~assertSame('first line', text[1])
  self~assertSame('second line', text[2])

  fsObj~close


-- Regression test for bug  2776442
::method test_seek_usedAsCount_2776442

  fileName = createFile(.array~of(1, 2, 3, 4, 5, 6, 7, 8), "delMe.test_stream_seek")
  self~assertTrue(fileName \== "")
  self~streamTestingFile = fileName

  -- The test case file for the original bug had a last line, without a new line
  -- at the end of the file.  To keep this test case as close to that as
  -- possible, we add a last line with no new line at the end of the file.
  ret = charout(fileName, "9")
  self~assertSame(0, ret)
  ret = stream(fileName, 'C', "close")
  self~assertSame("READY:", ret)

  f = .stream~new(fileName)
  ret = f~open("READ SHAREREAD")
  self~assertSame("READY:", ret)

  ret = f~seek(+99999 "READ LINE")
  self~assertSame(9, ret)

  count = f~seek(-1 "READ LINE") + 1
  self~assertSame(9, count)

  secondCount = f~lines("COUNT")
  self~assertSame(2, secondCount)
  f~close


-- Regression test for bug  2772454
::method test_open_canWrite_2772454

  str = "1234567890"
  fileName = createFile(.array~of(str), "delMe.test_open_bug_2772454")
  self~assertTrue(fileName \== "")
  self~streamTestingFile = fileName

  f = .stream~new(fileName)
  ret = f~open
  self~assertSame("READY:", ret)

  ret = f~seek("1 read")
  self~assertSame(1, ret)

  bytes = f~charin( , f~chars)
  self~assertSame(str || .endOfLine, bytes)

  ret = f~seek("4 write")
  self~assertSame(4, ret)

  ret = f~charout("xyz")
  self~assertSame(0, ret)

  ret = f~seek("1 read")
  self~assertSame(1, ret)

  expected = str~overlay("xyz", 4) || .endOfLine

  bytes =  f~charin( , f~chars)
  self~assertSame(expected, bytes)

  f~close


-- Regression test for bug  2721242
::method test_open_canWrite_2721242

  src = .array~new
  src[1] = "1234567890"
  do i = 2 to 12
    src[i] = src[1]
  end
  fileName = createFile(src, "delMe.test_streamObj_2721242")
  self~assertTrue(fileName \== "")
  self~streamTestingFile = fileName

  f = .stream~new(fileName)
  ret = f~open("READ")
  self~assertSame("READY:", ret)

  ret = f~Position("=100 READ CHAR")
  self~assertSame(100, ret)

  ret = f~Query("POSITION READ CHAR")
  self~assertSame(100, ret)

  f~close


-- End of class: Stream.testGroup
