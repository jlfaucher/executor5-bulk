#!/usr/bin/rexx
/*
   name:             DateTime.testGroup
   author:           Lee Peedin
   date:             2007/10/08
   version:          1.0

-- line commented lines are ignored, when building the directory of infos from this header
   changed:

   languageLevel:    6.02
   purpose:          Test the methods of the class DateTime class.
   remark:           ---

   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

// category needs not to be numbered, importance is given by position (1=most important)
   category:         ooRexx
   category:         Base
   category:         Class
   category:         DateTime
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/

-------------------------------------------------------------------------------------------
   /* list of array objects, each containing the testGroup class object and an
      optional list of mandatory test case methods name                       */
mandatoryTestMethods=.list~new   -- no mandatory tests for this testCase class
testGroupList=.list~of( .array~of(.DateTime.testGroup,  mandatoryTestMethods) )


-------------------------------------------------------------------------------------------
-- ===> the following code needs not to be individualized                              <===

   -- read top comment, containing infos about this program
arrLines=.array~new
do i=1 to 150 until arrLines[i]="*/"
   arrLines[i]=sourceline(i)
end
      -- supply information for the testClass(es) in this file; the class attribute
      -- "TestCaseInfo" (a directory object, index points to a queue) will store
      -- the parsed infos
atestGroupClass=testGroupList~at(testGroupList~first)[1] -- get first testClass

   -- will parse the array lines and store result in class object
call makeDirTestInfo atestGroupClass, arrLines
tmpDir=atestGroupClass~TestCaseInfo
parse source s   -- op_sys invocationType fullPathToThisFile
tmpDir~setentry("test_Case-source", s)

   -- now add this directory to other testCase classes, if any left
do arr over testGroupList
   if arr[1]=atestGroupClass then iterate  -- already handled
   arr[1]~TestCaseInfo=tmpDir             -- save info in class object
end

-- if this file is CALLed or REQUIRED then define an entry "bRunTestLocally" in .local
-- and set it to .false; this way the independent local invocation of the tests is inhibited
if .local~hasentry("bRunTestsLocally")=.false then
   .local~bRunTestsLocally=.true -- if this file is executed directly, then run tests for debugging

if .bRunTestsLocally=.true then  -- run ALL tests in this test unit
do
   ts=.testSuite~new             -- create a testSuite
   do arr over testGroupList
      -- create a testSuite for the given test case class, use all its testmethods
      ts~addTest( .testSuite~new(arr[1]))
   end
   testResult=ts~run       -- now run all the tests

--   call simpleDumpTestResults testResult
    call simpleFormatTestResults testResult
end

   /* return list of array objects containing test case classes and
      optionally list of mandatory test methods                      */
return testGroupList

::requires ooRexxUnit.cls     -- load the ooRexxUnit classes

-- class named exactly like file
::class "DateTime.testGroup" subclass TestCase public

::method 'test_minDate'
    expected = '0001-01-01T00:00:00.000000'
    self~assertEquals('subTest1',expected,.datetime~minDate)

    expected = '0001-01-0100:00:00.000000'
    self~assertNotEquals('subTest2',expected,.datetime~minDate)

::method 'test_maxDate'
    expected = '9999-12-31T23:59:59.999999'
    self~assertEquals('subTest3',expected,.datetime~maxDate)

    expected = '9999-12-3123:59:59.999999'
    self~assertNotEquals('subTest4',expected,.datetime~maxDate)

::method 'test_today'
    todays = date('s')
    expected = todays~left(4)'-'todays~substr(5,2)'-'todays~right(2)'T00:00:00.000000'
    self~assertEquals('subTest5',expected,.datetime~today)

    todayb = date('b')
    yesterday = date('s',todayb-1,'b')
    expected = yesterday~left(4)'-'yesterday~substr(5,2)'-'yesterday~right(2)'T00:00:00.000000'
    self~assertNotEquals('subTest6',expected,.datetime~today)

::method 'test_fromNormalDate'
    a_normalDate1 = '8 Oct 2007'
    a_normalDate2 = '8-Oct-2007'
    a_normalDate3 = '8Oct2007'

    expected = '2007-10-08T00:00:00.000000'

    self~assertEquals('subTest7',expected,.datetime~fromNormalDate(a_normalDate1))
    self~assertEquals('subTest8',expected,.datetime~fromNormalDate(a_normalDate1,' '))

    self~assertEquals('subTest9',expected,.datetime~fromNormalDate(a_normalDate2,'-'))

    self~assertEquals('subTest10',expected,.datetime~fromNormalDate(a_normalDate3,''))

::method 'test_fromEuropeanDate'
    a_europeanDate1 = '08/10/07'
    a_europeanDate2 = '08-10-07'
    a_europeanDate3 = '081007'


    expected = '2007-10-08T00:00:00.000000'
    self~assertEquals('subTest11',expected,.datetime~fromEuropeanDate(a_europeanDate1))
    self~assertEquals('subTest12',expected,.datetime~fromEuropeanDate(a_europeanDate1,'/'))

    self~assertEquals('subTest13',expected,.datetime~fromEuropeanDate(a_europeanDate2,'-'))

    self~assertEquals('subTest14',expected,.datetime~fromEuropeanDate(a_europeanDate3,''))

::method 'test_fromOrderedDate'
    a_orderedDate1 = '07/10/08'
    a_orderedDate2 = '07-10-08'
    a_orderedDate3 = '071008'

    expected = '2007-10-08T00:00:00.000000'
    self~assertEquals('subTest15',expected,.datetime~fromOrderedDate(a_orderedDate1))
    self~assertEquals('subTest16',expected,.datetime~fromOrderedDate(a_orderedDate1,'/'))

    self~assertEquals('subTest17',expected,.datetime~fromOrderedDate(a_orderedDate2,'-'))

    self~assertEquals('subTest18',expected,.datetime~fromOrderedDate(a_orderedDate3,''))

::method 'test_fromStandardDate'
    a_standardDate1 = '20071008'
    a_standardDate2 = '2007-10-08'
    a_standardDate3 = '2007/10/08'

    expected = '2007-10-08T00:00:00.000000'
    self~assertEquals('subTest19',expected,.datetime~fromStandardDate(a_standardDate1))
    self~assertEquals('subTest20',expected,.datetime~fromStandardDate(a_standardDate1,''))

    self~assertEquals('subTest21',expected,.datetime~fromStandardDate(a_standardDate2,'-'))

    self~assertEquals('subTest22',expected,.datetime~fromStandardDate(a_standardDate3,'/'))

::method 'test_fromUsaDate'
    a_usaDate1 = '10/08/07'
    a_usaDate2 = '10-08-07'
    a_usaDate3 = '100807'

    expected = '2007-10-08T00:00:00.000000'
    self~assertEquals('subTest23',expected,.datetime~fromUsaDate(a_usaDate1))
    self~assertEquals('subTest24',expected,.datetime~fromUsaDate(a_usaDate1,'/'))

    self~assertEquals('subTest25',expected,.datetime~fromUsaDate(a_usaDate2,'-'))

    self~assertEquals('subTest26',expected,.datetime~fromUsaDate(a_usaDate3,''))

::method 'test_fromNormalTime'
    a_normalTime = '13:16:07'

    expected = '0001-01-01T13:16:07.000000'
    self~assertEquals('subTest27',expected,.datetime~fromNormalTime(a_normalTime))

::method 'test_fromCivilTime'
    a_civilTime1 = '1:16pm'
    a_civilTime2 = '1:16am'
    a_civilTime3 = '0:00am'
    a_civilTime4 = '11:59pm'

    expected = '0001-01-01T13:16:00.000000'
    self~assertEquals('subTest28',expected,.datetime~fromCivilTime(a_civilTime1))

    expected = '0001-01-01T01:16:00.000000'
    self~assertEquals('subTest28',expected,.datetime~fromCivilTime(a_civilTime2))

    expected = '0001-01-01T00:00:00.000000'
    self~assertEquals('subTest29',expected,.datetime~fromCivilTime(a_civilTime3))

    expected = '0001-01-01T23:59:00.000000'
    self~assertEquals('subTest30',expected,.datetime~fromCivilTime(a_civilTime4))

::method 'test_fromLongTime'
    a_longTime = '13:40:22.093000'

    expected = '0001-01-01T13:40:22.093000'
    self~assertEquals('subTest31',expected,.datetime~fromLongTime(a_longTime))

::method 'test_fromBaseDate'
    a_baseDate = 732956

    expected = '2007-10-08T00:00:00.000000'
    self~assertEquals('subTest32',expected,.datetime~fromBaseDate(a_baseDate))

::method 'test_fromTicks'
    a_ticksTime = '1191851246'

    expected = '2007-10-08T13:47:26.000000'
    self~assertEquals('subTest33',expected,.datetime~fromTicks(a_ticksTime))

::method 'test_fromIsoDate'
    a_isoDate = '2007-10-08T13:47:26.000000'

    expected = '2007-10-08T13:47:26.000000'
    self~assertEquals('subTest34',expected,.datetime~fromIsoDate(a_isoDate))

::method 'test_compareTo'
    a_dateTime1 = '2007-10-08T13:47:26.000000'
    a_dateTime2 = '2007-10-08T13:47:26.000000'
    a_dateTime3 = '2007-10-08T13:47:26.000001'

    expected = 0
    self~assertEquals('subTest34',expected,a_dateTime1~compareTo(a_dateTime2))

    expected = -1
    self~assertEquals('subTest35',expected,a_dateTime1~compareTo(a_dateTime3))

    expected = 1
    self~assertEquals('subTest36',expected,a_dateTime3~compareTo(a_dateTime1))

::method 'test_year_etc'
    a_dateTime = .dateTime~new(2007,10,8,13,10,5,123456)
    self~assertEquals('subTest37',2007,a_dateTime~year)
    self~assertEquals('subTest38',10,a_dateTime~month)
    self~assertEquals('subTest39',8,a_dateTime~day)
    self~assertEquals('subTest40',13,a_dateTime~hours)
    self~assertEquals('subTest41',10,a_dateTime~minutes)
    self~assertEquals('subTest42',5,a_dateTime~seconds)
    self~assertEquals('subTest43',123456,a_dateTime~microseconds)
    self~assertEquals('subTest44',790,a_dateTime~dayMinutes)
    self~assertEquals('subTest45',47405,a_dateTime~daySeconds)
    self~assertEquals('subTest46',47405123456,a_dateTime~dayMicroseconds)

::method 'test_hash'
    a_dateTime1 = .dateTime~new(2007,10,8,13,10,5,123456)

    a_dateTime2 = a_dateTime1~addDays(1)
    a_dateTime3 = a_dateTime1~addMinutes(1440)

    expected = .true
    self~assertEquals('subTest46a',expected,a_dateTime2~hashCode == a_dateTime3~hashCode)

::method 'test_adds'

    a_dateTime = .dateTime~new(2007,10,8,13,10,5,123456)

    expected = '2019-10-08T13:10:05.123456'
    self~assertEquals('subTest47',expected,a_dateTime~addYears(12))

    expected = '2007-10-15T13:10:05.123456'
    self~assertEquals('subTest48',expected,a_dateTime~addWeeks(1))

    expected = '2008-01-07T13:10:05.123456'
    self~assertEquals('subTest49',expected,a_dateTime~addWeeks(13))

    expected = '2007-12-31T13:10:05.123456'
    self~assertEquals('subTest50',expected,a_dateTime~addDays(84))

    expected = '2008-01-02T13:10:05.123456'
    self~assertEquals('subTest51',expected,a_dateTime~addDays(86))

    expected = '2007-10-08T23:10:05.123456'
    self~assertEquals('subTest52',expected,a_dateTime~addHours(10))

    expected = '2007-10-09T00:10:05.123456'
    self~assertEquals('subTest53',expected,a_dateTime~addHours(11))

    expected = '2007-10-08T13:59:05.123456'
    self~assertEquals('subTest54',expected,a_dateTime~addMinutes(49))

    expected = '2007-10-08T14:05:05.123456'
    self~assertEquals('subTest55',expected,a_dateTime~addMinutes(55))

    expected = '2007-10-08T13:10:59.123456'
    self~assertEquals('subTest56',expected,a_dateTime~addSeconds(54))

    expected = '2007-10-09T13:10:05.123456'
    self~assertEquals('subTest57',expected,a_dateTime~addSeconds(86400))  -- 1 whole day

    expected = '2007-10-08T13:10:05.777777'
    self~assertEquals('subTest58',expected,a_dateTime~addMicroSeconds(654321))

    expected = '2007-10-09T13:10:05.123456'
    self~assertEquals('subTest59',expected,a_dateTime~addMicroSeconds(86400000000))  -- 1 whole day

-- Not sure what isoDate is susposed to do

::method 'test_back2RexxDate'
    a_dateTime = .dateTime~new(2007,10,8)

    expected = 732956
    self~assertEquals('subTest60',expected,a_dateTime~baseDate)

    expected = 1
    self~assertEquals('subTest61',expected,a_dateTime~weekDay)

    expected = '08/10/07'
    self~assertEquals('subTest62',expected,a_dateTime~europeanDate)

-- skipping languageDate since it is language dependent

    expected = '8 Oct 2007'
    self~assertEquals('subTest63',expected,a_dateTime~normalDate)

    expected = '07/10/08'
    self~assertEquals('subTest64',expected,a_dateTime~orderedDate)

    expected = 20071008
    self~assertEquals('subTest65',expected,a_dateTime~standardDate)

    expected = '10/08/07'
    self~assertEquals('subTest66',expected,a_dateTime~usaDate)

::method 'test_back2RexxTime'
    a_dateTime = .dateTime~new(2007,10,8,13,10,5,123456)

    expected = '1:10pm'
    self~assertEquals('subTest67',expected,a_dateTime~civilTime)

    expected = '13:10:05'
    self~assertEquals('subTest68',expected,a_dateTime~normalTime)

    expected = 1191849005
    self~assertEquals('subTest69',expected,a_dateTime~ticks)

    expected = '2007-10-08T00:00:00.000000'
    self~assertEquals('subTest70',expected,a_dateTime~date)

::method 'test_neverHadBeFore'
    a_dateTime = .dateTime~new(2007,10,8,13,10,5,123456)

    expected = 281
    self~assertEquals('subTest71',expected,a_dateTime~yearDay)

    expected = 'October'
    self~assertEquals('subTest72',expected,a_dateTime~monthName)

    expected = '13:10:05.123456'
    self~assertEquals('subTest73',expected,a_dateTime~longTime)

    expected = 63327445805123456
    self~assertEquals('subTest74',expected,a_dateTime~fullDate)

    expected = '13:10:05.123456'
    self~assertEquals('subTest75',expected,a_dateTime~timeOfDay)

    expected = 0
    self~assertEquals('subTest76',expected,a_dateTime~isLeapYear)

    a_dateTime2 = .dateTime~new(2008,10,8,13,10,5,123456)
    expected = 1
    self~assertEquals('subTest77',expected,a_dateTime2~isLeapYear)

    expected = 31
    self~assertEquals('subTest78',expected,a_dateTime~daysInMonth)

    expected = '2007-10-08T13:10:05.123456'
    self~assertEquals('subTest79',expected,a_dateTime~string)

::method 'test_SyntaxBadDate1'
    expected = '88.907'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0000,00,0,13,10,5,123456)

::method 'test_SyntaxBadDate2'
    expected = '88.907'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,13,0,13,10,5,123456)

::method 'test_SyntaxBadDate3'
    expected = '40.19'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,9,31,13,10,5,123456)

::method 'test_SynTaxBadTime1'
    expected = '88.907'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,01,1,-1,0,0,0)

::method 'test_SynTaxBadTime2'
    expected = '88.907'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,01,1,0,60,0,0)

::method 'test_SynTaxBadTime3'
    expected = '88.907'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,01,1,0,0,60,0)

::method 'test_SynTaxBadTime4'
    expected = '88.907'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,01,1,0,0,0,-1)

::method 'test_SynTaxBadTime5'
    expected = '88.907'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,01,1,0,0,0,1234567)

::method 'test_BadArg1'
    expected = '93.903'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(,1,1,0,0,0,0)

::method 'test_BadArg2'
    expected = '93.903'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,,1,0,0,0,0)

::method 'test_BadArg3'
    expected = '93.903'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,1,,0,0,0,0)

::method 'test_BadArg4'
    expected = '93.903'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,1,1,,0,0,0)

::method 'test_BadArg5'
    expected = '93.903'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,1,1,0,,0,0)

::method 'test_BadArg6'
    expected = '93.903'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,1,1,0,0,,0)

::method 'test_InitA'
    a_dateTime  = .dateTime~new
    timeN       = time('n')
    todayS      = date('s')
    a_dateTimeS = a_dateTime~string

    -- Note: This test may fail is minute rolls over between execution of 1st 2 statements above
    expected = todayS~left(4)'-'todayS~substr(5,2)'-'todayS~right(2)'T'timeN~left(5)':'
    self~assertEquals('subTest80',expected,a_dateTimeS~left(17))

::method 'test_InitB'
    day = .dateTime~new(date('f','20070930','s'))
    expected = '2007-09-30T00:00:00.000000'
    self~assertEquals('subTest81',expected,day)

::method 'test_InitC'
    day = .dateTime~new(2007,9,30)
    expected = '2007-09-30T00:00:00.000000'
    self~assertEquals('subTest81',expected,day)

::method 'test_InitD'
    day = .dateTime~new(2007,9,30,10,33,00)
    expected = '2007-09-30T10:33:00.000000'
    self~assertEquals('subTest82',expected,day)

::method 'test_Comparison'
    d = .dateTime~new(2007,10,8,11,30,0)
    midnight = d~date
    startTime = midnight~addHours(9.5)
    endTime = startTime~addHours(8)
    expected = 1
    self~assertEquals('subTest83',expected,startTime <= d & d <= endTime)

::method 'test_daysInYear1'
    a_dt = .dateTime~new(2007,10,8)
    expected = 365
    self~assertEquals('subTest84',expected,a_dt~daysInYear)
    a_dt = .dateTime~new(1,1,1)
    self~assertEquals('Year 1 should have 365 days', 365, a_dt~daysInYear)
    a_dt = .dateTime~new(9999,11,13)
    self~assertEquals('Year 9999 should have 365 days', 365, a_dt~daysInYear)

    do i = 1 to 125
      a_dt = .dateTime~new(i,1,31)
      select
         when i == 100 then expected = 365
         when i // 4 == 0 then expected = 366
         otherwise expected = 365
      end
      self~assertEquals('Year' i 'should have' expected 'days', expected, a_dt~daysInYear)
    end

    do i = 9999 to 9888 by -1
      a_dt = .dateTime~new(i,12,31)
      select
         when i // 100  == 0 then expected = 365
         when i // 4 == 0 then expected = 366
         otherwise expected = 365
      end
      self~assertEquals('Year' i 'should have' expected 'days', expected, a_dt~daysInYear)
    end

::method 'test_daysInYear2'
    a_dt = .dateTime~new(2008,10,8)
    expected = 366
    self~assertEquals('subTest85',expected,a_dt~daysInYear)

::method 'test_elasped1'
    a_dt = .datetime~new
    call syssleep 1
    duration = a_dt~elapsed
    expected = 1
    self~assertEquals('subTest86',expected,duration~seconds)

::method 'test_FractionalAdds'
-- need additional tests for fractional add values - adding one now for an example
    a_dateTime = .dateTime~new(2007,10,8,13,0,0)
    expected = '2007-10-09T01:00:00.000000'
    self~assertEquals('subTest1000',expected,a_dateTime~addDays(.5))


