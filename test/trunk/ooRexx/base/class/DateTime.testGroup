#!/usr/bin/rexx
/*
   name:             DateTime.testGroup
   author:           Lee Peedin
   date:             2007/10/08
   version:          1.0

-- line commented lines are ignored, when building the directory of infos from this header
   changed:

   languageLevel:    6.02
   purpose:          Test the methods of the class DateTime class.
   remark:           ---

   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

// category needs not to be numbered, importance is given by position (1=most important)
   category:         ooRexx
   category:         Base
   category:         Class
   category:         DateTime
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . fileSpec

  group = .TestGroup~new(fileSpec)
  group~add(.DateTime.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult
-- End of entry point.

::requires 'ooTest.frm' -- load the ooRexxUnit classes

::class "DateTime.testGroup" subclass ooTestCase public

::method 'test_minDate'
    expected = '0001-01-01T00:00:00.000000'
    self~assertEquals(expected, .datetime~minDate)

    expected = '0001-01-0100:00:00.000000'
    self~assertNotEquals(expected, .datetime~minDate)

::method 'test_maxDate'
    expected = '9999-12-31T23:59:59.999999'
    self~assertEquals(expected, .datetime~maxDate)

    expected = '9999-12-3123:59:59.999999'
    self~assertNotEquals(expected, .datetime~maxDate)

::method 'test_today'
    todays = date('s')
    expected = todays~left(4)'-'todays~substr(5,2)'-'todays~right(2)'T00:00:00.000000'
    self~assertEquals(expected, .datetime~today)

    todayb = date('b')
    yesterday = date('s',todayb-1,'b')
    expected = yesterday~left(4)'-'yesterday~substr(5,2)'-'yesterday~right(2)'T00:00:00.000000'
    self~assertNotEquals(expected, .datetime~today)

::method 'test_fromNormalDate'
    a_normalDate1 = '8 Oct 2007'
    a_normalDate2 = '8-Oct-2007'
    a_normalDate3 = '8Oct2007'

    expected = '2007-10-08T00:00:00.000000'

    self~assertEquals(expected, .datetime~fromNormalDate(a_normalDate1))
    self~assertEquals(expected, .datetime~fromNormalDate(a_normalDate1,' '))

    self~assertEquals(expected, .datetime~fromNormalDate(a_normalDate2,'-'))

    self~assertEquals(expected, .datetime~fromNormalDate(a_normalDate3,''))

::method 'test_fromEuropeanDate'
    a_europeanDate1 = '08/10/07'
    a_europeanDate2 = '08-10-07'
    a_europeanDate3 = '081007'


    expected = '2007-10-08T00:00:00.000000'
    self~assertEquals(expected, .datetime~fromEuropeanDate(a_europeanDate1))
    self~assertEquals(expected, .datetime~fromEuropeanDate(a_europeanDate1,'/'))

    self~assertEquals(expected, .datetime~fromEuropeanDate(a_europeanDate2,'-'))

    self~assertEquals(expected, .datetime~fromEuropeanDate(a_europeanDate3,''))

::method 'test_fromOrderedDate'
    a_orderedDate1 = '07/10/08'
    a_orderedDate2 = '07-10-08'
    a_orderedDate3 = '071008'

    expected = '2007-10-08T00:00:00.000000'
    self~assertEquals(expected, .datetime~fromOrderedDate(a_orderedDate1))
    self~assertEquals(expected, .datetime~fromOrderedDate(a_orderedDate1,'/'))

    self~assertEquals(expected, .datetime~fromOrderedDate(a_orderedDate2,'-'))

    self~assertEquals(expected, .datetime~fromOrderedDate(a_orderedDate3,''))

::method 'test_fromStandardDate'
    a_standardDate1 = '20071008'
    a_standardDate2 = '2007-10-08'
    a_standardDate3 = '2007/10/08'

    expected = '2007-10-08T00:00:00.000000'
    self~assertEquals(expected, .datetime~fromStandardDate(a_standardDate1))
    self~assertEquals(expected, .datetime~fromStandardDate(a_standardDate1,''))

    self~assertEquals(expected, .datetime~fromStandardDate(a_standardDate2,'-'))

    self~assertEquals(expected, .datetime~fromStandardDate(a_standardDate3,'/'))

::method 'test_fromUsaDate'
    a_usaDate1 = '10/08/07'
    a_usaDate2 = '10-08-07'
    a_usaDate3 = '100807'

    expected = '2007-10-08T00:00:00.000000'
    self~assertEquals(expected, .datetime~fromUsaDate(a_usaDate1))
    self~assertEquals(expected, .datetime~fromUsaDate(a_usaDate1,'/'))

    self~assertEquals(expected, .datetime~fromUsaDate(a_usaDate2,'-'))

    self~assertEquals(expected, .datetime~fromUsaDate(a_usaDate3,''))

::method 'test_fromNormalTime'
    a_normalTime = '13:16:07'

    expected = '0001-01-01T13:16:07.000000'
    self~assertEquals(expected, .datetime~fromNormalTime(a_normalTime))

::method 'test_fromCivilTime'
    a_civilTime1 = '1:16pm'
    a_civilTime2 = '1:16am'
    a_civilTime3 = '0:00am'
    a_civilTime4 = '11:59pm'

    expected = '0001-01-01T13:16:00.000000'
    self~assertEquals(expected, .datetime~fromCivilTime(a_civilTime1))

    expected = '0001-01-01T01:16:00.000000'
    self~assertEquals(expected, .datetime~fromCivilTime(a_civilTime2))

    expected = '0001-01-01T00:00:00.000000'
    self~assertEquals(expected, .datetime~fromCivilTime(a_civilTime3))

    expected = '0001-01-01T23:59:00.000000'
    self~assertEquals(expected, .datetime~fromCivilTime(a_civilTime4))

::method 'test_fromLongTime'
    a_longTime = '13:40:22.093000'

    expected = '0001-01-01T13:40:22.093000'
    self~assertEquals(expected, .datetime~fromLongTime(a_longTime))

::method 'test_fromBaseDate'
    a_baseDate = 732956

    expected = '2007-10-08T00:00:00.000000'
    self~assertEquals(expected, .datetime~fromBaseDate(a_baseDate))

::method 'test_fromTicks'
    a_ticksTime = '1191851246'

    expected = '2007-10-08T13:47:26.000000'
    self~assertEquals(expected, .datetime~fromTicks(a_ticksTime))

::method 'test_fromIsoDate'
    a_isoDate = '2007-10-08T13:47:26.000000'

    expected = '2007-10-08T13:47:26.000000'
    self~assertEquals(expected, .datetime~fromIsoDate(a_isoDate))

::method 'test_compareTo'
    a_dateTime1 = '2007-10-08T13:47:26.000000'
    a_dateTime2 = '2007-10-08T13:47:26.000000'
    a_dateTime3 = '2007-10-08T13:47:26.000001'

    expected = 0
    self~assertEquals(expected, a_dateTime1~compareTo(a_dateTime2))

    expected = -1
    self~assertEquals(expected, a_dateTime1~compareTo(a_dateTime3))

    expected = 1
    self~assertEquals(expected, a_dateTime3~compareTo(a_dateTime1))

::method 'test_year_etc'
    a_dateTime = .dateTime~new(2007,10,8,13,10,5,123456)
    self~assertEquals(2007, a_dateTime~year)
    self~assertEquals(10, a_dateTime~month)
    self~assertEquals(8, a_dateTime~day)
    self~assertEquals(13, a_dateTime~hours)
    self~assertEquals(10, a_dateTime~minutes)
    self~assertEquals(5, a_dateTime~seconds)
    self~assertEquals(123456, a_dateTime~microseconds)
    self~assertEquals(790, a_dateTime~dayMinutes)
    self~assertEquals(47405, a_dateTime~daySeconds)
    self~assertEquals(47405123456, a_dateTime~dayMicroseconds)

::method 'test_hash'
    a_dateTime1 = .dateTime~new(2007,10,8,13,10,5,123456)

    a_dateTime2 = a_dateTime1~addDays(1)
    a_dateTime3 = a_dateTime1~addMinutes(1440)

    expected = .true
    self~assertEquals(expected, a_dateTime2~hashCode == a_dateTime3~hashCode)

::method 'test_adds'

    a_dateTime = .dateTime~new(2007,10,8,13,10,5,123456)

    expected = '2019-10-08T13:10:05.123456'
    self~assertEquals(expected, a_dateTime~addYears(12))

    expected = '2007-10-15T13:10:05.123456'
    self~assertEquals(expected, a_dateTime~addWeeks(1))

    expected = '2008-01-07T13:10:05.123456'
    self~assertEquals(expected, a_dateTime~addWeeks(13))

    expected = '2007-12-31T13:10:05.123456'
    self~assertEquals(expected, a_dateTime~addDays(84))

    expected = '2008-01-02T13:10:05.123456'
    self~assertEquals(expected, a_dateTime~addDays(86))

    expected = '2007-10-08T23:10:05.123456'
    self~assertEquals(expected, a_dateTime~addHours(10))

    expected = '2007-10-09T00:10:05.123456'
    self~assertEquals(expected, a_dateTime~addHours(11))

    expected = '2007-10-08T13:59:05.123456'
    self~assertEquals(expected, a_dateTime~addMinutes(49))

    expected = '2007-10-08T14:05:05.123456'
    self~assertEquals(expected, a_dateTime~addMinutes(55))

    expected = '2007-10-08T13:10:59.123456'
    self~assertEquals(expected, a_dateTime~addSeconds(54))

    expected = '2007-10-09T13:10:05.123456'
    self~assertEquals(expected, a_dateTime~addSeconds(86400))  -- 1 whole day

    expected = '2007-10-08T13:10:05.777777'
    self~assertEquals(expected, a_dateTime~addMicroSeconds(654321))

    expected = '2007-10-09T13:10:05.123456'
    self~assertEquals(expected, a_dateTime~addMicroSeconds(86400000000))  -- 1 whole day

-- Not sure what isoDate is susposed to do

::method 'test_back2RexxDate'
    a_dateTime = .dateTime~new(2007,10,8)

    expected = 732956
    self~assertEquals(expected, a_dateTime~baseDate)

    expected = 1
    self~assertEquals(expected, a_dateTime~weekDay)

    expected = '08/10/07'
    self~assertEquals(expected, a_dateTime~europeanDate)

-- skipping languageDate since it is language dependent

    expected = '8 Oct 2007'
    self~assertEquals(expected, a_dateTime~normalDate)

    expected = '07/10/08'
    self~assertEquals(expected, a_dateTime~orderedDate)

    expected = 20071008
    self~assertEquals(expected, a_dateTime~standardDate)

    expected = '10/08/07'
    self~assertEquals(expected, a_dateTime~usaDate)

::method 'test_back2RexxTime'
    a_dateTime = .dateTime~new(2007,10,8,13,10,5,123456)

    expected = '1:10pm'
    self~assertEquals(expected, a_dateTime~civilTime)

    expected = '13:10:05'
    self~assertEquals(expected, a_dateTime~normalTime)

    expected = 1191849005
    self~assertEquals(expected, a_dateTime~ticks)

    expected = '2007-10-08T00:00:00.000000'
    self~assertEquals(expected, a_dateTime~date)

::method 'test_neverHadBeFore'
    a_dateTime = .dateTime~new(2007,10,8,13,10,5,123456)

    expected = 281
    self~assertEquals(expected, a_dateTime~yearDay)

    expected = 'October'
    self~assertEquals(expected, a_dateTime~monthName)

    expected = '13:10:05.123456'
    self~assertEquals(expected, a_dateTime~longTime)

    expected = 63327445805123456
    self~assertEquals(expected, a_dateTime~fullDate)

    expected = '13:10:05.123456'
    self~assertEquals(expected, a_dateTime~timeOfDay)

    expected = 0
    self~assertEquals(expected, a_dateTime~isLeapYear)

    a_dateTime2 = .dateTime~new(2008,10,8,13,10,5,123456)
    expected = 1
    self~assertEquals(expected, a_dateTime2~isLeapYear)

    expected = 31
    self~assertEquals(expected, a_dateTime~daysInMonth)

    expected = '2007-10-08T13:10:05.123456'
    self~assertEquals(expected, a_dateTime~string)

::method 'test_SyntaxBadDate1'
    expected = '88.907'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0000,00,0,13,10,5,123456)

::method 'test_SyntaxBadDate2'
    expected = '88.907'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,13,0,13,10,5,123456)

::method 'test_SyntaxBadDate3'
    expected = '40.19'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,9,31,13,10,5,123456)

::method 'test_SynTaxBadTime1'
    expected = '88.907'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,01,1,-1,0,0,0)

::method 'test_SynTaxBadTime2'
    expected = '88.907'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,01,1,0,60,0,0)

::method 'test_SynTaxBadTime3'
    expected = '88.907'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,01,1,0,0,60,0)

::method 'test_SynTaxBadTime4'
    expected = '88.907'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,01,1,0,0,0,-1)

::method 'test_SynTaxBadTime5'
    expected = '88.907'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,01,1,0,0,0,1234567)

::method 'test_BadArg1'
    expected = '93.903'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(,1,1,0,0,0,0)

::method 'test_BadArg2'
    expected = '93.903'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,,1,0,0,0,0)

::method 'test_BadArg3'
    expected = '93.903'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,1,,0,0,0,0)

::method 'test_BadArg4'
    expected = '93.903'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,1,1,,0,0,0)

::method 'test_BadArg5'
    expected = '93.903'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,1,1,0,,0,0)

::method 'test_BadArg6'
    expected = '93.903'
    self~expectSyntax(expected)
    a_dateTime = .dateTime~new(0001,1,1,0,0,,0)

::method 'test_InitA'
    a_dateTime  = .dateTime~new
    timeN       = time('n')
    todayS      = date('s')
    a_dateTimeS = a_dateTime~string

    -- Note: This test may fail is minute rolls over between execution of 1st 2 statements above
    expected = todayS~left(4)'-'todayS~substr(5,2)'-'todayS~right(2)'T'timeN~left(5)':'
    self~assertEquals(expected, a_dateTimeS~left(17))

::method 'test_InitB'
    day = .dateTime~new(date('f','20070930','s'))
    expected = '2007-09-30T00:00:00.000000'
    self~assertEquals(expected, day)

::method 'test_InitC'
    day = .dateTime~new(2007,9,30)
    expected = '2007-09-30T00:00:00.000000'
    self~assertEquals(expected, day)

::method 'test_InitD'
    day = .dateTime~new(2007,9,30,10,33,00)
    expected = '2007-09-30T10:33:00.000000'
    self~assertEquals(expected, day)

::method 'test_Comparison'
    d = .dateTime~new(2007,10,8,11,30,0)
    midnight = d~date
    startTime = midnight~addHours(9.5)
    endTime = startTime~addHours(8)
    expected = 1
    self~assertEquals(expected, startTime <= d & d <= endTime)

::method 'test_daysInYear1'
    a_dt = .dateTime~new(2007,10,8)
    expected = 365
    self~assertEquals(expected, a_dt~daysInYear)
    a_dt = .dateTime~new(1,1,1)
    self~assertEquals(365, a_dt~daysInYear, 'Year 1 should have 365 days')
    a_dt = .dateTime~new(9999,11,13)
    self~assertEquals(365, a_dt~daysInYear, 'Year 9999 should have 365 days')

    do i = 1 to 125
      a_dt = .dateTime~new(i,1,31)
      select
         when i == 100 then expected = 365
         when i // 4 == 0 then expected = 366
         otherwise expected = 365
      end
      self~assertEquals(expected, a_dt~daysInYear, 'Year' i 'should have' expected 'days')
    end

    do i = 9999 to 9888 by -1
      a_dt = .dateTime~new(i,12,31)
      select
         when i // 100  == 0 then expected = 365
         when i // 4 == 0 then expected = 366
         otherwise expected = 365
      end
      self~assertEquals(expected, a_dt~daysInYear, 'Year' i 'should have' expected 'days')
    end

::method 'test_daysInYear2'
    a_dt = .dateTime~new(2008,10,8)
    expected = 366
    self~assertEquals(expected, a_dt~daysInYear)

::method 'test_elasped1'
    a_dt = .datetime~new
    call syssleep 1
    duration = a_dt~elapsed
    expected = 1
    self~assertEquals(expected, duration~seconds)

::method 'test_FractionalAdds'
-- need additional tests for fractional add values - adding one now for an example
    a_dateTime = .dateTime~new(2007,10,8,13,0,0)
    expected = '2007-10-09T01:00:00.000000'
    self~assertEquals(expected, a_dateTime~addDays(.5))


