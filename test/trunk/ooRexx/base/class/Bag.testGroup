#!/usr/bin/rexx
/*
  SVN Revision: $Rev$
  Change Date:  $Date$
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007-2017 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . s

  group = .TestGroup~new(s)
  group~add(.Bag.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult
-- End of entry point.

::requires 'ooTest.frm' -- load the ooRexxUnit classes

::class "Bag.testGroup" subclass ooTestCase public

::method init
  expose collDir clz bUserDefinedIndex bSingleItem o1 o2
  forward class (super) continue    -- let superclass initialize

  clz=.Bag                        -- collection class object to use
  bUserDefinedIndex=.true           -- user defined index? (determines what MAKEARRAY returns)
  bSingleItem      =.false          -- index associates only one item

  collDir=.directory~new            -- define directory containing predefined collections
  collDir~emptyColl=clz~new

  o1=.object~new
  o2=.object~new

  collDir~coll_1   =clz~new~~put("1","1")~~put("2","2")~~put("2","2")              ~~put(o1,o1)~~put(o1)
  collDir~coll_2   =clz~new              ~~put("2","2")~~put("2","2")~~put("2","2")~~put(o1,o1)~~put(o1)~~put(o2,o2)~~put(o2) ~~put("3","3")

  collDir~allIndexes1=.array~of("1", "2", "2",      o1, o1)
  collDir~allIndexes2=.array~of(     "2", "2", "2", o1, o1, o2, o2, "3")

  collDir~allItems1=.array~of("1", "2", "2",      o1, o1)
  collDir~allItems2=.array~of(     "2", "2", "2", o1, o1, o2, o2, "3")

   /* determine resulting collection   */
  collDir~difference1 =clz~new~~put("1","1")  /* coll_1~difference(coll_2) */
  collDir~difference2 =clz~new~~put("2","2")~~put(o2,o2)~~put(o2)~~put("3","3")   /* coll_2~difference(coll_1) */

  collDir~interSectionColl=clz~new~~put("2","2")~~put("2","2")~~put(o1)~~put(o1)

  collDir~unionColl       =clz~new~~put("1","1")~~put("2","2")~~put("2","2") ~~put(o1,o1)~~put(o1)-
                                  ~~put("2","2")~~put("2","2")~~put("2","2") ~~put(o1,o1)~~put(o1)~~put(o2,o2)~~put(o2) ~~put("3","3")

  collDir~xorColl         =clz~new~~put("1","1")~~put("2","2")~~put("3","3")~~put(o2) ~~put(o2)



::method "test_AT"
  expose collDir clz bUserDefinedIndex bSingleItem

  coll=collDir~coll_1      -- get the prepared Bag
  self~assertEquals("1", coll~at("1"))
  self~assertEquals("2", coll~at("2"))
  self~assertNull(coll~at("3"))


::method "test_[]"
  expose collDir clz bUserDefinedIndex bSingleItem

  coll=collDir~coll_1      -- get the prepared Bag
  self~assertEquals("1", coll~"[]"("1"))
  self~assertEquals("2", coll~"[]"("2"))
  self~assertNull(coll~"[]"("3"))


::method "test_allIndexes"
  expose collDir clz bUserDefinedIndex bSingleItem

  self~assertTrue(sameContent(.bag~new~union(collDir~allIndexes1      ),                                            .bag~new~union(collDir~coll_1~allIndexes)))

  self~assertTrue(sameContent(.bag~new~union(collDir~allIndexes2      ),                                            .bag~new~union(collDir~coll_2~allIndexes)))

  tmp=collDir~emptyColl~allIndexes
  self~assertTrue(tmp~isInstanceOf(.array))
  self~assertEquals(0, tmp~items)


::method "test_allItems"
  expose collDir clz bUserDefinedIndex bSingleItem

  self~assertTrue(sameContent(.bag~new~union(collDir~allItems1      ),                                            .bag~new~union(collDir~coll_1~allItems)))

  self~assertTrue(sameContent(.bag~new~union(collDir~allItems2      ),                                            .bag~new~union(collDir~coll_2~allItems)))

  tmp=collDir~emptyColl~allItems
  self~assertTrue(tmp~isInstanceOf(.array))
  self~assertEquals(0, tmp~items)



::method "test_difference"
  expose collDir clz bUserDefinedIndex bSingleItem

  ce=collDir~emptyColl
  c1=collDir~coll_1
  c2=collDir~coll_2

  self~assertTrue(sameContent(ce, ce~difference(ce)))

  self~assertTrue(sameContent(c1, c1~difference(ce)))
  self~assertTrue(sameContent(c2, c2~difference(ce)))

  self~assertTrue(sameContent(collDir~difference1, c1~difference(c2)))
  self~assertTrue(sameContent(collDir~difference2, c2~difference(c1)))

  self~assertTrue(sameContent(ce, c1~difference(c1)))
  self~assertTrue(sameContent(ce, c2~difference(c2)))


   -- now test where other is an 'OrderedCollection': "makeArray" returns "allItems"
  o1=.object~new
  c =clz~new~~put("1")~~put("2")~~put("2")~~put(o1)~~put(o1)
  other=.array~new
  other[104]="2"
  other[106]=o1
  d1=clz~of("1", "2", o1)     -- expected result
  d2=c~difference(other)
  self~assertTrue(sameContent(d1, d2), "subtest8: 'other' is an 'OrderedCollection'")

  -- Simplistic difference test where the argument collection is a table
  obj = .Bag.testGroup~new
  receiverBag = .bag~of("Lion", "Tiger", "Dog", obj)

  argumentTable = .table~new
  argumentTable["Lion"] = "Lion"
  argumentTable["Tiger"] = "Tiger"

  expectedBag = .bag~of("Dog", obj)
  resultBag = receiverBag~difference(argumentTable)

  self~assertTrue(resultBag~isA(.bag), "Result object after difference must be a bag")
  self~assertTrue(sameContent(expectedBag, resultBag), "Difference in bag and table should be Dog and obj")


::method "test_empty"
  expose collDir clz bUserDefinedIndex bSingleItem

  ce=collDir~emptyColl
  self~assertTrue(sameContent(ce, ce~copy~~empty))

  c1=collDir~coll_1~copy
  self~assertTrue(sameContent(ce, c1~copy~~empty))

  c2=collDir~coll_2~copy
  self~assertTrue(sameContent(ce, c2~copy~~empty))


::method "test_hasIndex"
  expose collDir clz bUserDefinedIndex bSingleItem

  coll=collDir~coll_1      -- get the prepared Bag
  self~assertTrue(coll~hasIndex("1"))
  self~assertTrue(coll~hasIndex("2"))
  self~assertFalse(coll~hasIndex("3"))



::method "test_hasItem"
  expose collDir clz bUserDefinedIndex bSingleItem

  coll=collDir~coll_1      -- get the prepared Bag
  self~assertTrue(coll~hasItem("1"))
  self~assertTrue(coll~hasItem("2"))
  self~assertFalse(coll~hasItem("3"))


::method "test_index"
  expose collDir clz bUserDefinedIndex bSingleItem

  coll=collDir~coll_1      -- get the prepared Bag
  self~assertEquals("1", coll~index("1"))
  self~assertEquals("2", coll~index("2"))
  self~assertNull(coll~index("3"))



::method "test_interSection"
  expose collDir clz bUserDefinedIndex bSingleItem

  ce=collDir~emptyColl
  c1=collDir~coll_1
  c2=collDir~coll_2
  res=collDir~interSectionColl

  self~assertTrue(sameContent(ce, ce~interSection(ce)))

  self~assertTrue(sameContent(ce, c1~interSection(ce)))
  self~assertTrue(sameContent(ce, c2~interSection(ce)))

  self~assertTrue(sameContent(res, c1~interSection(c2)))
  self~assertTrue(sameContent(res, c2~interSection(c1)))

  self~assertTrue(sameContent(c1, c1~interSection(c1)))
  self~assertTrue(sameContent(c2, c2~interSection(c2)))


   -- now test where other is an 'OrderedCollection': "makeArray" returns "allItems"
  o1=.object~new
  c =clz~new~~put("1")~~put("2")~~put("2")~~put(o1)~~put(o1)
  other=.array~new
  other[104]="2"
  other[106]=o1
  d1=clz~of("2", o1)          -- expected result
  d2=c~interSection(other)
  self~assertTrue(sameContent(d1, d2), "subtest8: 'other' is an 'OrderedCollection'")

  -- Simplistic intersection test where the argument collection is a table.
  obj = .Bag.testGroup~new
  receiverBag = .bag~of("Lion", "Tiger", "Dog", obj)

  argumentTable = .table~new
  argumentTable["Elm"] = "Elm"
  argumentTable["Maple"] = "Maple"
  argumentTable["Dog"] = "Dog"
  argumentTable[obj] = obj

  expectedBag = .bag~of("Dog", obj)
  resultBag = receiverBag~intersection(argumentTable)

  self~assertTrue(resultBag~isA(.bag), "Result object after intersection must be a bag")
  self~assertTrue(sameContent(expectedBag, resultBag), "Intersection of bag and table should be Dog and obj")



::method "test_isInstanceOf"     -- test whether collection object is of the correct kind (class)
  expose collDir clz bUserDefinedIndex bSingleItem

  o=collDir~coll_1

  self~assertTrue(o~isInstanceOf(.Object), "01: subclass of .Object")
  self~assertTrue(o~isInstanceOf(clz), "02: subclass of .Object")

  if .ooRexxUnit.languageLevel>6.01 then
  do
     self~assertTrue(o~isInstanceOf(.MapCollection), "03: subclass of .OrderedCollection")
     self~assertTrue(o~isInstanceOf(.SetCollection), "04: subclass of .OrderedCollection")
  end



::method "test_isEmpty"
  expose collDir clz bUserDefinedIndex bSingleItem

  self~assertTrue(collDir~emptyColl~isEmpty)
  self~assertFalse(collDir~coll_1~isEmpty)
  self~assertFalse(collDir~coll_2~isEmpty)

  self~assertTrue(collDir~coll_1~copy~~empty~isEmpty)



::method "test_items"
  expose collDir clz bUserDefinedIndex bSingleItem

  self~assertEquals(0, collDir~emptyColl~items)
  self~assertEquals(5, collDir~coll_1~items)
  self~assertEquals(8, collDir~coll_2~items)



::method "test_makeArray"
  expose collDir clz bUserDefinedIndex bSingleItem

  tmp=collDir~coll_1~makeArray
  self~assertTrue(tmp~isInstanceOf(.array))
  if bUserDefinedIndex then
     self~assertTrue(sameContent(.bag~new~union(tmp                ),                                               .bag~new~union(collDir~allIndexes1)))
  else
     self~assertTrue(sameContent(.bag~new~union(tmp                ),                                               .bag~new~union(collDir~allItems1)))


  tmp=collDir~coll_2~makeArray
  self~assertTrue(tmp~isInstanceOf(.array))
  if bUserDefinedIndex then
     self~assertTrue(sameContent(.bag~new~union(tmp                ),                                               .bag~new~union(collDir~allIndexes2)))
  else
     self~assertTrue(sameContent(.bag~new~union(tmp                ),                                               .bag~new~union(collDir~allItems2)))


  tmp=collDir~emptyColl~makeArray
  self~assertTrue(tmp~isInstanceOf(.array))
  self~assertEquals(0, tmp~items)


::method "test_of"
  expose collDir clz bUserDefinedIndex bSingleItem o1 o2

  tmpColl=clz~of("1", "2", "2", o1, o1)
  self~assertTrue(sameContent(collDir~coll_1, tmpColl))
  self~assertEquals(5, tmpColl              ~items)

  tmpColl=clz~of
  self~assertEquals(0, tmpColl              ~items)





::method "test_PUT"
  expose collDir clz bUserDefinedIndex bSingleItem

  tmpColl=clz~new
  self~assertEquals(0, tmpColl              ~items)

  self~assertEquals(1, tmpColl~~put("1","1")~items)
  self~assertTrue(tmpColl~hasindex("1"))
  self~assertTrue(tmpColl~hasitem("1"))

  self~assertEquals(2, tmpColl~~put("2","2")~items)
  self~assertTrue(tmpColl~hasindex("2"))
  self~assertTrue(tmpColl~hasitem("2"))

  self~assertEquals(3, tmpColl~~put("2","2")~items)
  self~assertTrue(tmpColl~hasindex("2"))
  self~assertTrue(tmpColl~hasitem("2"))

  self~assertEquals(4, tmpColl~~put("3","3")~items)
  self~assertTrue(tmpColl~hasindex("3"))
  self~assertTrue(tmpColl~hasitem("3"))


::method "test_PUT_2"
  expose collDir clz bUserDefinedIndex bSingleItem

  tmpColl=clz~new
  self~assertEquals(0, tmpColl              ~items)

  self~assertEquals(1, tmpColl~~put("1")~items)
  self~assertTrue(tmpColl~hasindex("1"))
  self~assertTrue(tmpColl~hasitem("1"))

  self~assertEquals(2, tmpColl~~put("2")~items)
  self~assertTrue(tmpColl~hasindex("2"))
  self~assertTrue(tmpColl~hasitem("2"))

  self~assertEquals(3, tmpColl~~put("2")~items)
  self~assertTrue(tmpColl~hasindex("2"))
  self~assertTrue(tmpColl~hasitem("2"))

  self~assertEquals(4, tmpColl~~put("3")~items)
  self~assertTrue(tmpColl~hasindex("3"))
  self~assertTrue(tmpColl~hasitem("3"))



::method "test_[]="
  expose collDir clz bUserDefinedIndex bSingleItem

  tmpColl=clz~new
  self~assertEquals(0, tmpColl              ~items)

  self~assertEquals(1, tmpColl~~"[]="("1","1")~items)
  self~assertTrue(tmpColl~hasindex("1"))
  self~assertTrue(tmpColl~hasitem("1"))

  self~assertEquals(2, tmpColl~~"[]="("2","2")~items)
  self~assertTrue(tmpColl~hasindex("2"))
  self~assertTrue(tmpColl~hasitem("2"))

  self~assertEquals(3, tmpColl~~"[]="("2","2")~items)
  self~assertTrue(tmpColl~hasindex("2"))
  self~assertTrue(tmpColl~hasitem("2"))

  self~assertEquals(4, tmpColl~~"[]="("3","3")~items)
  self~assertTrue(tmpColl~hasindex("3"))
  self~assertTrue(tmpColl~hasitem("3"))



::method "test_[]=_2"
  expose collDir clz bUserDefinedIndex bSingleItem

  tmpColl=clz~new
  self~assertEquals(0, tmpColl              ~items)

  self~assertEquals(1, tmpColl~~"[]="("1")~items)
  self~assertTrue(tmpColl~hasindex("1"))
  self~assertTrue(tmpColl~hasitem("1"))

  self~assertEquals(2, tmpColl~~"[]="("2")~items)
  self~assertTrue(tmpColl~hasindex("2"))
  self~assertTrue(tmpColl~hasitem("2"))

  self~assertEquals(3, tmpColl~~"[]="("2")~items)
  self~assertTrue(tmpColl~hasindex("2"))
  self~assertTrue(tmpColl~hasitem("2"))

  self~assertEquals(4, tmpColl~~"[]="("3")~items)
  self~assertTrue(tmpColl~hasindex("3"))
  self~assertTrue(tmpColl~hasitem("3"))




::method "test_putAll"
  expose collDir clz bUserDefinedIndex bSingleItem

  tmpColl=clz~new

  ce=collDir~emptyColl
  c1=collDir~coll_1
  c2=collDir~coll_2
  cu=collDir~unionColl

  self~assertTrue(sameContent(ce, ce~copy~~putAll(ce)))
  self~assertTrue(sameContent(c1, c1~copy~~putAll(ce)))
  self~assertTrue(sameContent(c2, c2~copy~~putAll(ce)))

  self~assertTrue(sameContent(c1, clz~new~~putAll(c1)))
  self~assertTrue(sameContent(c2, clz~new~~putAll(c2)))

  self~assertTrue(sameContent(cu, c1~copy~~putAll(c2)))
  self~assertTrue(sameContent(cu, c2~copy~~putAll(c1)))



::method "test_remove"
  expose collDir clz bUserDefinedIndex bSingleItem o1 o2

  ce=collDir~emptyColl~copy
  c1=collDir~coll_1~copy

  self~assertNull(ce~remove("1"))
  self~assertNull(ce~remove(.nil))

  self~assertNull(c1~remove("99"))

  self~assertEquals("1", c1~remove("1"))
  self~assertNull(c1~remove("1"))

  self~assertEquals("2", c1~remove("2"))
  self~assertEquals("2", c1~remove("2"))
  self~assertNull(c1~remove("2"))

  self~assertEquals(o1, c1~remove(o1))
  self~assertEquals(o1, c1~remove(o1))
  self~assertNull(c1~remove("2"))

  self~assertEquals(0, c1~items)



::method "test_removeItem"
  expose collDir clz bUserDefinedIndex bSingleItem o1 o2

  ce=collDir~emptyColl~copy
  c1=collDir~coll_1~copy

  self~assertNull(ce~removeItem("1", "1"))
  self~assertNull(ce~removeItem(.nil, .nil))

  self~assertNull(c1~removeItem("99", "99"))

  self~assertEquals("1", c1~removeItem("1", "1"))
  self~assertNull(c1~removeItem("1", "1"))

  self~assertEquals("2", c1~removeItem("2","2"))
  self~assertEquals("2", c1~removeItem("2","2"))
  self~assertNull(c1~removeItem("2","2"))

  self~assertEquals(o1, c1~removeItem(o1,o1))
  self~assertEquals(o1, c1~removeItem(o1,o1))
  self~assertNull(c1~removeItem(o1,o1))

  self~assertEquals(0, c1~items)

::method test_removeall
  c = .bag~new
  c~~put("2")~~put("2")
  removed = c~removeAll("2")
  self~assertTrue(sameContent(c, .bag~new))
  self~assertTrue(sameArrayContent(removed, .array~of("2", "2")))

  c = .bag~new
  c~~put("3")~~put("3")
  check = c~copy
  removed = c~removeAll("2")

  self~assertTrue(sameContent(c, check))
  self~assertTrue(sameArrayContent(removed, .array~new))


-- TODO: determine whether INDEX part may truly be left out, otherwise change
--       testcase to expect the appropriate error message
::method "test_removeItem_2"
  expose collDir clz bUserDefinedIndex bSingleItem o1 o2

  ce=collDir~emptyColl~copy
  c1=collDir~coll_1~copy

  self~assertNull(ce~removeItem("1"))
  self~assertNull(ce~removeItem(.nil))

  self~assertNull(c1~removeItem("99"))

  self~assertEquals("1", c1~removeItem("1"))
  self~assertNull(c1~removeItem("1"))

  self~assertEquals("2", c1~removeItem("2"))
  self~assertEquals("2", c1~removeItem("2"))
  self~assertNull(c1~removeItem("2"))

  self~assertEquals(o1, c1~removeItem(o1))
  self~assertEquals(o1, c1~removeItem(o1))
  self~assertNull(c1~removeItem(o1))

  self~assertEquals(0, c1~items)




::method "test_subset"
  expose collDir clz bUserDefinedIndex bSingleItem

  ce=collDir~emptyColl
  c1=collDir~coll_1
  c2=collDir~coll_2
  cu=collDir~unionColl

  self~assertTrue(ce~subset(ce))
  self~assertTrue(ce~subset(c1))
  self~assertTrue(ce~subset(c2))

  self~assertTrue(c1~subset(c1))
  self~assertTrue(c2~subset(c2))

  self~assertTrue(ce~subset(cu))
  self~assertTrue(c1~subset(cu))
  self~assertTrue(c2~subset(cu))

  self~assertFalse(c1~subset(ce))
  self~assertFalse(c1~subset(c2))

  self~assertFalse(c2~subset(ce))
  self~assertFalse(c2~subset(c1))


   -- now test where other is an 'OrderedCollection': "makeArray" returns "allItems"
  o1=.object~new
  c =clz~new~~put("1")~~put("2")~~put("2")~~put(o1)~~put(o1)
  other=.array~new
  other[104]="2"
  other[106]=o1
  d2=c~subSet(other)
  self~assertFalse(d2, "subtest14: 'other' is an 'OrderedCollection'")

  -- Simplistic test of subset where the argument is a table
  obj = .Bag.testGroup~new
  receiverBag = .bag~of("Lion", "Tiger", "Dog", obj)

  argumentTable = .table~new
  argumentTable["Dog"] = "Dog"
  argumentTable[obj] = obj
  self~assertFalse(receiverBag~subset(argumentTable), "Lion Tiger Dog 'obj' is not a subset of Dog 'obj'")

  argumentTable = .table~new
  argumentTable["Elm"] = "Elm"
  argumentTable["Maple"] = "Maple"
  argumentTable["Dog"] = "Dog"
  argumentTable[obj] = obj

  receiverBag~remove("Lion")
  receiverBag~remove("Tiger")
  self~assertTrue(receiverBag~subset(argumentTable), "Dog 'obj' is a subset of Elm Maple Dog 'obj'")

  receiverBag~remove("Dog")
  receiverBag~remove(obj)
  self~assertTrue(receiverBag~subset(argumentTable), "Empty bag is a subset of Elm Maple Dog 'obj'")

  emptyTable = .table~new
  self~assertTrue(receiverBag~subset(emptyTable), "Empty bag is a subset table")

   -- now test where other is an 'OrderedCollection': "makeArray" returns "allItems"
  o1=.object~new
  c =clz~new~~put("1")~~put("2")~~put("2")~~put(o1)~~put(o1)
  other=.array~new
  other[101]="1"
  other[102]="2"
  other[103]="3"
  other[104]="2"
  other[106]=o1
  other[107]=o1
  d2=c~subSet(other)
  self~assertTrue(d2, "subtest16: 'other' is an 'OrderedCollection'")



::method "test_Supplier"
  expose collDir clz bUserDefinedIndex bSingleItem

  ce=collDir~emptyColl
  c1=collDir~coll_1

  self~assertTrue(sameContent(ce, makeColl(clz, ce)))
  self~assertTrue(sameContent(c1, makeColl(clz, c1)))

  return

makeColl: procedure
  use arg clz, tmpColl

  new=clz~new
  s=tmpColl~supplier
  do while s~available
     new~put(s~item, s~index)
     s~next
  end
  return new



::method "test_union"
  expose collDir clz bUserDefinedIndex bSingleItem

  ce=collDir~emptyColl
  c1=collDir~coll_1
  c2=collDir~coll_2
  res=collDir~unionColl

  self~assertTrue(sameContent(ce, ce~union(ce)))

  self~assertTrue(sameContent(c1, c1~union(ce)))
  self~assertTrue(sameContent(c2, c2~union(ce)))

  self~assertTrue(sameContent(c1, ce~union(c1)))
  self~assertTrue(sameContent(c2, ce~union(c2)))

  self~assertTrue(sameContent(res, c1~union(c2)))
  self~assertTrue(sameContent(res, c2~union(c1)))


   -- now test where other is an 'OrderedCollection': "makeArray" returns "allItems"
  o1=.object~new
  c =clz~new~~put("1")~~put("2")~~put("2")~~put(o1)~~put(o1)
  other=.array~new
  other[104]="2"
  other[106]=o1
  d1=clz~of("1", "2", "2", "2", o1, o1, o1)  -- expected result
  d2=c~union(other)
  self~assertTrue(sameContent(d1, d2), "subtest8: 'other' is an 'OrderedCollection'")

  -- Simplistic test of union where the argument collection is a table.
  obj = .Bag.testGroup~new
  lionStr = "Lion"
  tigerStr = "Tiger"
  dogStr = "Dog"
  receiverBag = .bag~of(lionStr, tigerStr, dogStr, obj)

  argumentTable = .table~new
  elmStr = "Elm"
  mapleStr = "Maple"
  argumentTable[ElmStr] = ElmStr
  argumentTable[MapleStr] = MapleStr
  argumentTable[DogStr] = DogStr
  argumentTable[obj] = obj

  expectedBag = .bag~of(LionStr, TigerStr, DogStr, obj, ElmStr, MapleStr, DogStr, obj)
  resultBag = receiverBag~union(argumentTable)

  nl = '0d0a'x
  self~assertTrue(resultBag~isA(.bag), "Result object after union must be a bag")

  -- Documentation from Object Rexx:
  -- Set-Like Operations on Collections with Duplicates
  -- UNION operation
  --  All elements of A and B are united:
  --
  -- Using that definition, the new bag should have 8 items and contain every
  -- item in receiverBag and argumentTable.
  self~assertSame(8, resultBag~items, "Union of Lion Tiger Dog 'obj' with Elm Maple Dog 'obj' should" || nl ||                    "contain all 8 items")

  self~assertTrue(sameContent(expectedBag, resultBag), "Using Bag, union of Lion Tiger Dog 'obj' with Elm Maple Dog 'obj'" || nl ||                    "should be Lion Tiger Dog 'obj' Elm Maple Dog 'obj'")





::method "test_xor"
  expose collDir clz bUserDefinedIndex bSingleItem

  ce=collDir~emptyColl
  c1=collDir~coll_1
  c2=collDir~coll_2
  res=collDir~xorColl

  self~assertTrue(sameContent(ce, ce~xor(ce)))

  self~assertTrue(sameContent(c1, c1~xor(ce)))
  self~assertTrue(sameContent(c2, c2~xor(ce)))

  self~assertTrue(sameContent(res, c1~xor(c2)))
  self~assertTrue(sameContent(res, c2~xor(c1)))

  self~assertTrue(sameContent(ce, c1~xor(c1)))
  self~assertTrue(sameContent(ce, c2~xor(c2)))


   -- now test where other is an 'OrderedCollection': "makeArray" returns "allItems"
  o1=.object~new
  c =clz~new~~put("1")~~put("2")~~put("2")~~put(o1)~~put(o1)
  other=.array~new
  other[104]="2"
  other[106]=o1
  d1=clz~of("1", "2", o1)          -- expected result
  d2=c~xor(other)
  self~assertTrue(sameContent(d1, d2), "subtest8: 'other' is an 'OrderedCollection'")

  -- Simplistic test of XOR where the argument is a table
  obj = .Bag.testGroup~new
  lionStr = "Lion"
  tigerStr = "Tiger"
  dogStr = "Dog"
  receiverBag = .bag~of(lionStr, tigerStr, dogStr, obj, tigerStr, tigerStr)

  argumentTable = .table~new
  elmStr = "Elm"
  mapleStr = "Maple"
  argumentTable[ElmStr] = ElmStr
  argumentTable[MapleStr] = MapleStr
  argumentTable[DogStr] = DogStr
  argumentTable[obj] = obj

  expectedBag = .bag~of(LionStr, TigerStr, TigerStr, TigerStr, ElmStr, MapleStr)
  resultBag = receiverBag~xor(argumentTable)

  nl = '0d0a'x
  self~assertTrue(resultBag~isA(.bag), "Result object after union must be a bag")

  self~assertSame(6, resultBag~items, "XOR of Lion Tiger Dog 'obj' Tiger Tiger with Elm Maple Dog 'obj' should" || nl ||                    "contain 6 items")

  self~assertTrue(sameContent(expectedBag, resultBag), "Using Bag, XOR of Lion Tiger Dog 'obj' Tiger Tiger with Elm Maple Dog 'obj'" || nl ||                    "should be Lion Tiger Tiger Tiger Elm Maple")

::method "test_equivalent"
  -- empty collection
  self~assertTrue(.bag~new~equivalent(.bag~new))
  -- empty vs. non-empty, two ways
  self~assertFalse(.bag~of(1,2,3)~equivalent(.bag~new))
  self~assertFalse(.bag~new~equivalent(.bag~of(1,2,3)))
  -- simple true test
  self~assertTrue(.bag~of(1,2,3)~equivalent(.bag~of(1,2,3)))
  -- same number of items, different values
  self~assertFalse(.bag~of(1,2,3)~equivalent(.bag~of(1,2,4)))
  -- duplicate items vs. non-duplicate items
  self~assertFalse(.bag~of(1,2,3)~equivalent(.bag~of(1,2,2,3)))
  self~assertFalse(.bag~of(1,2,2,3)~equivalent(.bag~of(1,2,3)))
  -- mismatch on number of arguments, tested both ways
  self~assertFalse(.bag~of(1,2,3)~equivalent(.bag~of(1,2,3,4)))
  self~assertFalse(.bag~of(1,2,3,4)~equivalent(.bag~of(1,2,3)))

  -- simple cross class test using an array.  The array is converted to a set using the items
  self~assertTrue(.set~of(1,2,3)~equivalent(.array~of(1,2,3)))
  -- and the same using a sparse array
  self~assertTrue(.set~of(1,2,3)~equivalent(.array~of(1,,2,,3)))

::method "test_disjoint"
  -- empty bags are disjoint because they have no elements in common.
  self~assertTrue(.bag~new~disjoint(.bag~new))
  -- empty vs. non-empty, two ways.  Both disjoint
  self~assertTrue(.bag~of(1,2,3)~disjoint(.bag~new))
  self~assertTrue(.bag~new~disjoint(.bag~of(1,2,3)))
  -- simple true test
  self~assertTrue(.bag~of(1,2,3)~disjoint(.bag~of(4,5,6)))
  -- equal collections
  self~assertFalse(.bag~of(1,2,3)~disjoint(.bag~of(1,2,3)))
  -- single element overlap
  self~assertFalse(.bag~of(1,2,3)~disjoint(.bag~of(3,4,5)))


-- index must be identical to value for Bag[index] = value
::method test_putset_value_notequal_index
  self~expectSyntax(93.949) -- The value and index objects must be the same for PUT to an index-only collection
  .Bag~new[1] = .nil


-- index must be identical to value for Bag~put(value, index)
::method test_put_value_notequal_index
  self~expectSyntax(93.949) -- The value and index objects must be the same for PUT to an index-only collection
  .Bag~new~put(1, .nil)


-- removeItem(value, index) always returns .nil if index not identical to value 
::method test_removeitem_value_notequal_index
  c = .Bag~of(1, 1, 1)
  items = c~items
  self~assertEquals(.nil, c~removeItem(1, .nil))
  self~assertEquals(items, c~items)


-- hasItem(value, index) always returns .nil if index not identical to value 
::method test_hasitem_value_notequal_index
  c = .Bag~of(1, 1, 1)
  self~assertEquals(.nil, c~hasItem(1, .nil))



/* Test whether both collections contain the same entries.
   returns .true, if the same, .false else
*/
::routine "sameContent"
  use arg coll_1, coll_2

  if coll_1~items<>coll_2~items then      -- not the same amount of objects
     return .false

   -- work on a copy
  tmp=coll_1~copy
  do o over coll_2
     if \tmp~hasindex(o) then             -- no entry anymore ?
        return .false

     tmp~remove(o)                        -- remove object
  end

  return (tmp~items=0)                    -- if the same, then no items left


::routine "dumpColl"
  use arg coll, title
  if arg(2, "o") then title=o~class~id "object ("coll~items" entries)"

  .output~charout(">>>" title": [")
  do o over coll
     .output~charout("" o~string)
  end
  say "] <<<"
  say



/* Test whether two arrays contain the same content, regardless of order.
*/
::routine "sameArrayContent"
  use arg coll_1, coll_2

  if coll_1~items<>coll_2~items then      -- not the same amount of objects
     return .false

   -- work on a copy
  tmp=coll_1~copy
  do o over coll_2
     index = tmp~index(o)
     if index == .nil then             -- no entry anymore ?
        return .false

     tmp~remove(index)                    -- remove object
  end

  return (tmp~items=0)                    -- if the same, then no items left
