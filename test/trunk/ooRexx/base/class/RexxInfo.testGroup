#!/usr/bin/rexx
/*
  SVN Revision: $Rev$
  Change Date:  $Date$
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007-2019 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . fileSpec

  group = .TestGroup~new(fileSpec)
  group~add(.RexxInfo.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult
-- End of entry point.

::requires 'ooTest.frm' -- load the ooRexxUnit classes


::class "RexxInfo.testGroup" subclass ooTestCase public

  /*
  architecture              64
  casesensitivefiles        1
  date                      9 Mar 2019
  digits                    9
  directoryseparator        /
  endOfLine                 '0A'x
  executable                /usr/bin/rexx
  form                      SCIENTIFIC
  fuzz                      0
  internaldigits            18
  internalmaxnumber         999999999999999999
  internalminnumber         -999999999999999999
  languagelevel             6.05
  librarypath               /usr/lib/
  majorversion              5
  maxarraysize              99999999999999999
  maxexponent               999999999
  maxpathlength             4096
  minexponent               -999999999
  modification              0
  name                      REXX-ooRexx_5.0.0(MT)_64-bit 6.05 9 Mar 2019
  package                   The REXX Package
  pathseparator             :
  platform                  LINUX
  release                   0
  revision                  11828
  version                   5.0.0

  parse version:
  REXX-ooRexx_5.0.0(MT)_64-bit 6.05 9 Mar 2019

  parse source:
  LINUX COMMAND ...
  */

::method test_rexxInfo_package
  self~assertTrue(.RexxInfo~package~isA(.Package), ".RexxInfo~package should return a .Package instance")

::method test_rexxInfo_digits
  self~assertEquals("NUM", .RexxInfo~digits~dataType, ".RexxInfo~digits should return a numeric value")
  self~assertEquals(digits(), .RexxInfo~digits, ".RexxInfo~digits should be current digits()")

::method test_rexxInfo_fuzz
  self~assertEquals("NUM", .RexxInfo~fuzz~dataType, ".RexxInfo~fuzz should return a numeric value")
  self~assertEquals(fuzz(), .RexxInfo~fuzz, ".RexxInfo~fuzz should be current fuzz()")

::method test_rexxInfo_form
  self~assertTrue('ENGINEERING SCIENTIFIC'~wordPos(.RexxInfo~form) > 0, ".RexxInfo~form should return either 'ENGINEERING' or 'SCIENTIFIC'")
  self~assertEquals(form(), .RexxInfo~form, ".RexxInfo~form should be current form()")

::method test_rexxInfo_internalDigits
  self~assertEquals("NUM", .RexxInfo~internalDigits~dataType, ".RexxInfo~internalDigits should return a numeric value")
  self~assertTrue(.RexxInfo~internalDigits >= digits(), ".RexxInfo~internalDigits should be equal to or larger than digits()")
  digits = "9"~copies(.RexxInfo~internalDigits)
  self~assertEquals(digits, .RexxInfo~internalMaxNumber)
  self~assertEquals(-digits, .RexxInfo~internalMinNumber)

::method test_rexxInfo_maxArraySize
  self~assertEquals("NUM", .RexxInfo~internalMaxNumber~dataType, ".RexxInfo~internalMaxNumber should return a numeric value")

::method test_rexxInfo_exponent
  self~assertEquals("NUM", .RexxInfo~maxExponent~dataType)
  self~assertEquals("NUM", .RexxInfo~minExponent~dataType)
  self~assertTrue(.RexxInfo~minExponent < .RexxInfo~maxExponent, "minExponent should be smaller than maxExponent")

::method test_rexxInfo_maxPathLength
  self~assertEquals("NUM", .RexxInfo~maxPathLength~dataType)

::method test_rexxInfo_name
  self~assertTrue(.RexxInfo~name~length > 0, ".RexxInfo~name should return a non-null string")
  parse version version
  self~assertEquals(version, .RexxInfo~name, ".RexxInfo~name should be equal to parse version")

::method test_rexxInfo_langaugeLevel
  self~assertTrue(.RexxInfo~languageLevel~length > 0, ".RexxInfo~languageLevel should return a non-null string")

::method test_rexxInfo_majorVersion_release_modification_version
  self~assertEquals(.RexxInfo~version, .RexxInfo~majorVersion||"."||.RexxInfo~release||"."||.RexxInfo~modification, ".RexxInfo~version should be equal to .RexxInfo~majorVersion . .RexxInfo~release . .RexxInfo~revision")

::method test_rexxInfo_revision
  self~assertEquals("NUM", .RexxInfo~revision~dataType, ".RexxInfo~revision should be a number")

::method test_rexxInfo_date
  self~assertTrue(.RexxInfo~date~length > 0, ".RexxInfo~date should return a non-null string")
  self~assertEquals(.RexxInfo~name~right(.RexxInfo~date~length), .RexxInfo~date, ".RexxInfo~date should be equal to the last tokens of .RexxInfo~name")

::method test_rexxInfo_platform
  self~assertTrue(.RexxInfo~platform~length > 0, ".RexxInfo~platform should return a non-null string")
  parse source platform .
  self~assertEquals(platform, .RexxInfo~platform, ".RexxInfo~platform should be equal to parse source first token")
  -- on Linux, .RexxInfo~platform returns "LINUX", but SysVersion returns "Linux .."
  -- on Windows, .RexxInfo~platform returns "WindowsNT", but SysVersion returns "Windows .."
  parse value SysVersion() with platform .
  self~assertTrue(platform~length > 0, "SysVersion() should return a non-null string")
  if platform~caselessStartsWith("Windows") then
    self~assertTrue(.RexxInfo~platform~caselessStartsWith(platform), ".RexxInfo~platform should match SysVersion() first token")
  else
    self~assertEquals(platform~upper, .RexxInfo~platform~upper, ".RexxInfo~platform should be equal to SysVersion() first token")

::method test_rexxInfo_architecture
  self~assertTrue(.RexxInfo~architecture~length > 0, ".RexxInfo~architecture should return a non-null string")

::method test_rexxInfo_endofline
  self~assertEquals(.endofline, .RexxInfo~endofline, ".RexxInfo~endofline should be equal to .endofline")

::method test_rexxInfo_pathSeparator
  self~assertEquals(.File~pathSeparator, .rexxinfo~pathSeparator, ".RexxInfo~pathSeparator should be equal to .File~pathSeparator")

::method test_rexxInfo_directorySeparator
  self~assertEquals(.File~separator, .rexxinfo~directorySeparator, ".RexxInfo~directorySeparator should be equal to be .File~separator")

::method test_rexxInfo_caseSensitiveFiles
  self~assertTrue("0 1"~wordPos(.RexxInfo~caseSensitiveFiles) > 0, ".RexxInfo~caseSensitiveFiles should return .true or .false")
  self~assertEquals(.File~isCaseSensitive, .RexxInfo~caseSensitiveFiles, ".RexxInfo~caseSensitiveFiles should be equal to .File~isCaseSensitive")

::method test_rexxInfo_executable
  -- in the wild .RexxInfo~executable may be .nil or may not point to rexx(.exe)
  -- but for a typical test scenario this should not happen, so we really want
  -- know when and why this happens
  if .RexxInfo~platform~caselessStartsWith("Windows") then
    self~assertTrue(.RexxInfo~executable~endsWith("\rexx.exe"), ".RexxInfo~executable '" || .RexxInfo~executable || "' should end in '\rexx.exe'")
  else
    self~assertTrue(.RexxInfo~executable~endsWith("/rexx"), ".RexxInfo~executable '" || .RexxInfo~executable || "' should end in '/rexx'")
  self~assertTrue(.File~new(.RexxInfo~executable)~exists, ".RexxInfo~executable '" || .RexxInfo~executable || "' should exist")
  self~assertTrue(.File~new(.RexxInfo~executable)~isFile, ".RexxInfo~executable '" || .RexxInfo~executable || "' should be an existing file")

::method test_rexxInfo_libraryPath
  -- in rare cases .RexxInfo~libraryPath may be .nil because it couldn't be determined
  -- but for a typical test scenario this should not happen, so we really want
  -- know when and why this happens
  self~assertTrue(.RexxInfo~libraryPath~endsWith(.File~separator), ".RexxInfo~libraryPath '" || .RexxInfo~executable || "' should end in '" || .File~separator || "'")
  self~assertTrue(.File~new(.RexxInfo~libraryPath)~exists, ".RexxInfo~libraryPath '" || .RexxInfo~executable || "' should exist")
  self~assertTrue(.File~new(.RexxInfo~libraryPath)~isDirectory, ".RexxInfo~libraryPath '" || .RexxInfo~executable || "' should be an existing directory")


::options novalue error
