#!/usr/bin/rexx
/*
  SVN Revision: $Rev$
  Change Date:  $Date$
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007 - 2008 Rexx Language Association. All rights reserved.  */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . s
  group = .TestGroup~new(s)
  group~add(.Encode_DecodeBase64.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult

::requires 'ooTest.frm' -- load the ooRexxUnit classes

::class "Encode_DecodeBase64.testGroup" subclass ooTestCase public

::method setup       -- add entries to .local
      /* define data needed for the Rexx implementation of encodeBase64 and decodeBase64  */
   .local~base64.padChar="="                    -- use equal sign as a pad char
   .local~base64.mimeTable= "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" ||,
                                 padChar        -- trailing space indicator

   .local~base64.base64  = xrange("00"x, "3F"x) -- all 64 possible 6-bits values

::method tearDown    -- remove entries from .local
   .local~remove("BASE64.PADCHAR")
   .local~remove("BASE64.MIMETABLE")
   .local~remove("BASE64.BASE64")

  -- test {de|en}codeBase64
  /* based on newsgroup article:
         From: "Salvador Parra Camacho" <sparrac@gmail.com>
         Newsgroups: comp.lang.rexx
         Subject: encodebase64 method of the String class in ooRexx 3.1
         Date: 14 Oct 2006 12:31:13 -0700
         Organization: http://groups.google.com
  */
::method "test_EncodeBase64_DecodeBase64"
   allChars=xrange("00"x, "ff"x) -- create a string with all 8-Bit chars
   do i=1 to allChars~length
      a=allChars~left(i)         -- create a string from the left
      self~assertSame(a, a~encodeBase64~decodeBase64)  -- test whether same value
      -- self~assertEquals(a, a1~encodeBase64~decodeBase64)  -- test whether same value

      b=allChars~right(i)        -- create a string from the right
      self~assertSame(b, b~encodeBase64~decodeBase64)  -- test whether same value
   end

   a="Hello world"
   a1=a~encodeBase64          -- encode the string with ooRexx
      -- "Hello world" encoded value from Perl, Ruby, etc. according to Salvador's article
   a2="SGVsbG8gd29ybGQ="

   self~assertSame(a, a2~decodeBase64)
   self~assertSame(a, a1~decodeBase64)

::method "used_to_test_rexx_enDecoding" -- "test_Enbase64_Debase64"
   allChars=xrange("00"x, "ff"x) -- create a string with all 8-Bit chars
   do i=1 to allChars~length
      a=allChars~left(i)         -- create a string from the left
      self~assertSame(a, debase64(enbase64(a)))  -- test whether same value

      b=allChars~right(i)        -- create a string from the right
      self~assertSame(b, debase64(enbase64(b)))  -- test whether same value
   end



/* Systematically test built-in method vs. a Rexx-solution (c) Rony G. Flatscher */
::method "test_EncodeBase64"
   allChars=xrange("00"x, "ff"x) -- create a string with all 8-Bit chars

   do i=1 to allChars~length
      a=allChars~left(i)         -- create a string from the left
      self~assertSame(enbase64(a), a~encodeBase64)  -- test whether same value
      -- self~assertEquals(enbase64(a), a~encodeBase64)  -- test whether same value
   end


/* Systematically test built-in method vs. a Rexx-solution (c) Rony G. Flatscher */
::method "test_DecodeBase64"
   allChars=xrange("00"x, "ff"x) -- create a string with all 8-Bit chars

   do i=1 to allChars~length
      a=allChars~left(i)         -- create a string from the left
      a2=enbase64(a)             -- base64 encode it
      self~assertSame(a, a2~decodeBase64)  -- test whether same value
      -- self~assertEquals(a, a2~decodeBase64)  -- test whether same value
   end



/* Systematically test built-in method vs. a Rexx-solution (c) Rony G. Flatscher */
-- enbase64: procedure expose mimeTable padChar base64
::routine enbase64
     parse arg data

           -- do we need to pad the data at the end?
     pad = 3-length(data) // 3   -- get rest of integer division
     if pad<>3 then data=data || copies("00"x, pad)      -- add blanks to get to multiple of 3's
     data=x2b(c2x(data))         -- turn all data into a bitstring

     new=.mutableBuffer~new
     do while data <> ""
        parse var data nr1 +6 nr2 +6 nr3 +6 nr4 +6 data    -- get data of 3 bytes in six-bit-packs

        -- new = new || x2c(b2x(nr1)) || x2c(b2x(nr2)) || x2c(b2x(nr3)) || x2c(b2x(nr4))  -- add them to result
        new~~append(x2c(b2x(nr1))) ~~append(x2c(b2x(nr2))) ~~append(x2c(b2x(nr3)))
        new~~append(x2c(b2x(nr4)))  -- add them to result
     end

     new=translate(new~string, .base64.mimeTable, .base64.base64)     -- translate to table chars

     if pad<>3 then         -- not a multiple of 3, then indicate pads with "="
        new = overlay( copies(.base64.padChar, pad), new, (length(new)-pad+1) )
     return new


::routine deBase64 public
  use arg data

  pos=pos(.base64.padChar,data)        -- find pad character
  if pos<>0 then
  do
     pnum = length(data) - pos + 1   -- how many are there (1 or 2) ?
     if pnum>2 then pnum=0   -- something went wrong, there shouldn't be more than two, reset
  end
  else
     pnum = 0

  data=translate(data, .base64.base64, .base64.mimetable)    -- translate from table

        -- check if data is missing, if so pad with "00"x
  pad = length(data) // 4       -- get rest of integer division
  if pad<>0 then data=data || copies("00"x, 4-pad)      -- add blanks to get to multiple of 4's

  data=x2b(c2x(data))   -- now turn data into a bitstring

  new=.mutableBuffer~new
  do while data<>""
     parse var data . +2 nr5 +6 . +2 nr6 +6 . +2 nr7 +6 .+2 nr8 +6 data

     if data = "" then  -- last round, nothing left after this one
        new~append(left( x2c(b2x(nr5 ||nr6 || nr7 || nr8)), 3-pnum)) -- use only non-chunked bytes
     else
        new~append(x2c(b2x(nr5 ||nr6 || nr7 || nr8)))
  end
  return new~string



