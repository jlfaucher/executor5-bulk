#!/usr/bin/env rexx
/*
  SVN Revision: $Rev$
  Change Date:  $Date$
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007-2020 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
parse source . . fileSpec
group = .TestGroup~new(fileSpec)
group~add(.SysSearchPath.testgroup)
if group~isAutomatedTest then
  return group
else
  return group~suite~execute~~print

::requires 'ooTest.frm'
::class SysSearchPath.testgroup subclass ooTestCase public


::method test_searchpath_args_none
  self~expectSyntax((88.901, 1)) -- Missing argument; argument 1 is required
  call SysSearchPath

::method test_searchpath_args_one
  self~expectSyntax((88.901, 2)) -- Missing argument; argument 2 is required
  call SysSearchPath ""

::method test_searchpath_args_four
  self~expectSyntax((88.922, 3)) -- Too many arguments in invocation; 3 expected
  call SysSearchPath "", "", "", ""

::method test_searchpath_option_null
  self~expectSyntax(40.920) -- SysSearchPath argument option must be one of "'C' or 'N'"
  call SysSearchPath "", "", ""

::method test_searchpath_option_invalid
  self~expectSyntax(40.920) -- SysSearchPath argument option must be one of "'C' or 'N'"
  call SysSearchPath "", "", "x"


::method test_searchpath_empty
  self~assertSame("", SysSearchPath("", ""))
  self~assertSame("", SysSearchPath("", "no-file"))
  self~assertSame("", SysSearchPath("no-variable", ""))
  self~assertSame("", SysSearchPath("no-variable", "no-file"))
  self~assertSame("", SysSearchPath("PATH", ""))
  self~assertSame("", SysSearchPath("PATH", "no-file"))

  self~assertSame("", SysSearchPath("", "", "n"))
  self~assertSame("", SysSearchPath("", "", "C"))
  self~assertSame("", SysSearchPath("", "", "No"))
  self~assertSame("", SysSearchPath("", "", "cur"))

  -- SysSearchPath searches for files only, no directories
  self~assertSame("", SysSearchPath("", "/", "nocurrent"))
  self~assertSame("", SysSearchPath("", "/", "CURRENT"))
  self~assertSame("", SysSearchPath("", "/"))
  self~assertSame("", SysSearchPath("", ".", "C"))
  self~assertSame("", SysSearchPath("", "./."))
  self~assertSame("", SysSearchPath("", directory()))

::method test_searchpath_relative
  -- test all files in the current directory
  do file over .File~new('.')~listFiles
    if file~isFile then do
      msg = file~name "in directory" directory()
      -- option C searches current directory
      self~assertSame(file~absolutePath, SysSearchPath("", file~name, "current"), msg)
      self~assertSame(file~absolutePath, SysSearchPath("", "./"file~name, "current"), "./" || msg)
      -- option N won't search current directory
      if .RexxInfo~platform~caselessStartsWith("DARWIN") then
      do
      -- avoid problems with hidden .DS_Store files on macOS
         res = SysSearchPath("", file~name, "nocurrent")
         if res~caselessPos('.DS_Store') = 0 then self~assertSame("", SysSearchPath("", file~name, "nocurrent"), msg)
         else self~assertSame(res, SysSearchPath("", file~name, "nocurrent"), msg)
      end
      else self~assertSame("", SysSearchPath("", file~name, "nocurrent"), msg)
    end
  end

-- files with an absolute path are always found
::method test_searchpath_absolute
  parse source . . file
  do absolute over file, .RexxInfo~executable
    self~assertSame(absolute, SysSearchPath("", absolute))
    self~assertSame(absolute, SysSearchPath("no-variable", absolute))
    self~assertSame(absolute, SysSearchPath("PATH", absolute))
  end

::method test_searchpath_rexx
  rexxPath = .Rexxinfo~executable
  rexx = filespec("name", rexxPath)

  self~assertSame(rexxPath, SysSearchPath("PATH", rexx))
  self~assertSame(rexxPath, SysSearchPath("PATH", rexx, "c"))
  self~assertSame(rexxPath, SysSearchPath("PATH", rexx, "n"))

  -- Environment variables on Unix-like systems are
  -- case-sensititve even if the file system isn't, like on Darwin
  if .RexxInfo~platform~caselessStartsWith("windows") then
    return
  self~assertSame("", SysSearchPath("path", rexx))

::method test_searchpath_variable
  parse source . . file
  name = filespec("name", file)
  path = filespec("location", file) -- this keeps a trailing delimiter
  pathStripped = path~strip("t", "/")
  -- to avoid surprises we dont't search the current directory
  self~assertSame("",   self~searchPath(.Array~of(""), name, "N"))
  self~assertSame("",   self~searchPath(("", ""), name, "n"))
  self~assertSame(file, self~searchPath(.Array~of(path), name, "n"))
  self~assertSame(file, self~searchPath(.Array~of(pathStripped), name, "n"))
  self~assertSame(file, self~searchPath(("abc", path, pathStripped, "xyz"), name, "n"))
  self~assertSame(file, self~searchPath(("abc"~copies(500), path), name, "n"))

::method searchPath
  use strict arg list, file, option = "c"
  call value "test_searchpath", list~toString(, .File~pathSeparator), "environment"
  return SysSearchPath("test_searchpath", file)

::method 'notestSearchPath_Current_Script'
    parse source . . me
    lastSlash = me~lastPos("/")
    directory = me~left(lastSlash - 1)
    filename = me~substr(lastSlash + 1)

    oldval = value("varname", , "ENVIRONMENT")

    call value "varname", directory, "ENVIRONMENT"
    self~assertNotEquals("", SysSearchPath("varname", filename), "01 : Must be found because current dir is in path")
    call value "varname", "*dummy before*:"directory":*dummy after*", "ENVIRONMENT"
    self~assertNotEquals("", SysSearchPath("varname", filename), "02 : Must be found because current dir is in path")
    call value "varname", "a"~copies(2000)":"directory, "ENVIRONMENT"
    self~assertNotEquals("", SysSearchPath("varname", filename), "03 : Must be found, even if path > 1024 characters (was a bug under Windows)")
    call value "varname", oldval, "ENVIRONMENT" -- restore

    curdir = directory(directory)
    self~assertNotEquals("", SysSearchPath("*non existent varname*", filename, "c"), "04 : Must be found because current dir is searched")
    self~assertEquals("", SysSearchPath("*non existent varname*", filename, "n"), "05 : Must not be found because current dir is not searched")
    call directory curdir -- restore


::options novalue syntax
