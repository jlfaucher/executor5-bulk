#!/usr/bin/env rexx
/*
  SVN Revision: $Rev$
  Change Date:  $Date$
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007-2020 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/

    parse source . . fileSpec;

    group = .TestGroup~new(fileSpec)
    group~add(.SysFileXXX.testGroup)

    if group~isAutomatedTest then return group

    testResult = group~suite~execute~~print

return testResult
-- End of entry point.

::requires 'ooTest.frm'
::class 'SysFileXXX.testgroup' subclass ooTestCase public

::method test_fileexists_no_arg
  self~expectSyntax(88.901) -- Missing argument; argument 1 is required
  call SysFileExists

::method test_fileexists_two_args
  self~expectSyntax((88.922, 1)) -- Too many arguments in invocation; 1 expected
  call SysFileExists "", ""

::method test_fileexists_invalid
  self~assertFalse(SysFileExists(""))
  self~assertFalse(SysFileExists("*"))
  self~assertFalse(SysFileExists("??"))

::method test_fileexists_valid
  self~assertTrue(SysFileExists("."))
  self~assertTrue(SysFileExists("/."))
  self~assertTrue(SysFileExists("./"))
  self~assertTrue(SysFileExists("./."))
  self~assertTrue(SysFileExists(".."))
  self~assertTrue(SysFileExists("../"))
  self~assertTrue(SysFileExists("../."))
  self~assertTrue(SysFileExists("/.."))
  self~assertTrue(SysFileExists("./.."))

::method test_file_exists

    parse source . . me

    directory = filespec('Location', me)
    filename = filespec('Name', me)

    -- the fully resolve directory and file should exist
    self~assertTrue(sysFileExists(me))
    self~assertTrue(sysFileExists(directory))

    currentDir = Directory(directory)
    self~assertTrue(SysFileExists(filename))

    self~assertFalse(SysFileExists(filename||'xxxxx'))

    self~assertTrue(SysIsFile(me))
    self~assertTrue(SysIsFile(fileName))
    self~assertFalse(SysIsFile(directory))
    self~assertFalse(SysIsFile(""))
    self~assertFalse(SysIsFile("."))
    self~assertFalse(SysIsFile(".."))

    self~assertFalse(SysIsFile(filename||'xxxxx'))

    self~assertFalse(SysIsFileDirectory(me))
    self~assertFalse(SysIsFileDirectory(fileName))
    self~assertTrue(SysIsFileDirectory(directory))
    self~assertTrue(SysIsFileDirectory("."))
    self~assertTrue(SysIsFileDirectory(".."))

    self~assertFalse(SysIsFileDirectory(directory||'xxxxx'))

    temp = .TemporaryTestFile~new(self, 'testinput')
    temp~create(("Line1","","Line3"))

    self~assertTrue(SysFileExists('testinput'))
    self~assertEquals(0, SysFileDelete(temp~fullName))
    self~assertFalse(SysFileExists('testinput'))

    temp = .TemporaryTestFile~new(self, 'testinput2')
    temp~create(("Line1","","Line3"))

    self~assertTrue(SysFileExists('testinput2'))
    self~assertEquals(0, SysFileDelete('testinput2'))
    self~assertFalse(SysFileExists('testinput2'))

    self~assertNotEquals(0, SysFileDelete('testinput3'))
    self~assertNotEquals(0, SysFileDelete(directory))

    temp = .TemporaryTestFile~new(self, 'testinput4')
    temp~create(("Line1","","Line3"))

    -- this only applies to Windows
    if .ooRexxUnit.OSName == "WINDOWS" then do
       tempFile = .File~new(temp~fullName)
       tempFile~setReadOnly
       self~assertFalse(tempFile~canWrite)
       self~assertNotEquals(0, SysFileDelete('testinput4'))
       self~assertTrue(SysFileExists('testinput4'))
       tempFile~setWritable
       self~assertEquals(0, SysFileDelete('testinput4'))
    end

    temp = .TemporaryTestDirectory~new(self, "testdir")

    self~assertEquals(0, SysMkDir(temp~fullName))
    self~assertTrue(SysIsFileDirectory(temp~fullName))
    self~assertEquals(0, SysRmDir(temp~fullName))
    self~assertFalse(SysFileExists(temp~fullName))

    call directory currentDir

-- (Windows-only) UNC filename tests
::method test_name_UNC
  if \.RexxInfo~platform~caselessStartsWith("Windows") then
      return
  parse source . . this
  thisFile = .File~new(this~changeStr(':', '$'), '\\localhost')
  thisDir = thisFile~parentFile
  self~assertTrue(SysFileExists(thisFile~absolutePath), thisFile~absolutePath "should exist")
  self~assertTrue(SysIsFile(thisFile~absolutePath), thisFile~absolutePath "should exist")
  self~assertTrue(SysFileExists(thisDir~absolutePath), thisDir~absolutePath "should exist")
  self~assertTrue(SysIsFileDirectory(thisDir~absolutePath), thisDir~absolutePath "should exist")

::method test_file_copy
    parse source . . me

    directory = filespec('Location', me)

    lines = ("Line1","","Line3")
    temp = .TemporaryTestFile~new(self, 'copysource')
    temp~create(lines)

    temp2 = .TemporaryTestFile~new(self, 'copytarget')

    self~assertEquals(0, SysFileCopy(temp~fullName, temp2~fullname))
    self~assertTrue(SysFileExists(temp~fullName));
    self~assertTrue(SysFileExists(temp2~fullName));

    s = .stream~new(temp2~fullName)
    self~assertEquivalentList(lines, s~arrayIn)
    s~close

    currentDir = Directory(directory)

    lines = ("Line4","","Line6")
    temp~create(lines)

    self~assertEquals(0, SysFileCopy('copysource', 'copytarget'))
    self~assertTrue(SysFileExists('copysource'));
    self~assertTrue(SysFileExists('copytarget'));

    s = .stream~new('copytarget')
    self~assertEquivalentList(lines, s~arrayIn)
    s~close

::method test_file_move
    parse source . . me

    directory = filespec('Location', me)

    lines = ("Line1","","Line3")
    temp = .TemporaryTestFile~new(self, 'movesource')
    temp~create(lines)

    temp2 = .TemporaryTestFile~new(self, 'movetarget')

    self~assertEquals(0, SysFileMove(temp~fullName, temp2~fullname))
    self~assertFalse(SysFileExists(temp~fullName));
    self~assertTrue(SysFileExists(temp2~fullName));

    s = .stream~new(temp2~fullName)
    self~assertEquivalentList(lines, s~arrayIn)
    s~close

    call SysFileDelete(temp2~fullName)

    currentDir = Directory(directory)

    lines = ("Line4","","Line6")
    temp~create(lines)

    self~assertEquals(0, SysFileMove('movesource', 'movetarget'))
    self~assertFalse(SysFileExists('movesource'));
    self~assertTrue(SysFileExists('movetarget'));

    s = .stream~new('movetarget')
    self~assertEquivalentList(lines, s~arrayIn)
    s~close

    temp~create(("Line7","","Line8"))

    self~assertNotEquals(0, SysFileMove('movesourcexxxx', 'movetargetxxxx'))
    self~assertFalse(SysFileExists('movesourcexxxx'));
    self~assertFalse(SysFileExists('movetargetxxxx'));

::method test_tempfile_no_arg
  self~expectSyntax(88.901) -- Missing argument; argument 1 is required
  call SysTempFileName

::method test_tempfile_three_args
  self~expectSyntax((88.922, 2)) -- Too many arguments in invocation; 2 expected
  call SysTempFileName "", "", ""

::method test_tempfile_filler_null
  self~expectSyntax(40.23) -- SysTempFileName argument filler must be a single character
  call SysTempFileName "foo?", ""

::method test_tempfile_filler_long
  self~expectSyntax(40.23) -- SysTempFileName argument filler must be a single character
  call SysTempFileName "--", "--"

::method test_tempfile_template_filler_mismatch
  self~assertSame("", SysTempFileName(""))
  self~assertSame("", SysTempFileName("", "?"))
  self~assertSame("", SysTempFileName("file"))
  self~assertSame("", SysTempFileName("?", "*"))
  self~assertSame("", SysTempFileName("***", "."))
  self~assertSame("", SysTempFileName("file", "?"))
  self~assertSame("", SysTempFileName("file??", "-"))
  self~assertSame("", SysTempFileName("?????file?????"))

::method test_tempfile_simple
  s = .File~separator
  self~assertSame("?", template("?"))
  self~assertSame("??", template("??"))
  self~assertSame("???", template("???"))
  self~assertSame("????", template("????"))
  self~assertSame("?????", template("?????"))
  self~assertSame("??????", template("??????"))
  self~assertSame("???????", template("???????"))
  self~assertSame("????????", template("????????"))
  self~assertSame("?????????", template("?????????"))

  self~assertSame("*", template("*", "*"))
  self~assertSame("?x", template("?x"))
  self~assertSame("-?-", template("-?-"))
  self~assertSame("file???", template("file???"))
  self~assertSame("test.dat", template("test.dat", "."))

  self~assertSame("dir"s"file?", template("dir"s"file?"))
  self~assertSame("dir?"s"file?", template("dir?"s"file?"))
  self~assertSame(".dir."s".file.", template(".dir."s".file.", "."))
  self~assertSame("*********", template("*********", "*"))
  return

  template: procedure
  use arg template, filler
  if arg(2, "omitted") then
    return SysTempFileName(template)~translate(, "0123456789", "?")~right(template~length)
  else
    return SysTempFileName(template, filler)~translate(, "0123456789", filler)~right(template~length)

::method test_tempfile_path
  s = .File~separator
  -- always an absolute path
  self~assertSame(.File~new("?")~absolutePath, template("?"))
  self~assertSame(.File~new("/??temp")~absolutePath, template("/??temp"))
  return

  template: procedure
  use arg template
  name = SysTempFileName(template)
  return name~translate(, "0123456789", "?", name~length - template~length + 1)

::method test_tempfile_exhaust
  dir = .File~new(self~class~package~name)~parentFile
  template = .File~new("test_tempfile_exhaust", dir)~absolutePath
  files = .Array~new
  file = .true
  loop
    name = SysTempFileName(template, "_")
    if name = "" then
      leave
    files~append(.File~new(name))
    -- create a file/directory until all possibilities are exhausted
    if file then
      .Stream~new(name)~~open("write replace")~close
    else
      .File~new(name)~makeDir
    file = \file
  end
  self~assertSame(100, files~items)
  do file over files
    file~delete
  end

::method test_temp_file_name
    parse source . . me

    directory = filespec('Location', me)
    currentDir = Directory(directory)

    n = SysTempFileName("foo?.bar?")
    self~assertEquals(0, n~pos('?'))
    self~assertFalse(SysFileExists(n))

    lines = ("Line1","","Line3")
    tempfiles = .array~new(10)

    loop i = 0 to 9
       temp = .TemporaryTestFile~new(self, 'foo'||i)
       temp~create(lines)
       tempfiles~append(temp)
    end

    -- this should ensure this can't be created
    n = SysTempFileName("foo?")
    self~assertEquals("", n)

    n = SysTempFileName("foo*.bar*", '*')
    self~assertEquals(0, n~pos('*'))
    self~assertFalse(SysFileExists(n))



::method verifySeq
  use arg source., result.

  do i=0 to result.0
     self~assertEquals(source.i, result.i)
  end

::method of
  use arg target.
  values = arg(2, 'a')

  target.0 = values~items
  do i = 1 to target.0
      target.i = values[i]
  end

::options novalue error

