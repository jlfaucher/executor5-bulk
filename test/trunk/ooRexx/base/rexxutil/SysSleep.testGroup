#!/usr/bin/env rexx
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2022 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* https://www.oorexx.org/license.html                                        */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
parse source . . s

group = .TestGroup~new(s)
group~add(.SysSleep.testGroup)
if group~isAutomatedTest then
  return group
else
  return group~suite~execute~~print


::requires 'ooTest.frm'
::class SysSleep.testgroup subclass ooTestCase public

::constant isWindows (.RexxInfo~platform~caselessStartsWith("Windows"))
-- on Windows we allow SysSleep to be up to 21 ms early or 30 ms late
-- on Unix-like systems it must never(*) be early, but we allow it being up
-- to 26 ms late (we're seeing such long delays e. g. in our MacOS or NetBSD
-- VM agents)
-- (*) "nanosleep() function causes the calling thread to sleep for the amount
-- of time specified [but] the actual time slept may be longer"
::constant tooEarly (self~isWindows~?(0.021, 0))
::constant tooLate (self~isWindows~?(0.030, 0.026))

::method test_sleep_no_arg
  self~expectSyntax(88.901) -- Missing argument; argument 1 is required
  call SysSleep

::method test_sleep_two_args
  self~expectSyntax(88.922) -- Too many arguments in invocation; 1 expected
  call SysSleep 0, 0

::method test_sleep_invalid
  self~expectSyntax(88.902) -- The delay argument must be a number
  call SysSleep ""

::method test_sleep_invalid_negative
  self~expectSyntax(88.907) -- Argument delay must be in the range 0 to 2147483; found "-1"
  call SysSleep -0.01

::method test_sleep_invalid_too_large
  self~expectSyntax(88.907) -- Argument delay must be in the range 0 to 2147483; found "-1"
  call SysSleep 2147483.1

::method test_sleep_duration
  -- on Windows SysSleep uses Sleep() for up to 333 ms, and SetTimer when longer
  do duration over 0, 0.0, 0.00000001, 0.001, 0.1, 0.016, 0.2, 0.333, 0.5
    self~assertSleepDuration(duration)
  end

::method test_sleep_concurrent
  -- start concurrently
  wait = .Array~new
  assert = .Array~new
  do duration over 4.99, 3, 2.4, 1.333
    wait~append(self~start("assertSleepDuration", duration, assert))
  end
  -- wait for all of them to finish
  do w over wait
    w~wait
  end
  if assert~items > 0 then
    self~assertFail(assert[1])

-- assert that the given duration (with some leeway) is slept
::method assertSleepDuration unguarded
  use strict arg duration, assert = .true
  call time "r"
  r = SysSleep(duration)
  elapsed = time("e") / 1 -- remove trailing zeroes
  min = (duration - self~tooEarly)~max(0) -- must not be less than 0
  max = duration + self~tooLate
  -- when being called concurrently, we cannot allow concurrent asserts
  -- as the framework doesn't support multiple failures
  if assert == .true then do
    -- not concurrent: we can assert
    self~assertSame(0, r, "SysSleep("duration") should return 0")
    self~assertTrue(min <= elapsed & elapsed <= max, "SysSleep("duration") took" elapsed "but should take between" min "and" max "seconds")
  end
  else do
    -- concurrent: we must not assert
    -- we instead save all failure messages
    if r \== 0
      then assert~append("SysSleep("duration") should return 0, not" r)
    if \(min <= elapsed & elapsed <= max)
      then assert~append("SysSleep("duration") took" elapsed "but should take between" min "and" max "seconds")
  end

::options all syntax
