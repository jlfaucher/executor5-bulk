#!/usr/bin/rexx
/*
   name:             CONSTANT.testGroup
   author:           Rick McGuire
   date:             2007-12-29
   version:          1.0.0

-- line commented lines are ignored, when building the directory of infos from this header
   changed:          ---

   languageLevel:    6.03
   purpose:          Test the ::CONSTANT directive
   remark:

   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

   category1:        ooRexx
   category2:        Base
   category3:        directive
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007-2008 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . fileSpec
  group = .TestGroup~new(fileSpec)

  group~add(.CONSTANT.testGroup)
  group~add(.ConstantSyntaxErrs)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult
-- End of entry point.

::requires 'ooTest.frm'
::requires "FileUtils.cls"

::class "CONSTANT.testGroup" subclass ooTestCase public

::method "test_direct_definition"

  self~assertEquals("Fred", .test~s1, "s1_class")
  self~assertEquals("Rick", .test~s2, "s2_class")
  self~assertEquals(" ", .test~s3, "s3_class")
  self~assertEquals(" ", .test~s4, "s4_class")
  self~assertEquals("1", .test~n1, "n1_class")
  self~assertEquals("1.00000000000000000000", .test~n2, "n2_class")
  self~assertEquals(".23", .test~n3, "n3_class")
  self~assertEquals("1E4", .test~n4, "n4_class")
  self~assertEquals("1E-4", .test~n5, "n5_class")
  self~assertEquals("1E+4", .test~n6, "n6_class")
  self~assertEquals("23.38885e-5", .test~n7, "n7_class")
  self~assertEquals(".NIL", .test~c1, "c1_class")
  self~assertEquals(".", .test~c2, "c2_class")

  t = .test~new

  self~assertEquals("Fred", t~s1, "s1_instance")
  self~assertEquals("Rick", t~s2, "s2_instance")
  self~assertEquals(" ", t~s3, "s3_instance")
  self~assertEquals(" ", t~s4, "s4_instance")
  self~assertEquals("1", t~n1, "n1_instance")
  self~assertEquals("1.00000000000000000000", t~n2, "n2_instance")
  self~assertEquals(".23", t~n3, "n3_instance")
  self~assertEquals("1E4", t~n4, "n4_instance")
  self~assertEquals("1E-4", t~n5, "n5_instance")
  self~assertEquals("1E+4", t~n6, "n6_instance")
  self~assertEquals("23.38885e-5", t~n7, "n7_instance")
  self~assertEquals(".NIL", t~c1, "c1_instance")
  self~assertEquals(".", t~c2, "c2_instance")

  self~assertEquals("Fred", t~class~s1, "s1_instance_class")
  self~assertEquals("Rick", t~class~s2, "s2_instance_class")
  self~assertEquals(" ", t~class~s3, "s3_instance_class")
  self~assertEquals(" ", t~class~s4, "s4_instance_class")
  self~assertEquals("1", t~class~n1, "n1_instance_class")
  self~assertEquals("1.00000000000000000000", t~class~n2, "n2_instance_class")
  self~assertEquals(".23", t~class~n3, "n3_instance_class")
  self~assertEquals("1E4", t~class~n4, "n4_instance_class")
  self~assertEquals("1E-4", t~class~n5, "n5_instance_class")
  self~assertEquals("1E+4", t~class~n6, "n6_instance_class")
  self~assertEquals("23.38885e-5", t~class~n7, "n7_instance_class")
  self~assertEquals(".NIL", t~class~c1, "c1_instance_class")
  self~assertEquals(".", t~class~c2, "c2_instance_class")


::method "test_subclass_definition"

  self~assertEquals("Fred", .test2~s1, "s1_class")
  self~assertEquals("Rick", .test2~s2, "s2_class")
  self~assertEquals(" ", .test2~s3, "s3_class")
  self~assertEquals(" ", .test2~s4, "s4_class")
  self~assertEquals("1", .test2~n1, "n1_class")
  self~assertEquals("1.00000000000000000000", .test2~n2, "n2_class")
  self~assertEquals(".23", .test2~n3, "n3_class")
  self~assertEquals("1E4", .test2~n4, "n4_class")
  self~assertEquals("1E-4", .test2~n5, "n5_class")
  self~assertEquals("1E+4", .test2~n6, "n6_class")
  self~assertEquals("23.38885e-5", .test2~n7, "n7_class")
  self~assertEquals(".NIL", .test2~c1, "c1_class")
  self~assertEquals(".", .test2~c2, "c2_class")

  t = .test2~new

  self~assertEquals("Fred", t~s1, "s1_instance")
  self~assertEquals("Rick", t~s2, "s2_instance")
  self~assertEquals(" ", t~s3, "s3_instance")
  self~assertEquals(" ", t~s4, "s4_instance")
  self~assertEquals("1", t~n1, "n1_instance")
  self~assertEquals("1.00000000000000000000", t~n2, "n2_instance")
  self~assertEquals(".23", t~n3, "n3_instance")
  self~assertEquals("1E4", t~n4, "n4_instance")
  self~assertEquals("1E-4", t~n5, "n5_instance")
  self~assertEquals("1E+4", t~n6, "n6_instance")
  self~assertEquals("23.38885e-5", t~n7, "n7_instance")
  self~assertEquals(".NIL", t~c1, "c1_instance")
  self~assertEquals(".", t~c2, "c2_instance")

  self~assertEquals("Fred", t~class~s1, "s1_instance_class")
  self~assertEquals("Rick", t~class~s2, "s2_instance_class")
  self~assertEquals(" ", t~class~s3, "s3_instance_class")
  self~assertEquals(" ", t~class~s4, "s4_instance_class")
  self~assertEquals("1", t~class~n1, "n1_instance_class")
  self~assertEquals("1.00000000000000000000", t~class~n2, "n2_instance_class")
  self~assertEquals(".23", t~class~n3, "n3_instance_class")
  self~assertEquals("1E4", t~class~n4, "n4_instance_class")
  self~assertEquals("1E-4", t~class~n5, "n5_instance_class")
  self~assertEquals("1E+4", t~class~n6, "n6_instance_class")
  self~assertEquals("23.38885e-5", t~class~n7, "n7_instance_class")
  self~assertEquals(".NIL", t~class~c1, "c1_instance_class")
  self~assertEquals(".", t~class~c2, "c2_instance_class")


::method "test_mixinclass_definition"

  self~assertEquals("Fred", .test3~s1, "s1_class")
  self~assertEquals("Rick", .test3~s2, "s2_class")
  self~assertEquals(" ", .test3~s3, "s3_class")
  self~assertEquals(" ", .test3~s4, "s4_class")
  self~assertEquals("1", .test3~n1, "n1_class")
  self~assertEquals("1.00000000000000000000", .test3~n2, "n2_class")
  self~assertEquals(".23", .test3~n3, "n3_class")
  self~assertEquals("1E4", .test3~n4, "n4_class")
  self~assertEquals("1E-4", .test3~n5, "n5_class")
  self~assertEquals("1E+4", .test3~n6, "n6_class")
  self~assertEquals("23.38885e-5", .test3~n7, "n7_class")
  self~assertEquals(".NIL", .test3~c1, "c1_class")
  self~assertEquals(".", .test3~c2, "c2_class")

  t = .test3~new

  self~assertEquals("Fred", t~s1, "s1_instance")
  self~assertEquals("Rick", t~s2, "s2_instance")
  self~assertEquals(" ", t~s3, "s3_instance")
  self~assertEquals(" ", t~s4, "s4_instance")
  self~assertEquals("1", t~n1, "n1_instance")
  self~assertEquals("1.00000000000000000000", t~n2, "n2_instance")
  self~assertEquals(".23", t~n3, "n3_instance")
  self~assertEquals("1E4", t~n4, "n4_instance")
  self~assertEquals("1E-4", t~n5, "n5_instance")
  self~assertEquals("1E+4", t~n6, "n6_instance")
  self~assertEquals("23.38885e-5", t~n7, "n7_instance")
  self~assertEquals(".NIL", t~c1, "c1_instance")
  self~assertEquals(".", t~c2, "c2_instance")

  self~assertEquals("Fred", t~class~s1, "s1_instance_class")
  self~assertEquals("Rick", t~class~s2, "s2_instance_class")
  self~assertEquals(" ", t~class~s3, "s3_instance_class")
  self~assertEquals(" ", t~class~s4, "s4_instance_class")
  self~assertEquals("1", t~class~n1, "n1_instance_class")
  self~assertEquals("1.00000000000000000000", t~class~n2, "n2_instance_class")
  self~assertEquals(".23", t~class~n3, "n3_instance_class")
  self~assertEquals("1E4", t~class~n4, "n4_instance_class")
  self~assertEquals("1E-4", t~class~n5, "n5_instance_class")
  self~assertEquals("1E+4", t~class~n6, "n6_instance_class")
  self~assertEquals("23.38885e-5", t~class~n7, "n7_instance_class")
  self~assertEquals(".NIL", t~class~c1, "c1_instance_class")
  self~assertEquals(".", t~class~c2, "c2_instance_class")


::class test mixinclass object
::CONSTANT s1 'Fred'
::constant S2 "Rick"
::constant s3 '20'x
::ConStanT 'S4' '00100000'b
::constant 'n1' 1
::constant 'n2' 1.00000000000000000000
::constant 'N3' .23
::constant n4 1e4
::constant n5 1e-4
::constant n6 1e+4
::constant n7 23.38885e-5
::constant c1 .nil
::constant c2 .

::class test2 subclass test

::class test3 inherit test


/** This class tests syntax errors for the constant directive.  Since putting
 *  incorrect syntax for the directive in this file would cause the test group
 *  to not run, the bad syntax tests are done by writing out a Rexx program
 *  with the incorrect syntax.
 */
::class "ConstantSyntaxErrs" public subclass ooTestCase

  -- A, maybe, temporary measure.  Currently the test framework only allows
  -- adding more than one test case object to a test group when the test types
  -- of the test case objects are different.  The rationale being that different
  -- test types would be in separate test group files.  In the future that
  -- restriction may be changed, or this class may be moved to a separate file.
  -- In the mean time, a work around is to make this class a different test case
  -- type.
  ::method init class
    forward class (super) continue
    self~ooTestType = self~UNIT_LONG_TEST

  ::attribute functionFileName

  ::method setUp
    use arg testResult

     file = .ooRexxUnit.dir || .ooRexxUnit.directory.separator || 'testConstant.rex'

     src = .array~new()
     src[1] = "/* This is a temporary file for testing the constant directive. */"
     src[2] = "/* This file can always be deleted. */"
     src[3] = ""
     src[4] = "t = .TestClass~new"
     src[5] = ""
     self~functionFileName = createFile(src, file)

     -- If self~functionFileName is the empty string, an error happened.  It
     -- would be nice at this point to end the test.

  -- tearDown() is invoked after every test case method has executed.  Use this
  -- opportunity to ensure that the temporary files are deleted.
  ::method tearDown
    j = deleteFile(self~functionFileName)

  ::method test_bad_syntax_object

    -- First assert that the start of the source file has been created.  This
    -- allows for failing the test if there is some problem creating the file.
    self~assertNotSame("", self~functionFileName, "Must be able to create source file")

    src = .array~new
    src[1] = "return 0"
    src[2] = "::class 'TestClass'"
    src[3] = "::constant MESSAGE_PRODUCER (.Message~class)"
    name = addToFile(src, self~functionFileName)

    self~expectSyntax(19.916)
    ret = 'testConstant'()

  ::method  test_duplicate_name
    self~assertNotSame("", self~functionFileName, "Must be able to create source file")

    src = .array~new
    src[1] = "return 0"
    src[2] = ""
    src[3] = "::class 'TestClass'"
    src[4] = "::constant PI 3.14195"
    src[5] = "::constant ZERO 0.0"
    src[6] = "::constant PI 3.14195"
    name = addToFile(src, self~functionFileName)

    self~expectSyntax(99.932)
    ret = 'testConstant'()

  ::method  test_duplicate_name_floating_methods
    self~assertNotSame("", self~functionFileName, "Must be able to create source file")

    src = .array~new
    src[1] = "return 0"
    src[2] = ""
    src[3] = "::constant MAX_DOGS_PER_HOUSEHOLD 6"
    src[4] = "::constant MAX_CATS_PER_HOUSEHOLD 0"
    src[5] = "::constant MAX_CATS_PER_HOUSEHOLD 0"
    src[6] = ""
    src[7] = "::class 'TestClass'"
    src[8] = "::constant PI 3.14195"
    src[9] = "::constant ZERO 0.0"
    name = addToFile(src, self~functionFileName)

    self~expectSyntax(99.932)
    ret = 'testConstant'()

  ::method  test_code_after_directive
    self~assertNotSame("", self~functionFileName, "Must be able to create source file")

    src = .array~new
    src[1] = "return .TestClass~MAX_DOGS_PER_HOUSEHOLD"
    src[2] = ""
    src[3] = "::class 'TestClass'"
    src[4] = "::constant PI 3.14195"
    src[5] = "::constant ZERO 0.0"
    src[6] = "::constant MAX_DOGS_PER_HOUSEHOLD 6"
    src[7] = "  return 14"
    src[8] = "::constant MAX_CATS_PER_HOUSEHOLD 0"
    name = addToFile(src, self~functionFileName)

    self~expectSyntax(99.916)
    ret = 'testConstant'()

  ::method  test_code_after_directive_floating_method
    self~assertNotSame("", self~functionFileName, "Must be able to create source file")

    src = .array~new
    src[1] = "::constant MAX_DOGS_PER_HOUSEHOLD 6"
    src[2] = "::constant MAX_CATS_PER_HOUSEHOLD 0"
    src[3] = ""
    src[4] = "return 0"
    src[5] = ""
    src[6] = "::class 'TestClass'"
    src[7] = "::constant PI 3.14195"
    src[8] = "::constant ZERO 0.0"
    name = addToFile(src, self~functionFileName)

    self~expectSyntax(99.916)
    ret = 'testConstant'()

  ::method  test_extra_values
    self~assertNotSame("", self~functionFileName, "Must be able to create source file")

    src = .array~new
    src[1] = "return 0"
    src[2] = ""
    src[3] = "::class 'TestClass'"
    src[4] = "::constant PI 3.14195"
    src[5] = "::constant ZERO 0.0"
    src[6] = "::constant MAX_NUMS 5 6 7"
    name = addToFile(src, self~functionFileName)

    self~expectSyntax(21.913)
    ret = 'testConstant'()

  ::method  test_no_values
    self~assertNotSame("", self~functionFileName, "Must be able to create source file")

    src = .array~new
    src[1] = "return 0"
    src[2] = ""
    src[3] = "::class 'TestClass'"
    src[4] = "::constant PI"
    src[5] = "::constant ZERO 0.0"
    src[6] = "::constant MAX_NUMS 5"
    name = addToFile(src, self~functionFileName)

    self~expectSyntax(19.916)
    ret = 'testConstant'()

  ::method  test_math_expression
    self~assertNotSame("", self~functionFileName, "Must be able to create source file")

    src = .array~new
    src[1] = "return 0"
    src[2] = ""
    src[3] = "::class 'TestClass'"
    src[4] = "::constant NO_ERR_RC       0"
    src[5] = "::constant BAD_FILENAME_RC 0 + 1"
    src[6] = "::constant READONLY_RC     0 + 2"
    src[7] = "::constant ZERO 0.0"
    src[8] = "::constant MAX_NUMS 5"
    name = addToFile(src, self~functionFileName)

    self~expectSyntax(21.913)
    ret = 'testConstant'()
