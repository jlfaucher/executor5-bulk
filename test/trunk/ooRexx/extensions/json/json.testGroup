#!/usr/bin/env rexx
/*
  SVN Revision: $Rev$
  Change Date:  $Date$
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007-2020 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
parse source . . fileSpec
group = .TestGroup~new(fileSpec)
group~add(.json.testGroup)
if group~isAutomatedTest then
  return group
else
  return group~suite~execute~~print

::requires 'ooTest.frm' -- load the ooRexxUnit classes
::requires 'json.cls'
::class "JSON.testGroup" public subclass ooTestCase

::method init
  expose thisDir     -- the location of this testGroup, including the trailing slash
  parse source . . s
  thisDir=filespec("Location",s) -- save this testGroup's directory (with trailing slash)
  forward class (super)

::method test_01_valid_json_files
  expose thisDir

  parser=.json~new    -- get a JSON parser instance
  search=thisDir'valid\*.json'
  call sysFileTree search, 'file', 'fo'
  do i = 1 to file.0
      self~assertTrue(self~check_valid_json_file(parser, file.i))
  end

::method check_valid_json_file      -- the received files are valid JSON files
   use strict arg parser, fileName

-- signal on syntax
   data=readFile(fileName)
   parser~fromJson(data)
   return .true
syntax:
   return .false

------------------------------------------------------------------------------

::method test_02_invalid_json_files
  expose thisDir

  parser=.json~new    -- get a JSON parser instance
  search=thisDir'invalid\*.json'
  call sysFileTree search, 'file', 'fo'
  do i = 1 to file.0
      self~assertTrue(self~check_invalid_json_file(parser, file.i))
  end


::method check_invalid_json_file    -- the received files are invalid JSON files
   use strict arg parser, fileName

   signal on syntax
   data=readFile(fileName)
   parser~fromJson(data)      -- a syntax error must be raised (3.900)
   return .false              -- assertion does not hold!
syntax:
   return .true               -- assertion holds (syntax error occurred)

------------------------------------------------------------------------------

::method test_invalid_empty
  self~expectSyntax(3.900) -- Invalid JSON value
  .Json~new~fromJson("")

::method test_invalid_empty_whitespace
  self~expectSyntax(3.900) -- Invalid JSON value
  .Json~new~fromJson('09'x)

::method test_invalid_literal
  self~expectSyntax(3.900) -- Invalid JSON value
  .Json~new~fromJson("nullstring")


-- According to its grammar, a JSON text can be true, false, null,
-- or a number, a string, an array, or an object.


-- true, false, null literals
::method test_literals
  j = .Json~new
  self~assertSame(1, j~fromJson("true"))
  self~assertSame(1, j~fromJson(" true"))
  self~assertSame(0, j~fromJson("false"))
  self~assertSame(0, j~fromJson("false" '09'x))
  self~assertSame(.nil, j~fromJson("null"))
  self~assertSame(.true, j~toJson(.true))
  self~assertSame(.false, j~toJson(.false))
  self~assertSame("null", j~toJson(.nil))


-- number

::method test_number_invalid_nan
  self~expectSyntax(3.900) -- Invalid JSON value
  .Json~new~fromJson("NaN")

::method test_number_invalid_double_minus
  self~expectSyntax(3.900) -- Invalid JSON value
  .Json~new~fromJson("--1")

::method test_number_invalid_exponential
  self~expectSyntax(3.900) -- Invalid JSON value
  .Json~new~fromJson("1e")

::method test_number
  -- strictly speaking, the JSON number grammar doesn't allow numbers like
  -- 0123, 1., +3, or .2
  -- json.cls allows for all valid Rexx numbers
  -- https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf
  -- number ::= '-'? ('0' | [1-9] [0-9]+) ('.' [0-9]+)? (('e' | 'E') ( | '+' | '-') [0-9]+)?

  j = .Json~new
  -- integer
  do number over 0, 1, -4, 0123, 12345678901234567890
    self~assertSame(number, j~toJson(j~fromJson(number)))
  end

  -- fractions
  do number over 1.2, .2, -0.003, 0.00000000000000
    self~assertSame(number, j~toJson(j~fromJson(number)))
  end

  -- exponential
  do number over "1e0", "-1E0", 1E999999999, -2e5, 1e-9, -9e-9, 0.00003e4, -1.23e0
    self~assertSame(number, j~toJson(j~fromJson(number)))
  end

  -- whitespace
  number = 123
  self~assertSame(number, j~toJson(j~fromJson(" " number)))
  self~assertSame(number, j~toJson(j~fromJson(number || '0d 0a'x)))
  self~assertSame(number, j~toJson(j~fromJson('20 0d 09 0a'x || number || '0a 09 20 0a'x)))


-- string

::method test_string_invalid_missing_quote
  self~expectSyntax(3.900) -- Invalid JSON value
  .Json~new~fromJson('"')

::method test_string_invalid_superfluous_quote
  self~expectSyntax(3.900) -- Invalid JSON value
  .Json~new~fromJson('"""')

::method test_string_invalid_escape
  self~expectSyntax(3.900) -- Invalid JSON value
  .Json~new~fromJson('"\x"')

::method test_string
  j = .Json~new
  -- standard
  do string over '""', '" "', '"' || "x"~copies(256) || '"'
    self~assertSame(string, j~toJson(j~fromJson(string)))
  end

  -- whitespace
  string = '"abc"'
  self~assertSame(string, j~toJson(j~fromJson(" " string)))
  self~assertSame(string, j~toJson(j~fromJson(string || '0d 0a'x)))
  self~assertSame(string, j~toJson(j~fromJson('20 0d 09 0a'x || string || '0a 09 20 0a'x)))


::method test_string_escape
  j = .Json~new

  -- All code points may be placed within the quotation marks except for
  -- quote, backslash, and the control characters '00'x through '1f'x
  -- which must be escaped.  There are eight two-character escape
  -- sequence representations \" \\ \/ \b \f \n \r \t.

  -- for control character without two-character escapes \u00XX is used
  do c over xrange('00'x, '07'x, '0b'x, '0b'x, '0e'x, '1f'x)~makeArray("")
    self~assertSame(c, j~fromJson('"\u00' || c~c2x ||'"'))
    self~assertSame('"\u00' || c~c2x ||'"', j~toJson(c))
  end

  self~assertSame('"', j~fromJson('"\""'))
  self~assertSame("\", j~fromJson('"\\"'))
  self~assertSame("/", j~fromJson('"\/"'))
  self~assertSame('08'x, j~fromJson('"\b"'))
  self~assertSame('0c'x, j~fromJson('"\f"'))
  self~assertSame('0a'x, j~fromJson('"\n"'))
  self~assertSame('0d'x, j~fromJson('"\r"'))
  self~assertSame('09'x, j~fromJson('"\t"'))

  self~assertSame('"\""', j~toJson('"'))
  self~assertSame('"\\"', j~toJson("\"))
  self~assertSame('"\/"', j~toJson("/"))
  self~assertSame('"\b"', j~toJson('08'x))
  self~assertSame('"\f"', j~toJson('0c'x))
  self~assertSame('"\n"', j~toJson('0a'x))
  self~assertSame('"\r"', j~toJson('0d'x))
  self~assertSame('"\t"', j~toJson('09'x))


-- array

::method test_array_invalid_missing_bracket
  self~expectSyntax(3.900) -- Invalid JSON value
  .Json~new~fromJson("[")

::method test_array_invalid_missing_value
  self~expectSyntax(3.900) -- Invalid JSON value
  .Json~new~fromJson("[1,]")

::method test_array
  j = .Json~new

  -- simple
  do array over "[]", "[1]", "[2,3]", '[2, "string"]', '[3, "mno", "xyz"]'
    r = j~fromJson(array)
    self~assertIsA(r, .Array)
    self~assertSame((r[1] = .nil)~?(0, r[1]), r~items)
    self~assertSame(array~space(0), j~toJson(r))
  end

  -- nested
  nested = j~fromJson('[1, "string", []]')
  self~assertIsA(nested, .Array)
  self~assertSame(3, nested~items)
  self~assertSame(1, nested[1])
  self~assertSame("string", nested[2])
  self~assertIsA(nested[3], .Array)
  self~assertSame(0, nested[3]~items)

  -- whitespace
  do array over " [ ]", '[ "abc" ]', " [ 2  , 3 ] ", '09'x || "[" || '09'x || "]" || '09'x
    self~assertIsA(j~fromJson(array), .Array)
  end


-- object

::method test_object_invalid_missing_brace
  self~expectSyntax(3.900) -- Invalid JSON value
  .Json~new~fromJson("{")

::method test_object_invalid_missing_value
  self~expectSyntax(3.900) -- Invalid JSON value
  .Json~new~fromJson('{"name": }')

::method test_object
  j = .Json~new

  json = "{}"
  dir = j~fromJson(json)
  self~assertIsA(dir, .Directory)
  self~assertSame(0, dir~items)
  self~assertSame(json, j~toJson(dir))

  json = '{"name": "value"}'
  dir = j~fromJson(json)
  self~assertIsA(dir, .Directory)
  self~assertSame(1, dir~items)
  self~assertSame("value", dir["name"])



::routine readFile            -- reads all bytes from the file and returns them
  use strict arg fileName

  file  =.file~new(fileName)  -- get file object
  stream=.stream~new(file)    -- get stream to read from it
  data = stream~charIn(1,file~length)  -- get data
  stream~close
  return data                 -- return read data


::options novalue error
