#!/usr/bin/rexx
/*
   name:             ooRexx.Base.String.testUnit
   author:           Rony G. Flatscher
   date:             2005-08-07
   version:          1.0.4

-- line commented lines are ignored, when building the directory of infos from this header
   changed:          2005-08-21, ---rgf, renamed the testUnit-class to match exactly the
                             file name, i.e. a dot (.) between class name and "TestUnit";
                             added convention to return a list of arrays containing the
                             test case class object and an optional list of mandatory test
                             case methods from it
                     2005-10-09, ---rgf, renamed from ".String." to ".BIF." to reflect the testing area
                             "BIF": "built in function"
                     2005-10-11, ---rgf, finished first round of testing the documentation
                             BIF examples
                     2005-10-17, ---rgf, added Walter Pachl's Errornumber()-tests
                     2006-11-12, ---rgf, removed a wrong comment
                     2007-01-20, ---rgf, adapted "test_SOURCELINE" to cater for hash-bang processing
                     2007-03-21, ---rgf, added 6.01 datatype(value, 'O') test
                     2007-03-26, ---rgf, finally corrected the sequence of "expected" and "actual" value
                                         for assert[Not]Equals() and assert[Not]Same()
                     2007-05-30, ---rgf, in language level 6.02 error text number 89 gets a text, adjusted
                     2007-06-10, ---rgf, added test cases for lower() and upper() BIFs;
                                         added test cases to test whether TAB and blank chars are
                                         really treated equal in all related BIFs
                     2007-06-11, ---rgf, added TAB=blank test case for PARSE

   languageLevel:    6.02
   purpose:          Test the String functions.
   remark:           Initial test unit for demonstration purposes, needs to be completed.

                     Following BIFs are missing: CHARIN, CHAROUT, CHARS, CONDITION, DIRECTORY,
                                                 ENDLOCAL, FILESPEC, LINEIN, LINEOUT, LINES,
                                                 QUEUED, RXFUNCADD, RXFUNCDROP, RXFUNCQUERY,
                                                 RXQUEUE, SETLOCAL, STREAM, TRACE, USERID


   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

   category1:        ooRexx
   category2:        Base
   category3:        BIF
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2005-2007 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/



-------------------------------------------------------------------------------------------
-- ===> adapt the "testUnitList" to your testCase classes; each element in the list is <===
-- ===> an array object, the first element containing the testCase class object, the   <===
-- ===> second element is a list of test method names which are regarded to be         <===
-- ===> mandatory (if the list remains empty all test methods are mandatory)           <===

   /* list of array objects, each containing the testUnit class object and an
      optional list of mandatory test case methods name                       */

mandatoryTestMethods=.list~new   -- no mandatory tests for this testCase class
testUnitList=.list~of( .array~of(.ooRexx.Base.BIF.testUnit,  mandatoryTestMethods) )


-------------------------------------------------------------------------------------------
-- ===> the following code needs not to be individualized                              <===

   -- read top comment, containing infos about this program
arrLines=.array~new
do i=1 to 150 until arrLines[i]="*/"
   arrLines[i]=sourceline(i)
end
      -- supply information for the testClass(es) in this file; the class attribute
      -- "TestCaseInfo" (a directory object, index points to a queue) will store
      -- the parsed infos
aTestUnitClass=testUnitList~at(testUnitList~first)[1] -- get first testClass

   -- will parse the array lines and store result in class object
call makeDirTestInfo aTestUnitClass, arrLines
tmpDir=aTestUnitClass~TestCaseInfo
parse source s   -- op_sys invocationType fullPathToThisFile
tmpDir~setentry("test_Case-source", s)

   -- now add this directory to other testCase classes, if any left
do arr over testUnitList
   if arr[1]=aTestUnitClass then iterate  -- already handled
   arr[1]~TestCaseInfo=tmpDir             -- save info in class object
end

-- if this file is CALLed or REQUIRED then define an entry "bRunTestLocally" in .local
-- and set it to .false; this way the independent local invocation of the tests is inhibited
if .local~hasentry("bRunTestsLocally")=.false then
   .local~bRunTestsLocally=.true -- if this file is executed directly, then run tests for debugging

if .bRunTestsLocally=.true then  -- run ALL tests in this test unit
do
   ts=.testSuite~new             -- create a testSuite
   do arr over testUnitList
      -- create a testSuite for the given test case class, use all its testmethods
      ts~addTest( .testSuite~new(arr[1]))
   end
   -- testResult=.testSuite~new(testUnitClass)~run
   testResult=ts~run       -- now run all the tests

   call simpleDumpTestResults testResult
end

   /* return list of array objects containing test case classes and
      optionally list of mandatory test methods                      */
return testUnitList



::requires ooRexxUnit.cls     -- load the ooRexxUnit classes

::class "ooRexx.Base.BIF.testUnit" subclass TestCase public

   -- test the ABBREV BIF, using examples from the documentation
::method "test_ABBREV"

   word="Print"
   self~assertSame("subTest1", .true , ABBREV(word, "Pri")    )

   word="PRINT"
   self~assertSame("subTest2", .false, ABBREV(word, "Pri")    )
   self~assertSame("subTest3", .false, ABBREV(word, "PRI", 4) )
   self~assertSame("subTest4", .false, ABBREV(word, "PRY")    )
   self~assertSame("subTest5", .true , ABBREV(word, "")       )
   self~assertSame("subTest6", .false, ABBREV(word, "", 1)    )


   -- test the BIF, using examples from the documentation
::method "test_ABS"

   self~assertSame("subTest1",  12.3 , ABS('12.3'),   )
   self~assertSame("subTest2",  0.307, ABS(' -0.307'),)

      -- new tests
   self~assertSame("subTest3",  0    , ABS(' -0'),    )
   self~assertSame("subTest4",  0    , ABS(' +0'),    )
   self~assertSame("subTest5",  0    , ABS(' - 0 '),  )
   self~assertSame("subTest6",  0    , ABS(' + 0 '),  )
   self~assertSame("subTest7",  1    , ABS(' -1'),    )
   self~assertSame("subTest8",  1    , ABS(' +1'),    )
   self~assertSame("subTest9",  1    , ABS(' - 1 '),  )
   self~assertSame("subTest10", 1    , ABS(' + 1 '),  )


   -- test the BIF
::method "test_ADDRESS"

   addr=address()       -- get default address environment (e.g. cmd.exe, bash, etc.)
   self~assertNotSame("subTest1",  addr~string~strip, "")   -- make sure something is returned
   self~assertNotSame("subTest2",  addr, .nil)              -- make sure something is returned

   -- test for default command processor
   parse source os .             -- get name of operating system
   os1=os~left(1)~translate      -- get first character in uppercase
   if pos(os1, "O W") > 0 then   -- OS2, Windows ?
   do
      self~assertSame("subTest3 - default address environment for" pp(os)"="pp(addr) "not" pp("CMD"), "CMD",  addr)
   end
   else if os1=="L" then         -- Linux
   do
      self~assertSame("subTest3 - default address environment for" pp(os)"="pp(addr) "not" pp("bash"), "bash", addr)
   end


   -- test the BIF, using examples from the documentation
::method "test_ARG"
  call name1               -- call procedure without arguments
  call name2 'a', , 'b'    -- call procedure with arguments

  exit

  name1:
    self~assertSame("subTest1",  0    , arg()             )
    self~assertSame("subTest2", ""    , arg(1)            )
    self~assertSame("subTest3", ""    , arg(2)            )
    self~assertSame("subTest4", .false, arg(1, 'e')       )
    self~assertSame("subTest5", .true , arg(1, 'o')       )
    self~assertSame("subTest6", 0     , arg(1, 'a')~items )
    return

  name2:
    self~assertSame("subTest7",   3    , arg()            )
    self~assertSame("subTest8",  "a"   , arg(1)           )
    self~assertSame("subTest9",  ""    , arg(2)           )
    self~assertSame("subTest10", "b"   , arg(3)           )
    self~assertSame("subTest11", ""    , arg(4)           )
    self~assertSame("subTest12", .true , arg(1, 'e')      )
    self~assertSame("subTest13", .false, arg(2, 'e')      )
    self~assertSame("subTest14", .true , arg(3, 'e')      )
    self~assertSame("subTest15", .false, arg(1, 'o')      )
    self~assertSame("subTest16", .true , arg(2, 'o')      )
    self~assertSame("subTest17", .false, arg(3, 'o')      )
    return



   -- test the BIF
::method "test_BEEP"

   call beep 262 /* middle C */, 1  /* 1/1000 second or standard beep */
   self~assertTrue(.true)     -- o.k., test went o.k. count assertion


   -- test the BIF, using examples from the documentation
::method "test_BITAND"
    self~assertSame("subTest1", '12'x   , BITAND('12'x)               )
    self~assertSame("subTest2", '23'x   , BITAND('73'x,'27'x)         )
    self~assertSame("subTest3", '1155'x , BITAND('13'x,'5555'x)       )
    self~assertSame("subTest4", '1154'x , BITAND('13'x,'5555'x,'74'x) )
    self~assertSame("subTest5", 'PQRS'  , BITAND('pQrS', ,'DF'x)      )


   -- test the BIF, using examples from the documentation
::method "test_BITOR"
    self~assertSame("subTest1", '12'x   , BITOR('12'x)               )
    self~assertSame("subTest2", '35'x   , BITOR('15'x,'24'x)         )
    self~assertSame("subTest3", '3556'x , BITOR('15'x,'2456'x)       )
    self~assertSame("subTest4", '35F6'x , BITOR('15'x,'2456'x,'F0'x) )
    self~assertSame("subTest5", '5D5D'x , BITOR('1111'x, ,'4D'x)     )
    self~assertSame("subTest6", 'pqrs'  , BITOR('pQrS', ,'20'x)      )


   -- test the BIF, using examples from the documentation
::method "test_BITXOR"
    self~assertSame("subTest1", '12'x     , BITXOR('12'x)                  )
    self~assertSame("subTest2", '30'x     , BITXOR('12'x,'22'x)            )
    self~assertSame("subTest3", '3011'x   , BITXOR('1211'x,'22'x)          )
    self~assertSame("subTest4", '555544'x , BITXOR('1111'x,'444444'x)      )
    self~assertSame("subTest5", '555504'x , BITXOR('1111'x,'444444'x,'40'x))
    self~assertSame("subTest6", '5C5C'x   , BITXOR('1111'x, ,'4D'x)        )
    self~assertSame("subTest7", 'E53302'x , BITXOR('C711'x,'222222'x,' ')  )


   -- test the BIF, using examples from the documentation
::method "test_C2D"
    self~assertSame("subTest1" , 0     ,  C2D('')       )

    self~assertSame("subTest2" , 9     ,  C2D('09'X)    )
    self~assertSame("subTest3" , 129   ,  C2D('81'X)    )
    self~assertSame("subTest4" , 65409 ,  C2D('FF81'X)  )
    self~assertSame("subTest5" , 0     ,  C2D("")       )
    self~assertSame("subTest6" , 97    ,  C2D('a')      )

    self~assertSame("subTest7" , -127  ,  C2D('81'X,1)  )
    self~assertSame("subTest8" , 129   ,  C2D('81'X,2)  )
    self~assertSame("subTest9" , -127  ,  C2D('FF81'X,2))
    self~assertSame("subTest10", -127  , C2D('FF81'X,1) )
    self~assertSame("subTest11", 127   , C2D('FF7F'X,1) )
    self~assertSame("subTest12", -3967 , C2D('F081'X,2) )
    self~assertSame("subTest13", -127  , C2D('F081'X,1) )
    self~assertSame("subTest14", 0     , C2D('0031'X,0) )



   -- test the BIF, using examples from the documentation
::method "test_C2X"
    self~assertSame("subTest1", ""       , C2X('')     )

    self~assertSame("subTest2", '0123'   , C2X('0123'X)) /* '30313233'X in ASCII */
    self~assertSame("subTest3", '5A4438' , C2X('ZD8')  ) /* '354134343338'X in ASCII */



   -- test the BIF, using examples from the documentation
::method "test_CENTER"
    self~assertSame("subTest1", '  ABC  '  , CENTER(abc,7)            )
    self~assertSame("subTest2", '--ABC---' , CENTER(abc,8,'-')        )
    self~assertSame("subTest3", 'e blue s' , CENTRE('The blue sky',8) )
    self~assertSame("subTest4", 'e blue '  , CENTRE('The blue sky',7) )


   -- test the BIF, using examples from the documentation
::method "test_CHANGESTR"
    self~assertSame("subTest1", '000'    , CHANGESTR('1','101100',"")  )
    self~assertSame("subTest2", 'X0XX00' , CHANGESTR('1','101100','X') )

   -- new tests
    self~assertSame("subTest3", '101100' , CHANGESTR('','101100','X')  )
    self~assertSame("subTest4", ''       , CHANGESTR('1',''     ,'X')  )


   -- test the BIF, using examples from the documentation
::method "test_COMPARE"
    self~assertSame("subTest1", 0 , COMPARE('abc','abc')     )
    self~assertSame("subTest2", 2 , COMPARE('abc','ak')      )
    self~assertSame("subTest3", 0 , COMPARE('ab ','ab')      )
    self~assertSame("subTest4", 0 , COMPARE('ab ','ab',' ')  )
    self~assertSame("subTest5", 3 , COMPARE('ab ','ab','x')  )
    self~assertSame("subTest6", 5 , COMPARE('ab-- ','ab','-'))

   -- new tests
    self~assertSame("subTest7", 0 ,  COMPARE(''     ,''  ,'-'))
    self~assertSame("subTest8", 2 ,  COMPARE(' '    ,'  ','-'))
    self~assertSame("subTest9", 2 ,  COMPARE('  '   ,' ' ,'-'))
    self~assertSame("subTest10", 0 , COMPARE(' '    ,' ' ,'-'))


   -- test the BIF, using examples from the documentation
::method "test_COPIES"
    self~assertSame("subTest1", 'abcabcabc' , COPIES('abc',3))
    self~assertSame("subTest2", ""          , COPIES('abc',0))


   -- test the BIF, using examples from the documentation
::method "test_COUNTSTR"
    self~assertSame("subTest1", 4 , COUNTSTR('1','101101') )
    self~assertSame("subTest2", 1 , COUNTSTR('KK','J0KKK0'))

   -- new tests
    self~assertSame("subTest3", 0 , COUNTSTR('','J0KKK0')  )
    self~assertSame("subTest4", 0 , COUNTSTR(' ','J0KKK0') )


   -- test the BIF, using examples from the documentation
::method "test_D2C"
    self~assertSame("subTest1", 'A'                  , D2C(65)    )
    self~assertSame("subTest2", 'A'                  , D2C(65,1)  )
    self~assertSame("subTest3", right('A', 2, "00"x) , D2C(65,2)  )
    self~assertSame("subTest4", right('A', 5, "00"x) , D2C(65,5)  )
    self~assertSame("subTest5", 'm'                  , D2C(109)   ) /* '6D'x is an ASCII 'm' */
    self~assertSame("subTest6", '93'x                , D2C(-109,1)) /* '93'x is an ASCII 'ô' */
    self~assertSame("subTest7", right('L', 2, "00"x) , D2C(76,2)  ) /* '4C'x is an ASCII ' L' */
    self~assertSame("subTest8", right('L', 2, "FF"x) , D2C(-180,2))

   -- new tests
    self~assertSame("subTest9", ""                   , D2C(-180,0))


   -- test the BIF, using examples from the documentation
::method "test_D2X"
    self~assertSame("subTest1", '9'    , D2X(9)     )
    self~assertSame("subTest2", '81'   , D2X(129)   )
    self~assertSame("subTest3", '1'    , D2X(129,1) )
    self~assertSame("subTest4", '81'   , D2X(129,2) )
    self~assertSame("subTest5", '0081' , D2X(129,4) )
    self~assertSame("subTest6", '01'   , D2X(257,2) )
    self~assertSame("subTest7", '81'   , D2X(-127,2))
    self~assertSame("subTest8", 'FF81' , D2X(-127,4))
    self~assertSame("subTest9", ""     , D2X(12,0)  )


   -- test the BIF, using examples from the documentation
::method "test_DATATYPE"
    self~assertEquals("subTest1" , 'NUM'  , DATATYPE(' 12 ')     )
    self~assertEquals("subTest2" , 'CHAR' , DATATYPE("")         )
    self~assertEquals("subTest3" , 'CHAR' , DATATYPE('123*')     )

    self~assertTrue("subTest4"  , DATATYPE('12.3','N')  )
    self~assertFalse("subTest5" , DATATYPE('12.3','W')  )
    self~assertTrue("subTest6"  , DATATYPE('Fred','M')  )
    self~assertFalse("subTest7" , DATATYPE('Fred','U')  ) -- changed, syntax error in documentation !
    self~assertFalse("subTest8" , DATATYPE('Fred','L')  )
    self~assertTrue("subTest9"  , DATATYPE('?20K','s')  )
    self~assertTrue("subTest10" , DATATYPE('BCd3','X')  )
    self~assertTrue("subTest11" , DATATYPE('BC d3','X') )

   -- new tests
    self~assertTrue("subTest12" , DATATYPE('',     'X') )

    self~assertTrue("subTest13" , DATATYPE('BCd3' ,'A') ) -- alphanumeric
    self~assertFalse("subTest14", DATATYPE('BC-d3','A') )

    self~assertTrue("subTest15" , DATATYPE('a1'   ,'s') ) -- symbol
    self~assertTrue("subTest16" , DATATYPE('.a1'  ,'s') )
    self~assertTrue("subTest17" , DATATYPE('_'    ,'s') )
    self~assertTrue("subTest18" , DATATYPE('!'    ,'s') )
    self~assertTrue("subTest19" , DATATYPE('?'    ,'s') )
    self~assertTrue("subTest20" , DATATYPE('.'    ,'s') )
    self~assertTrue("subTest21" , DATATYPE('1'    ,'s') )
    self~assertTrue("subTest22" , DATATYPE('1b_!?','s') )
    self~assertFalse("subTest23", DATATYPE('. .'  ,'s') )

    self~assertTrue("subTest24" , DATATYPE('abc'  ,'v') ) -- variable
    self~assertTrue("subTest25" , DATATYPE('?'    ,'v') )
    self~assertTrue("subTest26" , DATATYPE('_'    ,'v') )
    self~assertTrue("subTest27" , DATATYPE('!'    ,'v') )
    self~assertTrue("subTest28" , DATATYPE('a1!_?','v') )
    self~assertFalse("subTest29", DATATYPE('.'    ,'v') )
    self~assertFalse("subTest30", DATATYPE('.a'   ,'v') )
    self~assertFalse("subTest31", DATATYPE('1'    ,'v') )


    a=digits()          -- get digits
    numeric digits 9
    self~assertTrue( "subTest32", DATATYPE('0'    ,'W')  ) -- whole number
    self~assertTrue( "subTest33", DATATYPE('1'    ,'W')  )
    self~assertTrue( "subTest34", DATATYPE('-1'   ,'W')  )
    self~assertTrue( "subTest35", DATATYPE('12345','W')  )
    self~assertTrue( "subTest36", DATATYPE('1E3'  ,'W')  )
    self~assertFalse("subTest37", DATATYPE('1E9'  ,'W')  )

    numeric digits a

    self~assertFalse("subTest44", DATATYPE('z'  ,'X')  )    -- heX-digits
    self~assertTrue( "subTest45", DATATYPE(''  ,'X')   )

    self~assertFalse("subTest46", DATATYPE('z'  ,'B')         )   -- binary digits
    self~assertTrue( "subTest47", DATATYPE(''  ,'B')          )
    self~assertTrue( "subTest48", DATATYPE('01'  ,'B')        )
    self~assertTrue( "subTest49", DATATYPE('01101001'  ,'B')  )
    self~assertTrue( "subTest50", DATATYPE('0110 1001'  ,'B') )
    self~assertFalse("subTest51", DATATYPE('011 01001'  ,'B') )

    numeric digits 9
    self~assertEquals("subTest52", 'NUM'   , DATATYPE(' 1e3       ')     )
    self~assertEquals("subTest53", 'NUM'   , DATATYPE(' 123456789 ')     )
    self~assertEquals("subTest54", 'NUM'   , DATATYPE(' 1234567891 ')    )
    self~assertEquals("subTest55", 'CHAR'  , DATATYPE("")                )
    self~assertEquals("subTest56", 'CHAR'  , DATATYPE("a")               )
    self~assertEquals("subTest57", 'CHAR'  , DATATYPE("abc")             )
    self~assertEquals("subTest58", 'CHAR'  , DATATYPE("1A0")             )

    self~assertTrue("subTest59" ,   DATATYPE("123456789012345", "N" )    ) -- Numeric
    self~assertTrue("subTest60" ,   DATATYPE("0"              , "N" )    ) -- Numeric
    self~assertTrue("subTest61" ,   DATATYPE("1234567890.1234", "N" )    ) -- Numeric
    self~assertFalse("subTest61" ,  DATATYPE(""               , "N" )    ) -- Numeric
    numeric digits a

    self~assertTrue("subtest62",    DATATYPE(0,  "O") )  -- Logical (Boolean)
    self~assertTrue("subtest63",    DATATYPE(1,  "O") )  -- Logical (Boolean)
    self~assertFalse("subtest64",   DATATYPE(2,  "O") )  -- Logical (Boolean)
    self~assertFalse("subtest65",   DATATYPE(-1, "O") )  -- Logical (Boolean)
    self~assertFalse("subtest66",   DATATYPE("", "O") )  -- Logical (Boolean)


   -- test the BIF, using examples from the documentation
::method "test_DATATYPE_WITH_OPTION_9"
    a=digits()          -- get digits

    numeric digits 1    -- make sure that numeric digits is not set to 9
    self~assertTrue( "subTest38", DATATYPE('0'    ,'9')  ) -- whole number under 9 digits (?)
    self~assertTrue( "subTest39", DATATYPE('1'    ,'9')  )
    self~assertTrue( "subTest40", DATATYPE('-1'   ,'9')  )
    self~assertTrue( "subTest41", DATATYPE('12345' ,'9')  ) -- ?
    self~assertTrue( "subTest42", DATATYPE('1E3'   ,'9')  ) -- ?
    self~assertFalse( "subTest43", DATATYPE('1E9'  ,'9')  ) -- ?
    numeric digits a


   -- test the BIF, using examples from the documentation
::method "test_DATE"
    tmpD='13 Nov 1996'

    self~assertSame("subTest1" , '13 Nov 1996'      , DATE(   , tmpD ))
    self~assertSame("subTest2" , 728975             , DATE('B', tmpD ))             -- error: 728609             )
    self~assertSame("subTest3" , 318                , DATE('D', tmpD ))             -- error: 317                )
    self~assertSame("subTest4" , '13/11/96'         , DATE('E', tmpD ))
    self~assertSame("subTest5" , '13 November 1996' , DATE('L', tmpD ))
    self~assertSame("subTest6" , 'November'         , DATE('M', tmpD ))
    self~assertSame("subTest7" , '13 Nov 1996'      , DATE('N', tmpD ))
    self~assertSame("subTest8" , '96/11/13'         , DATE('O', tmpD ))
    self~assertSame("subTest9" , '19961113'         , DATE('S', tmpD ))
    self~assertSame("subTest10", '11/13/96'         , DATE('U', tmpD ))
    self~assertSame("subTest11", 'Wednesday'        , DATE('W', tmpD ))             -- error: 'Monday'           )

    self~assertSame("subTest12", '23/02/13' , DATE('O','13 Feb 1923') )
    self~assertSame("subTest13", '50/06/01' , DATE('O','06/01/50','U'))

    self~assertSame("subTest14", '1996-02-13'  , DATE('S','13 Feb 1996','N','-'))
    self~assertSame("subTest15", '13Feb1996'   , DATE('N','13 Feb 1996','N',"") )
    self~assertSame("subTest16", '13-Feb-1996' , DATE('N','13 Feb 1996','N','-'))
    self~assertSame("subTest17", '500601'      , DATE('O','06/01/50','U',"")    )
    self~assertSame("subTest18", '13.02.96'    , DATE('E','02/13/96','U','.')   )
    self~assertSame("subTest19", '26_Mar_1998' , DATE('N', '26 Mar 1998', ,'_') )

    -- self~assertSame("subTest20", DATE('S','1996-11-13','S', ,"",'-'), '19961113' ) -- error: more than 5 arg() !
    self~assertSame("subTest20", '19961113' , DATE('S','1996-11-13','S',"",'-')  )

    self~assertSame("subTest21", '19961113' , DATE('S','13-Nov-1996','N',"",'-') )
    self~assertSame("subTest22", '500601'   , DATE('O','06*01*50','U',"",'*')    )
    self~assertSame("subTest23", '02/13/96' , DATE('U','13.Feb.1996','N', ,'.')  )


   -- test the BIF, using examples from the documentation
::method "test_DELSTR"
    self~assertSame("subTest1" , 'ab'    , DELSTR('abcd',3)   )
    self~assertSame("subTest2" , 'abe'   , DELSTR('abcde',3,2))
    self~assertSame("subTest3" , 'abcde' , DELSTR('abcde',6)  )

   -- new tests
    self~assertSame("subTest4" , ''      , DELSTR('abcde',1)  )
    self~assertSame("subTest5" , 'bcde'  , DELSTR('abcde',1,1))
    self~assertSame("subTest6" , 'abcde' , DELSTR('abcde',1,0))
    self~assertSame("subTest7" , 'abcde' , DELSTR('abcde',3,0))
    self~assertSame("subTest8" , 'abde'  , DELSTR('abcde',3,1))
    self~assertSame("subTest9" , 'abcde' , DELSTR('abcde',9)  )


   -- test the BIF, using examples from the documentation
::method "test_DELWORD"
    self~assertSame("subTest1" , 'Now time'        , DELWORD('Now is the time',2,2))
    self~assertSame("subTest2" , 'Now is '         , DELWORD('Now is the time ',3) )
    self~assertSame("subTest3" , 'Now is the time' , DELWORD('Now is the time',5)  )
    self~assertSame("subTest4" , 'Now is time'     , DELWORD('Now is the time',3,1))
    self~assertSame("subTest5" , 'Now time'        , DELWORD('Now is the time',2,2))

   -- new tests
    self~assertSame("subTest4" , 'Now is the time' , DELWORD('Now is the time',3,0))
    self~assertSame("subTest4" , 'Now is the time' , DELWORD('Now is the time',1,0))


   -- test the BIF
::method "test_DIGITS"
    self~assertTrue("subTest1", datatype(digits(),"N"))  -- make sure a number is returned
    self~assertTrue("subTest2", digits()>0            )  -- make sure a number is returned


   -- test the BIF, using examples from the documentation
::method "test_ERRORTEXT"
    self~assertSame("subTest-2" , 'Label not found' , ERRORTEXT(16))
    self~assertSame("subTest-1" , ""                , ERRORTEXT(60))

   -- additional tests by Walter Pachl (2005-10-14)
    self~assertSame('subTest1' , ''                                        , ERRORTEXT(1) )
    self~assertSame('subTest2' , ''                                        , ERRORTEXT(2) )
    self~assertSame('subTest3' , 'Failure during initialization'           , ERRORTEXT(3) )
    self~assertSame('subTest4' , 'Program interrupted'                     , ERRORTEXT(4) )
    self~assertSame('subTest5' , 'System resources exhausted'              , ERRORTEXT(5) )
    self~assertSame('subTest6' , 'Unmatched "/*" or quote'                 , ERRORTEXT(6) )
    self~assertSame('subTest7' , 'WHEN or OTHERWISE expected'              , ERRORTEXT(7) )
    self~assertSame('subTest8' , 'Unexpected THEN or ELSE'                 , ERRORTEXT(8) )
    self~assertSame('subTest9' , 'Unexpected WHEN or OTHERWISE'            , ERRORTEXT(9) )
    self~assertSame('subTest10', 'Unexpected or unmatched END'             , ERRORTEXT(10))
    self~assertSame('subTest11', 'Control stack full'                      , ERRORTEXT(11))
    self~assertSame('subTest12', ''                                        , ERRORTEXT(12))
    self~assertSame('subTest13', 'Invalid character in program'            , ERRORTEXT(13))
    self~assertSame('subTest14', 'Incomplete DO/SELECT/IF'                 , ERRORTEXT(14))
    self~assertSame('subTest15', 'Invalid hexadecimal or binary string'    , ERRORTEXT(15))
    self~assertSame('subTest16', 'Label not found'                         , ERRORTEXT(16))
    self~assertSame('subTest17', 'Unexpected PROCEDURE'                    , ERRORTEXT(17))
    self~assertSame('subTest18', 'THEN expected'                           , ERRORTEXT(18))
    self~assertSame('subTest19', 'String or symbol expected'               , ERRORTEXT(19))
    self~assertSame('subTest20', 'Symbol expected'                         , ERRORTEXT(20))
    self~assertSame('subTest21', 'Invalid data on end of clause'           , ERRORTEXT(21))
    self~assertSame('subTest22', 'Invalid character string'                , ERRORTEXT(22))
    self~assertSame('subTest23', 'Invalid data string'                     , ERRORTEXT(23))
    self~assertSame('subTest24', 'Invalid TRACE request'                   , ERRORTEXT(24))
    self~assertSame('subTest25', 'Invalid subkeyword found'                , ERRORTEXT(25))
    self~assertSame('subTest26', 'Invalid whole number'                    , ERRORTEXT(26))
    self~assertSame('subTest27', 'Invalid DO syntax'                       , ERRORTEXT(27))
    self~assertSame('subTest28', 'Invalid LEAVE or ITERATE'                , ERRORTEXT(28))
    self~assertSame('subTest29', 'Environment name too long'               , ERRORTEXT(29))
    self~assertSame('subTest30', 'Name or string too long'                 , ERRORTEXT(30))
    self~assertSame('subTest31', 'Name starts with number or "."'          , ERRORTEXT(31))
    self~assertSame('subTest32', ''                                        , ERRORTEXT(32))
    self~assertSame('subTest33', 'Invalid expression result'               , ERRORTEXT(33))
    self~assertSame('subTest34', 'Logical value not 0 or 1'                , ERRORTEXT(34))
    self~assertSame('subTest35', 'Invalid expression'                      , ERRORTEXT(35))
    self~assertSame('subTest36', 'Unmatched "(" or "[" in expression'      , ERRORTEXT(36))
    self~assertSame('subTest37', 'Unexpected ",", ")", or "]"'             , ERRORTEXT(37))
    self~assertSame('subTest38', 'Invalid template or pattern'             , ERRORTEXT(38))
    self~assertSame('subTest39', 'Evaluation stack overflow'               , ERRORTEXT(39))
    self~assertSame('subTest40', 'Incorrect call to routine'               , ERRORTEXT(40))
    self~assertSame('subTest41', 'Bad arithmetic conversion'               , ERRORTEXT(41))
    self~assertSame('subTest42', 'Arithmetic overflow/underflow'           , ERRORTEXT(42))
    self~assertSame('subTest43', 'Routine not found'                       , ERRORTEXT(43))
    self~assertSame('subTest44', 'Function or message did not return data' , ERRORTEXT(44))
    self~assertSame('subTest45', 'No data specified on function RETURN'    , ERRORTEXT(45))
    self~assertSame('subTest46', 'Invalid variable reference'              , ERRORTEXT(46))
    self~assertSame('subTest47', 'Unexpected label'                        , ERRORTEXT(47))
    self~assertSame('subTest48', 'Failure in system service'               , ERRORTEXT(48))
    self~assertSame('subTest49', 'Interpretation error'                    , ERRORTEXT(49))
    self~assertSame('subTest50', ''                                        , ERRORTEXT(50))
    self~assertSame('subTest51', ''                                        , ERRORTEXT(51))
    self~assertSame('subTest52', ''                                        , ERRORTEXT(52))
    self~assertSame('subTest53', ''                                        , ERRORTEXT(53))
    self~assertSame('subTest54', ''                                        , ERRORTEXT(54))
    self~assertSame('subTest55', ''                                        , ERRORTEXT(55))
    self~assertSame('subTest56', ''                                        , ERRORTEXT(56))
    self~assertSame('subTest57', ''                                        , ERRORTEXT(57))
    self~assertSame('subTest58', ''                                        , ERRORTEXT(58))
    self~assertSame('subTest59', ''                                        , ERRORTEXT(59))
    self~assertSame('subTest60', ''                                        , ERRORTEXT(60))
    self~assertSame('subTest61', ''                                        , ERRORTEXT(61))
    self~assertSame('subTest62', ''                                        , ERRORTEXT(62))
    self~assertSame('subTest63', ''                                        , ERRORTEXT(63))
    self~assertSame('subTest64', ''                                        , ERRORTEXT(64))
    self~assertSame('subTest65', ''                                        , ERRORTEXT(65))
    self~assertSame('subTest66', ''                                        , ERRORTEXT(66))
    self~assertSame('subTest67', ''                                        , ERRORTEXT(67))
    self~assertSame('subTest68', ''                                        , ERRORTEXT(68))
    self~assertSame('subTest69', ''                                        , ERRORTEXT(69))
    self~assertSame('subTest70', ''                                        , ERRORTEXT(70))
    self~assertSame('subTest71', ''                                        , ERRORTEXT(71))
    self~assertSame('subTest72', ''                                        , ERRORTEXT(72))
    self~assertSame('subTest73', ''                                        , ERRORTEXT(73))
    self~assertSame('subTest74', ''                                        , ERRORTEXT(74))
    self~assertSame('subTest75', ''                                        , ERRORTEXT(75))
    self~assertSame('subTest76', ''                                        , ERRORTEXT(76))
    self~assertSame('subTest77', ''                                        , ERRORTEXT(77))
    self~assertSame('subTest78', ''                                        , ERRORTEXT(78))
    self~assertSame('subTest79', ''                                        , ERRORTEXT(79))
    self~assertSame('subTest80', ''                                        , ERRORTEXT(80))
    self~assertSame('subTest81', ''                                        , ERRORTEXT(81))
    self~assertSame('subTest82', ''                                        , ERRORTEXT(82))
    self~assertSame('subTest83', ''                                        , ERRORTEXT(83))
    self~assertSame('subTest84', ''                                        , ERRORTEXT(84))
    self~assertSame('subTest85', ''                                        , ERRORTEXT(85))
    self~assertSame('subTest86', ''                                        , ERRORTEXT(86))
    self~assertSame('subTest87', ''                                        , ERRORTEXT(87))
    self~assertSame('subTest88', ''                                        , ERRORTEXT(88))
    self~assertSame('subTest89', 'Variable or message term expected'       , ERRORTEXT(89))
    self~assertSame('subTest90', 'External name not found'                 , ERRORTEXT(90))
    self~assertSame('subTest91', 'No result object'                        , ERRORTEXT(91))
    self~assertSame('subTest92', 'OLE error'                               , ERRORTEXT(92))
    self~assertSame('subTest93', 'Incorrect call to method'                , ERRORTEXT(93))
    self~assertSame('subTest94', ''                                        , ERRORTEXT(94))
    self~assertSame('subTest95', ''                                        , ERRORTEXT(95))
    self~assertSame('subTest96', ''                                        , ERRORTEXT(96))
    self~assertSame('subTest97', 'Object method not found'                 , ERRORTEXT(97))
    self~assertSame('subTest98', 'Execution error'                         , ERRORTEXT(98))
    self~assertSame('subTest99', 'Translation error'                       , ERRORTEXT(99))

    self~assertTrue("subTest100", test100())
    self~assertTrue("subTest101", test101())

    return

    ----------------------------------------------------------------------

    test100: procedure  -- nonexisting error text number
       signal on syntax name test100syntax
       call errortext(100) -- should invoke a syntax error
       return .false       -- arriving here is an error!
    test100syntax:         -- syntax error # 40.903
       return condition("o")~code=40.903

    ----------------------------------------------------------------------

    test101: procedure  -- not using a whole number as index
       signal on syntax name test101syntax
       a='blabla';
       errortext(a)        -- should invoke a syntax error
       return .false
    test101syntax:         -- syntax error # 40.12
       return condition("o")~code=40.12






   -- test the BIF
::method "test_FORM"
    numeric form scientific
    self~assertSame("subTest1", "SCIENTIFIC",  form())

    numeric form engineering
    self~assertSame("subTest2", "ENGINEERING", form())

    numeric form                 -- reset to default, which is scientific
    self~assertSame("subTest1", "SCIENTIFIC",  form())



   -- test the BIF, using examples from the documentation
::method "test_FORMAT"
    self~assertSame("subTest1" , '   3'             , FORMAT('3',4)               )
    self~assertSame("subTest2" , '   2'             , FORMAT('1.73',4,0)          )
    self~assertSame("subTest3" , '   1.730'         , FORMAT('1.73',4,3)          )
    self~assertSame("subTest4" , '  -0.8'           , FORMAT('-.76',4,1)          )
    self~assertSame("subTest5" , '   3.03'          , FORMAT('3.03',4)            )
    self~assertSame("subTest6" , '-12.7300'         , FORMAT(' - 12.73', ,4)      )
    self~assertSame("subTest7" , '-12.73'           , FORMAT(' - 12.73')          )
    self~assertSame("subTest8" , '0'                , FORMAT('0.000')             )

    self~assertSame("subTest9" , '1.234573E+04'     , FORMAT('12345.73', , ,2,2)  ) --
    self~assertSame("subTest10", '1.235E+4'         , FORMAT('12345.73', ,3, ,0)  )
    self~assertSame("subTest11", '1.235'            , FORMAT('1.234573', ,3, ,0)  )
    self~assertSame("subTest12", '12345.73'         , FORMAT('12345.73', , ,3,6)  )
    self~assertSame("subTest13", '123456700000.000' , FORMAT('1234567e5', ,3,0)   )



   -- test the BIF
::method "test_FUZZ"
    numeric fuzz 0
    self~assertEquals("subTest1",  0, fuzz())

    numeric fuzz 1
    self~assertEquals("subTest2",  1, fuzz())

    numeric fuzz
    self~assertEquals("subTest3",  0, fuzz())



   -- test the BIF, using examples from the documentation
::method "test_INSERT"
    self~assertSame("subTest1" , 'abc def'      , INSERT(' ','abcdef',3)     )
    self~assertSame("subTest2" , 'abc  123   '  , INSERT('123','abc',5,6)    )
    self~assertSame("subTest3" , 'abc++123+++'  , INSERT('123','abc',5,6,'+'))
    self~assertSame("subTest4" , '123abc'       , INSERT('123','abc')        )
    self~assertSame("subTest5" , '123--abc'     , INSERT('123','abc', ,5,'-'))

   -- new tests
    self~assertSame("subTest6" , 'abcdef'       , INSERT('','abcdef',3)      )
    self~assertSame("subTest7" , 'abcdef'       , INSERT(' ','abcdef',3, 0)  )
    self~assertSame("subTest8" , ''             , INSERT('','')              )
    self~assertSame("subTest9" , '   '          , INSERT('','', 3, 0)        )
    self~assertSame("subTest10", '    '         , INSERT('','', 3, 1)        )



   -- test the BIF, using examples from the documentation
::method "test_LASTPOS"
    self~assertEquals("subTest1" , 8  , LASTPOS(' ','abc def ghi')  )
    self~assertEquals("subTest2" , 0  , LASTPOS(' ','abcdefghi')    )
    self~assertEquals("subTest3" , 4  , LASTPOS('xy','efgxyz')      )
    self~assertEquals("subTest4" , 4  , LASTPOS(' ','abc def ghi',7))

   -- new tests
    self~assertEquals("subTest5" , 0  , LASTPOS('','abc def ghi',7))
    self~assertEquals("subTest6" , 0  , LASTPOS('','')             )


   -- test the BIF, using examples from the documentation
::method "test_LEFT"
    self~assertSame("subTest1" , 'abc d   ' , LEFT('abc d',8)    )
    self~assertSame("subTest2" , 'abc d...' , LEFT('abc d',8,'.'))
    self~assertSame("subTest3" , 'abc  de'  , LEFT('abc  def',7) )

   -- new tests
    self~assertSame("subTest4" , 'a'        , LEFT('abc  def',1) )
    self~assertSame("subTest5" , ''         , LEFT('abc  def',0) )



   -- test the BIF, using examples from the documentation
::method "test_LENGTH"
    self~assertSame("subTest1" , 8  , LENGTH('abcdefgh'))
    self~assertSame("subTest2" , 8  , LENGTH('abc defg'))
    self~assertSame("subTest3" , 0  , LENGTH("")        )


::method "test_LOWER"
    self~assertSame("subTest_01" , 'AbCdeFGH', lower('ABCdeFGH', 2,  1 ))
    self~assertSame("subTest_02" , 'ABCdeFGH', lower('ABCdeFGH', 1,  0 ))
    self~assertSame("subTest_03" , 'ABCdeFGH', lower('ABCdeFGH', 99, 2 ))
    self~assertSame("subTest_04" , 'Abcdefgh', lower('ABCdeFGH', 2     ))
    self~assertSame("subTest_05" , 'abcdefgh', lower('ABCdeFGH'        ))



   -- test the BIF, using examples from the documentation
::method "test_MAX"
    self~assertEquals("subTest1" , 12  , MAX(12,6,7,9)                                             )
    self~assertEquals("subTest2" , 19  , MAX(17.3,19,17.03)                                        )
    self~assertEquals("subTest3" , -3  , MAX(-7,-3,-4.3)                                           )
    self~assertEquals("subTest4" , 21  , MAX(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21))



   -- test the BIF, using examples from the documentation
::method "test_MIN"
    self~assertEquals("subTest1" , 6     , MIN(12,6,7,9)                                             )
    self~assertEquals("subTest2" , 17.03 , MIN(17.3,19,17.03)                                        )
    self~assertEquals("subTest3" , -7    , MIN(-7,-3,-4.3)                                           )
    self~assertEquals("subTest4" , 1     , MIN(21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1))


   -- test the BIF, using examples from the documentation
::method "test_OVERLAY"
    self~assertSame("subTest1" , 'ab def'    , OVERLAY(' ','abcdef',3)      )
    self~assertSame("subTest2" , 'ab. ef'    , OVERLAY('.','abcdef',3,2)    )
    self~assertSame("subTest3" , 'qqcd'      , OVERLAY('qq','abcd')         )
    self~assertSame("subTest4" , 'abcqq'     , OVERLAY('qq','abcd',4)       )
    self~assertSame("subTest5" , 'abc+123+++', OVERLAY('123','abc',5,6,'+') )

   -- new tests
    self~assertSame("subTest6" , 'abc'       , OVERLAY('','abc',3)          )
    self~assertSame("subTest7" , 'abc'       , OVERLAY('','abc',3, 0)       )
    self~assertSame("subTest8" , 'ab '       , OVERLAY('','abc',3, 1)       )
    self~assertSame("subTest9" , 'abc   '    , OVERLAY('','abc',6, 1)       )

    self~assertSame("subTest10", 'abc'       , OVERLAY('  ','abc',3, 0)     )
    self~assertSame("subTest11", 'ab '       , OVERLAY('  ','abc',3, 1)     )
    self~assertSame("subTest12", 'abc   '    , OVERLAY('  ','abc',6, 1)     )

    self~assertSame("subTest13", 'abc'       , OVERLAY('12','abc',3, 0)     )
    self~assertSame("subTest14", 'ab3'       , OVERLAY('34','abc',3, 1)     )
    self~assertSame("subTest15", 'abc  5'    , OVERLAY('56','abc',6, 1)     )




   -- test the BIF, using examples from the documentation
::method "test_POS"
    self~assertEquals("subTest1" , 6,  POS('day','Saturday')   )
    self~assertEquals("subTest2" , 0,  POS('x','abc def ghi')  )
    self~assertEquals("subTest3" , 4,  POS(' ','abc def ghi')  )
    self~assertEquals("subTest4" , 8,  POS(' ','abc def ghi',5))

   -- new test
    self~assertEquals("subTest5" , 0, POS('','abc def ghi',5)  )


   -- test the BIF, using examples from the documentation
::method "test_RANDOM"

    min="0  0 1  9999"
    max="1 +1 9 99999"
    seed="0 179 34 99999"
    reps=100

    do i=1 to words(min)
       mi=word(min, i)
       ma=word(max, i)
       do reps
          x=random(mi, ma)
          if x<mi | x>ma then
             self~fail(x "not in range: min="mi", max="ma)
       end
       self~assertTrue(.true)   -- indicate that this run holds
    end

    -- now collect first 100 random numbers per seed, repeat generation and compare with stored ones
    do i=1 to words(min)
       mi=word(min, i)
       ma=word(max, i)
       se=word(seed, i)

       x.1=random(mi, ma, se)    -- define a seed to start the generator test
       do i1=2 to reps
          x.i1=random(mi, ma)
          if x.i1<mi | x.i1>ma then
             self~fail(x.i1 "not in range: min="mi", max="ma)
       end

         -- now re-run with same seed
       y.1=random(mi, ma, se)
       do i1=2 to reps
          y.i1=random(mi, ma)
          if y.i1<mi | y.i1>ma then
             self~fail(y.i1 "not in range: min="mi", max="ma)
       end

         -- now compare both runs
       do i1=1 to reps
          if x.i1<>y.i1 then
             self~fail("i1="i1"," x.i1 "<>" y.i1)
       end
       self~assertTrue(.true)   -- indicate that this run holds
       drop x. y.
    end



   -- test the BIF, using examples from the documentation
::method "test_REVERSE"
    self~assertSame("subTest1" , '.cBA' , REVERSE('ABc.'))
    self~assertSame("subTest2" , ' ZYX' , REVERSE('XYZ '))

   -- new tests
    self~assertSame("subTest3" , ''     , REVERSE(''    ))
    self~assertSame("subTest4" , ''     , REVERSE(''    ))



-- test the BIF, using examples from the documentation
::method "test_RIGHT"
    self~assertSame("subTest1" , '  abc  d'    , RIGHT('abc  d',8)   )
    self~assertSame("subTest2" , 'c def'       , RIGHT('abc def',5)  )
    self~assertSame("subTest3" , '00012'       , RIGHT('12',5,'0')   )

   -- new tests
    self~assertSame("subTest4" , '   '         , RIGHT('', 3)        )
    self~assertSame("subTest5" , ''            , RIGHT('', 0)        )
    self~assertSame("subTest6" , ''            , RIGHT('123', 0)     )



   -- test the BIF, using examples from the documentation
::method "test_SIGN"
    self~assertEquals("subTest1" ,  1 , SIGN('12.3')    )
    self~assertEquals("subTest2" , -1 , SIGN(' -0.307') )
    self~assertEquals("subTest3" ,  0 , SIGN(0.0)       )

   -- new tests
    self~assertEquals("subTest4" ,  0 , SIGN(-0.0)      )



   -- test the BIF, using examples from the documentation
::method "test_SOURCELINE"
    -- self~assertEquals("subTest1" , SOURCELINE(1)   ,  "/*"  )

    self~assertTrue("subTest1"   , datatype(sourceline(), "N"))
    self~assertEquals("subTest2" , "/*"  , SOURCELINE(2)  )

    -- get operating system
    parse upper source opsys +1
    if pos(opsys, "WO")=0 then      -- assuming Unix based operating system
    do
         -- assuming hash-bang characters get removed on Unix by the opsys/shell
       self~assertEquals("subTest3a (Unix-based)" , ""  , SOURCELINE(1)  )
    end
    else                            -- Windows or OS/2
    do
       self~assertEquals("subTest3b (Windows)" , "/usr/bin/rexx"   , SOURCELINE(1)~substr(3)  )
    end



   -- test the BIF, using examples from the documentation
::method "test_SPACE"
    self~assertSame("subTest1" , 'abc def'   , SPACE('abc def ')       )
    self~assertSame("subTest2" , 'abc   def' , SPACE('  abc def',3)    )
    self~assertSame("subTest3" , 'abc def'   , SPACE('abc  def ',1)    )
    self~assertSame("subTest4" , 'abcdef'    , SPACE('abc  def ',0)    )
    self~assertSame("subTest5" , 'abc++def'  , SPACE('abc  def ',2,'+'))

   -- new tests
    self~assertSame("subTest6" , '' , SPACE('     ',0) )
    self~assertSame("subTest7" , '' , SPACE('     ',1) )
    self~assertSame("subTest8" , '' , SPACE('     ',2) )
    self~assertSame("subTest9" , '' , SPACE('     ',3) )
    self~assertSame("subTest10", '' , SPACE(''     ,0) )
    self~assertSame("subTest11", '' , SPACE(''     ,1) )
    self~assertSame("subTest12", '' , SPACE(''     ,2) )
    self~assertSame("subTest13", '' , SPACE(''     ,3) )




   -- test the BIF, using examples from the documentation
::method "test_STRIP"
    self~assertSame("subTest1" , 'ab c'    , STRIP('  ab c  ')      )
    self~assertSame("subTest2" , 'ab c  '  , STRIP('  ab c  ','L')  )
    self~assertSame("subTest3" , '  ab c'  , STRIP('  ab c  ','t')  )
    self~assertSame("subTest4" , '12.7'    , STRIP('12.7000', ,0)   )
    self~assertSame("subTest5" , '12.7'    , STRIP('0012.700', ,0)  )

   -- new tests
    self~assertSame("subTest6" , ''        , STRIP(''    ) )
    self~assertSame("subTest7" , ''        , STRIP('    ') )



   -- test the BIF, using examples from the documentation
::method "test_SUBSTR"
    self~assertSame("subTest1" , 'bc'    , SUBSTR('abc',2)        )
    self~assertSame("subTest2" , 'bc  '  , SUBSTR('abc',2,4)      )
    self~assertSame("subTest3" , 'bc....', SUBSTR('abc',2,6,'.')  )

   -- new tests
    self~assertSame("subTest4" , ''      , SUBSTR('abc',2,0)      )
    self~assertSame("subTest5" , 'a'     , SUBSTR('abc',1,1)      )
    self~assertSame("subTest6" , 'c'     , SUBSTR('abc',3,1)      )
    self~assertSame("subTest7" , ' '     , SUBSTR('abc',4,1)      )
    self~assertSame("subTest8" , '  '    , SUBSTR('abc',4,2)      )


   -- test the BIF, using examples from the documentation
::method "test_SUBWORD"
    self~assertSame("subTest1" , 'is the'  , SUBWORD('Now is the time',2,2) )
    self~assertSame("subTest2" , 'the time', SUBWORD('Now is the time',3)   )
    self~assertSame("subTest3" , ""        , SUBWORD('Now is the time',5)   )

   -- new tests
    self~assertSame("subTest4" , ''          , SUBWORD('Now is the time',2,0)     )
    self~assertSame("subTest5" , 'the  time' , SUBWORD('Now  is  the  time  ',3)  )
    self~assertSame("subTest6" , "time"      , SUBWORD('Now  is  the  time  ',4)  )
    self~assertSame("subTest7" , ""          , SUBWORD('Now  is  the  time  ',5)  )


   -- test the BIF, using examples from the documentation
::method "test_SYMBOL"
    /* following: Drop A.3; J=3 */
    drop a.3
    j=3

    self~assertEquals("subTest1" , 'VAR'                           , SYMBOL('J')   )
    self~assertEquals("subTest2" , 'LIT' /* has tested "3" */      , SYMBOL(J)     )
    self~assertEquals("subTest3" , 'LIT' /* has tested A.3 */      , SYMBOL('a.j') )
    self~assertEquals("subTest4" , 'LIT' /* a constant symbol */   , SYMBOL(2)     )
    self~assertEquals("subTest5" , 'BAD' /* not a valid symbol */  , SYMBOL('*')   )

   -- new tests
    self~assertEquals("subTest6" , 'LIT' /* not a valid symbol */  , SYMBOL('.')   )
    self~assertEquals("subTest7" , 'LIT' /* not a valid symbol */  , SYMBOL('.a')  )
    self~assertEquals("subTest8" , 'BAD' /* not a valid symbol */  , SYMBOL('')    )
    self~assertEquals("subTest9" , 'BAD' /* not a valid symbol */  , SYMBOL('  ')  )


   -- starting with 3.2 TAB chars are treated like blanks
::method "test_TABs"
    TAB  ="09"x
    TAB2 =TAB||TAB

    PLANK=" "
    PLANK2=PLANK||PLANK

      -- test equality of TAB and blank, Rexx-philosophy
    self~assertTrue( "subtest_01a", PLANK = TAB)
    self~assertTrue( "subtest_01b", PLANK = "" )
    self~assertTrue( "subtest_01c", ""    = TAB)

    self~assertFalse("subtest_02a", PLANK ==TAB)
    self~assertFalse("subtest_02b", ""    ==TAB)
    self~assertFalse("subtest_02c", PLANK =="" )

    self~assertTrue( "subtest_03a", PLANK2= TAB2)
    self~assertTrue( "subtest_03b", ""    = TAB2)
    self~assertTrue( "subtest_03c", PLANK2= ""  )

    self~assertFalse("subtest_04a", PLANK2==TAB2)
    self~assertFalse("subtest_04b", ""    ==TAB2)
    self~assertFalse("subtest_04c", PLANK2==""  )

    self~assertEquals("subtest_05a", 3, words("word1" TAB "word2" "word3"))
    self~assertEquals("subtest_05b", "a", PLANK "a" PLANK2)
    self~assertEquals("subtest_05c", "a", PLANK "a" TAB2)
    self~assertEquals("subtest_05d", "a", TAB "a" TAB2)



   -- starting with 3.2 TAB chars are treated like blanks
::method "test_TABs_DELWORD"
    TAB  ="09"x
    TAB2 =TAB||TAB

    PLANK=" "
    PLANK2=PLANK||PLANK

      -- test DELWORD
    s0  ="hey"
    s0_p="hey you"
    s0_p2="hey  you"
    s0_t="hey"TAB"you"
    s0_t2="hey"TAB2"you"

    s1="hey"PLANK"is-this"PLANK2"you"
    s2="hey"TAB"is-this"PLANK2"you"
    s3="hey"PLANK"is-this"TAB"you"
    s4="hey"PLANK2"is-this"TAB2"you"
    s5="hey"TAB"is-this"TAB2"you"
    s6="hey"TAB2"is-this"TAB2"you"

      -- delete second word
    self~assertSame("subtest_01a", s0_p, delword(s1, 2, 1))
    self~assertSame("subtest_01b", s0_t, delword(s2, 2, 1))
    self~assertSame("subtest_01c", s0_p, delword(s3, 2, 1))
    self~assertSame("subtest_01d", s0_p2, delword(s4, 2, 1))
    self~assertSame("subtest_01e", s0_t, delword(s5, 2, 1))
    self~assertSame("subtest_01f", s0_t2, delword(s6, 2, 1))

      -- delete everything starting and including the second word
    self~assertSame("subtest_02a", s0||PLANK , delword(s1, 2))
    self~assertSame("subtest_02b", s0||TAB   , delword(s2, 2))
    self~assertSame("subtest_02c", s0||PLANK , delword(s3, 2))
    self~assertSame("subtest_02d", s0||PLANK2, delword(s4, 2))
    self~assertSame("subtest_02e", s0||TAB   , delword(s5, 2))
    self~assertSame("subtest_02f", s0||TAB2  , delword(s6, 2))


   -- starting with 3.2 TAB chars are treated like blanks
::method "test_TABs_PARSE"
    TAB  ="09"x
    TAB2 =TAB||TAB

    PLANK=" "
    PLANK2=PLANK||PLANK

    str=plank2 "This" plank "is" plank "a" plank2 "test." || plank2
    word5exp=PLANK

    parse var str word1 word2 word3 word4 .
    self~assertSame("subtest_01", "This"  , word1)
    self~assertSame("subtest_02", "is"    , word2)
    self~assertSame("subtest_03", "a"     , word3)
    self~assertSame("subtest_04", "test." , word4)

    parse var str word1 word2 word3 word4 word5 .
    self~assertSame("subtest_11", "This"  , word1)
    self~assertSame("subtest_12", "is"    , word2)
    self~assertSame("subtest_13", "a"     , word3)
    self~assertSame("subtest_14", "test." , word4)
    self~assertSame("subtest_15", ""      , word5)

    parse var str word1 word2 word3 word4 word5
    self~assertSame("subtest_21", "This"  , word1)
    self~assertSame("subtest_22", "is"    , word2)
    self~assertSame("subtest_23", "a"     , word3)
    self~assertSame("subtest_24", "test." , word4)
    self~assertSame("subtest_25", word5exp, word5)


    str=plank2 "This" plank "is" tab "a" plank2 "test."   || tab2
    word5exp=TAB

    parse var str word1 word2 word3 word4 .
    self~assertSame("subtest_31", "This"  , word1)
    self~assertSame("subtest_32", "is"    , word2)
    self~assertSame("subtest_33", "a"     , word3)
    self~assertSame("subtest_34", "test." , word4)

    parse var str word1 word2 word3 word4 word5 .
    self~assertSame("subtest_41", "This"  , word1)
    self~assertSame("subtest_42", "is"    , word2)
    self~assertSame("subtest_43", "a"     , word3)
    self~assertSame("subtest_44", "test." , word4)
    self~assertSame("subtest_45", ""      , word5)

    parse var str word1 word2 word3 word4 word5
    self~assertSame("subtest_51", "This"  , word1)
    self~assertSame("subtest_52", "is"    , word2)
    self~assertSame("subtest_53", "a"     , word3)
    self~assertSame("subtest_54", "test." , word4)
    self~assertSame("subtest_55", word5exp, word5)



   -- starting with 3.2 TAB chars are treated like blanks
::method "test_TABs_SPACE"
    TAB  ="09"x
    TAB2 =TAB||TAB

    PLANK=" "
    PLANK2=PLANK||PLANK

    str0=plank2 "This" plank "is" tab "a" plank2 "test." tab2

    str1="This" || plank || "is" || plank || "a" || plank || "test."
    str2="This" || tab   || "is" || tab   || "a" || tab   || "test."
    str3="Thisisatest."

    self~assertSame("subtest_01", str1, space(str0))
    self~assertSame("subtest_02", str2, space(str0,1,TAB))
    self~assertSame("subtest_03", str3, space(str0,0))



   -- starting with 3.2 TAB chars are treated like blanks
::method "test_TABs_STRIP"
    TAB  ="09"x
    TAB2 =TAB||TAB

    PLANK=" "
    PLANK2=PLANK||PLANK

    str0a=plank2 "This" plank "is" tab "a" plank2 "test." plank2
    str0b=tab2   "This" plank "is" tab "a" plank2 "test." tab2

    str1="This" plank "is" tab "a" plank2 "test."

    str2a="This" plank "is" tab "a" plank2 "test." plank2
    str2b="This" plank "is" tab "a" plank2 "test." tab2

    str3a=plank2 "This" plank "is" tab "a" plank2 "test."
    str3b=tab2   "This" plank "is" tab "a" plank2 "test."


    self~assertSame("subtest_01a", str1,  strip(str0a))
    self~assertSame("subtest_01b", str1,  strip(str0a,'B'))
    self~assertSame("subtest_02a", str2a, strip(str0a,'L'))
    self~assertSame("subtest_03a", str3a, strip(str0a,'T'))

    self~assertSame("subtest_04a", str1,  strip(str0b))
    self~assertSame("subtest_04b", str1,  strip(str0b,'B'))
    self~assertSame("subtest_05a", str2b, strip(str0b,'L'))
    self~assertSame("subtest_05a", str3b, strip(str0b,'T'))


   -- starting with 3.2 TAB chars are treated like blanks
::method "test_TABs_SUBWORD"
    TAB  ="09"x
    TAB2 =TAB||TAB

    PLANK=" "
    PLANK2=PLANK||PLANK

    str0=plank2 "This" plank "is" tab "a" plank2 "test." tab2

    str1="This" plank "is"
    str2="is" tab "a" plank2 "test."
    str3="This" plank "is" tab "a"
    str4="This" plank "is" tab "a" plank2 "test."

    self~assertSame("subtest_01",  "This", subword(str0,1,1)  )



   -- starting with 3.2 TAB chars are treated like blanks
::method "test_TABs_WORD"
    TAB  ="09"x
    TAB2 =TAB||TAB

    PLANK=" "
    PLANK2=PLANK||PLANK

    str0=plank2 "This" plank "is" tab "a" plank2 "test." tab2

    self~assertSame("subtest_01a",  "This" , word(str0,1)  )
    self~assertSame("subtest_01b",  "is"   , word(str0,2)  )
    self~assertSame("subtest_01c",  "a"    , word(str0,3)  )
    self~assertSame("subtest_01d",  "test.", word(str0,4)  )
    self~assertSame("subtest_01e",  ""     , word(str0,5)  )


   -- starting with 3.2 TAB chars are treated like blanks
::method "test_TABs_WORDINDEX"
    TAB  ="09"x
    TAB2 =TAB||TAB

    PLANK=" "
    PLANK2=PLANK||PLANK

      --            1
      --  123456789 +   123    45678
    str0=" This  is"tab"a"tab2"test."tab2

    self~assertEquals("subtest_01a",  2 , wordIndex(str0,1)  )
    self~assertEquals("subtest_01b",  8 , wordIndex(str0,2)  )
    self~assertEquals("subtest_01c", 11 , wordIndex(str0,3)  )
    self~assertEquals("subtest_01d", 14 , wordIndex(str0,4)  )
    self~assertEquals("subtest_01e",  0 , wordIndex(str0,5)  )


   -- starting with 3.2 TAB chars are treated like blanks
::method "test_TABs_WORDLENGTH"
    TAB  ="09"x
    TAB2 =TAB||TAB

    PLANK=" "
    PLANK2=PLANK||PLANK

      --            1
      --  123456789 +   123    45678
    str0=" This  is"tab"a"tab2"test."tab2

    self~assertEquals("subtest_01a",  4 , wordLength(str0,1)  )
    self~assertEquals("subtest_01b",  2 , wordLength(str0,2)  )
    self~assertEquals("subtest_01c",  1 , wordLength(str0,3)  )
    self~assertEquals("subtest_01d",  5 , wordLength(str0,4)  )
    self~assertEquals("subtest_01e",  0 , wordLength(str0,5)  )



   -- starting with 3.2 TAB chars are treated like blanks
::method "test_TABs_WORDPOS"
    TAB  ="09"x
    TAB2 =TAB||TAB

    PLANK=" "
    PLANK2=PLANK||PLANK

      --            1
      --  123456789 +   123    45678
    str0=" This  is"tab"a"tab2"test."tab2

    self~assertEquals("subtest_01a",  1 , wordPos("This" , str0))
    self~assertEquals("subtest_01b",  2 , wordPos("is"   , str0))
    self~assertEquals("subtest_01c",  3 , wordPos("a"    , str0))
    self~assertEquals("subtest_01d",  4 , wordPos("test.", str0))
    self~assertEquals("subtest_01e",  0 , wordPos("t"    , str0))


   -- starting with 3.2 TAB chars are treated like blanks
::method "test_TABs_WORDS"
    TAB  ="09"x
    TAB2 =TAB||TAB

    PLANK=" "
    PLANK2=PLANK||PLANK

      --            1
      --  123456789 +   123    45678
    str0=" This  is"tab"a"tab2"test."tab2

    self~assertEquals("subtest_01",  4 , words(str0))





   -- test the BIF, using examples from the documentation
::method "test_TIME"
    self~assertSame("subTest1"  , "11:27am"  , time('C','11:27:21')    )
    self~assertSame("subTest2"  , "11:27:00" , time('N','11:27am','C') )

    self~assertEquals("subTest3", 1020       , TIME('M','5:00pm','C')  )

      --   TIME()     '16:54:22'
      --   TIME('C')  '4:54pm'
      --   TIME('H')  '16'
      --   TIME('L')  '16:54:22.120000' /* Perhaps */
      --   TIME('M')  '1014'            /* 54 + 60*16 */
      --   TIME('N')  '16:54:22'
      --   TIME('S')  '60862'           /* 22 + 60*(54+60*16) */

   -- new tests

   -- all date() and time() calls within a statement use the same dateTime

   -- subTest
      parse value time() time('C') with hh":"mm":"ss h1":"m1 +3 ampm
      self~assertTrue("subTest4", (hh>11 & ampm="pm") | (hh<12 & ampm="am"))  -- check for correct usage of am/pm

   -- subTest
      parse value time() time('H') with hh":"mm":"ss h1
      self~assertTrue("subTest5", (hh=h1) )

   -- subTest, check for microseconds
      parse value time() time('L') with hh":"mm":"ss"."uu
      self~assertTrue("subTest6", (datatype(uu,"w") & (length(uu)=6)) )

   -- subTest
      parse value time() time('M') with hh":"mm":"ss m1
      self~assertTrue("subTest7", ((hh*60+mm)=m1))

   -- subTest
      parse value time() time('N') with t1 t2
      self~assertTrue("subTest8", (t1==t2) )

   -- subTest
      parse value time() time('S') with hh":"mm":"ss s1
      self~assertTrue("subTest9", ((hh*60*60+mm*60+ss)=s1))


    self~assertEquals("subTest10", 17    , TIME('H','5:00pm','C'))
    self~assertEquals("subTest11", 61200 , TIME('S','5:00pm','C'))


   -- test the BIF, using examples from the documentation
::method "test_TRANSLATE"
    self~assertSame("subTest1" , 'ABCDEF' , TRANSLATE('abcdef')                  )
    self~assertSame("subTest2" , 'ab2d1f' , TRANSLATE('abcdef','12','ec')        )
    self~assertSame("subTest3" , '12..ef' , TRANSLATE('abcdef','12','abcd','.')  )
    self~assertSame("subTest4" , 'A Q V'  , TRANSLATE('APQRV', ,'PR')            )
    self~assertSame("subTest5" , 'APQ  '  , TRANSLATE('APQRV',XRANGE('00'X,'Q')) )
    self~assertSame("subTest6" , 'dabc'   , TRANSLATE('4123','abcd','1234')      )


   -- test the BIF, using examples from the documentation
::method "test_TRUNC"
    self~assertSame("subTest1" , 12      , TRUNC(12.3)       )
    self~assertSame("subTest2" , 127.097 , TRUNC(127.09782,3))
    self~assertSame("subTest3" , 127.100 , TRUNC(127.1,3)    )
    self~assertSame("subTest4" , 127.00  , TRUNC(127,2)      )


::method "test_UPPER"
    self~assertSame("subTest_01" , 'aBcDEfgh', UPPER('abcDEfgh', 2,  1 ))
    self~assertSame("subTest_02" , 'abcDEfgh', UPPER('abcDEfgh', 1,  0 ))
    self~assertSame("subTest_03" , 'abcDEfgh', UPPER('abcDEfgh', 99, 2 ))
    self~assertSame("subTest_04" , 'aBCDEFGH', UPPER('abcDEfgh', 2     ))
    self~assertSame("subTest_05" , 'ABCDEFGH', UPPER('abcDEfgh'        ))


   -- test the BIF, using examples from the documentation
::method "test_VALUE"
    /* After: Drop A3; A33=7; K=3; fred='K'; list.5='Hi' */
    Drop A3; A33=7; K=3; fred='K'; list.5='Hi'

    self~assertSame("subTest1" , 'A3' , VALUE('a'k)    )  /* looks up A3 */
    self~assertSame("subTest2" , '7'  , VALUE('a'k||k) )
    self~assertSame("subTest3" , 'K'  , VALUE('fred')  )  /* looks up FRED */
    self~assertSame("subTest4" , '3'  , VALUE(fred)    )  /* looks up K */
    self~assertSame("subTest5" , '3'  , VALUE(fred,5)  )  /* looks up K and then sets K=5 */
    self~assertSame("subTest6" , '5'  , VALUE(fred)    )  /* looks up K */
    self~assertSame("subTest7" , 'Hi' , VALUE('LIST.'k))  /* looks up LIST.5 */

   --
    /* Given that an external variable FRED has a value of 4 */
    share = 'ENVIRONMENT'
    call value 'FRED', 4, share  -- set FRED to 4
    self~assertEquals("subTest8" , 4 , VALUE('FRED',7,share))/* says '4' and assigns */
                                                             /* FRED a new value of 7 */
    self~assertEquals("subTest9" , 7 , VALUE('FRED', ,share)) /* says '7' */

    call value 'FRED', .nil, share  -- delete 'FRED' from environment
    self~assertSame("subTest10"  , "", VALUE('FRED', ,share))

   -- test set/getting .environment-entries
    call value 'UhU', 1, ''         -- define entry 'UHU' in .environment
    self~assertSame("subTest11"  , 1, VALUE('UhU',   , ''))
    call value 'UhU', .nil, ''      -- set entry in .environment to .nil
    self~assertSame("subTest12"  , .nil, VALUE('UhU', , ''))
    .environment~remove('UHU')      -- delete entry in .environment
    self~assertSame("subTest13"  , '.UHU', VALUE('UhU', , ''))


   -- test the BIF, using examples from the documentation
::method "test_VAR"
    /* Following: DROP A.3; J=3 */
    DROP A.3; J=3
    self~assertTrue("subTest1"  , VAR('J')   )
    self~assertFalse("subTest2" , VAR(J)     ) /* has tested "3" */
    self~assertFalse("subTest3" , VAR('a.j') ) /* has tested "A.3" */
    self~assertFalse("subTest4" , VAR(2)     ) /* a constant symbol */
    self~assertFalse("subTest5" , VAR('*')   ) /* an invalid symbol */
    self~assertFalse("subTest6" , VAR('.LOCAL')   ) /* an environment symbol, not a variable */


   -- test the BIF, using examples from the documentation
::method "test_VERIFY"
    self~assertEquals("subTest1" , 0 , VERIFY('123','1234567890')         )
    self~assertEquals("subTest2" , 2 , VERIFY('1Z3','1234567890')         )
    self~assertEquals("subTest3" , 1 , VERIFY('AB4T','1234567890')        )
    self~assertEquals("subTest4" , 3 , VERIFY('AB4T','1234567890','M')    )
    self~assertEquals("subTest5" , 1 , VERIFY('AB4T','1234567890','N')    )
    self~assertEquals("subTest6" , 4 , VERIFY('1P3Q4','1234567890', ,3)   )
    self~assertEquals("subTest7" , 2 , VERIFY('123','',N,2)               )  --
    self~assertEquals("subTest8" , 3 , VERIFY('ABCDE','', ,3)             )  --
    self~assertEquals("subTest9" , 6 , VERIFY('AB3CD5','1234567890','M',4))


   -- test the BIF, using examples from the documentation
::method "test_WORD"
    self~assertSame("subTest1" , 'the' , WORD('Now is the time',3) )
    self~assertSame("subTest2" , ""    , WORD('Now is the time',5) )


   -- test the BIF, using examples from the documentation
::method "test_WORDINDEX"
    self~assertEquals("subTest1" , 8 , WORDINDEX('Now is the time',3))
    self~assertEquals("subTest2" , 0 , WORDINDEX('Now is the time',6))


   -- test the BIF, using examples from the documentation
::method "test_WORDLENGTH"
    self~assertEquals("subTest1" , 2 , WORDLENGTH('Now is the time',2)   )
    self~assertEquals("subTest2" , 5 , WORDLENGTH('Now comes the time',2))
    self~assertEquals("subTest3" , 0 , WORDLENGTH('Now is the time',6)   )


   -- test the BIF, using examples from the documentation
::method "test_WORDPOS"
    self~assertEquals("subTest1" , 3 , WORDPOS('the','now is the time')     )
    self~assertEquals("subTest2" , 0 , WORDPOS('The','now is the time')     )
    self~assertEquals("subTest3" , 2 , WORDPOS('is the','now is the time')  )
    self~assertEquals("subTest4" , 2 , WORDPOS('is the','now is the time')  )
    self~assertEquals("subTest5" , 0 , WORDPOS('is time ','now is the time'))
    self~assertEquals("subTest6" , 2 , WORDPOS('be','To be or not to be')   )
    self~assertEquals("subTest7" , 6 , WORDPOS('be','To be or not to be',3) )


   -- test the BIF, using examples from the documentation
::method "test_WORDS"
    self~assertEquals("subTest1" , 4 , WORDS('Now is the time'))
    self~assertEquals("subTest2" , 0 , WORDS(' ')              )

   -- new tests
    self~assertEquals("subTest3" , 0 , WORDS('')               )



   -- test the BIF, using examples from the documentation
::method "test_X2B"
    self~assertEquals("subTest1" , '11000011'     , X2B('C3')  )
    self~assertEquals("subTest2" , '0111'         , X2B('7')   )
    self~assertEquals("subTest3" , '000111000001' , X2B('1 C1'))

   -- new tests
    self~assertEquals("subTest4" , '' , X2B(''))
    self~assertEquals("subTest4" , '' , X2B(''))


   -- test the BIF, using examples from the documentation
::method "test_X2C"
    self~assertSame("subTest1" , 'Hello' /* ASCII */ , X2C('4865 6c6c 6f') )
    self~assertSame("subTest2" , '72s'   /* ASCII */ , X2C('3732 73')      )

   -- new tests
    self~assertSame("subTest3" , ''      /* ASCII */ , X2C('')             )


   -- test the BIF, using examples from the documentation
::method "test_X2D"
    self~assertEquals("subTest1" , 14                , X2D('0E')      )
    self~assertEquals("subTest2" , 129               , X2D('81')      )
    self~assertEquals("subTest3" , 3969              , X2D('F81')     )
    self~assertEquals("subTest4" , 65409             , X2D('FF81')    )
    self~assertEquals("subTest5" , 240 /* ASCII */   , X2D('46 30'X)  )
    self~assertEquals("subTest6" , 240 /* ASCII */   , X2D('66 30'X)  )

    self~assertEquals("subTest7" , -127              , X2D('81',2)    ) --
    self~assertEquals("subTest8" , 129               , X2D('81',4)    )
    self~assertEquals("subTest9" , -3967             , X2D('F081',4)  )
    self~assertEquals("subTest10", 129               , X2D('F081',3)  )
    self~assertEquals("subTest11", -127              , X2D('F081',2)  )
    self~assertEquals("subTest12", 1                 , X2D('F081',1)  )
    self~assertEquals("subTest13", 0                 , X2D('0031',0)  )

   -- new tests
    self~assertEquals("subTest14", 0                 , X2D('')        )
    self~assertEquals("subTest14", 0                 , X2D('',1)      )
    self~assertEquals("subTest14", 0                 , X2D('',17)     )



   -- test the BIF, using examples from the documentation
::method "test_XRANGE"
    self~assertSame("subTest1" , 'abcdef'         , XRANGE('a','f')      )
    self~assertSame("subTest2" , '0304050607'x    , XRANGE('03'x,'07'x)  )
    self~assertSame("subTest3" , '0001020304'x    , XRANGE(,'04'x)       )
    self~assertSame("subTest4" , 'FEFF000102'x    , XRANGE('FE'x,'02'x)  )
    self~assertSame("subTest5" , 'ij' /* ASCII */ , XRANGE('i','j')      )

   -- new tests
    chars=""
    do i=0 to 255
       chars=chars||d2c(i)
    end
    self~assertSame("subTest6", chars , XRANGE()            )
    self~assertSame("subTest7", chars , XRANGE("00"x, "ff"x))







