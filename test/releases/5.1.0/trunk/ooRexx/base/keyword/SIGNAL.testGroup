#!/usr/bin/env rexx
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007-2024 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* https://www.oorexx.org/license.html                                        */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
parse source . . fileSpec
group = .TestGroup~new(fileSpec)
group~add(.SIGNAL.testGroup)
if group~isAutomatedTest then
  return group
else
  return group~suite~execute~~print

::requires 'ooTest.frm'

::class SIGNAL.testGroup subclass ooTestCase public

::method "test_1"
   signal on syntax
   a = 10101k
   self~assertTrue(0)
   return

   syntax:
   self~assertSame(condition('cs'), 'SYNTAX')
   self~assertSame(condition('i'), 'SIGNAL')
   self~assertSame(condition('s'), 'OFF')
   return

::method "test_2"
   signal on syntax
   raise syntax 41.1
   self~assertTrue(0)
   return

   syntax:
   self~assertSame(condition('cs'), 'SYNTAX')
   self~assertSame(condition('i'), 'SIGNAL')
   self~assertSame(condition('s'), 'OFF')
   return

::method "test_3"
   signal on novalue
   a = z
   self~assertTrue(0)
   return

   novalue:
   self~assertSame(condition('cs'), 'NOVALUE')
   self~assertSame(condition('i'), 'SIGNAL')
   self~assertSame(condition('s'), 'OFF')
   return

::method "test_4"
   signal on novalue
   call myproc
   self~assertTrue(0)
   return

   novalue:
   self~assertSame(condition('cs'), 'NOVALUE')
   self~assertSame(condition('i'), 'SIGNAL')
   self~assertSame(condition('s'), 'OFF')
   return

   myproc:
   raise novalue return
   return

::method "test_5"
   signal off failure
   signal on error
   trace off -- we don't want ERROR trace output

   -- a non-existing command should always raise ERROR
   address "" "non-existing-command" with error using (.Array~new)
   self~assertFail("'non-existing-command' should have raised ERROR")
   return

   error:
   self~assertSame(condition('cs'), 'ERROR')
   self~assertSame(condition('i'), 'SIGNAL')
   self~assertSame(condition('s'), 'OFF')
   return

::method "test_6"
   signal on error
   call myproc
   self~assertTrue(0)
   return

   error:
   self~assertSame(condition('cs'), 'ERROR')
   self~assertSame(condition('i'), 'SIGNAL')
   self~assertSame(condition('s'), 'OFF')
   return

   myproc: procedure
   raise error 44.1 return
   return

::method "test_7"
   signal on user badvalue
   call myproc
   self~assertTrue(0)
   return

   badvalue:
   self~assertSame(condition('cs'), 'USER BADVALUE')
   self~assertSame(condition('i'), 'SIGNAL')
   self~assertSame(condition('s'), 'OFF')
   return

   myproc: procedure
   raise user badvalue return
   return

::method "test_8"
   signal on failure
   trace off

   address xyzzy 'grue'  -- this is a deliberate unknown command
   self~assertTrue(0)
   return

   failure:
   self~assertSame(condition('cs'), 'FAILURE')
   self~assertSame(condition('i'), 'SIGNAL')
   self~assertSame(condition('s'), 'OFF')
   return

::method "test_9"
   signal on failure
   call myproc
   self~assertTrue(0)
   return

   failure:
   self~assertSame(condition('cs'), 'FAILURE')
   self~assertSame(condition('i'), 'SIGNAL')
   self~assertSame(condition('s'), 'OFF')
   return

   myproc: procedure
   raise failure 44.1 return
   return


-- testcases added for [bugs:#1361] SIGNAL ON ANY doesn't trigger on NOVALUE
::method test_signal_any_condition_error
  self~expectCondition("ERROR")
  signal on any
  "exit 1"                   -- raises ERROR (Windows/Linux)
  return
  any: raise propagate

::method test_signal_any_condition_failure
  self~expectCondition("FAILURE")
  signal on any
  trace off                  -- avoid trace output from FAILURE
  address a_failure ""       -- raises FAILURE
  return
  any: raise propagate

::method test_signal_any_condition_halt
  self~expectCondition("HALT")
  signal on any
  address "hostemu" "HI"     -- raises HALT
  return
  any: raise propagate
  ::requires "hostemu" LIBRARY

::method test_signal_any_condition_lostdigits
  self~expectCondition("LOSTDIGITS")
  signal on any
  a = 1 / 9999999999         -- raises LOSTDIGITS
  return
  any: raise propagate

::method test_signal_any_condition_nomethod
  self~expectCondition("NOMETHOD")
  signal on any
  ""~no_method               -- raises NOMETHOD
  return
  any: raise propagate

::method test_signal_any_condition_nostring
  self~expectCondition("NOSTRING")
  signal on any
  call datatype .nil         -- raises NOSTRING
  return
  any: raise propagate

::method test_signal_any_condition_notready
  self~expectCondition("NOTREADY")
  signal on any
  call charin "/"            -- raises NOTREADY
  return
  any: raise propagate

::method test_signal_any_condition_novalue
  self~expectCondition("NOVALUE")
  signal on any
  call datatype no_value     -- raises NOVALUE
  return
  any: raise propagate

::method test_signal_any_condition_syntax
  self~expectSyntax(43.1)
  signal on any
  call no_target             -- raises SYNTAX
  return
  any: raise propagate

-- [bugs:#1664] OPTIONS NOVALUE becomes disabled unexpectedly
::method test_bug_1664
  -- none of these should raise NOVALUE
  self~runDynamicSource(("signal off novalue; return a; ::options novalue syntax"))
  self~runDynamicSource(("signal off novalue; return a; ::options all syntax"))

  -- but these two should raise Error 98.986:  Reference to unassigned variable
  self~assertSyntaxError(98.986, ("signal off lostdigits; a = a; ::options novalue syntax"))
  self~assertSyntaxError(98.986, ("signal off lostdigits; a = a; ::options all syntax"))

-- [bugs:#1877] SYNTAX error raised on next clause only
-- if (e.g.) a NOVALUE is raised and fails due to missing label, the resulting
-- SYNTAX should be raised on the same clause instead of the next clause only
::method test_bug_1877
  signal on novalue
  signal on syntax
  a = novalue
  a = "next clause"
  syntax:
  self~assertNotSame("next clause", a)


-- SIGNAL label tests

::method test_no_label
  -- String or symbol expected after SIGNAL keyword
  self~assertSyntaxError(19.4, "signal")

::method test_label_additional
  -- Data must not follow the SIGNAL label name
  self~assertSyntaxError(21.905, "signal lbl x")

::method test_value_missing
  -- Missing expression following VALUE keyword of a SIGNAL instruction
  self~assertSyntaxError(35.915, "signal value")

::method test_label_symbol_not_found
  self~expectSyntax(16.1) -- Label "X" not found
  signal x

::method test_label_symbol
  lbl = "FAIL"
  signal lbl -- just a symbol, not a variable
  fail: self~assertFail
  lbl:

::method test_label_literal
  lbl = "FAIL"
  signal "lbl" -- a literal, case-sensitive
  lbl: "LBL": fail: self~assertFail
  "lbl":

::method test_label_literal_hex
  lbl = "FAIL"
  signal '41 42 43'x -- hex literal "ABC"
  lbl: "abc": self~assertFail
  abc:

::method test_label_value_string
  value = "ABC"
  signal (value) -- an expression in parens
  value: "abc": self~assertFail
  '41 42 43'x:

::method test_label_duplicate
  signal lbl -- should transfer to first label found
  nop; lbl: nop
  return
  lbl: self~assertFail

::method test_label_if
  if 0 then
    signal fail
  else
    signal lbl -- ends IF
  fail: self~assertFail
  lbl:

::method test_label_do
  do 2
    signal lbl -- ends DO
  end
  self~assertFail
  lbl:

::method test_label_select
  select
    when 0 then signal fail
    otherwise signal lbl -- ends SELECT
  end
  fail: self~assertFail
  lbl:

::method test_label_interpret
  interpret "signal lbl" -- ends INTERPRET
  self~assertFail
  lbl:


::options all syntax
