#!/usr/bin/env rexx
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007-2022 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* https://www.oorexx.org/license.html                                        */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
parse source . . fileSpec
group = .TestGroup~new(fileSpec)
group~add(.environmentEntries.testGroup)
if group~isAutomatedTest then
  return group
else
  return group~suite~execute~~print

::requires 'ooTest.frm' -- load the ooRexxUnit classes

::class environmentEntries.testGroup subclass ooTestCase public

::constant isWindows (.RexxInfo~platform~caselessStartsWith("Windows"))


-- .local

-- .local~allIndexes~sort
::resource local
DEBUGINPUT
ERROR
INPUT
OUTPUT
STDERR
STDIN
STDOUT
STDQUE
SYSCARGS
TRACEOUTPUT
::END

::method test_local_entries
  -- all above should be found in .local
  do entry over .resources~local
    self~assertTrue(.local~hasIndex(entry), ".local should contain" entry)
  end

-- .local has Monitors .debuginput, .error, .input, .output, and .traceoutput
::method test_local_monitors
  do monitor over "debuginput", "error", "input", "output", "traceoutput"
    self~assertIsA(value("."monitor), .Monitor, monitor "should be a Monitor; found" value("."monitor)~class~id)
  end

  self~assertSame(.input, .debugInput~current)
  self~assertSame(.stderr, .error~current)
  self~assertSame(.stdin, .input~current)
  self~assertSame(.stdout, .output~current)
  self~assertSame(.error, .traceoutput~current)

-- below five invalid destination tests leave the Monitors in disarray
-- that makes other tests fail, so we run them last (_zzz_)
::method test_zzz_output_invalid
  self~expectSyntax(97.1) -- Object .. does not understand message "SAY"
  .output~destination("") -- has no SAY method
  say 123

::method test_zzz_error_invalid
  self~expectSyntax(97.1) -- Object .. does not understand message "LINEOUT"
  .error~destination("") -- has no LINEOUT method
  .error~lineOut

::method test_zzz_traceoutput_invalid
  self~expectSyntax(97.1) -- Object .. does not understand message "LINEOUT"
  .traceOutput~destination("") -- has no LINEOUT method
  trace r
  trace n

::method test_zzz_input_invalid
  self~expectSyntax(97.1) -- Object .. does not understand message "LINEIN"
  .input~destination("") -- has no LINEIN method
  pull .

::method test_zzz_debuginput_invalid
  self~expectSyntax(97.1) -- Object .. does not understand message "LINEIN"
  .debugInput~destination("") -- has no LINEIN method
  self~disableTraceOutput -- .traceOutput~destination(.NullOutput~new)
  trace ?r
  trace ?

-- redirect .output to capture some output
::method test_output
  -- switch .Output to an ArrayStream
  arrayStream = .ArrayStream~new
  .Output~destination(arrayStream)
  -- .Output is the destination for SAY, .Output~lineOut, and
  -- LINEOUT with no stream name
  say "SAY"
  .Output~lineOut("Output~say")

  -- switch off .Output, no output should show up
  self~disableOutput -- .Output~destination(.NullOutput~new)
  say "disabled SAY"
  .Output~lineOut("disabled Output~say")
  call lineout , "disabled LINEOUT"

  -- and back to our ArrayStream
  .Output~destination
  call lineout , "LINEOUT"

  -- back to default
  .Output~destination
  self~assertSame(.stdout, .Output~current)

  -- only those three lines of output should have been captured
  self~assertSameList(("SAY", "Output~say", "LINEOUT"), arrayStream)

-- capture .Error output
::method test_error
  -- .Error is the default destination for error messages and trace output
  -- as long as .TraceOutput redirects to .Error (which is the default)
  arrayStream = .ArrayStream~new
  .Error~destination(arrayStream)
  trace label
  label: line1 = .line
  -- switch off .Error, no error output should show up
  self~disableError -- .Error~destination(.NullOutput~new)
  secondLabel:

  -- and back to our ArrayStream
  .Error~destination
  thirdLabel: line3 = .line
  -- only these two lines of trace output should have been captured
  self~assertSameList(( -
   line1~format(6) "*-* label:", line3~format(6) "*-* thirdLabel:"), arrayStream)

  -- back to default
  .Error~destination
  self~assertSame(.stderr, .Error~current)

-- use redirected .input to feed various input operations
::method test_input
  -- .input is the source for PULL, PARSE PULL, PARSE LINEIN, the
  -- LINEIN bif (if no stream is given), and the .input~lineIn method
  .input~destination(.ArrayStream~of("a", "b", "c", "d", "e"))
  pull a
  parse pull b
  parse linein c
  d = linein()
  e = .input~lineIn
  .input~destination
  self~assertSame("A b c d e", a b c d e)

-- use redirected .debugInput to run an Interactive Debugging session
::method test_debuginput_traceoutput
  -- .debugInput is the source for Interactive Debugging with trace ?
  -- debugging steps are: step into the "if"; correct its course by setting
  -- "a=2", redo the if, and end tracing
  .debugInput~destination(.ArrayStream~of("", "a=2", "=", "trace ?"))
  -- .traceOutput is the destination for trace output (and error messages)
  -- we don't want to see our interactive debug output
  self~disableTraceOutput -- .traceOutput~destination(.NullOutput~new)
  trace ?r
  a = 1
  if a = 2 then a = 3
  .debugInput~destination
  self~assertSame(3, a)


-- .local has Streams .stderr, stdin, .stdout,
-- RexxQueue .stdque, and Array .syscargs
::method test_local_streams_queue_array
  self~assertIsA(.stderr, .Stream)
  self~assertIsA(.stdin, .Stream)
  self~assertIsA(.stdout, .Stream)
  self~assertIsA(.stdque, .RexxQueue)
  self~assertSame("SESSION", .stdque)
  self~assertIsA(.syscargs, .Array)


-- .environment

-- .environment~allIndexes~sort~~removeItem("OLEOBJECT")~~removeItem("OLEVARIANT")
::resource environment
ALARM
ALARMNOTIFICATION
ARGUTIL
ARRAY
BAG
BUFFER
CASELESSCOLUMNCOMPARATOR
CASELESSCOMPARATOR
CASELESSDESCENDINGCOMPARATOR
CIRCULARQUEUE
CLASS
COLLECTION
COLUMNCOMPARATOR
COMPARABLE
COMPARATOR
DATETIME
DESCENDINGCOMPARATOR
DIRECTORY
ENDOFLINE
ENVIRONMENT
EVENTSEMAPHORE
FALSE
FILE
IDENTITYTABLE
INPUTOUTPUTSTREAM
INPUTSTREAM
INVERTINGCOMPARATOR
LIST
LOCAL
MAPCOLLECTION
MESSAGE
MESSAGENOTIFICATION
METHOD
MONITOR
MUTABLEBUFFER
MUTEXSEMAPHORE
NIL
NUMERICCOMPARATOR
OBJECT
ORDERABLE
ORDEREDCOLLECTION
OUTPUTSTREAM
PACKAGE
POINTER
PROPERTIES
QUEUE
RELATION
REXXCONTEXT
REXXINFO
REXXQUEUE
ROUTINE
SET
SETCOLLECTION
SINGLETON
STACKFRAME
STEM
STREAM
STREAMSUPPLIER
STRING
STRINGTABLE
SUPPLIER
TABLE
TICKER
TIMESPAN
TRUE
VALIDATE
VARIABLEREFERENCE
WEAKREFERENCE
::END

-- do entry over .environment~allIndexes~sort
--   if value(entry, , "")~class~id \= "Class" then
--     say entry
-- end
::resource environmentOther
ENDOFLINE
ENVIRONMENT
FALSE
LOCAL
NIL
REXXINFO
TRUE
::END

::method test_environment_entries
  entries = .resources~environment
  if self~isWindows then
    entries = entries~appendAll(("OLEOBJECT", "OLEVARIANT"))

  do entry over entries
    self~assertTrue(.environment~hasIndex(entry), ".environment should contain" entry)
  end

  do entry over entries~difference(.resources~environmentOther)
    self~assertIsA(value(entry, , ""), .Class, "." || entry "should be a class")
  end

  -- .endofline should be '0d 0a'x on Windows and '0a'x else
  self~assertSame(self~isWindows~?('0d 0a'x, '0a'x), .endofline)

  -- .RexxInfo is a RexxInfo instance
  self~assertIsA(.RexxInfo, .RexxInfo~class)


-- .false, .true, .nil

::method test_false_true_nil
  self~assertSame(0, .false)
  self~assertSame(1, .true)
  self~assertNull(.nil)


-- Rexx-defined symbols

-- .context, .line, .methods, .routines, .resources, .rs
::method test_rexx_defined_symbols
  -- .context: should be a RexxContext instance
  self~assertIsa(.context, .RexxContext)

  -- .line: should always be a number and match with sigl
  self~assertSame("NUM", .line~dataType)
  line = .line
  -- below line number should be equal to above line number plus 2
  self~assertSame(line + 2, .line)
  -- sigl and .line should give same result
  signal foo; foo: line = sigl; self~assertSame(line, .line)

  -- .methods: this test group has no floating methods
  self~assertSame(".METHODS", .methods)
  self~assertIsa(self~runDynamicSource(("return .methods", "::method m")), .Stringtable)

  -- .routines: this test group has no routines
  self~assertSame(".ROUTINES", .routines)
  self~assertIsa(self~runDynamicSource(("return .routines", "::routine r")), .Stringtable)

  -- .resources: this test group has some resources
  self~assertIsa(.resources, .StringTable)
  self~assertSame(".RESOURCES", self~runDynamicSource("return .resources"))

  -- .rs: initially command return status is not set
  self~assertEquals(".RS", .rs)
  -- should be 0 when a command is successful
  address "" "exit" -- returns 0 on both Unix and Windows
  self~assertSame(0, .rs)
  -- should be 1 after an ERROR
  address "" "exit 2" -- returns 2 on both Unix and Windows
  self~assertSame(1, .rs)
  -- should be is -1 after a FAILURE
  trace off -- no trace please
  address "badenvironment" "exit"
  self~assertSame(-1, .rs)


-- we inherit from stream just for the SAY method
::class ArrayStream subclass Array inherit Stream
::method init
  expose line
  line = 0
  array = .Array~new
::method lineOut
  self~append(arg(1))
  return 0
::method lineIn
  expose line
  line += 1
  if line > self~size then
    raise notready
  return self[line]


::options all syntax error condition failure condition
