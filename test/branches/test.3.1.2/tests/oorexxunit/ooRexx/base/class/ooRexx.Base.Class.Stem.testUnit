#!/usr/bin/rexx
/*
   name:             ooRexx.Base.Class.Stem.testUnit
   author:           Rony G. Flatscher
   date:             2007-06-10
   version:          1.0.1

-- line commented lines are ignored, when building the directory of infos from this header
   changed:          ---

   languageLevel:    6.00, 6.02
   purpose:          Test the methods of the class Stem.
   remark:           2007-06-10, ---rgf, added test cases to test collection object for correct types

   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

// category needs not to be numbered, importance is given by position (1=most important)
   category:         ooRexx
   category:         Base
   category:         Class
   category:         Stem
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/

-- Do not execute if ooRexx version 3.1.2 or less
if .ooRexxUnit.languageLevel < 6.02 then return .list~new

testUnitClass=.ooRexx.Base.Class.Stem.TestUnit  -- change accordingly
-------------------------------------------------------------------------------------------
-- ===> adapt the "testUnitList" to your testCase classes; each element in the list is <===
-- ===> an array object, the first element containing the testCase class object, the   <===
-- ===> second element is a list of test method names which are regarded to be         <===
-- ===> mandatory (if the list remains empty all test methods are mandatory)           <===

   /* list of array objects, each containing the testUnit class object and an
      optional list of mandatory test case methods name                       */
mandatoryTestMethods=.list~new   -- no mandatory tests for this testCase class
testUnitList=.list~of( .array~of(.ooRexx.Base.Class.Stem.testUnit,  mandatoryTestMethods) )


-------------------------------------------------------------------------------------------
-- ===> the following code needs not to be individualized                              <===

   -- read top comment, containing infos about this program
arrLines=.array~new
do i=1 to 150 until arrLines[i]="*/"
   arrLines[i]=sourceline(i)
end
      -- supply information for the testClass(es) in this file; the class attribute
      -- "TestCaseInfo" (a directory object, index points to a queue) will store
      -- the parsed infos
aTestUnitClass=testUnitList~at(testUnitList~first)[1] -- get first testClass

   -- will parse the array lines and store result in class object
call makeDirTestInfo aTestUnitClass, arrLines
tmpDir=aTestUnitClass~TestCaseInfo
parse source s   -- op_sys invocationType fullPathToThisFile
tmpDir~setentry("test_Case-source", s)

   -- now add this directory to other testCase classes, if any left
do arr over testUnitList
   if arr[1]=aTestUnitClass then iterate  -- already handled
   arr[1]~TestCaseInfo=tmpDir             -- save info in class object
end

-- if this file is CALLed or REQUIRED then define an entry "bRunTestLocally" in .local
-- and set it to .false; this way the independent local invocation of the tests is inhibited
if .local~hasentry("bRunTestsLocally")=.false then
   .local~bRunTestsLocally=.true -- if this file is executed directly, then run tests for debugging

if .bRunTestsLocally=.true then  -- run ALL tests in this test unit
do
   ts=.testSuite~new             -- create a testSuite
   do arr over testUnitList
      -- create a testSuite for the given test case class, use all its testmethods
      ts~addTest( .testSuite~new(arr[1]))
   end
   -- testResult=.testSuite~new(testUnitClass)~run
   testResult=ts~run       -- now run all the tests

   call simpleDumpTestResults testResult
end

   /* return list of array objects containing test case classes and
      optionally list of mandatory test methods                      */
return testUnitList



::requires ooRexxUnit.cls     -- load the ooRexxUnit classes

   -- class named exactly like file
::class "ooRexx.Base.Class.Stem.TestUnit" subclass TestCase public

::method init
  expose collDir clz bUserDefinedIndex bSingleItem o1 o2
  forward class (super) continue    -- let superclass initialize

  clz=.Stem                        -- collection class object to use
  bUserDefinedIndex=.true           -- user defined index? (determines what MAKEARRAY returns)
  bSingleItem      =.true           -- index associates only one item

  collDir=.directory~new            -- define directory containing predefined collections
  collDir~emptyColl=clz~new

  o1=.object~new
  o2=.object~new

  collDir~coll_1   =clz~new~~put("1","1")~~put("2","2")~~put("2","2")~~put(o1,"o1")~~put(o1,"o1")
  collDir~coll_2   =clz~new              ~~put("2","2")~~put("999","2")~~put("2","2")~~put(o1,"o1")~~put(o1,"o1")~~put(o2,"o2")~~put(o2,"o2")~~put("3","3")

  collDir~allIndexes1=.array~of("1", "2", "o1")
  collDir~allIndexes2=.array~of(     "2", "o1", "o2", "3")

  collDir~allItems1=.array~of("1", "2", o1)
  collDir~allItems2=.array~of(     "2", o1, o2, "3")

   /* determine resulting collection   */
  collDir~difference1 =clz~new~~put("1","1")  /* coll_1~difference(coll_2) */
  collDir~difference2 =clz~new~~put("3","3")~~put(o2,"o2")  /* coll_2~difference(coll_1) */

  collDir~interSectionColl=clz~new~~put("2","2")~~put("2","2")~~put(o1,"o1")

  collDir~unionColl       =clz~new~~put("1","1")~~put("2","2")~~put(o1,"o1")~~put(o2,"o2")~~put("3","3")

  collDir~xorColl         =clz~new~~put("1","1")~~put(o2,"o2")~~put("3","3")



::method "test_AT"
  expose collDir clz bUserDefinedIndex bSingleItem

  coll=collDir~coll_1      -- get the prepared Stem
  self~assertEquals("subtest1", "1", coll~at("1"))
  self~assertEquals("subtest2", "2", coll~at("2"))
  self~assertEquals("subtest2a", coll, coll~at)

  val="oha, Dackel"
  self~assertEquals("subtest3", val, coll~at(val))

  a.=clz~new("def")
  self~assertEquals("subtest4", a.     , a.~at)
  self~assertEquals("subtest5", a.||val, a.~at(val))
  self~assertEquals("subtest6", a.||1"."2"."3, a.~at(1,2,3))



::method "test_[]"
  expose collDir clz bUserDefinedIndex bSingleItem

  coll=collDir~coll_1      -- get the prepared Stem
  self~assertEquals("subtest1", "1", coll~"[]"("1"))
  self~assertEquals("subtest2", "2", coll~"[]"("2"))
  self~assertEquals("subtest2a", coll~string, coll~"[]")
  self~assertEquals("subtest2b", coll       , coll~"[]")

  val="oha, Dackel"
  self~assertEquals("subtest3", val, coll~"[]"(val))

  a.=clz~new("def")
  self~assertEquals("subtest4", a.~string, a.~"[]")
  self~assertEquals("subtest4a", a.      , a.~"[]")
  self~assertEquals("subtest5", a.||val, a.~"[]"(val))
  self~assertEquals("subtest6", a.||1"."2"."3, a.~"[]"(1,2,3))




::method "test_allIndexes"
  expose collDir clz bUserDefinedIndex bSingleItem

  if .ooRexxUnit.languageLevel<6.02 then
  do
     .error~say(self~string" - 'test_allIndexes': not carried out, needs language level 6.02, currently:" .ooRexxUnit.languageLevel)
     return
  end

  self~assertTrue("subtest1", sameContent(.bag~new~union(collDir~allIndexes1      ), -
                                          .bag~new~union(collDir~coll_1~allIndexes)))

  self~assertTrue("subtest2", sameContent(.bag~new~union(collDir~allIndexes2      ), -
                                          .bag~new~union(collDir~coll_2~allIndexes)))

  tmp=collDir~emptyColl~allIndexes
  self~assertTrue("subtest3", tmp~isInstanceOf(.array))
  self~assertEquals("subtest4", 0, tmp~items)


::method "test_allItems"
  expose collDir clz bUserDefinedIndex bSingleItem

  if .ooRexxUnit.languageLevel<6.02 then
  do
     .error~say(self~string" - 'test_allItems': not carried out, needs language level 6.02, currently:" .ooRexxUnit.languageLevel)
     return
  end

  self~assertTrue("subtest1", sameContent(.bag~new~union(collDir~allItems1      ), -
                                          .bag~new~union(collDir~coll_1~allItems)))

  self~assertTrue("subtest2", sameContent(.bag~new~union(collDir~allItems2      ), -
                                          .bag~new~union(collDir~coll_2~allItems)))

  tmp=collDir~emptyColl~allItems
  self~assertTrue("subtest3", tmp~isInstanceOf(.array))
  self~assertEquals("subtest4", 0, tmp~items)



::method "test_difference"
  expose collDir clz bUserDefinedIndex bSingleItem

  ce=collDir~emptyColl
  c1=collDir~coll_1
  c2=collDir~coll_2

  self~assertTrue("subtest1", sameContent(ce, ce~difference(ce)))

  self~assertTrue("subtest2", sameContent(c1, c1~difference(ce)))
  self~assertTrue("subtest3", sameContent(c2, c2~difference(ce)))

  self~assertTrue("subtest4", sameContent(collDir~difference1, c1~difference(c2)))
  self~assertTrue("subtest5", sameContent(collDir~difference2, c2~difference(c1)))

  self~assertTrue("subtest6", sameContent(ce, c1~difference(c1)))
  self~assertTrue("subtest7", sameContent(ce, c2~difference(c2)))



::method "test_empty"
  expose collDir clz bUserDefinedIndex bSingleItem

  if .ooRexxUnit.languageLevel<6.02 then
  do
     .error~say(self~string" - 'test_empty': not carried out, needs language level 6.02, currently:" .ooRexxUnit.languageLevel)
     return
  end

  ce=collDir~emptyColl
  self~assertTrue("subtest01:", sameContent(ce, ce~copy~~empty))

  c1=collDir~coll_1~copy
  self~assertTrue("subtest02:", sameContent(ce, c1~copy~~empty))

  c2=collDir~coll_2~copy
  self~assertTrue("subtest03:", sameContent(ce, c2~copy~~empty))


::method "test_hasIndex"
  expose collDir clz bUserDefinedIndex bSingleItem

  coll=collDir~coll_1      -- get the prepared Stem
  self~assertTrue( "subtest1", coll~hasIndex("1"))
  self~assertTrue( "subtest2", coll~hasIndex("2"))
  self~assertFalse("subtest3", coll~hasIndex("3"))



::method "test_hasItem"
  expose collDir clz bUserDefinedIndex bSingleItem
  if .ooRexxUnit.languageLevel<6.02 then
  do
     .error~say(self~string" - 'test_hasItem': not carried out, needs language level 6.02, currently:" .ooRexxUnit.languageLevel)
     return
  end

  coll=collDir~coll_1      -- get the prepared Stem
  self~assertTrue( "subtest1", coll~hasItem("1"))
  self~assertTrue( "subtest2", coll~hasItem("2"))
  self~assertFalse("subtest3", coll~hasItem("3"))


::method "test_index"
  expose collDir clz bUserDefinedIndex bSingleItem
  if .ooRexxUnit.languageLevel<6.02 then
  do
     .error~say(self~string" - 'test_index': not carried out, needs language level 6.02, currently:" .ooRexxUnit.languageLevel)
     return
  end

  coll=collDir~coll_1      -- get the prepared Stem
  self~assertEquals("subtest1", "1", coll~index("1"))
  self~assertEquals("subtest2", "2", coll~index("2"))
  self~assertNull(  "subtest3",      coll~index("3"))



::method "test_interSection"
  expose collDir clz bUserDefinedIndex bSingleItem

  ce=collDir~emptyColl
  c1=collDir~coll_1
  c2=collDir~coll_2
  res=collDir~interSectionColl

  self~assertTrue("subtest1", sameContent(ce, ce~interSection(ce)))
  self~assertTrue("subtest2", sameContent(ce, c1~interSection(ce)))
  self~assertTrue("subtest3", sameContent(ce, c2~interSection(ce)))

  self~assertTrue("subtest4", sameContent(res, c1~interSection(c2)))
  self~assertTrue("subtest5", sameContent(res, c2~interSection(c1)))

  self~assertTrue("subtest6", sameContent(c1, c1~interSection(c1)))
  self~assertTrue("subtest7", sameContent(c2, c2~interSection(c2)))



::method "test_isInstanceOf"     -- test whether collection object is of the correct kind (class)
  expose collDir clz bUserDefinedIndex bSingleItem

  o=collDir~coll_1

  self~assertTrue("01: subclass of .Object", o~isInstanceOf(.Object))
  self~assertTrue("02: subclass of .Object", o~isInstanceOf(clz))

  if .ooRexxUnit.languageLevel>6.01 then
     self~assertTrue("03: subclass of .OrderedCollection", o~isInstanceOf(.MapCollection))



::method "test_isEmpty"
  expose collDir clz bUserDefinedIndex bSingleItem

  if .ooRexxUnit.languageLevel<6.02 then
  do
     .error~say(self~string" - 'test_isEmpty': not carried out, needs language level 6.02, currently:" .ooRexxUnit.languageLevel)
     return
  end

  self~assertTrue( "subtest01", collDir~emptyColl~isEmpty)
  self~assertFalse("subtest02", collDir~coll_1~isEmpty)
  self~assertFalse("subtest03", collDir~coll_2~isEmpty)

  self~assertTrue( "subtest04", collDir~coll_1~copy~~empty~isEmpty)



::method "test_items"
  expose collDir clz bUserDefinedIndex bSingleItem

  self~assertEquals("subtest1", 0, collDir~emptyColl~items)
  self~assertEquals("subtest2", 3, collDir~coll_1~items)
  self~assertEquals("subtest3", 4, collDir~coll_2~items)



::method "test_makeArray"
  expose collDir clz bUserDefinedIndex bSingleItem

  tmp=collDir~coll_1~makeArray
  self~assertTrue("subtest1", tmp~isInstanceOf(.array))
  if bUserDefinedIndex then
     self~assertTrue("subtest2", sameContent(.bag~new~union(tmp                ), -
                                             .bag~new~union(collDir~allIndexes1)))
  else
     self~assertTrue("subtest2", sameContent(.bag~new~union(tmp                ), -
                                             .bag~new~union(collDir~allItems1)))


  tmp=collDir~coll_2~makeArray
  self~assertTrue("subtest3", tmp~isInstanceOf(.array))
  if bUserDefinedIndex then
     self~assertTrue("subtest4", sameContent(.bag~new~union(tmp                ), -
                                             .bag~new~union(collDir~allIndexes2)))
  else
     self~assertTrue("subtest4", sameContent(.bag~new~union(tmp                ), -
                                             .bag~new~union(collDir~allItems2)))


  tmp=collDir~emptyColl~makeArray
  self~assertTrue("subtest5", tmp~isInstanceOf(.array))
  self~assertEquals("subtest6", 0, tmp~items)



::method "test_PUT"
  expose collDir clz bUserDefinedIndex bSingleItem

  tmpColl=clz~new
  self~assertEquals("subtest01", 0, tmpColl              ~items)

  self~assertEquals("subtest02a", 1, tmpColl~~put("1","1")~items)
  self~assertTrue(  "subtest02b", tmpColl~hasindex("1"))
  self~assertTrue(  "subtest02c", tmpColl~hasitem("1"))

  self~assertEquals("subtest03", 2, tmpColl~~put("2","2")~items)
  self~assertTrue(  "subtest03b", tmpColl~hasindex("2"))
  self~assertTrue(  "subtest03c", tmpColl~hasitem("2"))

  self~assertEquals("subtest04", 2, tmpColl~~put("3","2")~items)
  self~assertTrue(  "subtest04b", tmpColl~hasindex("2"))
  self~assertTrue(  "subtest04c", tmpColl~hasitem("3"))

  self~assertEquals("subtest05", 2, tmpColl~~put("2","2")~items)
  self~assertTrue(  "subtest05b", tmpColl~hasindex("2"))
  self~assertTrue(  "subtest05c", tmpColl~hasitem("2"))

  self~assertEquals("subtest06", 3, tmpColl~~put("3","3")~items)
  self~assertTrue(  "subtest06b", tmpColl~hasindex("3"))
  self~assertTrue(  "subtest06c", tmpColl~hasitem("3"))

  self~assertTrue("subtest07", sameContent(.bag~of("1","2","3"), tmpColl))


::method "test_[]="
  expose collDir clz bUserDefinedIndex bSingleItem

  tmpColl=clz~new
  self~assertEquals("subtest01", 0, tmpColl              ~items)

  self~assertEquals("subtest02a", 1, tmpColl~~"[]="("1","1")~items)
  self~assertTrue(  "subtest02b", tmpColl~hasindex("1"))
  self~assertTrue(  "subtest02c", tmpColl~hasitem("1"))

  self~assertEquals("subtest03", 2, tmpColl~~"[]="("2","2")~items)
  self~assertTrue(  "subtest03b", tmpColl~hasindex("2"))
  self~assertTrue(  "subtest03c", tmpColl~hasitem("2"))

  self~assertEquals("subtest04", 2, tmpColl~~"[]="("3","2")~items)
  self~assertTrue(  "subtest04b", tmpColl~hasindex("2"))
  self~assertTrue(  "subtest04c", tmpColl~hasitem("3"))

  self~assertEquals("subtest05", 2, tmpColl~~"[]="("2","2")~items)
  self~assertTrue(  "subtest05b", tmpColl~hasindex("2"))
  self~assertTrue(  "subtest05c", tmpColl~hasitem("2"))

  self~assertEquals("subtest06", 3, tmpColl~~"[]="("3","3")~items)
  self~assertTrue(  "subtest06b", tmpColl~hasindex("3"))
  self~assertTrue(  "subtest06c", tmpColl~hasitem("3"))

  self~assertTrue("subtest07", sameContent(.bag~of("1","2","3"), tmpColl))



::method "test_putAll"
  expose collDir clz bUserDefinedIndex bSingleItem

  if .ooRexxUnit.languageLevel<6.02 then
  do
     .error~say(self~string" - 'test_putAll': not carried out, needs language level 6.02, currently:" .ooRexxUnit.languageLevel)
     return
  end

  tmpColl=clz~new

  ce=collDir~emptyColl
  c1=collDir~coll_1
  c2=collDir~coll_2
  cu=collDir~unionColl

  self~assertTrue("subtest01", sameContent(ce, ce~copy~~putAll(ce)))
  self~assertTrue("subtest03", sameContent(c1, c1~copy~~putAll(ce)))
  self~assertTrue("subtest04", sameContent(c2, c2~copy~~putAll(ce)))

  self~assertTrue("subtest05", sameContent(c1, clz~new~~putAll(c1)))
  self~assertTrue("subtest06", sameContent(c2, clz~new~~putAll(c2)))

  self~assertTrue("subtest07", sameContent(cu, c1~copy~~putAll(c2)))
  self~assertTrue("subtest08", sameContent(cu, c2~copy~~putAll(c1)))



::method "test_remove"
  expose collDir clz bUserDefinedIndex bSingleItem o1 o2

  ce=collDir~emptyColl~copy
  c1=collDir~coll_1~copy

  self~assertNull("subtest01", ce~remove("1"))
  self~assertNull("subtest02", ce~remove(""))

  self~assertNull("subtest03", c1~remove("99"))

  self~assertEquals("subtest04", "1", c1~remove("1"))
  self~assertNull(  "subtest05", c1~remove("1"))

  self~assertEquals("subtest06", "2", c1~remove("2"))
  self~assertNull(  "subtest07", c1~remove("2"))

  self~assertEquals("subtest08", o1, c1~remove("o1"))
  self~assertNull(  "subtest09", c1~remove("o1"))

  self~assertEquals("subtest10", 0, c1~items)



::method "test_removeItem"
  expose collDir clz bUserDefinedIndex bSingleItem o1 o2

  if .ooRexxUnit.languageLevel<6.02 then
  do
     .error~say(self~string" - 'test_removeItem': not carried out, needs language level 6.02, currently:" .ooRexxUnit.languageLevel)
     return
  end


  ce=collDir~emptyColl~copy
  c1=collDir~coll_1~copy

  self~assertNull("subtest01", ce~removeItem("1"))
  self~assertNull("subtest02", ce~removeItem(.nil))

  self~assertNull("subtest03", c1~removeItem("99"))

  self~assertEquals("subtest04", "1", c1~removeItem("1"))
  self~assertNull(  "subtest05", c1~removeItem("1"))

  self~assertEquals("subtest06", "2", c1~removeItem("2"))
  self~assertNull(  "subtest07", c1~removeItem("2"))

  self~assertEquals("subtest07", o1, c1~removeItem(o1))
  self~assertNull(  "subtest08", c1~removeItem(o1))

  self~assertEquals("subtest09", 0, c1~items)



::method "test_subset"
  expose collDir clz bUserDefinedIndex bSingleItem

  ce=collDir~emptyColl
  c1=collDir~coll_1
  c2=collDir~coll_2
  cu=collDir~unionColl

  self~assertTrue("subtest01", ce~subset(ce))
  self~assertTrue("subtest02", ce~subset(c1))
  self~assertTrue("subtest03", ce~subset(c2))

  self~assertTrue("subtest04", c1~subset(c1))
  self~assertTrue("subtest05", c2~subset(c2))

  self~assertTrue("subtest06", ce~subset(cu))
  self~assertTrue("subtest07", c1~subset(cu))
  self~assertTrue("subtest08", c2~subset(cu))

  self~assertFalse("subtest10", c1~subset(ce))
  self~assertFalse("subtest11", c1~subset(c2))

  self~assertFalse("subtest12", c2~subset(ce))
  self~assertFalse("subtest13", c2~subset(c1))



::method "test_Supplier"
  expose collDir clz bUserDefinedIndex bSingleItem

  ce=collDir~emptyColl
  c1=collDir~coll_1

  self~assertTrue("subtest01", sameContent(ce, makeColl(clz, ce)))
  self~assertTrue("subtest02", sameContent(c1, makeColl(clz, c1)))

  return

makeColl: procedure
  use arg clz, tmpColl

  new=clz~new
  s=tmpColl~supplier
  do while s~available
     new~put(s~item, s~index)
     s~next
  end
  return new



::method "test_union"
  expose collDir clz bUserDefinedIndex bSingleItem

  ce=collDir~emptyColl
  c1=collDir~coll_1
  c2=collDir~coll_2
  res=collDir~unionColl

  self~assertTrue("subtest1", sameContent(ce, ce~union(ce)))

  self~assertTrue("subtest2", sameContent(c1, c1~union(ce)))
  self~assertTrue("subtest3", sameContent(c2, c2~union(ce)))

  self~assertTrue("subtest4", sameContent(c1, ce~union(c1)))
  self~assertTrue("subtest5", sameContent(c2, ce~union(c2)))

  self~assertTrue("subtest6", sameContent(res, c1~union(c2)))
  self~assertTrue("subtest7", sameContent(res, c2~union(c1)))



::method "test_xor"
  expose collDir clz bUserDefinedIndex bSingleItem

  ce=collDir~emptyColl
  c1=collDir~coll_1
  c2=collDir~coll_2
  res=collDir~xorColl

  self~assertTrue("subtest1", sameContent(ce, ce~xor(ce)))
  self~assertTrue("subtest2", sameContent(c1, c1~xor(ce)))

  self~assertTrue("subtest3", sameContent(c2, c2~xor(ce)))

  self~assertTrue("subtest4", sameContent(res, c1~xor(c2)))
  self~assertTrue("subtest5", sameContent(res, c2~xor(c1)))

  self~assertTrue("subtest6", sameContent(ce, c1~xor(c1)))
  self~assertTrue("subtest7", sameContent(ce, c2~xor(c2)))





/* --------------------- Stem specific methods -------------------- */

/* test the default value */

::method "test_default_value"
  expose collDir clz bUserDefinedIndex bSingleItem o1 o2

         /* explicitly created stem object      */
  s=clz~new          -- no default value given, hence empty string ""
  self~assertSame("subtest_01a", ""     , s~at       )
  self~assertSame("subtest_01b", "1"    , s~at("1")  )
  self~assertSame("subtest_01c", "aha"  , s~at("aha"))
  self~assertSame("subtest_01d", "1.A.1", s~at(1, "A", 1))

  self~assertSame("subtest_02a", ""     , s~"[]"       )
  self~assertSame("subtest_02b", "1"    , s~"[]"("1")  )
  self~assertSame("subtest_02c", "aha"  , s~"[]"("aha"))
  self~assertSame("subtest_02d", "1.A.1", s~"[]"(1, "A", 1))

       /* implicitly created stem object, using stem name as default value  */
  self~assertSame("subtest_03a", "A."     , a.~at       )
  self~assertSame("subtest_03b", "A.1"    , a.~at("1")  )
  self~assertSame("subtest_03c", "A.aha"  , a.~at("aha"))
  self~assertSame("subtest_03d", "A.1.A.1", a.~at(1, "A", 1))

  self~assertSame("subtest_04a", "A."     , a.~"[]"       )
  self~assertSame("subtest_04b", "A.1"    , a.~"[]"("1")  )
  self~assertSame("subtest_04c", "A.aha"  , a.~"[]"("aha"))
  self~assertSame("subtest_04d", "A.1.A.1", a.~"[]"(1, "A", 1))

      /* explicitly created stem object, changing default values */
  defVal1="DefaultValue1"
  defVal2="DefaultValue2"
  s=clz~new(defVal1)

  self~assertSame("subtest_05a", defVal1, s~at  )
  self~assertSame("subtest_05b", defVal1, s~"[]")

  self~assertEquals("subtest_06a", 0, s~items)
  s~put("1", "1")
  self~assertEquals("subtest_06b", 1, s~items)

         /* resetting default value, will empty stem  */
  s~put(defVal2)
  self~assertSame("subtest_07a", defVal2, s~at  )
  self~assertSame("subtest_07b", defVal2, s~"[]")
  self~assertEquals("subtest_08a", 0, s~items)
  s~put("1", "1")
  self~assertEquals("subtest_08b", 1, s~items)






::method "test_unknown_error1"
  expose collDir clz bUserDefinedIndex bSingleItem o1 o2

  a=clz~new
  self~expectSyntax(93.903)
  a~unknown


::method "test_unknown_error2"
  expose collDir clz bUserDefinedIndex bSingleItem o1 o2

  a=clz~new
  self~expectSyntax(93.938)
  a~unknown(.object~new)

::method "test_unknown_error3"
  expose collDir clz bUserDefinedIndex bSingleItem o1 o2

  a=clz~new
  self~expectSyntax(93.903)
  a~unknown(nixi)


::method "test_unknown_error4"
  expose collDir clz bUserDefinedIndex bSingleItem o1 o2

  a=clz~new
  self~expectSyntax(93.902)
  a~unknown(nixi, noxi, nixo)


::method "test_unknown_error5"
  expose collDir clz bUserDefinedIndex bSingleItem o1 o2

  a=clz~new
  self~expectSyntax(93.938)
  a~unknown(.nil, .nil)








/* Test whether both collections contain the same entries.
   returns .true, if the same, .false else
*/
::routine "sameContent"
  use arg coll_1, coll_2

  if coll_1~items<>coll_2~items then      -- not the same amount of objects
     return .false
   -- work on a copy
  tmp=coll_1~copy
  do o over coll_2
     if \tmp~hasindex(o) then             -- no entry anymore ?
        return .false

     tmp~remove(o)                        -- remove object
  end

  return (tmp~items=0)                    -- if the same, then no items left


::routine "dumpColl"
  use arg coll, title
  if arg(2, "o") then title=o~class~id "object ("coll~items" entries)"

  .output~charout(">>>" title": [")
  do o over coll
     .output~charout("" o~string)
  end
  say "] <<<"
  say

