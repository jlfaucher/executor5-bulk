#!/usr/bin/rexx
/*
   name:             String_datatypeMethod.testGroup
   author:           Lee Peedin
   date:             2007-12-24
   version:          1.0.0

-- line commented lines are ignored, when building the directory of infos from this header

   languageLevel:    6.02
   purpose:          Test the datatype method of the class String.
   remark:           Initial test unit for demonstration purposes, needs to be completed.

   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

// category needs not to be numbered, importance is given by position (1=most important)
   category:         ooRexx
   category:         Base
   category:         Class
   category:         String
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007 - 2008 Rexx Language Association. All rights reserved.  */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/


-------------------------------------------------------------------------------------------
-- ===> adapt the "testGroupList" to your testCase classes; each element in the list is <===
-- ===> an array object, the first element containing the testCase class object, the   <===
-- ===> second element is a list of test method names which are regarded to be         <===
-- ===> mandatory (if the list remains empty all test methods are mandatory)           <===

   /* list of array objects, each containing the testGroup class object and an
      optional list of mandatory test case methods name                       */
mandatoryTestMethods=.list~new   -- no mandatory tests for this testCase class
testGroupList=.list~of( .array~of(.String_datatypeMethod.testGroup,  mandatoryTestMethods) )


-------------------------------------------------------------------------------------------
-- ===> the following code needs not to be individualized                              <===

   -- read top comment, containing infos about this program
arrLines=.array~new
do i=1 to 150 until arrLines[i]="*/"
   arrLines[i]=sourceline(i)
end
      -- supply information for the testClass(es) in this file; the class attribute
      -- "TestCaseInfo" (a directory object, index points to a queue) will store
      -- the parsed infos
aTestGroupClass=testGroupList~at(testGroupList~first)[1] -- get first testClass

   -- will parse the array lines and store result in class object
call makeDirTestInfo aTestGroupClass, arrLines
tmpDir=aTestGroupClass~TestCaseInfo
parse source s   -- op_sys invocationType fullPathToThisFile
tmpDir~setentry("test_Case-source", s)

   -- now add this directory to other testCase classes, if any left
do arr over testGroupList
   if arr[1]=aTestGroupClass then iterate  -- already handled
   arr[1]~TestCaseInfo=tmpDir             -- save info in class object
end

-- if this file is CALLed or REQUIRED then define an entry "bRunTestLocally" in .local
-- and set it to .false; this way the independent local invocation of the tests is inhibited
if .local~hasentry("bRunTestsLocally")=.false then
   .local~bRunTestsLocally=.true -- if this file is executed directly, then run tests for debugging

if .bRunTestsLocally=.true then  -- run ALL tests in this test unit
do
   ts=.testSuite~new             -- create a testSuite
   do arr over testGroupList
      -- create a testSuite for the given test case class, use all its testmethods
      ts~addTest( .testSuite~new(arr[1]))
   end
   -- testResult=.testSuite~new(testGroupClass)~run
   testResult=ts~run       -- now run all the tests

   call simpleFormatTestResults testResult
end

   /* return list of array objects containing test case classes and
      optionally list of mandatory test methods                      */
return testGroupList

::requires ooRexxUnit.cls     -- load the ooRexxUnit classes

::class "String_datatypeMethod.testGroup" subclass TestCase public

::method 'test01'
    s = ''
    self~assertSame('subTest01','010000001C',dts(s))

::method 'test02'
    do i = 0 to 255
        s = d2c(i)
        self~assertSame('subTest'i~right(3,'0'),mydts(s),dts(s))
    end

::method 'test03'
    sarray = .array~new()
    sarray~append('A')
    sarray~append('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
    sarray~append('a')
    sarray~append('abcdefghijklmnopqrstuvwxyz')
    sarray~append('aBCDEFGHIJKLMNOPQRSTUVWXYZ')
    sarray~append('ABCdEFGHIJKLMNOPQRSTUVWXYZ')
    sarray~append('Abcdefghijklmnopqrstuvwxyz')
    sarray~append('abcDefghijklmnopqrstuvwxyz')
    sarray~append(' bcdeFghijklmnopqrstuvwxyz')
    sarray~append('abc efGhijklmnopqrstuvwxyz')
    sarray~append('abcdefgHijklmnopqrstuvwxy ')
    sarray~append('abcdefghI     opqrstuvwxyz')
    sarray~append(copies('a',100000))
    sarray~append('{')
    sarray~append('º')
    sarray~append('}')
    sarray~append('›')
    sarray~append('\')
    sarray~append('!')
    sarray~append('~')
    sarray~append('%')
    sarray~append('ª')
    sarray~append('&')
    sarray~append('*')
    sarray~append('$')
    sarray~append('cba@')
    sarray~append('@aBc')
    sarray~append('?')
    sarray~append('!?!')
    sarray~append('!?|')
    sarray~append('.')
    sarray~append('-')
    sarray~append('+')
    sarray~append('1.1.')
    sarray~append('+1.1.')
    sarray~append('-1.1.')
    sarray~append('1.e.1')
    sarray~append('1e.1')
    sarray~append('+')
    sarray~append('@')
    sarray~append(copies('0',100000))
    sarray~append(copies('1',100000))
    sarray~append(1)
    sarray~append(1.0)
    sarray~append(.0)
    sarray~append('1')
    sarray~append('-1')
    sarray~append('+1')
    sarray~append('2')
    sarray~append('123456789')
    sarray~append('1234567890')
    sarray~append('12345678901')
    sarray~append('-1.4142')
    sarray~append('+1.4142')
    sarray~append('+1.733e+5')
    sarray~append('-1.733e+5')
    sarray~append('+1.733e-5')
    sarray~append('-1.733e-5')
    sarray~append('2.7172718536')
    sarray~append('123.456789')
    sarray~append('1230.456789')
    sarray~append('1e-3')
    sarray~append('1E-3')
    sarray~append('1e+3')
    sarray~append('1E+3')
    sarray~append('1E -3')
    sarray~append('1e 3')
    sarray~append('1.e3')
    sarray~append('1e3')
    sarray~append('1E3')
    sarray~append(' 1E+3')
    sarray~append(' 1e3')
    sarray~append('1E+3 ')
    sarray~append('1e3 ')
    sarray~append('1e')
    sarray~append('e3')
    sarray~append('1e999999999')
    sarray~append('1e1000000000')
    sarray~append('1e+999999999')
    sarray~append('1e+1000000000')
    sarray~append('1e-999999999')
    sarray~append('1e-1000000000')
    sarray~append(copies('1234567890',25))
    sarray~append(copies('1234567890',25)'1')
    sarray~append(copies('1234567890',24)'e3')
    sarray~append(copies('1234567890',25)'e3')
    sarray~append(copies('1234567890', 5000)'.'copies('1234567890', 5000))
    sarray~append(copies('1234567890', 5000)'.'copies('1234567890', 5000)'e3')
    sarray~append(copies('1234567890', 3333)'.'copies('1234567890', 3333)'e'copies('1234567890', 3333))
    sarray~append(copies('1234567890',10000)'e+3')
    sarray~append(copies('1234567890',10000)'e-3')
    sarray~append(copies('1234567890', 5000)'.'copies('1234567890', 5000)'e+3')
    sarray~append(copies('1234567890', 5000)'.'copies('1234567890', 5000)'e-3')
    sarray~append('0123456789abcdef')
    sarray~append('0123456789ABCDEF')
    sarray~append('C2 0DAB')
    sarray~append('C2 DAB')
    sarray~append('c2 0dab')
    sarray~append('c2 dab')
    sarray~append('C2 0dab')
    sarray~append('c2 0Dab')
    sarray~append('C2  0d ab')
    sarray~append('c2   0D       ab')
    sarray~append(' c2   0D       ab')
    sarray~append('  c2   0D       ab')
    sarray~append('c2   0D       ab  ')
    sarray~append('c2   0D       ab ')
    sarray~append(' c2   0D       ab  ')
    sarray~append('  c2   0D       ab ')

    rarray = .array~new()
    rarray~append('100101101C')
    rarray~append('100101100C')
    rarray~append('101101001C')
    rarray~append('101101000C')
    rarray~append('100101000C')
    rarray~append('100101000C')
    rarray~append('100101000C')
    rarray~append('100101000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('101100001C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000001000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000001000C')
    rarray~append('000001000C')
    rarray~append('000000000C')
    rarray~append('000001000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000001000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000001000C')
    rarray~append('000001000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('110010011N')
    rarray~append('110010001N')
    rarray~append('110011011N')
    rarray~append('000011010N')
    rarray~append('000011010N')
    rarray~append('110011011N')
    rarray~append('000010010N')
    rarray~append('000010010N')
    rarray~append('100011011N')
    rarray~append('100011011N')
    rarray~append('100011001N')
    rarray~append('100011001N')
    rarray~append('000010000N')
    rarray~append('000010000N')
    rarray~append('000010010N')
    rarray~append('000010010N')
    rarray~append('000010000N')
    rarray~append('000010000N')
    rarray~append('000011000N')
    rarray~append('000011000N')
    rarray~append('000011000N')
    rarray~append('000011000N')
    rarray~append('000011000N')
    rarray~append('000011010N')
    rarray~append('000011010N')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000011010N')
    rarray~append('100011011N')
    rarray~append('100011011N')
    rarray~append('000010010N')
    rarray~append('000010010N')
    rarray~append('000010010N')
    rarray~append('000010010N')
    rarray~append('100001001C')
    rarray~append('100001001C')
    rarray~append('100011001N')
    rarray~append('100001001C')
    rarray~append('000011000N')
    rarray~append('000001000C')
    rarray~append('000011000N')
    rarray~append('000001000C')
    rarray~append('100011001N')
    rarray~append('100010001N')
    rarray~append('100011001N')
    rarray~append('100010001N')
    rarray~append('000010000N')
    rarray~append('000010000N')
    rarray~append('000000000C')
    rarray~append('000010000N')
    rarray~append('000010000N')
    rarray~append('000010000N')
    rarray~append('000010000N')
    rarray~append('100001001C')
    rarray~append('100001001C')
    rarray~append('000000001C')
    rarray~append('000000000C')
    rarray~append('000000001C')
    rarray~append('000000000C')
    rarray~append('000000001C')
    rarray~append('000000001C')
    rarray~append('000000001C')
    rarray~append('000000001C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')

    do i = 1 to sarray~items
        self~assertSame('subTest'i~right(3,'0'),rarray[i],dts(sarray[i]))
    end

::method 'test04'  -- Additional tests added by Lee
    self~assertTrue('subtest01',(0)~datatype('O'))

::method 'test05'
    self~assertTrue('subtest01',(1)~datatype('O'))

::method 'test06'
    self~assertFalse('subtest02',(2)~datatype('O'))

::method 'test07'
    self~assertFalse('subtest03',(-1)~datatype('O'))

::method 'test08'
    self~assertFalse('subtest04',('')~datatype('O'))

-- Found some more tests to add
::method 'test09'
    numeric digits 3
    a0 = 0
    a1 = 1
    self~assertSame('subTest01','1',(999)~datatype('w'))
    self~assertSame('subTest02',a1,(1.004)~datatype('w'))
    self~assertSame('subTest03','0',(1.005)~datatype('w'))
    self~assertSame('subTest04',a0,(1.00E+3)~datatype('w'))
    self~assertSame('subTest05','0',(-1.23456789012345E-2)~datatype('w'))

::method 'test10'
    numeric digits 4
    self~assertSame('subTest01','1',(1000)~datatype('w'))

::routine dts
    parse arg a
    x = a~datatype
return (a)~datatype('A')||-
       (a)~datatype('B')||-
       (a)~datatype('L')||-
       (a)~datatype('M')||-
       (a)~datatype('N')||-
       (a)~datatype('S')||-
       (a)~datatype('U')||-
       (a)~datatype('W')||-
       (a)~datatype('X')||left(x,1)

::routine mydts
    parse Arg a
    notype = mydt(a,'N')
    res = mydt(a,'A')||-
          mydt(a,'B')||-
          mydt(a,'L')||-
          mydt(a,'M')||-
          mydt(a,'N')||-
          mydt(a,'S')||-
          mydt(a,'U')||-
          mydt(a,'W')||-
          mydt(a,'X')
    if notype then
        return res||'N'
    else
        return res||'C'

::routine mydt
    parse arg what,opt
    g.0numc = '0123456789'
    g.0alpl = 'abcdefghijklmnopqrstuvwxyz'
    g.0alpu = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    g.0soze = '.!?_'

    signal on Syntax name mysyntax
    select
        when opt == 'A' then
            return verify(what,g.0numc||g.0alpl||g.0alpu)=0
        when opt == 'B' then
            return verify(what,'01')=0
        when opt == 'L' then
            return verify(what,g.0alpl)=0
        when opt == 'M' then
            return verify(what,g.0alpl||g.0alpu)=0
        when opt == 'N' then
            do
                erg='1'
                dummy=what+0
                return erg
            end
        when opt == 'S' then
            return verify(what,g.0numc||g.0alpl||g.0alpu||g.0soze)=0
        when opt == 'U' then
            return verify(what,g.0alpu)=0
        when opt == 'W' then
            do
                erg='1'
                dummy=left('ABC',what)
                return erg
            end
        when opt == 'X' then
            do
                erg='1'
                dummy=x2c(what)
                return erg
            end
        otherwise
            nop
    end
return

mysyntax:
    erg = '0'
return erg

-- from bif.testgroup
   -- test the BIF, using examples from the documentation
::method "test_DATATYPE"
    self~assertEquals("subTest1" , 'NUM'  , (' 12 ')~datatype()     )
    self~assertEquals("subTest2" , 'CHAR' , ("")~datatype()         )
    self~assertEquals("subTest3" , 'CHAR' , ('123*')~datatype()     )

    self~assertTrue("subTest4"  , ('12.3')~datatype('N')  )
    self~assertFalse("subTest5" , ('12.3')~datatype('W')  )
    self~assertTrue("subTest6"  , ('Fred')~datatype('M')  )
    self~assertFalse("subTest7" , ('Fred')~datatype('U')  ) -- changed, syntax error in documentation !
    self~assertFalse("subTest8" , ('Fred')~datatype('L')  )
    self~assertTrue("subTest9"  , ('?20K')~datatype('s')  )
    self~assertTrue("subTest10" , ('BCd3')~datatype('X')  )
    self~assertTrue("subTest11" , ('BC d3')~datatype('X') )

   -- new tests
    self~assertTrue("subTest12" , ('')~datatype(     'X') )

    self~assertTrue("subTest13" , ('BCd3') ~datatype('A') ) -- alphanumeric
    self~assertFalse("subTest14", ('BC-d3')~datatype('A') )

    self~assertTrue("subTest15" , ('a1'   )~datatype('s') ) -- symbol
    self~assertTrue("subTest16" , ('.a1'  )~datatype('s') )
    self~assertTrue("subTest17" , ('_'    )~datatype('s') )
    self~assertTrue("subTest18" , ('!'    )~datatype('s') )
    self~assertTrue("subTest19" , ('?'    )~datatype('s') )
    self~assertTrue("subTest20" , ('.'    )~datatype('s') )
    self~assertTrue("subTest21" , ('1'    )~datatype('s') )
    self~assertTrue("subTest22" , ('1b_!?')~datatype('s') )
    self~assertFalse("subTest23", ('. .'  )~datatype('s') )

    self~assertTrue("subTest24" , ('abc'  )~datatype('v') ) -- variable
    self~assertTrue("subTest25" , ('?'    )~datatype('v') )
    self~assertTrue("subTest26" , ('_'    )~datatype('v') )
    self~assertTrue("subTest27" , ('!'    )~datatype('v') )
    self~assertTrue("subTest28" , ('a1!_?')~datatype('v') )
    self~assertFalse("subTest29", ('.'    )~datatype('v') )
    self~assertFalse("subTest30", ('.a'   )~datatype('v') )
    self~assertFalse("subTest31", ('1'    )~datatype('v') )


    a=digits()          -- get digits
    numeric digits 9
    self~assertTrue( "subTest32", ('0'    )~datatype('W')  ) -- whole number
    self~assertTrue( "subTest33", ('1'    )~datatype('W')  )
    self~assertTrue( "subTest34", ('-1'   )~datatype('W')  )
    self~assertTrue( "subTest35", ('12345')~datatype('W')  )
    self~assertTrue( "subTest36", ('1E3'  )~datatype('W')  )
    self~assertFalse("subTest37", ('1E9'  )~datatype('W')  )

    numeric digits a

    self~assertFalse("subTest44", ('z'  )~datatype('X')  )    -- heX-digits
    self~assertTrue( "subTest45", (''  )~datatype('X')   )

    self~assertFalse("subTest46", ('z'  )~datatype('B')         )   -- binary digits
    self~assertTrue( "subTest47", (''  )~datatype('B')          )
    self~assertTrue( "subTest48", ('01'  )~datatype('B')        )
    self~assertTrue( "subTest49", ('01101001'  )~datatype('B')  )
    self~assertTrue( "subTest50", ('0110 1001'  )~datatype('B') )
    self~assertFalse("subTest51", ('011 01001'  )~datatype('B') )


    numeric digits 9
    self~assertEquals("subTest52", 'NUM'   , (' 1e3       ')~datatype()     )
    self~assertEquals("subTest53", 'NUM'   , (' 123456789 ')~datatype()     )
    self~assertEquals("subTest54", 'NUM'   , (' 1234567891 ')~datatype()    )
    self~assertEquals("subTest55", 'CHAR'  , ("")~datatype()                )
    self~assertEquals("subTest56", 'CHAR'  , ("a")~datatype()               )
    self~assertEquals("subTest57", 'CHAR'  , ("abc")~datatype()             )
    self~assertEquals("subTest58", 'CHAR'  , ("1A0")~datatype()             )

    self~assertTrue("subTest59" ,   ("123456789012345")~datatype( "N" )    ) -- Numeric
    self~assertTrue("subTest60" ,   ("0"              )~datatype( "N" )    ) -- Numeric
    self~assertTrue("subTest61" ,   ("1234567890.1234")~datatype( "N" )    ) -- Numeric
    self~assertFalse("subTest61" ,  (""               )~datatype( "N" )    ) -- Numeric
    numeric digits a

    self~assertTrue("subtest62",    (0)~datatype(  "O") )  -- Logical (Boolean)
    self~assertTrue("subtest63",    (1)~datatype(  "O") )  -- Logical (Boolean)
    self~assertFalse("subtest64",   (2)~datatype(  "O") )  -- Logical (Boolean)
    self~assertFalse("subtest65",   (-1)~datatype( "O") )  -- Logical (Boolean)
    self~assertFalse("subtest66",   ("")~datatype( "O") )  -- Logical (Boolean)


   -- test the BIF, using examples from the documentation
::method "test_DATATYPE_WITH_OPTION_9"
    a=digits()          -- get digits

    numeric digits 1    -- make sure that numeric digits is not set to 9
    self~assertTrue( "subTest38", ('0'    )~datatype('9')  ) -- whole number under 9 digits (?)
    self~assertTrue( "subTest39", ('1'    )~datatype('9')  )
    self~assertTrue( "subTest40", ('-1'   )~datatype('9')  )
    self~assertTrue( "subTest41", ('12345' )~datatype('9')  ) -- ?
    self~assertTrue( "subTest42", ('1E3'   )~datatype('9')  ) -- ?
    self~assertFalse( "subTest43", ('1E9'  )~datatype('9')  ) -- ?
    numeric digits a

