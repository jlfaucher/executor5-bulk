#!/usr/bin/rexx
/*
   name:             CollectionSetlikeMethods.testGroup
   author:           Rony G. Flatscher
   date:             2007-05-26
   version:          1.0.0

-- line commented lines are ignored, when building the directory of infos from this header
   changed:          ---

   languageLevel:    6.0.1
   purpose:          Test the collection setlike methods: difference, interSection,
                     subset, union, xor

   remark:           ---

   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

// category needs not to be numbered, importance is given by position (1=most important)
   category:         ooRexx
   category:         Base
   category:         Class
   category:         CollectionSetlikeMethods
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/

-------------------------------------------------------------------------------------------
-- ===> adapt the "testGroupList" to your testCase classes; each element in the list is <===
-- ===> an array object, the first element containing the testCase class object, the   <===
-- ===> second element is a list of test method names which are regarded to be         <===
-- ===> mandatory (if the list remains empty all test methods are mandatory)           <===

   /* list of array objects, each containing the testGroup class object and an
      optional list of mandatory test case methods name                       */
mandatoryTestMethods=.list~new   -- no mandatory tests for this testCase class
testGroupList=.list~of( .array~of(.CollectionSetlikeMethods.testGroup,  mandatoryTestMethods) )


-------------------------------------------------------------------------------------------
-- ===> the following code needs not to be individualized                              <===

   -- read top comment, containing infos about this program
arrLines=.array~new
do i=1 to 150 until arrLines[i]="*/"
   arrLines[i]=sourceline(i)
end
      -- supply information for the testClass(es) in this file; the class attribute
      -- "TestCaseInfo" (a directory object, index points to a queue) will store
      -- the parsed infos
atestGroupClass=testGroupList~at(testGroupList~first)[1] -- get first testClass

   -- will parse the array lines and store result in class object
call makeDirTestInfo atestGroupClass, arrLines
tmpDir=atestGroupClass~TestCaseInfo
parse source s   -- op_sys invocationType fullPathToThisFile
tmpDir~setentry("test_Case-source", s)

   -- now add this directory to other testCase classes, if any left
do arr over testGroupList
   if arr[1]=atestGroupClass then iterate  -- already handled
   arr[1]~TestCaseInfo=tmpDir             -- save info in class object
end

-- if this file is CALLed or REQUIRED then define an entry "bRunTestLocally" in .local
-- and set it to .false; this way the independent local invocation of the tests is inhibited
if .local~hasentry("bRunTestsLocally")=.false then
   .local~bRunTestsLocally=.true -- if this file is executed directly, then run tests for debugging

if .bRunTestsLocally=.true then  -- run ALL tests in this test unit
do
   ts=.testSuite~new             -- create a testSuite
   do arr over testGroupList
      -- create a testSuite for the given test case class, use all its testmethods
      ts~addTest( .testSuite~new(arr[1]))
   end
   -- testResult=.testSuite~new(testGroupClass)~run
   testResult=ts~run       -- now run all the tests

   call simpleDumpTestResults testResult
end

   /* return list of array objects containing test case classes and
      optionally list of mandatory test methods                      */
return testGroupList



::requires ooRexxUnit.cls     -- load the ooRexxUnit classes

   -- class named exactly like file
::class "CollectionSetlikeMethods.testGroup" subclass TestCase public


::method init
  expose inputBag1 inputBag2 differenceBag1 differenceBag2 intersectionBag unionBag xorBag emptyBag -
         inputSet1 inputSet2 differenceSet1 differenceSet2 intersectionSet unionSet xorSet emptySet

  forward class (super) continue

  inputBag1      =.bag~of("1", "2", "2"               )
  inputBag2      =.bag~of(     "2", "2",           "3")
  differenceBag1 =.bag~of("1"                         )
  differenceBag2 =.bag~of(                         "3")
  intersectionBag=.bag~of(     "2", "2"               )
  unionBag       =.bag~of("1", "2", "2", "2", "2", "3")
  xorBag         =.bag~of("1",                     "3")
  emptyBag       =.bag~new

  inputSet1      =.set~of("1", "2"      )
  inputSet2      =.set~of(     "2", "3" )
  differenceSet1 =.Set~of("1"           )
  differenceSet2 =.Set~of(          "3" )
  intersectionSet=.Set~of(     "2"      )
  unionSet       =.Set~of("1", "2", "3" )
  xorSet         =.Set~of("1",      "3" )
  emptySet       =.set~new

  self~assertTrue("subtest1: sameContent(inputBag1,inputBag1)", sameContent(inputBag1, inputBag1))
  self~assertTrue("subtest2: sameContent(emptyBag, emptyBag)",  sameContent(emptyBag,  emptyBag))

  self~assertTrue("subtest3: sameContent(inputSet1,inputSet1)", sameContent(inputSet1, inputSet1))
  self~assertTrue("subtest4: sameContent(emptySet2,emptySet2)", sameContent(emptySet,  emptySet))

  self~assertTrue("subtest5: sameContent(emptyBag, emptySet)",  sameContent(emptyBag,  emptySet ))

  self~assertTrue("subtest6a:  inputBag1~subSet(inputBag1)",    inputBag1~subSet(inputBag1)  )
  self~assertTrue("subtest6b:  emptyBag ~subSet(inputBag1)",    emptyBag ~subSet(inputBag1)  )
  self~assertFalse("subtest6c: inputBag1~subSet(emptyBag) ",    inputBag1~subSet(emptyBag)   )
  self~assertFalse("subtest6d: inputBag2~subSet(emptyBag) ",    inputBag2~subSet(emptyBag)   )

  self~assertFalse("subtest7a: inputBag2~subSet(inputBag1)",    inputBag2~subSet(inputBag1)  )
  self~assertFalse("subtest7b: inputBag1~subSet(inputBag2)",    inputBag1~subSet(inputBag2)  )



::method "test_difference_bag_set"

  expose inputBag1 inputBag2 differenceBag1 differenceBag2 intersectionBag unionBag xorBag emptyBag -
         inputSet1 inputSet2 differenceSet1 differenceSet2 intersectionSet unionSet xorSet emptySet

  self~assertTrue("subtest1: sameContent(emptyBag, emptyBag~difference(emptyBag))", sameContent(emptyBag, emptyBag~difference(emptyBag)))
  self~assertTrue("subtest2: sameContent(emptySet, emptySet~difference(emptySet))", sameContent(emptySet, emptySet~difference(emptySet)))

  self~assertTrue("subtest3: sameContent(inputBag1, inputBag1~difference(emptyBag))", sameContent(inputBag1, inputBag1~difference(emptyBag)))
  self~assertTrue("subtest4: sameContent(inputSet1, inputSet1~difference(emptySet))", sameContent(inputSet1, inputSet1~difference(emptySet)))

  self~assertTrue("subtest5: sameContent(differenceBag1, inputBag1~difference(inputBag2))", sameContent(differenceBag1, inputBag1~difference(inputBag2)))
  self~assertTrue("subtest6: sameContent(differenceSet1, inputSet1~difference(inputSet2))", sameContent(differenceSet1, inputSet1~difference(inputSet2)))

  self~assertTrue("subtest7: sameContent(differenceBag2, inputBag2~difference(inputBag1))", sameContent(differenceBag2, inputBag2~difference(inputBag1)))
  self~assertTrue("subtest8: sameContent(differenceSet2, inputSet2~difference(inputSet1))", sameContent(differenceSet2, inputSet2~difference(inputSet1)))


::method "test_intersection_bag_set"

  expose inputBag1 inputBag2 differenceBag1 differenceBag2 intersectionBag unionBag xorBag emptyBag -
         inputSet1 inputSet2 differenceSet1 differenceSet2 intersectionSet unionSet xorSet emptySet

  self~assertTrue("subtest1: sameContent(emptyBag, emptyBag~interSection(emptyBag))", sameContent(emptyBag, emptyBag~interSection(emptyBag)))
  self~assertTrue("subtest2: sameContent(emptySet, emptySet~interSection(emptySet))", sameContent(emptySet, emptySet~interSection(emptySet)))

  self~assertTrue("subtest3: sameContent(emptyBag, inputBag1~interSection(emptyBag))", sameContent(emptyBag, inputBag1~interSection(emptyBag)))
  self~assertTrue("subtest4: sameContent(emptySet, inputSet1~interSection(emptySet))", sameContent(emptySet, inputSet1~interSection(emptySet)))

  self~assertTrue("subtest5: sameContent(interSectionBag, inputBag1~interSection(inputBag2))", sameContent(interSectionBag, inputBag1~interSection(inputBag2)))
  self~assertTrue("subtest6: sameContent(interSectionSet, inputSet1~interSection(inputSet2))", sameContent(interSectionSet, inputSet1~interSection(inputSet2)))

  self~assertTrue("subtest7: sameContent(interSectionBag, inputBag2~interSection(inputBag1))", sameContent(interSectionBag, inputBag2~interSection(inputBag1)))
  self~assertTrue("subtest8: sameContent(interSectionSet, inputSet2~interSection(inputSet1))", sameContent(interSectionSet, inputSet2~interSection(inputSet1)))



::method "test_union_bag_set"

  expose inputBag1 inputBag2 differenceBag1 differenceBag2 intersectionBag unionBag xorBag emptyBag -
         inputSet1 inputSet2 differenceSet1 differenceSet2 intersectionSet unionSet xorSet emptySet


  self~assertTrue("subtest1: sameContent(emptyBag, emptyBag~union(emptyBag))", sameContent(emptyBag, emptyBag~union(emptyBag)))
  self~assertTrue("subtest2: sameContent(emptySet, emptySet~union(emptySet))", sameContent(emptySet, emptySet~union(emptySet)))

  self~assertTrue("subtest3: sameContent(inputBag1, inputBag1~union(emptyBag))", sameContent(inputBag1, inputBag1~union(emptyBag)))
  self~assertTrue("subtest4: sameContent(inputSet1, inputSet1~union(emptySet))", sameContent(inputSet1, inputSet1~union(emptySet)))

  self~assertTrue("subtest5: sameContent(unionBag, inputBag1~union(inputBag2))", sameContent(unionBag, inputBag1~union(inputBag2)))
  self~assertTrue("subtest6: sameContent(unionSet, inputSet1~union(inputSet2))", sameContent(unionSet, inputSet1~union(inputSet2)))

  self~assertTrue("subtest7: sameContent(unionBag, inputBag2~union(inputBag1))", sameContent(unionBag, inputBag2~union(inputBag1)))
  self~assertTrue("subtest8: sameContent(unionSet, inputSet2~union(inputSet1))", sameContent(unionSet, inputSet2~union(inputSet1)))


::method "test_xor_bag_set"

  expose inputBag1 inputBag2 differenceBag1 differenceBag2 intersectionBag unionBag xorBag emptyBag -
         inputSet1 inputSet2 differenceSet1 differenceSet2 intersectionSet unionSet xorSet emptySet


  self~assertTrue("subtest1: sameContent(emptyBag, emptyBag~xor(emptyBag))", sameContent(emptyBag, emptyBag~xor(emptyBag)))
  self~assertTrue("subtest2: sameContent(emptySet, emptySet~xor(emptySet))", sameContent(emptySet, emptySet~xor(emptySet)))

  self~assertTrue("subtest3: sameContent(inputBag1, inputBag1~xor(emptyBag))", sameContent(inputBag1, inputBag1~xor(emptyBag)))
  self~assertTrue("subtest4: sameContent(inputSet1, inputSet1~xor(emptySet))", sameContent(inputSet1, inputSet1~xor(emptySet)))

  self~assertTrue("subtest5: sameContent(xorBag, inputBag1~xor(inputBag2))", sameContent(xorBag, inputBag1~xor(inputBag2)))
  self~assertTrue("subtest6: sameContent(xorSet, inputSet1~xor(inputSet2))", sameContent(xorSet, inputSet1~xor(inputSet2)))

  self~assertTrue("subtest7: sameContent(xorBag, inputBag2~xor(inputBag1))", sameContent(xorBag, inputBag2~xor(inputBag1)))
  self~assertTrue("subtest8: sameContent(xorSet, inputSet2~xor(inputSet1))", sameContent(xorSet, inputSet2~xor(inputSet1)))


::method "test_directory"

   -- test the directory class, indicate collection has unique indixes
  self~do_the_tests(.directory, .true)


::method "test_relation"

   -- test the directory class, indicate collection has unique indixes
  self~do_the_tests(.relation, .false)


::method "test_bag"
   -- test the directory class, indicate collection has unique indixes
  self~do_the_tests(.bag, .false)


::method "test_table"
   -- test the directory class, indicate collection has unique indixes
  self~do_the_tests(.table, .true)

::method "test_set"
   -- test the directory class, indicate collection has unique indixes
  self~do_the_tests(.set, .true)




::method "do_the_tests"

  expose inputBag1 inputBag2 differenceBag1 differenceBag2 intersectionBag unionBag xorBag emptyBag -
         inputSet1 inputSet2 differenceSet1 differenceSet2 intersectionSet unionSet xorSet emptySet
  use arg clz, bUniqueIdx

  if bUniqueIdx then
  do
     coll_Input1      =inputSet1
     coll_Input2      =inputSet2
     coll_Difference1 =differenceSet1
     coll_Difference2 =differenceSet2
     coll_Intersection=intersectionSet
     coll_Union       =unionSet
     coll_Xor         =xorSet
     coll_Empty       =emptySet
  end
  else
  do
     coll_Input1      =inputBag1
     coll_Input2      =inputBag2
     coll_Difference1 =differenceBag1
     coll_Difference2 =differenceBag2
     coll_Intersection=intersectionBag
     coll_Union       =unionBag
     coll_Xor         =xorBag
     coll_Empty       =emptyBag
  end

  coll0=clz~new

  coll1=clz~new
  call putAll coll1, coll_Input1    -- create collection content

  coll2=clz~new
  call putAll coll2, coll_Input2    -- create collection content

  self~assertTrue("do_the_test: subtest01: sameContent(coll_Empty, coll0~difference(coll0) ) ", sameContent(coll_Empty, coll0~difference(coll0) ) )
  self~assertTrue("do_the_test: subtest02: sameContent(coll_Empty, coll0~interSection(coll0) ", sameContent(coll_Empty, coll0~interSection(coll0)))
  self~assertTrue("do_the_test: subtest03: coll0~subSet(coll0)                             ", coll0~subSet(coll0)                             )
  self~assertTrue("do_the_test: subtest04: sameContent(coll_Empty, coll0~union(coll0)      ) ", sameContent(coll_Empty, coll0~union(coll0)      ) )
  self~assertTrue("do_the_test: subtest05: sameContent(coll_Empty, coll0~xor(coll0)        ) ", sameContent(coll_Empty, coll0~xor(coll0)        ) )


  self~assertTrue("do_the_test: subtest06a: coll1~subset(coll1)"                                      , coll1~subset(coll1)                                     )
  self~assertTrue("do_the_test: subtest06b: coll2~subset(coll2)"                                      , coll2~subset(coll2)                                     )

  self~assertTrue("do_the_test: subtest07a: coll0~subset(coll1)"                                      , coll0~subset(coll1)                                     )
  self~assertTrue("do_the_test: subtest07b: coll0~subset(coll2)"                                      , coll0~subset(coll2)                                     )

  self~assertTrue("do_the_test: subtest08a: coll0~subset(coll1)"                                      , coll0~subset(coll1)                                     )
  self~assertTrue("do_the_test: subtest08b: coll0~subset(coll2)"                                      , coll0~subset(coll2)                                     )

  self~assertFalse("do_the_test: subtest09a: coll1~subset(coll2)"                                     ,  coll1~subset(coll2)                                    )
  self~assertFalse("do_the_test: subtest09b: coll2~subset(coll1)"                                     ,  coll2~subset(coll1)                                    )

  self~assertFalse("do_the_test: subtest09c: coll1~subset(coll0)"                                     ,  coll1~subset(coll0)                                    )
  self~assertFalse("do_the_test: subtest09d: coll2~subset(coll0)"                                     ,  coll2~subset(coll0)                                    )

  self~assertTrue("do_the_test: subtest10:  sameContent(coll_Difference1,  coll1~difference(coll2) )) " , sameContent(coll_Difference1,  coll1~difference(coll2) )  )
  self~assertTrue("do_the_test: subtest11:  sameContent(coll_Difference2,  coll2~difference(coll1) )) " , sameContent(coll_Difference2,  coll2~difference(coll1) )  )

  self~assertTrue("do_the_test: subtest12a: sameContent(coll_Intersection, coll1~interSection(coll2)) " , sameContent(coll_Intersection, coll1~interSection(coll2)) )
  self~assertTrue("do_the_test: subtest12b: sameContent(coll_Intersection, coll2~interSection(coll1)) " , sameContent(coll_Intersection, coll2~interSection(coll1)) )

  self~assertTrue("do_the_test: subtest13a: sameContent(coll_Union,        coll1~union(coll2)       ) " , sameContent(coll_Union,        coll1~union(coll2)       ) )
  self~assertTrue("do_the_test: subtest13b: sameContent(coll_Union,        coll2~union(coll1)       ) " , sameContent(coll_Union,        coll2~union(coll1)       ) )

  self~assertTrue("do_the_test: subtest14a: sameContent(coll_Xor,          coll1~xor(coll2)         ) " , sameContent(coll_Xor,          coll1~xor(coll2)         ) )
  self~assertTrue("do_the_test: subtest14b: sameContent(coll_Xor,          coll2~xor(coll1)         ) " , sameContent(coll_Xor,          coll2~xor(coll1)         ) )




/* Test whether both collections contain the same entries.
   returns .true, if the same, .false else
*/
::routine "sameContent"
  use arg coll_1, coll_2

  if coll_1~items<>coll_2~items then      -- not the same amount of objects
     return .false

   -- work on a copy
  tmp=coll_1~copy
  do o over coll_2
     if \tmp~hasindex(o) then             -- no entry anymore ?
        return .false

     tmp~remove(o)                        -- remove object
  end

  return (tmp~items=0)                    -- if the same, then no items left


::routine "putAll"                        -- put all objects of "coll" into "target" collection
  use arg target, coll

  do o over coll
     target~put(o,o)
  end
  return target


::routine "dumpColl"
  use arg coll, title
  if arg(2, "o") then title=o~class~id "object ("coll~items" entries)"

  say ">>>" title":"
  do o over coll
     .output~charout("" o~string)
  end
  say
  say "-----------------------------------<<<"
