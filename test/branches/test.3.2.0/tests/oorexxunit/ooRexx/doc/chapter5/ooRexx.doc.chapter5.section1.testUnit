#!/usr/bin/rexx
/*
   name:             ooRexx.doc.chapter5.section1.testUnit
   author:           Mark Miesfeld
   date:             2007-08-09
   version:          0.0.9
   changed:

   languageLevel:    6.0
   purpose:          Test examples in the Rexx Reference documentation from
                     chapter 5, section 1.
   remark:


   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

   category1:        ooRexx
   category2:        Documentation examples
   category3:        Rexx Reference
   category4:        Chapter 5 section 1

*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
use arg cmdLine

  -- A convenience since the test case class name is so long.
  testUnitClass = .ooRexx.doc.chapter5.section1.testUnit

  testUnitList = .list~of( .array~of( testUnitClass, .list~new ) )

  srcLines = .array~new
  do i = 1 to 150 until srcLines[ i ] = "*/"
     srcLines[ i ] = sourceline( i )
  end

  call makeDirTestInfo testUnitClass, srcLines

  parse source s
  testUnitClass~testCaseInfo~setentry( "test_Case-source", s )

  -- If there is no entry in the .local directory of 'bRunTestsLocally' then add
  -- one with a value of true.
  if \ .local~hasentry( "bRunTestsLocally" ) then
     .local~bRunTestsLocally = .true

  -- Now honor the setting of bRunTestsLocally, which may have been set by a
  -- caller of this test unit.
  if .bRunTestsLocally == .true then do
    ts = .TestSuite~new
    ts~addTest( .TestSuite~new( testUnitClass ) )

    testResult = ts~run
    call simpleDumpTestResults testResult
  end

return testUnitList
-- End of entry point.

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
  Directives, Classes, or Routines.
\* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
::requires "OOREXXUNIT.CLS"

/* class: ooRexx.doc.chapter5.section1.testUnit- - - - - - - - - - - - - - - -*\

    The Chapter 5, section 1 test unit class.  Each method starting with 'test_'
    is an individual test case for an example in this section of the
    documentation.

    Note that in the comment for the test cases here, there is a reference to
    the exact section of the doc that the example is in.  It is highly likely
    that the section numbers will change in the documentation.

\* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
::class ooRexx.doc.chapter5.section1.testUnit public subclass TestCase

  /* test_object_start( )- - - - - - - - - - - - - - - - - - - - - - - - - - -*\

    Test the example from 5.1.1.19 (currently.)  This is the example for the
    Object class, the start method of the Object class.  The following is
    the current example:

    world=.WorldObject~new
    msg1=world~start("HELLO")                /* same as next line     */
    msg2=.message~new(world,"HELLO")~~start  /* same as previous line */

    say msg1~result           /* Produces Hello world 21:04:25.065000 */
                              /* for example                          */
    say msg2~result           /* Produces Hello world 21:04:25.081000 */
                              /* for example                          */

    ::class 'WorldObject' public
    ::method hello
      return "Hello world" time('L')

  \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ::method  test_object_start

    world=.WorldObject~new
    self~assertTrue("world object must be a WorldObj object", world~class == .WorldObject)

    msg1=world~start("HELLO")
    self~assertTrue("msg1 must be a Message object", msg1~class == .Message)

    j = SysSleep(.001)

    msg2=.message~new(world,"HELLO")~~start
    self~assertTrue("msg2 must be a Message object", msg2~class == .Message)

    -- Now test that each message result is correct.  The result should begin
    -- with Hello world.
    res1 = msg1~result
    self~assertTrue("result should begin with Hello World for msg1", res1~abbrev("Hello world"))
    res2 = msg2~result
    self~assertTrue("result should begin with Hello World for msg2", res2~abbrev("Hello world"))

    -- In addition the return of the hello method has the long time appended to
    -- it.  So the message result is a string, but should not be the exact same
    -- string.
    self~assertFalse("result strings should not be exactly equal", res1 == res2)

  -- End test_object_start( )

  /* test_object_isInstanceOf( ) - - - - - - - - - - - - - - - - - - - - - - -*\

    Test the example from 5.1.1.13 (currently.)  This is the example for the
    Object class, the isInstanceOf method of the Object class.  The following is
    the current example:

    "abc"~isInstanceOf(.string) -> 1
    "abc"~isInstanceOf(.object) -> 1
    "abc"~isInstanceOf(.mutablebuffer) -> 0

  \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ::method  test_object_isInstanceOf

    obj = "abc"
    self~assertTrue("abc should be instance of .String", obj~isInstanceOf(.String))
    self~assertTrue("abc should be instance of .Object", obj~isInstanceOf(.Object))
    self~assertFalse("abc should not be instance of .MutableBuffer", obj~isInstanceOf(.MutableBuffer))

    -- Note that section 5.1.1.12 is for the isA method which is declared to be
    -- an alias for isInstanceOf.
    self~assertTrue("abc should be instance of .String", obj~isA(.String))
    self~assertTrue("abc should be instance of .Object", obj~isA(.Object))
    self~assertFalse("abc should not be instance of .MutableBuffer", obj~isA(.MutableBuffer))

  -- End test_object_isInstanceOf( )

  /* test_object_ObjectNameEquals( ) - - - - - - - - - - - - - - - - - - - - - - -*\

    Test the example from 5.1.1.15 (currently.)  This is the example for the
    Object class, the objectName= method of the Object class.  The following is
    the current example:

    points=.array~of("N","S","E","W")
    say points~objectName            /* (no change yet) Says: "an Array" */
    points~objectName=("compass")    /* Changes obj name POINTS to "compass"*/
    say points~objectName            /* Shows new obj name. Says: "compass" */
    say points~defaultName           /* Default is still available. */
                                     /* Says "an Array" */
    say points                       /* Says string representation of */
                                     /* points "compass" */
    say points[3]                    /* Says: "E" Points is still an array */
                                     /* of 4 items */

  \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ::method  test_object_ObjectNameEquals

    points=.array~of("N","S","E","W")
    self~assertTrue("points must be an array", points~class == .Array)

    -- Need to change the example slightly to test
    self~assertSame("objectName should still be an Array", points~objectName, "an Array")

    points~objectName=("compass")
    self~assertSame("objectName should now be compass", points~objectName, "compass")
    self~assertSame("default name should still be an Array", points~defaultName, "an Array")

    -- say points
    --
    -- A hard thing to translate into a test case.  points is an object,
    -- compass is an object.  The following commented out assertion fails
    -- because the two objects are *not* the same.
    /*
    self~assertSame("string representation should be compass", points, "compass")
    */

    -- So, a little creativity.  We need a way to capture a say statement, but
    -- still keep the test automated.  So, temporarily change the destination of
    -- a "say" to a file.  Then read back the file.
    fName = "ttXXTemp.out"
    outObj = .stream~new(fName)~~command("OPEN WRITE REPLACE")
    .output~destination(outObj)

    say points

    -- Reset the destination for output
    .output~destination(.Stdout)

    -- Close the file, reopen, read the output, delete the file, do the test
    outObj~close
    inObj = .stream~new(fName)~~command("OPEN READ")
    pointsStr = inObj~linein
    inObj~close
    j = SysFileDelete(fName)

    self~assertSame("string representation should be compass", pointsStr, "compass")
    self~assertSame("points is still an array, should be 'E'", points[3], "E")

  -- End test_object_ObjectNameEquals( )

-- End of class: ooRexx.doc.chapter5.section1.testUnit


-- Helper class for the test_object_start test case.
::class 'WorldObject' public
::method hello
  return "Hello world" time('L')

