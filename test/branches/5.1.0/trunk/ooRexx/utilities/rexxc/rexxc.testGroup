#!/usr/bin/env rexx
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2018-2025 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* https://www.oorexx.org/license.html                                        */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . s
  group = .TestGroup~new(s)
  group~add(.rexxc.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult


::requires 'ooTest.frm' -- load the ooRexxUnit classes

::class "rexxc.testGroup" subclass ooTestCase public

::constant testSource "test_rexxc.rex"
::constant testSourceNotExist "test_rexxc_notexist.rex"
::constant testCompiled "test_rexxc.rexc"


-- if a file path contains blanks, it needs to be quoted
::method q
  use strict arg path
  if path~contains(" ") then
    return '"' || path || '"'
  else
    return path

::method test_rexxc_no_arg
  address "" "rexxc" with output stem s.
  self~assertRc(-1, rc)
  self~assertTrue(s.0 > 0, "'rexxc' is expected to produce a few lines of output")

::method test_rexxc_one_arg_not_found
  address "" "rexxc" self~testSourceNotExist with output stem s. error stem e.
  -- Error 3.901:  Failure during initialization: Program .. was not found
  self~assertRc(-3, rc)
  -- (only) on SunOS/Solaris no redirected output is captured - reason unknown
  -- rexx -e "address '' 'rexxc nonexisting' with output stem o. error stem e.; say o.0 e.0"
  self~assertTrue(s.0 > 0, "tracker bug #n/a: on SunOS/Solaris no output is captured")
  self~assertTrue(e.0 > 0, "'rexxc" self~testSourceNotExist"' is expected to produce some lines of syntax error output")

::method test_rexxc_three_args
  address "" "rexxc" self~testSourceNotExist self~testSourceNotExist with output stem s.
  self~assertRc(-2, rc) -- Output file name must be different from input file name
  self~assertTrue(s.0 > 0, "'rexxc' with three args is expected to produce a few lines of output")

::method test_rexxc_one_arg_syntax
  source = .TemporaryTestFile~new(self, self~testSource)
  source~create("/**/@")
  address "" "rexxc" self~q(source~fullName) with output stem s. error stem e.
  -- Error 13.1:  Incorrect character in program "@" ('40'X)
  self~assertRc(-13, rc)
  self~assertTrue(s.0 > 0, "tracker bug #n/a: on SunOS/Solaris no output is captured")
  self~assertTrue(e.0 > 0, "'/**/@' is expected to produce some lines of syntax error output")

::method test_rexxc_one_arg
  source = .TemporaryTestFile~new(self, self~testSource)
  do resource over .resources
    source~createFromResource(resource)
    address "" "rexxc" self~q(source~fullName) with output stem s. error stem e.
    self~assertRc(0, rc, "'"resource"' Rexx code expected to compile with rc 0")
    self~assertTrue(s.0 > 0, "tracker bug #n/a: on SunOS/Solaris no output is captured")
    self~assertTrue(e.0 = 0, "rexxc" self~testSource "is expected to produce no error output")
  end

::method test_rexxc_one_arg_option_s
  source = .TemporaryTestFile~new(self, self~testSource)
  do resource over .resources
    source~createFromResource(resource)
    address "" "rexxc" self~q(source~fullName) "-s" with output stem s. error stem e.
    self~assertRc(0, rc, "'"resource"' Rexx code expected to compile with rc 0")
    self~assertTrue(s.0 = 0, "'rexxc" self~testSource "-s' is expected to produce no output")
    self~assertTrue(e.0 = 0, "'rexxc" self~testSource "-s' is expected to produce no error output")
  end

::method test_rexxc_two_args
  source = .TemporaryTestFile~new(self, self~testSource)
  o = .Array~new
  e = .Array~new
  compiled = .File~new(self~testCompiled)
  -- the header is always line-feed terminated, both on Windows and Unix-like systems
  expectedHeader = "#!/usr/bin/env rexx" ||'0a'x || "/**/@REXX"
  do resource over .resources
    source~createFromResource(resource)
    address "" "rexxc" self~q(source~fullName) self~q(compiled~absolutePath) with output using (o) error using (e)
    self~assertRc(0, rc, "'"resource"' Rexx code expected to compile with rc 0")
    self~assertTrue(o~items > 0, "tracker bug #n/a: on SunOS/Solaris no output is captured")
    self~assertSame("", e~toString, "unexpected error output from rexxc '"resource"'")

    -- compiled code should have been generated; check shebang and header
    self~assertTrue(compiled~exists, "rexxc compiled output '" || self~testCompiled || "' should exist")
    self~assertTrue(compiled~canRead, "rexxc compiled output '" || self~testCompiled || "' should be readable")
    c = .Stream~new(compiled)
    c~open("read shared")
    actualHeader = c~charIn(, expectedHeader~length)
    c~close
    self~assertSame(expectedHeader, actualHeader, "unexpected rexxc compiled output header")

    -- the code compiled by rexxc should run successfully
    address "" "rexx" self~q(compiled~absolutePath) with output using (o) error using (e)
    self~assertRc(resource~subWord(2), rc, "unexpected rc from compiled '"resource"'")
    self~assertSame("", o~toString, "unexpected output from compiled '"resource"'")
    self~assertSame("", e~toString, "unexpected error output from compiled '"resource"'")

    -- remove compiled Rexx code
    compiled~delete
  end


::method test_rexxc_encoding

  pkgDir   =filespec('Location', .context~package~name)  -- this package's location
  fnSource ="source_program.rex"                   -- source file name
  fnComp   =self~testsource"_compiled"             -- compiled file name
  fnCompEnc=self~testsource"_compiled_and_encoded" -- compiled and encoded file name

  call clean   -- make sure we clean before work

   -- create test file
  .stream~new(pkgDir || fnSource) ~~open("replace") ~~lineout("return 42") ~~close

   -- compile
  address "" "rexxc" self~q(pkgDir || fnSource) self~q(pkgDir || fnComp) "-s" with output stem s. error stem e.
  self~assertRc(0, rc, "'"fnSource"' Rexx code expected to compile with rc 0")
  self~assertTrue(s.0 = 0, "'rexxc" fnSource "-s' is expected to produce no output")
  self~assertTrue(e.0 = 0, "'rexxc" fnSource "-s' is expected to produce no error output")

  r=.routine~newFile(pkgDir || fnComp)  -- create from file
  res=r~call
  self~assertTrue(res = 42, "calling compiled program" self~q(fnComp) "returns '"res"' instead of '42'")

   -- compile and encode
  address "" "rexxc" self~q(pkgDir || fnSource) self~q(pkgDir || fnCompEnc) "-e -s" with output stem s. error stem e.
  self~assertRc(0, rc, "'"fnSource"' Rexx code expected to compile with rc 0")
  self~assertTrue(s.0 = 0, "'rexxc" fnSource "-e -s' is expected to produce no output")
  self~assertTrue(e.0 = 0, "'rexxc" fnSource "-e -s' is expected to produce no error output")

  r=.routine~newFile(pkgDir || fnCompEnc)
  res=r~call
  self~assertTrue(res = 42, "calling compiled program" self~q(fnCompEnc) "returns '"res"' instead of '42'")

  s=.stream~new(pkgDir || fnCompEnc)~~open("read") -- read compiled and encoded data
  data=s~arrayin     -- read all program data
  s~close
  r=.routine~new(fnCompEnc,data) -- create from file's data
  res=r~call
  self~assertTrue(res = 42, "calling compiled program" self~q(fnCompEnc) "returns '"res"' instead of '42'")

   -- assert difference in sizes
  f=.file~new(pkgDir || fnSource)
  len_fnSource =f~length
  f=.file~new(pkgDir || fnComp)
  len_fnComp   =f~length
  f=.file~new(pkgDir || fnCompEnc)
  len_fnCompEnd=f~length

  self~assertTrue(len_fnSource<>0, "source file '"fnSource"' is empty")
  self~assertTrue(len_fnSource<len_fnComp   , "compiled file '"fnComp"' is not larger than '"fnSource"'")
  self~assertTrue(len_fnSource<len_fnCompEnd, "compiled and encoded file '"fnCompEnc"' is not larger than '"fnSource"'")
  self~assertTrue(len_fnComp  <len_fnCompEnd, "compiled and encoded file '"fnCompEnc"' is not larger than '"fnSource"'")

   -- clean up
  call clean
  return

clean:   -- make sure that files do not exist
  do fn over fnSource, fnComp, fnCompEnc
     fn=pkgDir || fn
     if sysFileExists(fn) then
     do
        rc=sysFileDelete(fn)
        self~assertTrue(rc=0, self~q(fn) "exists, but cannot be deleted")
     end
  end
  return


-- second word of the resource name is the expected return code
::resource "empty 0"
::END

-- second word of the resource name is the expected return code
::resource "return 99"
return 99
::END


::options all syntax error condition
