#!/usr/bin/env rexx
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007-2022 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* https://www.oorexx.org/license.html                                        */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . s
  group = .TestGroup~new(s)
  group~add(.Collection_arrayMethod.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult

::requires 'ooTest.frm' -- load the ooRexxUnit classes

::class "Collection_arrayMethod.testGroup" subclass ooTestCase public

::method "test_2"
   arr = .array~of()
   self~assertEquals(0, arr~items)
   arr1 = .array~of(1)
   self~assertEquals(1, arr1~items)
   arr2 = .array~of(1,1)
   self~assertEquals(2, arr2~items)
   arr3 = .array~of(1,1,1)
   self~assertEquals(3, arr3~items)
   arr4 = .array~of(1,1,1,1,1,1,1,1,1,1,,
                    2,2,2,2,2,2,2,2,2,2,,
                    3,3,3,3,3,3,3,3,3,3,,
                    4,4,4,4,4,4,4,4,4,4,,
                    5,5,5,5,5,5,5,5,5,5,,
                    6,6,6,6,6,6,6,6,6,6,,
                    7,7,7,7,7,7,7,7,7,7,,
                    8,8,8,8,8,8,8,8,8,8,,
                    9,9,9,9,9,9,9,9,9,9,,
                    0,0,0,0,0,0,0,0,0,0)
   self~assertEquals(100, arr4~items)

::method "test_3"
   arr1 = .array~of(1,2,3)
   self~assertEquals(1, arr1[1])
   self~assertEquals(2, arr1[2])
   self~assertEquals(3, arr1[3])

::method "test_4"
   arr1 = .array~new(4)
   do i = 1 to 4
      arr1[i] = i
   end
   self~assertEquals(1, arr1[1])
   self~assertEquals(2, arr1[2])
   self~assertEquals(3, arr1[3])
   self~assertEquals(4, arr1[4])

::method "test_5"
   arr1 = .array~new(2,2)
   do i = 1 to 2
      do j = 1 to 2
         arr1[i,j] = j
      end
   end
   self~assertEquals(1, arr1[1,1])
   self~assertEquals(2, arr1[1,2])
   self~assertEquals(1, arr1[2,1])
   self~assertEquals(2, arr1[2,2])

::method "test_6"
   arr1 = .array~new()
   do i = 1 to 10 by 2
      arr1[i] = i
   end
   idxs = arr1~allIndexes
   self~assertEquals(5, idxs~items)
   j = 1
   do i = 1 to 5
      self~assertEquals(j, idxs[i])
      j += 2
   end

::method "test_6a"
   arr1 = .array~new()
   do i = 1 to 10 by 2
      arr1[i] = i
   end
   j = 1
   do i = 2 to 10 by 2
      self~assertSame(.nil, arr1[i])
      arr1[i] = i
   end

::method "test_7"
   arr1 = .array~new()
   do i = 1 to 10 by 2
      arr1[i] = i
   end
   items = arr1~allItems
   self~assertEquals(5, items~items)
   j = 1
   do i = 1 to 5
      self~assertEquals(j, items[i])
      j += 2
   end

::method "test_8"
   arr1 = .array~of(1,2,3)
   arr1~append(4)
   self~assertEquals(4, arr1~items)
   arr1~append(5)
   self~assertEquals(5, arr1~items)

::method "test_9"
   arr1 = .array~of(1,2,3)
   self~assertEquals(1, arr1~at(1))
   self~assertEquals(2, arr1~at(2))
   self~assertEquals(3, arr1~at(3))
   self~assertSame(.nil, arr1~at(4))

::method "test_10"
   arr1 = .array~new()
   self~assertEquals(0, arr1~dimension)
   arr1 = .array~new(1)
   self~assertEquals(1, arr1~dimension)
   arr1 = .array~new(1,1)
   self~assertEquals(2, arr1~dimension)
   arr1 = .array~new(1,1,1,1,1,1,1,1,1,1)
   self~assertEquals(10, arr1~dimension)

::method "test_dimensions"
   arr1 = .array~new()
   self~assertTrue(arr1~dimensions~equivalent(.array~of(0)))
   arr1 = .array~new(1)
   self~assertTrue(arr1~dimensions~equivalent(.array~of(1)))
   arr1 = .array~new(1,1)
   self~assertTrue(arr1~dimensions~equivalent(.array~of(1,1)))
   arr1 = .array~new(1,1,1,1,1,1,1,1,1,1)
   self~assertTrue(arr1~dimensions~equivalent(.array~of(1,1,1,1,1,1,1,1,1,1)))

::method "test_11"
   arr1 = .array~of(1,2,3)
   self~assertEquals(3, arr1~items)
   arr1~empty
   self~assertEquals(0, arr1~items)

::method "test_12"
   arr1 = .array~of("Mike", "Rick", "Fred", "Rick")
   self~assertEquals(1, arr1~first)
   arr2 = .array~of(,"Mike", "Rick")
   self~assertEquals(2, arr2~first)

::method "test_13"
   arr1 = .array~new()
   do i = 1 to 10 by 2
      arr1[i] = i
   end
   self~assertEquals(1, arr1~hasindex(1))
   self~assertEquals(0, arr1~hasindex(2))

::method "test_14"
   arr1 = .array~of("Mike", "Rick", "Fred", "Rick")
   self~assertEquals(1, arr1~hasItem('Mike'))
   self~assertEquals(1, arr1~hasItem('Rick'))
   self~assertEquals(0, arr1~hasItem('Sam'))
   self~assertEquals(0, arr1~hasItem('Ricky'))

::method "test_15"
   arr1 = .array~of("Mike", "Rick", "Fred", "Rick")
   self~assertEquals(1, arr1~index('Mike'))
   self~assertEquals(2, arr1~index('Rick'))
   self~assertSame(.nil, arr1~index('Sam'))
   self~assertSame(.nil, arr1~index('Ricky'))

::method "test_16"
   arr1 = .array~new()
   self~assertEquals(1, arr1~isEmpty)
   do i = 1 to 10 by 2
      arr1[i] = i
   end
   self~assertEquals(0, arr1~isEmpty)

::method "test_17"
   arr1 = .array~new()
   self~assertEquals(0, arr1~items)
   arr1 = .array~of(, "Rick", "Fred", "Rick")
   self~assertEquals(3, arr1~items)

::method "test_18"
   arr1 = .array~of("Mike", "Rick", "Fred", "Rick")
   self~assertEquals(4, arr1~last)
   arr0 = .array~new()
   self~assertSame(.nil, arr0~last)

::method "test_19"
   arr1 = .array~of("Mike", "Rick", "Fred", "Rick")
   arr2 = arr1~makeArray
   self~assertEquals(arr1~items, arr2~items)
   do i = 1 to arr1~items
      self~assertEquals(arr1[i], arr2[i])
   end

::method "test_20"
   arr1 = .array~of("Mike", "Rick", "Fred", "Rick")
   c1 = arr1[1] || arr1[2] || arr1[3] || arr1[4]
   c2 = arr1[1] || ',' || arr1[2] || ',' || arr1[3] || ',' || arr1[4]
   c3 = arr1[1] || .endofline || arr1[2] || .endofline || arr1[3] || .endofline || arr1[4]
   tc1 = arr1~makeString()
   self~assertEquals(c3, arr1~makeString)
   self~assertEquals(c2, arr1~makeString(, ','))
   self~assertEquals(c1, arr1~makeString('C'))
   self~assertEquals(c3, arr1~makeString('L'))
   self~assertEquals(c2, arr1~makeString('L', ','))

::method "test_21"
   arr1 = .array~of(, "Rick", , "Rick")
   self~assertEquals(2, arr1~next(1))
   self~assertEquals(4, arr1~next(2))
   self~assertEquals(4, arr1~next(3))
   self~assertSame(.nil, arr1~next(4))

::method "test_21a"
   arr1 = .array~new(4,4)
   self~assertSame(.nil, arr1~next(1,1))

::method "test_22"
   arr1 = .array~of(, "Rick", , "Rick")
   self~assertEquals(4, arr1~previous(6))
   self~assertEquals(4, arr1~previous(5))
   self~assertEquals(2, arr1~previous(4))
   self~assertEquals(2, arr1~previous(3))
   self~assertSame(.nil, arr1~previous(2))
   self~assertSame(.nil, arr1~previous(1))

::method "test_22a"
   arr1 = .array~new(4,4)
   self~assertSame(.nil, arr1~previous(1,1))

::method "test_23"
   arr1 = .array~of(1,2,3)
   arr1~put(4,4)
   self~assertEquals(4, arr1~items)
   self~assertEquals(4, arr1[4])
   arr1~put(6,1)
   self~assertEquals(6, arr1[1])

::method "test_24"
   arr1 = .array~of("David", "Rick", "Sam", "Rick")
   arr1~remove(1)
   self~assertEquals(3, arr1~items)
   arr1~remove(4)
   self~assertEquals(2, arr1~items)
   arr1~remove(3)
   self~assertEquals(1, arr1~items)
   arr1~remove(3)
   self~assertEquals(1, arr1~items)

::method "test_25"
   arr1 = .array~of("David", "Rick", "Sam", "Rick")
   arr1~removeItem("Rick")
   self~assertEquals(3, arr1~items)
   self~assertSame(.nil, arr1[2])
   arr1~removeItem("David")
   self~assertEquals(2, arr1~items)
   self~assertSame(.nil, arr1[1])
   arr1~removeItem("Rick")
   self~assertEquals(1, arr1~items)
   self~assertSame(.nil, arr1[4])
   arr1~removeItem("Sam")
   self~assertEquals(0, arr1~items)
   self~assertSame(.nil, arr1[3])

::method "test_26"
   arr = .array~of(1,2,3,4)
   b = arr~section(2)
   self~assertEquals(.array~of(2,3,4), b)
   c = arr~section(2,2)
   self~assertEquals(.array~of(2,3), c)
   d = arr~section(2,0)
   self~assertEquals(.array~new(), d)

::method "test_27"
   arr = .array~new()
   self~assertEquals(0, arr~size)
   arr = .array~new(1)
   self~assertEquals(1, arr~size)
   arr = .array~new(1,2)
   self~assertEquals(1*2, arr~size)
   arr = .array~new(1,2,3)
   self~assertEquals(1*2*3, arr~size)
   arr = .array~new(1,2,3,4)
   self~assertEquals(1*2*3*4, arr~size)

::method "test_28"
   arr1 = .array~of("David", "Rick", "Sam", "Rick")
   arr2 = .array~of("David", "Rick", "Rick", "Sam")
   sorted = arr1~sort
   self~assertEquals(arr2, arr1)

::method "test_29"
   -- sortWith

::method "test_30"
   arr1 = .array~of("David", "Rick", "Sam", "Rick")
   arr2 = .array~of("David", "Rick", "Rick", "Sam")
   sorted = arr1~stableSort
   self~assertEquals(arr2, arr1)

::method "test_31"
   -- stableSortWith

::method "test_32"
   arr = .array~of("David", "Rick")
   sup = arr~supplier
   self~assertEquals('a Supplier', sup)
   self~assertEquals(1, sup~available)
   self~assertEquals(1, sup~index)
   self~assertEquals('David', sup~item)
   sup~next
   self~assertEquals(1, sup~available)
   self~assertEquals(2, sup~index)
   self~assertEquals('Rick', sup~item)
   sup~next
   self~assertEquals(0, sup~available)
   self~expectSyntax(93.937)
   sup~next

::method "test_33"
   arr1 = .array~of("Mike", "Rick", "Fred", "Rick")
   c1 = arr1[1] || arr1[2] || arr1[3] || arr1[4]
   c2 = arr1[1] || ',' || arr1[2] || ',' || arr1[3] || ',' || arr1[4]
   c3 = arr1[1] || .endofline || arr1[2] || .endofline || arr1[3] || .endofline || arr1[4]
   tc1 = arr1~makeString()
   self~assertEquals(c3, arr1~toString)
   self~assertEquals(c2, arr1~toString(, ','))
   self~assertEquals(c1, arr1~toString('C'))
   self~assertEquals(c3, arr1~toString('L'))
   self~assertEquals(c2, arr1~toString('L', ','))

::method "test_34"
   arr1 = .array~of("Mike", "Rick", "Fred", "Rick")
   self~expectSyntax(93.907)
   t1 = arr1[0]

::method "test_35"
   arr1 = .array~of("Mike", "Rick", "Fred", "Rick")
   self~expectSyntax(93.907)
   t1 = arr1[-1]

::method "test_36"
   arr1 = .array~of("Mike", "Rick", "Fred", "Rick")
   self~expectSyntax(93.907)
   t1 = arr1['Mike']

::method "test_37"
   arr1 = .array~of("Mike", "Rick", "Fred", "Rick")
   self~expectSyntax(93.907)
   t1 = arr1[.nil]


::options novalue error
