/*
   name:             ooRexx.Base.String.testUnit
   author:           Rony G. Flatscher
   date:             2005-10-22
   version:          0.9.1

-- line commented lines are ignored, when building the directory of infos from this header
   changed:          ---


   languageLevel:    6.0
   purpose:          Test the setting of the Rexx variable named "RESULT", "RC" and "SIGL"
   remark:           ---


   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

   category1:        ooRexx
   category2:        Base

*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2005 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/



-------------------------------------------------------------------------------------------
-- ===> adapt the "testUnitList" to your testCase classes; each element in the list is <===
-- ===> an array object, the first element containing the testCase class object, the   <===
-- ===> second element is a list of test method names which are regarded to be         <===
-- ===> mandatory (if the list remains empty all test methods are mandatory)           <===

   /* list of array objects, each containing the testUnit class object and an
      optional list of mandatory test case methods name                       */

mandatoryTestMethods=.list~new   -- no mandatory tests for this testCase class
testUnitList=.list~of( .array~of(.ooRexx.Base.RESULT_RC_SIGL.testUnit,  mandatoryTestMethods) )


-------------------------------------------------------------------------------------------
-- ===> the following code needs not to be individualized                              <===

   -- read top comment, containing infos about this program
arrLines=.array~new
do i=1 to 150 until arrLines[i]="*/"
   arrLines[i]=sourceline(i)
end
      -- supply information for the testClass(es) in this file; the class attribute
      -- "TestCaseInfo" (a directory object, index points to a queue) will store
      -- the parsed infos
aTestUnitClass=testUnitList~at(testUnitList~first)[1] -- get first testClass

   -- will parse the array lines and store result in class object
call makeDirTestInfo aTestUnitClass, arrLines
tmpDir=aTestUnitClass~TestCaseInfo
parse source s   -- op_sys invocationType fullPathToThisFile
tmpDir~setentry("test_Case-source", s)

   -- now add this directory to other testCase classes, if any left
do arr over testUnitList
   if arr[1]=aTestUnitClass then iterate  -- already handled
   arr[1]~TestCaseInfo=tmpDir             -- save info in class object
end

-- if this file is CALLed or REQUIRED then define an entry "bRunTestLocally" in .local
-- and set it to .false; this way the independent local invocation of the tests is inhibited
if .local~hasentry("bRunTestsLocally")=.false then
   .local~bRunTestsLocally=.true -- if this file is executed directly, then run tests for debugging

if .bRunTestsLocally=.true then  -- run ALL tests in this test unit
do
   ts=.testSuite~new             -- create a testSuite
   do arr over testUnitList
      -- create a testSuite for the given test case class, use all its testmethods
      ts~addTest( .testSuite~new(arr[1]))
   end
   -- testResult=.testSuite~new(testUnitClass)~run
   testResult=ts~run       -- now run all the tests

   call simpleDumpTestResults testResult
end

   /* return list of array objects containing test case classes and
      optionally list of mandatory test methods                      */
return testUnitList



::requires ooRexxUnit.cls     -- load the ooRexxUnit classes

::class "ooRexx.Base.RESULT_RC_SIGL.testUnit" subclass TestCase public

::method init
  expose fileName
  fileName="ooRexx.Base.RESULT.rex"         -- define temporary file name
  forward class (super)       -- a MUST: let superclass initialize, otherwise you'll get into troubles...

::method setUp             -- create external Rexx program for testing
  expose fileName
-- say "setUp..."

  s=.stream~new(fileName)~~open("replace")   -- create empty file
  s~~lineout("/*" date("S") time() ", ---rgf */")~~lineout
  s~~lineout("exit 1234") ~~lineout          -- return value "1234"

  s~~lineout("::routine testExternalWithReturn public")
  s~~lineout("  return 'ReturnValue'") ~~lineout

  s~~lineout("::routine testExternalWithExit public")
  s~~lineout("  return 'ExitValue'") ~~lineout
  s~close




::method tearDown
  expose fileName
-- say "tearDown..."
  call sysFileDelete fileName -- delete file



::method "test_Result_with_Return"

      -- "rgfTestMethodWithReturn"
   drop result             -- make sure, variable is dropped
   self~assertSame("subTest1",   self~rgfTestMethodWithReturn  , "ReturnValue"        )
   self~assertFalse("subTest2",  var("RESULT") ) -- must not be set !

      -- via a message object
   .message~new(self, "rgfTestMethodWithReturn")~send
   self~assertSame("subTest3" ,  result                        , "ReturnValue"        )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest4",  var("RESULT") ) -- must not be set !

   .message~new(self, "rgfTestMethodWithReturn")~send
   self~assertTrue("subTest5",   var("RESULT") )  -- must be set !


      -- routine
   self~assertSame("subTest6",   rgfTestRoutineWithReturn()    , "ReturnValue"       )
   self~assertFalse("subTest7",  var("RESULT") ) -- must not be set !

   call rgfTestRoutineWithReturn
   self~assertSame("subTest8",   result                        , "ReturnValue"       )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest9",  var("RESULT") )  -- must not be set !

   call rgfTestRoutineWithReturn
   self~assertTrue("subTest10",  var("RESULT") )   -- must be set !


      -- function
   self~assertSame("subTest11",  rgfTestProcedureWithReturn()  , "ReturnValue"       )
   self~assertFalse("subTest12", var("RESULT") ) -- must not be set !

   call rgfTestProcedureWithReturn
   self~assertSame("subTest13",  result                        , "ReturnValue"       )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest14", var("RESULT") )  -- must not be set !

   call rgfTestProcedureWithReturn
   self~assertTrue("subTest15",  var("RESULT") )   -- must be set !

   exit

   rgfTestProcedureWithReturn:
      return "ReturnValue"


::method "test_Result_with_Exit"

      -- "rgfTestMethodWithExit"
   drop result             -- make sure, variable is dropped
   self~assertSame("subTest1",   self~rgfTestMethodWithExit  , "ExitValue"        )
   self~assertFalse("subTest2",  var("RESULT") ) -- must not be set !

      -- via a message object
   .message~new(self, "rgfTestMethodWithExit")~send
   self~assertSame("subTest3" ,  result                      , "ExitValue"        )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest4",  var("RESULT") ) -- must not be set !

   .message~new(self, "rgfTestMethodWithExit")~send
   self~assertTrue("subTest5",   var("RESULT") )  -- must be set !


      -- routine
   self~assertSame("subTest6",   rgfTestRoutineWithExit()    , "ExitValue"       )
   self~assertFalse("subTest7",  var("RESULT") ) -- must not be set !

   call rgfTestRoutineWithExit
   self~assertSame("subTest8",   result                      , "ExitValue"       )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest9",  var("RESULT") )  -- must not be set !

   call rgfTestRoutineWithExit
   self~assertTrue("subTest10",  var("RESULT") )   -- must be set !


::method "test_Result_with_Reply"

      -- "rgfTestMethodWithReply"
   drop result             -- make sure, variable is dropped
   self~assertSame("subTest1",   self~rgfTestMethodWithReply  , "ReplyValue"        )
   self~assertFalse("subTest2",  var("RESULT") ) -- must not be set !

      -- via a message object
   .message~new(self, "rgfTestMethodWithReply")~send
   self~assertSame("subTest3" ,  result                      , "ReplyValue"        )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest4",  var("RESULT") ) -- must not be set !

   .message~new(self, "rgfTestMethodWithReply")~send
   self~assertTrue("subTest5",   var("RESULT") )  -- must be set !


::method  rgfTestMethodWithReturn
   return "ReturnValue"


::method  rgfTestMethodWithExit
   exit   "ExitValue"


::method  rgfTestMethodWithReply
   reply  "ReplyValue"
   a=1


   -- call as a Rexx function, hence "result" will be set
::method "test_Result_with_Return_ExternalFile"
   expose fileName
   call (fileName)      -- call external program

   if var("RESULT") then tmpResult=result -- save value of "result"
   if var("RC")     then tmpRC    =rc     -- save value of "rc"

   self~assertTrue("subTest1", var("TMPRESULT"))
   self~assertFalse("subTest1b", var("TMPRC"))
   self~assertSame("subTest2", tmpResult, "1234")  -- value of EXIT in external file

      -- routine
   self~assertSame("subTest5",   testExternalWithReturn()    , "ReturnValue"       )
   self~assertFalse("subTest6",  var("RESULT") ) -- must not be set !

   call testExternalWithReturn
   self~assertSame("subTest7",   result                        , "ReturnValue"       )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest8",  var("RESULT") )  -- must not be set !

   call testExternalWithReturn
   self~assertTrue("subTest9" ,  var("RESULT") )   -- must be set !


   -- call as a Rexx function, hence "result" will be set
::method "test_Result_with_Exit_ExternalFile"
   expose fileName
   call (fileName)      -- call external program

   if var("RESULT") then tmpResult=result -- save value of "result"
   if var("RC")     then tmpRC    =rc     -- save value of "rc"

   self~assertTrue("subTest1", var("TMPRESULT"))
   self~assertFalse("subTest1b", var("TMPRC"))
   self~assertSame("subTest2", tmpResult, "1234")  -- value of EXIT in external file

      -- routine
   self~assertSame("subTest3",   testExternalWithExit()    , "ExitValue"       )
   self~assertFalse("subTest4",  var("RESULT") ) -- must not be set !

   call testExternalWithExit
   self~assertSame("subTest5",   result                      , "ExitValue"       )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest6",  var("RESULT") )  -- must not be set !

   call testExternalWithExit
   self~assertTrue("subTest7",  var("RESULT") )   -- must be set !


   -- now address external Rexx program as a command, hence retrieving a "RC"-value
   -- instead of a "RESULT"
::method "test_Result_with_Exit_ADDRESSING_ExternalFile"
   expose fileName

   ADDRESS CMD "rexx" fileName

   if var("RESULT") then tmpResult=result -- save value of "result"
   if var("RC")     then tmpRC    =RC     -- save value of "result"

-- say "tmpresult="pp(tmpresult) var("tmpresult")
-- say "tmprc    ="pp(tmprc)     var("tmprc")

   self~assertTrue("subTest2", var("TMPRC"))
   self~assertSame("subTest3", tmpRC, "1234")  -- value of EXIT in external file
--say pp(var("TMPRESULT"))
   self~assertFalse("subTest1", var("TMPRESULT"))


   -- check whether SIGL points to the correct lines
::method "test_SIGL"

      signal label_1

   label_1 :
      -- say "l1:" sigl pp(sourceline(sigl))
      self~assertEquals("subtest1", sourceline(sigl), "signal label_1")
      signal label_3

   label_2 :
      -- say "l2:" sigl pp(sourceline(sigl))
      self~assertEquals("subtest2", sourceline(sigl), "signal label_2")
      exit

   label_3 :
      -- say "l3:" sigl pp(sourceline(sigl))
      self~assertEquals("subtest3", sourceline(sigl), "signal label_3")
      signal label_2




----------------------- routines ----------------------

::routine rgfTestRoutineWithReturn
   return "ReturnValue"

::routine rgfTestRoutineWithExit
   exit   "ExitValue"




