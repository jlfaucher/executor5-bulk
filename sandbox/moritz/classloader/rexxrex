#!/usr/bin/rexx
/*
Written by Moritz Hoffmann. Contributed to the ooRexx project.
This is a wrapper application to boot rexx application that require the
class loader to be present. It intercepts require statements and parses
them. In case the require statement is intended to be used by the package
loader it will be handled correctly. Otherwise it will not touch the statement.
*/

if arg() = 0 then do
  Say "ooRexx executor with dynamic class loading support"
  Say "usage: rexxrex program [arguments]"
  Say "program will be started with the trailing parameters"
  exit 255
end

parse value arg(1) with program args
--say "Running:" program
if stream(program,"C","QUERY EXISTS") = "" then do
  raise syntax 3.901 array (program)
end

.Go~getInstance~SecurityManager = .PackageResolver~new
method = .method~newFile(program)
.Go~getInstance~run(method,"Array",arg(1,'A')~~put(args,1))
exit 0

::REQUIRES "Classloader.cls"
/*
A wrapper that exposes the run method to the public. It also stores some
objects to avoid recreating them at each invocation.
*/
::CLASS Go
::ATTRIBUTE SecurityManager
::METHOD getInstance CLASS
  expose instance
  if var("instance") then return instance
  else do
    instance = self~new
    return instance
  end
::METHOD run
  use strict arg method ...
  method~setSecurityManager(self~SecurityManager)
  self~run:super(method,"Array",arg(2,"A"))

/*
A security manager that intercepts the call to requires.
It will parse the statement if it has the following layout:
[:alnum:]+([~][:alnum:]+)*
    ([(]
	([:alnum:]+([ ]+as[ ]+[:alnum:]+)([,][:alnum:]+([ ]+as[ ]+[:alnum:]+)*)
    )[)])

To simplify this there is an example:
::REQUIRES "sys~serializable(serializable as ser,serializefunctions)"
*/
::CLASS PackageResolver
::METHOD UNKNOWN
  return 0
::METHOD REQUIRES
--  signal on syntax
  use arg info
  name = info~name
  -- check if this is a special require not actually requiring a file
  if name~pos("~") > 1 then do
    info~name = "nop"
    info~SecurityManager = .Go~getInstance~SecurityManager
    self~resolve(name)
    return 1
  end
  else
    return 0

::METHOD resolve
  use strict arg res
  parse arg name "(" cls ")"
  path = name~makeArray("~")
  classes = .directory~new
  trace i
  do class over cls~makeArray(",")
    parse upper var class name " AS " abrev
    name = name~strip
    abrev = abrev~strip
    if abrev~length = 0 then abrev = name
    classes[name] = abrev
  end
--  trace r
  pkgdata = self~getPackage(path)
  if classes~items > 0 then do
    do class over pkgdata~classes
      id = class~id~upper
      if classes~hasIndex(id) then do
        self~setClass(classes[id],class)
      end
    end
  end
  else do class over pkgdata~classes
    self~setClass(class~id,class)
  end

::METHOD getPackage
  signal on user PackageNotFound
  use strict arg path
  s = .Package
  do i over path
    o = s~getName
    s = s~getElement(i)
  end
  if s~isSubclassOf(.PackageData) then
    return s~new
  else raise syntax 93.900 array ("Unable to load package '"i"', no package data found")

  PackageNotFound:
  raise syntax 3.900 array ("Unable to locate package '"i"' in" o)


::METHOD setClass
  use strict arg name, class
  .local[name] = class

