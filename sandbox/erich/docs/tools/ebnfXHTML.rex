/*
 * For ooRexx 5.0 docs (e. g. rexxref, rxmath) the existing ASCII-style
 * railroad syntax diagrams were changed to SVG-graphics generated by a
 * web-based tool called "Railroad Diagram Generator" (RDG) from an
 * EBNF-based input.  RDG seems to be an appropriate tool to document a
 * language (e. g. ooRexx itself), but it's not a 100% replacement for
 * all old-style ASCII railroad syntax diagram features.
 *
 * http://bottlecaps.de/rr/ui "Railroad Diagram Generator"
 * Tab "Options": Color "#CCCCCC"
 * Tab "Edit Grammar": Browse.. (e. g.) docs\trunk\rexxref\en-US\images\bif\bif.ebnf; Load
 * Tab "View Diagram": Radio button "SVG", Download, Save as docs\trunk\rexxref\en-US\images\bif\bif.xhtml
 *
 * The downloaded XHTML contains all diagrams embedded as <svg>..</svg>,
 * which we will need to split out and save as separate .svg files.
 * RDG allows to set output colors, but not output fonts.  As ooRexx
 * documentation uses italic font for function/method variables, we'll add
 * "font-style: italic;" to each SVG's CSS "text.nonterminal {..}"
 * definition while splitting them from the base XHTML file.
 * Additionally, RDG adds links to each "nonterminal" (which we use for
 * function/method parameters).  Those links show up e.g. during hovering,
 * but are otherwise non-functional.  We'll remove them (by commenting
 * them) during the split process.                         
**/

parse arg options
dryRun = 1
noFix = 0
do option over options~makeArray(" ")
  option = option~strip("L", "-")
  select
    when "dryrun dry-run nowrite no-write"~caselessWordPos(option) >0
      then dryRun = 1
    when "write"~caselessWordPos(option) >0
      then dryRun = 0
    when "nofix no-fix"~caselessWordPos(option) >0
      then noFix = 1
    otherwise do
      say "Unknwon option" '<'option'>'
      exit 
    end
  end
end

-- current directory must contain base XHTML
-- individual SVG files will also be written to the current directory
svgsExisting = .Directory~new          -- SVGs already in working copy
svgsAllNew = .Directory~new            -- SVGs extracted from XHTML
svgsAllChanged = .Directory~new        --  ..
svgsAllIdentical = .Directory~new      --  ..
xhtmls = .List~new                     -- XHTML's in working copy

-- iterate all files in current directory, remember XHTML's and SVG's
list = .File~new(".")~listFiles
do file over list
  filename = file~name
  if filename~reverse~caselessAbbrev(".svg"~reverse) then   -- caselessEndsWith in 5.0
  do
    svg = .Stream~new(file)
    svg~open("READ SHARED")
    svgsExisting~put(svg~arrayIn, filename)
    svg~close
  end
  if filename~reverse~caselessAbbrev(".xhtml"~reverse) then -- caselessEndsWith in 5.0
    xhtmls~append(file)
end
say xhtmls~items "XHTML files," svgsExisting~items "SVG files found"

-- work through all XHTML's
do xhtml over xhtmls
  xml = .xml~new(.Stream~new(xhtml))
  svgsNew = .Directory~new             -- SVGs extracted from XHTML
  svgsChanged = .Directory~new         --  ..
  svgsIdentical = .Directory~new       --  ..

  -- XHTML layout: <body> .. ( <xhtml:a name=" .. <svg .. </svg> )*
  xml~skipTo("<body>", "required tag")
  do while xml~skipTo('<xhtml:a name="')
    parse value xml~line with '<xhtml:a name="' filename '"'

    -- the XHTML signature area contains an SVG that we ignore
    if filename~caselessEquals("Railroad-Diagram-Generator") then
      iterate

    xml~skipTo("<svg", "required tag") -- start of SVG data
    if noFix
      then tags = xml~get              -- collect SVG data
      else tags = fixItalicAndLinks(xml~get) -- collect SVG data, and fix it

    -- SVG identical to existing, or changed?
    select
      -- new SVG
      when .nil == svgsExisting[filename".svg"] then
        svgsNew~put(tags, filename".svg")
      -- SVG identical to existing
      when tags~makeString == svgsExisting[filename".svg"]~makeString then do
        /*Dbg say (xhtml~name":" filename)~left(35) tags~items "identical lines"*/
        svgsIdentical~put(tags, filename".svg")
      end 
      -- SVG changed
      otherwise do
        say (xhtml~name":" filename)~left(35) svgsExisting[filename".svg"]~items "existing ->" tags~items "new changed lines" 
        svgsChanged~put(tags, filename".svg")
      end
    end
  end

  say xhtml~name":" svgsIdentical~items "identical," svgsChanged~items "changed, and" svgsNew~items "new SVGs" 
  svgsAllIdentical~putAll(svgsIdentical)
  svgsAllChanged~putAll(svgsChanged)
  svgsAllNew~putAll(svgsNew)
end

say
say "Totals:"
say xhtmls~items "HTMLs," svgsAllIdentical~items "identical," svgsAllChanged~items "changed, and" svgsAllNew~items "new SVGs" 
svgsAll = .Directory~new
svgsAll~putAll(svgsAllIdentical)
svgsAll~putAll(svgsAllChanged)
svgsAll~putAll(svgsAllNew)
unmatched = svgsAll~allIndexes~difference(svgsExisting~allIndexes)
say unmatched~items "existing SVGs unmatched" unmatched~allItems~sort~makeString(, ",")

svgsAll = .Directory~new
svgsAll~putAll(svgsAllChanged)
svgsAll~putAll(svgsAllNew)
do svg over svgsAll
  newFile = .File~new(svg)
  new = .Stream~new(newFile)
  if \dryRun then do
    code = new~open("WRITE REPLACE")
    if code~abbrev("READY") then do
      new~arrayOut(svgsAll[svg])
      new~close
    end
      else say "Cannot write to" svg":" code
  end
end
if dryRun
  then say "dry-run .. no new/changed SVGs written"
  else say "new/changed SVGs written to working copy"


-- navigate XHTML stream; not a full XML parser
::class xml

::attribute line get

::method init
  expose stream line
  use arg stream
  stream~open("READ SHARED")
  line = ""

::method uninit
  expose stream
  stream~close

-- we don't do full XML parsing, just simple text search
::method skipTo
  expose stream line
  use strict arg text, error = ""
  signal on notready
  line = stream~linein                 -- start searching beyond current line
  do while line~caselessPos(text) = 0
    line = stream~linein
  end
  return 1

  notready:
    if error = "" then
      return 0
    say self~class~id"~skipTo" stream~name";" error text
      exit 1

-- we don't do full XML parsing, just simple text search
::method get
  expose stream line
  signal on notready
  tags = .Array~new
  endTag = line~word(1)~insert("/", 1)~strip("T", ">")||">"
  do until line~caselessPos(endTag) > 0
    tags~append(line)
    line = stream~linein
  end
  tags~append(line)
  return tags

  notready:
    if error = "" then
      return 0
    say self~class~id"~skipTo" stream~name":" error text
      exit 1


-- change "nonterminal" CSS for italic font, and remove xlinks
::routine fixItalicAndLinks
  use arg lines
  do n=1 to lines~items

    -- add "font-style: italic;" to "nonterminal" CSS
    if lines[n]~caselessPos("text.nonterminal") > 0 then
      lines[n] ||= " font-style: italic;"

    -- comment any xlinks
    if lines[n]~caselessPos('<a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="') > 0 then
      lines[n] = lines[n]~overlay("<!-- ")~strip("T") "-->"
    if lines[n]~caselessPos("</a>") > 0 then
      lines[n] = lines[n]~overlay("<!-- ")~strip("T") "-->"

  end
  return lines


::options novalue error
