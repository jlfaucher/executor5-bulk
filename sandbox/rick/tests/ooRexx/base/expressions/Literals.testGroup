#!/usr/bin/rexx
/*
  SVN Revision: $Rev: 11306 $
  Change Date:  $Date: 2017-10-07 20:21:20 +0200 (Sa, 07 Okt 2017) $
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2017 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . s
  group = .TestGroup~new(s)
  group~add(.LiteralsSingleQuote.testGroup)
  group~add(.LiteralsDoubleQuote.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult

::requires 'ooTest.frm' -- load the ooRexxUnit classes


::class LiteralsSingleQuote.testGroup subclass Literals.testGroup public
::constant quote "'"

::class LiteralsDoubleQuote.testGroup subclass Literals.testGroup public
::constant quote '"'


::class Literals.testGroup subclass ooTestCase public

::method quoteHex
  use strict arg string
  quote = self~quote
  return quote || string || quote || "x"

::method quoteBin
  use strict arg string
  quote = self~quote
  return quote || string || quote || "b"


-- literal hexadecimal string tests

::method test_hexadecimal_blank
   -- Incorrect location of whitespace character in position 1 in hexadecimal string
   self~assertSyntaxError(15.1, "s =" self~quoteHex(" "))

::method test_hexadecimal_tab
   -- Incorrect location of whitespace character in position 1 in hexadecimal string
   self~assertSyntaxError(15.1, "s =" self~quoteHex(.String~tab))

::method test_hexadecimal_invalid_dot
   -- Only 0-9, a-f, A-F, and whitespace characters are valid in a hexadecimal string
   self~assertSyntaxError(15.3, "s =" self~quoteHex("."))

::method test_hexadecimal_invalid_char
   -- Only 0-9, a-f, A-F, and whitespace characters are valid in a hexadecimal string
   self~assertSyntaxError(15.3, "s =" self~quoteHex("X"))

::method test_hexadecimal_leading_blank
   -- Incorrect location of whitespace character in position 1 in hexadecimal string
   self~assertSyntaxError(15.1, "s =" self~quoteHex(" 41"))

::method test_hexadecimal_leading_tab
   -- Incorrect location of whitespace character in position 1 in hexadecimal string
   self~assertSyntaxError(15.1, "s =" self~quoteHex(.String~tab || "41"))

::method test_hexadecimal_trailing_blank
   -- Incorrect location of whitespace character in position 3 in hexadecimal string
   self~assertSyntaxError(15.1, "s =" self~quoteHex("41 "))

::method test_hexadecimal_trailing_tab
   -- Incorrect location of whitespace character in position 3 in hexadecimal string
   self~assertSyntaxError(15.1, "s =" self~quoteHex("41" || .String~tab))

::method test_hexadecimal_inner_blank_2_b_1
   -- Only 0-9, a-f, A-F, and whitespace characters are valid in a hexadecimal string
   -- this message really isn't appropriate
   self~assertSyntaxError(15.3, "s =" self~quoteHex("41 4"))

::method test_hexadecimal_inner_tab_2_t_1
   -- Only 0-9, a-f, A-F, and whitespace characters are valid in a hexadecimal string
   -- this message really isn't appropriate
   self~assertSyntaxError(15.3, "s =" self~quoteHex("41" || .String~tab || "4"))

::method test_hexadecimal_inner_blank_1_b_3
   -- Only 0-9, a-f, A-F, and whitespace characters are valid in a hexadecimal string
   -- this message really isn't appropriate
   self~assertSyntaxError(15.3, "s =" self~quoteHex("4 142"))

::method test_hexadecimal_inner_tab_1_t_3
   -- Only 0-9, a-f, A-F, and whitespace characters are valid in a hexadecimal string
   -- this message really isn't appropriate
   self~assertSyntaxError(15.3, "s =" self~quoteHex("4" || .String~tab || "142"))

::method test_hexadecimal_single
   -- '0'x .. 'f'x
   n = 0
   do hex over "0123456789abcdef"~makeArray("")
     self~assertSame(n~d2c, self~runDynamicSource("return" self~quoteHex(hex)))
     n += 1
   end
   -- 'A'x .. 'F'x
   n = 10
   do hex over "ABCDEF"~makeArray("")
     self~assertSame(n~d2c, self~runDynamicSource("return" self~quoteHex(hex)))
     n += 1
   end

::method test_hexadecimal_double
   -- '00'x .. 'fF'x
   n = 0
   do first over "0123456789abcdef"~makeArray("")
     do second over "0123456789ABCDEF"~makeArray("")
       self~assertSame(n~d2c, self~runDynamicSource("return" self~quoteHex(first || second)))
       n += 1
     end
   end

::method test_hexadecimal_all_allowed
   self~assertSame(.String~xdigit~x2c, '0123456789ABCDEFabcdef'x)


::method test_hexadecimal_whitespace
   tab = .String~tab
   self~assertSame("AB", self~runDynamicSource("return" self~quoteHex("41 42")))
   self~assertSame("AB", self~runDynamicSource("return" self~quoteHex("41  42")))
   self~assertSame("AB", self~runDynamicSource("return" self~quoteHex("41   42")))
   self~assertSame("AB", self~runDynamicSource("return" self~quoteHex("41" || tab || "42")))
   self~assertSame("AB", self~runDynamicSource("return" self~quoteHex("41" || tab || tab || "42")))
   self~assertSame("AB", self~runDynamicSource("return" self~quoteHex("41" || tab || tab || tab || "42")))
   self~assertSame("AB", self~runDynamicSource("return" self~quoteHex("41 " || tab || "42")))
   self~assertSame("AB", self~runDynamicSource("return" self~quoteHex("41" || tab || " 42")))


-- literal binary string tests

::method test_binary_blank
   -- Incorrect location of whitespace character in position 1 in binary string
   self~assertSyntaxError(15.2, "s =" self~quoteBin(" "))

::method test_binary_tab
   -- Incorrect location of whitespace character in position 1 in binary string
   self~assertSyntaxError(15.2, "s =" self~quoteBin(.String~tab))

::method test_binary_invalid_dot
   -- Only 0, 1, and whitespace characters are valid in a binary string
   self~assertSyntaxError(15.4, "s =" self~quoteBin("."))

::method test_binary_invalid_char
   -- Only 0, 1, and whitespace characters are valid in a binary string
   self~assertSyntaxError(15.4, "s =" self~quoteBin("2"))

::method test_binary_leading_blank
   -- Incorrect location of whitespace character in position 1 in binary string
   self~assertSyntaxError(15.2, "s =" self~quoteBin(" 0000"))

::method test_binary_leading_tab
   -- Incorrect location of whitespace character in position 1 in binary string
   self~assertSyntaxError(15.2, "s =" self~quoteBin(.String~tab || "0000"))

::method test_binary_trailing_blank
   -- Incorrect location of whitespace character in position 5 in binary string
   self~assertSyntaxError(15.2, "s =" self~quoteBin("0000 "))

::method test_binary_trailing_tab
   -- Incorrect location of whitespace character in position 5 in binary string
   self~assertSyntaxError(15.2, "s =" self~quoteBin("0000" || .String~tab))

::method test_binary_inner_blank_4_b_3
   -- Incorrect location of whitespace character in position 5 in binary string
   self~assertSyntaxError(15.2, "s =" self~quoteBin("0000 111"))

::method test_binary_inner_tab_4_t_3
   -- Incorrect location of whitespace character in position 5 in binary string
   self~assertSyntaxError(15.2, "s =" self~quoteBin("0000" || .String~tab || "111"))

::method test_binary_inner_blank_1_b_5
   -- Incorrect location of whitespace character in position 2 in binary string
   self~assertSyntaxError(15.2, "s =" self~quoteBin("0 11111"))

::method test_binary_inner_tab_1_t_5
   -- Incorrect location of whitespace character in position 2 in binary string
   self~assertSyntaxError(15.2, "s =" self~quoteBin("0" || .String~tab || "11111"))

::method test_binary_single
   -- '0'b, '1'b
   do bin = 0 to 1
     self~assertSame(bin~d2c, self~runDynamicSource("return" self~quoteBin(bin)))
   end

::method test_binary_nibble
   -- '0000'b .. '1111'b
   n = 0
   do first = 0 to 1
     do second = 0 to 1
       do third = 0 to 1
         do fourth = 0 to 1
           self~assertSame(n~d2c, self~runDynamicSource("return" self~quoteBin(first || second || third || fourth)))
           n += 1
         end
       end
     end
   end

::method test_binary_ones
  -- '1'b .. '111..(total of 64)..111'b
  numeric digits 20
  do power = 1 to 64
    self~assertSame((2 ** power - 1)~d2c, self~runDynamicSource("return" self~quoteBin(1~copies(power))))
  end

::method test_binary_whitespace
   tab = .String~tab
   self~assertSame("A", self~runDynamicSource("return" self~quoteBin("0100 0001")))
   self~assertSame("A", self~runDynamicSource("return" self~quoteBin("0100  0001")))
   self~assertSame("A", self~runDynamicSource("return" self~quoteBin("0100   0001")))
   self~assertSame("A", self~runDynamicSource("return" self~quoteBin("0100" || tab || "0001")))
   self~assertSame("A", self~runDynamicSource("return" self~quoteBin("0100" || tab || tab || "0001")))
   self~assertSame("A", self~runDynamicSource("return" self~quoteBin("0100" || tab || tab || tab || "0001")))
   self~assertSame("A", self~runDynamicSource("return" self~quoteBin("0100 " || tab || "0001")))
   self~assertSame("A", self~runDynamicSource("return" self~quoteBin("0100" || tab || " 0001")))

   self~assertSame("AB", self~runDynamicSource("return" self~quoteBin("0100 0001 0100 0010")))
   self~assertSame("AB", self~runDynamicSource("return" self~quoteBin("0100 0001  01000010")))
   self~assertSame("AB", self~runDynamicSource("return" self~quoteBin("0100 00010100  0010")))
   self~assertSame("AB", self~runDynamicSource("return" self~quoteBin("0100   000101000010")))
   self~assertSame("AB", self~runDynamicSource("return" self~quoteBin("01000001 0100 0010")))
   self~assertSame("AB", self~runDynamicSource("return" self~quoteBin("01000001  01000010")))
   self~assertSame("AB", self~runDynamicSource("return" self~quoteBin("010000010100  0010")))


::options novalue error
