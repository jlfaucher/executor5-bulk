#!/usr/bin/rexx
/*
  SVN Revision: $Rev: 8249 $
  Change Date:  $Date: 2012-08-24 18:57:30 -0400 (Fri, 24 Aug 2012) $
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . fileSpec

  group = .TestGroup~new(fileSpec)
  group~add(.StackFrame.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult
-- End of entry point.

::requires 'ooTest.frm' -- load the ooRexxUnit classes


::class "StackFrame.testGroup" subclass ooTestCase public

::method testMethodFrame
  -- the top frame is for this method call.  We can just use that to
  -- double check
  info = grabContextInfo(.context, .line, .context~stackFrames)

  frame = info~stackFrames[1]

  self~checkFrame("METHOD", self, frame, info)

::method testRoutineFrame
  info = routineContext()

  frame = info~stackFrames[1]

  self~checkFrame("ROUTINE", .nil, frame, info)

::method testInternalCallFrame
  info = internalContext()

  frame = info~stackFrames[1]

  self~checkFrame("INTERNALCALL", .nil, frame, info)
  exit

  internalContext:
  return grabContextInfo(.context, .line, .context~stackFrames)

::method testInterpretFrame

  interpret "info = grabContextInfo(.context, .line, .context~stackFrames)"
  frame = info~stackFrames[1]
  -- interpret frames do not have a name
  info~name = ""

  self~checkFrame("INTERPRET", .nil, frame, info)
  exit

::method testNativeCodeFrame
  test = .array~of(1,2)

  comparator = .ContextComparator~new
  test~sortwith(comparator)

  -- the sortwith method should be one back
  frame = comparator~stackframes[2]
  self~assertSame("METHOD", frame~type)
  self~assertTrue(.array~of(comparator)~equivalent(frame~arguments))
  self~assertSame("SORTWITH", frame~name)
  self~assertSame(.Array~method("SORTWITH"), frame~executable)
  self~assertSame(.nil, frame~line)
  self~assertSame(test, frame~target)
  self~assertSame(frame~traceLine, frame~string)
  self~assertSame(frame~traceLine, frame~makestring)

::method testExternalNativeCodeFrame
  signal on syntax

  s = .stream~new("test.dat")
  s~charin("abc")

  exit
  syntax:

  o = condition('o')

  frame = o~stackframes~firstItem
  self~assertSame("METHOD", frame~type)
  self~assertTrue(.array~of("abc")~equivalent(frame~arguments))
  self~assertSame("CHARIN", frame~name)
  self~assertSame(.Stream~method("CHARIN"), frame~executable)
  self~assertSame(.nil, frame~line)
  self~assertSame(s, frame~target)
  self~assertSame(frame~traceLine, frame~string)
  self~assertSame(frame~traceLine, frame~makestring)


-- perform a series of validity checks on a frame
::method checkFrame
  use arg type, target, frame, info

  self~assertSame(type, frame~type)
  self~assertTrue(info~args~equivalent(frame~arguments))
  self~assertSame(info~name, frame~name)
  self~assertSame(info~executable, frame~executable)
  self~assertSame(info~line, frame~line)
  self~assertSame(target, frame~target)
  self~assertSame(frame~traceLine, frame~string)
  self~assertSame(frame~traceLine, frame~makestring)

::class ContextComparator subclass NumericComparator
::attribute stackframes

::method compare
  self~stackframes = .context~stackframes
  forward class(super)


::routine routineContext
  return grabContextInfo(.context, .line, .context~stackFrames)

::routine grabContextInfo
  use arg context, line, stackframes

  info = .directory~new
  info~name = context~name
  info~stackFrames = stackframes
  info~executable = context~executable
  info~line = line
  info~args = context~args

  return info




