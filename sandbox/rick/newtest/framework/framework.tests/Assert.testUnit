#!/usr/bin/rexx
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2006 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
.ooRexx.framework.Assert.testUnit~run


::requires ooRexxUnit.cls     -- load the ooRexxUnit classes

::class "ooRexx.framework.Assert.testUnit" subclass TestCase public

   -- test "assertEquals"
::method "test_assertEquals_00"
   self~assertEquals(1, 1)          -- no failure message

   -- test "assertEquals"
::method "test_assertEquals_01"
   self~assertEquals(1   , 1,    "subtest_01")
   self~assertEquals(2   , 2,    "subtest_02")
   self~assertEquals(.nil, .nil, "subtest_03")
   o=.object~new
   self~assertEquals(o, o, "subtest_04")

   self~assertEquals("abc", " abc ")
   self~assertEquals(1, 1.0)

   -- test "assertEquals"
::method "test_assertNotEquals_01a"
   self~assertNotEqual(1 , 2,    "subtest_01")
   self~assertNotEqual("abc", .nil, "subtest_03")
   o1=.object~new
   o2=.object~new
   self~assertNotEqual(o1, o2, "subtest_04")

   -- test "assertEquals"
::method "test_assertEquals_02"
   bag=.bag~of("a", "a", "b", "c")
   set=.set~new~union(bag)

   self~assertEquals(bag, bag, "subtest_01")
   self~assertEquals(set, set, "subtest_02")
   self~assertIdentical(bag, bag, "subtest_01")
   self~assertIdentical(set, set, "subtest_02")
   self~assertCollectionsEqual(.bag~new~union(set), .bag~new~union(set), "subtest_03")

   -- test "assertEquals"
::method "test_assertEquals_03"
   b=.bag~of("a", "a", "b")
   r=.relation~new
   r["a"]="a"
   r["a"]="a"
   r["b"]="b"
   self~assertCollectionsEqual(b, r, "subtest_01")


   -- test "assertEquals"
::method "test_assertEquals_04"
   s=.set~of("a", "a", "b")
   t=.table~new
   t["a"]="a"
   t["a"]="a"
   t["b"]="b"
   self~assertCollectionsEqual(s, t, "subtest_01")


   -- test "assertEquals"
::method "test_assertEquals_05"
   s=.set~of("a", "a", "b")
   d=.directory~new
   d["a"]="a"
   d["a"]="a"
   d["b"]="b"
   self~assertCollectionsEqual(s, d, "subtest_01")


   -- test "assertEquals"
::method "test_assertEquals_06"
   a=.array~of("a", "a", "b")
   l=.list~of("a", "a", "b")
   q=.queue~new~~queue("a")~~queue("a")~~queue("b")
   c=.circularQueue~new(3)~~queue("a")~~queue("a")~~queue("b")

   self~assertCollectionsEqual(q, l, "subtest_01")
   self~assertCollectionsEqual(l, a, "subtest_02")
   self~assertCollectionsEqual(q, a, "subtest_03")
   self~assertCollectionsEqual(c, a, "subtest_04")
   self~assertCollectionsEqual(c, l, "subtest_05")
   self~assertCollectionsEqual(c, q, "subtest_06")



::method "test_assertEquals_07"
   s=.set~of("a", "a", "b")
   t=.table~new~union(s)
   self~assertCollectionsEqual(s, t, "subtest_01")


::method "test_assertEquals_08"
   s=.set~of("a", "a", "b")
   r=.relation~new~union(s)
   self~assertCollectionsEqual(s, r, "subtest_01")


::method "test_assertEquals_09"
   t=.table~new
   t["a"]="a"
   t["b"]="b"
   r=.relation~new~union(t)
   self~assertCollectionsEqual(t, r, "subtest_01")



   -- test "assertNotEquals"
::method "test_assertNotEquals_00"
   self~assertNotEquals(1, 2)          -- no failure message

   -- test "assertNotEquals"
::method "test_assertNotEquals_01"
   self~assertNotEquals(1, 2, "subtest_01")
   self~assertNotEquals(2, 1, "subtest_02")
   self~assertNotEquals(.nil, .object, "subtest_03")
   o=.object~new
   self~assertNotEquals(.nil, o, "subtest_04")


   -- test "assertNotEquals"
::method "test_assertNotEquals_02"
   bag=.bag~of("a", "a", "b", "c")
   set=.set~new~union(bag)

   self~assertCollectionsNotEqual(bag, set, "subtest_01")
   self~assertCollectionsNotEqual(set, bag, "subtest_02")
   self~assertCollectionsNotEqual(.bag~new~union(set), .bag~new~union(set)~~put("c"), "subtest_03")

   -- test "assertNotEquals"
::method "test_assertNotEquals_03"
   b=.bag~of("a", "a", "b")
   r=.relation~new
   r["a"]="a"
   r["a"]="a"
   r["b"]="b"
   r["c"]="c"
   self~assertCollectionsNotEqual(b, r, "subtest_01")


   -- test "assertNotEquals"
::method "test_assertNotEquals_04"
   s=.set~of("a", "a", "b")
   t=.table~new
   t["a"]="a"
   t["a"]="a"
   t["b"]="b"
   t["c"]="c"
   self~assertCollectionsNotEqual(s, t, "subtest_01")


   -- test "assertNotEquals"
::method "test_assertNotEquals_05"
   s=.set~of("a", "a", "b")
   d=.directory~new
   d["a"]="a"
   d["a"]="a"
   d["b"]="b"
   d["c"]="c"
   self~assertCollectionsNotEqual(s, d, "subtest_01")


   -- test "assertNotEquals"
::method "test_assertNotEquals_06"
   a=.array~of("a", "a", "b", "b")
   l=.list~of("a", "a", "b", "b", "c")
   q=.queue~new~~queue("a")~~queue("a")~~queue("b")~~queue("b")~~queue("c")~~queue("c")
   c=.circularQueue~new(3)~~queue("a")~~queue("a")~~queue("b")~~queue("b")~~queue("c")~~queue("c")~~queue("d")

   self~assertCollectionsNotEqual(q, l, "subtest_01")
   self~assertCollectionsNotEqual(l, a, "subtest_02")
   self~assertCollectionsNotEqual(q, a, "subtest_03")
   self~assertCollectionsNotEqual(c, a, "subtest_04")
   self~assertCollectionsNotEqual(c, l, "subtest_05")
   self~assertCollectionsNotEqual(c, q, "subtest_06")


::method "test_assertNotEquals_07"
   s=.set~of("a", "a", "b")
   t=.table~new~union(s)~~put("c","c")
   self~assertCollectionsNotEqual(s, t, "subtest_01")


::method "test_assertNotEquals_08"
   s=.set~of("a", "a", "b")
   r=.relation~new~union(s)~~put("c", "c")
   self~assertCollectionsNotEqual(s, r, "subtest_01")


::method "test_assertNotEquals_09"
   t=.table~new
   t["a"]="a"
   t["b"]="b"
   r=.relation~new~union(t)~~put("c", "c")
   self~assertCollectionsNotEqual(t, r, "subtest_01")



::method "test_assertFalse"
   self~assertFalse(.false)         -- no failure message
   self~assertFalse(.false, "should be .false")



::method "test_assertNotNull"
   self~assertNotNull("2")          -- no failure message
   self~assertNotNull("2", "message in case of failure")


::method "test_assertNotSame"
   self~assertNotSame(1, "2")       -- no failure message
   self~assertNotSame(1, "2", "message in case of failure")


::method "test_assertNull"
   self~assertNull(.nil)            -- no failure message
   self~assertNull(.nil, "message in case of failure")


::method "test_assertSame"
   self~assertSame(1, "1")          -- no failure message
   self~assertSame(1, "1", "message in case of failure")


::method "test_assertTrue"
   self~assertTrue(.true)           -- no failure message
   self~assertTrue(.true, "should be .true")


::method "test_expectSyntax"
   self~expectSyntax(13.1)
   raise syntax 13.1


::method "test_expectCondition"
   self~expectCondition("NOVALUE")
   raise novalue


/* *** test methods which create failures and demonstrate the
       resulting failure messages.  We expect the syntax error
       used internally for assertion failures and pass on that */

::method "test_fail_assertEquals_01"
  self~expectSyntax(self~AssertionCode)
  self~assertEquals(12, 13)


::method "test_fail_assertEquals_02"
  self~expectSyntax(self~AssertionCode)
  self~assertEquals(12, 13, "A message in case of a failure.")


::method "test_fail_assertFalse_01"
  self~expectSyntax(self~AssertionCode)
  self~assertFalse(.true)

::method "test_fail_assertFalse_02"
  self~expectSyntax(self~AssertionCode)
  self~assertFalse(.true, "A message in case of a failure.")


::method "test_fail_assertNotNull_01"
  self~expectSyntax(self~AssertionCode)
  self~assertNotNull(.nil)

::method "test_fail_assertNotNull_02"
  self~expectSyntax(self~AssertionCode)
  self~assertNotNull(.nil, "A message in case of a failure.")


::method "test_fail_assertNotSame_01"
  self~expectSyntax(self~AssertionCode)
  a=12
  self~assertNotSame(a, a)

::method "test_fail_assertNotSame_02"
  self~expectSyntax(self~AssertionCode)
  a=12
  self~assertNotSame(a, a, "A message in case of a failure.")

::method "test_fail_assertNotEquals_01"
  self~expectSyntax(self~AssertionCode)
  self~assertNotEquals(12, 12)

::method "test_fail_assertNotEquals_02"
  self~expectSyntax(self~AssertionCode)
  self~assertNotEquals(12, 12, "A message in case of a failure.")

::method "test_fail_assertNull_01"
  self~expectSyntax(self~AssertionCode)
  self~assertNull(12)

::method "test_fail_assertNull_02"
  self~expectSyntax(self~AssertionCode)
  self~assertNull(12, "A message in case of a failure.")

::method "test_fail_assertSame_01"
  self~expectSyntax(self~AssertionCode)
  self~assertSame(12, " 12")

::method "test_fail_assertSame_02"
  self~expectSyntax(self~AssertionCode)
  self~assertSame(12, "12 ", "A message in case of a failure.")

::method "test_fail_assertTrue_01"
  self~expectSyntax(self~AssertionCode)
  self~assertTrue(.false)

::method "test_fail_assertTrue_02"
  self~expectSyntax(self~AssertionCode)
  self~assertTrue(.false, "A message in case of a failure.")
