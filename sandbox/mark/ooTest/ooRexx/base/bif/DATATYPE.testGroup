#!/usr/bin/rexx
/*
   name:             DATATYPE.testUnit
   author:           Lee Peedin
   date:             2007/12/06
   version:          1.0
   date:             2007/12/18
   version:          1.1

-- line commented lines are ignored, when building the directory of infos from this header
   changed:

   languageLevel:    6.02
   purpose:          Test the DATATYPE BIF
   remark:           ---

   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

// category needs not to be numbered, importance is given by position (1=most important)
   category1:        ooRexx
   category2:        Base
   category3:        BIF

*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/

-------------------------------------------------------------------------------------------
   /* list of array objects, each containing the testUnit class object and an
      optional list of mandatory test case methods name                       */
    mandatoryTestMethods=.list~new   -- no mandatory tests for this testCase class
    testUnitList=.list~of(.array~of(.DATATYPE.testGroup, mandatoryTestMethods))

-------------------------------------------------------------------------------------------
-- ===> the following code needs not to be individualized                              <===

   -- read top comment, containing infos about this program
    arrLines=.array~new
    do i=1 to 150 until arrLines[i]="*/"
        arrLines[i]=sourceline(i)
    end
      -- supply information for the testClass(es) in this file; the class attribute
      -- "TestCaseInfo" (a directory object, index points to a queue) will store
      -- the parsed infos
    aTestUnitClass=testUnitList~at(testUnitList~first)[1] -- get first testClass

   -- will parse the array lines and store result in class object
    call makeDirTestInfo aTestUnitClass, arrLines
    tmpDir=aTestUnitClass~TestCaseInfo
    parse source s   -- op_sys invocationType fullPathToThisFile
    tmpDir~setentry("test_Case-source", s)
   -- now add this directory to other testCase classes, if any left
    do arr over testUnitList
        if arr[1]=aTestUnitClass then
            iterate  -- already handled
        arr[1]~TestCaseInfo=tmpDir             -- save info in class object
    end

-- if this file is CALLed or REQUIRED then define an entry "bRunTestLocally" in .local
-- and set it to .false; this way the independent local invocation of the tests is inhibited
    if .local~hasentry("bRunTestsLocally")=.false then
        .local~bRunTestsLocally=.true -- if this file is executed directly, then run tests for debugging

    if .bRunTestsLocally=.true then  -- run ALL tests in this test unit
        do
            ts=.testSuite~new             -- create a testSuite
            do arr over testUnitList
                -- create a testSuite for the given test case class, use all its testmethods
                ts~addTest( .testSuite~new(arr[1]))
            end
            -- testResult=.testSuite~new(testUnitClass)~run
            testResult=ts~run       -- now run all the tests

            call simpleFormatTestResults testResult
        end

   /* return list of array objects containing test case classes and
      optionally list of mandatory test methods                      */
return testUnitList

::requires ooRexxUnit.cls     -- load the ooRexxUnit classes

-- class named exactly like file
::class "DATATYPE.testGroup" subclass TestCase public

::method 'test01'
    s = ''
    self~assertSame('subTest01','010000001C',dts(s))

::method 'test02'
    do i = 0 to 255
        s = d2c(i)
        self~assertSame('subTest'i~right(3,'0'),mydts(s),dts(s))
    end

::method 'test03'
    sarray = .array~new()
    sarray~append('A')
    sarray~append('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
    sarray~append('a')
    sarray~append('abcdefghijklmnopqrstuvwxyz')
    sarray~append('aBCDEFGHIJKLMNOPQRSTUVWXYZ')
    sarray~append('ABCdEFGHIJKLMNOPQRSTUVWXYZ')
    sarray~append('Abcdefghijklmnopqrstuvwxyz')
    sarray~append('abcDefghijklmnopqrstuvwxyz')
    sarray~append(' bcdeFghijklmnopqrstuvwxyz')
    sarray~append('abc efGhijklmnopqrstuvwxyz')
    sarray~append('abcdefgHijklmnopqrstuvwxy ')
    sarray~append('abcdefghI     opqrstuvwxyz')
    sarray~append(copies('a',100000))
    sarray~append('{')
    sarray~append('º')
    sarray~append('}')
    sarray~append('›')
    sarray~append('\')
    sarray~append('!')
    sarray~append('~')
    sarray~append('%')
    sarray~append('ª')
    sarray~append('&')
    sarray~append('*')
    sarray~append('$')
    sarray~append('cba@')
    sarray~append('@aBc')
    sarray~append('?')
    sarray~append('!?!')
    sarray~append('!?|')
    sarray~append('.')
    sarray~append('-')
    sarray~append('+')
    sarray~append('1.1.')
    sarray~append('+1.1.')
    sarray~append('-1.1.')
    sarray~append('1.e.1')
    sarray~append('1e.1')
    sarray~append('+')
    sarray~append('@')
    sarray~append(copies('0',100000))
    sarray~append(copies('1',100000))
    sarray~append(1)
    sarray~append(1.0)
    sarray~append(.0)
    sarray~append('1')
    sarray~append('-1')
    sarray~append('+1')
    sarray~append('2')
    sarray~append('123456789')
    sarray~append('1234567890')
    sarray~append('12345678901')
    sarray~append('-1.4142')
    sarray~append('+1.4142')
    sarray~append('+1.733e+5')
    sarray~append('-1.733e+5')
    sarray~append('+1.733e-5')
    sarray~append('-1.733e-5')
    sarray~append('2.7172718536')
    sarray~append('123.456789')
    sarray~append('1230.456789')
    sarray~append('1e-3')
    sarray~append('1E-3')
    sarray~append('1e+3')
    sarray~append('1E+3')
    sarray~append('1E -3')
    sarray~append('1e 3')
    sarray~append('1.e3')
    sarray~append('1e3')
    sarray~append('1E3')
    sarray~append(' 1E+3')
    sarray~append(' 1e3')
    sarray~append('1E+3 ')
    sarray~append('1e3 ')
    sarray~append('1e')
    sarray~append('e3')
    sarray~append('1e999999999')
    sarray~append('1e1000000000')
    sarray~append('1e+999999999')
    sarray~append('1e+1000000000')
    sarray~append('1e-999999999')
    sarray~append('1e-1000000000')
    sarray~append(copies('1234567890',25))
    sarray~append(copies('1234567890',25)'1')
    sarray~append(copies('1234567890',24)'e3')
    sarray~append(copies('1234567890',25)'e3')
    sarray~append(copies('1234567890', 5000)'.'copies('1234567890', 5000))
    sarray~append(copies('1234567890', 5000)'.'copies('1234567890', 5000)'e3')
    sarray~append(copies('1234567890', 3333)'.'copies('1234567890', 3333)'e'copies('1234567890', 3333))
    sarray~append(copies('1234567890',10000)'e+3')
    sarray~append(copies('1234567890',10000)'e-3')
    sarray~append(copies('1234567890', 5000)'.'copies('1234567890', 5000)'e+3')
    sarray~append(copies('1234567890', 5000)'.'copies('1234567890', 5000)'e-3')
    sarray~append('0123456789abcdef')
    sarray~append('0123456789ABCDEF')
    sarray~append('C2 0DAB')
    sarray~append('C2 DAB')
    sarray~append('c2 0dab')
    sarray~append('c2 dab')
    sarray~append('C2 0dab')
    sarray~append('c2 0Dab')
    sarray~append('C2  0d ab')
    sarray~append('c2   0D       ab')
    sarray~append(' c2   0D       ab')
    sarray~append('  c2   0D       ab')
    sarray~append('c2   0D       ab  ')
    sarray~append('c2   0D       ab ')
    sarray~append(' c2   0D       ab  ')
    sarray~append('  c2   0D       ab ')

    rarray = .array~new()
    rarray~append('100101101C')
    rarray~append('100101100C')
    rarray~append('101101001C')
    rarray~append('101101000C')
    rarray~append('100101000C')
    rarray~append('100101000C')
    rarray~append('100101000C')
    rarray~append('100101000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('101100001C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000001000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000001000C')
    rarray~append('000001000C')
    rarray~append('000000000C')
    rarray~append('000001000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000001000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000001000C')
    rarray~append('000001000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('110010011N')
    rarray~append('110010001N')
    rarray~append('110011011N')
    rarray~append('000011010N')
    rarray~append('000011010N')
    rarray~append('110011011N')
    rarray~append('000010010N')
    rarray~append('000010010N')
    rarray~append('100011011N')
    rarray~append('100011011N')
    rarray~append('100011001N')
    rarray~append('100011001N')
    rarray~append('000010000N')
    rarray~append('000010000N')
    rarray~append('000010010N')
    rarray~append('000010010N')
    rarray~append('000010000N')
    rarray~append('000010000N')
    rarray~append('000011000N')
    rarray~append('000011000N')
    rarray~append('000011000N')
    rarray~append('000011000N')
    rarray~append('000011000N')
    rarray~append('000011010N')
    rarray~append('000011010N')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000011010N')
    rarray~append('100011011N')
    rarray~append('100011011N')
    rarray~append('000010010N')
    rarray~append('000010010N')
    rarray~append('000010010N')
    rarray~append('000010010N')
    rarray~append('100001001C')
    rarray~append('100001001C')
    rarray~append('100011001N')
    rarray~append('100001001C')
    rarray~append('000011000N')
    rarray~append('000001000C')
    rarray~append('000011000N')
    rarray~append('000001000C')
    rarray~append('100011001N')
    rarray~append('100010001N')
    rarray~append('100011001N')
    rarray~append('100010001N')
    rarray~append('000010000N')
    rarray~append('000010000N')
    rarray~append('000000000C')
    rarray~append('000010000N')
    rarray~append('000010000N')
    rarray~append('000010000N')
    rarray~append('000010000N')
    rarray~append('100001001C')
    rarray~append('100001001C')
    rarray~append('000000001C')
    rarray~append('000000000C')
    rarray~append('000000001C')
    rarray~append('000000000C')
    rarray~append('000000001C')
    rarray~append('000000001C')
    rarray~append('000000001C')
    rarray~append('000000001C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')
    rarray~append('000000000C')

    do i = 1 to sarray~items
        self~assertSame('subTest'i~right(3,'0'),rarray[i],dts(sarray[i]))
    end

::method 'test04'  -- Additional tests added by Lee
    self~assertTrue('subtest01',datatype(0,'O'))

::method 'test05'
    self~assertTrue('subtest01',datatype(1,'O'))

::method 'test06'
    self~assertFalse('subtest02',datatype(2,'O'))

::method 'test07'
    self~assertFalse('subtest03',datatype(-1,'O'))

::method 'test08'
    self~assertFalse('subtest04',datatype('','O'))

-- Found some more tests to add
::method 'test09'
    numeric digits 3
    a0 = 0
    a1 = 1
    self~assertSame('subTest01','1',datatype(999,'w'))
    self~assertSame('subTest02',a1,datatype(1.004,'w'))
    self~assertSame('subTest03','0',datatype(1.005,'w'))
    self~assertSame('subTest04',a0,datatype(1.00E+3,'w'))
    self~assertSame('subTest05','0',datatype(-1.23456789012345E-2,'w'))

::method 'test10'
    numeric digits 4
    self~assertSame('subTest01','1',datatype(1000,'w'))

::routine dts
    parse arg a
    x = 'DATATYPE'(a)
return 'DATATYPE'(a,'A')||-
       'DATATYPE'(a,'B')||-
       'DATATYPE'(a,'L')||-
       'DATATYPE'(a,'M')||-
       'DATATYPE'(a,'N')||-
       'DATATYPE'(a,'S')||-
       'DATATYPE'(a,'U')||-
       'DATATYPE'(a,'W')||-
       'DATATYPE'(a,'X')||left(x,1)

::routine mydts
    parse Arg a
    notype = mydt(a,'N')
    res = mydt(a,'A')||-
          mydt(a,'B')||-
          mydt(a,'L')||-
          mydt(a,'M')||-
          mydt(a,'N')||-
          mydt(a,'S')||-
          mydt(a,'U')||-
          mydt(a,'W')||-
          mydt(a,'X')
    if notype then
        return res||'N'
    else
        return res||'C'

::routine mydt
    parse arg what,opt
    g.0numc = '0123456789'
    g.0alpl = 'abcdefghijklmnopqrstuvwxyz'
    g.0alpu = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    g.0soze = '.!?_'

    signal on Syntax name mysyntax
    select
        when opt == 'A' then              /* DATATYPE(what,'A')             */
            return verify(what,g.0numc||g.0alpl||g.0alpu)=0
        when opt == 'B' then              /* DATATYPE(what,'B')             */
            return verify(what,'01')=0
        when opt == 'L' then              /* DATATYPE(what,'L')             */
            return verify(what,g.0alpl)=0
        when opt == 'M' then              /* DATATYPE(what,'M')             */
            return verify(what,g.0alpl||g.0alpu)=0
        when opt == 'N' then              /* DATATYPE(what,'N')             */
            do
                erg='1'
                dummy=what+0
                return erg
            end
        when opt == 'S' then              /* DATATYPE(what,'S')             */
            return verify(what,g.0numc||g.0alpl||g.0alpu||g.0soze)=0
        when opt == 'U' then              /* DATATYPE(what,'U')             */
            return verify(what,g.0alpu)=0
        when opt == 'W' then              /* DATATYPE(what,'W')             */
            do
                erg='1'
                dummy=left('ABC',what)
                return erg
            end
        when opt == 'X' then              /* DATATYPE(what,'X')             */
            do
                erg='1'
                dummy=x2c(what)
                return erg
            end
        otherwise
            nop
    end
return

mysyntax:
    erg = '0'
return erg

-- from bif.testgroup
   -- test the BIF, using examples from the documentation
::method "test_DATATYPE"
    self~assertEquals("subTest1" , 'NUM'  , DATATYPE(' 12 ')     )
    self~assertEquals("subTest2" , 'CHAR' , DATATYPE("")         )
    self~assertEquals("subTest3" , 'CHAR' , DATATYPE('123*')     )

    self~assertTrue("subTest4"  , DATATYPE('12.3','N')  )
    self~assertFalse("subTest5" , DATATYPE('12.3','W')  )
    self~assertTrue("subTest6"  , DATATYPE('Fred','M')  )
    self~assertFalse("subTest7" , DATATYPE('Fred','U')  ) -- changed, syntax error in documentation !
    self~assertFalse("subTest8" , DATATYPE('Fred','L')  )
    self~assertTrue("subTest9"  , DATATYPE('?20K','s')  )
    self~assertTrue("subTest10" , DATATYPE('BCd3','X')  )
    self~assertTrue("subTest11" , DATATYPE('BC d3','X') )

   -- new tests
    self~assertTrue("subTest12" , DATATYPE('',     'X') )

    self~assertTrue("subTest13" , DATATYPE('BCd3' ,'A') ) -- alphanumeric
    self~assertFalse("subTest14", DATATYPE('BC-d3','A') )

    self~assertTrue("subTest15" , DATATYPE('a1'   ,'s') ) -- symbol
    self~assertTrue("subTest16" , DATATYPE('.a1'  ,'s') )
    self~assertTrue("subTest17" , DATATYPE('_'    ,'s') )
    self~assertTrue("subTest18" , DATATYPE('!'    ,'s') )
    self~assertTrue("subTest19" , DATATYPE('?'    ,'s') )
    self~assertTrue("subTest20" , DATATYPE('.'    ,'s') )
    self~assertTrue("subTest21" , DATATYPE('1'    ,'s') )
    self~assertTrue("subTest22" , DATATYPE('1b_!?','s') )
    self~assertFalse("subTest23", DATATYPE('. .'  ,'s') )

    self~assertTrue("subTest24" , DATATYPE('abc'  ,'v') ) -- variable
    self~assertTrue("subTest25" , DATATYPE('?'    ,'v') )
    self~assertTrue("subTest26" , DATATYPE('_'    ,'v') )
    self~assertTrue("subTest27" , DATATYPE('!'    ,'v') )
    self~assertTrue("subTest28" , DATATYPE('a1!_?','v') )
    self~assertFalse("subTest29", DATATYPE('.'    ,'v') )
    self~assertFalse("subTest30", DATATYPE('.a'   ,'v') )
    self~assertFalse("subTest31", DATATYPE('1'    ,'v') )


    a=digits()          -- get digits
    numeric digits 9
    self~assertTrue( "subTest32", DATATYPE('0'    ,'W')  ) -- whole number
    self~assertTrue( "subTest33", DATATYPE('1'    ,'W')  )
    self~assertTrue( "subTest34", DATATYPE('-1'   ,'W')  )
    self~assertTrue( "subTest35", DATATYPE('12345','W')  )
    self~assertTrue( "subTest36", DATATYPE('1E3'  ,'W')  )
    self~assertFalse("subTest37", DATATYPE('1E9'  ,'W')  )

    numeric digits a

    self~assertFalse("subTest44", DATATYPE('z'  ,'X')  )    -- heX-digits
    self~assertTrue( "subTest45", DATATYPE(''  ,'X')   )

    self~assertFalse("subTest46", DATATYPE('z'  ,'B')         )   -- binary digits
    self~assertTrue( "subTest47", DATATYPE(''  ,'B')          )
    self~assertTrue( "subTest48", DATATYPE('01'  ,'B')        )
    self~assertTrue( "subTest49", DATATYPE('01101001'  ,'B')  )
    self~assertTrue( "subTest50", DATATYPE('0110 1001'  ,'B') )
    self~assertFalse("subTest51", DATATYPE('011 01001'  ,'B') )

    numeric digits 9
    self~assertEquals("subTest52", 'NUM'   , DATATYPE(' 1e3       ')     )
    self~assertEquals("subTest53", 'NUM'   , DATATYPE(' 123456789 ')     )
    self~assertEquals("subTest54", 'NUM'   , DATATYPE(' 1234567891 ')    )
    self~assertEquals("subTest55", 'CHAR'  , DATATYPE("")                )
    self~assertEquals("subTest56", 'CHAR'  , DATATYPE("a")               )
    self~assertEquals("subTest57", 'CHAR'  , DATATYPE("abc")             )
    self~assertEquals("subTest58", 'CHAR'  , DATATYPE("1A0")             )

    self~assertTrue("subTest59" ,   DATATYPE("123456789012345", "N" )    ) -- Numeric
    self~assertTrue("subTest60" ,   DATATYPE("0"              , "N" )    ) -- Numeric
    self~assertTrue("subTest61" ,   DATATYPE("1234567890.1234", "N" )    ) -- Numeric
    self~assertFalse("subTest61" ,  DATATYPE(""               , "N" )    ) -- Numeric
    numeric digits a

    self~assertTrue("subtest62",    DATATYPE(0,  "O") )  -- Logical (Boolean)
    self~assertTrue("subtest63",    DATATYPE(1,  "O") )  -- Logical (Boolean)
    self~assertFalse("subtest64",   DATATYPE(2,  "O") )  -- Logical (Boolean)
    self~assertFalse("subtest65",   DATATYPE(-1, "O") )  -- Logical (Boolean)
    self~assertFalse("subtest66",   DATATYPE("", "O") )  -- Logical (Boolean)


   -- test the BIF, using examples from the documentation
::method "test_DATATYPE_WITH_OPTION_9"
    a=digits()          -- get digits

    numeric digits 1    -- make sure that numeric digits is not set to 9
    self~assertTrue( "subTest38", DATATYPE('0'    ,'9')  ) -- whole number under 9 digits (?)
    self~assertTrue( "subTest39", DATATYPE('1'    ,'9')  )
    self~assertTrue( "subTest40", DATATYPE('-1'   ,'9')  )
    self~assertTrue( "subTest41", DATATYPE('12345' ,'9')  ) -- ?
    self~assertTrue( "subTest42", DATATYPE('1E3'   ,'9')  ) -- ?
    self~assertFalse( "subTest43", DATATYPE('1E9'  ,'9')  ) -- ?
    numeric digits a

