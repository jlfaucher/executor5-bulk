#!/usr/bin/rexx
/*
  SVN Revision: $Rev: 3371 $
  Change Date:  $Date: 2008-09-21 00:33:29 -0400 (Sun, 21 Sep 2008) $
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2005-2010 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . fileSpec;

  group = .TestGroup~new(fileSpec)
  group~add(.text.testGroup)
  group~add(.comment.testGroup)
  group~add(.processinginstruction.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult
-- End of entry point.

::requires "ooTest.frm"     -- load the ooRexxUnit classes
::requires "xmldom.cls"

::class "characterdata.testGroup" subclass ooTestCase public
::method setup
  expose dom document
  dom = .ooRexxDOM~implementation
  document = dom~createDocument

::attribute dom
::attribute document
::attribute nodeName
::attribute nodeClass
::attribute nodeType

::method testBaseNode
  root = self~document~createElement("root")

  node = self~createNode("xyz")

  self~assertTrue(node~isa(self~nodeclass))
  self~assertEquals(self~nodeName, node~nodeName)
  self~assertNull(node~localName)
  self~assertEquals("xyz", node~data)
  self~assertEquals("xyz", node~nodeValue)
  self~assertEquals("xyz"~length, node~length)
  self~assertEquals(self~nodeType, node~nodetype)
  self~assertNull(node~parentNode)
  self~assertNull(node~nextSibling)
  self~assertNull(node~previousSibling)
  self~assertNull(node~firstChild)
  self~assertNull(node~lastChild)
  self~assertNull(node~attributes)
  self~assertNull(node~prefix)
  self~assertNull(node~namespaceURI)
  self~assertFalse(node~hasAttributes)
  self~assertFalse(node~hasChildNodes)

  self~assertEquals(0, node~childNodes~length)

  -- add this to the part
  root~appendChild(node)

  self~assertSame(root, node~parentNode)
  -- only text and cdata nodes affect the text content
  if node~nodeType == .Node~TEXT_NODE | node~nodeType == .Node~CDATA_SECTION_NODE then
      self~assertEquals("xyz", root~textContent)
  else self~assertEquals("", root~textContent)
  -- the text content does not change the element nodeValue
  self~assertEquals(.nil, root~nodeValue)

::method testCommonStringMethods

  node = self~createNode("xyz")
  -- appending
  node~appendData("abc")
  self~assertEquals("xyzabc", node~data)
  node~appendData("")
  self~assertEquals("xyzabc", node~data)

  -- deleting
  node~deleteData(0, 1)
  self~assertEquals("yzabc", node~data)
  node~deleteData(1, 2)
  self~assertEquals("ybc", node~data)
  node~deleteData(2, 10)
  self~assertEquals("yb", node~data)

  -- inserting
  node~insertData(0, "123")
  self~assertEquals("123yb", node~data)
  node~insertData(3, "")
  self~assertEquals("123yb", node~data)
  node~insertData(4, "456")
  self~assertEquals("123y456b", node~data)
  node~insertData(8, "789")
  self~assertEquals("123y456b789", node~data)

-- replacing
  node~replaceData(3, 1, "xxxx")
  self~assertEquals("123xxxx456b789", node~data)
  node~replaceData(0, 1, "")
  self~assertEquals("23xxxx456b789", node~data)
  node~replaceData(6, 20, "000")
  self~assertEquals("23xxxx000", node~data)

-- setting
  node~data = ""
  self~assertEquals("", node~data)
  self~assertEquals("", node~nodeValue)
  node~data = "abc"
  self~assertEquals("abc", node~data)
  self~assertEquals("abc", node~nodeValue)

-- substring
  self~assertEquals("ab", node~substringData(0, 2))
  self~assertEquals("", node~substringData(0, 0))
  -- NB uses Rexx padding rules
  self~assertEquals("abc ", node~substringData(0, 4))


::class "comment.testgroup" subclass characterdata.testgroup public
::method setup
  forward class(super) continue
  self~nodeName = "#comment"
  self~nodeClass = .Comment
  self~nodeType = .Node~COMMENT_NODE

::method createNode
  use arg text
  return self~document~createComment(text)

::class "processinginstruction.testgroup" subclass characterdata.testgroup public
::method setup
  forward class(super) continue
  self~nodeName = "TARGET"
  self~nodeClass = .ProcessingInstruction
  self~nodeType = .Node~PROCESSING_INSTRUCTION_NODE

::method createNode
  use arg text
  return self~document~createProcessingInstruction("TARGET", text)

::class "text.testgroup" subclass characterdata.testgroup public
::method setup
  forward class(super) continue
  self~nodeName = "#text"
  self~nodeClass = .Text
  self~nodeType = .Node~TEXT_NODE

::method createNode
  use arg text
  return self~document~createTextNode(text)

-- this method only applies to the Text node type
::method testSplitText

  -- a root element to ensure the split node gets added as a child
  root = self~document~createElement("root")
  node = self~createNode("1234567890")
  root~appendChild(node)

  self~assertEquals("67890", node~splitText(5)~data)
  self~assertEquals(2, root~length)
  self~assertEquals("12345", node~data)
  -- there should be a following sibling with the remainder of the data
  self~assertEquals("67890", node~nextSibling~data)

  root = self~document~createElement("root")
  node = self~createNode("1234567890")
  root~appendChild(node)

  -- split before the first character
  self~assertEquals("1234567890", node~splitText(0)~data)
  self~assertEquals("", node~data)
  self~assertEquals("1234567890", node~nextSibling~data)

  root = self~document~createElement("root")
  node = self~createNode("1234567890")
  root~appendChild(node)

  -- split after the last character
  self~assertEquals("", node~splitText(10)~data)
  self~assertEquals("1234567890", node~data)
  self~assertEquals("", node~nextSibling~data)


  -- this text node has no parent element...this should return an
  -- "orphan" node
  node = self~createNode("1234567890")

  newNode = node~splitText(5)
  self~assertEquals("67890", newNode~data)
  self~assertEquals("12345", node~data)
  self~assertNull(node~nextSibling)
  self~assertNull(node~previousSibling)
