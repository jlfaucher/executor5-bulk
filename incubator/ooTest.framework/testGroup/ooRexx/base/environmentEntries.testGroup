#!/usr/bin/rexx
/*
   name:             environmentEntries.testGroup
   author:           Rony G. Flatscher
   date:             2007-09-16
   version:          1.0.2

-- line commented lines are ignored, when building the directory of infos from this header
   changed:          2007-09-16, ---rgf, removed tests for Windows-specific classes (OLEObject,
                                         OLEVariant) as they are not available on all platforms,
                                         made test for .LINE a little bit more flexible to adapt
                                         to new line numbers, in case it gets shifted
                     2007-10-15  ---rgf, Fix some system dependent tests to be system independent.

   languageLevel:    6.02
   purpose:          Test the entries in .local and .environment
   remark:           ---

   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

   category1:        ooRexx
   category2:        Base
   category3:        environmentEntries
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/



-------------------------------------------------------------------------------------------
-- ===> adapt the "testGroupList" to your testCase classes; each element in the list is <===
-- ===> an array object, the first element containing the testCase class object, the   <===
-- ===> second element is a list of test method names which are regarded to be         <===
-- ===> mandatory (if the list remains empty all test methods are mandatory)           <===

   /* list of array objects, each containing the testGroup class object and an
      optional list of mandatory test case methods name                       */

mandatoryTestMethods=.list~new   -- no mandatory tests for this testCase class
testGroupList=.list~of( .array~of(.environmentEntries.testGroup,  mandatoryTestMethods) )

-------------------------------------------------------------------------------------------
-- ===> the following code needs not to be individualized                              <===

   -- read top comment, containing infos about this program
arrLines=.array~new
do i=1 to 150 until arrLines[i]="*/"
   arrLines[i]=sourceline(i)
end
      -- supply information for the testClass(es) in this file; the class attribute
      -- "TestCaseInfo" (a directory object, index points to a queue) will store
      -- the parsed infos
aTestGroupClass=testGroupList~at(testGroupList~first)[1] -- get first testClass

   -- will parse the array lines and store result in class object
call makeDirTestInfo aTestGroupClass, arrLines
tmpDir=aTestGroupClass~TestCaseInfo
parse source s   -- op_sys invocationType fullPathToThisFile
tmpDir~setentry("test_Case-source", s)

   -- now add this directory to other testCase classes, if any left
do arr over testGroupList
   if arr[1]=aTestGroupClass then iterate  -- already handled
   arr[1]~TestCaseInfo=tmpDir             -- save info in class object
end

-- if this file is CALLed or REQUIRED then define an entry "bRunTestLocally" in .local
-- and set it to .false; this way the independent local invocation of the tests is inhibited
if .local~hasentry("bRunTestsLocally")=.false then
   .local~bRunTestsLocally=.true -- if this file is executed directly, then run tests for debugging

if .bRunTestsLocally=.true then  -- run ALL tests in this test unit
do
   ts=.testSuite~new             -- create a testSuite
   do arr over testGroupList
      -- create a testSuite for the given test case class, use all its testmethods
      ts~addTest( .testSuite~new(arr[1]))
   end
   -- testResult=.testSuite~new(testGroupClass)~run
   testResult=ts~run       -- now run all the tests

   call simpleDumpTestResults testResult
end

   /* return list of array objects containing test case classes and
      optionally list of mandatory test methods                      */
return testGroupList



::requires 'ooTest.frm'     -- load the ooRexxUnit classes

::class "environmentEntries.testGroup" subclass ooTestCase public


   -- ATTENTION !  ATTENTION !  ATTENTION !  ATTENTION !  ATTENTION !
   -- ATTENTION !  ATTENTION !  ATTENTION !  ATTENTION !  ATTENTION !
   -- ATTENTION !  ATTENTION !  ATTENTION !  ATTENTION !  ATTENTION !
::method "test_line_entry"
     self~assertTrue("subTest # 1: is [.LINE] a wholeNumber?", .line~datatype("Whole"))

   -- ATTENTION !  ATTENTION !  ATTENTION !  ATTENTION !  ATTENTION !
   -- ATTENTION !  ATTENTION !  ATTENTION !  ATTENTION !  ATTENTION !

   tmpLine=141    -->  the following line *MUST* *BE* on line # tmpLine, otherwise the test fails !!
   self~assertSame("subTest '.LINE', this statement *MUST* start/be on line #" tmpLine "in the source code!", -
                    tmpLine, .LINE)
   -- ATTENTION !  ATTENTION !  ATTENTION !  ATTENTION !  ATTENTION !
   -- ATTENTION !  ATTENTION !  ATTENTION !  ATTENTION !  ATTENTION !


::method "test_local_directory_entries"
  entries= -
        "ERROR"                        -
        "INPUT"                        -
        "LOCALSERVER"                  -
        "OUTPUT"                       -
        "STDERR"                       -
        "STDIN"                        -
        "STDOUT"                       -
        "STDQUE"

  do i=1 to words(entries)
     w=word(entries,i)        -- extract word
     self~assertTrue("subTest" i "entry=["w"]", .local~hasEntry(w))
  end


::method "test_environment_directory_entries"
  entries= -
        "ALARM"                        -
        "ARRAY"                        -
        "BAG"                          -
        "CASELESSCOLUMNCOMPARATOR"     -
        "CASELESSCOMPARATOR"           -
        "CASELESSDESCENDINGCOMPARATOR" -
        "CIRCULARQUEUE"                -
        "CLASS"                        -
        "COLLECTION"                   -
        "COLUMNCOMPARATOR"             -
        "COMPARABLE"                   -
        "COMPARATOR"                   -
        "DATETIME"                     -
        "DESCENDINGCOMPARATOR"         -
        "DIRECTORY"                    -
        "ENDOFLINE"                    -
        "ENVIRONMENT"                  -
        "FALSE"                        -
        "INPUTOUTPUTSTREAM"            -
        "INPUTSTREAM"                  -
        "INVERTINGCOMPARATOR"          -
        "LIST"                         -
        "LOCAL"                        -
        "MAPCOLLECTION"                -
        "MESSAGE"                      -
        "METHOD"                       -
        "MONITOR"                      -
        "MUTABLEBUFFER"                -
        "NIL"                          -
        "OBJECT"                       -
        "ORDEREDCOLLECTION"            -
        "OUTPUTSTREAM"                 -
        "PROPERTIES"                   -
        "PUBLIC_ROUTINES"              -
        "QUEUE"                        -
        "RELATION"                     -
        "REXXQUEUE"                    -
        "SET"                          -
        "SETCOLLECTION"                -
        "STATIC_REQUIRES"              -
        "STEM"                         -
        "STREAM"                       -
        "STREAMSUPPLIER"               -
        "STRING"                       -
        "SUPPLIER"                     -
        "SYSTEM"                       -
        "TABLE"                        -
        "TIMESPAN"                     -
        "TRUE"

  do i=1 to words(entries)
     w=word(entries,i)        -- extract word
     self~assertTrue("subTest #" i "entry=["w"]", .environment~hasEntry(w))
  end

::method "test_environment_directory_class_object_entries"

  entries =                            -
        "ALARM"                        -
        "ARRAY"                        -
        "BAG"                          -
        "CASELESSCOLUMNCOMPARATOR"     -
        "CASELESSCOMPARATOR"           -
        "CASELESSDESCENDINGCOMPARATOR" -
        "CIRCULARQUEUE"                -
        "CLASS"                        -
        "COLLECTION"                   -
        "COLUMNCOMPARATOR"             -
        "COMPARABLE"                   -
        "COMPARATOR"                   -
        "DESCENDINGCOMPARATOR"         -
        "DIRECTORY"                    -
        "INPUTOUTPUTSTREAM"            -
        "INPUTSTREAM"                  -
        "INVERTINGCOMPARATOR"          -
        "LIST"                         -
        "MAPCOLLECTION"                -
        "MESSAGE"                      -
        "METHOD"                       -
        "MONITOR"                      -
        "MUTABLEBUFFER"                -
        "OBJECT"                       -
        "ORDEREDCOLLECTION"            -
        "OUTPUTSTREAM"                 -
        "PROPERTIES"                   -
        "QUEUE"                        -
        "RELATION"                     -
        "REXXQUEUE"                    -
        "SET"                          -
        "SETCOLLECTION"                -
        "STEM"                         -
        "STREAM"                       -
        "STREAMSUPPLIER"               -
        "STRING"                       -
        "SUPPLIER"                     -
        "TABLE"                        -

  if .ooRexxUnit.OSName="WINDOWS" then    -- add Windows-specific entries
  do
     entries=entries "OLEOBJECT OLEVARIANT"
  end

  do i=1 to words(entries)
     w=word(entries,i)        -- extract word
     self~assertTrue("subTest #" i "is entry=["w"] a class object?", .environment~Entry(w)~isA(.class))
  end

::method "test_error_monitor"
  self~assertTrue(".error~current=.stdErr", .error~current=.stdErr)

::method "test_input_monitor"
  self~assertTrue(".input~current=.stdIn", .input~current=.stdIn)

::method "test_output_monitor"
  self~assertTrue(".output~current=.stdOut", .output~current=.stdOut)


::method "test_local_monitor_objects"
  entries="ERROR INPUT OUTPUT"
  do i=1 to words(entries)
     w=word(entries,i)        -- extract word
     self~assertTrue("subTest #" i "is [."w"] a monitor object?", value("."w)~isA(.monitor))
  end

::method "test_local_stream_objects"
  entries="STDERR STDIN STDOUT"
  do i=1 to words(entries)
     w=word(entries,i)        -- extract word
     self~assertTrue("subTest #" i "is [."w"] a stream object?", value("."w)~isA(.stream))
  end

::method "test_stdqueue"
  self~assertTrue("subTest: .STDQUEUE~isA(.RexxQueue)", .STDQUE~isA(.RexxQueue))

::method "test_true"
  self~assertTrue(".true", .true)

::method "test_false"
  self~assertFalse(".false", .false)



::method "test_rs"

  self~assertEquals("subTest_01: .RS not set", ".RS", .RS)

   /* test command execution without error/failure */
  select
    when .ooRexxUnit.shellName~translate == "CMD" then do
      address cmd "exit"
      self~assertEquals("subTest_02: .RS=0", 0, .RS)
    end
    when .ooRexxUnit.shellName~translate == "BASH" then do
      address "bash" "exit"
      self~assertEquals("subTest_02: .RS=0", 0, .RS)
    end
    when .ooRexxUnit.shellName~translate == "CSH" then do
      address "csh" "exit"
      self~assertEquals("subTest_02: .RS=0", 0, .RS)
    end
    otherwise do
      -- Don't address to a specific environment.
      "exit"
      self~assertEquals("subTest_02: .RS=0", 0, .RS)
    end
  end
  -- End select

   /* test ERROR condition */
  signal on error name error_label
  self~expectCondition("ERROR")
  call error_proc
  self~fail("subTest_02: .RS not '0'")
  self~fail("subTest_02: ERROR condition not trapped by 'SIGNAL ON ERROR' !")
error_label:
  self~assertEquals("subTest_02: .RS=1 (command raised an ERROR condition)", 1, .RS)


   /* test FAILURE condition */
  signal on failure name failure_label
  call failure_proc
  self~fail("subTest_03: FAILURE condition not trapped by 'SIGNAL ON FAILURE' !")
failure_label:
  self~assertEquals("subTest_03: .RS=-1 (command raised an FAILURE condition)", -1, .RS)

  return

error_proc: procedure
  raise error 99

failure_proc: procedure
  raise failure 99

