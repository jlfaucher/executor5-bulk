#!/usr/bin/rexx
/*
   name:             RESULT_RC_SIGL.testGroup
   author:           Rony G. Flatscher
   date:             2005-10-22
   version:          1.0.1
   changed:          2007-01-24, --rgf, using "ooRexxUnit.getShellName()" for determining the
                                        shell to ADDRESS
                     2007-03-26, ---rgf, finally corrected the sequence of "expected" and "actual" value
                                         for assert[Not]Equals() and assert[Not]Same()

-- line commented lines are ignored, when building the directory of infos from this header

   languageLevel:    6.0
   purpose:          Test the setting of the Rexx variable named "RESULT", "RC" and "SIGL"
   remark:           ---


   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

   category1:        ooRexx
   category2:        Base

*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2005-2007 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . fileSpec

  lines = .array~new
  do i = 1 until lines[i] = "*/"
    lines[i] = sourceline(i)
  end

  group = .TestGroup~new(fileSpec, lines)
  group~add(.RESULT_RC_SIGL.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~run~~print

return testResult


::requires 'ooTest.frm'     -- load the ooRexxUnit classes

::class "RESULT_RC_SIGL.testGroup" subclass ooTestCase public

::method init
  expose fileName
  fileName="ooRexx.Base.RESULT.rex"         -- define temporary file name
  forward class (super)       -- a MUST: let superclass initialize, otherwise you'll get into troubles...

::method setUp             -- create external Rexx program for testing
  expose fileName
-- say "setUp..."

  s=.stream~new(fileName)~~open("replace")   -- create empty file
  s~~lineout("/*" date("S") time() ", ---rgf */")~~lineout
  s~~lineout("exit 234") ~~lineout          -- return value "234" (Linux restriction: 0-255)

  s~~lineout("::routine testExternalWithReturn public")
  s~~lineout("  return 'ReturnValue'") ~~lineout

  s~~lineout("::routine testExternalWithExit public")
  s~~lineout("  return 'ExitValue'") ~~lineout
  s~close




::method tearDown
  expose fileName
-- say "tearDown..."
  call sysFileDelete fileName -- delete file



::method "test_Result_with_Return"

      -- "rgfTestMethodWithReturn"
   drop result             -- make sure, variable is dropped
   self~assertSame("subTest1" , "ReturnValue",   self~rgfTestMethodWithReturn          )
   self~assertFalse("subTest2",  var("RESULT") ) -- must not be set !

      -- via a message object
   .message~new(self, "rgfTestMethodWithReturn")~send
   self~assertSame("subTest3" , "ReturnValue",   result                                )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest4",  var("RESULT") ) -- must not be set !

   .message~new(self, "rgfTestMethodWithReturn")~send
   self~assertTrue("subTest5",   var("RESULT") )  -- must be set !


      -- routine
   self~assertSame("subTest6" , "ReturnValue",   rgfTestRoutineWithReturn()           )
   self~assertFalse("subTest7",  var("RESULT") ) -- must not be set !

   call rgfTestRoutineWithReturn
   self~assertSame("subTest8" , "ReturnValue",   result                               )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest9",  var("RESULT") )  -- must not be set !

   call rgfTestRoutineWithReturn
   self~assertTrue("subTest10",  var("RESULT") )   -- must be set !


      -- function
   self~assertSame("subTest11" , "ReturnValue",  rgfTestProcedureWithReturn()         )
   self~assertFalse("subTest12", var("RESULT") ) -- must not be set !

   call rgfTestProcedureWithReturn
   self~assertSame("subTest13" , "ReturnValue",  result                               )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest14", var("RESULT") )  -- must not be set !

   call rgfTestProcedureWithReturn
   self~assertTrue("subTest15",  var("RESULT") )   -- must be set !

   exit

   rgfTestProcedureWithReturn:
      return "ReturnValue"


::method "test_Result_with_Exit"

      -- "rgfTestMethodWithExit"
   drop result             -- make sure, variable is dropped
   self~assertSame("subTest1" , "ExitValue",   self~rgfTestMethodWithExit          )
   self~assertFalse("subTest2",  var("RESULT") ) -- must not be set !

      -- via a message object
   .message~new(self, "rgfTestMethodWithExit")~send
   self~assertSame("subTest3" , "ExitValue",  result                              )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest4",  var("RESULT") ) -- must not be set !

   .message~new(self, "rgfTestMethodWithExit")~send
   self~assertTrue("subTest5",   var("RESULT") )  -- must be set !


      -- routine
   self~assertSame("subTest6" , "ExitValue",   rgfTestRoutineWithExit()           )
   self~assertFalse("subTest7",  var("RESULT") ) -- must not be set !

   call rgfTestRoutineWithExit
   self~assertSame("subTest8" , "ExitValue",   result                             )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest9",  var("RESULT") )  -- must not be set !

   call rgfTestRoutineWithExit
   self~assertTrue("subTest10",  var("RESULT") )   -- must be set !


::method "test_Result_with_Reply"

      -- "rgfTestMethodWithReply"
   drop result             -- make sure, variable is dropped
   self~assertSame("subTest1" , "ReplyValue",   self~rgfTestMethodWithReply          )
   self~assertFalse("subTest2",  var("RESULT") ) -- must not be set !

      -- via a message object
   .message~new(self, "rgfTestMethodWithReply")~send
   self~assertSame("subTest3" , "ReplyValue",  result                              )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest4",  var("RESULT") ) -- must not be set !

   .message~new(self, "rgfTestMethodWithReply")~send
   self~assertTrue("subTest5",   var("RESULT") )  -- must be set !


::method  rgfTestMethodWithReturn
   return "ReturnValue"


::method  rgfTestMethodWithExit
   exit   "ExitValue"


::method  rgfTestMethodWithReply
   reply  "ReplyValue"
   a=1


   -- call as a Rexx function, hence "result" will be set
::method "test_Result_with_Return_ExternalFile"
   expose fileName
   call (fileName)      -- call external program

   if var("RESULT") then tmpResult=result -- save value of "result"
   if var("RC")     then tmpRC    =rc     -- save value of "rc"

   self~assertTrue("subTest1", var("TMPRESULT"))
   self~assertFalse("subTest1b", var("TMPRC"))
   self~assertSame("subTest2", "234", tmpResult)  -- value of EXIT in external file

      -- routine
   self~assertSame("subTest5" , "ReturnValue",   testExternalWithReturn()           )
   self~assertFalse("subTest6",  var("RESULT") ) -- must not be set !

   call testExternalWithReturn
   self~assertSame("subTest7" , "ReturnValue",   result                               )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest8",  var("RESULT") )  -- must not be set !

   call testExternalWithReturn
   self~assertTrue("subTest9" ,  var("RESULT") )   -- must be set !


   -- call as a Rexx function, hence "result" will be set
::method "test_Result_with_Exit_ExternalFile"
   expose fileName
   call (fileName)      -- call external program

   if var("RESULT") then tmpResult=result -- save value of "result"
   if var("RC")     then tmpRC    =rc     -- save value of "rc"

   self~assertTrue("subTest1", var("TMPRESULT"))
   self~assertFalse("subTest1b", var("TMPRC"))
   self~assertSame("subTest2", "234", tmpResult)  -- value of EXIT in external file

      -- routine
   self~assertSame("subTest3", "ExitValue",   testExternalWithExit()           )
   self~assertFalse("subTest4",  var("RESULT") ) -- must not be set !

   call testExternalWithExit
   self~assertSame("subTest5", "ExitValue",   result                             )
      -- now that a function/method was invoked, Rexx dropped "RESULT"
   self~assertFalse("subTest6",  var("RESULT") )  -- must not be set !

   call testExternalWithExit
   self~assertTrue("subTest7",  var("RESULT") )   -- must be set !


   -- now address external Rexx program as a command, hence retrieving a "RC"-value
   -- instead of a "RESULT"
::method "test_Result_with_Exit_ADDRESSING_ExternalFile"
   expose fileName

   currentEnvironment=address()              -- save current environment
   address (ooRexxUnit.getShellName())       -- set environment to shell

   -- ADDRESS CMD "rexx" fileName
   "rexx" fileName

   if var("RESULT") then tmpResult=result -- save value of "result"
   if var("RC")     then tmpRC    =RC     -- save value of "result"

-- say "tmpresult="pp(tmpresult) var("tmpresult")
-- say "tmprc    ="pp(tmprc)     var("tmprc")

   address (currentEnvironment)              -- restore current environment

--say pp(var("TMPRESULT"))
   self~assertFalse("subTest1", var("TMPRESULT"))
   self~assertTrue("subTest2", var("TMPRC"))
   self~assertSame("subTest3", "234", tmpRC)  -- value of EXIT in external file


   -- check whether SIGL points to the correct lines
::method "test_SIGL"

      signal label_1

   label_1 :
      -- say "l1:" sigl pp(sourceline(sigl))
      self~assertEquals("subtest1", "signal label_1", sourceline(sigl))
      signal label_3

   label_2 :
      -- say "l2:" sigl pp(sourceline(sigl))
      self~assertEquals("subtest2", "signal label_2", sourceline(sigl))
      exit

   label_3 :
      -- say "l3:" sigl pp(sourceline(sigl))
      self~assertEquals("subtest3", "signal label_3", sourceline(sigl))
      signal label_2




----------------------- routines ----------------------

::routine rgfTestRoutineWithReturn
   return "ReturnValue"

::routine rgfTestRoutineWithExit
   exit   "ExitValue"




