#!/usr/bin/rexx
/*
   name:             String.testGroup
   author:           Rony G. Flatscher
   date:             2005-08-07
   version:          1.0.3

-- line commented lines are ignored, when building the directory of infos from this header
   changed:          2005-08-21, ---rgf, renamed the testGroup-class to match exactly the
                             file name, i.e. a dot (.) between class name and "testGroup";
                             added convention to return a list of arrays containing the
                             test case class object and an optional list of mandatory test
                             case methods from it
                     2005-10-20, ---rgf, completed the String's class method tests from the docs
                     2006-06-18, ---rgf, corrected a bug in TEST_DATATYPE, enquiting "-1" in
                             "subTest3"
                     2006-10-15, ---rgf, added "test_EnCodeBase64_DecodeBase64"
                     2006-10-21, ---rgf, added own (old) Rexx-implementation for
                                         en/de-coding base64 to test the C-implementation against
                     2007-03-21, ---rgf, added test for SUBCHAR (available with 6.01)
                                         changed sequence of expected/actual values to match the meaning
                                         in the failure message(s)
                     2007-06-10, ---rgf, added test cases for LOWER and UPPER
                     2007-06-23, ---rgf, added test case for 'caselessWordPos'
                     2007-07-10, ---rgf, changed names of test cases, added various caseless tests
                     2007-09-16, ---rgf, added tests for new 'count' argument in [caseless]changeStr()

   languageLevel:    6.02
   purpose:          Test the methods of the class String.
   remark:           Initial test unit for demonstration purposes, needs to be completed.

   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

// category needs not to be numbered, importance is given by position (1=most important)
   category:         ooRexx
   category:         Base
   category:         Class
   category:         String
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2005-2007 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/


-------------------------------------------------------------------------------------------
-- ===> adapt the "testGroupList" to your testCase classes; each element in the list is <===
-- ===> an array object, the first element containing the testCase class object, the   <===
-- ===> second element is a list of test method names which are regarded to be         <===
-- ===> mandatory (if the list remains empty all test methods are mandatory)           <===

   /* list of array objects, each containing the testGroup class object and an
      optional list of mandatory test case methods name                       */
mandatoryTestMethods=.list~new   -- no mandatory tests for this testCase class
testGroupList=.list~of( .array~of(.String.testGroup,  mandatoryTestMethods) )


-------------------------------------------------------------------------------------------
-- ===> the following code needs not to be individualized                              <===

   -- read top comment, containing infos about this program
arrLines=.array~new
do i=1 to 150 until arrLines[i]="*/"
   arrLines[i]=sourceline(i)
end
      -- supply information for the testClass(es) in this file; the class attribute
      -- "TestCaseInfo" (a directory object, index points to a queue) will store
      -- the parsed infos
aTestGroupClass=testGroupList~at(testGroupList~first)[1] -- get first testClass

   -- will parse the array lines and store result in class object
call makeDirTestInfo aTestGroupClass, arrLines
tmpDir=aTestGroupClass~TestCaseInfo
parse source s   -- op_sys invocationType fullPathToThisFile
tmpDir~setentry("test_Case-source", s)

   -- now add this directory to other testCase classes, if any left
do arr over testGroupList
   if arr[1]=aTestGroupClass then iterate  -- already handled
   arr[1]~TestCaseInfo=tmpDir             -- save info in class object
end

-- if this file is CALLed or REQUIRED then define an entry "bRunTestLocally" in .local
-- and set it to .false; this way the independent local invocation of the tests is inhibited
if .local~hasentry("bRunTestsLocally")=.false then
   .local~bRunTestsLocally=.true -- if this file is executed directly, then run tests for debugging

if .bRunTestsLocally=.true then  -- run ALL tests in this test unit
do
   ts=.testSuite~new             -- create a testSuite
   do arr over testGroupList
      -- create a testSuite for the given test case class, use all its testmethods
      ts~addTest( .testSuite~new(arr[1]))
   end
   -- testResult=.testSuite~new(testGroupClass)~run
   testResult=ts~run       -- now run all the tests

   call simpleDumpTestResults testResult
end

   /* return list of array objects containing test case classes and
      optionally list of mandatory test methods                      */
return testGroupList



::requires 'ooTest.frm'     -- load the ooRexxUnit classes

   -- class named exactly like file
::class "String.testGroup" subclass ooTestCase public


::method setup       -- add entries to .local
      /* define data needed for the Rexx implementation of encodeBase64 and decodeBase64  */
   .local~base64.padChar="="                    -- use equal sign as a pad char
   .local~base64.mimeTable= "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" ||,
                                 padChar        -- trailing space indicator

   .local~base64.base64  = xrange("00"x, "3F"x) -- all 64 possible 6-bits values


::method tearDown    -- remove entries from .local
   .local~remove("BASE64.PADCHAR")
   .local~remove("BASE64.MIMETABLE")
   .local~remove("BASE64.BASE64")


   -- test the BIF, using examples from the documentation
::method "test_NEW"
   self~assertSame("subTest1"   , .string~new("")   , ""  )
   self~assertSame("subTest2"   , .string~new(" ")  , " " )
   self~assertSame("subTest3"   , .string~new("  ") , "  ")
   self~assertSame("subTest4"   , .string~new("ab") , "ab")

   self~assertEquals("subTest5" , .string~new("")   , ""  )
   self~assertEquals("subTest6" , .string~new(" ")  , " " )
   self~assertEquals("subTest7" , .string~new("  ") , "  ")
   self~assertEquals("subTest8" , .string~new("ab") , "ab")


::method "test_arithmetic_operators"

   self~assertEquals("subTest1" , 10 , 5+5  )
   self~assertEquals("subTest2" , 3  , 8-5  )
   self~assertEquals("subTest3" , 10 , 5*2  )
   self~assertEquals("subTest4" , 3  , 6/2  )
   self~assertEquals("subTest5" , 1  , 9//4 )
   self~assertEquals("subTest6" , 2  , 9%4  )
   self~assertEquals("subTest7" , 8  , 2**3 )
   self~assertEquals("subTest8" , 5  , +5   ) /* Prefix + */
   self~assertEquals("subTest9" , -5 , -5   ) /* Prefix - */

   self~assertEquals("subTest11" , 10 , 5~'+'(5)  )
   self~assertEquals("subTest12" , 3  , 8~'-'(5)  )
   self~assertEquals("subTest13" , 10 , 5~'*'(2)  )
   self~assertEquals("subTest14" , 3  , 6~'/'(2)  )
   self~assertEquals("subTest15" , 1  , 9~'//'(4) )
   self~assertEquals("subTest16" , 2  , 9~'%'(4)  )
   self~assertEquals("subTest17" , 8  , 2~'**'(3) )
   self~assertEquals("subTest18" , 5  , 5~'+'     ) /* Prefix + */
   self~assertEquals("subTest19" , -5 , 5~'-'     ) /* Prefix - */



::method "test_comparison_operators"

   self~assertTrue( "subTest1"  , 5=5    ) /* equal */
   self~assertTrue( "subTest2"  , 42\=41 ) /* All of these are */
   self~assertTrue( "subTest3"  , 42><41 ) /* "not equal" */
   self~assertTrue( "subTest4"  , 42<>41 )
   self~assertTrue( "subTest5"  , 13>12  ) /* Variations of */
   self~assertTrue( "subTest6"  , 12<13  ) /* less than and */
   self~assertTrue( "subTest7"  , 13>=12 ) /* greater than */
   self~assertFalse("subTest8"  , 12\<13 )
   self~assertTrue( "subTest9"  , 12<=13 )
   self~assertTrue( "subTest10" , 12\>13 )

   self~assertTrue( "subTest11" , 5~'='(5)    ) /* equal */
   self~assertTrue( "subTest12" , 42~'\='(41) ) /* All of these are */
   self~assertTrue( "subTest13" , 42~'><'(41) ) /* "not equal" */
   self~assertTrue( "subTest14" , 42~'<>'(41) )
   self~assertTrue( "subTest15" , 13~'>'(12)  ) /* Variations of */
   self~assertTrue( "subTest16" , 12~'<'(13)  ) /* less than and */
   self~assertTrue( "subTest17" , 13~'>='(12) ) /* greater than */
   self~assertFalse("subTest18" , 12~'\<'(13) )
   self~assertTrue( "subTest19" , 12~'<='(13) )
   self~assertTrue( "subTest20" , 12~'\>'(13) )

   -- identical
   self~assertTrue( "subTest21"  , 'space'  ==  'space'  )  /* Strictly equal */
   self~assertTrue( "subTest22"  , 'space'  \== ' space' )  /* Strictly not equal */
   self~assertTrue( "subTest23"  , 'space'  >>  ' space' )  /* Variations of */
   self~assertTrue( "subTest24"  , ' space' <<  'space'  )  /* strictly greater */
   self~assertTrue( "subTest25"  , 'space'  >>= ' space' )  /* than and less than */
   self~assertTrue( "subTest26"  , 'space'  \<< ' space' )
   self~assertTrue( "subTest27"  , ' space' <<= 'space'  )
   self~assertTrue( "subTest28"  , ' space' \>> 'space'  )

   self~assertTrue( "subTest29"  , 'space'~'=='('space')   )  /* Strictly equal */
   self~assertTrue( "subTest30"  , 'space'~'\=='(' space') )  /* Strictly not equal */
   self~assertTrue( "subTest31"  , 'space'~'>>'(' space')  )  /* Variations of */
   self~assertTrue( "subTest32"  , ' space'~'<<'('space')  )  /* strictly greater */
   self~assertTrue( "subTest33"  , 'space'~'>>='(' space') )  /* than and less than */
   self~assertTrue( "subTest34"  , 'space'~'\<<'(' space') )
   self~assertTrue( "subTest35"  , ' space'~'<<='('space') )
   self~assertTrue( "subTest36"  , ' space'~'\>>'('space') )


::method "test_logical_operators"

   self~assertFalse( "subTest1"  , 0&0   )
   self~assertFalse( "subTest2"  , 1&0   )
   self~assertFalse( "subTest3"  , 0&1   )
   self~assertTrue(  "subTest4"  , 1&1   )
   self~assertFalse( "subTest5"  , 0&1&0 )
   self~assertTrue(  "subTest6"  , 1&1&1 )
   self~assertFalse( "subTest7"  , 0|0   )
   self~assertTrue(  "subTest8"  , 1|0   )
   self~assertTrue(  "subTest9"  , 0|1   )
   self~assertTrue(  "subTest10" , 0|1|0 )
   self~assertTrue(  "subTest11" , 1|0|1 )
   self~assertTrue(  "subTest12" , 1&&0  )
   self~assertTrue(  "subTest13" , 0&&1  )
   self~assertFalse( "subTest14" , 1&&1  )
   self~assertFalse( "subTest15" , 0&&0  )
   self~assertFalse( "subTest16" , \1    )
   self~assertTrue(  "subTest17" , \0    )



::method "test_concatenation_operators"

   num=33
   self~assertSame("subTest1" , "33%"              , num"%"                           ) /* abuttal */
   self~assertSame("subTest2" , "33%"              , num~""('%')                      )
   self~assertSame("subTest3" , "ooRexx"           , "ooR"||"exx"                     ) /* || */
   self~assertSame("subTest4" , "ooRexx"           , "ooR"~'||'("exx")                ) /* || */
   self~assertSame("subTest5" , "Open Object Rexx" , 'Open'  'Object' 'Rexx'          ) /* blank */
   self~assertSame("subTest6" , "Open Object Rexx" , ('Open'  'Object')  ~' '('Rexx') )
   self~assertSame("subTest7" , "Open Object Rexx" , 'Open'~' '('Object')~' '('Rexx') )







   -- test the BIF, using examples from the documentation
::method "test_ABBREV"

   self~assertTrue(  "subTest1", 'Print'~ABBREV("Pri")    )

   self~assertFalse( "subTest2", "PRINT"~ABBREV("Pri")    )
   self~assertFalse( "subTest3", "PRINT"~ABBREV("PRI", 4) )
   self~assertFalse( "subTest4", "PRINT"~ABBREV("PRY")    )
   self~assertTrue(  "subTest5", "PRINT"~ABBREV("")       )
   self~assertFalse( "subTest6", "PRINT"~ABBREV("", 1)    )


   -- test the BIF, using examples from the documentation
::method "test_ABBREV_caseless"

   self~assertTrue(  "subTest1", 'Print'~caselessABBREV("Pri")    )

   self~assertTrue(  "subTest2", "PRINT"~caselessABBREV("Pri")    )
   self~assertFalse( "subTest3", "PRINT"~caselessABBREV("PRI", 4) )
   self~assertFalse( "subTest4", "PRINT"~caselessABBREV("PRY")    )
   self~assertTrue(  "subTest5", "PRINT"~caselessABBREV("")       )
   self~assertFalse( "subTest6", "PRINT"~caselessABBREV("", 1)    )


   -- test the BIF, using examples from the documentation
::method "test_ABS"

   self~assertEquals("subTest1" , 12.3  ,  12.3~ABS     )
   self~assertEquals("subTest1b", 12.3  ,'12.3'~ABS     )
   self~assertEquals("subTest2" , 0.307 , ' -0.307'~ABS )

      -- new tests
   self~assertEquals("subTest03", 0 ,  ' -0'~ABS   )
   self~assertEquals("subTest04", 0 ,  ' +0'~ABS   )
   self~assertEquals("subTest05", 0 ,  ' - 0 '~ABS )
   self~assertEquals("subTest06", 0 ,  ' + 0 '~ABS )
   self~assertEquals("subTest07", 1 ,  ' -1'~ABS   )
   self~assertEquals("subTest08", 1 ,  ' +1'~ABS   )
   self~assertEquals("subTest09", 1 ,  ' - 1 '~ABS )
   self~assertEquals("subTest10", 1 ,  ' + 1 '~ABS )


   -- test the BIF, using examples from the documentation
::method "test_B2X"

   self~assertSame("subTest1" , 'C3'  , '11000011'~B2X    )
   self~assertSame("subTest2" , '17'  , '10111'~B2X       )
   self~assertSame("subTest3" , '5'   , '101'~B2X         )
   self~assertSame("subTest4" , '1F0' , '1 1111 0000'~B2X )
   self~assertSame("subTest5" , '23'  , '10111'~B2X~X2D   ) /* decimal 23 */


   -- test the BIF, using examples from the documentation
::method "test_BITAND"

   self~assertSame("subTest1" , '12'x   , '12'x~BITAND                 )
   self~assertSame("subTest2" , '23'x   , '73'x~BITAND('27'x)          )
   self~assertSame("subTest3" , '1155'x , '13'x~BITAND('5555'x)        )
   self~assertSame("subTest4" , '1154'x , '13'x~BITAND('5555'x,'74'x)  )
   self~assertSame("subTest5" , 'PQRS'  , 'pQrS'~BITAND(,'DF'x)        )  /* ASCII */


   -- test the BIF, using examples from the documentation
::method "test_BITOR"

   self~assertSame("subTest1" , '12'x   , '12'x~BITOR                )
   self~assertSame("subTest2" , '35'x   , '15'x~BITOR('24'x)         )
   self~assertSame("subTest3" , '3556'x , '15'x~BITOR('2456'x)       )
   self~assertSame("subTest4" , '35F6'x , '15'x~BITOR('2456'x,'F0'x) )
   self~assertSame("subTest5" , '5D5D'x , '1111'x~BITOR(,'4D'x)      )
   self~assertSame("subTest6" , 'pqrs'  , 'pQrS'~BITOR(,'20'x)       ) /* ASCII */


   -- test the BIF, using examples from the documentation
::method "test_BITXOR"

   self~assertSame("subTest1" , '12'x     , '12'x~BITXOR                     )
   self~assertSame("subTest2" , '30'x     , '12'x~BITXOR('22'x)              )
   self~assertSame("subTest3" , '3011'x   , '1211'x~BITXOR('22'x)            )
   self~assertSame("subTest4" , '555544'x , '1111'x~BITXOR('444444'x)        )
   self~assertSame("subTest5" , '555504'x , '1111'x~BITXOR('444444'x,'40'x)  )
   self~assertSame("subTest6" , '5C5C'x   , '1111'x~BITXOR(,'4D'x)           )
   self~assertSame("subTest7" , 'E53302'x , 'C711'x~BITXOR('222222'x,' ')    ) /* ASCII */



   -- test the BIF, using examples from the documentation
::method "test_C2D"

   self~assertEquals("subTest1" , 9     , '09'X~C2D      )
   self~assertEquals("subTest2" , 129   , '81'X~C2D      )
   self~assertEquals("subTest3" , 65409 , 'FF81'X~C2D    )
   self~assertEquals("subTest4" , 0     , ""~C2D         )
   self~assertEquals("subTest5" , 97    , 'a'~C2D        ) /* ASCII */

   self~assertEquals("subTest6" , -127  , '81'X~C2D(1)   )     -- -- --
   self~assertEquals("subTest7" , 129   , '81'X~C2D(2)   )
   self~assertEquals("subTest8" , -127  , 'FF81'X~C2D(2) )
   self~assertEquals("subTest9" , -127  , 'FF81'X~C2D(1) )
   self~assertEquals("subTest10", 127   , 'FF7F'X~C2D(1) )
   self~assertEquals("subTest11", -3967 , 'F081'X~C2D(2) )
   self~assertEquals("subTest12", -127  , 'F081'X~C2D(1) )
   self~assertEquals("subTest13", 0     , '0031'X~C2D(0) )



   -- test the BIF, using examples from the documentation
::method "test_C2X"

   self~assertEquals("subTest1" , '0123'  , '0123'X~C2X  ) /* '30313233'X in ASCII */
   self~assertEquals("subTest2" , '5A4438', 'ZD8'~C2X    ) /* '354134343338'X in ASCII */



   -- test the BIF, using examples from the documentation
::method "test_CENTER"

   self~assertSame("subTest1" , '  ABC  '  , abc~CENTER(7)             )
   self~assertSame("subTest2" , '--ABC---' , abc~CENTER(8,'-')         )
   self~assertSame("subTest3" , 'e blue s' , 'The blue sky'~CENTRE(8)  )
   self~assertSame("subTest4" , 'e blue '  , 'The blue sky'~CENTRE(7)  )


   -- test the BIF, using examples from the documentation
::method "test_CHANGESTR"

   self~assertSame("subTest1" , '000'    , 101100~CHANGESTR('1',"")  )
   self~assertSame("subTest2" , 'X0XX00' , 101100~CHANGESTR('1','X') )

   -- new tests
    self~assertSame("subTest3", '101100' , '101100'~changestr('','X')  )
    self~assertSame("subTest4", ''       , ''~changestr('1','X')  )

   -- new tests: optional, trailing "count" argument
    self~assertSame("subTest5", 'ha-lo' , 'hallo'~changeStr('l','-',1)  )
    self~assertSame("subTest6", 'ha--o' , 'hallo'~changeStr('l','-',2)  )
    self~assertSame("subTest7", 'ha--o' , 'hallo'~changestr('l','-',3)  )

::method "test_changeStr_error_93.907"
    self~expectSyntax(93.907)
    'aha'~changeStr('a','A',0)



::method "test_ChangeStr_caseless"

   self~assertSame("subTest1" , 'aABBcC' , "aAbBcC"~caselessChangeStr('b',"B")  )
   self~assertSame("subTest2" , 'aAbbcC' , "aAbBcC"~caselessChangeStr('B',"b")  )
   self~assertSame("subTest3" , 'aA99cC' , "aAbBcC"~caselessChangeStr('B',"9")  )

   -- new tests: optional, trailing "count" argument
    self~assertSame("subTest4a", 'ha-lo' , 'hallo'~caselessChangeStr('L','-',1)  )
    self~assertSame("subTest4b", 'ha-lo' , 'haLlo'~caselessChangeStr('L','-',1)  )
    self~assertSame("subTest4c", 'ha-Lo' , 'haLLo'~caselessChangeStr('L','-',1)  )
    self~assertSame("subTest4d", 'ha-lo' , 'haLlo'~caselessChangeStr('l','-',1)  )
    self~assertSame("subTest4e", 'ha-Lo' , 'haLLo'~caselessChangeStr('l','-',1)  )

    self~assertSame("subTest5a", 'ha--o' , 'hallo'~caselessChangeStr('l','-',2)  )
    self~assertSame("subTest5b", 'ha--o' , 'haLlo'~caselessChangeStr('L','-',2)  )
    self~assertSame("subTest5c", 'ha--o' , 'haLLo'~caselessChangeStr('L','-',2)  )
    self~assertSame("subTest5d", 'ha--o' , 'haLlo'~caselessChangeStr('l','-',2)  )
    self~assertSame("subTest5e", 'ha--o' , 'haLLo'~caselessChangeStr('l','-',2)  )

    self~assertSame("subTest6a", 'ha--o' , 'hallo'~caselessChangestr('l','-',3)  )
    self~assertSame("subTest6b", 'ha--o' , 'haLlo'~caselessChangeStr('L','-',3)  )
    self~assertSame("subTest6c", 'ha--o' , 'haLLo'~caselessChangeStr('L','-',3)  )
    self~assertSame("subTest6d", 'ha--o' , 'haLlo'~caselessChangeStr('l','-',3)  )
    self~assertSame("subTest6e", 'ha--o' , 'haLLo'~caselessChangeStr('l','-',3)  )

::method "test_changeStr_caseless_error_93.907"
    self~expectSyntax(93.907)
    'aha'~caselessChangeStr('a','A',0)



   -- test the BIF, using examples from the documentation
::method "test_COMPARE"

   self~assertEquals("subTest1" , 0 , 'abc'  ~COMPARE('abc')    )
   self~assertEquals("subTest2" , 2 , 'abc'  ~COMPARE('ak')     )
   self~assertEquals("subTest3" , 0 , 'ab '  ~COMPARE('ab')     )
   self~assertEquals("subTest4" , 0 , 'ab '  ~COMPARE('ab',' ') )
   self~assertEquals("subTest5" , 3 , 'ab '  ~COMPARE('ab','x') )
   self~assertEquals("subTest6" , 5 , 'ab-- '~COMPARE('ab','-') )

::method "test_COMPARE_caseless"

   self~assertEquals("subTest1" , 0 , 'abc'  ~caselessCompare('aBc')    )
   self~assertEquals("subTest2" , 2 , 'abc'  ~caselessCompare('Ak')     )
   self~assertEquals("subTest3" , 0 , 'ab '  ~caselessCompare('AB')     )
   self~assertEquals("subTest4" , 0 , 'ab '  ~caselessCompare('aB',' ') )
   self~assertEquals("subTest5" , 3 , 'ab '  ~caselessCompare('Ab','x') )
   self~assertEquals("subTest6" , 5 , 'ab-- '~caselessCompare('AB','-') )


::method "test_compareTo"  -- 3.2

  self~assertEquals("subtest_01", -1, "a"~compareTo("b"))
  self~assertEquals("subtest_02",  0, "a"~compareTo("a"))
  self~assertEquals("subtest_03",  1, "b"~compareTo("a"))


::method "test_CompareTo_caseless"  -- 3.2

  self~assertEquals("subtest_01", -1, "a"~caselessCompareTo("B"))
  self~assertEquals("subtest_02",  0, "a"~caselessCompareTo("A"))
  self~assertEquals("subtest_03",  1, "b"~caselessCompareTo("A"))

  self~assertEquals("subtest_04", -1, "A"~caselessCompareTo("b"))
  self~assertEquals("subtest_05",  0, "A"~caselessCompareTo("a"))
  self~assertEquals("subtest_06",  1, "B"~caselessCompareTo("a"))


   -- test the BIF, using examples from the documentation
::method "test_COPIES"

   self~assertSame("subTest1" , 'abcabcabc' , 'abc'~COPIES(3) )
   self~assertSame("subTest2" , ""          , 'abc'~COPIES(0) )


   -- test the BIF, using examples from the documentation
::method "test_COUNTSTR"

   self~assertEquals("subTest1" , 4 , '101101'~COUNTSTR('1')  )
   self~assertEquals("subTest2" , 1 , 'J0KKK0'~COUNTSTR('KK') )

   -- test the BIF, using examples from the documentation
::method "test_COUNTSTR_caseless"

   self~assertEquals("subTest1" , 1 , 'J0kKk0'~caselessCountStr('KK') )
   self~assertEquals("subTest2" , 2 , 'J0kKkK0'~caselessCountStr('KK') )
   self~assertEquals("subTest3" , 2 , 'J0kKkK0'~caselessCountStr('kK') )
   self~assertEquals("subTest4" , 2 , 'J0kKkK0'~caselessCountStr('Kk') )
   self~assertEquals("subTest5" , 2 , 'J0kKkK0'~caselessCountStr('kk') )


   -- test the BIF, using examples from the documentation
::method "test_D2C"

   self~assertSame("subTest1" , 'A'            , '65'~D2C       ) /* '41'x is an ASCII 'A' */
   self~assertSame("subTest2" , 'A'            , '65'~D2C(1)    )
   self~assertSame("subTest3" , '00'x'A'       , '65'~D2C(2)    )
   self~assertSame("subTest4" , '00000000'x'A' , '65'~D2C(5)    )
   self~assertSame("subTest5" , 'm'            , '109'~D2C      ) /* '6D'x is an ASCII 'm' */
   self~assertSame("subTest6" , '93'x          , '-109'~D2C(1)  ) -- 'ô'   ) /* '93'x is an ASCII 'ô' */
   self~assertSame("subTest7" , '00'x'L'       , '76'~D2C(2)    ) /* '4C'x is an ASCII ' L' */
   self~assertSame("subTest8" , 'ff'x'L'       , '-180'~D2C(2)  )


   -- test the BIF, using examples from the documentation
::method "test_D2X"

   self~assertSame("subTest1" , '9'    , '9'~D2X        )
   self~assertSame("subTest2" , '81'   , '129'~D2X      )
   self~assertSame("subTest3" , '1'    , '129'~D2X(1)   )
   self~assertSame("subTest4" , '81'   , '129'~D2X(2)   )
   self~assertSame("subTest5" , '0081' , '129'~D2X(4)   )
   self~assertSame("subTest6" , '01'   , '257'~D2X(2)   )
   self~assertSame("subTest7" , '81'   , '-127'~D2X(2)  )
   self~assertSame("subTest8" , 'FF81' , '-127'~D2X(4)  )
   self~assertSame("subTest9" , ""     , '12'~D2X(0)    )



   -- test the BIF, using examples from the documentation
::method "test_DATATYPE"

-- p.210

   self~assertEquals("subTest1" , 'NUM' , ' 12 '~DATATYPE       )
   self~assertEquals("subTest2" , 'CHAR', ''~DATATYPE           )    -- error!
   self~assertEquals("subTest3" , 'CHAR', '123*'~DATATYPE       )
   self~assertTrue( "subTest4"  , '12.3'~DATATYPE('N')          )
   self~assertFalse("subTest5"  , '12.3'~DATATYPE('W')          )
   self~assertTrue( "subTest6"  , 'Fred'~DATATYPE('M')          )
   self~assertFalse("subTest7"  , 'Fred'~DATATYPE('U')          )    -- error! option changed
   self~assertFalse("subTest8"  , 'Fred'~DATATYPE('L')          )
   self~assertTrue( "subTest9"  , '?20K'~DATATYPE('s')          )
   self~assertTrue( "subTest10" , 'BCd3'~DATATYPE('X')          )
   self~assertTrue( "subTest11" , 'BC d3'~DATATYPE('X')         )


::method "test_DATATYPE_9"

   numeric digits 1
   self~assertTrue( "subTest1" , '0'~DATATYPE('9')           )
   self~assertTrue( "subTest2" , 1~DATATYPE('9')           )
   self~assertTrue( "subTest3" , "-1"~DATATYPE('9')           )
   self~assertTrue( "subTest4" , '12'~DATATYPE('9')           )
   self~assertTrue( "subTest5" , '-12'~DATATYPE('9')           )


   -- test the BIF, using examples from the documentation
::method "test_DELSTR"

   self~assertSame("subTest1" , 'ab'    , 'abcd'~DELSTR(3)    )
   self~assertSame("subTest2" , 'abe'   , 'abcde'~DELSTR(3,2) )
   self~assertSame("subTest3" , 'abcde' , 'abcde'~DELSTR(6)   )


   -- test the BIF, using examples from the documentation
::method "test_DELWORD"

   self~assertSame("subTest1" , 'Now time'         , 'Now is the  time'~DELWORD(2,2)  )
   self~assertSame("subTest2" , 'Now is '          , 'Now is the time '~DELWORD(3)    )
   self~assertSame("subTest3" , 'Now is the  time' , 'Now is the  time'~DELWORD(5)    )
   self~assertSame("subTest4" , 'Now is   time'    , 'Now is   the time'~DELWORD(3,1) )


::method "test_Equals"

    self~assertSame("subTest_01" , 1, "a"~equals("a"))
    self~assertSame("subTest_02" , 0, "a"~equals("A"))
    self~assertSame("subTest_03" , 0, "a"~equals("b"))
    self~assertSame("subTest_04" , 0, "a"~equals("B"))
    self~assertSame("subTest_05" , 1, "b"~equals("b"))
    self~assertSame("subTest_06" , 0, "b"~equals("B"))
    self~assertSame("subTest_07" , 0, "b"~equals("a"))
    self~assertSame("subTest_08" , 0, "b"~equals("A"))


::method "test_Equals_caseless"

    self~assertSame("subTest_01" , 1, "a"~caselessEquals("a"))
    self~assertSame("subTest_02" , 1, "a"~caselessEquals("A"))
    self~assertSame("subTest_03" , 0, "a"~caselessEquals("b"))
    self~assertSame("subTest_04" , 0, "a"~caselessEquals("B"))
    self~assertSame("subTest_05" , 1, "b"~caselessEquals("b"))
    self~assertSame("subTest_06" , 1, "b"~caselessEquals("B"))
    self~assertSame("subTest_07" , 0, "b"~caselessEquals("a"))
    self~assertSame("subTest_08" , 0, "b"~caselessEquals("A"))



   -- test the BIF, using examples from the documentation
::method "test_FORMAT"

   self~assertSame("subTest1" , '   3'             , '3'~FORMAT(4)               )
   self~assertSame("subTest2" , '   2'             , '1.73'~FORMAT(4,0)          )
   self~assertSame("subTest3" , '   1.730'         , '1.73'~FORMAT(4,3)          )
   self~assertSame("subTest4" , '  -0.8'           , '-.76'~FORMAT(4,1)          )
   self~assertSame("subTest5" , '   3.03'          , '3.03'~FORMAT(4)            )
   self~assertSame("subTest6" , '-12.7300'         , ' - 12.73'~FORMAT(,4)       )
   self~assertSame("subTest7" , '-12.73'           , ' - 12.73'~FORMAT           )
   self~assertSame("subTest8" , '0'                , '0.000'~FORMAT              )
   self~assertSame("subTest9" , '1.234573E+04'     , '12345.73'~FORMAT(, ,2,2)   )   --
   self~assertSame("subTest10", '1.235E+4'         , '12345.73'~FORMAT(,3, ,0)   )
   self~assertSame("subTest11", '1.235'            , '1.234573'~FORMAT(,3, ,0)   )
   self~assertSame("subTest12", '12345.73'         , '12345.73'~FORMAT(, ,3,6)   )
   self~assertSame("subTest13", '123456700000.000' , '1234567e5'~FORMAT(,3,0)    )


   -- test the BIF, using examples from the documentation
::method "test_INSERT"

   self~assertSame("subTest1" , '123abc'      , 'abc'~INSERT('123')          )
   self~assertSame("subTest2" , 'abc def'     , 'abcdef'~INSERT(' ',3)       )
   self~assertSame("subTest3" , 'abc  123   ' , 'abc'~INSERT('123',5,6)      )
   self~assertSame("subTest4" , 'abc++123+++' , 'abc'~INSERT('123',5,6,'+')  )
   self~assertSame("subTest5" , '123--abc'    , 'abc'~INSERT('123', ,5,'-')  )


   -- test the BIF, using examples from the documentation
::method "test_LASTPOS"

   self~assertEquals("subTest1" , 8 , 'abc def ghi'~LASTPOS(' ')   )
   self~assertEquals("subTest2" , 0 , 'abcdefghi'~LASTPOS(' ')     )
   self~assertEquals("subTest3" , 4 , 'efgxyz'~LASTPOS('xy')       )
   self~assertEquals("subTest4" , 4 , 'abc def ghi'~LASTPOS(' ',7) )


   -- test the BIF, using examples from the documentation
::method "test_LastPos_caseless"

   self~assertEquals("subTest1" , 4 , 'efgxyz'~caselessLastPos('xy')       )
   self~assertEquals("subTest2" , 4 , 'efgxyz'~caselessLastPos('XY')       )
   self~assertEquals("subTest3" , 4 , 'efgxyz'~caselessLastPos('Xy')       )
   self~assertEquals("subTest4" , 4 , 'efgxyz'~caselessLastPos('xY')       )


   -- test the BIF, using examples from the documentation
::method "test_LEFT"

   self~assertSame("subTest1" , 'abc d   ' , 'abc d'~LEFT(8)      )
   self~assertSame("subTest2" , 'abc d...' , 'abc d'~LEFT(8,'.')  )
   self~assertSame("subTest3" , 'abc  de'  , 'abc  def'~LEFT(7)   )


   -- test the BIF, using examples from the documentation
::method "test_LENGTH"

   self~assertEquals("subTest1" , 8 , 'abcdefgh'~LENGTH )
   self~assertEquals("subTest2" , 8 , 'abc defg'~LENGTH )
   self~assertEquals("subTest3" , 0 , ""~LENGTH         )


::method "test_LOWER"

    str='ABCdeFGH'
    self~assertSame("subTest_01" , 'AbCdeFGH', str~lower(2,  1 ))
    self~assertSame("subTest_02" , 'ABCdeFGH', str~lower(1,  0 ))
    self~assertSame("subTest_03" , 'ABCdeFGH', str~lower(99, 2 ))
    self~assertSame("subTest_04" , 'Abcdefgh', str~lower(2     ))
    self~assertSame("subTest_05" , 'abcdefgh', str~lower        )


   -- test the BIF, using examples from the documentation
::method "test_MAKEARRAY"

   nl = '0d0a'x
   string = "hello"nl"world"nl"this is an array."
   array = string~makearray
   -- say "the second line is:" array[2]
   self~assertSame("subTest1", "world", array[2])

   string = "hello*world*this is an array."
   array = string~makearray('*')
   -- say "the third line is:" array[3]
   self~assertSame("subTest2", "this is an array.", array[3])


   -- test the BIF, using examples from the documentation
::method "test_MAKESTRING"

   self~assertSame("subTest1" , ''     , ''~MAKESTRING        )
   self~assertSame("subTest2" , ' '    , ' '~MAKESTRING       )
   self~assertSame("subTest3" , 'ab'   , 'ab'~MAKESTRING      )
   self~assertSame("subTest3" , ' ab ' , ' ab '~MAKESTRING    )



::method "test_Match"

    str="abcDEFghi"
    self~assertSame("subTest_01" , 1, str~match(2, "bc"))
    self~assertSame("subTest_02",  1, str~match(2, "bcD"))
    self~assertSame("subTest_03" , 0, str~match(2, "bcd"))
    self~assertSame("subTest_04" , 0, str~match(2, "ab"))
    self~assertSame("subTest_05",  0, str~match(2, "cD"))


::method "test_Match_caseless"

    str="abcDEFghi"
    self~assertSame("subTest_01" , 1, str~caselessMatch(2, "bc"))
    self~assertSame("subTest_02",  1, str~caselessMatch(2, "bcD"))
    self~assertSame("subTest_03" , 1, str~caselessMatch(2, "bcd"))
    self~assertSame("subTest_04" , 0, str~caselessMatch(2, "ab"))
    self~assertSame("subTest_05",  0, str~caselessMatch(2, "cD"))


::method "test_MatchChar"

    str="abcDEFghi"
    self~assertSame("subTest_01" , 1, str~MatchChar(2, "b"))
    self~assertSame("subTest_02",  0, str~MatchChar(2, "B"))
    self~assertSame("subTest_03" , 0, str~MatchChar(2, "c"))


::method "test_MatchChar_caseless"

    str="abcDEFghi"
    self~assertSame("subTest_01" , 1, str~CaselessMatchChar(2, "b"))
    self~assertSame("subTest_02",  1, str~CaselessMatchChar(2, "B"))
    self~assertSame("subTest_03" , 0, str~CaselessMatchChar(2, "c"))



   -- test the BIF, using examples from the documentation
::method "test_MAX"

   self~assertEquals("subTest1" , 12 , 12~MAX(6,7,9)                                              )
   self~assertEquals("subTest2" , 19 , 17.3~MAX(19,17.03)                                         )
   self~assertEquals("subTest3" , -3 , '-7'~MAX('-3','-4.3')                                      )
   self~assertEquals("subTest4" , 21 , 1~MAX(2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21) )


   -- test the BIF, using examples from the documentation
::method "test_MIN"

   self~assertEquals("subTest1" , 6     , 12~MIN(6,7,9)                                              )
   self~assertEquals("subTest2" , 17.03 , 17.3~MIN(19,17.03)                                         )
   self~assertEquals("subTest3" , -7    , '-7'~MIN('-3','-4.3')                                      )
   self~assertEquals("subTest4" , 1     , 21~MIN(20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1) )



   -- test the BIF, using examples from the documentation
::method "test_OVERLAY"

   self~assertSame("subTest1" , 'ab def'     , 'abcdef'~OVERLAY(' ',3)       )
   self~assertSame("subTest2" , 'ab. ef'     , 'abcdef'~OVERLAY('.',3,2)     )
   self~assertSame("subTest3" , 'qqcd'       , 'abcd'~OVERLAY('qq')          )
   self~assertSame("subTest4" , 'abcqq'      , 'abcd'~OVERLAY('qq',4)        )
   self~assertSame("subTest5" , 'abc+123+++' , 'abc'~OVERLAY('123',5,6,'+')  )


   -- test the BIF, using examples from the documentation
::method "test_Pos_caseless"

   self~assertEquals("subTest1" , 6 , 'Saturday'~caselessPos('da')    )
   self~assertEquals("subTest2" , 6 , 'Saturday'~caselessPos('dA')    )
   self~assertEquals("subTest3" , 6 , 'Saturday'~caselessPos('Da')    )
   self~assertEquals("subTest4" , 6 , 'Saturday'~caselessPos('DA')    )


   -- test the BIF, using examples from the documentation
::method "test_REVERSE"

   self~assertSame("subTest1" , '.cBA' , 'ABc.'~REVERSE )
   self~assertSame("subTest2" , ' ZYX' , 'XYZ '~REVERSE )



   -- test the BIF, using examples from the documentation
::method "test_RIGHT"

   self~assertSame("subTest1" , 'abc  d'~RIGHT(8)  , '  abc  d' )
   self~assertSame("subTest2" , 'abc def'~RIGHT(5) , 'c def'    )
   self~assertSame("subTest3" , '12'~RIGHT(5,'0')  , '00012'    )


   -- test the BIF, using examples from the documentation
::method "test_SIGN"

   self~assertEquals("subTest1" , 1  , '12.3'~SIGN     )
   self~assertEquals("subTest2" , -1 , ' -0.307'~SIGN  )
   self~assertEquals("subTest3" , 0  , 0.0~SIGN        )


   -- test the BIF, using examples from the documentation
::method "test_STRING"

   self~assertSame("subTest1" , ''    , ''~STRING         )
   self~assertSame("subTest2" , ' '   , ' '~STRING        )
   self~assertSame("subTest3" , 'ab'  , 'ab'~STRING       )
   self~assertSame("subTest3" , ' ab ', ' ab '~STRING     )


   -- test the BIF, using examples from the documentation
::method "test_STRIP"

   self~assertSame("subTest1" , 'ab c'  , '  ab c  '~STRIP        )
   self~assertSame("subTest2" , 'ab c  ', '  ab c  '~STRIP('L')   )
   self~assertSame("subTest3" , '  ab c', '  ab c  '~STRIP('t')   )
   self~assertSame("subTest4" , '12.7'  , '12.7000'~STRIP(,0)     )
   self~assertSame("subTest5" , '12.7'  , '0012.700'~STRIP(,0)    )


   -- test the BIF, using examples from the documentation
::method "test_SUBSTRING"

   self~assertSame("subTest1" , 'bc'     , 'abc'~SUBSTR(2)         )
   self~assertSame("subTest2" , 'bc  '   , 'abc'~SUBSTR(2,4)       )
   self~assertSame("subTest3" , 'bc....' , 'abc'~SUBSTR(2,6,'.')   )

   -- test the BIF, using examples from the documentation
::method "test_SUBCHAR"

   self~assertSame("subTest1" ,  'a',  'abc'~SUBCHAR(1)     )
   self~assertSame("subTest2" ,  'b',  'abc'~SUBCHAR(2)     )
   self~assertSame("subTest3" ,  'c',  'abc'~SUBCHAR(3)     )
   self~assertSame("subTest4" ,  '' ,  'abc'~SUBCHAR(4)     )



   -- test the BIF, using examples from the documentation
::method "test_SUBWORD"

   self~assertSame("subTest1" , 'is the'   , 'Now is the  time'~SUBWORD(2,2)  )
   self~assertSame("subTest2" , 'the  time', 'Now is the  time'~SUBWORD(3)    )
   self~assertSame("subTest3" , ""         , 'Now is the  time'~SUBWORD(5)    )


   -- test the BIF, using examples from the documentation
::method "test_TRANSLATE"

   self~assertSame("subTest1" , 'ABCDEF' , 'abcdef'~TRANSLATE                     )
   self~assertSame("subTest2" , 'ab2d1f' , 'abcdef'~TRANSLATE('12','ec')          )
   self~assertSame("subTest3" , '12..ef' , 'abcdef'~TRANSLATE('12','abcd','.')    )
   self~assertSame("subTest4" , 'A Q V'  , 'APQRV'~TRANSLATE(,'PR')               )
   self~assertSame("subTest5" , 'APQ  '  , 'APQRV'~TRANSLATE(XRANGE('00'X,'Q'))   )
   self~assertSame("subTest6" , 'dabc'   , '4123'~TRANSLATE('abcd','1234')        )


   -- test the BIF, using examples from the documentation
::method "test_TRUNC"

   self~assertSame("subTest1" , 12      , 12.3~TRUNC           )
   self~assertSame("subTest2" , 127.097 , 127.09782~TRUNC(3)   )
   self~assertSame("subTest3" , 127.100 , 127.1~TRUNC(3)       )
   self~assertSame("subTest4" , 127.00  , 127~TRUNC(2)         )



::method "test_UPPER"

    str='abcDEfgh'
    self~assertSame("subTest_01" , 'aBcDEfgh', str~UPPER(2,  1 ))
    self~assertSame("subTest_02" , 'abcDEfgh', str~UPPER(1,  0 ))
    self~assertSame("subTest_03" , 'abcDEfgh', str~UPPER(99, 2 ))
    self~assertSame("subTest_04" , 'aBCDEFGH', str~UPPER(2     ))
    self~assertSame("subTest_05" , 'ABCDEFGH', str~UPPER        )


   -- test the BIF, using examples from the documentation
::method "test_VERIFY"

   self~assertEquals("subTest1" , 0 , '123'~VERIFY('1234567890')           )
   self~assertEquals("subTest2" , 2 , '1Z3'~VERIFY('1234567890')           )
   self~assertEquals("subTest3" , 1 , 'AB4T'~VERIFY('1234567890')          )
   self~assertEquals("subTest4" , 3 , 'AB4T'~VERIFY('1234567890','M')      )
   self~assertEquals("subTest5" , 1 , 'AB4T'~VERIFY('1234567890','N')      )
   self~assertEquals("subTest6" , 4 , '1P3Q4'~VERIFY('1234567890', ,3)     )
   self~assertEquals("subTest7" , 2 , '123'~VERIFY("",N,2)                 )
   self~assertEquals("subTest8" , 3 , 'ABCDE'~VERIFY("", ,3)               )
   self~assertEquals("subTest9" , 6 , 'AB3CD5'~VERIFY('1234567890','M',4)  )


   -- test the BIF, using examples from the documentation
::method "test_WORD"

   self~assertSame("subTest1" , 'the', 'Now is the time'~WORD(3)  )
   self~assertSame("subTest2" , ""   , 'Now is the time'~WORD(5)  )


   -- test the BIF, using examples from the documentation
::method "test_WORDINDEX"

   self~assertEquals("subTest1" , 8 , 'Now is the time'~WORDINDEX(3) )
   self~assertEquals("subTest2" , 0 , 'Now is the time'~WORDINDEX(6) )


   -- test the BIF, using examples from the documentation
::method "test_WORDLENGTH"

   self~assertEquals("subTest1" , 2 , 'Now is the time'~WORDLENGTH(2)    )
   self~assertEquals("subTest2" , 5 , 'Now comes the time'~WORDLENGTH(2) )
   self~assertEquals("subTest3" , 0 , 'Now is the time'~WORDLENGTH(6)    )


   -- test the BIF, using examples from the documentation
::method "test_WORDPOS"

   self~assertEquals("subTest1" , 3 , 'now is the time'~WORDPOS('the')           )
   self~assertEquals("subTest2" , 0 , 'now is the time'~WORDPOS('The')           )
   self~assertEquals("subTest3" , 2 , 'now is the time'~WORDPOS('is the')        )
   self~assertEquals("subTest4" , 2 , 'now is the time'~WORDPOS('is   the')      )
   self~assertEquals("subTest5" , 0 , 'now is   the time'~WORDPOS('is    time ') )
   self~assertEquals("subTest6" , 2 , 'To be or not to be'~WORDPOS('be')         )
   self~assertEquals("subTest7" , 6 , 'To be or not to be'~WORDPOS('be',3)       )


   -- test the BIF, using examples from the documentation
::method "test_WORDPOS_caseless"

   self~assertEquals("subTest01" , 3 , 'now is the time'~caselessWordPos('the')           )
   self~assertEquals("subTest02" , 3 , 'now is the time'~caselessWordPos('The')           )
   self~assertEquals("subTest03" , 2 , 'now is the time'~caselessWordPos('is tHE')        )
   self~assertEquals("subTest04" , 2 , 'now is the time'~caselessWordPos('Is ThE')        )
   self~assertEquals("subTest05" , 2 , 'now is the time'~caselessWordPos('is   the')      )
   self~assertEquals("subTest06" , 2 , 'now is the time'~caselessWordPos('iS   ThE')      )
   self~assertEquals("subTest07" , 0 , 'now is   the time'~caselessWordPos('is    time ') )
   self~assertEquals("subTest08" , 2 , 'To be or not to be'~caselessWordPos('be')         )
   self~assertEquals("subTest09" , 2 , 'To be or not to be'~caselessWordPos('Be')         )
   self~assertEquals("subTest10" , 6 , 'To be or not to be'~caselessWordPos('be',3)       )
   self~assertEquals("subTest11" , 6 , 'To be or not to be'~caselessWordPos('bE',3)       )


   -- test the BIF, using examples from the documentation
::method "test_WORDS"

   self~assertEquals("subTest1" , 4 , 'Now is the time'~WORDS )
   self~assertEquals("subTest2" , 0 , ' '~WORDS               )


   -- test the BIF, using examples from the documentation
::method "test_X2B"

   self~assertSame("subTest1" , '11000011'    , 'C3'~X2B        )
   self~assertSame("subTest2" , '0111'        , '7'~X2B         )
   self~assertSame("subTest3" , '000111000001', '1 C1'~X2B      )
   self~assertSame("subTest4" , '11000011'    , 'C3'x~C2X~X2B   )    --
   self~assertSame("subTest5" , '10000001'    , '129'~D2X~X2B   )
   self~assertSame("subTest6" , '1100'        , '12'~D2X~X2B    )


   -- test the BIF, using examples from the documentation
::method "test_X2C"

   self~assertSame("subTest1" , '4865 6c6c 6f'~X2C , 'Hello' )/* ASCII */
   self~assertSame("subTest2" , '3732 73'~X2C      , '72s'   )/* ASCII */


   -- test the BIF, using examples from the documentation
::method "test_X2D"

   self~assertSame("subTest1" , 14    , '0E'~X2D       )
   self~assertSame("subTest2" , 129   , '81'~X2D       )
   self~assertSame("subTest3" , 3969  , 'F81'~X2D      )
   self~assertSame("subTest4" , 65409 , 'FF81'~X2D     )
   self~assertSame("subTest5" , 240   , '46 30'X~X2D   ) /* ASCII */
   self~assertSame("subTest6" , 240   , '66 30'X~X2D   ) /* ASCII */
   self~assertSame("subTest7" , -127  , '81'~X2D(2)    ) --
   self~assertSame("subTest8" , 129   , '81'~X2D(4)    )
   self~assertSame("subTest9" , -3967 , 'F081'~X2D(4)  )
   self~assertSame("subTest10", 129   , 'F081'~X2D(3)  )
   self~assertSame("subTest11", -127  , 'F081'~X2D(2)  )
   self~assertSame("subTest12", 1     , 'F081'~X2D(1)  )
   self~assertSame("subTest13", 0     , '0031'~X2D(0)  )


  -- test {de|en}codeBase64
  /* based on newsgroup article:
         From: "Salvador Parra Camacho" <sparrac@gmail.com>
         Newsgroups: comp.lang.rexx
         Subject: encodebase64 method of the String class in ooRexx 3.1
         Date: 14 Oct 2006 12:31:13 -0700
         Organization: http://groups.google.com
  */
::method "test_EncodeBase64_DecodeBase64"
   allChars=xrange("00"x, "ff"x) -- create a string with all 8-Bit chars
   do i=1 to allChars~length
      a=allChars~left(i)         -- create a string from the left
      self~assertSame("subTest"i"a", a, a~encodeBase64~decodeBase64)  -- test whether same value
      -- self~assertEquals("subTest"i, a, a1~encodeBase64~decodeBase64)  -- test whether same value

      b=allChars~right(i)        -- create a string from the right
      self~assertSame("subTest"i"b", b, b~encodeBase64~decodeBase64)  -- test whether same value
   end

   a="Hello world"
   a1=a~encodeBase64          -- encode the string with ooRexx
      -- "Hello world" encoded value from Perl, Ruby, etc. according to Salvador's article
   a2="SGVsbG8gd29ybGQ="

   self~assertSame("subTest257" , a , a2~decodeBase64 )
   self~assertSame("subTest258" , a , a1~decodeBase64 )

::method "used_to_test_rexx_enDecoding" -- "test_Enbase64_Debase64"
   allChars=xrange("00"x, "ff"x) -- create a string with all 8-Bit chars
   do i=1 to allChars~length
      a=allChars~left(i)         -- create a string from the left
      self~assertSame("subTest"i"a", a, debase64(enbase64(a)))  -- test whether same value

      b=allChars~right(i)        -- create a string from the right
      self~assertSame("subTest"i"b", b, debase64(enbase64(b)))  -- test whether same value
   end



/* Systematically test built-in method vs. a Rexx-solution (c) Rony G. Flatscher */
::method "test_EncodeBase64"
   allChars=xrange("00"x, "ff"x) -- create a string with all 8-Bit chars

   do i=1 to allChars~length
      a=allChars~left(i)         -- create a string from the left
      self~assertSame("subTest"i, enbase64(a), a~encodeBase64)  -- test whether same value
      -- self~assertEquals("subTest"i, enbase64(a), a~encodeBase64)  -- test whether same value
   end


/* Systematically test built-in method vs. a Rexx-solution (c) Rony G. Flatscher */
::method "test_DecodeBase64"
   allChars=xrange("00"x, "ff"x) -- create a string with all 8-Bit chars

   do i=1 to allChars~length
      a=allChars~left(i)         -- create a string from the left
      a2=enbase64(a)             -- base64 encode it
      self~assertSame("subTest"i, a, a2~decodeBase64)  -- test whether same value
      -- self~assertEquals("subTest"i, a, a2~decodeBase64)  -- test whether same value
   end



/* Systematically test built-in method vs. a Rexx-solution (c) Rony G. Flatscher */
-- enbase64: procedure expose mimeTable padChar base64
::routine enbase64
     parse arg data

           -- do we need to pad the data at the end?
     pad = 3-length(data) // 3   -- get rest of integer division
     if pad<>3 then data=data || copies("00"x, pad)      -- add blanks to get to multiple of 3's
     data=x2b(c2x(data))         -- turn all data into a bitstring

     new=.mutableBuffer~new
     do while data <> ""
        parse var data nr1 +6 nr2 +6 nr3 +6 nr4 +6 data    -- get data of 3 bytes in six-bit-packs

        -- new = new || x2c(b2x(nr1)) || x2c(b2x(nr2)) || x2c(b2x(nr3)) || x2c(b2x(nr4))  -- add them to result
        new~~append(x2c(b2x(nr1))) ~~append(x2c(b2x(nr2))) ~~append(x2c(b2x(nr3)))
        new~~append(x2c(b2x(nr4)))  -- add them to result
     end

     new=translate(new~string, .base64.mimeTable, .base64.base64)     -- translate to table chars

     if pad<>3 then         -- not a multiple of 3, then indicate pads with "="
        new = overlay( copies(.base64.padChar, pad), new, (length(new)-pad+1) )
     return new


::routine deBase64 public
  use arg data

  pos=pos(.base64.padChar,data)        -- find pad character
  if pos<>0 then
  do
     pnum = length(data) - pos + 1   -- how many are there (1 or 2) ?
     if pnum>2 then pnum=0   -- something went wrong, there shouldn't be more than two, reset
  end
  else
     pnum = 0

  data=translate(data, .base64.base64, .base64.mimetable)    -- translate from table

        -- check if data is missing, if so pad with "00"x
  pad = length(data) // 4       -- get rest of integer division
  if pad<>0 then data=data || copies("00"x, 4-pad)      -- add blanks to get to multiple of 4's

  data=x2b(c2x(data))   -- now turn data into a bitstring

  new=.mutableBuffer~new
  do while data<>""
     parse var data . +2 nr5 +6 . +2 nr6 +6 . +2 nr7 +6 .+2 nr8 +6 data

     if data = "" then  -- last round, nothing left after this one
        new~append(left( x2c(b2x(nr5 ||nr6 || nr7 || nr8)), 3-pnum)) -- use only non-chunked bytes
     else
        new~append(x2c(b2x(nr5 ||nr6 || nr7 || nr8)))
  end
  return new~string

