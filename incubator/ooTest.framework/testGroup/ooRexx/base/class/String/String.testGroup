#!/usr/bin/rexx
/*
   name:             String.testGroup
   author:           Rony G. Flatscher
   date:             2005-08-07
   version:          1.0.3

-- line commented lines are ignored, when building the directory of infos from this header
   changed:          2005-08-21, ---rgf, renamed the testGroup-class to match exactly the
                             file name, i.e. a dot (.) between class name and "testGroup";
                             added convention to return a list of arrays containing the
                             test case class object and an optional list of mandatory test
                             case methods from it
                     2005-10-20, ---rgf, completed the String's class method tests from the docs
                     2006-06-18, ---rgf, corrected a bug in TEST_DATATYPE, enquiting "-1" in
                             "subTest3"
                     2006-10-15, ---rgf, added "test_EnCodeBase64_DecodeBase64"
                     2006-10-21, ---rgf, added own (old) Rexx-implementation for
                                         en/de-coding base64 to test the C-implementation against
                     2007-03-21, ---rgf, added test for SUBCHAR (available with 6.01)
                                         changed sequence of expected/actual values to match the meaning
                                         in the failure message(s)
                     2007-06-10, ---rgf, added test cases for LOWER and UPPER
                     2007-06-23, ---rgf, added test case for 'caselessWordPos'
                     2007-07-10, ---rgf, changed names of test cases, added various caseless tests
                     2007-09-16, ---rgf, added tests for new 'count' argument in [caseless]changeStr()

   languageLevel:    6.02
   purpose:          Test the methods of the class String.
   remark:           Initial test unit for demonstration purposes, needs to be completed.

   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

// category needs not to be numbered, importance is given by position (1=most important)
   category:         ooRexx
   category:         Base
   category:         Class
   category:         String
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2005-2007 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . fileSpec

  lines = .array~new
  do i = 1 until lines[i] = "*/"
    lines[i] = sourceline(i)
  end

  group = .TestGroup~new(fileSpec, lines)
  group~add(.String.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult

::requires 'ooTest.frm'     -- load the ooRexxUnit classes

::class "String.testGroup" subclass ooTestCase public


::method setup       -- add entries to .local
      /* define data needed for the Rexx implementation of encodeBase64 and decodeBase64  */
   .local~base64.padChar="="                    -- use equal sign as a pad char
   .local~base64.mimeTable= "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" ||,
                                 padChar        -- trailing space indicator

   .local~base64.base64  = xrange("00"x, "3F"x) -- all 64 possible 6-bits values


::method tearDown    -- remove entries from .local
   .local~remove("BASE64.PADCHAR")
   .local~remove("BASE64.MIMETABLE")
   .local~remove("BASE64.BASE64")


   -- test the BIF, using examples from the documentation
::method "test_NEW"
   self~assertSame(.string~new(""), "")
   self~assertSame(.string~new(" "), " ")
   self~assertSame(.string~new("  "), "  ")
   self~assertSame(.string~new("ab"), "ab")

   self~assertEquals(.string~new(""), "")
   self~assertEquals(.string~new(" "), " ")
   self~assertEquals(.string~new("  "), "  ")
   self~assertEquals(.string~new("ab"), "ab")


::method "test_arithmetic_operators"

   self~assertEquals(10, 5+5)
   self~assertEquals(3, 8-5)
   self~assertEquals(10, 5*2)
   self~assertEquals(3, 6/2)
   self~assertEquals(1, 9//4)
   self~assertEquals(2, 9%4)
   self~assertEquals(8, 2**3)
   self~assertEquals(5, +5) /* Prefix + */
   self~assertEquals(-5, -5) /* Prefix - */

   self~assertEquals(10, 5~'+'(5))
   self~assertEquals(3, 8~'-'(5))
   self~assertEquals(10, 5~'*'(2))
   self~assertEquals(3, 6~'/'(2))
   self~assertEquals(1, 9~'//'(4))
   self~assertEquals(2, 9~'%'(4))
   self~assertEquals(8, 2~'**'(3))
   self~assertEquals(5, 5~'+') /* Prefix + */
   self~assertEquals(-5, 5~'-') /* Prefix - */



::method "test_comparison_operators"

   self~assertTrue(5=5) /* equal */
   self~assertTrue(42\=41) /* All of these are */
   self~assertTrue(42><41) /* "not equal" */
   self~assertTrue(42<>41)
   self~assertTrue(13>12) /* Variations of */
   self~assertTrue(12<13) /* less than and */
   self~assertTrue(13>=12) /* greater than */
   self~assertFalse(12\<13)
   self~assertTrue(12<=13)
   self~assertTrue(12\>13)

   self~assertTrue(5~'='(5)) /* equal */
   self~assertTrue(42~'\='(41)) /* All of these are */
   self~assertTrue(42~'><'(41)) /* "not equal" */
   self~assertTrue(42~'<>'(41))
   self~assertTrue(13~'>'(12)) /* Variations of */
   self~assertTrue(12~'<'(13)) /* less than and */
   self~assertTrue(13~'>='(12)) /* greater than */
   self~assertFalse(12~'\<'(13))
   self~assertTrue(12~'<='(13))
   self~assertTrue(12~'\>'(13))

   -- identical
   self~assertTrue('space'  ==  'space')  /* Strictly equal */
   self~assertTrue('space'  \== ' space')  /* Strictly not equal */
   self~assertTrue('space'  >>  ' space')  /* Variations of */
   self~assertTrue(' space' <<  'space')  /* strictly greater */
   self~assertTrue('space'  >>= ' space')  /* than and less than */
   self~assertTrue('space'  \<< ' space')
   self~assertTrue(' space' <<= 'space')
   self~assertTrue(' space' \>> 'space')

   self~assertTrue('space'~'=='('space'))  /* Strictly equal */
   self~assertTrue('space'~'\=='(' space'))  /* Strictly not equal */
   self~assertTrue('space'~'>>'(' space'))  /* Variations of */
   self~assertTrue(' space'~'<<'('space'))  /* strictly greater */
   self~assertTrue('space'~'>>='(' space'))  /* than and less than */
   self~assertTrue('space'~'\<<'(' space'))
   self~assertTrue(' space'~'<<='('space'))
   self~assertTrue(' space'~'\>>'('space'))


::method "test_logical_operators"

   self~assertFalse(0&0)
   self~assertFalse(1&0)
   self~assertFalse(0&1)
   self~assertTrue(1&1)
   self~assertFalse(0&1&0)
   self~assertTrue(1&1&1)
   self~assertFalse(0|0)
   self~assertTrue(1|0)
   self~assertTrue(0|1)
   self~assertTrue(0|1|0)
   self~assertTrue(1|0|1)
   self~assertTrue(1&&0)
   self~assertTrue(0&&1)
   self~assertFalse(1&&1)
   self~assertFalse(0&&0)
   self~assertFalse(\1)
   self~assertTrue(\0)



::method "test_concatenation_operators"

   num=33
   self~assertSame("33%", num"%") /* abuttal */
   self~assertSame("33%", num~""('%'))
   self~assertSame("ooRexx", "ooR"||"exx") /* || */
   self~assertSame("ooRexx", "ooR"~'||'("exx")) /* || */
   self~assertSame("Open Object Rexx", 'Open'  'Object' 'Rexx') /* blank */
   self~assertSame("Open Object Rexx", ('Open'  'Object')  ~' '('Rexx'))
   self~assertSame("Open Object Rexx", 'Open'~' '('Object')~' '('Rexx'))







   -- test the BIF, using examples from the documentation
::method "test_ABBREV"

   self~assertTrue('Print'~ABBREV("Pri"))

   self~assertFalse("PRINT"~ABBREV("Pri"))
   self~assertFalse("PRINT"~ABBREV("PRI", 4))
   self~assertFalse("PRINT"~ABBREV("PRY"))
   self~assertTrue("PRINT"~ABBREV(""))
   self~assertFalse("PRINT"~ABBREV("", 1))


   -- test the BIF, using examples from the documentation
::method "test_ABBREV_caseless"

   self~assertTrue('Print'~caselessABBREV("Pri"))

   self~assertTrue("PRINT"~caselessABBREV("Pri"))
   self~assertFalse("PRINT"~caselessABBREV("PRI", 4))
   self~assertFalse("PRINT"~caselessABBREV("PRY"))
   self~assertTrue("PRINT"~caselessABBREV(""))
   self~assertFalse("PRINT"~caselessABBREV("", 1))


   -- test the BIF, using examples from the documentation
::method "test_ABS"

   self~assertEquals(12.3, 12.3~ABS)
   self~assertEquals(12.3, '12.3'~ABS)
   self~assertEquals(0.307, ' -0.307'~ABS)

      -- new tests
   self~assertEquals(0, ' -0'~ABS)
   self~assertEquals(0, ' +0'~ABS)
   self~assertEquals(0, ' - 0 '~ABS)
   self~assertEquals(0, ' + 0 '~ABS)
   self~assertEquals(1, ' -1'~ABS)
   self~assertEquals(1, ' +1'~ABS)
   self~assertEquals(1, ' - 1 '~ABS)
   self~assertEquals(1, ' + 1 '~ABS)


   -- test the BIF, using examples from the documentation
::method "test_B2X"

   self~assertSame('C3', '11000011'~B2X)
   self~assertSame('17', '10111'~B2X)
   self~assertSame('5', '101'~B2X)
   self~assertSame('1F0', '1 1111 0000'~B2X)
   self~assertSame('23', '10111'~B2X~X2D) /* decimal 23 */


   -- test the BIF, using examples from the documentation
::method "test_BITAND"

   self~assertSame('12'x, '12'x~BITAND)
   self~assertSame('23'x, '73'x~BITAND('27'x))
   self~assertSame('1155'x, '13'x~BITAND('5555'x))
   self~assertSame('1154'x, '13'x~BITAND('5555'x,'74'x))
   self~assertSame('PQRS', 'pQrS'~BITAND(,'DF'x))  /* ASCII */


   -- test the BIF, using examples from the documentation
::method "test_BITOR"

   self~assertSame('12'x, '12'x~BITOR)
   self~assertSame('35'x, '15'x~BITOR('24'x))
   self~assertSame('3556'x, '15'x~BITOR('2456'x))
   self~assertSame('35F6'x, '15'x~BITOR('2456'x,'F0'x))
   self~assertSame('5D5D'x, '1111'x~BITOR(,'4D'x))
   self~assertSame('pqrs', 'pQrS'~BITOR(,'20'x)) /* ASCII */


   -- test the BIF, using examples from the documentation
::method "test_BITXOR"

   self~assertSame('12'x, '12'x~BITXOR)
   self~assertSame('30'x, '12'x~BITXOR('22'x))
   self~assertSame('3011'x, '1211'x~BITXOR('22'x))
   self~assertSame('555544'x, '1111'x~BITXOR('444444'x))
   self~assertSame('555504'x, '1111'x~BITXOR('444444'x,'40'x))
   self~assertSame('5C5C'x, '1111'x~BITXOR(,'4D'x))
   self~assertSame('E53302'x, 'C711'x~BITXOR('222222'x,' ')) /* ASCII */



   -- test the BIF, using examples from the documentation
::method "test_C2D"

   self~assertEquals(9, '09'X~C2D)
   self~assertEquals(129, '81'X~C2D)
   self~assertEquals(65409, 'FF81'X~C2D)
   self~assertEquals(0, ""~C2D)
   self~assertEquals(97, 'a'~C2D) /* ASCII */

   self~assertEquals(-127, '81'X~C2D(1))     -- -- --
   self~assertEquals(129, '81'X~C2D(2))
   self~assertEquals(-127, 'FF81'X~C2D(2))
   self~assertEquals(-127, 'FF81'X~C2D(1))
   self~assertEquals(127, 'FF7F'X~C2D(1))
   self~assertEquals(-3967, 'F081'X~C2D(2))
   self~assertEquals(-127, 'F081'X~C2D(1))
   self~assertEquals(0, '0031'X~C2D(0))



   -- test the BIF, using examples from the documentation
::method "test_C2X"

   self~assertEquals('0123', '0123'X~C2X) /* '30313233'X in ASCII */
   self~assertEquals('5A4438', 'ZD8'~C2X) /* '354134343338'X in ASCII */



   -- test the BIF, using examples from the documentation
::method "test_CENTER"

   self~assertSame('  ABC  ', abc~CENTER(7))
   self~assertSame('--ABC---', abc~CENTER(8,'-'))
   self~assertSame('e blue s', 'The blue sky'~CENTRE(8))
   self~assertSame('e blue ', 'The blue sky'~CENTRE(7))


   -- test the BIF, using examples from the documentation
::method "test_CHANGESTR"

   self~assertSame('000', 101100~CHANGESTR('1',""))
   self~assertSame('X0XX00', 101100~CHANGESTR('1','X'))

   -- new tests
    self~assertSame('101100', '101100'~changestr('','X'))
    self~assertSame('', ''~changestr('1','X'))

   -- new tests: optional, trailing "count" argument
    self~assertSame('ha-lo', 'hallo'~changeStr('l','-',1))
    self~assertSame('ha--o', 'hallo'~changeStr('l','-',2))
    self~assertSame('ha--o', 'hallo'~changestr('l','-',3))

::method "test_changeStr_error_93.907"
    self~expectSyntax(93.907)
    'aha'~changeStr('a','A',0)



::method "test_ChangeStr_caseless"

   self~assertSame('aABBcC', "aAbBcC"~caselessChangeStr('b',"B"))
   self~assertSame('aAbbcC', "aAbBcC"~caselessChangeStr('B',"b"))
   self~assertSame('aA99cC', "aAbBcC"~caselessChangeStr('B',"9"))

   -- new tests: optional, trailing "count" argument
    self~assertSame('ha-lo', 'hallo'~caselessChangeStr('L','-',1))
    self~assertSame('ha-lo', 'haLlo'~caselessChangeStr('L','-',1))
    self~assertSame('ha-Lo', 'haLLo'~caselessChangeStr('L','-',1))
    self~assertSame('ha-lo', 'haLlo'~caselessChangeStr('l','-',1))
    self~assertSame('ha-Lo', 'haLLo'~caselessChangeStr('l','-',1))

    self~assertSame('ha--o', 'hallo'~caselessChangeStr('l','-',2))
    self~assertSame('ha--o', 'haLlo'~caselessChangeStr('L','-',2))
    self~assertSame('ha--o', 'haLLo'~caselessChangeStr('L','-',2))
    self~assertSame('ha--o', 'haLlo'~caselessChangeStr('l','-',2))
    self~assertSame('ha--o', 'haLLo'~caselessChangeStr('l','-',2))

    self~assertSame('ha--o', 'hallo'~caselessChangestr('l','-',3))
    self~assertSame('ha--o', 'haLlo'~caselessChangeStr('L','-',3))
    self~assertSame('ha--o', 'haLLo'~caselessChangeStr('L','-',3))
    self~assertSame('ha--o', 'haLlo'~caselessChangeStr('l','-',3))
    self~assertSame('ha--o', 'haLLo'~caselessChangeStr('l','-',3))

::method "test_changeStr_caseless_error_93.907"
    self~expectSyntax(93.907)
    'aha'~caselessChangeStr('a','A',0)



   -- test the BIF, using examples from the documentation
::method "test_COMPARE"

   self~assertEquals(0, 'abc'  ~COMPARE('abc'))
   self~assertEquals(2, 'abc'  ~COMPARE('ak'))
   self~assertEquals(0, 'ab '  ~COMPARE('ab'))
   self~assertEquals(0, 'ab '  ~COMPARE('ab',' '))
   self~assertEquals(3, 'ab '  ~COMPARE('ab','x'))
   self~assertEquals(5, 'ab-- '~COMPARE('ab','-'))

::method "test_COMPARE_caseless"

   self~assertEquals(0, 'abc'  ~caselessCompare('aBc'))
   self~assertEquals(2, 'abc'  ~caselessCompare('Ak'))
   self~assertEquals(0, 'ab '  ~caselessCompare('AB'))
   self~assertEquals(0, 'ab '  ~caselessCompare('aB',' '))
   self~assertEquals(3, 'ab '  ~caselessCompare('Ab','x'))
   self~assertEquals(5, 'ab-- '~caselessCompare('AB','-'))


::method "test_compareTo"  -- 3.2

  self~assertEquals(-1, "a"~compareTo("b"))
  self~assertEquals(0, "a"~compareTo("a"))
  self~assertEquals(1, "b"~compareTo("a"))


::method "test_CompareTo_caseless"  -- 3.2

  self~assertEquals(-1, "a"~caselessCompareTo("B"))
  self~assertEquals(0, "a"~caselessCompareTo("A"))
  self~assertEquals(1, "b"~caselessCompareTo("A"))

  self~assertEquals(-1, "A"~caselessCompareTo("b"))
  self~assertEquals(0, "A"~caselessCompareTo("a"))
  self~assertEquals(1, "B"~caselessCompareTo("a"))


   -- test the BIF, using examples from the documentation
::method "test_COPIES"

   self~assertSame('abcabcabc', 'abc'~COPIES(3))
   self~assertSame("", 'abc'~COPIES(0))


   -- test the BIF, using examples from the documentation
::method "test_COUNTSTR"

   self~assertEquals(4, '101101'~COUNTSTR('1'))
   self~assertEquals(1, 'J0KKK0'~COUNTSTR('KK'))

   -- test the BIF, using examples from the documentation
::method "test_COUNTSTR_caseless"

   self~assertEquals(1, 'J0kKk0'~caselessCountStr('KK'))
   self~assertEquals(2, 'J0kKkK0'~caselessCountStr('KK'))
   self~assertEquals(2, 'J0kKkK0'~caselessCountStr('kK'))
   self~assertEquals(2, 'J0kKkK0'~caselessCountStr('Kk'))
   self~assertEquals(2, 'J0kKkK0'~caselessCountStr('kk'))


   -- test the BIF, using examples from the documentation
::method "test_D2C"

   self~assertSame('A', '65'~D2C) /* '41'x is an ASCII 'A' */
   self~assertSame('A', '65'~D2C(1))
   self~assertSame('00'x'A', '65'~D2C(2))
   self~assertSame('00000000'x'A', '65'~D2C(5))
   self~assertSame('m', '109'~D2C) /* '6D'x is an ASCII 'm' */
   self~assertSame('93'x, '-109'~D2C(1)) -- 'ô'   ) /* '93'x is an ASCII 'ô' */
   self~assertSame('00'x'L', '76'~D2C(2)) /* '4C'x is an ASCII ' L' */
   self~assertSame('ff'x'L', '-180'~D2C(2))


   -- test the BIF, using examples from the documentation
::method "test_D2X"

   self~assertSame('9', '9'~D2X)
   self~assertSame('81', '129'~D2X)
   self~assertSame('1', '129'~D2X(1))
   self~assertSame('81', '129'~D2X(2))
   self~assertSame('0081', '129'~D2X(4))
   self~assertSame('01', '257'~D2X(2))
   self~assertSame('81', '-127'~D2X(2))
   self~assertSame('FF81', '-127'~D2X(4))
   self~assertSame("", '12'~D2X(0))



   -- test the BIF, using examples from the documentation
::method "test_DATATYPE"

-- p.210

   self~assertEquals('NUM', ' 12 '~DATATYPE)
   self~assertEquals('CHAR', ''~DATATYPE)    -- error!
   self~assertEquals('CHAR', '123*'~DATATYPE)
   self~assertTrue('12.3'~DATATYPE('N'))
   self~assertFalse('12.3'~DATATYPE('W'))
   self~assertTrue('Fred'~DATATYPE('M'))
   self~assertFalse('Fred'~DATATYPE('U'))    -- error! option changed
   self~assertFalse('Fred'~DATATYPE('L'))
   self~assertTrue('?20K'~DATATYPE('s'))
   self~assertTrue('BCd3'~DATATYPE('X'))
   self~assertTrue('BC d3'~DATATYPE('X'))


::method "test_DATATYPE_9"

   numeric digits 1
   self~assertTrue('0'~DATATYPE('9'))
   self~assertTrue(1~DATATYPE('9'))
   self~assertTrue("-1"~DATATYPE('9'))
   self~assertTrue('12'~DATATYPE('9'))
   self~assertTrue('-12'~DATATYPE('9'))


   -- test the BIF, using examples from the documentation
::method "test_DELSTR"

   self~assertSame('ab', 'abcd'~DELSTR(3))
   self~assertSame('abe', 'abcde'~DELSTR(3,2))
   self~assertSame('abcde', 'abcde'~DELSTR(6))


   -- test the BIF, using examples from the documentation
::method "test_DELWORD"

   self~assertSame('Now time', 'Now is the  time'~DELWORD(2,2))
   self~assertSame('Now is ', 'Now is the time '~DELWORD(3))
   self~assertSame('Now is the  time', 'Now is the  time'~DELWORD(5))
   self~assertSame('Now is   time', 'Now is   the time'~DELWORD(3,1))


::method "test_Equals"

    self~assertSame(1, "a"~equals("a"))
    self~assertSame(0, "a"~equals("A"))
    self~assertSame(0, "a"~equals("b"))
    self~assertSame(0, "a"~equals("B"))
    self~assertSame(1, "b"~equals("b"))
    self~assertSame(0, "b"~equals("B"))
    self~assertSame(0, "b"~equals("a"))
    self~assertSame(0, "b"~equals("A"))


::method "test_Equals_caseless"

    self~assertSame(1, "a"~caselessEquals("a"))
    self~assertSame(1, "a"~caselessEquals("A"))
    self~assertSame(0, "a"~caselessEquals("b"))
    self~assertSame(0, "a"~caselessEquals("B"))
    self~assertSame(1, "b"~caselessEquals("b"))
    self~assertSame(1, "b"~caselessEquals("B"))
    self~assertSame(0, "b"~caselessEquals("a"))
    self~assertSame(0, "b"~caselessEquals("A"))



   -- test the BIF, using examples from the documentation
::method "test_FORMAT"

   self~assertSame('   3', '3'~FORMAT(4))
   self~assertSame('   2', '1.73'~FORMAT(4,0))
   self~assertSame('   1.730', '1.73'~FORMAT(4,3))
   self~assertSame('  -0.8', '-.76'~FORMAT(4,1))
   self~assertSame('   3.03', '3.03'~FORMAT(4))
   self~assertSame('-12.7300', ' - 12.73'~FORMAT(,4))
   self~assertSame('-12.73', ' - 12.73'~FORMAT)
   self~assertSame('0', '0.000'~FORMAT)
   self~assertSame('1.234573E+04', '12345.73'~FORMAT(, ,2,2))   --
   self~assertSame('1.235E+4', '12345.73'~FORMAT(,3, ,0))
   self~assertSame('1.235', '1.234573'~FORMAT(,3, ,0))
   self~assertSame('12345.73', '12345.73'~FORMAT(, ,3,6))
   self~assertSame('123456700000.000', '1234567e5'~FORMAT(,3,0))


   -- test the BIF, using examples from the documentation
::method "test_INSERT"

   self~assertSame('123abc', 'abc'~INSERT('123'))
   self~assertSame('abc def', 'abcdef'~INSERT(' ',3))
   self~assertSame('abc  123   ', 'abc'~INSERT('123',5,6))
   self~assertSame('abc++123+++', 'abc'~INSERT('123',5,6,'+'))
   self~assertSame('123--abc', 'abc'~INSERT('123', ,5,'-'))


   -- test the BIF, using examples from the documentation
::method "test_LASTPOS"

   self~assertEquals(8, 'abc def ghi'~LASTPOS(' '))
   self~assertEquals(0, 'abcdefghi'~LASTPOS(' '))
   self~assertEquals(4, 'efgxyz'~LASTPOS('xy'))
   self~assertEquals(4, 'abc def ghi'~LASTPOS(' ',7))


   -- test the BIF, using examples from the documentation
::method "test_LastPos_caseless"

   self~assertEquals(4, 'efgxyz'~caselessLastPos('xy'))
   self~assertEquals(4, 'efgxyz'~caselessLastPos('XY'))
   self~assertEquals(4, 'efgxyz'~caselessLastPos('Xy'))
   self~assertEquals(4, 'efgxyz'~caselessLastPos('xY'))


   -- test the BIF, using examples from the documentation
::method "test_LEFT"

   self~assertSame('abc d   ', 'abc d'~LEFT(8))
   self~assertSame('abc d...', 'abc d'~LEFT(8,'.'))
   self~assertSame('abc  de', 'abc  def'~LEFT(7))


   -- test the BIF, using examples from the documentation
::method "test_LENGTH"

   self~assertEquals(8, 'abcdefgh'~LENGTH)
   self~assertEquals(8, 'abc defg'~LENGTH)
   self~assertEquals(0, ""~LENGTH)


::method "test_LOWER"

    str='ABCdeFGH'
    self~assertSame('AbCdeFGH', str~lower(2,  1 ))
    self~assertSame('ABCdeFGH', str~lower(1,  0 ))
    self~assertSame('ABCdeFGH', str~lower(99, 2 ))
    self~assertSame('Abcdefgh', str~lower(2     ))
    self~assertSame('abcdefgh', str~lower)


   -- test the BIF, using examples from the documentation
::method "test_MAKEARRAY"

   nl = '0d0a'x
   string = "hello"nl"world"nl"this is an array."
   array = string~makearray
   -- say "the second line is:" array[2]
   self~assertSame("world", array[2])

   string = "hello*world*this is an array."
   array = string~makearray('*')
   -- say "the third line is:" array[3]
   self~assertSame("this is an array.", array[3])


   -- test the BIF, using examples from the documentation
::method "test_MAKESTRING"

   self~assertSame('', ''~MAKESTRING)
   self~assertSame(' ', ' '~MAKESTRING)
   self~assertSame('ab', 'ab'~MAKESTRING)
   self~assertSame(' ab ', ' ab '~MAKESTRING)



::method "test_Match"

    str="abcDEFghi"
    self~assertSame(1, str~match(2, "bc"))
    self~assertSame(1, str~match(2, "bcD"))
    self~assertSame(0, str~match(2, "bcd"))
    self~assertSame(0, str~match(2, "ab"))
    self~assertSame(0, str~match(2, "cD"))


::method "test_Match_caseless"

    str="abcDEFghi"
    self~assertSame(1, str~caselessMatch(2, "bc"))
    self~assertSame(1, str~caselessMatch(2, "bcD"))
    self~assertSame(1, str~caselessMatch(2, "bcd"))
    self~assertSame(0, str~caselessMatch(2, "ab"))
    self~assertSame(0, str~caselessMatch(2, "cD"))


::method "test_MatchChar"

    str="abcDEFghi"
    self~assertSame(1, str~MatchChar(2, "b"))
    self~assertSame(0, str~MatchChar(2, "B"))
    self~assertSame(0, str~MatchChar(2, "c"))


::method "test_MatchChar_caseless"

    str="abcDEFghi"
    self~assertSame(1, str~CaselessMatchChar(2, "b"))
    self~assertSame(1, str~CaselessMatchChar(2, "B"))
    self~assertSame(0, str~CaselessMatchChar(2, "c"))



   -- test the BIF, using examples from the documentation
::method "test_MAX"

   self~assertEquals(12, 12~MAX(6,7,9))
   self~assertEquals(19, 17.3~MAX(19,17.03))
   self~assertEquals(-3, '-7'~MAX('-3','-4.3'))
   self~assertEquals(21, 1~MAX(2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21))


   -- test the BIF, using examples from the documentation
::method "test_MIN"

   self~assertEquals(6, 12~MIN(6,7,9))
   self~assertEquals(17.03, 17.3~MIN(19,17.03))
   self~assertEquals(-7, '-7'~MIN('-3','-4.3'))
   self~assertEquals(1, 21~MIN(20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1))



   -- test the BIF, using examples from the documentation
::method "test_OVERLAY"

   self~assertSame('ab def', 'abcdef'~OVERLAY(' ',3))
   self~assertSame('ab. ef', 'abcdef'~OVERLAY('.',3,2))
   self~assertSame('qqcd', 'abcd'~OVERLAY('qq'))
   self~assertSame('abcqq', 'abcd'~OVERLAY('qq',4))
   self~assertSame('abc+123+++', 'abc'~OVERLAY('123',5,6,'+'))


   -- test the BIF, using examples from the documentation
::method "test_Pos_caseless"

   self~assertEquals(6, 'Saturday'~caselessPos('da'))
   self~assertEquals(6, 'Saturday'~caselessPos('dA'))
   self~assertEquals(6, 'Saturday'~caselessPos('Da'))
   self~assertEquals(6, 'Saturday'~caselessPos('DA'))


   -- test the BIF, using examples from the documentation
::method "test_REVERSE"

   self~assertSame('.cBA', 'ABc.'~REVERSE)
   self~assertSame(' ZYX', 'XYZ '~REVERSE)



   -- test the BIF, using examples from the documentation
::method "test_RIGHT"

   self~assertSame('abc  d'~RIGHT(8), '  abc  d')
   self~assertSame('abc def'~RIGHT(5), 'c def')
   self~assertSame('12'~RIGHT(5,'0'), '00012')


   -- test the BIF, using examples from the documentation
::method "test_SIGN"

   self~assertEquals(1, '12.3'~SIGN)
   self~assertEquals(-1, ' -0.307'~SIGN)
   self~assertEquals(0, 0.0~SIGN)


   -- test the BIF, using examples from the documentation
::method "test_STRING"

   self~assertSame('', ''~STRING)
   self~assertSame(' ', ' '~STRING)
   self~assertSame('ab', 'ab'~STRING)
   self~assertSame(' ab ', ' ab '~STRING)


   -- test the BIF, using examples from the documentation
::method "test_STRIP"

   self~assertSame('ab c', '  ab c  '~STRIP)
   self~assertSame('ab c  ', '  ab c  '~STRIP('L'))
   self~assertSame('  ab c', '  ab c  '~STRIP('t'))
   self~assertSame('12.7', '12.7000'~STRIP(,0))
   self~assertSame('12.7', '0012.700'~STRIP(,0))


   -- test the BIF, using examples from the documentation
::method "test_SUBSTRING"

   self~assertSame('bc', 'abc'~SUBSTR(2))
   self~assertSame('bc  ', 'abc'~SUBSTR(2,4))
   self~assertSame('bc....', 'abc'~SUBSTR(2,6,'.'))

   -- test the BIF, using examples from the documentation
::method "test_SUBCHAR"

   self~assertSame('a', 'abc'~SUBCHAR(1))
   self~assertSame('b', 'abc'~SUBCHAR(2))
   self~assertSame('c', 'abc'~SUBCHAR(3))
   self~assertSame('', 'abc'~SUBCHAR(4))



   -- test the BIF, using examples from the documentation
::method "test_SUBWORD"

   self~assertSame('is the', 'Now is the  time'~SUBWORD(2,2))
   self~assertSame('the  time', 'Now is the  time'~SUBWORD(3))
   self~assertSame("", 'Now is the  time'~SUBWORD(5))


   -- test the BIF, using examples from the documentation
::method "test_TRANSLATE"

   self~assertSame('ABCDEF', 'abcdef'~TRANSLATE)
   self~assertSame('ab2d1f', 'abcdef'~TRANSLATE('12','ec'))
   self~assertSame('12..ef', 'abcdef'~TRANSLATE('12','abcd','.'))
   self~assertSame('A Q V', 'APQRV'~TRANSLATE(,'PR'))
   self~assertSame('APQ  ', 'APQRV'~TRANSLATE(XRANGE('00'X,'Q')))
   self~assertSame('dabc', '4123'~TRANSLATE('abcd','1234'))


   -- test the BIF, using examples from the documentation
::method "test_TRUNC"

   self~assertSame(12, 12.3~TRUNC)
   self~assertSame(127.097, 127.09782~TRUNC(3))
   self~assertSame(127.100, 127.1~TRUNC(3))
   self~assertSame(127.00, 127~TRUNC(2))



::method "test_UPPER"

    str='abcDEfgh'
    self~assertSame('aBcDEfgh', str~UPPER(2,  1 ))
    self~assertSame('abcDEfgh', str~UPPER(1,  0 ))
    self~assertSame('abcDEfgh', str~UPPER(99, 2 ))
    self~assertSame('aBCDEFGH', str~UPPER(2     ))
    self~assertSame('ABCDEFGH', str~UPPER)


   -- test the BIF, using examples from the documentation
::method "test_VERIFY"

   self~assertEquals(0, '123'~VERIFY('1234567890'))
   self~assertEquals(2, '1Z3'~VERIFY('1234567890'))
   self~assertEquals(1, 'AB4T'~VERIFY('1234567890'))
   self~assertEquals(3, 'AB4T'~VERIFY('1234567890','M'))
   self~assertEquals(1, 'AB4T'~VERIFY('1234567890','N'))
   self~assertEquals(4, '1P3Q4'~VERIFY('1234567890', ,3))
   self~assertEquals(2, '123'~VERIFY("",N,2))
   self~assertEquals(3, 'ABCDE'~VERIFY("", ,3))
   self~assertEquals(6, 'AB3CD5'~VERIFY('1234567890','M',4))


   -- test the BIF, using examples from the documentation
::method "test_WORD"

   self~assertSame('the', 'Now is the time'~WORD(3))
   self~assertSame("", 'Now is the time'~WORD(5))


   -- test the BIF, using examples from the documentation
::method "test_WORDINDEX"

   self~assertEquals(8, 'Now is the time'~WORDINDEX(3))
   self~assertEquals(0, 'Now is the time'~WORDINDEX(6))


   -- test the BIF, using examples from the documentation
::method "test_WORDLENGTH"

   self~assertEquals(2, 'Now is the time'~WORDLENGTH(2))
   self~assertEquals(5, 'Now comes the time'~WORDLENGTH(2))
   self~assertEquals(0, 'Now is the time'~WORDLENGTH(6))


   -- test the BIF, using examples from the documentation
::method "test_WORDPOS"

   self~assertEquals(3, 'now is the time'~WORDPOS('the'))
   self~assertEquals(0, 'now is the time'~WORDPOS('The'))
   self~assertEquals(2, 'now is the time'~WORDPOS('is the'))
   self~assertEquals(2, 'now is the time'~WORDPOS('is   the'))
   self~assertEquals(0, 'now is   the time'~WORDPOS('is    time '))
   self~assertEquals(2, 'To be or not to be'~WORDPOS('be'))
   self~assertEquals(6, 'To be or not to be'~WORDPOS('be',3))


   -- test the BIF, using examples from the documentation
::method "test_WORDPOS_caseless"

   self~assertEquals(3, 'now is the time'~caselessWordPos('the'))
   self~assertEquals(3, 'now is the time'~caselessWordPos('The'))
   self~assertEquals(2, 'now is the time'~caselessWordPos('is tHE'))
   self~assertEquals(2, 'now is the time'~caselessWordPos('Is ThE'))
   self~assertEquals(2, 'now is the time'~caselessWordPos('is   the'))
   self~assertEquals(2, 'now is the time'~caselessWordPos('iS   ThE'))
   self~assertEquals(0, 'now is   the time'~caselessWordPos('is    time '))
   self~assertEquals(2, 'To be or not to be'~caselessWordPos('be'))
   self~assertEquals(2, 'To be or not to be'~caselessWordPos('Be'))
   self~assertEquals(6, 'To be or not to be'~caselessWordPos('be',3))
   self~assertEquals(6, 'To be or not to be'~caselessWordPos('bE',3))


   -- test the BIF, using examples from the documentation
::method "test_WORDS"

   self~assertEquals(4, 'Now is the time'~WORDS)
   self~assertEquals(0, ' '~WORDS)


   -- test the BIF, using examples from the documentation
::method "test_X2B"

   self~assertSame('11000011', 'C3'~X2B)
   self~assertSame('0111', '7'~X2B)
   self~assertSame('000111000001', '1 C1'~X2B)
   self~assertSame('11000011', 'C3'x~C2X~X2B)    --
   self~assertSame('10000001', '129'~D2X~X2B)
   self~assertSame('1100', '12'~D2X~X2B)


   -- test the BIF, using examples from the documentation
::method "test_X2C"

   self~assertSame('4865 6c6c 6f'~X2C, 'Hello')/* ASCII */
   self~assertSame('3732 73'~X2C, '72s')/* ASCII */


   -- test the BIF, using examples from the documentation
::method "test_X2D"

   self~assertSame(14, '0E'~X2D)
   self~assertSame(129, '81'~X2D)
   self~assertSame(3969, 'F81'~X2D)
   self~assertSame(65409, 'FF81'~X2D)
   self~assertSame(240, '46 30'X~X2D) /* ASCII */
   self~assertSame(240, '66 30'X~X2D) /* ASCII */
   self~assertSame(-127, '81'~X2D(2)) --
   self~assertSame(129, '81'~X2D(4))
   self~assertSame(-3967, 'F081'~X2D(4))
   self~assertSame(129, 'F081'~X2D(3))
   self~assertSame(-127, 'F081'~X2D(2))
   self~assertSame(1, 'F081'~X2D(1))
   self~assertSame(0, '0031'~X2D(0))


  -- test {de|en}codeBase64
  /* based on newsgroup article:
         From: "Salvador Parra Camacho" <sparrac@gmail.com>
         Newsgroups: comp.lang.rexx
         Subject: encodebase64 method of the String class in ooRexx 3.1
         Date: 14 Oct 2006 12:31:13 -0700
         Organization: http://groups.google.com
  */
::method "test_EncodeBase64_DecodeBase64"
   allChars=xrange("00"x, "ff"x) -- create a string with all 8-Bit chars
   do i=1 to allChars~length
      a=allChars~left(i)         -- create a string from the left
      self~assertSame(a, a~encodeBase64~decodeBase64)  -- test whether same value
      -- self~assertEquals(a, a1~encodeBase64~decodeBase64)  -- test whether same value

      b=allChars~right(i)        -- create a string from the right
      self~assertSame(b, b~encodeBase64~decodeBase64)  -- test whether same value
   end

   a="Hello world"
   a1=a~encodeBase64          -- encode the string with ooRexx
      -- "Hello world" encoded value from Perl, Ruby, etc. according to Salvador's article
   a2="SGVsbG8gd29ybGQ="

   self~assertSame(a, a2~decodeBase64)
   self~assertSame(a, a1~decodeBase64)

::method "used_to_test_rexx_enDecoding" -- "test_Enbase64_Debase64"
   allChars=xrange("00"x, "ff"x) -- create a string with all 8-Bit chars
   do i=1 to allChars~length
      a=allChars~left(i)         -- create a string from the left
      self~assertSame(a, debase64(enbase64(a)))  -- test whether same value

      b=allChars~right(i)        -- create a string from the right
      self~assertSame(b, debase64(enbase64(b)))  -- test whether same value
   end



/* Systematically test built-in method vs. a Rexx-solution (c) Rony G. Flatscher */
::method "test_EncodeBase64"
   allChars=xrange("00"x, "ff"x) -- create a string with all 8-Bit chars

   do i=1 to allChars~length
      a=allChars~left(i)         -- create a string from the left
      self~assertSame(enbase64(a), a~encodeBase64)  -- test whether same value
      -- self~assertEquals(enbase64(a), a~encodeBase64)  -- test whether same value
   end


/* Systematically test built-in method vs. a Rexx-solution (c) Rony G. Flatscher */
::method "test_DecodeBase64"
   allChars=xrange("00"x, "ff"x) -- create a string with all 8-Bit chars

   do i=1 to allChars~length
      a=allChars~left(i)         -- create a string from the left
      a2=enbase64(a)             -- base64 encode it
      self~assertSame(a, a2~decodeBase64)  -- test whether same value
      -- self~assertEquals(a, a2~decodeBase64)  -- test whether same value
   end



/* Systematically test built-in method vs. a Rexx-solution (c) Rony G. Flatscher */
-- enbase64: procedure expose mimeTable padChar base64
::routine enbase64
     parse arg data

           -- do we need to pad the data at the end?
     pad = 3-length(data) // 3   -- get rest of integer division
     if pad<>3 then data=data || copies("00"x, pad)      -- add blanks to get to multiple of 3's
     data=x2b(c2x(data))         -- turn all data into a bitstring

     new=.mutableBuffer~new
     do while data <> ""
        parse var data nr1 +6 nr2 +6 nr3 +6 nr4 +6 data    -- get data of 3 bytes in six-bit-packs

        -- new = new || x2c(b2x(nr1)) || x2c(b2x(nr2)) || x2c(b2x(nr3)) || x2c(b2x(nr4))  -- add them to result
        new~~append(x2c(b2x(nr1))) ~~append(x2c(b2x(nr2))) ~~append(x2c(b2x(nr3)))
        new~~append(x2c(b2x(nr4)))  -- add them to result
     end

     new=translate(new~string, .base64.mimeTable, .base64.base64)     -- translate to table chars

     if pad<>3 then         -- not a multiple of 3, then indicate pads with "="
        new = overlay( copies(.base64.padChar, pad), new, (length(new)-pad+1) )
     return new


::routine deBase64 public
  use arg data

  pos=pos(.base64.padChar,data)        -- find pad character
  if pos<>0 then
  do
     pnum = length(data) - pos + 1   -- how many are there (1 or 2) ?
     if pnum>2 then pnum=0   -- something went wrong, there shouldn't be more than two, reset
  end
  else
     pnum = 0

  data=translate(data, .base64.base64, .base64.mimetable)    -- translate from table

        -- check if data is missing, if so pad with "00"x
  pad = length(data) // 4       -- get rest of integer division
  if pad<>0 then data=data || copies("00"x, 4-pad)      -- add blanks to get to multiple of 4's

  data=x2b(c2x(data))   -- now turn data into a bitstring

  new=.mutableBuffer~new
  do while data<>""
     parse var data . +2 nr5 +6 . +2 nr6 +6 . +2 nr7 +6 .+2 nr8 +6 data

     if data = "" then  -- last round, nothing left after this one
        new~append(left( x2c(b2x(nr5 ||nr6 || nr7 || nr8)), 3-pnum)) -- use only non-chunked bytes
     else
        new~append(x2c(b2x(nr5 ||nr6 || nr7 || nr8)))
  end
  return new~string

