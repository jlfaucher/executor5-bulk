#!/usr/bin/rexx
/*
   name:             fileNameDialog_demo.testGroup
   author:           Mark Miesfeld
   date:             2007-08-13
   version:          0.0.9
   changed:

   languageLevel:    6.0
   purpose:          Test the fileNameDialog_demo ooRexx program

   remark:           A primary reason for this test group is to ensure the
                     sample program shipped with the release package of ooRexx
                     runs as expected.

                     If all samples have a test group, then an automated test
                     can be run after a build to ensure all sample programs will
                     execute.

                     This is a Windows only test.  This test needs to be run
                     with a standard ooRexx installation.

                     This test group is a work in progress.  Please feel free to
                     add to it.  The idea is to work through all the options of
                     the sample program.  A generic killExample() method is
                     started, but may not be finished.  The method would be used
                     to shut down the sample program if the test group gets
                     'stuck.'

                     The test group should also serve as an example of how to
                     automate the execution of an ooDialog program.

   license:          CPL 1.0 (Common Public License v1.0, see below)
   link:

   category1:        ooRexx
   category2:        samples
   category3:        ooDialog

*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2007 Rexx Language Association. All rights reserved.         */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.ibm.com/developerworks/oss/CPLv1.0.htm                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . fileSpec

  lines=.array~new
  do i=1 to 150 until lines[i]="*/"
     lines[i]=sourceline(i)
  end

  -- This is a Windows specific test.
  group = .TestGroup~new(fileSpec, lines)
  group~restrictOS("WINDOWS")

  -- 1.) The test cases in this GUI test need to execute in order.  So we use a
  -- method that places the individual test cases into the test suite in the
  -- order we specify. fetchMethodNames() returns an array of the test method
  -- names.  The order of the names in the array will be the order the tests
  -- are executed.
  --
  -- 2.) The test cases require the 'winsystm.cls' file.  Since this file only
  -- exists in a Windows ooRexx installation, a normal ::requires directive
  -- causes an ugly error if this .testGroup is run on a non-Windows system.  To
  -- fix this, a custom TestSuite (.FNDlgTestSuite) is used.  The custom test
  -- suite provides a setUp() method.  The setUp() method of a TestSuite is
  -- invoked immediately prior to the exeuction of the tests in the test suite.
  -- The setUp() method for .FNDlgTestSuite performs the necessary work to get
  -- the winsystm.cls classes loaded.
  group~addWithCollection(.fileNameDialog_demo.testGroup, fetchMethodNames(), .FNDlgTestSuite)

  if group~isAutomatedTest then return group

  -- Not an automated test, execute the tests now.
  testResult = group~suite~run~~print

return testResult
-- End of entry point.

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\
  Directives, Classes, or Routines.
\* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
::requires "FileUtils.cls"
::requires 'ooTest.frm'

/** fetchMehodNames()
 * This is a helper function that creates an array of the test methods.  The
 * order of the tests in the array is the order they will be executed.
 */
::routine fetchMethodNames
  tests = .array~new
  tests[1] = 'test_ooRexxInstalled'
  tests[2] = 'test_exampleStart'
  tests[3] = 'test_mainScreen'
  tests[4] = 'test_firstOption'
  tests[5] = 'test_exampleQuit'
return tests

::class 'FNDlgTestSuite' subclass TestSuite

::method setUp
  say 'In my test suite at set up'
  say 'self class:' self~class
  say 'self has method TestCaseInfo:' self~hasMethod('TestCaseInfo')
  say 'TestCaseInfo is a directory: ' self~testCaseInfo~isA(.directory)
  parse source . . fileSpec
  say 'My file is:' fileSpec
  say 'My error is on line:' .line

  j = printTestInfo(.fileNameDialog_demo.testGroup~testCaseInfo)
  prgFile = indirectRequire('WinUtils.cls')

  if prgFile == "" then do
    --group~markNoTests("Error loading WinUtils.cls. This test requires WinUtils.cls")
    -- Should have: 1.) way to not run these tests.  2.) report why they are not run.
    say 'Do NOT run the file name dialog demo test cases!'
    say 'Report this fact to someone!'
  end
  else do
    call (prgFile)
    j = deleteFile(prgFile)
  end

::method tearDown
  say 'In my test suite at tear down'

/* class: fileNameDialog_demo.testGroup- - - - - - - - - - - - - - - - - - - -*\

  The test group class will start the example program and then use the
  WindowObject class to locate the various Windows created by the program and
  push buttons to drive the program.

  The test cases need to execute in a specific order.  The test case methods are
  invoked in order, sorted by method name, by the framework.  This fact is
  used to ensure the correct order of execution.
\* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
::class 'fileNameDialog_demo.testGroup' public -
        subclass ooTestCase

  ::method test_ooRexxInstalled
    self~class~stop = .true

    home = value("REXX_HOME", , 'ENVIRONMENT')
    self~assertTrue("ooRexx must be installed and REXX_HOME set", home~length > 0)

    home = home || '\samples\fileNameDialog_demo.rex'
    j = SysFileTree(home, f., 'FOS')
    self~assertTrue("SysFileTree must not fail", j == 0)
    self~assertTrue("Example program must be located", f.0 == 1)

    prgPathName = f.1
    self~assertTrue("Example program must exist", .stream~new(prgPathName)~query("EXISTS")~length <> 0)
    self~class~prgPath = prgPathName
    self~class~stop = .false

  ::method test_exampleStart
    if self~class~stop then self~fail("Failure of one test causes all tests to fail.")
    self~class~stop = .true

    launcher = .ProgramLauncher~new(self~class~prgPath)
    ret = launcher~startProgram

    self~assertEquals('launcher~startProgram should return 0',    0,     ret)

    wf = .WindowFinder~new

    -- We know the example program puts up an InfoDialog first.
    wnd = wf~getWindow("Information")

    self~assertEquals('Must have a WindowObject object', .WindowObject, wnd~class)
    self~assertEquals('Window must have Information title', "Information", wnd~title)

    -- Click the okay button to close the InfoDialog and bring up the main screen.
    wnd~pushButton("OK")

    self~class~launcher = launcher
    self~class~windowFinder = wf
    self~class~stop = .false

  ::method test_mainScreen
    if self~class~stop then self~fail("Failure of one test causes all tests to fail.")
    self~class~stop = .true

    wf = self~class~windowFinder

    -- We know the example program has this title.  That's how we can find it.
    -- Changing the default pause to .5 seconds, because it sometimes takes the
    -- window longer to come up.
    wnd = wf~getWindow("FileNameDialog Demonstration", , .5)

    -- Assert that we found the main window of the program.
    self~assertEquals('Must have a WindowObject object', wnd~class, .WindowObject)
    self~assertEquals('Window must have proper program title', "FileNameDialog Demonstration", wnd~title)

    self~class~stop = .false

  ::method test_firstOption
    if self~class~stop then self~fail("Failure of one test causes all tests to fail.")
    self~class~stop = .true

    wf = self~class~windowFinder
    wnd = wf~getWindow("FileNameDialog Demonstration", , .5)
    self~assertEquals('Window must have proper program title', "FileNameDialog Demonstration", wnd~title)

    -- First option is radio button, ID 101.  But it should be already selected,
    -- so we just need to click the Ok button.  OK button has ID 1, so sending
    -- a command of 1 has the effect of clicking that button.
    wnd~sendCommand(1)

    wnd = wf~getWindow("Open a File", , .5)

    self~assertEquals('Must have a WindowObject object', .WindowObject, wnd~class)
    self~assertNotNull('Open File dialog must be active (option 1 clicked.)',  wnd)

    -- The cancel button has ID of 2, sending a command of 2 has the effect of
    -- clicking the cancel button.  In the sample program, if the user did not
    -- select a file, an error dialog is put up. (Since we click cancel, we do
    -- not select a file and therefore we should get an Error dialog window
    -- next.)
    wnd~sendCommand(2)
    wnd = wf~getWindow("Error", , .5)
    self~assertNotNull('Open File dialog canceled (option 1) must have ErrorDialog',  wnd)

    -- Push OK button, should be back to main screen.
    wnd~pushButton("OK")
    self~class~stop = .false

  -- End test_004_firstOption( )

  /* Note: we could continue to test more of the options on the sample dialog,
   * but we just end here.  We drop through to the last test which should end
   * the sample program.
   *
   * A little bit sticky here for an automated test framework.  If we can not
   * end the sample program, the automated testing will hang.  Yikes!
   */

  -- test_999_exampleQuit()
  ::method test_exampleQuit

    -- It is possible that we failed right off the bat and the WindowFinder
    -- object was never even created.  If so, just abort.
    if self~class~windowFinder == "" then return

    wf = self~class~windowFinder

    if self~class~stop then do
      -- Some previous test failed.  So, we are not sure what state the example
      -- program is in, which window is open.  Use a generic function to end
      -- the example
      self~killExample(wf)
    end
    else do
      wnd = wf~getWindow("FileNameDialog Demonstration", , .5)
      if wnd <> .nil then wnd~sendCommand(2)
    end

    -- Wait for the example program to end and get its return code.  The example
    -- program returns a distinctive code when it ends without error.
    ret = self~class~launcher~getResult

    -- Step 4 assert that we get the correct return code for a successful
    -- execution of the example program.
    self~assertEquals("fileNameDialog_demo return code should be 37", ret, 37)

  -- End test_999_exampleQuit()


  ::method killExample private
    use arg wf

    -- Try each possible window created by the example.  When we find an open
    -- one, proceed from that known spot.
    wnd = wf~getWindow("FileNameDialog Demonstration")
    if wnd <> .nil then do
      wnd~sendCommand(2)
      return 0
    end

    wnd = wf~getWindow("Error")
    if wnd <> .nil then return self~closeFromMsgBox(wf, wnd)

    wnd = wf~getWindow("Information")
    if wnd <> .nil then return self~closeFromMsgBox(wf, wnd)

  return self~findAndCloseFNDlg(wf)

  ::method findAndCloseFNFlg
    use arg wf

    wnd = wf~getWindow("Open a File")
    if wnd <> .nil then return~closeFromFNDlg(wf, wnd)

    title = "FileNameDialog-Option"
    do i = 2 to 7
      wndTitle = title || i
      wnd = wf~getWindow(wndTitle)
      if wnd <> .nil then return~closeFromFNDlg(wf, wnd)
    end

    -- Yikes, we are stuck.
  return -1

  -- Have a message box window (errorDialog or infoDialog) assume we can close
  -- with things working from here.  Because if we can not, we are stuck.
  ::method closeFromMsgBox private
    use arg wf, wnd
    wnd~pushButton("OK")
    wnd = wf~getWindow("FileNameDialog Demonstration")
    wnd~sendCommand(2)
  return 0

  -- Have one of the FileNameDialogs, assume we can close with things working
  -- from here.  Because if we can not, we are stuck.
  ::method closeFromFNDlg private
    use arg wf, wnd
    wnd~sendCommand(2)
    wnd = wf~getWindow("Error")
  return self~closeFromMsgBox(wf, wnd)

  ::method init class
    self~init:super
    self~prgPath = ""
    self~launcher = ""
    self~stop = .false
    self~windowFinder = ""

  ::method prgPath      attribute class
  ::method stop         attribute class
  ::method windowFinder attribute class
  ::method launcher     attribute class

-- End of class: fileNameDialog_demo.testGroup
