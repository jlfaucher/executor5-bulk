/* decimalFormat.cls */
::class decimalFormat public

::method init
    expose mask valid_mask_characters groupingSize separators
    use arg mask

-- Be sure ooRexx version is dated 20071030 or higher
    parse version ooRexxVer
    if date('s',ooRexxVer~subWord(3),'n') < 20071030 then
        raise syntax 3.903 array('decimalFormat.cls')
    valid_mask_characters = .array~of('#', ',', '0', '.')

    if arg(1,'o') | mask = '' then
        mask = '#,###.##'
    self~validateMask

    groupingSize = 3
    separators = ',.'

::method getVersion
return 'Beta'

::method getSeparators
    expose separators
return separators

::method setSeparators
    expose separators
    use arg new_separators
    if arg(1,'o') then
        raise syntax 93.903 array('Separators',1, arg(1))
    if new_separators~length <> 2 then
        raise syntax 93.900 array('Separators Must Have A Length of 2')

    if new_separators~left(1) = new_separators~right(1) then
        raise syntax 93.900 array('Each Separator Must Be Unique')

    separators = new_separators
return 0

::method getGroupingSize
    expose groupingSize
return groupingSize

::method setGroupingSize
    expose groupingSize
    use arg new_groupingSize
    if arg(1,'o') then
        raise syntax 93.903 array('Grouping Size',1, arg(1))

    if \new_groupingSize~datatype('w') then
        raise syntax 93.905 array(1,arg(1))
    groupingSize = new_groupingSize
return 0

::method validateMask
    expose mask pos_prefix pos_mask pos_suffix neg_prefix neg_mask neg_suffix zero_prefix zero_mask zero_suffix valid_mask_characters have_zMask
    -- step 1 - see if there's a ; divider, if so can't be > 2
    if mask~countStr(';') > 2 then
        raise syntax 93.900 array('Pattern Can NOT Have More The 2 Semi-Colons')
-------------------------------------------------------
-- examine all the pieces of the pattern
    parse var mask Wpos_mask';'Wneg_mask';'Wzero_mask
-------------------------------------------------------
-- examine all the pieces of the pos_mask
-- ascertain that single and/or double quotes are paired
    Wpos_mask = Wpos_mask~strip
    if Wpos_mask~pos("'") > 0 then
        do
            if Wpos_mask~countStr("'") // 2 \= 0 then
                raise syntax 93.900 array('Single Quotes Must Be Matched In The Positive Pattern')
        end

    if Wpos_mask~pos('"') > 0 then
        do
            if Wpos_mask~countStr('"') // 2 \= 0 then
                raise syntax 93.900 array('Double Quotes Must Be Matched In The Positive Pattern')
        end

-- see if there is a prefix
    first_char = Wpos_mask~left(1)
    pos_prefix = ''
    if first_char = '"' | first_char = "'" then
        do
            -- this will be the pre-fix for a positive number
            parse var Wpos_mask (first_char)pos_prefix(first_char)Wpos_mask
        end

-- see if there is a suffix
    last_char = Wpos_mask~right(1)
    pos_suffix = ''
    if last_char = '"' | last_char = "'" then
        do
            -- this will be the pre-fix for a positive number
            parse var Wpos_mask Wpos_mask(last_char)pos_suffix(last_char)
        end

-- can not be more than 1 '.' in the remaining pattern
    if Wpos_mask~countStr('.') > 1 then
        raise syntax 93.900 array('Positive Patterns Can Not Have More Than One Decimal (.)')

-- # can not follow 0 in m_int
    parse var Wpos_mask m_int'.'m_dec
    fp_z = m_int~pos('0')
    if fp_z > 0 then
        do
            if m_int~pos('#',fp_z) > 0 then
                raise syntax 93.900 array('A # Symbol Can Not Follow A 0 In The Integer Portion Of The Positive Pattern')
        end

-- 0 can not follow # in m_dec
    fp_p = m_dec~pos('#')
    if fp_p > 0 then
        do
            if m_dec~pos('0',fp_p) > 0 then
                raise syntax 93.900 array('A 0 Symbol Can Not Follow A # In The Decimal Portion Of The Positive Pattern')
        end

-- examine the characters in the remaining mask
    do i = 1 to Wpos_mask~length
        if \valid_mask_characters~hasItem(Wpos_mask~substr(i,1)) then
            raise syntax 93.900 array('The Mask Portion Of The Positive Pattern Can Not Contain Characters Other Than "#,0."')
    end

    pos_mask = Wpos_mask

-------------------------------------------------------
-- examine all the pieces of the neg_mask

-- Need to implement Rick's suggestion of having a negative mask, but only specifying the pre & suf fix

-- ascertain that single and/or double quotes are paired
    if Wneg_mask = '' then
        do
            neg_prefix = '-'pos_prefix
            neg_mask   = pos_mask
            neg_suffix = pos_suffix
        end
    else
        do
            Wneg_mask = Wneg_mask~strip
            if Wneg_mask~pos("'") > 0 then
                do
                    if Wneg_mask~countStr("'") // 2 \= 0 then
                        raise syntax 93.900 array('Single Quotes Must Be Matched In The Negative Pattern')
                end

            if Wneg_mask~pos('"') > 0 then
                do
                    if Wneg_mask~countStr('"') // 2 \= 0 then
                        raise syntax 93.900 array('Double Quotes Must Be Matched In The Negative Pattern')
                end

-- see if there is a prefix
            first_char = Wneg_mask~left(1)
            if first_char = '"' | first_char = "'" then
                do
                    -- this will be the pre-fix for a positive number
                    parse var Wneg_mask (first_char)neg_prefix(first_char)Wneg_mask
                end

-- see if there is a suffix
            last_char = Wneg_mask~right(1)
            if last_char = '"' | last_char = "'" then
                do
                    -- this will be the pre-fix for a positive number
                    parse var Wneg_mask Wneg_mask(last_char)neg_suffix(last_char)
                end

-- can not be more than 1 '.' in the remaining pattern
            if Wneg_mask~countStr('.') > 1 then
                    raise syntax 93.900 array('Negative Patterns Can Not Have More Than One Decimal (.)')

            if Wneg_mask = '' then
                Wneg_mask = pos_mask

            parse var Wneg_mask m_int'.'m_dec
-- # can not follow 0 in m_int
            fp_z = m_int~pos('0')
            if fp_z > 0 then
                do
                    if m_int~pos('#',fp_z) > 0 then
                        raise syntax 93.900 array('A # Symbol Can Not Follow A 0 In The Integer Portion Of The Negative Pattern')
                end

-- 0 can not follow # in m_dec
            fp_p = m_dec~pos('#')
            if fp_p > 0 then
                do
                    if m_dec~pos('0',fp_p) > 0 then
                        raise syntax 93.900 array('A 0 Symbol Can Not Follow A # In The Decimal Portion Of The Negative Pattern')
                end

-- examine the characters in the remaining mask
        do i = 1 to Wneg_mask~length
            if \valid_mask_characters~hasItem(Wneg_mask~substr(i,1)) then
                raise syntax 93.900 array('The Mask Portion Of The Negative Pattern Can Not Contain Characters Other Than "#,0."')
        end
        neg_mask = Wneg_mask
    end

---------------------------------------
-- examine all the pieces of the zero_mask
    if Wzero_mask = '' then
        do
            zero_prefix = pos_prefix
            zero_mask   = pos_mask
            zero_suffix = pos_suffix
            have_zMask = .false
        end
    else
        do
-- ascertain that single and/or double quotes are paired
            have_zMask = .true
            if Wzero_mask~pos("'") > 0 then
                do
                    if Wzero_mask~countStr("'") // 2 \= 0 then
                        raise syntax 93.900 array('Single Quotes Must Be Matched In The Zero Pattern')
                end

            if Wzero_mask~pos('"') > 0 then
                do
                    if Wzero_mask~countStr('"') // 2 \= 0 then
                        raise syntax 93.900 array('Double Quotes Must Be Matched In The Zero Pattern')
                end
-- set up used variables and strip the quotes
            zero_prefix = ''
            zero_mask   = Wzero_mask~strip('b',"'")
            zero_mask   = zero_mask~strip('b','"')
            zero_suffix = ''
        end

::method getPattern
    expose mask
return mask

::method setPattern
    expose mask
    use arg mask
    self~validateMask
return 0

::method format
    expose pos_prefix pos_mask pos_suffix neg_prefix neg_mask neg_suffix zero_prefix zero_mask zero_suffix input have_zMask separators
    use arg input
    numeric digits 30
    if arg(1,'o') then
        raise syntax 93.903 array('Decimal Number',1, arg(1))
    if \input~datatype('n') then
        raise syntax 93.904 array(1,arg(1))
    save_input = input
    input = input~abs()
    select
        when save_input~abs = 0 & have_zMask then
            do
                output = zero_mask
            end
        when save_input = 0 then
            do
                output = self~format2(zero_mask)
                output = zero_prefix||output||zero_suffix
            end
        when save_input > 0 then
            do
                output = self~format2(pos_mask)
                output = pos_prefix||output||pos_suffix
            end
        when save_input < 0 then
            do
                output = self~format2(neg_mask)
                output = neg_prefix||output||neg_suffix
-- the format in ~format2 may have produced a 0 value
                if output == '-0' then
                    output = 0
            end
        otherwise
            nop
    end
    if separators \= ',.' then
        do
            output = output~changeStr(',',.endOfLine)
            output = output~changeStr('.',separators~right(1))
            output = output~changeStr(.endOfLine,separators~left(1))
        end

return output

::method format2
    expose output input output zero_mask have_zMask groupingSize
    use arg mask2use
    numeric digits 30
    parse var mask2use m_part1'.'m_part2
    if m_part2 \== '' then
        do
            input = input~format(,m_part2~length)
        end
    else
        input = input~format(,0)

    select
        when input = 0 & \have_zMask then
            output = 0
        when input = 0 then
            output = zero_mask
        otherwise
            do
                if m_part2 \== '' & m_part_2~pos('0') < 1 then
                    do
                        input = input~strip('t','0')
                        input = input~strip('t','.')
                    end

                parse var input pt1'.'pt2
            -- deal with pt1
                if m_part1~pos(',') > 0 then
                    do
                        i_int = pt1~reverse
                        output = ''
                        do while i_int <> ''
--                            parse var i_int thousand_part 4 i_int
                            parse var i_int thousand_part =(groupingSize+1) i_int
                            if output == '' then
                                output = thousand_part
                            else
                                output = output','thousand_part
                        end
                        output = output~reverse
                    end
                else
                    output = pt1

                width = m_part1~length
                num01 = m_part1~countStr('0')
                if num01 > 0 then
                    do
                        if output~length < num01 then
                            do until output~length = num01
                                output = '0'||output
                            end
                    end

                if output = '' then
                    output = 0

                if num0 < 1 then
                    output = output~strip('l','0')

                op_pt1 = output

            -- deal with pt2
                if pt2 = '' then
                    do
                        num02 = m_part2~countStr('0')
                        if num02 < 1 then
                            output = op_pt1
                        else
                            do
                                output = op_pt1'.'||'0'~copies(num02)
                            end
                    end
                else
                    do
                        op_pt2 = pt2
                        width = m_part2~length
                        num02 = m_part2~countStr('0')
                        if num02 > 1 then
                            do
                                if op_pt2~length < width then
                                    do until op_pt2~length = width
                                        op_pt2 = op_pt2||'0'
                                    end
                            end
                        output = op_pt1'.'op_pt2
                    end

                if num01 = 0 then
                    do
                        output = output~strip('l','0')
                        if output = '' then
                            output = 0
                    end
            end
    end
return output


