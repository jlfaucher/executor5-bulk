/*
* generated by Xtext
*/
package org.oorexx.workbench.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.oorexx.workbench.services.RexxGrammarAccess;

import com.google.inject.Inject;

public class RexxParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private RexxGrammarAccess grammarAccess;
	
	@Override	
	public RexxGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new File_Group(this, this, 0, inst);
			case 1: return new Instruction_Group(this, this, 1, inst);
			case 2: return new Assignment_Group(this, this, 2, inst);
			case 3: return new If_Group(this, this, 3, inst);
			case 4: return new Do_Group(this, this, 4, inst);
			case 5: return new Call_Group(this, this, 5, inst);
			case 6: return new Arg_Group(this, this, 6, inst);
			case 7: return new UseArg_Group(this, this, 7, inst);
			case 8: return new UseArgs_Group(this, this, 8, inst);
			case 9: return new Arguments_Group(this, this, 9, inst);
			case 10: return new Raise_Group(this, this, 10, inst);
			case 11: return new Expression_Alternatives(this, this, 11, inst);
			case 12: return new ArrayAccess_Group(this, this, 12, inst);
			case 13: return new FnCall_Group(this, this, 13, inst);
			case 14: return new Message_Group(this, this, 14, inst);
			case 15: return new Negate_Group(this, this, 15, inst);
			case 16: return new Const_Group(this, this, 16, inst);
			case 17: return new Directives_Alternatives(this, this, 17, inst);
			case 18: return new Class_Group(this, this, 18, inst);
			case 19: return new ClassContent_Alternatives(this, this, 19, inst);
			case 20: return new Method_Group(this, this, 20, inst);
			case 21: return new Attribute_Group(this, this, 21, inst);
			case 22: return new AttributeSet_Group(this, this, 22, inst);
			case 23: return new AttributeGet_Group(this, this, 23, inst);
			case 24: return new AttributeNormal_Group(this, this, 24, inst);
			case 25: return new Constant_Group(this, this, 25, inst);
			case 26: return new Routine_Group(this, this, 26, inst);
			case 27: return new Requires_Group(this, this, 27, inst);
			case 28: return new Options_Group(this, this, 28, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule File ****************
 *
 * File:
 *   {File} TERM* instructions+=Instruction* requires+=Requires* methods+=Method*
 *   directives+=Directives*;
 *
 **/

// {File} TERM* instructions+=Instruction* requires+=Requires* methods+=Method*
// directives+=Directives*
protected class File_Group extends GroupToken {
	
	public File_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFileAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new File_DirectivesAssignment_5(parent, this, 0, inst);
			case 1: return new File_MethodsAssignment_4(parent, this, 1, inst);
			case 2: return new File_RequiresAssignment_3(parent, this, 2, inst);
			case 3: return new File_InstructionsAssignment_2(parent, this, 3, inst);
			case 4: return new File_TERMTerminalRuleCall_1(parent, this, 4, inst);
			case 5: return new File_FileAction_0(parent, this, 5, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFileRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {File}
protected class File_FileAction_0 extends ActionToken  {

	public File_FileAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getFileAccess().getFileAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getFileAccess().getFileAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// TERM*
protected class File_TERMTerminalRuleCall_1 extends UnassignedTextToken {

	public File_TERMTerminalRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFileAccess().getTERMTerminalRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new File_TERMTerminalRuleCall_1(parent, this, 0, inst);
			case 1: return new File_FileAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// instructions+=Instruction*
protected class File_InstructionsAssignment_2 extends AssignmentToken  {
	
	public File_InstructionsAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFileAccess().getInstructionsAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("instructions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("instructions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInstructionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFileAccess().getInstructionsInstructionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new File_InstructionsAssignment_2(parent, next, actIndex, consumed);
			case 1: return new File_TERMTerminalRuleCall_1(parent, next, actIndex, consumed);
			case 2: return new File_FileAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// requires+=Requires*
protected class File_RequiresAssignment_3 extends AssignmentToken  {
	
	public File_RequiresAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFileAccess().getRequiresAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Requires_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("requires",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("requires");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRequiresRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFileAccess().getRequiresRequiresParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new File_RequiresAssignment_3(parent, next, actIndex, consumed);
			case 1: return new File_InstructionsAssignment_2(parent, next, actIndex, consumed);
			case 2: return new File_TERMTerminalRuleCall_1(parent, next, actIndex, consumed);
			case 3: return new File_FileAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// methods+=Method*
protected class File_MethodsAssignment_4 extends AssignmentToken  {
	
	public File_MethodsAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFileAccess().getMethodsAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Method_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("methods",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("methods");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMethodRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFileAccess().getMethodsMethodParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new File_MethodsAssignment_4(parent, next, actIndex, consumed);
			case 1: return new File_RequiresAssignment_3(parent, next, actIndex, consumed);
			case 2: return new File_InstructionsAssignment_2(parent, next, actIndex, consumed);
			case 3: return new File_TERMTerminalRuleCall_1(parent, next, actIndex, consumed);
			case 4: return new File_FileAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// directives+=Directives*
protected class File_DirectivesAssignment_5 extends AssignmentToken  {
	
	public File_DirectivesAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFileAccess().getDirectivesAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Directives_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("directives",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("directives");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDirectivesRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFileAccess().getDirectivesDirectivesParserRuleCall_5_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new File_DirectivesAssignment_5(parent, next, actIndex, consumed);
			case 1: return new File_MethodsAssignment_4(parent, next, actIndex, consumed);
			case 2: return new File_RequiresAssignment_3(parent, next, actIndex, consumed);
			case 3: return new File_InstructionsAssignment_2(parent, next, actIndex, consumed);
			case 4: return new File_TERMTerminalRuleCall_1(parent, next, actIndex, consumed);
			case 5: return new File_FileAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule File ****************/


/************ begin Rule Instruction ****************
 *
 * Instruction:
 *   (Assignment|Do|If|Call|Arg|UseArg|Raise|Message) TERM+;
 *
 **/

// (Assignment|Do|If|Call|Arg|UseArg|Raise|Message) TERM+
protected class Instruction_Group extends GroupToken {
	
	public Instruction_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInstructionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_TERMTerminalRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getInstructionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Assignment|Do|If|Call|Arg|UseArg|Raise|Message
protected class Instruction_Alternatives_0 extends AlternativesToken {

	public Instruction_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getInstructionAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_AssignmentParserRuleCall_0_0(parent, this, 0, inst);
			case 1: return new Instruction_DoParserRuleCall_0_1(parent, this, 1, inst);
			case 2: return new Instruction_IfParserRuleCall_0_2(parent, this, 2, inst);
			case 3: return new Instruction_CallParserRuleCall_0_3(parent, this, 3, inst);
			case 4: return new Instruction_ArgParserRuleCall_0_4(parent, this, 4, inst);
			case 5: return new Instruction_UseArgParserRuleCall_0_5(parent, this, 5, inst);
			case 6: return new Instruction_RaiseParserRuleCall_0_6(parent, this, 6, inst);
			case 7: return new Instruction_MessageParserRuleCall_0_7(parent, this, 7, inst);
			default: return null;
		}	
	}	
		
}

// Assignment
protected class Instruction_AssignmentParserRuleCall_0_0 extends RuleCallToken {
	
	public Instruction_AssignmentParserRuleCall_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getAssignmentParserRuleCall_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Assignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Do
protected class Instruction_DoParserRuleCall_0_1 extends RuleCallToken {
	
	public Instruction_DoParserRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getDoParserRuleCall_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Do_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Do_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getDoRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// If
protected class Instruction_IfParserRuleCall_0_2 extends RuleCallToken {
	
	public Instruction_IfParserRuleCall_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getIfParserRuleCall_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new If_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(If_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIfRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Call
protected class Instruction_CallParserRuleCall_0_3 extends RuleCallToken {
	
	public Instruction_CallParserRuleCall_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getCallParserRuleCall_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Call_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Call_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Arg
protected class Instruction_ArgParserRuleCall_0_4 extends RuleCallToken {
	
	public Instruction_ArgParserRuleCall_0_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getArgParserRuleCall_0_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Arg_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Arg_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getArgRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// UseArg
protected class Instruction_UseArgParserRuleCall_0_5 extends RuleCallToken {
	
	public Instruction_UseArgParserRuleCall_0_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getUseArgParserRuleCall_0_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UseArg_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(UseArg_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getUseArgRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Raise
protected class Instruction_RaiseParserRuleCall_0_6 extends RuleCallToken {
	
	public Instruction_RaiseParserRuleCall_0_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getRaiseParserRuleCall_0_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Raise_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Raise_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRaiseRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Message
protected class Instruction_MessageParserRuleCall_0_7 extends RuleCallToken {
	
	public Instruction_MessageParserRuleCall_0_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getMessageParserRuleCall_0_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Message_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Message_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMessageRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


// TERM+
protected class Instruction_TERMTerminalRuleCall_1 extends UnassignedTextToken {

	public Instruction_TERMTerminalRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getInstructionAccess().getTERMTerminalRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_TERMTerminalRuleCall_1(parent, this, 0, inst);
			case 1: return new Instruction_Alternatives_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Instruction ****************/


/************ begin Rule Assignment ****************
 *
 * Assignment:
 *   target=Name "=" expression=Expression;
 *
 **/

// target=Name "=" expression=Expression
protected class Assignment_Group extends GroupToken {
	
	public Assignment_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_ExpressionAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// target=Name
protected class Assignment_TargetAssignment_0 extends AssignmentToken  {
	
	public Assignment_TargetAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getTargetAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getAssignmentAccess().getTargetNameParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// "="
protected class Assignment_EqualsSignKeyword_1 extends KeywordToken  {
	
	public Assignment_EqualsSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getEqualsSignKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_TargetAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expression=Expression
protected class Assignment_ExpressionAssignment_2 extends AssignmentToken  {
	
	public Assignment_ExpressionAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getExpressionAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAssignmentAccess().getExpressionExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Assignment_EqualsSignKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Assignment ****************/


/************ begin Rule If ****************
 *
 * If:
 *   "if" expression=Expression "then" TERM* topInstr=Instruction ("else" TERM* bottomInstr=
 *   Instruction)?;
 *
 **/

// "if" expression=Expression "then" TERM* topInstr=Instruction ("else" TERM* bottomInstr=
// Instruction)?
protected class If_Group extends GroupToken {
	
	public If_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIfAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new If_Group_5(parent, this, 0, inst);
			case 1: return new If_TopInstrAssignment_4(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIfRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "if"
protected class If_IfKeyword_0 extends KeywordToken  {
	
	public If_IfKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfAccess().getIfKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// expression=Expression
protected class If_ExpressionAssignment_1 extends AssignmentToken  {
	
	public If_ExpressionAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfAccess().getExpressionAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfAccess().getExpressionExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new If_IfKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "then"
protected class If_ThenKeyword_2 extends KeywordToken  {
	
	public If_ThenKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfAccess().getThenKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new If_ExpressionAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// TERM*
protected class If_TERMTerminalRuleCall_3 extends UnassignedTextToken {

	public If_TERMTerminalRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getIfAccess().getTERMTerminalRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new If_TERMTerminalRuleCall_3(parent, this, 0, inst);
			case 1: return new If_ThenKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// topInstr=Instruction
protected class If_TopInstrAssignment_4 extends AssignmentToken  {
	
	public If_TopInstrAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfAccess().getTopInstrAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("topInstr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("topInstr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInstructionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfAccess().getTopInstrInstructionParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new If_TERMTerminalRuleCall_3(parent, next, actIndex, consumed);
			case 1: return new If_ThenKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("else" TERM* bottomInstr=Instruction)?
protected class If_Group_5 extends GroupToken {
	
	public If_Group_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIfAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new If_BottomInstrAssignment_5_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "else"
protected class If_ElseKeyword_5_0 extends KeywordToken  {
	
	public If_ElseKeyword_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfAccess().getElseKeyword_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new If_TopInstrAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// TERM*
protected class If_TERMTerminalRuleCall_5_1 extends UnassignedTextToken {

	public If_TERMTerminalRuleCall_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getIfAccess().getTERMTerminalRuleCall_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new If_TERMTerminalRuleCall_5_1(parent, this, 0, inst);
			case 1: return new If_ElseKeyword_5_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// bottomInstr=Instruction
protected class If_BottomInstrAssignment_5_2 extends AssignmentToken  {
	
	public If_BottomInstrAssignment_5_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfAccess().getBottomInstrAssignment_5_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("bottomInstr",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("bottomInstr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInstructionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfAccess().getBottomInstrInstructionParserRuleCall_5_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new If_TERMTerminalRuleCall_5_1(parent, next, actIndex, consumed);
			case 1: return new If_ElseKeyword_5_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule If ****************/


/************ begin Rule Do ****************
 *
 * Do:
 *   "do" TERM+ instrs+=Instruction+ "end";
 *
 **/

// "do" TERM+ instrs+=Instruction+ "end"
protected class Do_Group extends GroupToken {
	
	public Do_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDoAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Do_EndKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDoRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "do"
protected class Do_DoKeyword_0 extends KeywordToken  {
	
	public Do_DoKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDoAccess().getDoKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// TERM+
protected class Do_TERMTerminalRuleCall_1 extends UnassignedTextToken {

	public Do_TERMTerminalRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDoAccess().getTERMTerminalRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Do_TERMTerminalRuleCall_1(parent, this, 0, inst);
			case 1: return new Do_DoKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// instrs+=Instruction+
protected class Do_InstrsAssignment_2 extends AssignmentToken  {
	
	public Do_InstrsAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDoAccess().getInstrsAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("instrs",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("instrs");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInstructionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDoAccess().getInstrsInstructionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Do_InstrsAssignment_2(parent, next, actIndex, consumed);
			case 1: return new Do_TERMTerminalRuleCall_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "end"
protected class Do_EndKeyword_3 extends KeywordToken  {
	
	public Do_EndKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDoAccess().getEndKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Do_InstrsAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Do ****************/


/************ begin Rule Call ****************
 *
 * Call:
 *   "call" name=Name args=Arguments;
 *
 **/

// "call" name=Name args=Arguments
protected class Call_Group extends GroupToken {
	
	public Call_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCallAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Call_ArgsAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCallRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "call"
protected class Call_CallKeyword_0 extends KeywordToken  {
	
	public Call_CallKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCallAccess().getCallKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=Name
protected class Call_NameAssignment_1 extends AssignmentToken  {
	
	public Call_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCallAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Call_CallKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getCallAccess().getNameNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// args=Arguments
protected class Call_ArgsAssignment_2 extends AssignmentToken  {
	
	public Call_ArgsAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCallAccess().getArgsAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Arguments_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("args",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("args");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getArgumentsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCallAccess().getArgsArgumentsParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Call_NameAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Call ****************/


/************ begin Rule Arg ****************
 *
 * Arg:
 *   {Arg} "arg" (args+=Name ("," args+=Name)*)?;
 *
 **/

// {Arg} "arg" (args+=Name ("," args+=Name)*)?
protected class Arg_Group extends GroupToken {
	
	public Arg_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getArgAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Arg_Group_2(parent, this, 0, inst);
			case 1: return new Arg_ArgKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getArgRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {Arg}
protected class Arg_ArgAction_0 extends ActionToken  {

	public Arg_ArgAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getArgAccess().getArgAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getArgAccess().getArgAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "arg"
protected class Arg_ArgKeyword_1 extends KeywordToken  {
	
	public Arg_ArgKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getArgAccess().getArgKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Arg_ArgAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (args+=Name ("," args+=Name)*)?
protected class Arg_Group_2 extends GroupToken {
	
	public Arg_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getArgAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Arg_Group_2_1(parent, this, 0, inst);
			case 1: return new Arg_ArgsAssignment_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// args+=Name
protected class Arg_ArgsAssignment_2_0 extends AssignmentToken  {
	
	public Arg_ArgsAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getArgAccess().getArgsAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Arg_ArgKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("args",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("args");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getArgAccess().getArgsNameParserRuleCall_2_0_0();
			return obj;
		}
		return null;
	}

}

// ("," args+=Name)*
protected class Arg_Group_2_1 extends GroupToken {
	
	public Arg_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getArgAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Arg_ArgsAssignment_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Arg_CommaKeyword_2_1_0 extends KeywordToken  {
	
	public Arg_CommaKeyword_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getArgAccess().getCommaKeyword_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Arg_Group_2_1(parent, this, 0, inst);
			case 1: return new Arg_ArgsAssignment_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// args+=Name
protected class Arg_ArgsAssignment_2_1_1 extends AssignmentToken  {
	
	public Arg_ArgsAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getArgAccess().getArgsAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Arg_CommaKeyword_2_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("args",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("args");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getArgAccess().getArgsNameParserRuleCall_2_1_1_0();
			return obj;
		}
		return null;
	}

}




/************ end Rule Arg ****************/


/************ begin Rule UseArg ****************
 *
 * UseArg:
 *   {UseArg} "use" strict?="strict"? "arg" (args+=UseArgs ("," args+=UseArgs)*)?;
 *
 **/

// {UseArg} "use" strict?="strict"? "arg" (args+=UseArgs ("," args+=UseArgs)*)?
protected class UseArg_Group extends GroupToken {
	
	public UseArg_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUseArgAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UseArg_Group_4(parent, this, 0, inst);
			case 1: return new UseArg_ArgKeyword_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUseArgRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {UseArg}
protected class UseArg_UseArgAction_0 extends ActionToken  {

	public UseArg_UseArgAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getUseArgAccess().getUseArgAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getUseArgAccess().getUseArgAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "use"
protected class UseArg_UseKeyword_1 extends KeywordToken  {
	
	public UseArg_UseKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUseArgAccess().getUseKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UseArg_UseArgAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// strict?="strict"?
protected class UseArg_StrictAssignment_2 extends AssignmentToken  {
	
	public UseArg_StrictAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUseArgAccess().getStrictAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UseArg_UseKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("strict",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("strict");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getUseArgAccess().getStrictStrictKeyword_2_0();
			return obj;
		}
		return null;
	}

}

// "arg"
protected class UseArg_ArgKeyword_3 extends KeywordToken  {
	
	public UseArg_ArgKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUseArgAccess().getArgKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UseArg_StrictAssignment_2(parent, this, 0, inst);
			case 1: return new UseArg_UseKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// (args+=UseArgs ("," args+=UseArgs)*)?
protected class UseArg_Group_4 extends GroupToken {
	
	public UseArg_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUseArgAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UseArg_Group_4_1(parent, this, 0, inst);
			case 1: return new UseArg_ArgsAssignment_4_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// args+=UseArgs
protected class UseArg_ArgsAssignment_4_0 extends AssignmentToken  {
	
	public UseArg_ArgsAssignment_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUseArgAccess().getArgsAssignment_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UseArgs_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("args",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("args");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUseArgsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUseArgAccess().getArgsUseArgsParserRuleCall_4_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UseArg_ArgKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," args+=UseArgs)*
protected class UseArg_Group_4_1 extends GroupToken {
	
	public UseArg_Group_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUseArgAccess().getGroup_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UseArg_ArgsAssignment_4_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class UseArg_CommaKeyword_4_1_0 extends KeywordToken  {
	
	public UseArg_CommaKeyword_4_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUseArgAccess().getCommaKeyword_4_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UseArg_Group_4_1(parent, this, 0, inst);
			case 1: return new UseArg_ArgsAssignment_4_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// args+=UseArgs
protected class UseArg_ArgsAssignment_4_1_1 extends AssignmentToken  {
	
	public UseArg_ArgsAssignment_4_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUseArgAccess().getArgsAssignment_4_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UseArgs_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("args",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("args");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUseArgsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUseArgAccess().getArgsUseArgsParserRuleCall_4_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UseArg_CommaKeyword_4_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule UseArg ****************/


/************ begin Rule UseArgs ****************
 *
 * UseArgs:
 *   name=Name ("=" default=Expression)?;
 *
 **/

// name=Name ("=" default=Expression)?
protected class UseArgs_Group extends GroupToken {
	
	public UseArgs_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUseArgsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UseArgs_Group_1(parent, this, 0, inst);
			case 1: return new UseArgs_NameAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUseArgsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=Name
protected class UseArgs_NameAssignment_0 extends AssignmentToken  {
	
	public UseArgs_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUseArgsAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getUseArgsAccess().getNameNameParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ("=" default=Expression)?
protected class UseArgs_Group_1 extends GroupToken {
	
	public UseArgs_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUseArgsAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UseArgs_DefaultAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "="
protected class UseArgs_EqualsSignKeyword_1_0 extends KeywordToken  {
	
	public UseArgs_EqualsSignKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUseArgsAccess().getEqualsSignKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UseArgs_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// default=Expression
protected class UseArgs_DefaultAssignment_1_1 extends AssignmentToken  {
	
	public UseArgs_DefaultAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUseArgsAccess().getDefaultAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("default",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("default");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUseArgsAccess().getDefaultExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UseArgs_EqualsSignKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule UseArgs ****************/


/************ begin Rule Arguments ****************
 *
 * Arguments:
 *   {Arguments} (arguments+=Expression ("," arguments+=Expression)*)?;
 *
 **/

// {Arguments} (arguments+=Expression ("," arguments+=Expression)*)?
protected class Arguments_Group extends GroupToken {
	
	public Arguments_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getArgumentsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Arguments_Group_1(parent, this, 0, inst);
			case 1: return new Arguments_ArgumentsAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getArgumentsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {Arguments}
protected class Arguments_ArgumentsAction_0 extends ActionToken  {

	public Arguments_ArgumentsAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getArgumentsAccess().getArgumentsAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getArgumentsAccess().getArgumentsAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// (arguments+=Expression ("," arguments+=Expression)*)?
protected class Arguments_Group_1 extends GroupToken {
	
	public Arguments_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getArgumentsAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Arguments_Group_1_1(parent, this, 0, inst);
			case 1: return new Arguments_ArgumentsAssignment_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// arguments+=Expression
protected class Arguments_ArgumentsAssignment_1_0 extends AssignmentToken  {
	
	public Arguments_ArgumentsAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getArgumentsAccess().getArgumentsAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("arguments",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("arguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getArgumentsAccess().getArgumentsExpressionParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Arguments_ArgumentsAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," arguments+=Expression)*
protected class Arguments_Group_1_1 extends GroupToken {
	
	public Arguments_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getArgumentsAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Arguments_ArgumentsAssignment_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Arguments_CommaKeyword_1_1_0 extends KeywordToken  {
	
	public Arguments_CommaKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getArgumentsAccess().getCommaKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Arguments_Group_1_1(parent, this, 0, inst);
			case 1: return new Arguments_ArgumentsAssignment_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// arguments+=Expression
protected class Arguments_ArgumentsAssignment_1_1_1 extends AssignmentToken  {
	
	public Arguments_ArgumentsAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getArgumentsAccess().getArgumentsAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("arguments",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("arguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getArgumentsAccess().getArgumentsExpressionParserRuleCall_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Arguments_CommaKeyword_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule Arguments ****************/


/************ begin Rule Raise ****************
 *
 * Raise:
 *   "raise" "syntax" mayor=SYMBOL_NUM ("." minor=SYMBOL_NUM);
 *
 **/

// "raise" "syntax" mayor=SYMBOL_NUM ("." minor=SYMBOL_NUM)
protected class Raise_Group extends GroupToken {
	
	public Raise_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRaiseAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Raise_Group_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRaiseRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "raise"
protected class Raise_RaiseKeyword_0 extends KeywordToken  {
	
	public Raise_RaiseKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRaiseAccess().getRaiseKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "syntax"
protected class Raise_SyntaxKeyword_1 extends KeywordToken  {
	
	public Raise_SyntaxKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRaiseAccess().getSyntaxKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Raise_RaiseKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// mayor=SYMBOL_NUM
protected class Raise_MayorAssignment_2 extends AssignmentToken  {
	
	public Raise_MayorAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRaiseAccess().getMayorAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Raise_SyntaxKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("mayor",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("mayor");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getRaiseAccess().getMayorSYMBOL_NUMTerminalRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// "." minor=SYMBOL_NUM
protected class Raise_Group_3 extends GroupToken {
	
	public Raise_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRaiseAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Raise_MinorAssignment_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "."
protected class Raise_FullStopKeyword_3_0 extends KeywordToken  {
	
	public Raise_FullStopKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRaiseAccess().getFullStopKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Raise_MayorAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// minor=SYMBOL_NUM
protected class Raise_MinorAssignment_3_1 extends AssignmentToken  {
	
	public Raise_MinorAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRaiseAccess().getMinorAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Raise_FullStopKeyword_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("minor",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("minor");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getRaiseAccess().getMinorSYMBOL_NUMTerminalRuleCall_3_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule Raise ****************/


/************ begin Rule Expression ****************
 *
 * Expression:
 *   {ExprVar} name=Name|fnCall|Message|ArrayAccess|Negate|Const;
 *
 **/

// {ExprVar} name=Name|fnCall|Message|ArrayAccess|Negate|Const
protected class Expression_Alternatives extends AlternativesToken {

	public Expression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Group_0(parent, this, 0, inst);
			case 1: return new Expression_FnCallParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Expression_MessageParserRuleCall_2(parent, this, 2, inst);
			case 3: return new Expression_ArrayAccessParserRuleCall_3(parent, this, 3, inst);
			case 4: return new Expression_NegateParserRuleCall_4(parent, this, 4, inst);
			case 5: return new Expression_ConstParserRuleCall_5(parent, this, 5, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {ExprVar} name=Name
protected class Expression_Group_0 extends GroupToken {
	
	public Expression_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExpressionAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_NameAssignment_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {ExprVar}
protected class Expression_ExprVarAction_0_0 extends ActionToken  {

	public Expression_ExprVarAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getExpressionAccess().getExprVarAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getExpressionAccess().getExprVarAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// name=Name
protected class Expression_NameAssignment_0_1 extends AssignmentToken  {
	
	public Expression_NameAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExpressionAccess().getNameAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ExprVarAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getExpressionAccess().getNameNameParserRuleCall_0_1_0();
			return obj;
		}
		return null;
	}

}


// fnCall
protected class Expression_FnCallParserRuleCall_1 extends RuleCallToken {
	
	public Expression_FnCallParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getFnCallParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FnCall_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FnCall_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFnCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Message
protected class Expression_MessageParserRuleCall_2 extends RuleCallToken {
	
	public Expression_MessageParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getMessageParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Message_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Message_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMessageRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ArrayAccess
protected class Expression_ArrayAccessParserRuleCall_3 extends RuleCallToken {
	
	public Expression_ArrayAccessParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getArrayAccessParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArrayAccess_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ArrayAccess_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getArrayAccessRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Negate
protected class Expression_NegateParserRuleCall_4 extends RuleCallToken {
	
	public Expression_NegateParserRuleCall_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getNegateParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Negate_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Negate_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNegateRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Const
protected class Expression_ConstParserRuleCall_5 extends RuleCallToken {
	
	public Expression_ConstParserRuleCall_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getConstParserRuleCall_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Const_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Const_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getConstRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Expression ****************/


/************ begin Rule ArrayAccess ****************
 *
 * ArrayAccess:
 *   target=Name "[" index=Expression "]";
 *
 **/

// target=Name "[" index=Expression "]"
protected class ArrayAccess_Group extends GroupToken {
	
	public ArrayAccess_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getArrayAccessAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArrayAccess_RightSquareBracketKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getArrayAccessRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// target=Name
protected class ArrayAccess_TargetAssignment_0 extends AssignmentToken  {
	
	public ArrayAccess_TargetAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getArrayAccessAccess().getTargetAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getArrayAccessAccess().getTargetNameParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// "["
protected class ArrayAccess_LeftSquareBracketKeyword_1 extends KeywordToken  {
	
	public ArrayAccess_LeftSquareBracketKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getArrayAccessAccess().getLeftSquareBracketKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArrayAccess_TargetAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// index=Expression
protected class ArrayAccess_IndexAssignment_2 extends AssignmentToken  {
	
	public ArrayAccess_IndexAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getArrayAccessAccess().getIndexAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("index",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("index");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getArrayAccessAccess().getIndexExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ArrayAccess_LeftSquareBracketKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "]"
protected class ArrayAccess_RightSquareBracketKeyword_3 extends KeywordToken  {
	
	public ArrayAccess_RightSquareBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getArrayAccessAccess().getRightSquareBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArrayAccess_IndexAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ArrayAccess ****************/


/************ begin Rule fnCall ****************
 *
 * fnCall:
 *   target=Name "(" args=Arguments ")";
 *
 **/

// target=Name "(" args=Arguments ")"
protected class FnCall_Group extends GroupToken {
	
	public FnCall_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFnCallAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FnCall_RightParenthesisKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFnCallRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// target=Name
protected class FnCall_TargetAssignment_0 extends AssignmentToken  {
	
	public FnCall_TargetAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFnCallAccess().getTargetAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getFnCallAccess().getTargetNameParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// "("
protected class FnCall_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public FnCall_LeftParenthesisKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFnCallAccess().getLeftParenthesisKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FnCall_TargetAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// args=Arguments
protected class FnCall_ArgsAssignment_2 extends AssignmentToken  {
	
	public FnCall_ArgsAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFnCallAccess().getArgsAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Arguments_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("args",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("args");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getArgumentsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFnCallAccess().getArgsArgumentsParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FnCall_LeftParenthesisKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class FnCall_RightParenthesisKeyword_3 extends KeywordToken  {
	
	public FnCall_RightParenthesisKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFnCallAccess().getRightParenthesisKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FnCall_ArgsAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule fnCall ****************/


/************ begin Rule Message ****************
 *
 * Message:
 *   target=Name "~" discard?="~"? message=Name (":" scope=Name)? ("(" args=Arguments ")"|"="
 *   value=Expression)?;
 *
 **/

// target=Name "~" discard?="~"? message=Name (":" scope=Name)? ("(" args=Arguments ")"|"="
// value=Expression)?
protected class Message_Group extends GroupToken {
	
	public Message_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMessageAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Message_Alternatives_5(parent, this, 0, inst);
			case 1: return new Message_Group_4(parent, this, 1, inst);
			case 2: return new Message_MessageAssignment_3(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMessageRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// target=Name
protected class Message_TargetAssignment_0 extends AssignmentToken  {
	
	public Message_TargetAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMessageAccess().getTargetAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getMessageAccess().getTargetNameParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// "~"
protected class Message_TildeKeyword_1 extends KeywordToken  {
	
	public Message_TildeKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMessageAccess().getTildeKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Message_TargetAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// discard?="~"?
protected class Message_DiscardAssignment_2 extends AssignmentToken  {
	
	public Message_DiscardAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMessageAccess().getDiscardAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Message_TildeKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("discard",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("discard");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getMessageAccess().getDiscardTildeKeyword_2_0();
			return obj;
		}
		return null;
	}

}

// message=Name
protected class Message_MessageAssignment_3 extends AssignmentToken  {
	
	public Message_MessageAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMessageAccess().getMessageAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Message_DiscardAssignment_2(parent, this, 0, inst);
			case 1: return new Message_TildeKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("message",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("message");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getMessageAccess().getMessageNameParserRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// (":" scope=Name)?
protected class Message_Group_4 extends GroupToken {
	
	public Message_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMessageAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Message_ScopeAssignment_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class Message_ColonKeyword_4_0 extends KeywordToken  {
	
	public Message_ColonKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMessageAccess().getColonKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Message_MessageAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// scope=Name
protected class Message_ScopeAssignment_4_1 extends AssignmentToken  {
	
	public Message_ScopeAssignment_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMessageAccess().getScopeAssignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Message_ColonKeyword_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("scope",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("scope");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getMessageAccess().getScopeNameParserRuleCall_4_1_0();
			return obj;
		}
		return null;
	}

}


// ("(" args=Arguments ")"|"=" value=Expression)?
protected class Message_Alternatives_5 extends AlternativesToken {

	public Message_Alternatives_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getMessageAccess().getAlternatives_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Message_Group_5_0(parent, this, 0, inst);
			case 1: return new Message_Group_5_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "(" args=Arguments ")"
protected class Message_Group_5_0 extends GroupToken {
	
	public Message_Group_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMessageAccess().getGroup_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Message_RightParenthesisKeyword_5_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class Message_LeftParenthesisKeyword_5_0_0 extends KeywordToken  {
	
	public Message_LeftParenthesisKeyword_5_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMessageAccess().getLeftParenthesisKeyword_5_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Message_Group_4(parent, this, 0, inst);
			case 1: return new Message_MessageAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// args=Arguments
protected class Message_ArgsAssignment_5_0_1 extends AssignmentToken  {
	
	public Message_ArgsAssignment_5_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMessageAccess().getArgsAssignment_5_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Arguments_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("args",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("args");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getArgumentsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMessageAccess().getArgsArgumentsParserRuleCall_5_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Message_LeftParenthesisKeyword_5_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class Message_RightParenthesisKeyword_5_0_2 extends KeywordToken  {
	
	public Message_RightParenthesisKeyword_5_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMessageAccess().getRightParenthesisKeyword_5_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Message_ArgsAssignment_5_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "=" value=Expression
protected class Message_Group_5_1 extends GroupToken {
	
	public Message_Group_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMessageAccess().getGroup_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Message_ValueAssignment_5_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "="
protected class Message_EqualsSignKeyword_5_1_0 extends KeywordToken  {
	
	public Message_EqualsSignKeyword_5_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMessageAccess().getEqualsSignKeyword_5_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Message_Group_4(parent, this, 0, inst);
			case 1: return new Message_MessageAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// value=Expression
protected class Message_ValueAssignment_5_1_1 extends AssignmentToken  {
	
	public Message_ValueAssignment_5_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMessageAccess().getValueAssignment_5_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMessageAccess().getValueExpressionParserRuleCall_5_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Message_EqualsSignKeyword_5_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule Message ****************/


/************ begin Rule Negate ****************
 *
 * Negate:
 *   "\\" expression=Expression;
 *
 **/

// "\\" expression=Expression
protected class Negate_Group extends GroupToken {
	
	public Negate_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNegateAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Negate_ExpressionAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNegateRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "\\"
protected class Negate_ReverseSolidusKeyword_0 extends KeywordToken  {
	
	public Negate_ReverseSolidusKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNegateAccess().getReverseSolidusKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// expression=Expression
protected class Negate_ExpressionAssignment_1 extends AssignmentToken  {
	
	public Negate_ExpressionAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNegateAccess().getExpressionAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNegateAccess().getExpressionExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Negate_ReverseSolidusKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Negate ****************/


/************ begin Rule Const ****************
 *
 * Const:
 *   {Const} value=( SYMBOL_NUM | STRING_BOOL | STRING_HEX );
 *
 **/

// {Const} value=( SYMBOL_NUM | STRING_BOOL | STRING_HEX )
protected class Const_Group extends GroupToken {
	
	public Const_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Const_ValueAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConstRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {Const}
protected class Const_ConstAction_0 extends ActionToken  {

	public Const_ConstAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getConstAccess().getConstAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getConstAccess().getConstAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// value=( SYMBOL_NUM | STRING_BOOL | STRING_HEX )
protected class Const_ValueAssignment_1 extends AssignmentToken  {
	
	public Const_ValueAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstAccess().getValueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Const_ConstAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getConstAccess().getValueSYMBOL_NUMTerminalRuleCall_1_0_0();
			return obj;
		}
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getConstAccess().getValueSTRING_BOOLTerminalRuleCall_1_0_1();
			return obj;
		}
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getConstAccess().getValueSTRING_HEXTerminalRuleCall_1_0_2();
			return obj;
		}
		return null;
	}

}


/************ end Rule Const ****************/


/************ begin Rule Directives ****************
 *
 * Directives:
 *   Class|Options|Routine;
 *
 **/

// Class|Options|Routine
protected class Directives_Alternatives extends AlternativesToken {

	public Directives_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getDirectivesAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Directives_ClassParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Directives_OptionsParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Directives_RoutineParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDirectivesRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Class
protected class Directives_ClassParserRuleCall_0 extends RuleCallToken {
	
	public Directives_ClassParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDirectivesAccess().getClassParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Class_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getClassRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Options
protected class Directives_OptionsParserRuleCall_1 extends RuleCallToken {
	
	public Directives_OptionsParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDirectivesAccess().getOptionsParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Options_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Options_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOptionsRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Routine
protected class Directives_RoutineParserRuleCall_2 extends RuleCallToken {
	
	public Directives_RoutineParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDirectivesAccess().getRoutineParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Routine_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Routine_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRoutineRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Directives ****************/


/************ begin Rule Class ****************
 *
 * Class:
 *   "::class" name=Name ("metaclass" meta=Name)? ("subclass" subclass=Name|"mixinclass"
 *   mixin=Name)? visibility=VISIBILITY? ("inherit" inherit+=Name+)? TERM+ content+=
 *   ClassContent*;
 *
 **/

// "::class" name=Name ("metaclass" meta=Name)? ("subclass" subclass=Name|"mixinclass"
// mixin=Name)? visibility=VISIBILITY? ("inherit" inherit+=Name+)? TERM+ content+=
// ClassContent*
protected class Class_Group extends GroupToken {
	
	public Class_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClassAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_ContentAssignment_7(parent, this, 0, inst);
			case 1: return new Class_TERMTerminalRuleCall_6(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getClassRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "::class"
protected class Class_ClassKeyword_0 extends KeywordToken  {
	
	public Class_ClassKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getClassKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=Name
protected class Class_NameAssignment_1 extends AssignmentToken  {
	
	public Class_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_ClassKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getClassAccess().getNameNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("metaclass" meta=Name)?
protected class Class_Group_2 extends GroupToken {
	
	public Class_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClassAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_MetaAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "metaclass"
protected class Class_MetaclassKeyword_2_0 extends KeywordToken  {
	
	public Class_MetaclassKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getMetaclassKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// meta=Name
protected class Class_MetaAssignment_2_1 extends AssignmentToken  {
	
	public Class_MetaAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getMetaAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_MetaclassKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("meta",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("meta");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getClassAccess().getMetaNameParserRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}


// ("subclass" subclass=Name|"mixinclass" mixin=Name)?
protected class Class_Alternatives_3 extends AlternativesToken {

	public Class_Alternatives_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getClassAccess().getAlternatives_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_Group_3_0(parent, this, 0, inst);
			case 1: return new Class_Group_3_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "subclass" subclass=Name
protected class Class_Group_3_0 extends GroupToken {
	
	public Class_Group_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClassAccess().getGroup_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_SubclassAssignment_3_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "subclass"
protected class Class_SubclassKeyword_3_0_0 extends KeywordToken  {
	
	public Class_SubclassKeyword_3_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getSubclassKeyword_3_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_Group_2(parent, this, 0, inst);
			case 1: return new Class_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// subclass=Name
protected class Class_SubclassAssignment_3_0_1 extends AssignmentToken  {
	
	public Class_SubclassAssignment_3_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getSubclassAssignment_3_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_SubclassKeyword_3_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subclass",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subclass");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getClassAccess().getSubclassNameParserRuleCall_3_0_1_0();
			return obj;
		}
		return null;
	}

}


// "mixinclass" mixin=Name
protected class Class_Group_3_1 extends GroupToken {
	
	public Class_Group_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClassAccess().getGroup_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_MixinAssignment_3_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "mixinclass"
protected class Class_MixinclassKeyword_3_1_0 extends KeywordToken  {
	
	public Class_MixinclassKeyword_3_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getMixinclassKeyword_3_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_Group_2(parent, this, 0, inst);
			case 1: return new Class_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// mixin=Name
protected class Class_MixinAssignment_3_1_1 extends AssignmentToken  {
	
	public Class_MixinAssignment_3_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getMixinAssignment_3_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_MixinclassKeyword_3_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("mixin",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("mixin");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getClassAccess().getMixinNameParserRuleCall_3_1_1_0();
			return obj;
		}
		return null;
	}

}



// visibility=VISIBILITY?
protected class Class_VisibilityAssignment_4 extends AssignmentToken  {
	
	public Class_VisibilityAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getVisibilityAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_Alternatives_3(parent, this, 0, inst);
			case 1: return new Class_Group_2(parent, this, 1, inst);
			case 2: return new Class_NameAssignment_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("visibility",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("visibility");
		if(Boolean.TRUE.booleanValue()) {  
			type = AssignmentType.ERC;
			element = grammarAccess.getClassAccess().getVisibilityVISIBILITYEnumRuleCall_4_0();
			return obj;
		}
		return null;
	}

}

// ("inherit" inherit+=Name+)?
protected class Class_Group_5 extends GroupToken {
	
	public Class_Group_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClassAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_InheritAssignment_5_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "inherit"
protected class Class_InheritKeyword_5_0 extends KeywordToken  {
	
	public Class_InheritKeyword_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getInheritKeyword_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_VisibilityAssignment_4(parent, this, 0, inst);
			case 1: return new Class_Alternatives_3(parent, this, 1, inst);
			case 2: return new Class_Group_2(parent, this, 2, inst);
			case 3: return new Class_NameAssignment_1(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
}

// inherit+=Name+
protected class Class_InheritAssignment_5_1 extends AssignmentToken  {
	
	public Class_InheritAssignment_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getInheritAssignment_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_InheritAssignment_5_1(parent, this, 0, inst);
			case 1: return new Class_InheritKeyword_5_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("inherit",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("inherit");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getClassAccess().getInheritNameParserRuleCall_5_1_0();
			return obj;
		}
		return null;
	}

}


// TERM+
protected class Class_TERMTerminalRuleCall_6 extends UnassignedTextToken {

	public Class_TERMTerminalRuleCall_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getClassAccess().getTERMTerminalRuleCall_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_TERMTerminalRuleCall_6(parent, this, 0, inst);
			case 1: return new Class_Group_5(parent, this, 1, inst);
			case 2: return new Class_VisibilityAssignment_4(parent, this, 2, inst);
			case 3: return new Class_Alternatives_3(parent, this, 3, inst);
			case 4: return new Class_Group_2(parent, this, 4, inst);
			case 5: return new Class_NameAssignment_1(parent, this, 5, inst);
			default: return null;
		}	
	}	
		
}

// content+=ClassContent*
protected class Class_ContentAssignment_7 extends AssignmentToken  {
	
	public Class_ContentAssignment_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getContentAssignment_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClassContent_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("content",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("content");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getClassContentRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClassAccess().getContentClassContentParserRuleCall_7_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Class_ContentAssignment_7(parent, next, actIndex, consumed);
			case 1: return new Class_TERMTerminalRuleCall_6(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Class ****************/


/************ begin Rule ClassContent ****************
 *
 * ClassContent:
 *   Method|Attribute|Constant;
 *
 **/

// Method|Attribute|Constant
protected class ClassContent_Alternatives extends AlternativesToken {

	public ClassContent_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getClassContentAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ClassContent_MethodParserRuleCall_0(parent, this, 0, inst);
			case 1: return new ClassContent_AttributeParserRuleCall_1(parent, this, 1, inst);
			case 2: return new ClassContent_ConstantParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getClassContentRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Method
protected class ClassContent_MethodParserRuleCall_0 extends RuleCallToken {
	
	public ClassContent_MethodParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getClassContentAccess().getMethodParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Method_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Method_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMethodRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Attribute
protected class ClassContent_AttributeParserRuleCall_1 extends RuleCallToken {
	
	public ClassContent_AttributeParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getClassContentAccess().getAttributeParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Attribute_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Constant
protected class ClassContent_ConstantParserRuleCall_2 extends RuleCallToken {
	
	public ClassContent_ConstantParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getClassContentAccess().getConstantParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Constant_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Constant_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getConstantRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule ClassContent ****************/


/************ begin Rule Method ****************
 *
 * Method:
 *   "::method" name=Name visibility=VISIBILITY? class?="class"? TERM+ ("expose" expose+=
 *   Name+ TERM+)? content+=Instruction*;
 *
 **/

// "::method" name=Name visibility=VISIBILITY? class?="class"? TERM+ ("expose" expose+=
// Name+ TERM+)? content+=Instruction*
protected class Method_Group extends GroupToken {
	
	public Method_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMethodAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Method_ContentAssignment_6(parent, this, 0, inst);
			case 1: return new Method_Group_5(parent, this, 1, inst);
			case 2: return new Method_TERMTerminalRuleCall_4(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMethodRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "::method"
protected class Method_MethodKeyword_0 extends KeywordToken  {
	
	public Method_MethodKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodAccess().getMethodKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=Name
protected class Method_NameAssignment_1 extends AssignmentToken  {
	
	public Method_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Method_MethodKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getMethodAccess().getNameNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// visibility=VISIBILITY?
protected class Method_VisibilityAssignment_2 extends AssignmentToken  {
	
	public Method_VisibilityAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodAccess().getVisibilityAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Method_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("visibility",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("visibility");
		if(Boolean.TRUE.booleanValue()) {  
			type = AssignmentType.ERC;
			element = grammarAccess.getMethodAccess().getVisibilityVISIBILITYEnumRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// class?="class"?
protected class Method_ClassAssignment_3 extends AssignmentToken  {
	
	public Method_ClassAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodAccess().getClassAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Method_VisibilityAssignment_2(parent, this, 0, inst);
			case 1: return new Method_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("class",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("class");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getMethodAccess().getClassClassKeyword_3_0();
			return obj;
		}
		return null;
	}

}

// TERM+
protected class Method_TERMTerminalRuleCall_4 extends UnassignedTextToken {

	public Method_TERMTerminalRuleCall_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getMethodAccess().getTERMTerminalRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Method_TERMTerminalRuleCall_4(parent, this, 0, inst);
			case 1: return new Method_ClassAssignment_3(parent, this, 1, inst);
			case 2: return new Method_VisibilityAssignment_2(parent, this, 2, inst);
			case 3: return new Method_NameAssignment_1(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
}

// ("expose" expose+=Name+ TERM+)?
protected class Method_Group_5 extends GroupToken {
	
	public Method_Group_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMethodAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Method_TERMTerminalRuleCall_5_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "expose"
protected class Method_ExposeKeyword_5_0 extends KeywordToken  {
	
	public Method_ExposeKeyword_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMethodAccess().getExposeKeyword_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Method_TERMTerminalRuleCall_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expose+=Name+
protected class Method_ExposeAssignment_5_1 extends AssignmentToken  {
	
	public Method_ExposeAssignment_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodAccess().getExposeAssignment_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Method_ExposeAssignment_5_1(parent, this, 0, inst);
			case 1: return new Method_ExposeKeyword_5_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expose",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expose");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getMethodAccess().getExposeNameParserRuleCall_5_1_0();
			return obj;
		}
		return null;
	}

}

// TERM+
protected class Method_TERMTerminalRuleCall_5_2 extends UnassignedTextToken {

	public Method_TERMTerminalRuleCall_5_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getMethodAccess().getTERMTerminalRuleCall_5_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Method_TERMTerminalRuleCall_5_2(parent, this, 0, inst);
			case 1: return new Method_ExposeAssignment_5_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// content+=Instruction*
protected class Method_ContentAssignment_6 extends AssignmentToken  {
	
	public Method_ContentAssignment_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMethodAccess().getContentAssignment_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("content",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("content");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInstructionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMethodAccess().getContentInstructionParserRuleCall_6_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Method_ContentAssignment_6(parent, next, actIndex, consumed);
			case 1: return new Method_Group_5(parent, next, actIndex, consumed);
			case 2: return new Method_TERMTerminalRuleCall_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Method ****************/


/************ begin Rule Attribute ****************
 *
 * Attribute:
 *   (AttributeSet|AttributeGet|AttributeNormal) visibility=VISIBILITY? class?="class"?
 *   TERM+ ("expose" expose+=Name+ TERM+)? content+=Instruction*;
 *
 **/

// (AttributeSet|AttributeGet|AttributeNormal) visibility=VISIBILITY? class?="class"?
// TERM+ ("expose" expose+=Name+ TERM+)? content+=Instruction*
protected class Attribute_Group extends GroupToken {
	
	public Attribute_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_ContentAssignment_5(parent, this, 0, inst);
			case 1: return new Attribute_Group_4(parent, this, 1, inst);
			case 2: return new Attribute_TERMTerminalRuleCall_3(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AttributeSet|AttributeGet|AttributeNormal
protected class Attribute_Alternatives_0 extends AlternativesToken {

	public Attribute_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAttributeAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_AttributeSetParserRuleCall_0_0(parent, this, 0, inst);
			case 1: return new Attribute_AttributeGetParserRuleCall_0_1(parent, this, 1, inst);
			case 2: return new Attribute_AttributeNormalParserRuleCall_0_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// AttributeSet
protected class Attribute_AttributeSetParserRuleCall_0_0 extends RuleCallToken {
	
	public Attribute_AttributeSetParserRuleCall_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAttributeAccess().getAttributeSetParserRuleCall_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeSet_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AttributeSet_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAttributeSetRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// AttributeGet
protected class Attribute_AttributeGetParserRuleCall_0_1 extends RuleCallToken {
	
	public Attribute_AttributeGetParserRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAttributeAccess().getAttributeGetParserRuleCall_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeGet_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AttributeGet_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAttributeGetRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// AttributeNormal
protected class Attribute_AttributeNormalParserRuleCall_0_2 extends RuleCallToken {
	
	public Attribute_AttributeNormalParserRuleCall_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAttributeAccess().getAttributeNormalParserRuleCall_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeNormal_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AttributeNormal_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAttributeNormalRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


// visibility=VISIBILITY?
protected class Attribute_VisibilityAssignment_1 extends AssignmentToken  {
	
	public Attribute_VisibilityAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeAccess().getVisibilityAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_Alternatives_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("visibility",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("visibility");
		if(Boolean.TRUE.booleanValue()) {  
			type = AssignmentType.ERC;
			element = grammarAccess.getAttributeAccess().getVisibilityVISIBILITYEnumRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// class?="class"?
protected class Attribute_ClassAssignment_2 extends AssignmentToken  {
	
	public Attribute_ClassAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeAccess().getClassAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_VisibilityAssignment_1(parent, this, 0, inst);
			case 1: return new Attribute_Alternatives_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("class",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("class");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAttributeAccess().getClassClassKeyword_2_0();
			return obj;
		}
		return null;
	}

}

// TERM+
protected class Attribute_TERMTerminalRuleCall_3 extends UnassignedTextToken {

	public Attribute_TERMTerminalRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAttributeAccess().getTERMTerminalRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_TERMTerminalRuleCall_3(parent, this, 0, inst);
			case 1: return new Attribute_ClassAssignment_2(parent, this, 1, inst);
			case 2: return new Attribute_VisibilityAssignment_1(parent, this, 2, inst);
			case 3: return new Attribute_Alternatives_0(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
}

// ("expose" expose+=Name+ TERM+)?
protected class Attribute_Group_4 extends GroupToken {
	
	public Attribute_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_TERMTerminalRuleCall_4_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "expose"
protected class Attribute_ExposeKeyword_4_0 extends KeywordToken  {
	
	public Attribute_ExposeKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeAccess().getExposeKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_TERMTerminalRuleCall_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expose+=Name+
protected class Attribute_ExposeAssignment_4_1 extends AssignmentToken  {
	
	public Attribute_ExposeAssignment_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeAccess().getExposeAssignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_ExposeAssignment_4_1(parent, this, 0, inst);
			case 1: return new Attribute_ExposeKeyword_4_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expose",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expose");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getAttributeAccess().getExposeNameParserRuleCall_4_1_0();
			return obj;
		}
		return null;
	}

}

// TERM+
protected class Attribute_TERMTerminalRuleCall_4_2 extends UnassignedTextToken {

	public Attribute_TERMTerminalRuleCall_4_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAttributeAccess().getTERMTerminalRuleCall_4_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_TERMTerminalRuleCall_4_2(parent, this, 0, inst);
			case 1: return new Attribute_ExposeAssignment_4_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// content+=Instruction*
protected class Attribute_ContentAssignment_5 extends AssignmentToken  {
	
	public Attribute_ContentAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeAccess().getContentAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Instruction_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("content",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("content");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInstructionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAttributeAccess().getContentInstructionParserRuleCall_5_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Attribute_ContentAssignment_5(parent, next, actIndex, consumed);
			case 1: return new Attribute_Group_4(parent, next, actIndex, consumed);
			case 2: return new Attribute_TERMTerminalRuleCall_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Attribute ****************/


/************ begin Rule AttributeSet ****************
 *
 * AttributeSet:
 *   "::attribute" name=Name "set";
 *
 **/

// "::attribute" name=Name "set"
protected class AttributeSet_Group extends GroupToken {
	
	public AttributeSet_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeSetAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeSet_SetKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAttributeSetRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "::attribute"
protected class AttributeSet_AttributeKeyword_0 extends KeywordToken  {
	
	public AttributeSet_AttributeKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeSetAccess().getAttributeKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=Name
protected class AttributeSet_NameAssignment_1 extends AssignmentToken  {
	
	public AttributeSet_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeSetAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeSet_AttributeKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getAttributeSetAccess().getNameNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "set"
protected class AttributeSet_SetKeyword_2 extends KeywordToken  {
	
	public AttributeSet_SetKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeSetAccess().getSetKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeSet_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule AttributeSet ****************/


/************ begin Rule AttributeGet ****************
 *
 * AttributeGet:
 *   "::attribute" name=Name "get";
 *
 **/

// "::attribute" name=Name "get"
protected class AttributeGet_Group extends GroupToken {
	
	public AttributeGet_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeGetAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeGet_GetKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAttributeGetRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "::attribute"
protected class AttributeGet_AttributeKeyword_0 extends KeywordToken  {
	
	public AttributeGet_AttributeKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeGetAccess().getAttributeKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=Name
protected class AttributeGet_NameAssignment_1 extends AssignmentToken  {
	
	public AttributeGet_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeGetAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeGet_AttributeKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getAttributeGetAccess().getNameNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "get"
protected class AttributeGet_GetKeyword_2 extends KeywordToken  {
	
	public AttributeGet_GetKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeGetAccess().getGetKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeGet_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule AttributeGet ****************/


/************ begin Rule AttributeNormal ****************
 *
 * AttributeNormal:
 *   "::attribute" name=Name;
 *
 **/

// "::attribute" name=Name
protected class AttributeNormal_Group extends GroupToken {
	
	public AttributeNormal_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeNormalAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeNormal_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAttributeNormalRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "::attribute"
protected class AttributeNormal_AttributeKeyword_0 extends KeywordToken  {
	
	public AttributeNormal_AttributeKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeNormalAccess().getAttributeKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=Name
protected class AttributeNormal_NameAssignment_1 extends AssignmentToken  {
	
	public AttributeNormal_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeNormalAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AttributeNormal_AttributeKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getAttributeNormalAccess().getNameNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule AttributeNormal ****************/


/************ begin Rule Constant ****************
 *
 * Constant:
 *   "::constant" name=Name TERM+;
 *
 **/

// "::constant" name=Name TERM+
protected class Constant_Group extends GroupToken {
	
	public Constant_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstantAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Constant_TERMTerminalRuleCall_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConstantRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "::constant"
protected class Constant_ConstantKeyword_0 extends KeywordToken  {
	
	public Constant_ConstantKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstantAccess().getConstantKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=Name
protected class Constant_NameAssignment_1 extends AssignmentToken  {
	
	public Constant_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstantAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Constant_ConstantKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getConstantAccess().getNameNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// TERM+
protected class Constant_TERMTerminalRuleCall_2 extends UnassignedTextToken {

	public Constant_TERMTerminalRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getConstantAccess().getTERMTerminalRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Constant_TERMTerminalRuleCall_2(parent, this, 0, inst);
			case 1: return new Constant_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Constant ****************/


/************ begin Rule Routine ****************
 *
 * Routine:
 *   "::routine" name=Name TERM+;
 *
 **/

// "::routine" name=Name TERM+
protected class Routine_Group extends GroupToken {
	
	public Routine_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRoutineAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Routine_TERMTerminalRuleCall_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRoutineRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "::routine"
protected class Routine_RoutineKeyword_0 extends KeywordToken  {
	
	public Routine_RoutineKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRoutineAccess().getRoutineKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=Name
protected class Routine_NameAssignment_1 extends AssignmentToken  {
	
	public Routine_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRoutineAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Routine_RoutineKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getRoutineAccess().getNameNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// TERM+
protected class Routine_TERMTerminalRuleCall_2 extends UnassignedTextToken {

	public Routine_TERMTerminalRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRoutineAccess().getTERMTerminalRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Routine_TERMTerminalRuleCall_2(parent, this, 0, inst);
			case 1: return new Routine_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Routine ****************/


/************ begin Rule Requires ****************
 *
 * Requires:
 *   "::requires" name=Name TERM+;
 *
 **/

// "::requires" name=Name TERM+
protected class Requires_Group extends GroupToken {
	
	public Requires_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRequiresAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Requires_TERMTerminalRuleCall_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRequiresRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "::requires"
protected class Requires_RequiresKeyword_0 extends KeywordToken  {
	
	public Requires_RequiresKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRequiresAccess().getRequiresKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=Name
protected class Requires_NameAssignment_1 extends AssignmentToken  {
	
	public Requires_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRequiresAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Requires_RequiresKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getRequiresAccess().getNameNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// TERM+
protected class Requires_TERMTerminalRuleCall_2 extends UnassignedTextToken {

	public Requires_TERMTerminalRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRequiresAccess().getTERMTerminalRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Requires_TERMTerminalRuleCall_2(parent, this, 0, inst);
			case 1: return new Requires_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Requires ****************/


/************ begin Rule Options ****************
 *
 * Options:
 *   "::options" name=Name TERM+;
 *
 **/

// "::options" name=Name TERM+
protected class Options_Group extends GroupToken {
	
	public Options_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOptionsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Options_TERMTerminalRuleCall_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOptionsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "::options"
protected class Options_OptionsKeyword_0 extends KeywordToken  {
	
	public Options_OptionsKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getOptionsAccess().getOptionsKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=Name
protected class Options_NameAssignment_1 extends AssignmentToken  {
	
	public Options_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOptionsAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Options_OptionsKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getOptionsAccess().getNameNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// TERM+
protected class Options_TERMTerminalRuleCall_2 extends UnassignedTextToken {

	public Options_TERMTerminalRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOptionsAccess().getTERMTerminalRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Options_TERMTerminalRuleCall_2(parent, this, 0, inst);
			case 1: return new Options_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Options ****************/


}
