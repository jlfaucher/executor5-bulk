grammar org.oorexx.workbench.Rexx //with org.eclipse.xtext.common.Terminals
hidden (ML_COMMENT, SL_COMMENT, WS)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate rexx "http://www.oorexx.org/workbench/Rexx"

File:
  {File} Delimiter? (instructions+=Instruction)* (requires+=Requires)* (methods+=
  Method)* (directives+=Directives)*;

Instruction:
  (
  //  Address|
  Assignment|Do|Drop|Exit|Nop|Call|Arg|UseArg|Raise|MessageInstruction //  |Expression
  | ExpressionFunction
)Delimiter | If;

//Address:
//  'address' (environment=Expression|value?='value') (command=Expression)?;


Assignment:
  target=VarName op=AssignmentOperator expression=Expression;
  
enum AssignmentOperator: ASSIGN='=' | ASSIGNPLUS='+='|ASSIGNMINUS='-='|
ASSIGNTIMES='*='|ASSIGNDIV='/=';

VarName:
  'do'|'adress'|'value'|'call'|'on'|'off'|'name'|'label'|'forever'|'over'|'to'|
  'by'|'for'|'while'|'until'|'drop'|'exit'|'if'|'then'|'else'|'nop'|'any'|'error'|
  'failure'|'halt'|'notready'|'user'|'use'|'arg'|'raise'|'syntax'|'get'|'set'|
  'public'|'private'|Name;

Call:
  'call' ({CallCall} ((name=Expression) args=Arguments))|CallOnOff;

CallOnOff:
  (on?='on'|off?='off') condition=Condition ('name' trap=Name)?;

Do:
  {Do}'do' ('label' label=Name)? repetitor=DoRepetitor? conditional=DoConditional?
  Delimiter (instrs+=Instruction)* 'end' endLabel=Name?;

DoRepetitor:
  DoTimes | DoOver | DoManual ;

DoTimes:
  times=ExpressionSimple;
DoOver:
  control=Name 'over' over=ExpressionSimple;
DoManual:
  control=VarName '=' start=ExpressionSimple
  ('to' to=ExpressionSimple)?
  ('by' by=ExpressionSimple)?
  ('for' for=ExpressionSimple)?;

DoConditional:
  ({DoWhile} 'while'|{DoUntil} 'until') condition=Expression;

Drop:
  'drop' var+=Expression (',' var+=Expression)*;

Exit:
  {Exit} 'exit' (result=Expression)?;

If:
  'if' expression=Expression Delimiter? 'then' Delimiter? topInstr=Instruction
  ( 'else' Delimiter? bottomInstr=Instruction)?;

Nop:
  {Nop} 'nop';

Condition returns Condition:
  ({ConditionAny} 'any'|{ConditionError} 'error'|{ConditionFailure} 'failure'|{
  ConditionHalt} 'halt'|{ConditionNotready} 'notready'|{ConditionUser} 'user' name=
  Name);

Arg:
  {Arg} 'arg' ((args+=Name) (',' (args+=Name))*)?;

UseArg:
  {UseArg} 'use' (strict?='strict')? 'arg' ((args+=UseArgs) (',' (args+=UseArgs))*)?;

UseArgs:
  name=Name ('=' default=Expression)?;

Arguments returns Arguments:
  {Arguments} (arguments+=Expression (',' arguments+=Expression)*)?;

Raise:
  'raise' 'syntax' mayor=SYMBOL_NUM ('.' minor=SYMBOL_NUM)?;

/*

Expression: l=Expression2 (op=ExpressionOp1 r=Expression2)?;
Expression2 returns Expression: l=Expression3 (op=ExpressionOp2 r=Expression3)?;
Expression3 returns Expression: l=Expression4 (op=ExpressionOp3 r=Expression4)?;
Expression4 returns Expression: l=Expression5 (op=ExpressionOp4 r=Expression5)?;
Expression5 returns Expression: l=Expression6 (op=ExpressionOp5 r=Expression6)?;
Expression6 returns Expression: l=Expression7 (op=ExpressionOp6 r=Expression7)?;
Expression7 returns Expression: l=Expression8 (op=ExpressionOp7 r=Expression8)?;
Expression8 returns Expression: l=Expression9 (op=ExpressionOp8 r=Expression9)?;
Expression9 returns Expression: l=Expression10 (op=ExpressionOp9 r=Expression10)?;
Expression10 returns Expression: l=Expression11 (op=ExpressionOp10 r=Expression11)?;
Expression11 returns Expression: l=Expression12 (op=ExpressionOp11 r=Expression12)?;
Expression12 returns Expression: l=Expression13 (op=ExpressionOp12 r=Expression13)?;
Expression13 returns Expression: l=Expression14 (op=ExpressionOp13 r=Expression14)?;
Expression14 returns Expression: l=Expression15 (op=ExpressionOp14 r=Expression15)?;
Expression15 returns Expression: l=Expression16 (op=ExpressionOp15 r=Expression16)?;
Expression16 returns Expression: l=Expression17 (op=ExpressionOp16 r=Expression17)?;
Expression17 returns Expression: l=Expression18 (op=ExpressionOp17 r=Expression18)?;
Expression18 returns Expression: Expression19 | op=ExpressionOp18 r=Expression19;
Expression19 returns Expression: l=ExpressionAtom (op=ExpressionOp19 r=ExpressionAtom)?;

ExpressionOp1: '|' | '&&';
ExpressionOp2: '&';
ExpressionOp3: '<=' | '<<=';
ExpressionOp4: '>=' | '>>=';
ExpressionOp5: '\\<<';
ExpressionOp6: '\\>>';
ExpressionOp7: '\\==';
ExpressionOp8: '\\<';
ExpressionOp9: '\\>';
ExpressionOp10: '<>' | '><';
ExpressionOp11: '\\=';
ExpressionOp12: '==' | '<=' | '>=';
ExpressionOp13: '=' | '<' | '>';
ExpressionOp14: '||';
ExpressionOp15: '+' | '-';
ExpressionOp16: '*' | '/' | '%' | '//';
ExpressionOp17: '**';
ExpressionOp18: '+' | '-' | '\\';
ExpressionOp19: '~' | '~~';


ExpressionAtom: ExpressionVar | Const | MessageTerm | ExpressionFunction | ExpressionParen;
ExpressionVar: name=VarName;
ExpressionFunction:  name=VarName '(' args=Arguments ')';
ExpressionParen: '(' expr=Expression ')';

*/
Expression:
  (ExpressionCommon tail=ExpressionFollow?)
//  | ExpressionNested
;

ExpressionSimple: ExpressionCommon 
//| ExpressionParen
;

ExpressionCommon: ExpressionVar|MessageTerm|ExpressionPrefix|Const|ExpressionFunction
  ;
ExpressionVar: name=VarName;
ExpressionFunction:  name=VarName '(' args=Arguments ')';
ExpressionParen: '(' expr=Expression ')';
ExpressionPrefix: '\\' expr=Expression;

ExpressionFollow: BinOpExpression;

BinOpExpression:
   op=BinOpSymbol next=ExpressionSimple;

BinOpSymbol: '+' | '-' | '*' | '/' | '//' |'%'| '**' | '|' | '||' | '&' | '&&'
| '=' | '==' | '\\=' | '\\=='
| '<' | '>' | '\\<' | '\\>' | '<>' | '><' | '<=' | '>=' | '>>' | '<<'
| '<<=' | '>>=' | '\\<<' | '\\>>';

MessageInstruction:
  message=MessageTerm ('=' value=Expression)?;

MessageTerm:
  receiver=MessageReceiver message+=( MessageTermMessage | MessageTermArray )+;

MessageTermMessage:
  ('~'|discard?='~~') name=MessageName (':' scope=Symbol)? ('(' args=Arguments ')')?;

MessageTermArray:
  '[' args=Arguments ']';

MessageReceiver:
  name=VarName; // TODO


MessageName:
  name=VarName; // TODO


Symbol:
  name=VarName; // TODO



Const returns Const:
  {Const} value=( SYMBOL_NUM | STRING_BOOL | STRING_HEX | SYMBOL_CLS );

Directives:
  Class|Options|Routine;

Class:
  '::class' name=Name ('metaclass' meta=Name)? (('subclass' subclass=Name)|(
  'mixinclass' mixin=Name))? (visibility=VISIBILITY)? ('inherit' (inherit+=Name)+)?
  Delimiter (content+=ClassContent)*;

ClassContent:
  Method|Attribute|Constant;

Method:
  '::method' name=Name ((visibility=VISIBILITY)? & (class?='class')?) Delimiter (
  'expose' (expose+=Name)+ Delimiter)? (content+=Instruction)*;

Attribute:
  (AttributeSet|AttributeGet|AttributeNormal) ((visibility=VISIBILITY)? & (class?=
  'class')?) Delimiter ('expose' (expose+=Name)+ Delimiter)? (content+=Instruction)*;

AttributeSet:
  '::attribute' name=Name 'set';

AttributeGet:
  '::attribute' name=Name 'get';

AttributeNormal:
  '::attribute' name=Name;

Constant:
  '::constant' name=Name Delimiter;

Routine:
  '::routine' name=Name Delimiter;

Requires:
  '::requires' name=Name Delimiter;

Options:
  '::options' name=Name Delimiter;

Name:
  STRING|SYMBOL_VAR;

enum VISIBILITY:
  PRIVATE='private' | PUBLIC='public'; //terminal CONTINUATION:
//  (OP_MINUS | COMMA) WS? (ML_COMMENT | SL_COMMENT)* WS? NL;


terminal WS:
  (' ' | '\t')+;

terminal ML_COMMENT:
  '/*'->'*/';

terminal SL_COMMENT:
  '--' !('\r' | '\n')*;

Delimiter:
  TERM+;

terminal TERM: ('\r'? '\n' | ';')+;

terminal STRING:
  (('"' (!'"')* '"') | ("'" (!"'" | "''")* "'"));

terminal STRING_HEX:
  STRING ('X' | 'x');

terminal STRING_BOOL:
  STRING ('B' | 'b');

terminal SYMBOL_VAR:
  ('A'..'Z' | 'a'..'z' | '_' | '?' | '!') ('A'..'Z' | 'a'..'z' | '0'..'9' | '_' | '.' | '!' | '?')*;

terminal SYMBOL_CLS:
  '.' SYMBOL_VAR;

terminal SYMBOL_NUM:
  '0'..'9'+ //| ('0'..'9')* '.' ('0'..'9')+ (('e' | 'E') ('+' | '-')? ('0'..'9')+)
;