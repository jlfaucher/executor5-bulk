grammar org.oorexx.workbench.Rexx //with org.eclipse.xtext.common.Terminals
hidden (ML_COMMENT, SL_COMMENT, WS)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate rexx "http://www.oorexx.org/workbench/Rexx"

File:
  {File} Delimiter? (instructions+=Instruction)* (requires+=Requires)* (methods+=
  Method)* (directives+=Directives)*;

Instruction:
  (
  //  Address|
  Assignment|Do|Drop|Exit|Nop|Call|Arg|UseArg|Raise|MessageInstruction //  |Expression
)Delimiter | If;

//Address:
//  'address' (environment=Expression|value?='value') (command=Expression)?;


Assignment:
  target=VarName '=' expression=Expression;

VarName:
  'do'|'adress'|'value'|'call'|'on'|'off'|'name'|'label'|'forever'|'over'|'to'|
  'by'|'for'|'while'|'until'|'drop'|'exit'|'if'|'then'|'else'|'nop'|'any'|'error'|
  'failure'|'halt'|'notready'|'user'|'use'|'arg'|'raise'|'syntax'|'get'|'set'|
  'public'|'private'|Name;

Call:
  'call' ({CallCall} ((name=Expression) args=Arguments))|CallOnOff;

CallOnOff:
  (on?='on'|off?='off') condition=Condition ('name' trap=Name)?;

Do:
  {Do}'do' ('label' label=Name)? repetitor=DoRepetitor? conditional=DoConditional?
  Delimiter (instrs+=Instruction)* 'end' endLabel=Name?;

DoRepetitor:
  {DoTimes} times=Expression|{DoOver} control=Name 'over' over=
  Expression|{DoManual} control=Name '=' start=Expression ('to' to=Expression)? ('by' by=
  Expression)? ('for' for=Expression)?;


DoConditional:
  ({DoWhile} 'while'|{DoUntil} 'until') condition=Expression;

Drop:
  'drop' var+=DropVar (',' var+=DropVar)*;

DropVar:
  {DropSymbol} name=Name|{DropExpression} '(' expression=Expression ')';

Exit:
  {Exit} 'exit' (result=Expression)?;

If:
  'if' expression=Expression Delimiter? 'then' Delimiter? topInstr=Instruction
  ( 'else' Delimiter? bottomInstr=Instruction)?;

Nop:
  {Nop} 'nop';

Condition returns Condition:
  ({ConditionAny} 'any'|{ConditionError} 'error'|{ConditionFailure} 'failure'|{
  ConditionHalt} 'halt'|{ConditionNotready} 'notready'|{ConditionUser} 'user' name=
  Name);

Arg:
  {Arg} 'arg' ((args+=Name) (',' (args+=Name))*)?;

UseArg:
  {UseArg} 'use' (strict?='strict')? 'arg' ((args+=UseArgs) (',' (args+=UseArgs))*)?;

UseArgs:
  name=Name ('=' default=Expression)?;

Arguments returns Arguments:
  {Arguments} (arguments+=Expression (',' arguments+=Expression)*)?;

Raise:
  'raise' 'syntax' mayor=SYMBOL_NUM ('.' minor=SYMBOL_NUM)?;

Expression:
  {ExprVar} name=VarName|//  fnCall|
  MessageTerm //|
  //  Negate
|Const //  |BinOp
; //fnCall:
//  name=VarName '(' args=Arguments ')';
//
//BinOp:
//  l=BinOpLeft op=( '+' | '-' | '*' | '/' | '**' | '||' | '&' | '&&' ) r=Expression;
//
//BinOpLeft:
//  {ExprVar} name=VarName|fnCall|MessageTerm|Negate|Const;


MessageInstruction:
  message=MessageTerm ('=' value=Expression)?;

MessageTerm:
  receiver=MessageReceiver message+=( MessageTermMessage | MessageTermArray )+;

MessageTermMessage:
  ('~'|discard?='~~') name=MessageName (':' scope=Symbol)? ('(' args=Arguments ')')?;

MessageTermArray:
  '[' args=Arguments ']';

MessageReceiver:
  name=VarName; // TODO


MessageName:
  name=VarName; // TODO


Symbol:
  name=VarName; // TODO


Negate:
  '\\' expression=Expression;

Const returns Const:
  {Const} value=( SYMBOL_NUM | STRING_BOOL | STRING_HEX );

Directives:
  Class|Options|Routine;

Class:
  '::class' name=Name ('metaclass' meta=Name)? (('subclass' subclass=Name)|(
  'mixinclass' mixin=Name))? (visibility=VISIBILITY)? ('inherit' (inherit+=Name)+)?
  Delimiter (content+=ClassContent)*;

ClassContent:
  Method|Attribute|Constant;

Method:
  '::method' name=Name ((visibility=VISIBILITY)? & (class?='class')?) Delimiter (
  'expose' (expose+=Name)+ Delimiter)? (content+=Instruction)*;

Attribute:
  (AttributeSet|AttributeGet|AttributeNormal) ((visibility=VISIBILITY)? & (class?=
  'class')?) Delimiter ('expose' (expose+=Name)+ Delimiter)? (content+=Instruction)*;

AttributeSet:
  '::attribute' name=Name 'set';

AttributeGet:
  '::attribute' name=Name 'get';

AttributeNormal:
  '::attribute' name=Name;

Constant:
  '::constant' name=Name Delimiter;

Routine:
  '::routine' name=Name Delimiter;

Requires:
  '::requires' name=Name Delimiter;

Options:
  '::options' name=Name Delimiter;

Name:
  STRING|SYMBOL_VAR;

enum VISIBILITY:
  PRIVATE='private' | PUBLIC='public'; //terminal CONTINUATION:
//  (OP_MINUS | COMMA) WS? (ML_COMMENT | SL_COMMENT)* WS? NL;


terminal WS:
  (' ' | '\t')+;

terminal ML_COMMENT:
  '/*'->'*/';

terminal SL_COMMENT:
  '--' !('\r' | '\n')*;

Delimiter:
  TERM+;

terminal TERM: ('\r'? '\n' | ';')+;

terminal STRING:
  (('"' (!'"')* '"') | ("'" (!"'" | "''")* "'"));

terminal STRING_HEX:
  STRING ('X' | 'x');

terminal STRING_BOOL:
  STRING ('B' | 'b');

terminal SYMBOL_VAR:
  ('A'..'Z' | 'a'..'z' | '_' | '?' | '!') ('A'..'Z' | 'a'..'z' | '0'..'9' | '_' | '.' | '!' | '?')*;

terminal SYMBOL_CLS:
  '.' SYMBOL_VAR;

terminal SYMBOL_NUM:
  '0'..'9'+ //| ('0'..'9')* '.' ('0'..'9')+ (('e' | 'E') ('+' | '-')? ('0'..'9')+)
;