#!/usr/bin/rexx
/*
  SVN Revision: $Rev: 3371 $
  Change Date:  $Date: 2008-09-21 00:33:29 -0400 (Sun, 21 Sep 2008) $
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2005-2010 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . fileSpec;

  group = .TestGroup~new(fileSpec)
  group~add(.regex.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult
-- End of entry point.

::requires "ooTest.frm"     -- load the ooRexxUnit classes
::requires "regex.cls"

::class "regex.testGroup" subclass ooTestCase public

-- tests simple string matches
::method testAtom
  p = .Pattern~compile("foo")
  -- some basic method results from pattern
  self~assertEquals("foo", p~pattern)
  self~assertEquals("foo", p~string)

  -- now some matching/search tests
  self~assertTrue(p~matches("foo"))
  self~assertFalse(p~matches("foobar"))
  self~assertFalse(p~matches("fo"))
  self~assertFalse(p~matches(" foo"))
  self~assertTrue(p~startsWith("foo"))
  self~assertTrue(p~startsWith("fooBar"))
  self~assertFalse(p~startsWith(" foo"))

  r = p~find("foo")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("", r~suffix)

  r = p~find("xxxfooyyy")
  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(7, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("xxx", r~prefix)
  self~assertEquals("yyy", r~suffix)

  r = p~find("xyzzy")
  self~assertFalse(r~matched)
  self~assertEquals(0, r~start)
  self~assertEquals(0, r~end)
  self~assertEquals(0, r~length)
  self~assertEquals("", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("xyzzy", r~suffix)

-- test various patterns containing "."
::method testDot

  p = .Pattern~compile(".")

  -- match against all ascii characters.  However,
  -- the default match mode for "." does not recognize
  -- either '0d'x or '0a'x.  We'll invert those.  Tests
  -- for the options overrides is a task for another day.
  do i = 0 to 255
      -- handle the special cases
      if i == 10 | i == 13 then do
          self~assertFalse(p~matches(d2c(i)))
      end
      else do
          self~assertTrue(p~matches(d2c(i)))
      end
  end

  self~assertFalse(p~matches(""))
  self~assertFalse(p~matches("AB"))

  self~assertFalse(p~startsWith(""))
  self~assertTrue(p~startsWith("A"))
  self~assertTrue(p~startsWith("AB"))

  r = p~find("foo")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("f", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("oo", r~suffix)

  -- now some composite tests
  p = .Pattern~compile("f.o")
  do i = 0 to 255
      -- handle the special cases
      if i == 10 | i == 13 then do
          self~assertFalse(p~matches("f"||d2c(i)||"o"))
      end
      else do
          self~assertTrue(p~matches("f"||d2c(i)||"o"))
      end
  end

  self~assertFalse(p~matches("fo"))
  self~assertFalse(p~matches("foobar"))

  self~assertFalse(p~startsWith("fo"))
  self~assertTrue(p~startsWith("foobar"))

  r = p~find("foo")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("", r~suffix)

  r = p~find("foobar")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("bar", r~suffix)

  r = p~find("xyzfoobar")
  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(7, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("xyz", r~prefix)
  self~assertEquals("bar", r~suffix)

  -- dot pattern on the end
  p = .Pattern~compile("fo.")
  do i = 0 to 255
      -- handle the special cases
      if i == 10 | i == 13 then do
          self~assertFalse(p~matches("fo"||d2c(i)))
      end
      else do
          self~assertTrue(p~matches("fo"||d2c(i)))
      end
  end

  self~assertFalse(p~matches("fo"))
  self~assertFalse(p~matches("foobar"))

  self~assertFalse(p~startsWith("fo"))
  self~assertTrue(p~startsWith("foo"))
  self~assertTrue(p~startsWith("foobar"))

  r = p~find("foo")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("", r~suffix)

  r = p~find("foobar")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("bar", r~suffix)

  r = p~find("xyzfoobar")
  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(7, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("xyz", r~prefix)
  self~assertEquals("bar", r~suffix)


  -- dot pattern at the start
  p = .Pattern~compile(".oo")
  do i = 0 to 255
      -- handle the special cases
      if i == 10 | i == 13 then do
          self~assertFalse(p~matches(d2c(i)||"oo"))
      end
      else do
          self~assertTrue(p~matches(d2c(i)||"oo"))
      end
  end

  self~assertFalse(p~matches("fo"))
  self~assertFalse(p~matches("foobar"))

  self~assertFalse(p~startsWith("fo"))
  self~assertTrue(p~startsWith("foo"))
  self~assertTrue(p~startsWith("foobar"))

  r = p~find("foo")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("", r~suffix)

  r = p~find("foobar")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("bar", r~suffix)

  r = p~find("xyzfoobar")
  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(7, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("xyz", r~prefix)
  self~assertEquals("bar", r~suffix)

-- simple classes that are just sequences of characters
::method testSimpleClass
  p = .Pattern~compile("[abc]")

  self~assertTrue(p~matches('a'))
  self~assertTrue(p~matches('b'))
  self~assertTrue(p~matches('c'))
  self~assertFalse(p~matches('e'))

  self~assertTrue(p~startsWith('abc'))
  self~assertTrue(p~startsWith('bye-bye'))
  self~assertTrue(p~startsWith('caldera'))
  self~assertFalse(p~startsWith('estuary'))

  r = p~find('abc')

  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("a", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("bc", r~suffix)

  r = p~find('xbc')

  self~assertTrue(r~matched)
  self~assertEquals(2, r~start)
  self~assertEquals(3, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("b", r~text)
  self~assertEquals("x", r~prefix)
  self~assertEquals("c", r~suffix)

  r = p~find('xxc')

  self~assertTrue(r~matched)
  self~assertEquals(3, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("c", r~text)
  self~assertEquals("xx", r~prefix)
  self~assertEquals("", r~suffix)

  p = .Pattern~compile("a[abc]c")

  r = p~find('xxabcyy')

  self~assertTrue(r~matched)
  self~assertEquals(3, r~start)
  self~assertEquals(6, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("abc", r~text)
  self~assertEquals("xx", r~prefix)
  self~assertEquals("yy", r~suffix)

-- simple classes that are just sequences of characters, with negation
::method testSimpleNotClass
  p = .Pattern~compile("[^abc]")

  self~assertFalse(p~matches('a'))
  self~assertFalse(p~matches('b'))
  self~assertFalse(p~matches('c'))
  self~assertTrue(p~matches('e'))

  self~assertFalse(p~startsWith('abc'))
  self~assertFalse(p~startsWith('bye-bye'))
  self~assertFalse(p~startsWith('caldera'))
  self~assertTrue(p~startsWith('estuary'))

  r = p~find('eabc')

  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("e", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("abc", r~suffix)

  r = p~find('aebc')

  self~assertTrue(r~matched)
  self~assertEquals(2, r~start)
  self~assertEquals(3, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("e", r~text)
  self~assertEquals("a", r~prefix)
  self~assertEquals("bc", r~suffix)

  r = p~find('abce')

  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(5, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("e", r~text)
  self~assertEquals("abc", r~prefix)
  self~assertEquals("", r~suffix)

  p = .Pattern~compile("a[^abc]c")

  r = p~find('abcaecyy')

  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(7, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("aec", r~text)
  self~assertEquals("abc", r~prefix)
  self~assertEquals("yy", r~suffix)


-- simple classes that are just sequences of characters, with negation
::method testRangeNotClass
  p = .Pattern~compile("[^a-c]")

  self~assertFalse(p~matches('a'))
  self~assertFalse(p~matches('b'))
  self~assertFalse(p~matches('c'))
  self~assertTrue(p~matches('e'))

  self~assertFalse(p~startsWith('abc'))
  self~assertFalse(p~startsWith('bye-bye'))
  self~assertFalse(p~startsWith('caldera'))
  self~assertTrue(p~startsWith('estuary'))

  r = p~find('eabc')

  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("e", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("abc", r~suffix)

  r = p~find('aebc')

  self~assertTrue(r~matched)
  self~assertEquals(2, r~start)
  self~assertEquals(3, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("e", r~text)
  self~assertEquals("a", r~prefix)
  self~assertEquals("bc", r~suffix)

  r = p~find('abce')

  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(5, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("e", r~text)
  self~assertEquals("abc", r~prefix)
  self~assertEquals("", r~suffix)

  p = .Pattern~compile("a[^a-c]c")

  r = p~find('abcaecyy')

  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(7, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("aec", r~text)
  self~assertEquals("abc", r~prefix)
  self~assertEquals("yy", r~suffix)

-- simple classes that use a range of characters
::method testRangeClass
  p = .Pattern~compile("[a-c]")

  self~assertTrue(p~matches('a'))
  self~assertTrue(p~matches('b'))
  self~assertTrue(p~matches('c'))
  self~assertFalse(p~matches('e'))

  self~assertTrue(p~startsWith('abc'))
  self~assertTrue(p~startsWith('bye-bye'))
  self~assertTrue(p~startsWith('caldera'))
  self~assertFalse(p~startsWith('estuary'))

  r = p~find('abc')

  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("a", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("bc", r~suffix)

  r = p~find('xbc')

  self~assertTrue(r~matched)
  self~assertEquals(2, r~start)
  self~assertEquals(3, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("b", r~text)
  self~assertEquals("x", r~prefix)
  self~assertEquals("c", r~suffix)

  r = p~find('xxc')

  self~assertTrue(r~matched)
  self~assertEquals(3, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("c", r~text)
  self~assertEquals("xx", r~prefix)
  self~assertEquals("", r~suffix)

  p = .Pattern~compile("a[a-c]c")

  r = p~find('xxabcyy')

  self~assertTrue(r~matched)
  self~assertEquals(3, r~start)
  self~assertEquals(6, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("abc", r~text)
  self~assertEquals("xx", r~prefix)
  self~assertEquals("yy", r~suffix)

