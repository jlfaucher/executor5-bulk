#!/usr/bin/rexx
/*
  SVN Revision: $Rev: 3371 $
  Change Date:  $Date: 2008-09-21 00:33:29 -0400 (Sun, 21 Sep 2008) $
*/
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2005-2010 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
  parse source . . fileSpec;

  group = .TestGroup~new(fileSpec)
  group~add(.regex.testGroup)

  if group~isAutomatedTest then return group

  testResult = group~suite~execute~~print

return testResult
-- End of entry point.

::requires "ooTest.frm"     -- load the ooRexxUnit classes
::requires "regex.cls"

::class "regex.testGroup" subclass ooTestCase public
-- tests simple string matches
::method testAtom
  p = .Pattern~compile("foo")
  -- some basic method results from pattern
  self~assertEquals("foo", p~pattern)
  self~assertEquals("foo", p~string)

  -- now some matching/search tests
  self~assertTrue(p~matches("foo"))
  self~assertFalse(p~matches("foobar"))
  self~assertFalse(p~matches("fo"))
  self~assertFalse(p~matches(" foo"))
  self~assertTrue(p~startsWith("foo"))
  self~assertTrue(p~startsWith("fooBar"))
  self~assertFalse(p~startsWith(" foo"))

  r = p~find("foo")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("", r~suffix)

  r = p~find("xxxfooyyy")
  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(7, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("xxx", r~prefix)
  self~assertEquals("yyy", r~suffix)

  r = p~find("xyzzy")
  self~assertFalse(r~matched)
  self~assertEquals(0, r~start)
  self~assertEquals(0, r~end)
  self~assertEquals(0, r~length)
  self~assertEquals("", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("xyzzy", r~suffix)

-- test various patterns containing "."
::method testDot

  p = .Pattern~compile(".")

  -- match against all ascii characters.  However,
  -- the default match mode for "." does not recognize
  -- either '0d'x or '0a'x.  We'll invert those.  Tests
  -- for the options overrides is a task for another day.
  self~checkExcludedCharacters(p, "0a0d"x)

  self~assertFalse(p~matches(""))
  self~assertFalse(p~matches("AB"))

  self~assertFalse(p~startsWith(""))
  self~assertTrue(p~startsWith("A"))
  self~assertTrue(p~startsWith("AB"))

  r = p~find("foo")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("f", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("oo", r~suffix)

  -- now some composite tests
  p = .Pattern~compile("f.o")
  do i = 0 to 255
      -- handle the special cases
      if i == 10 | i == 13 then do
          self~assertFalse(p~matches("f"||d2c(i)||"o"))
      end
      else do
          self~assertTrue(p~matches("f"||d2c(i)||"o"))
      end
  end

  self~assertFalse(p~matches("fo"))
  self~assertFalse(p~matches("foobar"))

  self~assertFalse(p~startsWith("fo"))
  self~assertTrue(p~startsWith("foobar"))

  r = p~find("foo")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("", r~suffix)

  r = p~find("foobar")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("bar", r~suffix)

  r = p~find("xyzfoobar")
  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(7, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("xyz", r~prefix)
  self~assertEquals("bar", r~suffix)

  -- dot pattern on the end
  p = .Pattern~compile("fo.")
  do i = 0 to 255
      -- handle the special cases
      if i == 10 | i == 13 then do
          self~assertFalse(p~matches("fo"||d2c(i)))
      end
      else do
          self~assertTrue(p~matches("fo"||d2c(i)))
      end
  end

  self~assertFalse(p~matches("fo"))
  self~assertFalse(p~matches("foobar"))

  self~assertFalse(p~startsWith("fo"))
  self~assertTrue(p~startsWith("foo"))
  self~assertTrue(p~startsWith("foobar"))

  r = p~find("foo")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("", r~suffix)

  r = p~find("foobar")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("bar", r~suffix)

  r = p~find("xyzfoobar")
  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(7, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("xyz", r~prefix)
  self~assertEquals("bar", r~suffix)


  -- dot pattern at the start
  p = .Pattern~compile(".oo")
  do i = 0 to 255
      -- handle the special cases
      if i == 10 | i == 13 then do
          self~assertFalse(p~matches(d2c(i)||"oo"))
      end
      else do
          self~assertTrue(p~matches(d2c(i)||"oo"))
      end
  end

  self~assertFalse(p~matches("fo"))
  self~assertFalse(p~matches("foobar"))

  self~assertFalse(p~startsWith("fo"))
  self~assertTrue(p~startsWith("foo"))
  self~assertTrue(p~startsWith("foobar"))

  r = p~find("foo")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("", r~suffix)

  r = p~find("foobar")
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("bar", r~suffix)

  r = p~find("xyzfoobar")
  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(7, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("foo", r~text)
  self~assertEquals("xyz", r~prefix)
  self~assertEquals("bar", r~suffix)

-- simple classes that are just sequences of characters
::method testSimpleClass
  p = .Pattern~compile("[abc]")

  -- verify the entire included set
  self~checkIncludedCharacters(p, "abc")

  self~assertTrue(p~startsWith('abc'))
  self~assertTrue(p~startsWith('bye-bye'))
  self~assertTrue(p~startsWith('caldera'))
  self~assertFalse(p~startsWith('estuary'))

  r = p~find('abc')

  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("a", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("bc", r~suffix)

  r = p~find('xbc')

  self~assertTrue(r~matched)
  self~assertEquals(2, r~start)
  self~assertEquals(3, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("b", r~text)
  self~assertEquals("x", r~prefix)
  self~assertEquals("c", r~suffix)

  r = p~find('xxc')

  self~assertTrue(r~matched)
  self~assertEquals(3, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("c", r~text)
  self~assertEquals("xx", r~prefix)
  self~assertEquals("", r~suffix)

  p = .Pattern~compile("a[abc]c")

  r = p~find('xxabcyy')

  self~assertTrue(r~matched)
  self~assertEquals(3, r~start)
  self~assertEquals(6, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("abc", r~text)
  self~assertEquals("xx", r~prefix)
  self~assertEquals("yy", r~suffix)

-- simple classes that are just sequences of characters, with negation
::method testSimpleNotClass
  p = .Pattern~compile("[^abc]")

  -- verify the entire excluded set
  self~checkExcludedCharacters(p, "abc")

  self~assertFalse(p~startsWith('abc'))
  self~assertFalse(p~startsWith('bye-bye'))
  self~assertFalse(p~startsWith('caldera'))
  self~assertTrue(p~startsWith('estuary'))

  r = p~find('eabc')

  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("e", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("abc", r~suffix)

  r = p~find('aebc')

  self~assertTrue(r~matched)
  self~assertEquals(2, r~start)
  self~assertEquals(3, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("e", r~text)
  self~assertEquals("a", r~prefix)
  self~assertEquals("bc", r~suffix)

  r = p~find('abce')

  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(5, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("e", r~text)
  self~assertEquals("abc", r~prefix)
  self~assertEquals("", r~suffix)

  p = .Pattern~compile("a[^abc]c")

  r = p~find('abcaecyy')

  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(7, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("aec", r~text)
  self~assertEquals("abc", r~prefix)
  self~assertEquals("yy", r~suffix)


-- simple classes that are just sequences of characters, with negation
::method testRangeNotClass
  p = .Pattern~compile("[^a-c]")

  -- verify the entire excluded set
  self~checkExcludedCharacters(p, "abc")

  self~assertFalse(p~startsWith('abc'))
  self~assertFalse(p~startsWith('bye-bye'))
  self~assertFalse(p~startsWith('caldera'))
  self~assertTrue(p~startsWith('estuary'))

  r = p~find('eabc')

  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("e", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("abc", r~suffix)

  r = p~find('aebc')

  self~assertTrue(r~matched)
  self~assertEquals(2, r~start)
  self~assertEquals(3, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("e", r~text)
  self~assertEquals("a", r~prefix)
  self~assertEquals("bc", r~suffix)

  r = p~find('abce')

  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(5, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("e", r~text)
  self~assertEquals("abc", r~prefix)
  self~assertEquals("", r~suffix)

  p = .Pattern~compile("a[^a-c]c")

  r = p~find('abcaecyy')

  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(7, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("aec", r~text)
  self~assertEquals("abc", r~prefix)
  self~assertEquals("yy", r~suffix)

-- simple classes that use a range of characters
::method testRangeClass
  p = .Pattern~compile("[a-c]")

  -- verify the entire included set
  self~checkIncludedCharacters(p, "abc")

  self~assertTrue(p~startsWith('abc'))
  self~assertTrue(p~startsWith('bye-bye'))
  self~assertTrue(p~startsWith('caldera'))
  self~assertFalse(p~startsWith('estuary'))

  r = p~find('abc')

  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("a", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("bc", r~suffix)

  r = p~find('xbc')

  self~assertTrue(r~matched)
  self~assertEquals(2, r~start)
  self~assertEquals(3, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("b", r~text)
  self~assertEquals("x", r~prefix)
  self~assertEquals("c", r~suffix)

  r = p~find('xxc')

  self~assertTrue(r~matched)
  self~assertEquals(3, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("c", r~text)
  self~assertEquals("xx", r~prefix)
  self~assertEquals("", r~suffix)

  p = .Pattern~compile("a[a-c]c")

  r = p~find('xxabcyy')

  self~assertTrue(r~matched)
  self~assertEquals(3, r~start)
  self~assertEquals(6, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("abc", r~text)
  self~assertEquals("xx", r~prefix)
  self~assertEquals("yy", r~suffix)

-- simple classes that use multiple ranges of
::method testMultipleRangeClass
  p = .Pattern~compile("[a-bA-B]")

  -- verify the entire included set
  self~checkIncludedCharacters(p, "abAB")

  self~assertTrue(p~startsWith('abc'))
  self~assertTrue(p~startsWith('bye-bye'))
  self~assertTrue(p~startsWith('Abc'))
  self~assertTrue(p~startsWith('Bye-bye'))
  self~assertFalse(p~startsWith('estuary'))

  r = p~find('abc')

  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("a", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("bc", r~suffix)

  r = p~find('ABC')

  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("A", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("BC", r~suffix)

  r = p~find('xb')

  self~assertTrue(r~matched)
  self~assertEquals(2, r~start)
  self~assertEquals(3, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("b", r~text)
  self~assertEquals("x", r~prefix)
  self~assertEquals("", r~suffix)

  r = p~find('xB')

  self~assertTrue(r~matched)
  self~assertEquals(2, r~start)
  self~assertEquals(3, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("B", r~text)
  self~assertEquals("x", r~prefix)
  self~assertEquals("", r~suffix)

  r = p~find('xxb')

  self~assertTrue(r~matched)
  self~assertEquals(3, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("b", r~text)
  self~assertEquals("xx", r~prefix)
  self~assertEquals("", r~suffix)

  p = .Pattern~compile("a[a-bC-D]c")

  r = p~find('aBcabcyy')

  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(7, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("abc", r~text)
  self~assertEquals("aBc", r~prefix)
  self~assertEquals("yy", r~suffix)
-- character class union tests
::method testClassUnion
  p = .Pattern~compile("[a-b[A-B]]")

  -- verify the entire included set
  self~checkIncludedCharacters(p, "abAB")

  self~assertTrue(p~startsWith('abc'))
  self~assertTrue(p~startsWith('bye-bye'))
  self~assertTrue(p~startsWith('Abc'))
  self~assertTrue(p~startsWith('Bye-bye'))
  self~assertFalse(p~startsWith('estuary'))

  r = p~find('abc')

  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("a", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("bc", r~suffix)

  r = p~find('ABC')

  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("A", r~text)
  self~assertEquals("", r~prefix)
  self~assertEquals("BC", r~suffix)

  r = p~find('xb')

  self~assertTrue(r~matched)
  self~assertEquals(2, r~start)
  self~assertEquals(3, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("b", r~text)
  self~assertEquals("x", r~prefix)
  self~assertEquals("", r~suffix)

  r = p~find('xB')

  self~assertTrue(r~matched)
  self~assertEquals(2, r~start)
  self~assertEquals(3, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("B", r~text)
  self~assertEquals("x", r~prefix)
  self~assertEquals("", r~suffix)

  r = p~find('xxb')

  self~assertTrue(r~matched)
  self~assertEquals(3, r~start)
  self~assertEquals(4, r~end)
  self~assertEquals(1, r~length)
  self~assertEquals("b", r~text)
  self~assertEquals("xx", r~prefix)
  self~assertEquals("", r~suffix)
  p = .Pattern~compile("a[a-b[C-D]]c")

  r = p~find('aBcabcyy')

  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(7, r~end)
  self~assertEquals(3, r~length)
  self~assertEquals("abc", r~text)
  self~assertEquals("aBc", r~prefix)
  self~assertEquals("yy", r~suffix)

-- character class intersection tests
::method testClassIntersection
  p = .Pattern~compile("[a-z&&[abc]]")

  -- verify the entire included set
  self~checkIncludedCharacters(p, "abc")

  self~assertTrue(p~startsWith('abc'))
  self~assertTrue(p~startsWith('bye-bye'))
  self~assertTrue(p~startsWith('causeway'))
  self~assertFalse(p~startsWith('estuary'))

  r = p~find('abc')

  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)

  r = p~find('ABC')

  self~assertFalse(r~matched)

  r = p~find('xb')

  self~assertTrue(r~matched)
  self~assertEquals(2, r~start)
  self~assertEquals(3, r~end)

  -- some subraction.  This is essentially the same pattern
  -- as the first one, but the intersection is done by exclusion
  p = .Pattern~compile("[a-z&&[^d-z]]")

  -- verify the entire included set
  self~checkIncludedCharacters(p, "abc")

  self~assertTrue(p~startsWith('abc'))
  self~assertTrue(p~startsWith('bye-bye'))
  self~assertTrue(p~startsWith('causeway'))
  self~assertFalse(p~startsWith('estuary'))

  r = p~find('abc')

  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)

  r = p~find('ABC')

  self~assertFalse(r~matched)

  r = p~find('xb')

  self~assertTrue(r~matched)
  self~assertEquals(2, r~start)
  self~assertEquals(3, r~end)


-- predefined character classes
::method testPredefinedClasses
-- NOTE:  We're only going to test the matches
-- here.  By this point, all of the different
-- matches/startsWith/find options have been sufficiently
-- tested that if one works, they should all work correctly.

  -- all digits
  p = .Pattern~compile("\d")
  self~checkIncludedCharacters(p, "0123456789")

  -- no digits
  p = .Pattern~compile("\D")
  self~checkExcludedCharacters(p, "0123456789")

  -- whitespace
  p = .Pattern~compile("\s")
  self~checkIncludedCharacters(p, "20090a0b0c0d"x)

  -- non-whitespace
  p = .Pattern~compile("\S")
  self~checkExcludedCharacters(p, "20090a0b0c0d"x)

  -- word character
  p = .Pattern~compile("\w")
  self~checkIncludedCharacters(p, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789")

  -- non-word character
  p = .Pattern~compile("\W")
  self~checkExcludedCharacters(p, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789")

-- tests of the * pattern modifier
::method testStarModifier
  p = .Pattern~compile("a*")     -- zero or more occurrances of a
  self~assertTrue(p~matches(""))  -- null string should match
  self~assertTrue(p~matches("a")) -- single a should match
  self~assertTrue(p~matches("aaaaaa")) -- multiple a's should match
  self~assertFalse(p~matches("aaaaaaq")) -- the trailing one should not

  -- a few starts tests.  These are all true
  self~assertTrue(p~startsWith(""))  -- null string should match
  self~assertTrue(p~startsWith("a")) -- single a should match
  self~assertTrue(p~startsWith("aaaaaa")) -- multiple a's should match
  self~assertTrue(p~startsWith("aaaaaaq")) -- This should also match

  r = p~find("xyzaxyz")
  -- because this matches no characters, this will be a zero length match
  -- at the beginning
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(1, r~end)
  self~assertEquals("", r~text)

  r = p~find("aaaaxyz")
  -- because this matches all of the a characters at the beginning
  -- at the beginning
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(5, r~end)
  self~assertEquals("aaaa", r~text)

  p = .Pattern~compile("ab*c")     -- repetive in the middle
  self~assertTrue(p~matches("ac"))  -- no b's are fine
  self~assertTrue(p~matches("abc"))  -- one should be ok too
  self~assertTrue(p~matches("abbbbbbbbbbbbbbbbbc"))  -- and a whole bunch

  -- example from the online tutorial

  p = .Pattern~compile(".*foo")     -- this is a greedy pattern
  self~assertTrue(p~matches("xfooxxxxxxfoo"))  -- should consume the entire string
  self~assertTrue(p~startsWith("xfooxxxxxxfoo"))  -- one should be ok too
  -- this should match the entire string
  r = p~find("xfooxxxxxxfoo")

  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(14, r~end)
  self~assertEquals("xfooxxxxxxfoo", r~text)

-- tests of the + pattern modifier
::method testPlusModifier
  p = .Pattern~compile("a+")     -- zero or more occurrances of a
  self~assertFalse(p~matches(""))  -- null string should not match
  self~assertTrue(p~matches("a")) -- single a should match
  self~assertTrue(p~matches("aaaaaa")) -- multiple a's should match
  self~assertFalse(p~matches("aaaaaaq")) -- the trailing one should not

  -- a few starts tests.  These are all true
  self~assertFalse(p~startsWith(""))  -- null string not should match
  self~assertTrue(p~startsWith("a")) -- single a should match
  self~assertTrue(p~startsWith("aaaaaa")) -- multiple a's should match
  self~assertTrue(p~startsWith("aaaaaaq")) -- should also match

  r = p~find("xyzaxyz")
  -- because this must match at least one character, it will locate the a
  -- in the middle
  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(5, r~end)
  self~assertEquals("a", r~text)

  r = p~find("aaaaxyz")
  -- because this matches all of the a characters at the beginning
  -- at the beginning
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(5, r~end)
  self~assertEquals("aaaa", r~text)

  p = .Pattern~compile("ab+c")     -- repetitive in the middle
  self~assertFalse(p~matches("ac"))  -- must have at least one b
  self~assertTrue(p~matches("abc"))  -- one should be ok too
  self~assertTrue(p~matches("abbbbbbbbbbbbbbbbbc"))  -- and a whole bunch

-- tests of the ? pattern modifier
::method testQuestionModifier
  p = .Pattern~compile("a?")     -- zero or more occurrances of a
  self~assertTrue(p~matches(""))  -- null string should match
  self~assertTrue(p~matches("a")) -- single a should match
  self~assertFalse(p~matches("aa")) -- multiple a's should not

  -- a few startsWith tests.  These are all true
  self~assertTrue(p~startsWith(""))  -- null string should match
  self~assertTrue(p~startsWith("a")) -- single a should match
  self~assertTrue(p~startsWith("aa")) -- multiple a's should match

  r = p~find("xyzaxyz")
  -- because this can match "nothing", this will be a zero length match at the beginning
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(1, r~end)
  self~assertEquals("", r~text)

  r = p~find("aaaaxyz")
  -- because this will only match the first a at the beginning
  self~assertTrue(r~matched)
  self~assertEquals(1, r~start)
  self~assertEquals(2, r~end)
  self~assertEquals("a", r~text)

  p = .Pattern~compile("ab?c")     -- repetitive in the middle
  self~assertTrue(p~matches("ac"))  -- need not have a b
  self~assertTrue(p~matches("abc"))  -- one should be ok too
  self~assertFalse(p~matches("abbbbbbbbbbbbbbbbbc"))  -- only zero or 1 b works

-- tests of the {n} pattern modifier
::method testExactCountModifier
  p = .Pattern~compile("a{3}")     -- exactly 3 occurrances of a
  self~assertFalse(p~matches(""))  -- null string should not match
  self~assertFalse(p~matches("a")) -- single a should not match
  self~assertFalse(p~matches("aa")) -- one less than the required
  self~assertTrue(p~matches("aaa")) -- The required number
  self~assertFalse(p~matches("aaaa")) -- One required number

  -- a few startsWith tests.
  self~assertFalse(p~startsWith(""))  -- null string should not match
  self~assertFalse(p~startsWith("aa")) -- still not enough
  self~assertTrue(p~startsWith("aaa")) -- this is ok
  self~assertTrue(p~startsWith("aaaa")) -- as is this

  r = p~find("xaaxaaaxyz")
  -- this will only match at the second grouping of a's
  self~assertTrue(r~matched)
  self~assertEquals(5, r~start)
  self~assertEquals(8, r~end)
  self~assertEquals("aaa", r~text)

  p = .Pattern~compile("ab{2}c")     -- repetitive in the middle
  self~assertFalse(p~matches("ac"))  -- must have 2 a's
  self~assertFalse(p~matches("abc"))  -- also bad
  self~assertTrue(p~matches("abbc"))  -- this is good
  self~assertFalse(p~matches("abbbc"))  -- overshot the mark

-- tests of the {n,m} pattern modifier
::method testMinMaxCountModifier
  p = .Pattern~compile("a{2,4}")     -- at least 2, no more than 4
  self~assertFalse(p~matches(""))  -- null string should not match
  self~assertFalse(p~matches("a")) -- single a should not match
  self~assertTrue(p~matches("aa")) -- should match
  self~assertTrue(p~matches("aaa")) -- ditto
  self~assertTrue(p~matches("aaaa")) -- The limit
  self~assertFalse(p~matches("aaaaa")) -- nope

  -- a few startsWith tests.
  self~assertFalse(p~startsWith(""))  -- null string should not match
  self~assertFalse(p~startsWith("a")) -- single a should not match
  self~assertTrue(p~startsWith("aa")) -- should match
  self~assertTrue(p~startsWith("aaa")) -- ditto
  self~assertTrue(p~startsWith("aaaa")) -- The limit
  self~assertTrue(p~startsWith("aaaaa")) -- the extra is ignored.
  self~assertTrue(p~startsWith("aaaa")) -- as is this

  r = p~find("xaxaaaxyz")
  -- this will only match at the second grouping of a's
  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(7, r~end)
  self~assertEquals("aaa", r~text)

  r = p~find("xaxaaaaxyz")
  -- this should match the full 4 charactes
  self~assertTrue(r~matched)
  self~assertEquals(4, r~start)
  self~assertEquals(8, r~end)
  self~assertEquals("aaaa", r~text)

  p = .Pattern~compile("ab{2,3}c")     -- repetitive in the middle
  self~assertFalse(p~matches("ac"))  -- must have 2 a's
  self~assertFalse(p~matches("abc"))  -- also bad
  self~assertTrue(p~matches("abbc"))  -- this is good
  self~assertTrue(p~matches("abbbc"))  -- should also work
  self~assertFalse(p~matches("abbbbc"))  -- should fail

-- utility method to perform tests on character class
-- tests to ensure they will only match characters
-- in the given set
::method checkIncludedCharacters
  use arg p, includes

  do i = 0 to 255
      -- handle the special cases
      ch = d2c(i)
      -- this is in the target set, this must match
      if includes~pos(ch) > 0 then do
          self~assertTrue(p~matches(ch))
      end
      else do
          self~assertFalse(p~matches(ch))
      end
  end

-- tests of the {n,} pattern modifier
::method testAtLeastCountModifier
  p = .Pattern~compile("a{3,}")     -- exactly 3 occurrances of a
  self~assertFalse(p~matches(""))  -- null string should not match
  self~assertFalse(p~matches("a")) -- single a should not match
  self~assertFalse(p~matches("aa")) -- one less than the required
  self~assertTrue(p~matches("aaa")) -- The required number
  self~assertTrue(p~matches("aaaa")) -- still good

  -- a few startsWith tests.
  self~assertFalse(p~startsWith(""))  -- null string should not match
  self~assertFalse(p~startsWith("aa")) -- still not enough
  self~assertTrue(p~startsWith("aaa")) -- this is ok
  self~assertTrue(p~startsWith("aaaa")) -- as is this

  r = p~find("xaaxaaaxyz")
  -- this will only match at the second grouping of a's
  self~assertTrue(r~matched)
  self~assertEquals(5, r~start)
  self~assertEquals(8, r~end)
  self~assertEquals("aaa", r~text)

  r = p~find("xaaxaaaaxyz")
  -- this should match the full 4 charactes
  self~assertTrue(r~matched)
  self~assertEquals(5, r~start)
  self~assertEquals(9, r~end)
  self~assertEquals("aaaa", r~text)

  p = .Pattern~compile("ab{2,}c")     -- repetitive in the middle
  self~assertFalse(p~matches("ac"))  -- must have 2 a's
  self~assertFalse(p~matches("abc"))  -- also bad
  self~assertTrue(p~matches("abbc"))  -- this is good
  self~assertTrue(p~matches("abbbc"))  -- should also work

-- utility method to perform tests on character class
-- tests to ensure they will not only match characters
-- in the given set
::method checkExcludedCharacters
  use arg p, excludes

  do i = 0 to 255
      -- handle the special cases
      ch = d2c(i)
      -- this is in the target set, this must match
      if excludes~pos(ch) > 0 then do
          self~assertFalse(p~matches(ch))
      end
      else do
          self~assertTrue(p~matches(ch))
      end
  end


