<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog User Guide XML file.
    #
    # Copyright (c) 2011-2012 Rexx Language Association. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->

<!-- Appendix 02 - Testing Popups				  v00-01 17Sep11
     An illusteration of how popups can be tested in stand-alone mode with a
     single code base. Supported by an example in Exercises\Samples folder.

     Changes:
     v00-01 17Sep11: First version
-->
<appendix id="apx-satesting">
  <title id="satesting.title">Testing Popups in Stand-Alone Mode</title>
  <indexterm><primary>Testing</primary><secondary>Popups</secondary></indexterm>
  <indexterm><primary>Popups</primary><secondary>Stand-alone Testing</secondary></indexterm>
  <para>
  Consider four dialogs called Parent, Child, Grandchild, and GreatGrandChild.
  Parent is the "application" - the dialog that opens first, and from which other
  dialogs are directly or indirectly surfaced. Parent can thus be called the "root" dialog,
  and is designed to run in "standalone" mode - that is, it is not surfaced by
  some other dialog. It pops up Child dialogs, each of which may pop-up Grandchild
  dialogs, which in turn may pop-up GreatGrandchild dialogs, and so on.
  </para>
  <para>
  When testing the application, there is often a need to test an individual dialog
  which, in the application, is invoked by some other "parent" dialog and so issues
  <emphasis role="italic">self~popUpAsChild(...)</emphasis> rather than <emphasis
  role="italic">self~execute(...)</emphasis>. In addition, popping-up requires the parent dialog to be specified:
  <emphasis role="italic">self~popUpAsChild(parent,...)</emphasis>. In the Order Management application, the
  <computeroutput>OrderMgmtView</computeroutput> class is the parent for all child dialogs. The reason for using
  popupAsChild is so that, for example, a CustomerList can be closed without automatically closing any Customer dialogs
  that might have been opened from it.
  </para>
  <para>
  Now, using the parent dialog (Order Management in our case) as some sort of test-harness
  that will eventually surface the child dialog to be tested can be time-consuming and irritating.
  However, if a child dialog is started without the parent first being run, it must still be able to invoke
  subordinate dialogs in the same way as if it were running as part of the full application.
  Thus there is a need to enable
  individual child dialogs to be tested in "stand-alone" mode, without using the parent dialog just to
  surface them, but invoking other "subordinate" dialogs as if it was not being run stand-alone (so
  it's not truly stand-alone in the most precise interpretation of the term).
  In addition, a stand-alone test of what is normally a "child" dialog will
  require the child to act as the parent of any "grandchild" dialogs that it invokes, which means
  that the child must pass its own id to the grandchild instead of passing the parent's.
  </para>
  <para>One approach to resolving this problem is to have two versions of each child dialog - one
  using <emphasis role="italic">~execute(...)</emphasis> and one using <emphasis
  role="italic">~popupAsChild(...)</emphasis>. This results in two code bases for each dialog - which can quickly get
  out of sync. Not the best idea.
  </para>
  <para>
  An arguably better solution is to build each dialog so it can be run either individually
  (stand-alone) or within the application. The file <computeroutput>TestPopups.rex</computeroutput>
  in the folder <computeroutput>Samples\PopupTesting</computeroutput> shows a way of doing this.
  </para>
  <para>
  The rules illustrated by the code in <computeroutput>TestPopups.rex</computeroutput> are as follows,
  assuming an application consisting of a single Parent dialog that invokes one or more Child dialogs,
  each of which may invoke one or more Grandchild dialogs, each of which may invoke one or more
  GreatGrandChild dialogs. The child and grandchild dialogs are "intermediate" dialogs.
  The GreatGrandChild dialog is a "leaf" dialog - that is, it does not invoke any
  other dialog (except of course those integral to its own functioning such as an About box
  or a data entry sub-dialog). For completeness, the Parent dialog is included in the following.
    <programlisting>
<![CDATA[
The Parent Dialog:

  (1) Is invoked from a Startup script with:
        .ParentDlg~newInstance

  (2) Provides an event handling method that sufaces a Child dialog:

        ::METHOD popupAChild
          ...
          .ChildDialog~newInstance(self)
          ...

An Intermediate Dialog:

  (1) For stand-alone testing is invoked from a Startup script with:
        .AnIntermediateDlg~newInstance("SA")

  (2) Provides the following methods (among others):

      ::METHOD newInstance CLASS
        use arg rootDlg
        ...
        dlg = self~new
        dlg~activate(rootDlg)

      ::METHOD activate UNGUARDED
        expose rootDlg
        use arg rootDlg
        ...
        if rootDlg = "SA" then do			-- If standalone operation required
          rootDlg = self				      -- To pass on to children
          self~execute("SHOWTOP")
        end
        else self~popupAsChild(rootDlg, "SHOWTOP")

      ::METHOD eventHandler UNGUARDED   -- An event handler method
        expose rootDlg
        .ASubordinateDlg~newInstance(rootDlg)

A Leaf Dialog:

  (1) For standalone testing is invoked from a Startup script with:
        .ALeafDlg~newInstance("SA")

  (2) Provides the following methods (among others):

      ::METHOD newInstance CLASS
        use arg rootDlg
        ...
        dlg = self~new
        dlg~activate(rootDlg)

      ::METHOD activate
        use arg rootDlg
        if rootDlg = "SA" then self~execute("SHOWTOP")
        else self~popupAsChild(rootDlg, "SHOWTOP")
]]>
</programlisting>




=======================================================================================
  </para>

</appendix>
