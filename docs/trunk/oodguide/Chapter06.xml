<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog User Guide XML file.
    #
    # Copyright (c) 2011-2012, Rexx Language Association. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->

<!-- Chapter06 - List Views, Re-Sizing, and PopUps 		  v00-04 ??Feb12

    Changes:
     v00-01 25Aug11: First version
     v00-02 03Dec11: Second version.
     v00-03 03Feb12: Sorted out structure; added text.
     v00-04 ??Feb12

    6     "An Application Workplace"      chapSix
    6.1     Program Structure             chap06-struc
    6.1.1     Overview
    6.1.2     Some Implications
    6.1.2.1     File Paths
    6.1.2.2     .Application Usage
    6.1.2.3     Externalized Strings
    6.1.3     Application Function
    6.2     Popups and Parents            chap06-popups
    6.3     Icons and Lists               chap06-lviews
    6.3.1     The Icon View               chap06-lviews-icon
    6.3.2     The Report View             chap06-listview-report
    6.4     Re-sizing Dialogs             chap06-resize
    6.5     Creating and Using Icons      chap06-icons
    6.6     Utility Dialogs               chap06-utildlgs

-->
<chapter id="chapSix"><title>An Application Workplace</title>
<indexterm><primary>OrderManager component</primary></indexterm>
<para>This chapter introduces the Order Management application, which is designed as a "workplace"
      for a user handling sales orders. As such, it provides access to the required components -
      customers, products, orders, and order forms. A common approach for a "workplace" dialog is to
      provide an icon for each component that the user may wish to use. In the
        <computeroutput>Exercise06</computeroutput> folder, run
        <computeroutput>startup.rex</computeroutput>. The Order Management dialog opens, and
      consists mainly of a List View containing four icons. Move the icons around; double-click them
      and if a Customer, Product, or Order List appears then double-click a list item; re-size the
      Order Management window; check out the menu items and the pushbuttons. As you see, while much
      of the application function is absent, and the data is hard-coded, and there is some
      redundancy (e.g. every time you double-click on an item in a list view a new Model and Data
      object is created), the essential parts of the Order Management application mentioned in
      <xref linkend="chapFour"/> are visible. This chapter addresses the following topics in the context
      of the Order Management application: <itemizedlist>
        <listitem>
          <para><xref linkend="chap06-struc"/></para>
        </listitem>
        <listitem>
          <para><xref linkend="chap06-popups"/></para>
        </listitem>
        <listitem>
          <para><xref linkend="chap06-lviews"/></para>
        </listitem>
        <listitem>
          <para><xref linkend="chap06-resize"/></para>
        </listitem>
        <listitem>
          <para><xref linkend="chap06-icons"/></para>
        </listitem>
        <listitem>
          <para><xref linkend="chap06-utildlgs"/></para>
        </listitem>
      </itemizedlist>
    </para>

<section id="chap06-struc"><title>Program Structure</title>  <!-- Section 6.1 -->

  <section id="chap06-struc-overview"><title>Overview</title>  <!-- Section 6.1.1 -->
  <para>In Exercise06, each business component has its own folder:
    Customer, Order, OrderMgr, and Product. Customer and Product are more or less identical
    to the same components introduced in Exercises 04 and 05.
    Placing each business component into a separate folder
    helps promote high cohesion and low coupling in the software,
    since the internals of each business component are opaque to other business components.
    Thus another application (e.g. Customer Relationship
    Management) might be able to make use of the Customer business component without change.
    The Order Management business component is unlikely to be re-used in other applications as it is
    a kind of "process" business component that "choreographs" the other business components.
    To the user, creating a new sales order consists of "choreographing" the various business aspects
    required - creating an Order Form (used to assemble the customer order), searching for and selecting a
    specific Customer, searching for and selecting one or more Products, recording the quantities ordered,
    and producing a Sales Order that is the "contract" between supplier and customer. Of course, the OrderManagement
    component could be used by "higher-level" components such as business processes or workflows. In systems
    organized according to these principles, invocation of components takes the form of a directed acyclic graph.
  </para>
  <para>
    Within each business component are one or more component groups and components. For example, the Customer
    business component contains two component groups: CustomerList and Customer. In turn,
    each of these consists of one View component and one Model component. Both model components
    share a single Data component. The Customer and Product
    component groups are essentially identical to those introduced in Exercises 4 and 5 respectively.
  </para>
  <para>The Order Management business component is, in this Exercise, implemented by a view class
          only. In fact, there are two view classes, each in its own .rex file:
            <computeroutput>OrderMgmtBaseView</computeroutput> and its subclass
            <computeroutput>OrderMgmtView</computeroutput>.
            <computeroutput>OrderMgmtBaseView</computeroutput> contains the code for handling a
          re-sizable dialog, and is a subclass of <computeroutput>UserDialog</computeroutput> which
          is required for any dialog that is dynamically re-sizable (see
          <xref linkend="chap06-resize"/>). <computeroutput>OrderMgmtView</computeroutput> contains the
          code specific to the Order Management application. The only reason for splitting the code
          like this is that it seems to fall happily into these two parts. This reduces the amount
          of code in any one class or file, and so (arguably) makes for better readability. </para>
  <para>Note that the "data" of the OrderManagement business component is the set of icons and their
    associated data. In Exercise06, this data is effectively embedded in the View classes.
    However, the code in the <computeroutput>OrderMgmtView</computeroutput> class uses an
    <emphasis role="italic">interpret</emphasis> instruction to launch views of the
    components represented by icons. Thus in principle, additional components can be added
    without changing the code in the <computeroutput>OrdermgmtView</computeroutput> class. To
    support this, a separate file - <computeroutput>RequiresList.rex</computeroutput> -
    contains the set of <emphasis role="italic">::requires</emphasis> statements corresponding
    to the components that might be surfaced. This is why the first executable statement in
    the file <computeroutput>OrderMgmtView.rex</computeroutput> is
    <emphasis role="italic">call "OrderMgmt\RequiresList.rex"</emphasis>. Examples of possible additional
    components could be a "commodities" component which shows the commodities required to
    produce a given product; or a credit-check component that links to an external
    credit-check agency.</para>
  <para>Finally, it's worth noting that the folder structure, while useful for development, is
    not necessarily the most appropriate structure for a deployed application. A more
    appropriate deployment structure will be described in the next chapter.
  </para>
  </section>  <!-- End of section 6.1.1 -->

  <section id="chap06-struc-impls"><title>Some Implications</title>  <!-- Section 6.1.2 -->
    <para>Choosing this folder structure for the development of the application has these
      design implications: file paths, the use of <computeroutput>.Application</computeroutput>, ????
    </para>
    <section id="chap06-struc-impls-paths"><title>File Paths</title>  <!-- Section 6.1.2.1 -->
      <para>When an ooRexx program is run, the current (or
        "home") directory is that from which the program is started. (That is, if a
        program is started on a command prompt like this: <computeroutput>c:\aaa\bbb>myprog.rex</computeroutput>,
        then the current directory will be <computeroutput>c:\aaa\bbb</computeroutput>. However, if the program
        is started like this: <computeroutput>c:\aaaa>bbb\myprog.rex</computeroutput>, then the current directory
        will be <computeroutput>c:\aaa</computeroutput> .) In Exercise06,
        all programs are started from the <computeroutput>Exercise06</computeroutput>
        folder. Thus any relative paths must be relative to
        <computeroutput>Exercise06</computeroutput>. However, using ResEdit with relative
        paths, the path for a resource such as a dialog icon is relative to the folder in
        which the *.rc file is created. For example, if <computeroutput>CustomerView.rc</computeroutput>
        is created in the <computeroutput>Customer</computeroutput> folder, then the icon will be specified
        in <computeroutput>CustomerView.rc</computeroutput> with the path
        <computeroutput>".\\bmp\\Customer.ico"</computeroutput> So the path to the icon
        resource in the *.rc file will be wrong, and the dialog icon will not be shown.</para>
      <para>The solution is either to edit the *.rc file and change the icon resource's path, or (much better)
        create the *.rc file in the Exercise06 folder and then move it into the
        <computeroutput>Customer</computeroutput> folder.
      </para>
      <para>Considering the implication of paths also applies to other parts of the code, such
        header files specified in the
        <computeroutput>.Application~addToConstDir(...)</computeroutput> statement.
      </para>
      <para>In summary, all paths (if not absolute) must be relative to the folder from which the
        program is started. This is why, when running a stand-alone test such as
        <computeroutput>startupCustomer.rex</computeroutput>, the program must be started
        from the <computeroutput>Exercise06</computeroutput> folder, since the design decision was
        taken to make all paths relative to <computeroutput>Exercise06</computeroutput> folder.
      </para>
      <para>This discussion on paths prompts two thoughts (at least). First, is there not a way to have some support code
        manage paths, so that each component asks this support code for the path it should use? While this may be feasible,
        it's much more a design question than an ooDialog one, and so is not pursued here. Second, using ResDialog instead of
        RcDialog reduces the problem of paths, since resources such as icons and bitmaps are placed in the *.dll file.
      </para>
      </section>  <!-- End of Section 6.2.1.1 -->

    <section><title>.Application Usage</title>  <!-- Section 6.2.1.2 -->
      <para>The startup file (<computeroutput>startup.rex</computeroutput>) applies application-wide
        defaults with the statement <computeroutput>.Application~setDefaults("O", , .false)</computeroutput>.
        However, the header file for each view class is included in its <computeroutput>newInstance</computeroutput>
        method; for example: <computeroutput>.Application~addToConstDir("Customer\CustomerView.h")</computeroutput>.
        For a shipped application that includes multiple classes, it would be much better to provide all the
        <computeroutput>~addToConstDir</computeroutput> statements in the startup file after, say, the
        <computeroutput>~setDefaults</computeroutput> statement. However, because at this stage the application
        is still in a pre-deployment state, and each component needs to be able to be unit-tested (see "Stand-alone Testing" below),
        it was deemed better to include <computeroutput>~addToConstDir</computeroutput> statements in each view file
        (of course an alternative is to include them in the unit-test startup programs).
      </para>
    </section>  <!-- End of Section 6.1.2.2 -->

    <section><title>Externalized Strings</title>  <!-- Section 6.1.2.3 -->
      <para>All components that display information to the user have the displayed strings separated from code either in
        a class whose name is prefaced "HRS" for "Human-Readable Strings" or in a *.rc file. Each such class name has a suffix
        - e.g. "HRScv" for the <computeroutput>CustomerView</computeroutput> class. The reason for the suffix is to
        distinguish the various HRS classes if the various files were later to be placed into a single file for
        application deployment purposes.
      </para>
      <para>Human-readable strings in *.rc classes are a problem when internationalization is a requirement. Internationalization
        (often referred to as I18N - there are 20 letters in the word "internationalization") is the term often given to
        allowing for translation of human-readable text to other languages.
        <indexterm><primary>Internationalization</primary></indexterm>
        An immediate solution is to display the translated strings from within the program rather than from the *.rc file.
        The <emphasis role="italic">initDialog</emphasis> method is a good place to do this. Try inserting the following
        in <computeroutput>CustomerView.rex</computeroutput>, say just before
        the statement <computeroutput>self~getData</computeroutput> in <emphasis role="italic">initDialog</emphasis>:
        <programlisting>
        <![CDATA[
          custNameLabel = self~newStatic("IDC_CUST_LBL_CUSTNAME")
          custNameLabel~setText("Namen:")
        ]]>
        </programlisting>
        The Customer View will be displayed with "Namen" (German)instead of "Name" (English).
      </para>
      <para>Of course, this text should
        come from an HRS class or better from a proper I18N resource file. Such files would be produced using special
        I18N tools. These tools take account of the many considerations and gotchas of internationalization.
        For example, in our trivial attempt to change the label from English "Name" to German "Namen", we've lost the colon
        at the end. This is because the
        horizontal space given to this particular static text in <computeroutput>CustomerView.rc</computeroutput> is not big enough.
        Some authorities suggest that 150% of the space required for English is needed to allow for proper translations to other languages.
        And this is only one of the lesser considerations in the task of internationalization.
        The following quote from the Wikipedia entry illustrates something of the full complexity of I18N:
        "It should be noted that "internationalized" does not necessarily mean that a system can be used absolutely anywhere,
        since simultaneous support for all possible locales is both practically almost impossible and commercially very hard
        to justify. In many cases an internationalized system includes full support only for the most spoken languages,
        plus any others of particular relevance to the application."
      </para>
    </section>  <!-- End of Section 6.1.2.3 -->

  </section>  <!-- End of Section 6.1.2 -->

  <section><title>Application Function</title>  <!-- Section 6.1.3 -->
  <para>

    <!--
      - the OrderManagerView
      is the "home" window. It'll have a sign-on and password field in a sub-dialog
      (also programmer-designed) which comes modally  when the OrderManagemwent
      window is established. Thus we demonstrate/discuss:
      - programmatic layout (can only use userDialog)
      - modal sub-window
      - Handling icons and showing them.
      - password dialog (shows asterisks when you type into it) - but can avoid
      with startup param "skipPW" (but the dialog in the startup prog to show
      use of ooDialog in normal rexx progs).
      - Icons that when dbl-clicked startup other views
      - Most menu items on OrderMgmgt dialog not implemented.

      - app function very absent - e.g. all dialog data is hard-coded - same for Cust, Prod, Order - no real data in any file.
      - e.g. no function for "New Order"
    -->

    Generally, in real applications, creating a Customer, or Product, or Order each requires a processmore
    complex process than shown by the sample application. This means that real apps have a different GUI than that shown here.
    But for present purposes, we'll assume Customer and Product get new records from a different place,
      so new records can(in this sample app) be got by adding to the relevant data files.
      However, OrderForm and Order are different - so have a component each.


    Naming - explain diff between OrderMgmt and OrderMgr where appropriate.

  </para>
  </section>  <!-- End of Section 6.1.3 -->

</section>  <!-- End of section 6.1 -->

<section id="chap06-popups"><title>Popups and Parents</title>  <!-- Section 6.2 -->
  <indexterm><primary>Popups</primary><secondary>Parents</secondary></indexterm>
  <indexterm><primary>Parents</primary><secondary>Popups</secondary></indexterm>
  <!--
    6.2    Pop-Ups and Parents incl Non-Modal Dialogs
    6.2.1    How get pop-up to pop up away from parent? Answer - have to code it yourself.
    6.2.2    Starting a dialog from a dialog (incl interpret statement - pointer to later)
    Use of "interpret", better would be to have a class object - but later we'll need interpret (won't we?) for the ObjectMgr.
    Leave "interpret" in but mention it – say class object would be better - show how can be fixed in later exercise – where
    this will be moved to a support class (ObjectMgr).
  -->

  <section id="chap06-nonmodal"><title>Non-Modal Dialogs</title>  <!-- Section 6.2.1 -->
    <para>
    </para>
  </section>  <!-- End of Section 6.2.1 -->

  <section id="chap06-dlgStart"><title>Starting a Popup Dialog</title>  <!-- Section 6.2.2 -->
    <para>
    </para>
  </section>  <!-- End of Section 6.2.2 -->


</section>  <!-- End of Section 6.2 -->

<section id="chap06-lviews"><title>Icons and Lists</title>  <!-- Section 6.3 -->
    <indexterm><primary>ListView</primary></indexterm>
    <indexterm><primary>Controls</primary><secondary>ListView</secondary></indexterm>
    <indexterm><primary>Icons</primary><secondary>in a ListView</secondary></indexterm>

  <para>The <computeroutput>ListView</computeroutput> should not be confused with <computeroutput>ListBox</computeroutput>;
  a ListView (see ooDialog Reference chapter 20) is a souped-up ListBox with lots of additional features. In particular:
  <itemizedlist>
    <listitem><para>An item in a ListView can be a complex structure or "record" containing
      multiple fields. One of these fields is termed the "label" of the item.</para></listitem>
    <listitem><para>ListView items can be displayed in four different modes:
      <itemizedlist>
        <listitem><para>Icon view - each item appears as a full-sized icon with a label below it.
          Items can be dragged around the ListView.</para></listitem>
        <listitem><para>Small-icon view - each item appears as a small icon with a label to its right.
          Items can be dragged around the ListView.</para></listitem>
        <listitem><para>List view - each item appears as a label with an optional small icon to its left.</para></listitem>
        <listitem><para>Report view - each item appears as a row in a table with an optional small icon to its left.
          </para></listitem>
      </itemizedlist>
      The four different modes are well illustrated by the sample program <computeroutput>oodListViews.rex</computeroutput>
      located in the <computeroutput>ooRexx\samples\oodialog</computeroutput> folder.</para></listitem>
  </itemizedlist>
  </para>
  <para>In the Order Management application, the ListView control provides the main area of the Order Management dialog
    where draggable icons (icon view) represent the various components of the application.
    It also provides the tabular lists (report views) in the CustomerList, ProductList, and OrderList dialogs.
    </para>

  <section id="chap06-lviews-icon"><title>The Icon View</title>  <!-- Section 6.3.1 -->
    <!--

      6.3.1    The Icon View
      - List Views - normal icon view - a "workplace" for Order Management..
      - Auto-resizing when window sized by user
    -->

  <para>

<!--
    OMBV
1     ::attribute lv

    OMV
2     ::method init
        expose records
        self~createIconList                               3
        records = self~initRecords                        4

5     ::method initDialog
        expose iconList records
        self~lv~newListView(..)
        self~lv~setImageList(..)
        /*- Add icons (i.e. records) to the ListView:  (actually used two hyphens at start - but oXygen doesn't like this.)*/
        do i=1 to records~items
          self~lv~addRow(, i-1, records[i]~name)
        end

3     ::method createIconList
        expose iconList
        imgCustList = .Image~getImage( filename )
        ...
        iconList = .ImageList~create(...)
        iconList~add(imgCustList)   /* item 0 in the list */
        ...

4     ::method initRecords
        expose records
        records = .array~new()
        rec = .directory~new
        rec~ID = "CustomerList"
        rec~name = "Customer List"
        records[1] = rec
        ...
        return records

6     ::method onDoubleClick
        expose records
        index = self~lv~focused   /* lv is an attribute of OBMBV */
-->

    The OrderManagement dialog uses the Icon View option of the ListView control. Five things are needed to produce an
    icon view: first, create (or obtain) some icons; second, specify the <computeroutput>ICON</computeroutput> style for the ListView
    control; third, create an ImageList from the icons (required by the ListView control); fourth, create a set of records
    (one record per icon) to be loaded into the ListView; and fifth, load the icons and records into the ListView.
    </para>
    <orderedlist numeration="arabic">

      <listitem> <!-- One -->
        <para><emphasis role="bold"><emphasis role="italic">Produce the Icons</emphasis></emphasis></para>
        <para>First, the large "icons" in the ListView are actually bitmaps. Icons and bitmaps have different formats, and different uses,
          and there are a number of differences between them. The icons themselves
          are in the folders of the relevant business components, so the icon for the Customer List, for example, is
          <computeroutput>Exercise06\Customer\bmp\CustList.bmp</computeroutput>. (The <computeroutput>*.ico</computeroutput>
          files are the dialog icons.)
          A number of tools are available for creating and editing images, icons, bitmaps etc.,
        some of them providing conversion and re-sizing capabilities. One such is GIMP (GNU Image Manipulation Program) from
        http://www.gimp.org.
        <indexterm><primary>Bitmap Editor</primary></indexterm><indexterm><primary>Icon editor</primary></indexterm>
        </para>
      </listitem>

      <listitem> <!-- Two -->
        <para><emphasis role="bold"><emphasis role="italic">Specify the ICON Style</emphasis></emphasis></para>
        <para>The icon style for a ListView control is specified either in the
                <computeroutput>*.rc</computeroutput> file as the
                <computeroutput>LVS_ICON</computeroutput> (in ResEdit, set the "View" property to
              "Icon"), or in a UserDialog, by creating the ListView control in the
          <emphasis role="italic">initDialog</emphasis> method using the
                <computeroutput>ICON</computeroutput> style (e.g.:
                <computeroutput>self~createListView(IDC_ORDMGMT_ICONS, ... "ICON")</computeroutput>
              where the first parameter is the ID for the ListView control.). </para>
      </listitem>

      <listitem> <!-- 3 -->
        <para><emphasis role="bold"><emphasis role="italic">Create an ImageList</emphasis></emphasis></para>
        <para>The ListView documentation provides several ways to load icons. Probably the easiest is to create an
              object of type <computeroutput>ImageList</computeroutput> (see ooDialog Reference
              section 26.3) which is loaded into the ListView. In <computeroutput>OrderMgmtView</computeroutput>, this
              is done in the <emphasis role="italic">createIconList</emphasis> method
          (invoked from the <emphasis role="italic">init</emphasis> method) as follows:
        <programlisting>
        <![CDATA[
          ::METHOD createIconList PRIVATE
            expose iconList
            imgCustList  = .Image~getImage("customer\bmp\CustList.bmp")
            imgProdList  = .Image~getImage("product\res\ProdList.bmp")
            imgOrderList = .Image~getImage("order\bmp\OrderList.bmp")
            imgOrderForm = .Image~getImage("order\bmp\OrderForm.bmp")
            -- Boldly assume no errors in creating the Image List or in the ~getImage statements.
            iconList = .ImageList~create(.Size~new(64, 64), .Image~toID(ILC_COLOR4), 4, 0)
            iconList~add(imgCustList)   -- item 0 in the list
            iconList~add(imgProdList)   -- item 1 in the list
            iconList~add(imgOrderList)  -- item 2 in the list
            iconList~add(imgOrderForm)  -- item 3 in the list
            imgCustList~release
            imgProdList~release
            imgOrderList~release
            imgOrderForm~release
            return
        ]]>
        </programlisting>
    For each icon, only two statements are required: create an Image from file then copy it to the ImageList (and a third, if you're
    a polite programmer and try to clean up afterwards, release the image).
    </para>
    </listitem>

    <listitem>  <!-- 4 -->
    <para><emphasis role="bold"></emphasis>Create Records</para>
    <para>Records are typically created in the <emphasis role="italic">init</emphasis> method (or in a method invoked from there).
      In <computeroutput>OrderMgmgtView</computeroutput> the records are created in the <emphasis role="italic">initRecords</emphasis>)
      method which is invoked from <emphasis role="italic">init</emphasis>. Each record has two fields: the text to appear beneath
      the icon, and the class name of the dialog to be surfaced when a user double-clicks on an icon. The design choice for these records
      is that each record will be a directory, and each directory will stored in an array. The array index of a record is equivalent
      to the position of its icon in the ImageList (remembering that arrays are 1-based while ImageLists are 0-based). The code for loading
      the record array is
      as follows (showing only the Sales Orders item for brevity):
      <programlisting>
    <![CDATA[
      ::METHOD initRecords PRIVATE
      expose records
      records = .array~new()
      ...
      rec = .directory~new
      rec~ID = "OrderList"
      rec~name = "Sales Orders"
      records[3] = rec
      ...
      return records
    ]]>
    </programlisting>
    </para>
  </listitem>
  <listitem> <!-- 5 -->
    <para><emphasis role="bold">Load the ImageList and the Records</emphasis></para>
    <para>Loading icon images and records into the ListView is done in the
      <emphasis role="italic">initDialog</emphasis>method:
    <programlisting><![CDATA[
    ::METHOD initDialog
      expose records iconList
      self~initDialog:super
      self~lv~setImageList(iconList, .Image~toID(LVSIL_NORMAL))
      do i=1 to records~items
        self~lv~addRow(, i-1, records[i]~name)
      end
    ]]>
    </programlisting>
      After invoking the superclass, the icons in the ImageList are applied to the ListView control
      using its <emphasis role="italic">setImageList</emphasis> method. The second parameter of this method
      specifies the size of the icons by invoking
      the Image class' <emphasis role="italic">toID</emphasis> method with the parameter <emphasis role="italic">LVSIL_NORMAL</emphasis>
      (the flag for the icon view). The Image class is used to work with and manipulate images,
      and is described in section 26.2 of the ooDialog Reference. The variable
      <emphasis role="italic">self~lv</emphasis> is the list view proxy, <emphasis role="italic">lv</emphasis> being an
      attribute of the <computeroutput>OrderMgmtBaseView</computeroutput> superclass.
      The icons having been set, the records are then added
        using the ListView's <emphasis role="italic">addRow</emphasis> method. The first parameter is the index of the list item
      - if omitted, the record is added after the last. The second parameter is the index of the icon to be used with this record, and
      the last parameter is the label for the list item - the string "Customer List" in the case of the first item added to the ListView in
      <computeroutput>OrderMgmtView</computeroutput>.
      </para>
    </listitem>
  </orderedlist>

  </section>  <!-- End of section 6.3.1 -->

  <section id="chap06-listview-report"><title>The Report View</title>  <!-- Section 6.3.2 -->
    <!--
      6.3.2.   The Report View
      - Looking at the two list views, almost begs for a superclass.
      - how do different fonts for the listView items
      - Explain the surfacing of an instance in the listview dialogs - check the showModel method.
    -->
    <para>Three of the icons in the Order Management dialog surface a list when double-clicked - Customers, Products, and Orders.
      These three components are technically very similar - to the extent that a "list superclass" could perhaps be created.
      For the meantime, however, this is not done, and each list is quite separate. However, their similarity means that discussing one
      list - the Customer List - effectively addresses all.
    </para>
    <para></para>
  </section>  <!-- End of section 6.3.2 -->

</section>  <!-- End of section 6.3 -->

<section id="chap06-resize"><title>Re-sizing Dialogs</title>  <!-- Section 6.4 -->
<para>If you haven't already done so, try re-sizing the Order Management dialog.
  The ListView containing the icons
  expands to match the new window size, and one of the two pushbuttons moves as well, although their size
  - unlike the size of the List View - does not change. This re-sizing function is only available
  for a <computeroutput>UserDialog</computeroutput>, and requires a number of methods and lines of code.
  ooDialog provides three samples of the resizing function in the folder
  <computeroutput>ooRexx\samples\oodialog</computeroutput> folder -
  the relevant programs being <computeroutput>dlgAreaUDemo.rex</computeroutput>,
  <computeroutput>dlgAreaUDemoTwo.rex</computeroutput>, and
  <computeroutput>dlgAreaUDemoThree.rex</computeroutput>.
  <computeroutput>OrderManagementBaseView.rex</computeroutput> includes much of the code from the last
  of these three samples.
</para>
<para>
  The re-sizing function is provided by two ooDialog classes: <computeroutput>dlgAreaU</computeroutput>
  and <computeroutput>dlgArea</computeroutput> (see ooDialog Reference sections 10.14 and 10.15).
  An important constraint is that, because <computeroutput>dlgAreaU</computeroutput> parses
  the source code of the <emphasis role="italic">defineDialog</emphasis> method in order to handle re-sizing,
  it will only work with <computeroutput>UserDialog</computeroutput>, where the dialog template is created
  through explicit control creation statements. In addition, since the source code is required at run-time,
  it will not work if the source code is tokenized using <emphasis role="italic">rexxc</emphasis>.
</para>
<para>
  Essentially, the dialog is first split into a number of areas - two areas for the
  OrderManagement dialog. ears for . dilaog defines the A re-sizeable dialog - an excellent sample dialog -
    </para>
</section>  <!-- End of section 6.4 -->


<section id="chap06-icons"><title>Creating and Using Icons</title>  <!-- Section 6.5 -->
  <!--
    6.5    Creating and Using Icons
    - Icons - making them, getting 'em into the program. -
    (1) Does the icon have to be a certain size, or will it get automatically shrunk?
    (2) If it has to be a certain size, what's the size, and are there any restrictions as to the palette (I'm no expert, but using GIMP I'm given the option of saving as 16-bit, 24-bit or 32-bit color (or I think it's color!)).
    (3) In the ~execute statement, I need to provide an ID. Does this mean I must have a *.rc file? Or can I invent an ID programmatically somehow - perhaps along the same lines as creating an ImageList?
    (4) I want to assign my own icon as the dialog icon (that is, the icon at the extreme top left of a dialog). This is done (I understand) in the ~execute(..., <icon_ID> ) method (ooDialog Reference section 3.10.3).
  -->
  <para>- Icons - making them, getting 'em into the program. - GIMP (GNU Image Manipulation Program) from
      http://www.gimp.org
</para>
</section>  <!-- End of section 6.5 -->

<section id="chap06-utildlgs"><title>Utility Dialogs</title>   <!-- Section 6.6 -->
  <indexterm><primary>Password dialog</primary></indexterm>
  <indexterm><primary>Utility routine</primary><secondary>PasswordBox</secondary></indexterm>
  <!--
    6.6    Utility Dialogs - <- ??? <What's this??> (Is this the layer - process-entity-utility? Or just useful "canned" dialogs?)
    - Mention password on startup to illustrate ooDialog use in otherwise non-ooDialog rexx programs.
    "startup enterPW" - password is "Password".
  -->
  <para>A subject not yet mentioned is the use of ooDialog utility classes and routines in non-ooDialog ooRexx programs.
    These are documented in Chapter 9 of the ooDialog Reference. The routines are very simple, and are often one-liners.
    As an example, the Exercise06 startup program
    provides for entry of a password using the (one-line) PasswordBox routine.
    Invoking <emphasis role="italic">startup enterPW</emphasis> produces a password box that will accept the password
    "Password". If you get the password wrong, the startup routine will silently end. The code is as follows:
    <programlisting>
    <![CDATA[
    parse arg pwOption
    if pwOption = "enterPW" then do
      pwd = PasswordBox("Please enter your password","Sign In")
      if pwd \= "Password" then exit
    end
    .OrderMgmtView~newInstance
    ::REQUIRES "OrderMgmt\OrderMgmtView.rex"
    ]]>
    </programlisting>

    </para>
</section>  <!-- End of section 6.6 -->

</chapter>

