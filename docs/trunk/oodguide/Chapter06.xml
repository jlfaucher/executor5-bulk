<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog User Guide XML file.
    #
    # Copyright (c) 2011-2012, Rexx Language Association. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->

<!-- Chapter06 - List Views, Re-Sizing, and PopUps 		  v00-03 03Feb12

    Changes:
     v00-01 25Aug11: First version
     v00-02 03Dec11: Second version.
     v00-03 03Feb12: Sorted out structure and added some text.


     6.    An Application Workplace

- the OrderManagerView
     is the "home" window. It'll have a sign-on and password field in a sub-dialog
     (also programmer-designed) which comes modally  when the OrderManagemwent
     window is established. Thus we demonstrate/discuss:
     - programmatic layout (can only use userDialog)
     - modal sub-window
     - Handling icons and showing them.
     - password dialog (shows asterisks when you type into it) - but can avoid
       with startup param "skipPW" (but the dialog in the startup prog to show
       use of ooDialog in normal rexx progs).
     - Icons that when dbl-clicked startup other views
     - Most menu items on OrderMgmgt dialog not implemented.

            - app function very absent - e.g. all dialog data is hard-coded - same for Cust, Prod, Order - no real data in any file.
                                                    - e.g. no function for "New Order"
     6.1    Program Structure
     6.1.1      Have to change .rc file manually to get icon showing properly - ResEdit makes it .\bmp\icon.ico
                   instead of .\order\bmp\icon.ico - even if you start resedit from Exercise06 and specify "resedit order\orderlistview.rc".
                   (Paths - esepc for ResEdit.)
     6.1.2    about use of .Application - not good for a shipped app - address later when "package" an app for shipping.
     6.1.3    Mention HRS class name changes to allow for possible packaging - all classes in a single file.
     6.1.3    Stand-alone testing
                  - incl how get dlgicons to show (Answer: rc file must be built and saved into the parent folder so that file path is right for invocation from the parent folder. )
                          Ditto for ResDialog - compile the dll in the parent folder (check this!)
     6.1.4    Several place-holders for app functions - custmodel & custdata created for each showmodel. Fix in next exercise.
     6.1.5    One Folder per component - for resources such as bitmaps/icons for RcDialogs, need to run resedit from parent folder so that path to resource is correct when run the component from the parent folder.
     6.1.6    Reference to standalone code and the sample. Also must start from the Exercise06 folder - Customer\StartupCustomer - 'cos all paths in the code are relative to the Exercise06 folder.
     6.1.7    Why no Model/Data components for list views?
     6.1.8    Generally, in real life, creating something (Customer, Product, Order) requires a process different from merely updating something. This means a different GUI. But for this Guide, we'll assume Customer and Product get new records from a different place,
     so new records can(in this sample app) be got by adding to the relevant data files. However, OrderForm and Order are different - so have a component each.
     6.1.9    The lists create a new instance for each list item - which is silly.
     6.1.10  Naming - explain diff between OrderMgmt & OrderMgr where appropriate.

???   Mention standalone execution - point to sample code in samples and to App3.

     6.2    Pop-Ups and Parents incl Non-Modal Dialogs
     6.2.1    How get pop-up to pop up away from parent? Answer - have to code it yourself.
     6.2.2    Starting a dialog from a dialog (incl interpret statement - pointer to later)
                 Use of "interpret", better would be to have a class object - but later we'll need interpret (won't we?) for the ObjectMgr.
                 Leave “interpret” in but mention it – say class object would be better - show how can be fixed in later exercise – where
                 this will be moved to a support class (ObjectMgr).

     6.3    Icons and Lists
     6.3.1    The Icon View
	- List Views - normal icon view - a "workplace" for Order Management..
	- Auto-resizing when window sized by user

     6.3.2.   The Report View
                 - Looking at the two list views, almost begs for a superclass.
                 - how do different fonts for the listView items
                 - Explain the surfacing of an instance in the listview dialogs - check the showModel method.

     6.4    Re-Sizing Dialogs

     6.5    Creating and Using Icons
	- Icons - making them, getting 'em into the program. -
              (1) Does the icon have to be a certain size, or will it get automatically shrunk?
              (2) If it has to be a certain size, what's the size, and are there any restrictions as to the palette (I'm no expert, but using GIMP I'm given the option of saving as 16-bit, 24-bit or 32-bit color (or I think it's color!)).
              (3) In the ~execute statement, I need to provide an ID. Does this mean I must have a *.rc file? Or can I invent an ID programmatically somehow - perhaps along the same lines as creating an ImageList?
              (4) I want to assign my own icon as the dialog icon (that is, the icon at the extreme top left of a dialog). This is done (I understand) in the ~execute(..., <icon_ID> ) method (ooDialog Reference section 3.10.3).

     6.6    Utility Dialogs - <- ??? <What's this??> (Is this the layer - process-entity-utility? Or just useful "canned" dialogs?)
	- Mention password on startup to illustrate ooDialog use in otherwise non-ooDialog rexx programs.
	  "startup enterPW" - password is "Password".





-->
<chapter id="chapSix"><title>An Application Workplace</title>
<indexterm><primary>OrderManager component</primary></indexterm>
<para>This chapter introduces the Order Management application, which is designed as a "workplace"
      for a user handling sales orders. As such, it provides access to the required components -
      customers, products, orders, and order forms. A common approach for a "workplace" dialog is to
      provide an icon for each component that the user may wish to use. In the
        <computeroutput>Exercise06</computeroutput> folder, run
        <computeroutput>startup.rex</computeroutput>. The Order Management dialog opens, and
      consists mainly of a List View containing four icons. Move the icons around; double-click them
      and if a Customer, Product, or Order List appears then double-click a list item; re-size the
      Order Management window; check out the menu items and the pushbuttons. As you see, while much
      of the application function is absent, and the data is hard-coded, the essential parts of the
      Order Management application mentioned in <xref linkend="chapFour"/> are visible. This chapter
      addresses the following topics in the context of the Order Management application: <itemizedlist>
        <listitem>
          <para><xref linkend="chap06-struc"/></para>
        </listitem>
        <listitem>
          <para><xref linkend="chap06-listviews"/>Icons and Lists</para>
        </listitem>
        <listitem>
          <para><xref linkend="chap06-popups"/></para>
        </listitem>
        <listitem>
          <para><xref linkend="chap06-resize"/></para>
        </listitem>
        <listitem>
          <para><xref linkend="chap06-icons"/></para>
        </listitem>
        <listitem>
          <para><xref linkend="chap06-utildlgs"/>Utility Dialogs</para>
        </listitem>
      </itemizedlist>
    </para>

<section id="chap06-struc"><title>Program Structure</title>  <!-- Section 6.1 -->
  <para>In Exercise06, each business component has its own folder:
    Customer, Order, OrderMgr, and Product. Customer and Product are more or less identical
    to the same components introduced in Exercises 04 and 05.
    Placing each business component into a separate folder
    helps promote high cohesion and low coupling in the software,
    since the internals of each business component are opaque to other business components.
    Thus another application (e.g. Customer Relationship
    Management) might be able to make use of the Customer business component without change.
    The Order Management business component is unlikely to be re-used in other applications as it is
    a kind of "process" business component that "choreographs" the other business components.
    To the user, creating a new sales order consists of "choreographing" the various business aspects
    required - creating an Order Form (used to assemble the customer order), searching for and selecting a
    specific Customer, searching for and selecting one or more Products, recording the quantities ordered,
    and producing a Sales Order that is the "contract" between supplier and customer. Of course, the OrderManagement
    component could be used by "higher-level" components such as business processes or workflows. In systems
    organized according to these principles, invocation of components takes the form of a directed acyclic graph.
  </para>
  <para>
    Within each business component are one or more component groups and components. For example, the Customer
    business component contains two component groups: CustomerList and Customer. In turn,
    each of these consists of one View component and one Model component. Both model components
    share a single Data component. The Customer and Product
    component groups are essentially identical to those introduced in Exercises 4 and 5 respectively.
  </para>
  <para>
    The Order Management business component is, in this Exercise, implemented by a view class only. In fact,
    there are two view classes, each in its own .rex file: <computeroutput>OrderMgmtBaseView</computeroutput>
    and its subclass <computeroutput>OrderMgmtView</computeroutput>.
    <computeroutput>OrderMgmtBaseView</computeroutput>
    contains the code for handling a re-sizable dialog, and is a subclass of <computeroutput>UserDialog</computeroutput>
    which is required for any dialog that is dynamically
    re-sizable (see <xref linkend="chap06-resize"/>). <computeroutput>OrderMgmtView</computeroutput> contains the code
    specific to the Order Management application.
    The only reason for splitting the code like this is that it seems to fall happily into these two parts. This reduces
    the amount of code in any one class or file, and so makes for better readability.
  </para>
  <para>
    Note that the "data" of the OrderManagement business component is the set of icons and their associated data.
    In Exercise06, this data is effectively embedded in the View classes. However, the code in the
    <computeroutput>OrderMgmtView</computeroutput> class uses an <emphasis role="italic">interpret</emphasis>
    instruction to launch views of the components represented by icons. Thus in principle, additional components
    can be added without changing the code in the <computeroutput>OrdermgmtView</computeroutput> class. To support this,
    a separate file - <computeroutput>RequiresList.rex</computeroutput> - contains the set of
    <emphasis role="italic">::requires</emphasis> statements corresponding to the components that might be surfaced.
    This is why the first executable statement in the file <computeroutput>OrderMgmtView.rex</computeroutput> is
    <emphasis role="italic">call "OrderMgmt\RequiresList.rex"</emphasis>. Examples of possible additional components
    could be a "commodities" component which shows
    the commodities required to produce a given product; or a credit-check component that links to an external
    credit-check agency.
  </para>
</section>  <!-- End of section 6.1 -->


<section id="chap06-listviews"><title>Icons and Lists</title>  <!-- Section 6.2 -->
  <indexterm><primary>ListView</primary></indexterm>
  <indexterm><primary>Controls</primary><secondary>ListView</secondary></indexterm>
  <indexterm><primary>Icons</primary><secondary>in a ListView</secondary></indexterm>
  <para>The <computeroutput>ListView</computeroutput> should not be confused with <computeroutput>ListBox</computeroutput>;
  a ListView (see ooDialog Reference chapter 20) is a souped-up ListBox with lots of additional features. In particular:
  <itemizedlist>
    <listitem><para>An item in a ListView can be a complex structure or "record" containing
      multiple fields. One of these fields is termed the "label" of the item.</para></listitem>
    <listitem><para>ListView items can be displayed in four different modes:
      <itemizedlist>
        <listitem><para>Icon view - each item appears as a full-sized icon with a label below it.
          Items can be dragged around the ListView.</para></listitem>
        <listitem><para>Small-icon view - each item appears as a small icon with a label to its right.
          Items can be dragged around the ListView.</para></listitem>
        <listitem><para>List view - each item appears as a label with an optional small icon to its left.</para></listitem>
        <listitem><para>Report view - each item appears as a row in a table with an optional small icon to its left.
          </para></listitem>
      </itemizedlist>
      The four different modes are well illustrated by the sample program <computeroutput>oodListViews.rex</computeroutput>
      located in the <computeroutput>ooRexx\samples\oodialog</computeroutput> folder.</para></listitem>
  </itemizedlist>
  </para>
  <para>In the Order Management application, the ListView control provides the main area of the Order Management dialog
    where draggable icons (icon view) represent the various components of the application.
    It also provides the tabular lists (report views) in the CustomerList, ProductList, and OrderList dialogs.
    </para>

  <section id="chap06-listview-icon"><title>The Icon View</title>  <!-- Section 6.2.1 -->
  <para>

<!--
    OMBV
1     ::attribute lv

    OMV
2     ::method init
        expose records
        self~createIconList                               3
        records = self~initRecords                        4

5     ::method initDialog
        expose iconList records
        self~lv~newListView(..)
        self~lv~setImageList(..)
        /*- Add icons (i.e. records) to the ListView:  (actually used two hyphens at start - but oXygen doesn't like this.)*/
        do i=1 to records~items
          self~lv~addRow(, i-1, records[i]~name)
        end

3     ::method createIconList
        expose iconList
        imgCustList = .Image~getImage( filename )
        ...
        iconList = .ImageList~create(...)
        iconList~add(imgCustList)   /* item 0 in the list */
        ...

4     ::method initRecords
        expose records
        records = .array~new()
        rec = .directory~new
        rec~ID = "CustomerList"
        rec~name = "Customer List"
        records[1] = rec
        ...
        return records

6     ::method onDoubleClick
        expose records
        index = self~lv~focused   /* lv is an attribute of OBMBV */
-->

    The OrderManagement dialog uses the Icon View option of the ListView control. Five things are needed to produce an
    icon view: first, create (or obtain) some icons; second, specify the <computeroutput>ICON</computeroutput> style for the ListView
    control; third, create an ImageList from the icons (required by the ListView control); fourth, create a set of records
    (one record per icon) to be loaded into the ListView; and fifth, load the icons and records into the ListView.
    </para>
    <orderedlist numeration="arabic">

      <listitem> <!-- One -->
        <para><emphasis role="bold"><emphasis role="italic">Produce the Icons</emphasis></emphasis></para>
        <para>First, the large "icons" in the ListView are actually bitmaps. Icons and bitmaps have different formats, and different uses,
          and there are a number of differences between them. The icons themselves
          are in the folders of the relevant business components, so the icon for the Customer List, for example, is
          <computeroutput>Exercise06\Customer\bmp\CustList.bmp</computeroutput>. (The <computeroutput>*.ico</computeroutput>
          files are the dialog icons.)
          A number of tools are available for creating and editing images, icons, bitmaps etc.,
        some of them providing conversion and re-sizing capabilities. One such is GIMP (GNU Image Manipulation Program) from
        http://www.gimp.org.
        <indexterm><primary>Bitmap Editor</primary></indexterm><indexterm><primary>Icon editor</primary></indexterm>
        </para>
      </listitem>

      <listitem> <!-- Two -->
        <para><emphasis role="bold"><emphasis role="italic">Specify the ICON Style</emphasis></emphasis></para>
        <para>The icon style for a ListView control is specified either in the
                <computeroutput>*.rc</computeroutput> file as the
                <computeroutput>LVS_ICON</computeroutput> (in ResEdit, set the "View" property to
              "Icon"), or in a UserDialog, by creating the ListView control in the
          <emphasis role="italic">initDialog</emphasis> method using the
                <computeroutput>ICON</computeroutput> style (e.g.:
                <computeroutput>self~createListView(IDC_ORDMGMT_ICONS, ... "ICON")</computeroutput>
              where the first parameter is the ID for the ListView control.). </para>
      </listitem>

      <listitem> <!-- 3 -->
        <para><emphasis role="bold"><emphasis role="italic">Create an ImageList</emphasis></emphasis></para>
        <para>The ListView documentation provides several ways to load icons. Probably the easiest is to create an
              object of type <computeroutput>ImageList</computeroutput> (see ooDialog Reference
              section 26.3) which is loaded into the ListView. In <computeroutput>OrderMgmtView</computeroutput>, this
              is done in the <emphasis role="italic">createIconList</emphasis> method
          (invoked from the <emphasis role="italic">init</emphasis> method) as follows:
        <programlisting>
        <![CDATA[
          ::METHOD createIconList PRIVATE
            expose iconList
            imgCustList  = .Image~getImage("customer\bmp\CustList.bmp")
            imgProdList  = .Image~getImage("product\res\ProdList.bmp")
            imgOrderList = .Image~getImage("order\bmp\OrderList.bmp")
            imgOrderForm = .Image~getImage("order\bmp\OrderForm.bmp")
            -- Boldly assume no errors in creating the Image List or in the ~getImage statements.
            iconList = .ImageList~create(.Size~new(64, 64), .Image~toID(ILC_COLOR4), 4, 0)
            iconList~add(imgCustList)   -- item 0 in the list
            iconList~add(imgProdList)   -- item 1 in the list
            iconList~add(imgOrderList)  -- item 2 in the list
            iconList~add(imgOrderForm)  -- item 3 in the list
            imgCustList~release
            imgProdList~release
            imgOrderList~release
            imgOrderForm~release
            return
        ]]>
        </programlisting>
    For each icon, only two statements are required: create an Image from file then copy it to the ImageList (and a third, if you're
    a polite programmer and try to clean up afterwards, release the image).
    </para>
    </listitem>

    <listitem>  <!-- 4 -->
    <para><emphasis role="bold"></emphasis>Create Records</para>
    <para>Records are typically created in the <emphasis role="italic">init</emphasis> method (or in a method invoked from there).
      In <computeroutput>OrderMgmgtView</computeroutput> the records are created in the <emphasis role="italic">initRecords</emphasis>)
      method which is invoked from <emphasis role="italic">init</emphasis>. Each record has two fields: the text to appear beneath
      the icon, and the class name of the dialog to be surfaced when a user double-clicks on an icon. The design choice for these records
      is that each record will be a directory, and each directory will stored in an array. The array index of a record is equivalent
      to the position of its icon in the ImageList (remembering that arrays are 1-based while ImageLists are 0-based). The code for loading
      the record array is
      as follows (showing only the Sales Orders item for brevity):
      <programlisting>
    <![CDATA[
      ::METHOD initRecords PRIVATE
      expose records
      records = .array~new()
      ...
      rec = .directory~new
      rec~ID = "OrderList"
      rec~name = "Sales Orders"
      records[3] = rec
      ...
      return records
    ]]>
    </programlisting>
    </para>
  </listitem>
  <listitem> <!-- 5 -->
    <para><emphasis role="bold">Load the ImageList and the Records</emphasis></para>
    <para>Loading icon images and records into the ListView is done in the
      <emphasis role="italic">initDialog</emphasis>method:
    <programlisting><![CDATA[
    ::METHOD initDialog
      expose records iconList
      self~initDialog:super
      self~lv~setImageList(iconList, .Image~toID(LVSIL_NORMAL))
      do i=1 to records~items
        self~lv~addRow(, i-1, records[i]~name)
      end
    ]]>
    </programlisting>
      After invoking the superclass, the icons in the ImageList are applied to the ListView control
      using its <emphasis role="italic">setImageList</emphasis> method. The second parameter of this method
      specifies the size of the icons by invoking
      the Image class' <emphasis role="italic">toID</emphasis> method with the parameter <emphasis role="italic">LVSIL_NORMAL</emphasis>
      (the flag for the icon view). The Image class is used to work with and manipulate images,
      and is described in section 26.2 of the ooDialog Reference. The variable
      <emphasis role="italic">self~lv</emphasis> is the list view proxy, <emphasis role="italic">lv</emphasis> being an
      attribute of the <computeroutput>OrderMgmtBaseView</computeroutput> superclass.
      The icons having been set, the records are then added
        using the ListView's <emphasis role="italic">addRow</emphasis> method. The first parameter is the index of the list item
      - if omitted, the record is added after the last. The second parameter is the index of the icon to be used with this record, and
      the last parameter is the label for the list item - the string "Customer List" in the case of the first item added to the ListView in
      <computeroutput>OrderMgmtView</computeroutput>.
      </para>
    </listitem>
  </orderedlist>

  </section>  <!-- End of section 6.2.1 -->

  <section id="chap06-listview-report"><title>The Report View</title>  <!-- Section 6.2.2 -->
    <para>Three of the icons in the Order Management dialog surface a list when double-clicked - Customers, Products, and Orders.
      These three components are technically very similar - to the extent that a "list superclass" could perhaps be created.
      For the meantime, however, this is not done, and each list is quite separate. However, their similarity means that discussing one
      list - the Customer List - effectively addresses all.
    </para>
    <para></para>
  </section>  <!-- End of section 6.2.2 -->


</section>  <!-- End of section 6.2 -->

  <section id="chap06-popups"><title>Non-Modal Dialogs</title>  <!-- Section 6.3 -->
    <para>
    </para>
  </section>  <!-- End of section 6.3 -->

<section id="chap06-resize"><title>Re-sizing Dialogs</title>  <!-- Section 6.4 -->
<para>If you haven't already done so, try re-sizing the Order Management dialog.
  The ListView containing the icons
  expands to match the new window size, and one of the two pushbuttons moves as well, although their size
  - unlike the size of the List View - does not change. This re-sizing function is only available
  for a <computeroutput>UserDialog</computeroutput>, and requires a number of methods and lines of code.
  ooDialog provides three samples of the resizing function in the folder
  <computeroutput>ooRexx\samples\oodialog</computeroutput> folder -
  the relevant programs being <computeroutput>dlgAreaUDemo.rex</computeroutput>,
  <computeroutput>dlgAreaUDemoTwo.rex</computeroutput>, and
  <computeroutput>dlgAreaUDemoThree.rex</computeroutput>.
  <computeroutput>OrderManagementBaseView.rex</computeroutput> includes much of the code from the last
  of these three samples.
</para>
<para>
  The re-sizing function is provided by two ooDialog classes: <computeroutput>dlgAreaU</computeroutput>
  and <computeroutput>dlgArea</computeroutput> (see ooDialog Reference sections 10.14 and 10.15).
  An important constraint is that, because <computeroutput>dlgAreaU</computeroutput> parses
  the source code of the <emphasis role="italic">defineDialog</emphasis> method in order to handle re-sizing,
  it will only work with <computeroutput>UserDialog</computeroutput>, where the dialog template is created
  through explicit control creation statements. In addition, since the source code is required at run-time,
  it will not work if the source code is tokenized using <emphasis role="italic">rexxc</emphasis>.
</para>
<para>
  Essentially, the dialog is first split into a number of areas - two areas for the
  OrderManagement dialog. ears for . dilaog defines the A re-sizeable dialog - an excellent sample dialog -
    </para>
</section>  <!-- End of section 6.4 -->


<section id="chap06-icons"><title>Creating and Using Icons</title>  <!-- Section 6.5 -->
  <para>- Icons - making them, getting 'em into the program. - GIMP (GNU Image Manipulation Program) from
      http://www.gimp.org
</para>
</section>  <!-- End of section 6.5 -->

<section id="chap06-utildlgs"><title>Utility Dialogs</title>   <!-- Section 6.6 -->
  <indexterm><primary>Password dialog</primary></indexterm>
  <indexterm><primary>Utility routine</primary><secondary>PasswordBox</secondary></indexterm>
  <para>A subject not yet mentioned is the use of ooDialog utility classes and routines in non-ooDialog ooRexx programs.
    These are documented in Chapter 9 of the ooDialog Reference. The routines are very simple, and are often one-liners.
    As an example, the Exercise06 startup program
    provides for entry of a password using the (one-line) PasswordBox routine.
    Invoking <emphasis role="italic">startup enterPW</emphasis> produces a password box that will accept the password
    "Password". If you get the password wrong, the startup routine will silently end. The code is as follows:
    <programlisting>
    <![CDATA[
    parse arg pwOption
    if pwOption = "enterPW" then do
      pwd = PasswordBox("Please enter your password","Sign In")
      if pwd \= "Password" then exit
    end
    .OrderMgmtView~newInstance
    ::REQUIRES "OrderMgmt\OrderMgmtView.rex"
    ]]>
    </programlisting>

    </para>
</section>  <!-- End of section 6.6 -->

</chapter>

