<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog User Guide XML file.
    #
    # Copyright (c) 2011-2012, Rexx Language Association. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->

<!-- Chapter06 - List Views, Re-Sizing, and PopUps 		  v00-04 ??Feb12

    Changes:
     v00-01 25Aug11: First version
     v00-02 03Dec11: Second version.
     v00-03 03Feb12: Sorted out structure; added text.
     v00-04 ??Feb12

    6     "An Application Workplace"      chapSix
    6.1     Program Structure             chap06-struc
    6.1.1     Overview
    6.1.2     Some Implications
    6.1.2.1     File Paths
    6.1.2.2     .Application Usage
    6.1.2.3     Externalized Strings
    6.1.3     Application Function
    6.2     Popups and Parents            chap06-popups
    6.2.1     Starting a Popup Dialog     chap06-popups-start
    6.2.2     Offsetting Dialogs          chap06-popups-offset
    6.2.3     Use of 'Interpret'          chap06-popups-interpret
    6.3     Icons and Lists               chap06-lviews
    6.3.1     The Icon View               chap06-lviews-icon
    6.3.2     The Report View             chap06-listview-report
    6.4     Re-sizing Dialogs             chap06-resize
    6.5     Creating and Using Icons      chap06-icons
    6.6     Utility Dialogs               chap06-utildlgs

-->
<!--  is the following useful??
  - the OrderManagerView
  We demonstrate/discuss:
  - programmatic layout (can only use userDialog)
  - modal sub-window
  - Handling icons and showing them.
  - Icons that when dbl-clicked startup other views
  - Most menu items on OrderMgmgt dialog not implemented.
  - e.g. no function for "New Order"
-->

<chapter id="chapSix"><title>An Application Workplace</title>
<indexterm><primary>OrderManager component</primary></indexterm>
<para>This chapter introduces the Order Management application, which is designed as a "workplace"
      for a user handling sales orders. As such, it provides access to the required components -
      customers, products, orders, and order forms. A common approach for a "workplace" dialog is to
      provide an icon for each component that the user may wish to use. In the
        <computeroutput>Exercise06</computeroutput> folder, run
        <computeroutput>startup.rex</computeroutput>. The Order Management dialog opens, and
      consists mainly of a List View containing four icons. Move the icons around; double-click them
      and if a Customer, Product, or Order List appears then double-click a list item; re-size the
      Order Management window; check out the menu items and the pushbuttons. As you see, while much
      of the application function is absent, and the data is hard-coded, and there is some
      redundancy (e.g. every time you double-click on an item in a list view a new Model and Data
      object is created), the essential parts of the Order Management application mentioned in
      <xref linkend="chapFour"/> are visible. This chapter addresses the following topics in the context
      of the Order Management application: <itemizedlist>
        <listitem>
          <para><link linkend="chap06-struc" endterm="progstruc.title"></link></para>
        </listitem>
        <listitem>
          <para><link linkend="chap06-popups" endterm="popups.title"></link></para>
        </listitem>
        <listitem>
          <para><link linkend="chap06-lviews" endterm="lviews.title"></link></para>
        </listitem>
        <listitem>
          <para><link linkend="chap06-resize" endterm="resize.title"></link></para>
        </listitem>
        <listitem>
          <para><link linkend="chap06-icons" endterm="icons.title"></link></para>
        </listitem>
        <listitem>
          <para><link linkend="chap06-utildlgs" endterm="utildlgs.title"></link></para>
        </listitem>
      </itemizedlist>
      Test of xref only: 1: blah <xref linkend="chapFour"/> blah. 2: blah <xref linkend="chapFour">
      blah. 3: blah <xref linkend="chapFour"></xref> blah.
    </para>

<section id="chap06-struc"><title id="progstruc.title">Program Structure</title>  <!-- Section 6.1 -->

  <section id="chap06-struc-overview"><title>Overview</title>  <!-- Section 6.1.1 -->
  <para>In Exercise 6, each business component has its own folder:
    Customer, Order, OrderMgr, and Product. Customer and Product are more or less identical
    to the same components introduced in Exercises 4 and 5.
    Placing each business component into a separate folder
    helps promote high cohesion and low coupling in the software,
    since the internals of each business component are opaque to other business components.
    Thus another application (e.g. Customer Relationship
    Management) might be able to make use of the Customer business component without change.
    The Order Management business component is unlikely to be re-used in other applications as it is
    a kind of "process" business component that "choreographs" the other business components.
    To the user, creating a new sales order consists of "choreographing" the various business aspects
    required - creating an Order Form (used to assemble the customer order), searching for and selecting a
    specific Customer, searching for and selecting one or more Products, recording the quantities ordered,
    and producing a Sales Order that is the "contract" between supplier and customer. Of course, the OrderManagement
    component could be used by "higher-level" components such as business processes or workflows. In systems
    organized according to these principles, invocation of components takes the form of a directed acyclic graph.
  </para>
  <para>
    Within each business component are one or more component groups and components. For example, the Customer
    business component contains two component groups: CustomerList and Customer. In turn,
    each of these consists of one View component and one Model component. Both model components
    share a single Data component. The Customer and Product
    component groups are essentially identical to those introduced in Exercises 4 and 5 respectively.
  </para>
  <para>The Order Management business component is, in this Exercise, implemented by a view class
    only. In fact, there are two view classes, each in its own .rex file:
    <computeroutput>OrderMgmtBaseView</computeroutput> and its subclass <computeroutput>OrderMgmtView</computeroutput>.
    <computeroutput>OrderMgmtBaseView</computeroutput> contains the code for handling a
    re-sizable dialog, and is a subclass of <computeroutput>UserDialog</computeroutput> which
    is required for any dialog that is dynamically re-sizable (see <xref linkend="chap06-resize"/>).
    <computeroutput>OrderMgmtView</computeroutput> contains the
    code specific to the Order Management application. The only reason for splitting the code
    like this is that it seems to fall happily into these two parts. This reduces the amount
    of code in any one class or file, and so (arguably) makes for better readability.
  </para>
  <para>Note that the "data" of the OrderManagement business component is the set of icons and their
    associated data. Examples of possible additional
    components could be a "commodities" component which shows the commodities required to
    produce a given product; or a credit-check component that links to an external
    credit-check agency.</para>
  <para>Finally, it's worth noting that the folder structure, while useful for development, is
    not necessarily the most appropriate structure for a deployed application. A more
    appropriate deployment structure will be described in the next chapter.
  </para>
  </section>  <!-- End of section 6.1.1 -->

  <section id="chap06-struc-impls"><title>Some Implications</title>  <!-- Section 6.1.2 -->
    <para>Choosing this folder structure for the development of the application has certain
      design implications worth mentioning. These are: file paths, the use of <computeroutput>.Application</computeroutput>,
      and the handling of externalized human-readable strings.
    </para>
    <section id="chap06-struc-impls-paths"><title>File Paths</title>  <!-- Section 6.1.2.1 -->
      <indexterm><primary>File path</primary></indexterm>
      <para>When an ooRexx program is run, the current (or
        "home") directory is that from which the program is started. That is, if a
        program is started on a command prompt like this: <computeroutput>c:\aaa\bbb>myprog.rex</computeroutput>,
        then the current directory will be <computeroutput>c:\aaa\bbb</computeroutput>. However, if the program
        is started like this: <computeroutput>c:\aaaa>bbb\myprog.rex</computeroutput>, then the current directory
        will be <computeroutput>c:\aaa</computeroutput>. In Exercise 6,
        all programs are started from the <computeroutput>Exercise06</computeroutput>
        folder. Thus any relative paths must be relative to the
        <computeroutput>Exercise06</computeroutput> folder. However, using ResEdit with relative
        paths, the path for a resource such as a dialog icon is relative to the folder in
        which the *.rc file is created. For example, if <computeroutput>CustomerView.rc</computeroutput>
        is created in the <computeroutput>Customer</computeroutput> folder, then the icon will be specified
        in <computeroutput>CustomerView.rc</computeroutput> with the path
        <computeroutput>".\\bmp\\Customer.ico"</computeroutput> So the path to the icon
        resource in the *.rc file will be wrong, and the dialog icon will not be shown.</para>
      <para>The solution is either to edit the *.rc file and change the icon resource's path, or (better)
        create the *.rc file in the Exercise06 folder and then move it into the
        <computeroutput>Customer</computeroutput> folder.
      </para>
      <para>Considering the implication of paths also applies to other parts of the code, such
        header files specified in the <emphasis role="italic">.Application~addToConstDir(...)</emphasis> statement and
        dialog creation statements such as <emphasis role="italic">dlg = .CustomerView~new(...)</emphasis>.
      </para>
      <para>In summary, all paths (if not absolute) must be relative to the folder from which the
        program is started. This is why, when running a stand-alone test such as
        <computeroutput>startupCustomer.rex</computeroutput>, the program must be started
        from the <computeroutput>Exercise06</computeroutput> folder, since the design decision was
        taken to make all paths relative to <computeroutput>Exercise06</computeroutput> folder.
      </para>
      <para>This discussion on paths prompts two thoughts (at least). First, is there not a way to have some support code
        manage paths, so that each component asks this support code for the path it should use? While this may be feasible,
        it's not specifically an ooDialog questions, and so is not pursued here. Second, using the
        <computeroutput>ResDialog</computeroutput> class instead of <computeroutput>RcDialog</computeroutput>
        reduces the problem of paths, since resources such as icons and bitmaps are placed in the *.dll file.
      </para>
      </section>  <!-- End of Section 6.1.2.1 -->

    <section><title>.Application Usage</title>  <!-- Section 6.1.2.2 -->
      <para>The file (<computeroutput>startup.rex</computeroutput>) applies application-wide
        defaults with the statement <emphasis role="italic">.Application~setDefaults("O", , .false)</emphasis> .
        However, the header file for each view class is included at the beginning of its file. For example,
        <emphasis role="italic">.Application~addToConstDir("Customer\CustomerView.h")</emphasis> is the first
        executable statement in the file <computeroutput>CustomerView.rex</computeroutput>.
        For a shipped application that includes multiple classes, it would be much better to provide all the
        <emphasis role="italic">~addToConstDir()</emphasis> statements in the startup file after, say, the
        <computeroutput>~setDefaults()</computeroutput> statement. However, because at this stage the application
        is still in a pre-deployment state, and each component needs to be able to be unit-tested
        (see <xref linkend="apx-satesting"/>),
        it was deemed better to include the <emphasis role="italic">~addToConstDir()</emphasis> statements in each view file.
        An alternative was to duplicate them in the unit-test startup programs, but code duplication is generally not the best strategy.
        <indexterm><primary>Unit-testing</primary><secondary>Placement of .Application statement</secondary></indexterm>
        <indexterm><primary>.Application</primary><secondary>and Unit-Testing</secondary></indexterm>
      </para>
    </section>  <!-- End of Section 6.1.2.2 -->

    <section><title>Externalized Strings</title>  <!-- Section 6.1.2.3 -->
      <para>All components that display information to the user have the displayed strings separated from code either in
        a class whose name is prefaced "HRS" for "Human-Readable Strings" or in a *.rc file. Each such class name has a suffix
        - e.g. "HRScv" for the <computeroutput>CustomerView</computeroutput> class. The reason for the suffix is to
        distinguish the various HRS classes if the various files were later to be placed into a single file for
        application deployment purposes.
      </para>
      <para>Human-readable strings in *.rc classes are a problem when internationalization is a requirement. Internationalization
        (often referred to as I18N - there are 20 letters in the word "internationalization") is the term given to
        providing for translation of human-readable text to other languages.
        <indexterm><primary>Internationalization</primary></indexterm>
        An immediate solution is to display the translated strings from within the program rather than from the *.rc file.
        The <emphasis role="italic">initDialog</emphasis> method is a good place to do this. Try inserting the following
        in <computeroutput>CustomerView.rex</computeroutput>, say just before
        the statement <emphasis role="italic">self~getData</emphasis> in the <emphasis role="italic">initDialog</emphasis> method:
        <programlisting>
        <![CDATA[
          custNameLabel = self~newStatic("IDC_CUST_LBL_CUSTNAME")
          custNameLabel~setText("Namen:")
        ]]>
        </programlisting>
        The Customer View will be displayed with "Namen" (German)instead of "Name" (English).
      </para>
      <para>Of course, this text should
        come from an HRS class or better from a proper I18N resource file. Such files would be produced using special
        I18N tools. These tools take account of the many considerations and gotchas of internationalization.
        For example, in our trivial attempt to change the label from English "Name" to German "Namen", we've lost the colon
        at the end. This is because the
        horizontal space given to this particular static text in <computeroutput>CustomerView.rc</computeroutput> is not big enough.
        Some authorities suggest that 150% of the space required for English is needed to allow for proper translations to other languages.
        And this is only one of the lesser considerations in the task of internationalization.
        The following quote from the Wikipedia entry illustrates something of the full complexity of I18N:
        "It should be noted that "internationalized" does not necessarily mean that a system can be used absolutely anywhere,
        since simultaneous support for all possible locales is both practically almost impossible and commercially very hard
        to justify. In many cases an internationalized system includes full support only for the most spoken languages,
        plus any others of particular relevance to the application."
      </para>
    </section>  <!-- End of Section 6.1.2.3 -->

  </section>  <!-- End of Section 6.1.2 -->

  <section><title>Application Function and Naming</title>  <!-- Section 6.1.3 -->
  <para>
    One of the first things to notice about Exercise 6 is that there is very little application function.
    For example, data is all hard-coded, and all Customers have identical data, as do all Products and all Orders
    (this will be fixed in the next exercise).
    The second thing is that while there's an <computeroutput>Order</computeroutput> component to display and change existing sales orders,
    there's a separate <computeroutput>OrderForm</computeroutput> component
    for creating new sales orders. But there is no way to create new Customers or Products. This will not be
    fixed in the next exercise, mainly because providing this function would not exercise any new ooDialog
    features. However, trivially, in the next exercise data will be able to be changed or added
    by updating a data file.
  </para>
  <para>The reason for having a different dialog for creating as opposed to viewing and updating is that in real applications,
    creating a Customer, or Product, or Order generally requires a more complex process than updating. For example,
    creating a Customer often cannot be done without a credit check and
    establishing the customer's bank details in the accounting system. In our Order Management application,
    only the <computeroutput>Order</computeroutput> component has a separate Order Creation dialog, in order to exercise,
    in the next chapter, more ooDialog capabilities. So, for present purposes,
    we assume that Customer and Product creation takes place outside of the sample Order Management application.
  </para>
  <para>Although perhaps not immediately apparent, a specific naming convention has been used.
    <indexterm><primary>Naming convention</primary><secondary>Components</secondary></indexterm>
    <indexterm><primary>Component names</primary><secondary>Naming convention</secondary></indexterm>
    This convention is useful to differentiate between the various parts of the application.
    Thus "X Management" is the name given to the application as a whole (in our case "X" is "Sales Order").
    Generally, a componentized application has one or more "coordinator" components that arrange for the
    "choreographing" of other components. These are often called "Managers" - hence the "Order Manager"
    component that provides the framework for the application. Finally, entities such as Customer
    are given the entity name - "Customer", "Product", etc. - followed by the suffix "View", "Model",
    or "Data" as discussed in <xref linkend="chapThree"/>.
  </para>
  <para>Finally, starting an application that can make changes to a business is generally guarded by some form of security.
    When starting the sample application, this is represented by a password dialog, which is visible if you start the application
    (in the <computeroutput>Exercise06</computeroutput> folder) with the command <emphasis role="italic">startup enterPW</emphasis> instead of just
    <emphasis role="italic">startup</emphasis>. Yes, this is the wrong way round, but its purpose is to illustrate the code
    required for a password prompt. It is very simple, and uses one of the many ooDialog built-in dialogs (documented in the
    ooDialog Reference sections 6.2 "Standard Dialog Classes" and 6.3 "Public Routines"), as follows:
    <programlisting>
    <![CDATA[
      parse arg pwOption
      if pwOption = "enterPW" then do
        pwd = PasswordBox("Please enter your password","Sign In")
        if pwd \= "Password" then exit
      end
    ]]>
    </programlisting>
  </para>

  </section>  <!-- End of Section 6.1.3 -->

</section>  <!-- End of section 6.1 -->

<section id="chap06-popups"><title id="popups.title">Popups and Parents</title>  <!-- Section 6.2 -->
  <para>This section addresses how the various dialogs in the Order Management application are launched.
    First, the way in which dialogs are started is addressed. Second, the use of the
    <emphasis role="italic">interpret</emphasis> statement in displaying dialogs
    by double-clicking an icon in the Order Management window is discussed.
  </para>

<section id="chap06-popups-start"><title>Starting a Popup Dialog</title>  <!-- Section 6.2.2 -->
  <indexterm><primary>Popups</primary><secondary>Parents</secondary></indexterm>
  <indexterm><primary>Parents</primary><secondary>Popups</secondary></indexterm>
  <para>In previous chapters, dialogs have been started using the statement
    <emphasis role="italic">self~execute(...)</emphasis>. The <emphasis role="italic">~execute</emphasis> method
    makes the dialogs "modal", that is, access to other dialogs is blocked until the dialog is closed
    (ooDialog Reference section 2.2.11). A good example of a modal dialog is the Help-About
    dialog in Exercise 5. While this is open, the Product View dialog is blocked.
  </para>
  <para>The dialogs in Exercise 6 are not modal; they are "amodal" or "modeless". Any of them can be accessed
    by the user at any time. A modeless dialog is
    created by using the <emphasis role="italic">~popup</emphasis> or <emphasis role="italic">~popupAsChild</emphasis>
    methods in place of <emphasis role="italic">~execute</emphasis>.
  </para>
  <para>The difference between a dialog started with <emphasis role="italic">~popup</emphasis> as
    opposed to <emphasis role="italic">~popupAsChild</emphasis> is as follows.
    <itemizedlist>
      <listitem><para><emphasis role="bold"><emphasis role="italic">~popup()</emphasis></emphasis> - If dialog A
        pops up dialog B, then B exists independently of A. Either can be accessed by the user at any time.
        Either can be closed without affecting the other. The application ends only when both are closed. </para>
      </listitem>
      <listitem><para><emphasis role="italic"><emphasis role="bold">~popupAsChild(parentDlg)</emphasis></emphasis> - If dialog
        A pops up dialog B as its child, then B's existence depends on A's. If A is closed, so does B. However, as with
        <emphasis role="italic">~popup</emphasis> either can be accessed by the user at any time. Note that the only required
        argument for <emphasis role="italic">~popupAsChild(parentDlg)</emphasis> is the parent dialog.</para>
      </listitem>
    </itemizedlist>
    <!-- if startupcustomerlist, if open a customer, then close list, cust also closes. But if use startup, it doesn't. -->
          <indexterm><primary>Popups</primary><secondary>PopupAsChild</secondary></indexterm>
          <indexterm><primary>PopupAsChild</primary></indexterm>
  </para>
  <para>
    It is the latter - <emphasis role="italic">~popupAsChild</emphasis> -
    that best fits the requirements of the Order Management application. Thus while
    <computeroutput>OrderMgrView</computeroutput> is started with <emphasis role="italic"
      >~execute</emphasis>, all other Order Management dialogs are started with <emphasis
        role="italic">~popupAsChild(rootDlg)</emphasis> where the "root" (or parent) dialog is always
    <computeroutput>OrderMgrView</computeroutput>. Thus all dialogs are modeless and independent of each other.
    The application ends only when <computeroutput>OrderMgrView</computeroutput> is closed.
    (Note that <computeroutput>ProductView</computeroutput>'s "About" dialog is still modal: it blocks access
    to the specific instance of <computeroutput>ProductView</computeroutput> from which it is launched; other instances
    of <computeroutput>ProductView</computeroutput> are unaffected, as are other dialogs.)
  </para>
  <para>So, for a dialog to be "popped up as child", there has to be a parent dialog that was surfaced
    with either <emphasis role="italic">~popup</emphasis> or <emphasis role="italic">~execute</emphasis>.
    This presents a problem for stand-alone testing. The solution adopted in the sample Order Management
    application is illustrated in the following code fragment, taken from
    <computeroutput>CustomerListView</computeroutput>'s
    <emphasis role="italic">activate></emphasis> method (which is called from its
    <emphasis role="italic">newInstance</emphasis> class method):
    <programlisting>
    <![CDATA[
      ::METHOD activate UNGUARDED
        expose rootDlg
        use arg rootDlg
        if rootDlg = "SA" then do			-- If standalone operation required
          rootDlg = self				      -- To pass on to children
          self~execute("SHOWTOP","IDI_CUSTLIST_DLGICON")
        end
        else self~popupAsChild(rootDlg, "SHOWTOP", ,"IDI_CUSTLIST_DLGICON")
        return
    ]]>
    </programlisting>
    This code illustrates the two ways of starting a dialog. For stand-alone testing (see
    <xref linkend="apx-satesting"/>), the dialog is started using
    <emphasis role="italic">self~execute()</emphasis>. In normal operation, however, it is started by
    <emphasis role="italic">self~popupAsChild(...)</emphasis>. Notice that the first parameter of
    <emphasis role="italic">~popupAsChild(rootDlg, ...)</emphasis> is the <computeroutput>OrderMgrView</computeroutput>
    dialog, which is passed to the <emphasis role="italic">newInstance</emphasis>
    class method and thence as the parameter <emphasis role="italic">rootDlg</emphasis> to the
    <emphasis role="italic">activate</emphasis> method. This dialog, the
    <computeroutput>CustomerListView</computeroutput> class, is both a child of the
    <computeroutput>OrderMgr</computeroutput> and parent of the
    <computeroutput>Customer</computeroutput> class. Later in
    <computeroutput>CustomerListView</computeroutput>, a Customer is displayed by the user
    double-clicking on an item in the List View. The event handler method (<emphasis role="italic">showCustomer</emphasis>)
    that surfaces the Customer is as follows:
    <programlisting>
    <![CDATA[
      ::METHOD showCustomer UNGUARDED
        expose lvCustomers rootDlg
        item = lvCustomers~selected
        if item = -1 then do		-- if no item selected.
          ret = MessageDialog(.HRSclv~nilSelected, self~hwnd, title, 'WARNING')
          return
        end
        info=.Directory~new
        if lvCustomers~getItemInfo(item, info) then do
          .local~my.idCustomerData  = .CustomerData~new	   -- create Customer Data instance
          .local~my.idCustomerModel = .CustomerModel~new	 -- create Customer Model instance
          .local~my.idCustomerData~activate
          .local~my.idCustomerModel~activate
          .CustomerView~newInstance(rootDlg,"CU003")
          self~disableControl("IDC_CUSTLIST_SHOWCUST")
        end
        else do
          say "CustomerListView-showCustomer-04: ~getItemInfo returned .false."
        end
    ]]>
    </programlisting>
    The list of customers is shown in a ListView control (see <xref linkend="lviews.title"/> below).
    The <emphasis role="italic">showCustomer</emphasis> method is invoked when the user double-clicks
    on an item in the list. This item is identified by the
    statement <emphasis role="italic">item = lvCustomers~selected</emphasis>, the proxy object for the
    list control being <emphasis role="italic">lvCustomers</emphasis>. If no item is selected, an error message
    is displayed, and the method returns. The data in the selected row is then placed in a directory
    (with an error check in case <emphasis role="italic">~getItemInfo</emphasis> returns
    <computeroutput>.false</computeroutput>). The next statements (<emphasis role="italic">.local~my...</emphasis>)
    create instances of the <computeroutput>CustomerModel</computeroutput> and <computeroutput>CustomerData</computeroutput>
    classes that are required by <computeroutput>CustomerView</computeroutput> (see <xref linkend="chap03-cplg"/>.
    Then an instance of <computeroutput>CustomerView</computeroutput> is created by the statement
    <emphasis role="italic">.CustomerView~newInstance(rootDlg,"CU003")</emphasis>. Finally, the "Show Customer"
    pushbutton is disabled.
  </para>
  <para>
    The approach to establishing the model and data objects shown here is not ideal. Indeed, the above code
    merely satisfies the requirement for a <computeroutput>CustomerView</computeroutput> object to have access
    to a <computeroutput>CustomerModel</computeroutput> instance which in turn needs access to an instance of
    <computeroutput>CustomerView</computeroutput>. Indeed, in this exercise, the data is all hard-coded. The
    next exercise will illustrate a much better way of doing this - but with data being read from a disk file
    (a notional "data base").
  </para>
  </section>  <!-- End of Section 6.2.1 -->

  <section id="chap06-popups-offset"><title>Offsetting Dialogs</title>  <!-- Section 6.2.2 -->
    <para>When creating a resource file for a dialog, it is unusual to define the position of the dialog
      on the screen, Instead, the option to center the dialog in the screen us often used.
      However, when a number of different dialogs are all
      <!-- How get pop-up to pop up away (offset) from parent? Answer - have to code it yourself.

      Test in ...\Ancillary\Tests\DragDrop:

      In DMHarness:

        ::METHOD startSourceDlg UNGUARDED
          parentPos = self~getRealPos             /* ooDialog Ref 4.4.22 */
          .DMSource~newInstance(self,parentPos)

     In DMSource:

     ::method newInstance class
       use arg parent, parentPos
       dlg = self~new
       dlg~activate(parent,parentPos)
       return

     ::method initDialog
       expose ... parentpos
       ...
       parentPos~incr(100,100)                  /* ooDialog Ref 9.11.7 */
       self~moveTo(parentPos, 'SHOWWINDOW')     /* ooDialog Ref 4.4.35 */
       self~ensureVisible                       /* ooDialog Ref 3.15.7 */

      -->

    </para>
  </section>  <!-- End of Section 6.2.2 -->

  <section id="chap06-popups-interpret"><title>Use of Interpret</title>  <!-- Section 6.2.3 -->
    <!--
      Starting a dialog from a dialog (incl interpret statement - pointer to later)
      Use of "interpret", better would be to have a class object - but later we'll need interpret (won't we?) for the ObjectMgr.
      Leave "interpret" in but mention it - say class object would be better - show how can be fixed in later exercise â€“ where
      this will be moved to a support class (ObjectMgr).
    -->
    <para>
      <!-- Fragment: -->However, the code in the <computeroutput>OrderMgmtView</computeroutput> class uses an
      <emphasis role="italic">interpret</emphasis> instruction to launch views of the
      components represented by icons. Thus in principle, additional components can be added
      without changing the code in the <computeroutput>OrdermgmtView</computeroutput> class. To
      support this, a separate file - <computeroutput>RequiresList.rex</computeroutput> -
      contains the set of <emphasis role="italic">::requires</emphasis> statements corresponding
      to the components that might be surfaced. This is why the first executable statement in
      the file <computeroutput>OrderMgmtView.rex</computeroutput> is
      <emphasis role="italic">call "OrderMgmt\RequiresList.rex"</emphasis>.
    </para>


  </section>  <!-- End of Section 6.2.3 -->

</section>  <!-- End of Section 6.2 -->

<section id="chap06-lviews"><title id="lviews.title">Icons and Lists</title>  <!-- Section 6.3 -->
    <indexterm><primary>ListView</primary></indexterm>
    <indexterm><primary>Controls</primary><secondary>ListView</secondary></indexterm>
    <indexterm><primary>Icons</primary><secondary>in a ListView</secondary></indexterm>

  <para>The <computeroutput>ListView</computeroutput> should not be confused with <computeroutput>ListBox</computeroutput>;
  a ListView (see ooDialog Reference chapter 20) is a souped-up ListBox with lots of additional features. In particular:
  <itemizedlist>
    <listitem><para>An item in a ListView can be a complex structure or "record" containing
      multiple fields. One of these fields is termed the "label" of the item.</para></listitem>
    <listitem><para>ListView items can be displayed in four different modes:
      <itemizedlist>
        <listitem><para>Icon view - each item appears as a full-sized icon with a label below it.
          Items can be dragged around the ListView.</para></listitem>
        <listitem><para>Small-icon view - each item appears as a small icon with a label to its right.
          Items can be dragged around the ListView.</para></listitem>
        <listitem><para>List view - each item appears as a label with an optional small icon to its left.</para></listitem>
        <listitem><para>Report view - each item appears as a row in a table with an optional small icon to its left.
          </para></listitem>
      </itemizedlist>
      The four different modes are well illustrated by the sample program <computeroutput>oodListViews.rex</computeroutput>
      located in the <computeroutput>ooRexx\samples\oodialog</computeroutput> folder.</para></listitem>
  </itemizedlist>
  </para>
  <para>In the Order Management application, the ListView control provides the main area of the Order Management dialog
    where draggable icons (icon view) represent the various components of the application.
    It also provides the tabular lists (report views) in the CustomerList, ProductList, and OrderList dialogs.
    </para>

  <section id="chap06-lviews-icon"><title>The Icon View</title>  <!-- Section 6.3.1 -->
    <!--

      6.3.1    The Icon View
      - List Views - normal icon view - a "workplace" for Order Management..
      - Auto-resizing when window sized by user
    -->

  <para>

<!--
    OMBV
1     ::attribute lv

    OMV
2     ::method init
        expose records
        self~createIconList                               3
        records = self~initRecords                        4

5     ::method initDialog
        expose iconList records
        self~lv~newListView(..)
        self~lv~setImageList(..)
        /*- Add icons (i.e. records) to the ListView:  (actually used two hyphens at start - but oXygen doesn't like this.)*/
        do i=1 to records~items
          self~lv~addRow(, i-1, records[i]~name)
        end

3     ::method createIconList
        expose iconList
        imgCustList = .Image~getImage( filename )
        ...
        iconList = .ImageList~create(...)
        iconList~add(imgCustList)   /* item 0 in the list */
        ...

4     ::method initRecords
        expose records
        records = .array~new()
        rec = .directory~new
        rec~ID = "CustomerList"
        rec~name = "Customer List"
        records[1] = rec
        ...
        return records

6     ::method onDoubleClick
        expose records
        index = self~lv~focused   /* lv is an attribute of OBMBV */
-->

    The OrderManagement dialog uses the Icon View option of the ListView control. Five things are needed to produce an
    icon view: first, create (or obtain) some icons; second, specify the <computeroutput>ICON</computeroutput> style for the ListView
    control; third, create an ImageList from the icons (required by the ListView control); fourth, create a set of records
    (one record per icon) to be loaded into the ListView; and fifth, load the icons and records into the ListView.
    </para>
    <orderedlist numeration="arabic">

      <listitem> <!-- One -->
        <para><emphasis role="bold"><emphasis role="italic">Produce the Icons</emphasis></emphasis></para>
        <para>First, the large "icons" in the ListView are actually bitmaps. Icons and bitmaps have different formats, and different uses,
          and there are a number of differences between them. The icons themselves
          are in the folders of the relevant business components, so the icon for the Customer List, for example, is
          <computeroutput>Exercise06\Customer\bmp\CustList.bmp</computeroutput>. (The <computeroutput>*.ico</computeroutput>
          files are the dialog icons.)
          A number of tools are available for creating and editing images, icons, bitmaps etc.,
        some of them providing conversion and re-sizing capabilities. One such is GIMP (GNU Image Manipulation Program) from
        http://www.gimp.org.
        <indexterm><primary>Bitmap Editor</primary></indexterm><indexterm><primary>Icon editor</primary></indexterm>
        </para>
      </listitem>

      <listitem> <!-- Two -->
        <para><emphasis role="bold"><emphasis role="italic">Specify the ICON Style</emphasis></emphasis></para>
        <para>The icon style for a ListView control is specified either in the
                <computeroutput>*.rc</computeroutput> file as the
                <computeroutput>LVS_ICON</computeroutput> (in ResEdit, set the "View" property to
              "Icon"), or in a UserDialog, by creating the ListView control in the
          <emphasis role="italic">initDialog</emphasis> method using the
                <computeroutput>ICON</computeroutput> style (e.g.:
                <computeroutput>self~createListView(IDC_ORDMGMT_ICONS, ... "ICON")</computeroutput>
              where the first parameter is the ID for the ListView control.). </para>
      </listitem>

      <listitem> <!-- 3 -->
        <para><emphasis role="bold"><emphasis role="italic">Create an ImageList</emphasis></emphasis></para>
        <para>The ListView documentation provides several ways to load icons. Probably the easiest is to create an
              object of type <computeroutput>ImageList</computeroutput> (see ooDialog Reference
              section 26.3) which is loaded into the ListView. In <computeroutput>OrderMgmtView</computeroutput>, this
              is done in the <emphasis role="italic">createIconList</emphasis> method
          (invoked from the <emphasis role="italic">init</emphasis> method) as follows:
        <programlisting>
        <![CDATA[
          ::METHOD createIconList PRIVATE
            expose iconList
            imgCustList  = .Image~getImage("customer\bmp\CustList.bmp")
            imgProdList  = .Image~getImage("product\res\ProdList.bmp")
            imgOrderList = .Image~getImage("order\bmp\OrderList.bmp")
            imgOrderForm = .Image~getImage("order\bmp\OrderForm.bmp")
            -- Boldly assume no errors in creating the Image List or in the ~getImage statements.
            iconList = .ImageList~create(.Size~new(64, 64), .Image~toID(ILC_COLOR4), 4, 0)
            iconList~add(imgCustList)   -- item 0 in the list
            iconList~add(imgProdList)   -- item 1 in the list
            iconList~add(imgOrderList)  -- item 2 in the list
            iconList~add(imgOrderForm)  -- item 3 in the list
            imgCustList~release
            imgProdList~release
            imgOrderList~release
            imgOrderForm~release
            return
        ]]>
        </programlisting>
    For each icon, only two statements are required: create an Image from file then copy it to the ImageList (and a third, if you're
    a polite programmer and try to clean up afterwards, release the image).
    </para>
    </listitem>

    <listitem>  <!-- 4 -->
    <para><emphasis role="bold"></emphasis>Create Records</para>
    <para>Records are typically created in the <emphasis role="italic">init</emphasis> method (or in a method invoked from there).
      In <computeroutput>OrderMgmgtView</computeroutput> the records are created in the <emphasis role="italic">initRecords</emphasis>)
      method which is invoked from <emphasis role="italic">init</emphasis>. Each record has two fields: the text to appear beneath
      the icon, and the class name of the dialog to be surfaced when a user double-clicks on an icon. The design choice for these records
      is that each record will be a directory, and each directory will stored in an array. The array index of a record is equivalent
      to the position of its icon in the ImageList (remembering that arrays are 1-based while ImageLists are 0-based). The code for loading
      the record array is
      as follows (showing only the Sales Orders item for brevity):
      <programlisting>
    <![CDATA[
      ::METHOD initRecords PRIVATE
      expose records
      records = .array~new()
      ...
      rec = .directory~new
      rec~ID = "OrderList"
      rec~name = "Sales Orders"
      records[3] = rec
      ...
      return records
    ]]>
    </programlisting>
    </para>
  </listitem>
  <listitem> <!-- 5 -->
    <para><emphasis role="bold">Load the ImageList and the Records</emphasis></para>
    <para>Loading icon images and records into the ListView is done in the
      <emphasis role="italic">initDialog</emphasis>method:
    <programlisting><![CDATA[
    ::METHOD initDialog
      expose records iconList
      self~initDialog:super
      self~lv~setImageList(iconList, .Image~toID(LVSIL_NORMAL))
      do i=1 to records~items
        self~lv~addRow(, i-1, records[i]~name)
      end
    ]]>
    </programlisting>
      After invoking the superclass, the icons in the ImageList are applied to the ListView control
      using its <emphasis role="italic">setImageList</emphasis> method. The second parameter of this method
      specifies the size of the icons by invoking
      the Image class' <emphasis role="italic">toID</emphasis> method with the parameter <emphasis role="italic">LVSIL_NORMAL</emphasis>
      (the flag for the icon view). The Image class is used to work with and manipulate images,
      and is described in section 26.2 of the ooDialog Reference. The variable
      <emphasis role="italic">self~lv</emphasis> is the list view proxy, <emphasis role="italic">lv</emphasis> being an
      attribute of the <computeroutput>OrderMgmtBaseView</computeroutput> superclass.
      The icons having been set, the records are then added
        using the ListView's <emphasis role="italic">addRow</emphasis> method. The first parameter is the index of the list item
      - if omitted, the record is added after the last. The second parameter is the index of the icon to be used with this record, and
      the last parameter is the label for the list item - the string "Customer List" in the case of the first item added to the ListView in
      <computeroutput>OrderMgmtView</computeroutput>.
      </para>
    </listitem>
  </orderedlist>

  </section>  <!-- End of section 6.3.1 -->

  <section id="chap06-listview-report"><title>The Report View</title>  <!-- Section 6.3.2 -->
    <!--
      6.3.2.   The Report View
      - Looking at the two list views, almost begs for a superclass.
      - how do different fonts for the listView items
      - Explain the surfacing of an instance in the listview dialogs - check the showModel method.
    -->
    <para>Three of the icons in the Order Management dialog surface a list when double-clicked - Customers, Products, and Orders.
      These three components are technically very similar - to the extent that a "list superclass" could perhaps be created.
      For the meantime, however, this is not done, and each list is quite separate. However, their similarity means that discussing one
      list - the Customer List - effectively addresses all.
    </para>
    <para></para>
  </section>  <!-- End of section 6.3.2 -->

</section>  <!-- End of section 6.3 -->

<section id="chap06-resize"><title id="resize.title">Re-sizing Dialogs</title>  <!-- Section 6.4 -->
<para>If you haven't already done so, try re-sizing the Order Management dialog.
  The ListView containing the icons
  expands to match the new window size, and one of the two pushbuttons moves as well, although their size
  - unlike the size of the List View - does not change. This re-sizing function is only available
  for a <computeroutput>UserDialog</computeroutput>, and requires a number of methods and lines of code.
  ooDialog provides three samples of the resizing function in the folder
  <computeroutput>ooRexx\samples\oodialog</computeroutput> folder -
  the relevant programs being <computeroutput>dlgAreaUDemo.rex</computeroutput>,
  <computeroutput>dlgAreaUDemoTwo.rex</computeroutput>, and
  <computeroutput>dlgAreaUDemoThree.rex</computeroutput>.
  <computeroutput>OrderManagementBaseView.rex</computeroutput> includes much of the code from the last
  of these three samples.
</para>
<para>
  The re-sizing function is provided by two ooDialog classes: <computeroutput>dlgAreaU</computeroutput>
  and <computeroutput>dlgArea</computeroutput> (see ooDialog Reference sections 10.14 and 10.15).
  An important constraint is that, because <computeroutput>dlgAreaU</computeroutput> parses
  the source code of the <emphasis role="italic">defineDialog</emphasis> method in order to handle re-sizing,
  it will only work with <computeroutput>UserDialog</computeroutput>, where the dialog template is created
  through explicit control creation statements. In addition, since the source code is required at run-time,
  it will not work if the source code is tokenized using <emphasis role="italic">rexxc</emphasis>.
</para>
<para>
  Essentially, the dialog is first split into a number of areas - two areas for the
  OrderManagement dialog. ears for . dilaog defines the A re-sizeable dialog - an excellent sample dialog -
    </para>
</section>  <!-- End of section 6.4 -->


<section id="chap06-icons"><title id="icons.title">Creating and Using Icons</title>  <!-- Section 6.5 -->
  <!--
    6.5    Creating and Using Icons
    - Icons - making them, getting 'em into the program. -
    (1) Does the icon have to be a certain size, or will it get automatically shrunk?
    (2) If it has to be a certain size, what's the size, and are there any restrictions as to the palette (I'm no expert, but using GIMP I'm given the option of saving as 16-bit, 24-bit or 32-bit color (or I think it's color!)).
    (3) In the ~execute statement, I need to provide an ID. Does this mean I must have a *.rc file? Or can I invent an ID programmatically somehow - perhaps along the same lines as creating an ImageList?
    (4) I want to assign my own icon as the dialog icon (that is, the icon at the extreme top left of a dialog). This is done (I understand) in the ~execute(..., <icon_ID> ) method (ooDialog Reference section 3.10.3).
  -->
  <para>- Icons - making them, getting 'em into the program. - GIMP (GNU Image Manipulation Program) from
      http://www.gimp.org
</para>
</section>  <!-- End of section 6.5 -->

<section id="chap06-utildlgs"><title id="utildlgs.title">Utility Dialogs</title>   <!-- Section 6.6 -->
  <indexterm><primary>Password dialog</primary></indexterm>
  <indexterm><primary>Utility routine</primary><secondary>PasswordBox</secondary></indexterm>
  <!--
    6.6    Utility Dialogs - <- ??? <What's this??> (Is this the layer - process-entity-utility? Or just useful "canned" dialogs?)
    - Mention password on startup to illustrate ooDialog use in otherwise non-ooDialog rexx programs.
    "startup enterPW" - password is "Password".
  -->
  <para>A subject not yet mentioned is the use of ooDialog utility classes and routines in non-ooDialog ooRexx programs.
    These are documented in Chapter 9 of the ooDialog Reference. The routines are very simple, and are often one-liners.
    As an example, the Exercise06 startup program
    provides for entry of a password using the (one-line) PasswordBox routine.
    Invoking <emphasis role="italic">startup enterPW</emphasis> produces a password box that will accept the password
    "Password". If you get the password wrong, the startup routine will silently end. The code is as follows:
    <programlisting>
    <![CDATA[
    parse arg pwOption
    if pwOption = "enterPW" then do
      pwd = PasswordBox("Please enter your password","Sign In")
      if pwd \= "Password" then exit
    end
    .OrderMgmtView~newInstance
    ::REQUIRES "OrderMgmt\OrderMgmtView.rex"
    ]]>
    </programlisting>

    </para>
</section>  <!-- End of section 6.6 -->

</chapter>
