<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog User Guide XML file.
    #
    # Copyright (c) 2011-2011, Rexx Language Association. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->

<!-- Chapter04 version 00-01 - Using Resource Dialogs
     4.1   Naming and Coding Conventions
     4.1.1 Naming Conventions
     4.1.2 Coding Conventions
     4.2   Resource Scripts and a Resource File Editors
     4.3   Coding an RcDialog Class
     4.3.1 Setting Up the Dialog
     4.3.2 Handling User Events
     4.3.3 Application Data and Function
     4.4   Coding a ResDialog Class

-->

<chapter id="chapFour">
  <title>Using Resource Dialogs</title>
<!-- Note: Could be called "Resource-based Dialogs" or some such...  -->
<indexterm><primary>Resource Dialogs</primary></indexterm>
<indexterm><primary>CustomerView component</primary></indexterm>
<indexterm><primary>ProductView component</primary></indexterm>
<para>In this chapter, we start to build components of the eventual sample application.
The completed application will be a rather simplistic sales order processing application, and
will look something like the following design mockup:
  <figure id="fig0401"><title>The Sales Order Management Application</title>
    <mediaobject>
      <imageobject>
        <!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
        <imagedata fileref="Chapter04-image1.jpg" scale="70">
      </imageobject>
    </mediaobject>
  </figure>
  The purpose of this application is to provide a vehicle for
  exploring various ooDialog concepts and facilities, and this chapter addresses the use of
  "resource files" in the context of two "View" components - CustomerView and "Product View".
</para>
<para>
  A resource file is a file that defines the GUI "resources" such as edit fields,
  lists, buttons, menus, etc. that populate a window. The easiest and arguably the
  best way to define the layout of GUI controls in a dialog window is to use a "resource editor".
  A resource editor is a "wysiwyg" (what you see is what you get) development tool
  that allows a developer to design a window layout visually. The output is a resource file.
  This avoids the sometimes
  tortuous effort of laying out the dialog programmatically.  Although using a resource editor
  is certainly not the be-all and end-all of ooDialog programming, it's very useful
  for getting started quickly, and is the recommended way to define ooDialog window layouts.
</para>
<para>The vehicles for exploring resource files will be the Customer
  and Product parts of the sample application. Although simplistic, the application is sufficiently
  complex for some naming and coding conventions to be useful, and the first section of this chapter
  describes these conventions. Then the use of human-readable
  resource scripts is introduced in the context of a "Customer View" dialog.
  Third, the three major parts of a dialog are discussed. The last section
  then introduces the use of compiled (binary) resource files in the context of a ProductView component.
</para>

<section id="chap04-convs"><title>Naming and Coding Conventions</title><!-- section 4.1 -->

<section id="chap04-convs-names"><title>Naming Conventions</title><!-- section 4.1.1 -->
<para>Readers may prefer to skip this section, at least for the tiem being, and go straight
  to <link linkend='chap04-resourcefile'>Resource Scripts and Resource File Editors</link>.
</para>
<para>At the beginning of Chapter 2 there was a brief discussion about separation of concerns into
        three areas: the UI including both presentation and user action, the "business", and
        accessing data. From here onwards, this approach becomes an important convention for the
        structure of the sample Order Management application. Essentially we adopt a "component"
        approach to the application. Thus the "customer" concept is implemented by three "main"
        classes <computeroutput>CustomerView</computeroutput>,
          <computeroutput>CustomerModel</computeroutput>, and
          <computeroutput>CustomerData</computeroutput>. By "main class" is meant the class that
        implements the business concept as opposed to subsidiary classes such as an "address" class
        that might be used within the Customer component. Such subsidiary classes are typically
        included in the same file as the main class. The name given to the group of main classes
        that contribute to a single important business concept such as "customer" is "business
        component". Thus in the sample application, CustomerView, CustomerModel and CustomerData are
        the three parts of the Customer Business Component.
</para>
<para>The naming convention
  used to distinguish between the three different kinds of main class is to provide one of the suffices
  "View", "Model", or "Data" to the class name. Thus for example:
  <computeroutput>CustomerView</computeroutput> will be the name of the "UI" part of the
  implementation of the "Customer" concept; <computeroutput>CustomerModel</computeroutput> the name
  of the "business" part, and <computeroutput>CustomerData</computeroutput> that of the data access part.
  Normally, each main class (plus any subsidiary classes) would be in its own file. However, since the
  focus is on View components, the Model and Data components are placed in a single file, called
  <computeroutput>xxxMAD.rex</computeroutput>, where "xxx" is the business concept name,
  and MAD is short for "Model and Data".
</para>
<para>By the way, in real-life systems there would probably be four parts to a concept such as
        "customer" - a view and a user-oriented model both supporting the user, and, supporting
        multiple concurrent users on a server or back-end system, a business-oriented "model" plus a
        data part that accesses the corporate database. Also by the way, in real-life supply chain
        management applications, addresses are typically treated as separate entities rather than
        being lumped in with such concepts as Customer, Employee or Supplier. </para>
<para>Finally, variables often have a prefix that indicates what the variable is.
  For example, an edit control that holds a customer number would be named
  <emphasis role='italic'>ecCustNo</emphasis>, the <emphasis role='italic'>ec</emphasis>
  being short for "edit control".
</para>
</section><!-- End of section 4.1.1 -->

<section id="chap04-convs-coding"><title>Coding Conventions</title><!-- section 4.1.2 -->
<para>The following coding conventions are used in the exercise code. First, ooRexx keywords are
        capitalized. Second, classes, methods, and routines are separated from each other by dotted
        or solid lines which in some editors are displayed in a different color from the executable
        code. This provides useful visual separation of methods and classes which is useful in
        larger programs. Third, camel case is used for variable names, with class names having their
        first letter capitalized. Finally, when an ooRexx program in one of the exercises is run,
        comments produced with an ooRexx "say" instruction may appear in the command prompt window.
        The format used for these comments is [classname]-[methodname]-[nn] - a little excessive for
        simple single-class programs, but useful for larger multi-class applications.
</para>
</section><!-- End of section 4.1.2 -->

</section><!-- End of section 4.1 -->

<section id="chap04-resourcefile"><title>Resource Scripts and Resource File Editors</title><!-- section 4.2 -->
<para>Our first foray into the sample Order Management application is to examine a simple
  Customer View component built using a resource editor.
</para>
<para>But which resource editor? Well, if you happen to have Microsoft's development kit, you'll
      find it has a resource editor. Alternatively, there are a number of fee and free resource
      editors available on the web. The author of this Guide happened to use a freeware product
      called "ResEdit" (see
      <!-- <ulink url="http://www.resedit.net/"><citetitle>www.resedit.net</citetitle></ulink> -->),
      and occasional hints about ResEdit usage will appear from time to time. In addition, comments
      about the use of resource file editors will assume ResEdit, and may well be inapplicable to
      other resource editors. If you plan to use ResEdit, please be aware that a number of Microsoft
      header files are required. These can be obtained at no charge from
      <!-- <ulink url="http://www.microsoft.com/downloads/en/details.aspx?FamilyID=c17ba869-9671-4330-a63e-1fd44e0e2505">
       <citetitle>Microsoft Windows SDK</citetitle></ulink>. -->
      They should be downloaded into a folder, and the full path name of that folder must be
      specified to ResEdit in "Options - Preferences - General - Include paths".
</para>
<para>A resource file editor outputs a window layout to a "resource file", which ooDialog can then
  use to lay out controls on a dialog automatically. There are two kinds of resource file:
  a human-readable file with the extension ".rc" (and sometimes ".dlg"), and a binary (compiled)
  file with the extension ".res".
</para>
<para>Locate the folder <computeroutput>Exercise04a</computeroutput>, and run
        <computeroutput>Startup.rex</computeroutput>. You see a "Customer" dialog. Explore the menu
      and behavior of this dialog. Note the following: <itemizedlist>
        <listitem>
          <para>A number of comments appear on the console; ignore them for the time being.</para>
        </listitem>
        <listitem>
          <para>The title bar (the blue bar right at the top of the dialog window) shows not the
            Customer's name, but the string "*CustomerName*", suggesting that the programmer has
            either made an error or (as in this case) has left a marker for future
            modification.</para>
        </listitem>
        <listitem>
          <para>Edit controls are shown grayed out or "disabled" - that is, not editable.</para>
        </listitem>
        <listitem>
          <para>The "Action" menu has four items.</para>
        </listitem>
        <listitem>
          <para>One button - "Record Changes" is disabled, the other is not.</para>
        </listitem>
      </itemizedlist>Make sure you exercise the menu items and buttons to explore the dialog's
      behavior. You'll find that some expected behavior is not implemented, and results in a
      message-box - for example "PRINT is not a method of CustomerView". Note also the tab order -
      that is, the order <indexterm>
        <primary>Tab order</primary>
      </indexterm> of controls reached as you press the tab key. This is defined by the sequence in
      which controls appear in the .rc file. If the tab order is not as you'd like it, you can edit
      the .rc file and use cut-and-paste to achieve the desired tab order. </para>
<para>Now double-click the file <computeroutput>CustomerView.rc</computeroutput> in the
        <computeroutput>Exercise04a</computeroutput> folder. The file should open in ResEdit (or
      your own preferred resource editor). In the ResEdit "Resources" window, double-click on
        <computeroutput>IDD_DIALOG1</computeroutput> and the dialog layout tool opens, looking like
      this: <figure id="fig0402">
        <title>A Resource Editor</title>
        <mediaobject>
          <imageobject>
            <!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
            <imagedata fileref="Chapter04-image2.jpg" scale="70">
          </imageobject>
        </mediaobject>
      </figure>
      <!-- Should the window also be shown to show how close it is to the ResEdit view?? -->
    </para>
    <para>You might move or re-size some of the controls, save the file, then re-run Exercise04a to
      see your changes implemented. Check the files in the
        <computeroutput>Exercise04a</computeroutput> folder. The files needed by ooDialog to create
      the window are <computeroutput>CustomerView.rc</computeroutput> and
        <computeroutput>CustomerView.h</computeroutput>. Both of these are generated by the resource
      editor. (ResEdit tip: to cause the .h file to be named the same as the .rc file, on the menu
      bar select Options - Preferences - Code Generation - Files, then set the "Header file name" to
        "<emphasis role="italic">%barefilename%.h"</emphasis>.)
    </para>
<para>Finally, a hint from hard experience. Some resource editors have been known,
very occasionally, to assign same ID number to two different controls in the .h file,
or to omit a resource from the .rc file. So, if it seems that
the wrong method is being invoked for a given symbolic ID, or some other error occurs
which on re-checking the code seems inexplicable, it could be worth checking the .h file
to see whether the same number has been assigned to two symbolic IDs. If so, you
can try hand-editing the .h file then re-starting the resource editor. If the .h
file looks OK, then you might check the .rc file to see if all the resources are there.
</para>
</section>

<section id="chap04-rcdialogcode"><title>Coding an RcDialog Class</title><!-- section 4.3 -->
<para>Having discussed coding conventions and resource editors, this section now looks in detail at
      the code in the <computeroutput>Exercise04a</computeroutput> folder. First, look at
        <computeroutput>Startup.rex</computeroutput> in an editor. There's only one executable
      statement: <emphasis role="italic">call startCustomerView</emphasis>. This routine is in the
        <computeroutput>CustomerView.rex</computeroutput> file (it's generally good practice to
      separate application startup concerns - such as creating new dialogs - from the various
      working parts of the application). </para>
<para>Now look at <computeroutput>CustomerView.rex</computeroutput> in an editor. Look for the
        <computeroutput>CLASS</computeroutput> statement: <programlisting>
    <![CDATA[
    ::CLASS 'CustomerView' SUBCLASS RcDialog PUBLIC
    ]]>
  </programlisting><computeroutput>CustomerView</computeroutput> is a subclass of the
      ooDialog built-in class <computeroutput>RcDialog</computeroutput>, which gets its dialog
      layout from a resource script file that is human-readable (using a text editor). RcDialog is
      one of two important ooDialog classes that use resource scripts; the other is
        <computeroutput>ResDialog</computeroutput>, which uses a binary (compiled) resource file as
      discussed in the next chapter. More information on resource files can be
      found in chapter 6 of the ooDialog Reference. </para>
<para>View classes can be seen as consisting of three major parts: setting up the dialog window,
      specifying the "active" controls (i.e. controls that need to be accessed programmatically),
      and handling the application data and function. Let's look at each of these in the context of
        <computeroutput>CustomerView.rex</computeroutput>. </para>

<section id="chap04-rcdialogcode-setup"><title>Setting Up the Dialog Window</title><!-- section 4.3.1 -->
<para>When you ran <computeroutput>StartUp.rex</computeroutput>, there were an initial set of
        comments displayed in the command prompt window, as follows: <programlisting>
    <![CDATA[
    D:\...\Exercise04a>startup
    StartCustomerView Routine-01: Start.
    CustomerView-init-01.
    CustomerView-createMenuBar-01.
    StartCustomerView Routine-02: dlg~activate.
    CustomerView-activate-01.
    CustomerView-initDialog-01.
    ]]>
  </programlisting>These comments trace the process of establishing a dialog to the point of
        making the window visible - in other words, setting up the dialog. One routine and four
        methods are involved, as follows: <orderedlist>
          <listitem>
            <para>The <computeroutput>StartCustomerView</computeroutput> routine
            in <computeroutput>CustomerView.rex</computeroutput> first stores the resource header file
            file <computeroutput>CustomerView.h</computeroutput> in the
            <indexterm><primary>.Application object</primary></indexterm>
            <computeroutput>.Application</computeroutput> object using the
            <emphasis role='italic'>useGlobalConstDir</emphasis> method. The header
            file provides the correspondance between numeric
            and symbolic IDs, so that the numeric IDs in the resource DLL can be
            mapped to symbolic IDs used in the program.(See sections 10.1 and 10.5 of the
            ooDialog Reference for further information on .Application.) Then an 
            instance of the <computeroutput>CustomerView</computeroutput> class (a subclass
            of <computeroutput>RcDialog</computeroutput>) is created.</para>
          </listitem>
          <listitem>
            <para>In the <emphasis role="italic">init</emphasis> method of the new view instance,
              first the superclass is invoked (this is an ooDialog requirement), and then the
                <emphasis role="italic">createMenuBar</emphasis> method is called. If the
              menubar creation fails, then the dialog's <emphasis role="italic">initCode</emphasis>
              attribute is set to 1 (initCode is an attribute of a <computeroutput>.Dialog</computeroutput>
              instance and represents the success of initialization of a dialog object).
              After the <emphasis role="italic">init</emphasis> method has executed the
              <emphasis role="italic">initCode</emphasis> attribute will be zero
              if the dialog initialization detected no errors, and non-zero if
              initialization failed or an error was detected.</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="italic">createMenuBar</emphasis> method then creates a menubar
              (in this case an instance of the .ScriptMenuBar class - see section 25.6 of the
              ooDialog Reference), referring to the menubar's ID in the .rc file. Note that after
              creation, the menubar is just another object, and is not yet associated with the
              dialog. The code at this point boldly assumes that the menubar instance was
              successfully created. This is not really best practice; however if initialization fails
              the failure will be immediately visible - or rather invisible in that the
              dialog will fail to appear!. Control then returns to the
              <emphasis role="italic">init</emphasis> method and from there back to the ...</para>
          </listitem>
          <listitem>
            <para>...<computeroutput>StartCustomerView</computeroutput> routine, which invokes the
              dialog's <emphasis role="italic">activate</emphasis> method. </para>
          </listitem>
          <listitem>
            <para>The <emphasis role="italic">activate</emphasis> method issues
                <computeroutput>SHOWTOP</computeroutput> to the view's superclass, which then sends
              itself an <emphasis role="italic">initDialog</emphasis> message.</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="italic">initDialog</emphasis> method attaches the menubar to
              itself (that is, to the dialog instance). The remainder of the method is concerned
              with specifying the active controls, which is addressed in the next section.</para>
          </listitem>
        </orderedlist>
      </para>
<para>The above process requires four methods and a total of 19 ooRexx statements including the
          <computeroutput>::Method</computeroutput> statements but excluding the <emphasis
          role="italic">say</emphasis> instructions. And if we didn't care too much for effective
        program structure or error checking, it could be squished down to just ten instructions as
        follows:
  <programlisting>
    <![CDATA[
    ::CLASS CustomerView SUBCLASS RcDialog PUBLIC
      ::METHOD init
        forward class (super) continue
        self~execute("SHOWTOP")
      ::METHOD initDialog
        menuBar = .scriptMenuBar~new("CustomerView.rc", "IDR_MENU1", self, , , .true)
        menuBar~attachTo(self)
      ::ROUTINE startCustomerView PUBLIC
        .application~useGlobalConstDir("O", "CustomerView.h")
        dlg = .CustomerView~new("customerView.rc", "IDD_DIALOG1")
    ]]>
  </programlisting>
  And if the <computeroutput>::class</computeroutput>,
  <computeroutput>::method</computeroutput>, and <computeroutput>::routine</computeroutput>
  directives are excluded, only six statements are required: defining
  <computeroutput>CustomerView.h</computeroutput> as the *.h file, the 
  <emphasis role="italic">.CustomerView~new</emphasis>
  to create a dialog instance, call super in the <emphasis role="italic">init</emphasis>
  method, issue <emphasis role="italic">execute("SHOWTOP")</emphasis>, create a menubar,
  and attach the menubar to the dialog.</para>
<para>
  In other words, dialogs of significant complexity can be created and displayed with
  only six executable statements. And that is the real power of resource dialogs.
</para>
</section>

<section id="chap04-rcdialogcode-controls"><title>Specifying the Active Controls</title><!-- section 4.3.2 -->
<para>An "active control" is a control that requires behavior to be programmed, while a "passive"
        control (such as text that is never changed) appears only in the resource file, and is of no
        concern to the program. The behavior associated with an active control is of two kinds:
        outbound or program-to-window - i.e. providing the user with information, and inbound or
        window-to-program - i.e. signaling the progam about a user event. Outbound behavior means
        changing the state of a control - for example, disabling a pushbutton, or displaying text in
        an edit control. Inbound behavior is a user event that requires the program to take some
        action - e.g. the user selects a menu item, or clicks a pushbutton. Much inbound behavior is
        ignored by the program (e.g. the user placing the cursor in an edit control). For both
        inbound behavior that is relevant to the program, and also for outbound behavior, the
        relevant controls must be made available to the programmer as ooRexx objects. </para>
<para>Now controls are actually created by Windows, based on information in the resource file, with
        each control being created and managed by facilities built into the Windows operating
        system. However, the ooRexx programmer accesses controls via instances of ooDialog classes,
        so that each control on a window is represented by an ooRexx object that is really a proxy<indexterm>
          <primary>Proxy for controls</primary>
        </indexterm> for the underlying Windows control. And it is ooDialog that creates the
        required link between such ooRexx objects and the underlying Windows controls - and hence
        between the ooRexx object and the visible controls on the screen. By the way, and rather
        obviously (but we'll say it anyway), this means that ooDialog cannot provide any GUI
        function that is not already provided by the underlying Windows facilities. </para>
<para>To manage controls, ooDialog provides a class for each control type (see chapters 11 through
        24 of the ooDialog reference). The link between an ooRexx control and the underlying Windows
        control is created via the control's symbolic ID in the <computeroutput>.rc</computeroutput>
        and <computeroutput>.h</computeroutput> files. Creating the ooRexx control proxies is
        typically done in the <emphasis role="italic">initDialog</emphasis> method. In the
          <computeroutput>CustomerView</computeroutput> code for example, in order to display the
        Customer Number in an edit control (outbound active behavior) an ooRexx proxy is created in
        the <emphasis role="italic">initDialog</emphasis> method as follows: <programlisting>
    <![CDATA[
    ecCustNo = self~newEdit("IDC_EDIT_CUST_NO")
    ]]>
  </programlisting>The variable <emphasis role="italic">ecCustNo</emphasis> is the proxy
        ooRexx object for the Windows edit control that will contain the customer number; <emphasis
          role="italic">self</emphasis> is the dialog instance; <emphasis role="italic"
          >newEdit</emphasis> is the method of the Dialog Object (see chapter 3 of the ooDialog
        Reference) that creates the ooRexx proxy for the underlying Windows control; and <emphasis
          role="italic">IDC_EDIT_CUST_NO</emphasis> is the controls' symbolic ID from the
          <computeroutput>.h</computeroutput> file. After execution of the statement, <emphasis
          role="italic">ecCustNo</emphasis> is an instance of the ooDialog
          <computeroutput>Edit</computeroutput> class, and ooDialog has made sure, in the instance's
        creation, that it is internally linked to the edit control on the screen identified in the
        .h and .rc files as <emphasis role="italic">IDC_EDIT_CUST_NO</emphasis>. </para>
<para>To avoid tedious repetition, from now on this document will assume an understanding of the
        relationship between a proxy ooRexx instance and the underlying Windows control, and will
        mention only the ooRexx control - without using the term "proxy". </para>
<para>A number of other outbound active controls are created in the <emphasis role="italic"
          >initDialog</emphasis> method - as many as there are fields on the dialog that need to
        have data placed in them when the dialog opens. In addition, a "Record Changes" pushbutton
        object is created so that the button can be enabled (outbound active behavior) when a user
        chooses the menu option "Update..." (inbound active behavior). </para>
<para>After this, the following statement appears:
<programlisting>
<![CDATA[
  self~connectButtonEvent("IDC_RECORD_CHANGES","CLICKED",recordChanges)
]]>
</programlisting>
  This is an example of specifying an "event handler" (inbound active
        behavior). Suppose the user presses the "Record Changes" button. Windows signals the event.
        The above statement states that this event - that is, the pushbutton (identified in the
          <computeroutput>.h</computeroutput> file as
          <computeroutput>IDC_RECORD_CHANGES</computeroutput>) is
          <computeroutput>CLICKED</computeroutput> - will invoke the <emphasis role="italic"
          >recordChanges</emphasis> method. In other words, the statement defines <emphasis
          role="italic">recordChanges</emphasis> as the event-handling method for the "Record
        Changes" pushbutton. The same is done for the "Show Last Order" pushbutton, where the event
        handler is specified to be the method <emphasis role="italic">lastOrder</emphasis>. </para>
<para>
  Notice that each of the event handler methods are specified as
  <computeroutput>UNGUARDED</computeroutput>. In general, an event handler should
  be unguarded to preclude the possibility that some guarded method in the dialog
  object is executing at the time the event notification is generated. For further
  information, see ooDialog Reference sections 2.2.4, the introduction to
  section 5.7, and also section 5.7.1.
</para>
<para>
  Specification of active controls is generally done in the
  <emphasis role='italic'>initDialog</emphasis> method. Indeed, in the
  <computeroutput>CustomerView</computeroutput> class, specification of active
  controls occupies most of this method.
</para>
<para>
  Note that MenuBar actions are not specified. This is because the menu items in
  <computeroutput>CustomerView.rex</computeroutput> are "auto-connected" (see the <link
  linkend="apx-connections">appendix</link>). Auto-connection is specified in the last parameter of the <emphasis
  role="italic">.ScriptMenuBar~new</emphasis> statement (see section 25.6 of the ooDialog Reference) in the <emphasis
  role="italic">createMenuBar</emphasis> method:

<programlisting>
<![CDATA[
    menuBar = .ScriptMenuBar~new("CustomerView.rc", "IDR_MENU1", self, , , .true)
]]>
</programlisting>
  <indexterm><primary>menuBar</primary><secondary>RcDialog</secondary></indexterm>
  <indexterm><primary>RcDialog</primary><secondary>menuBar</secondary></indexterm>
  Setting this parameter to <computeroutput>.true</computeroutput> (the default is
  <computeroutput>.false</computeroutput>) specifies that all menu items will be connected automatically to a method
  with the same name as the visible caption or text. In <computeroutput>CustomerView.rc</computeroutput> the "File"
  sub-menu is:
<programlisting>
<![CDATA[
    MENUITEM "New Customer...", IDM_NEWCUST___1
    MENUITEM "Update...", IDM_UPDATE___1
    MENUITEM "Print...", IDM_PRINT___1
    MENUITEM "Last Order", IDM_XXYYZZ
]]>
</programlisting>
  Spaces and trailing dots are stripped, giving method names of
        "NewCustomer", "Update", "Print", and "LastOrder". In the "Menu Methods" part of the
          <computeroutput>CustomerView</computeroutput> code, a method is provided for three of
        these menu items. There is deliberately no method provided for "Print" in order to show what
        happens when you don't provide a method for an auto-connected menu item (you get an error
        message box from ooDialog). </para>
<para>But before the menu actions will work, the <emphasis role="italic">menuBar</emphasis> object
        must be associated with the dialog object. This is done by this statement (at the beginning
        of the <emphasis role="italic">initDialog</emphasis> method):
<programlisting>
<![CDATA[
      menuBar~attachTo(self)
]]>
</programlisting>
  </para>
<para>At this point, the dialog is displayed complete with all its controls. But there is no data
        shown. When executed, it looks as if the data appears at the same time as the window, but it
        does not. To illustrate this, insert a <emphasis role="italic">call SysSleep 3</emphasis>
        statement just before and just after the statement <emphasis role="italic">
          menuBar~attachTo(self)</emphasis> and run the program. You'll see the window without
        menubar, then the menubar will appear, and then the data. </para>
<para>The last two statements in the <emphasis role="italic">initDialog</emphasis> method kick off
        the initial parts of the Application and Data Function category. The first invokes a method
        to retrieve the data for this customer, the second to display it. At which point the view
        sits back and waits for the user to do something. </para>
</section>  <!-- end of section 4.3.2 -->

<section id="chap04-rcdialogcode-appdata"><title>Application Data and Function</title> <!-- section 4.3.3 -->
<para>Designing the application function and data handling part of a main view class is more complex
        than is often thought. The designer has to consider a number of different possible states of
        the dialog, and also which state transitions are valid. Sometimes state and state transition
        charts are used to plan and record UI interactions. And, in doing this design work, the
        first consideration is the user. Indeed, providing what the user needs and likes is probably
        the most difficult aspect of GUI development. But who is "the user"? Well, this document
        would be going well outside its remit to embark on addressing this question. Suffice to say
        that there are a number of sources for information on usability, among which one of the
        author's favorites is "The Inmates Are Running The Asylum" by Alan Cooper. But here, the
        main concern is use of ooDialog rather than UI design per se, and so in this document, UI
        design takes a back seat.</para>
<para>In the case of <computeroutput>.CustomerView</computeroutput>, the application behavior is
        very simple: <itemizedlist>
          <listitem>
            <para>On initial display of the CustomerView instance, populate the controls with data.
              This is done by invoking (at the end of the <emphasis role="italic"
                >initDialog</emphasis> method) the <emphasis role="italic">getData</emphasis> and
                <emphasis role="italic">showData</emphasis> methods. The first gets the data for
              this customer, and the second displays that data. The dialog then waits for user
              input. </para>
          </listitem>
          <listitem>
            <para>On "Update" being menu-selected, the edit controls are first enabled so that the
              user can modify the data, and the "Record Changes" button is enabled.</para>
          </listitem>
          <listitem>
            <para>On the "Record Changes" button being pressed, first a check is made as to whether
              anything has in fact been changed. If so, a comment is output to the console, and the
              state is set back to the starting position with the "Record Changes" button and edit
              controls disabled. If nothing has been changed, a message box is displayed. </para>
          </listitem>
          <listitem>
            <para>Finally, several minimal or dummy actions are provided as place-markers for
              possible future use: three menu items (New Customer..., Print..., and Last Order) and
              a "Show Last Order" pushbutton. The last two - the "Last Order" menu item and the
              "Show Last Order" pushbutton illustrate how - if ever required - two or more events
              can invove the same event handler. </para>
          </listitem>
        </itemizedlist>
      </para>
<para>This function is delivered through nine methods: five event handler methods (three for menu
        items and two for pushbuttons) and four methods supporting the event handlers. Between them,
        they deliver the application and data function. The following examines the ooDialog aspects
        of the application function. </para>

<section><title>The getData and showData Methods</title> <!-- section 4.3.3.1 -->
<para>the <emphasis role='italic'>getData</emphasis> method merely puts dummy data
  into a directory object (in the next chapter it will retrieve data from the View's model
  object).
</para>
<para>
  The <emphasis role='italic'>showData</emphasis> method uses the
  <emphasis role='italic'>setText</emphasis> method (see section 5.4.27 of the
  ooDialog Reference) to set the text of the various
  controls to the customer's data. There are two things to note here:
  <itemizedlist>
  <listitem><para>First, each control is in fact a separate window in its own right.
    Thus the <emphasis role='italic'>setText</emphasis> method can be used to set the
    text for any control. For example, the text on a pushbutton can be changed using this method.
    To check this out, try inserting the statement:
    <programlisting>
    <![CDATA[
      custControls[btnRecordChanges]~setText("Press me")
    ]]>
  </programlisting>
    at the end of the <emphasis role='italic'>update</emphasis> method. When "Update"
    is menu-selected, the text on the button changes.
  </para></listitem>
  <listitem><para>Second, the Customer Address data is an array, which for display
    in a multi-line edit control must be transformed into a text string with line-ends
    inserted at appropriate places. This kind of transformation is very usual
    within view classes; after all, it's the responsiblity of any View class (or
    of its subsidiary classes or routines) to handle any re-formatting for display purposes.
  </para></listitem>
  </itemizedlist>
</para>
</section> <!-- end of section 4.3.3.1 -->

<section>
        <title>The Update and Record Changes Methods</title>
        <!-- section 4.3.3.2 -->
        <para> The <emphasis role="italic">update</emphasis> method enables the edit controls and
          the "Record Changes" button so that the user can make changes and then make the changes
          permanent (i.e. "record" them). Enabling edit controls is done by sending them the message
            <emphasis role="italic">setReadOnly</emphasis> with the parameter
            <computeroutput>.false</computeroutput>. For example: <programlisting>
    <![CDATA[
    custControls[ecCustName]~setReadOnly(.false)
    ]]>
  </programlisting>
        </para>
        <para>Pushbuttons are enabled by invoking <emphasis role="italic">enableControl</emphasis>
          on the dialog, the parameter being the control's symbolic ID as shown in the first
          statement below. The second statement below puts focus on the push-button - in this case
          by invoking the <emphasis role="italic">state</emphasis> method of the control object.
          Finally, the cursor is placed in the Customer Name edit control by invoking the dialog's
            <emphasis role="italic">focusControl</emphasis> method.
  <programlisting>
  <![CDATA[
    self~enableControl("IDC_RECORD_CHANGES")
    custControls[btnRecordChanges]~state = "FOCUS"  -- Put focus on the button
    self~focusControl("IDC_EDIT_CUST_NAME")         -- place cursor in the CustName edit control.
    ]]>
  </programlisting>
  </para>
        <para>Note that in some cases the method invoked is directly on the control object, and in
          other cases the method belongs to the dialog object with the control being specified in a
          method parameter. The reason for this is that some methods (such as <emphasis
            role="italic">setText</emphasis>) are applicable to all controls, and so can be invoked
          on any control, while others (such as <emphasis role="italic">focusControl</emphasis>)
          have meaning within the context of the dialog as a whole. </para>
        <para><emphasis role="bold">[OS Note: I believe that this explanation may be too simplistic
            and quite possibly wrong. To be reviewed!]</emphasis></para>
        <para>The dialog is now in a state whereby the user can make changes to the data. When the
          user presses the "Record Changes" button, the <emphasis role="italic"
            >recordChanges</emphasis> method is invoked. Processing from this point is almost all
          plain ooRexx with little ooDialog involvement: <itemizedlist>
            <listitem>
              <para>The <emphasis role="italic">xformView2App</emphasis> method is invoked and
                returns the data from the edit controls as a directory, with the address element
                being an array. To read data that the user has entered, the method uses the
                  <emphasis role="italic">getText</emphasis> and <emphasis role="italic"
                  >getLine</emphasis> methods of the Edit Control. </para>
            </listitem>
            <listitem>
              <para>Then the <emphasis role="italic">checkForChanges</emphasis> method is invoked
                with, as a parameter, the data returned from <emphasis role="italic"
                  >xformView2App</emphasis> method. </para>
            </listitem>
            <listitem>
              <para>If the data has not changed, a message box is displayed. If it has changed, then
                the old data is replaced with the new. In either case:</para>
            </listitem>
            <listitem>
              <para>The edit controls are set to read-only, and the "Record Changes" button is
                disabled.  </para>
            </listitem>
          </itemizedlist></para>
      </section> <!--end of section 4.3.3.2 -->

</section> <!-- end of section 4.3.3 -->

</section> <!-- end of section 4.3 -->

</chapter>

