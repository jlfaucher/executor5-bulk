<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog User Guide XML file.
    #
    # Copyright (c) 2011-2012 Rexx Language Association. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->

<!-- Chapter03 - Re-Structuring the Code			  v00-05 02Apr12

     v00-04 12Aug11: Changed names of rex files and view classes in the code;
                     text changed to match, plus some minor corrections.
     v00-05 02Apr12: Minor corrections.
     v00-06 20Apr12: Change book ref.
-->

<chapter id="chapThree"><title>Re-Structuring the Code</title>
<indexterm><primary>code structure</primary></indexterm>
<para>The current code is not good. It works - but only because it's very simple. The problem is its
      design - its structure. There are three quite different concerns that must be separated: the
      user interface (aka UI or GUI) including both presentation and user action; the data (in our
      case a set of text strings); and the "business" concept that we're implementing. And the
      "business" of this code is picking a single text string from a set of "words of wisdom"
      strings. The code in the <computeroutput>Exercise03</computeroutput> folder separates these
      concerns, with no change as far as the user's concerned. </para>
<para>The three areas of concern have a relationship with the Model-View-Controller (MVC) concept -
      see <ulink url="http://en.wikipedia.org/wiki/model-view-controller"
          ><citetitle>Model-View-Controller</citetitle></ulink>. However, the role of the Controller
      in classic MVC is handled largely by ooDialog and the underlying Windows UI platform. This
      leaves us with the View and the Model, where the Model is the "business" - that is, an
      implementation of the relevant part of the real business. But these two concepts - View and
      Model - to say nothing about the data (that is, data-on-disk aka "persistent data"). So three
      areas of concern are required: View, Model, and Data. This scheme works well for the
      PC-resident single-user applications introduced in this Guide, but does not scale to
      distributed systems with multiple concurrent users where, aside from anything else, the
      data is on a remote server. For such systems, additional architectural
      concepts are required (see, for example, chapters 1 and 2 of "Enterprise Service Oriented
      Architectures" by McGovern, Sims, Jain &amp; Little; or "Business Component Factory" by Herzum
      &amp; Sims).<indexterm><primary>Component concepts</primary><secondary>Reference</secondary></indexterm>
      </para>
<para>In summary, a Model component implements the essence of the required application. The View
      enables the user to take action and see the result. The Data component knows where the data
      is, and handles the mechanics of reading and writing data to disk. (For distributed multi-user
      applications, the Model would invoke some service on a back-end server, where there would
      probably be another kind of Model component which in turn would use a separate Data component
      that accesses a corporate database). </para>
<para>Let's now look at the implementation of each of these three areas of concern. In the second
      part of this chapter, we'll further reduce coupling (the rule is: low/loose coupling, high
      cohesion). </para>

<section id="chap03-struc"><title>Fixing the Structure</title><!-- section 3.1 -->
<para>First, re-run <computeroutput>Wow2.rex</computeroutput> in the
          <computeroutput>Exercise02</computeroutput> folder, and then run
          <computeroutput>Wow3.rex</computeroutput> from the
          <computeroutput>Exercise03</computeroutput> folder. To the user, they're identical.
        However, in <computeroutput>Wow3.rex</computeroutput> the code has been re-structured so
        that there are now three different classes, each implementing one of the three areas of
        concern. We'll look at each class in turn, but first here's a whiteboard-level picture of
        how the three classes interact to produce a "words of wisdom" string on the screen.
        </para>
        <para>
        <figure id="fig0301">
          <title>Exercise03 Structure</title>
          <mediaobject>
            <imageobject>
              <!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
              <imagedata fileref="Chapter03-Image1.jpg" scale="70">
            </imageobject>
          </mediaobject>
        </figure>Now look at the <computeroutput>Wow3.rex</computeroutput> code. It's split into the
        three classes shown in the diagram: <computeroutput>WowView</computeroutput>,
          <computeroutput>WowPicker</computeroutput>, and <computeroutput>WowData</computeroutput>.
        "Wow" in the names is short for "words of wisdom". </para>

<section id="chap03-struc-ui"><title>The "View" Area of Concern</title><!-- section 3.1.1 -->
<para>The <computeroutput>WowView</computeroutput> class implements the UI area of
          concern. Its <emphasis role="italic">init</emphasis> method is identical to that of
          Exercise02's <computeroutput>Wow2</computeroutput> except that it also creates an instance
          of <computeroutput>WowPicker</computeroutput> called (unsurprisingly) <emphasis
            role="italic">wowPicker</emphasis>". There's also an <emphasis role="italic"
            >expose</emphasis> statement to make the <emphasis role="italic">wowPicker</emphasis>
          object available to other methods. </para>
<para>
  The <emphasis role="italic">defineDialog</emphasis> method has not changed. But the
  <emphasis role="italic">okClicked</emphasis> method is different - and much shorter:
  <programlisting>
    <![CDATA[
    ::method okClicked
      expose wowPicker newText
      wow = wowPicker~pickWow
      newText~setText(wow)
      return
    ]]>
  </programlisting>
To get the "words of wisdom" to display, it now merely asks
  <emphasis role="italic">wowPicker</emphasis> for a string to display.
</para>
<para>One other change is that instead of creating a new static text control every time the button
          is pressed, the control is created once in the new <emphasis role="italic"
            >initDialog</emphasis> method and re-used in the <emphasis role="italic"
            >okClicked"</emphasis> method. The <emphasis role="italic">initDialog</emphasis> method
          is called automatically by ooDialog after the dialog has been created in order to allow
          controls to be initialized.</para>
<para>In summary, all knowledge of picking a string, and of the set from which to pick, has been
          exported elsewhere. The <computeroutput>WowView</computeroutput> class now addresses only
          the areas of GUI display and GUI interaction. This is crucially important. A good way to
          make a complex task hopelessly complicated is to mix "model" and "data" concerns with the
          "view" concerns. </para>

</section>

<section id="chap03-struc-bus"><title>The "Model" Area of Concern</title><!-- section 3.1.2 -->
<para> The class implementing the model area of concern - <computeroutput>WowPicker</computeroutput>
          - is very simple: <programlisting>
    <![CDATA[
    ::METHOD init
      expose arrWowSet
      dataSource = .WowData~new
      arrWowSet = dataSource~readWowSet
      return

    ::METHOD pickWow
      expose arrWowSet
      i = random(1,7)
      return arrWowSet[i]
    ]]>
  </programlisting>The <emphasis role="italic">init</emphasis>method gets a reference to an
          instance of the class <computeroutput>WowData</computeroutput> - which handles the data
          area of concern - and then gets a set of Words of Wisdom into the array variable <emphasis
            role="italic">arrWowSet</emphasis>. Then in the method <emphasis role="italic"
            >pickWow</emphasis> a Words of Wisdom string is picked randomly from <emphasis
            role="italic">arrWowSet</emphasis> and returned. </para>
</section>

<section id="chap03-struc-dat"><title>The "Data" Area of Concern</title><!-- section 3.1.3 -->
<para>The last (extremely simple) class in <computeroutput>Wow3.rex</computeroutput> is
            <computeroutput>WowData</computeroutput>. In its <emphasis role="italic">init</emphasis>
          method, it loads up an array of seven text strings into the instance variable <emphasis
            role="italic">arrWow</emphasis>, and in its <emphasis role="italic"
            >readWowSet</emphasis> method returns that array to the caller. One can see how this it
          might be enhanced, for example by providing a method that renews the set of "words of
          wisdom" from a larger set in a disk file. But that is nothing to do with ooDialog, so
          we'll leave it as it is. </para>
</section>
</section>
<section id="chap03-cplg"><title>Reducing Coupling</title><!-- section 3.2 -->
    <indexterm><primary>Coupling</primary></indexterm>
<para>The three classes in <computeroutput>Wow3.rex</computeroutput> are reasonably decoupled: the
        dialog is in one class, the business logic (such as it is) in another, and the data in a
        third. Notice however that both <computeroutput>WowView</computeroutput> and
          <computeroutput>WowPicker</computeroutput> create a reference to another class
          (<computeroutput>WowPicker</computeroutput> and <computeroutput>WowData</computeroutput>
        respectively) in order to invoke them. Each of these three classes can be called a "main"
        class, since each is the main (and in this case only) class implementing a separate area of
        responsibility. In more complex applications, each area will have one main class and a
        number of subsidiary classes - for example, a (main) SalesOrder class with subsidiary
        OrderLine and DeliveryInstructions classes. Such collections of classes, implementing an
        important concept in the application (and in the corresponding real world), are called
        "components". The intent of a component is to be, as much as possible, a self-contained unit
        of business function. <indexterm>
          <primary>Component</primary>
        </indexterm>
      </para>
<para>Now, when considering more complex applications, it is arguable that it is not the
        responsibility of either class to know about the creation of instances of other classes.
        Later we will see that, for each important business concept (such as SalesOrder, Customer,
        or Product), each area of responsibility (view, model, and data) will have a number of
        classes, each area having one main class for the business concept. If these three areas are
        to be as independent as possible, then each should know as little as possible about the
        others. Such independence is usefully enhanced if a way is found to move the knowledge of
        how to get references to the main classes to a fourth area. And there is just such an area -
        the application. </para>
  <para>In ooDialog programs, there is often a block of code at the beginning of the program file
        that kicks off a dialog by instantiating an ooDialog class. From there, all the behavior is
        in the dialog classes. This "kick-off" block of code can be used to reduce coupling by
        pre-instantiating the main classes, and storing the object references in
          <computeroutput>.local</computeroutput>. Thus no main class has to know how to instantiate
        any other main class. But, when a main class gets the object reference for another main
        class instance, doesn't the first class have to know the correct name of the object
        reference in <computeroutput>.local</computeroutput>? Well, yes, but even that could be
        fixed - for example by providing a business-oriented instance reference such as Customer
        Number, and having some third party object handle the instantiation. </para>
  <para>An example of decoupling the three areas of concern is provided in the
          <computeroutput>Exercise03</computeroutput> folder. Try running
          <computeroutput>Startup.rex</computeroutput>. It behaves exactly as
          <computeroutput>Wow3.rex</computeroutput> does. However, the code is now structured into
        four *.rex files: <computeroutput>Startup</computeroutput>,
          <computeroutput>WowView</computeroutput>, <computeroutput>WowModel</computeroutput>, and
          <computeroutput>WowData</computeroutput>. The code in
          <computeroutput>Startup.rex</computeroutput> is very simple: <programlisting>
    <![CDATA[
    .local~my.idWowData = .WowData~new
    .local~my.idWowPicker = .WowPicker~new
     dlg = .WowView~new

    .local~my.idWowData~activate
    .local~my.idWowPicker~activate
    dlg~activate

    ::REQUIRES "WowView.rex"
    ::REQUIRES "WowModel.rex"
    ::REQUIRES "WowData.rex"
    ]]>
  </programlisting>The first three statements create the three classes, with the ids of the
        first two being stored in <computeroutput>.local</computeroutput>. Creation of the dialog is
        done by the third statement (<computeroutput>dlg = .WowView~new</computeroutput>). The next
        three statements send an <emphasis role="italic">activate</emphasis> message to each of the
        three classes. This is because when dealing with complex applications with "main" classes,
        it is very useful to distinguish between two kinds of class setups: firstly the
        technical creation of a class (done by invoking the <emphasis role="italic">init</emphasis>
        method), and secondly the setup of various required application-related things (done by
        invoking an <emphasis role="italic">activate</emphasis> method. </para>
  <para>
  Notice that <computeroutput>WowView</computeroutput>'s
  <emphasis role="italic">init</emphasis>
  method returns to the caller. The <emphasis role='italic'>activate</emphasis> method, on the other hand,
  does not return until the dialog is closed. This is because
  the statement that actually surfaces the dialog -
  <emphasis role="italic">self~execute("SHOWTOP", IDI_DLG_OOREXX)</emphasis> is the
  last statement in <computeroutput>WowView</computeroutput>'s
  <emphasis role="italic">activate</emphasis> method. And once the dialog is surfaced
  using <computeroutput>SHOWTOP</computeroutput>,
  control only returns to the application (that is, to <computeroutput>Startup.rex</computeroutput>)
  when the dialog is closed (although, as will be discussed later, there are ways
  to return control much sooner).
  </para>
  <para>But why move the <emphasis role="italic">self~execute("SHOWTOP"...</emphasis> statement into
        the <emphasis role="italic">activate</emphasis> method of the
          <computeroutput>MyDialog</computeroutput> class? After all, it would work just as well if
        it were the last statement in the Startup file. The reason is that the business of surfacing
        the dialog window is arguably not that of the application; rather it's the business of the
        dialog class. Thus the application is reduced as much as possible to a simple "kickoff"
        script, while the real work is done by the classes that are kicked off. </para>
  <para>There is, however, one important consequence of this move. Since the
          <emphasis role="italic">self~execute("SHOWTOP"...)</emphasis> statement does not return
        until the dialog is closed, the method blocks on this statement, and there is potential for
        a hang. In <computeroutput>Wow3.rex</computeroutput>, this statement was at the end of the
        "application" part of the program, and as there was nothing after it, the block didn't
        matter. But refactoring the classes into different files has moved it to the <emphasis
          role="italic">activate</emphasis> method of <computeroutput>WowView</computeroutput>. This
        introduces a concurrency issue. If not dealt with, then when the user clicks the <emphasis
          role="italic">More wisdom</emphasis> button, the <emphasis role="italic"
          >okClicked</emphasis> method can not run until the <emphasis role="italic"
          >activate</emphasis> method ends - that is, until the user closes the dialog window - a
        real catch 22, where the result is that no words of wisdom will appear. </para>
  <para>
  The reason <computeroutput>WowView</computeroutput> works is because its
  <emphasis role="italic">activate</emphasis> method
  has the <emphasis role="italic">unguarded</emphasis> option specified on its
  method statement. Try commenting "UNGUARDED" out and running the exercise without it.
  </para>
  <para> As a general rule, event handling methods such as <emphasis role="italic"
    >okClicked</emphasis> should be unguarded. Indeed, <computeroutput>WowView</computeroutput> runs happily if the "unguarded"
        option is moved to the <emphasis role="italic">okClicked</emphasis> method statement - or
        indeed if it's on both method statements. </para>
  <para>
  In the next chapter, we leave "words of wisdom", and start building a more realistic application.
  </para>
</section>

</chapter>
