<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog User Guide XML file.
    #
    # Copyright (c) 2011-2012 Rexx Language Association. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<!-- Chapter05 - Using Binary Resource Dialogs	               	  v00-07 25Jan12
     5.1 - Dialog Initiation - using the newInstance class method.
     5.2 - Compiling a binary resource file
     5.3 - Differences between RcDialog and ResDialog
     5.4 - New controls (radio buttons, menu items with underscores, ... )
     5.5 - New Structures
     5.6 - Dialog Design

     Changes:
     v00-01: First version
     v00-02 08Aug11: Completed the chapter.
     v00-03 13Aug11: Minor mods after pdf printed.
     v00-04 15Aug11: Corrected error - modal because of ~execute, not 'showtop'.
     v00-05 17Aug11: Updated to reflect change to using .application~setdefaults.
     v00-06 29Nov11: Updated to discuss disabling close (or doing something to
                     over-ride normal Windows behaviour).
     v00-07 25Jan12: Minor corrections to wording after proof-read.
-->
<chapter id="chapFive">
    <title>Using Binary Resource Dialogs</title>
    <indexterm>
      <primary>Binary Resource Dialogs</primary>
    </indexterm>
    <indexterm>
      <primary>ProductView component</primary>
    </indexterm>
    <indexterm>
      <primary>ResDialog</primary>
    </indexterm>
    <para>This chapter uses a "Product View" class as the context for discussing several topics:
      first, dialog initiation, second the use of binary resource file (that is, *.dll files) and
      the differences in using binary resource files as opposed to script resource files, third
      several dialog controls not used in previous exercises, fourth some changes to program
      structure, and fifth a brief visit to some dialog design considerations. </para>
    <para>First, run <computeroutput>Startup.rex</computeroutput> in the
        <computeroutput>Exercise05</computeroutput> folder. A ProductView dialog appears. Check out
      the behavior of the dialog - there are several new behaviors compared to
        <computeroutput>CustomerView</computeroutput>. In particular, aside from controls not used
      in previous exercises, the behavior includes more realistic application-level edit checks -
      that is, implementation of some (fairly trivial) "business rules". </para>
  <section id="chap05-initdialog">
      <title>Dialog Initiation</title>
      <!-- section 5.1 -->
      <para>Previous exercise have used either the "application" or "startup" program, or a separate
        ooRexx routine, for dialog initiation. By "initiation" is meant the two statements
          "<computeroutput>dlg=.[DialogClassName]~new</computeroutput>" and
          "<computeroutput>dlg~execute(...)</computeroutput>". In other words, the responsibility
        for issuing these two initiation statements - which handle the technical creation and
        initial display of the dialog - have been outside the dialog class. If they could be moved
          <emphasis role="italic">within</emphasis> the class, then encapsulation would be enhanced
        - always a desirable thing. The question is, how. Well, ooRexx has a mature implementation
        of OO that (among other things) allows for class methods (as opposed to instance methods).
        Using this feature of ooRexx, the initiation statements can be quite happily moved into a
        class method. Thus the <computeroutput>ProductView</computeroutput> class has a method
        called <emphasis role="italic">newInstance</emphasis> which, with comments and "say"
        instructions removed, is as follows: <programlisting>
<![CDATA[
  ::METHOD newInstance CLASS PUBLIC UNGUARDED
    .Application~setDefaults("O", "ProductView.h", .false)
    dlg = .ProductView~new("res\ProductView.dll", IDD_PRODUCT_VIEW)
    dlg~activate
]]>
  </programlisting>The newInstance method is invoked from
          <computeroutput>Startup.rex</computeroutput> by the statement
          <computeroutput>.ProductView~newInstance</computeroutput>. So all knowledge about
        initiating a dialog is moved inside that dialog's class, and from now on this approach will
        be used. <indexterm>
          <primary>newInstance</primary>
          <secondary>Class method</secondary>
        </indexterm>
        <indexterm>
          <primary>Class methods</primary>
          <secondary>newInstance</secondary>
        </indexterm> Note also that the first parameter of the
          <computeroutput>.ProductView~new()</computeroutput> statement allows file paths. </para>
    </section>
    <!-- End of section 5.1 -->
  <section id="chap05-resfile">
      <title>Using a Binary Resource File</title>
      <!-- section 5.2 -->
      <indexterm>
        <primary>Binary resource files</primary>
      </indexterm>
      <indexterm>
        <primary>Resource file</primary>
        <secondary>Binary</secondary>
      </indexterm>
      <indexterm>
        <primary>Resource file</primary>
        <secondary>Compiling</secondary>
      </indexterm>
      <section>
        <title>Compilation</title>
        <!-- section 5.2.1 -->
        <para>ooDialog's <computeroutput>ResDialog</computeroutput> class (a subclass of
            <computeroutput>UserDialog</computeroutput>) requires a resource-only DLL. A
          resource-only DLL is a resource script (*.rc) file that has been compiled into binary (or
          *.dll) format. Most resource editors have this function. ResEdit is capable compiling a
          *.rc file, but with three caveats: <itemizedlist>
            <listitem>
              <para>It must be done from the command line:</para>
              <para><computeroutput>resedit -convert filename.rc
                filename.dll</computeroutput></para>
            </listitem>
            <listitem>
              <para>It only works (at the time of writing) for 32-bit DLLs - that is, you need to be
                on a 32-bit system.</para>
            </listitem>
            <listitem>
              <para>At compile time, the *.h file and any *.bmp files must be in the same directory
                as the .rc file. If present and referenced by the .rc file, *.bmp and *.ico files
                are compiled into the DLL. </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>At run-time, a ResDialog class needs only the *.dll the *.h files.
        <indexterm><primary>Resource files</primary><secondary>ResDialog</secondary></indexterm>
        <indexterm><primary>ResDialog</primary><secondary>Resource files needed</secondary></indexterm>
        </para>
      </section>
      <!-- End of section 5.2.1 -->
      <section>
        <title>Differences between RcDialog and ResDialog</title>
        <!-- section 5.2.2 -->
        <para>The Exercise05 folder contains a Product View component, the main class
            <computeroutput>ProductView</computeroutput> being a subclass of the ooDialog
            <computeroutput>ResDialog</computeroutput> class. The difference between
            <computeroutput>ResDialog</computeroutput> and <computeroutput>RcDialog</computeroutput>
          is mainly in the handling of the menubar. Console outputs from
            <computeroutput>CustomerView</computeroutput> (an
            <computeroutput>RcDialog</computeroutput> subclass) and ProductView (a
            <computeroutput>ResDialog</computeroutput> subclass) are as follows: <programlisting>
    <![CDATA[
CustomerView                                        ProductView

D:\...\Exercise04>startup                           D:\...\Exercise05>startup
StartCustomerView Routine-01: Start.                .ProductView-newInstance-01: Start.
CustomerView-init-01.                               ProductView-init-01.
CustomerView-initAutoDetection-01.                  ProductView-initAutoDetection-01.
CustomerView-createMenuBar-01.
StartCustomerView Routine-02: dlg~activate.         ProductView-newInstance-02: dlg~Activate.
CustomerView-activate-01.                           ProductView-activate-01.
CustomerView-initDialog-01.                         ProductView-initDialog-01
]]>
  </programlisting> There are two visible differences. First, as discussed above, instead of
          creating the <computeroutput>ProductView</computeroutput> instance in a routine, as was
          the case for CustomerView, the startup file invokes a class method - <emphasis
            role="italic">newInstance</emphasis> which does much the same as CustomerView's routine. </para>
        <para>The second difference is the absence of a <emphasis role="italic"
            >createMenuBar</emphasis> method. Now this method was not strictly necessary in
            <computeroutput>CustomerView</computeroutput> - the menu could have been created in the
            <emphasis role="italic">init</emphasis> method. The real difference is that in an
          RcDialog, the menu is created <emphasis role="underline">before</emphasis>
          <emphasis role="italic">initDialog</emphasis> is called, but is "attached" to the dialog
          in that method. In a <computeroutput>ResDialog</computeroutput> class, the menu is both
          created and attached in the <emphasis role="italic">initDialog</emphasis> method by the
          single statement: <computeroutput>menuBar=.BinaryMenuBar~new(...)</computeroutput>. </para>
        <para>A third and less visible difference is that when a dialog has multiple resources such
          as bitmaps and/or icons, the number of files required for an RcDialog class can result in
          a minor file management challenge in the runtime environment. A ResDialog class, on the
          other hand, has only two files: the *.dll and the *.h. </para>
      </section>
      <!-- End of section 5.2.2 -->
    </section>
    <!-- End of section 5.2 -->
    <section>
      <title>Dialog Controls</title>
      <!-- section 5.3 -->
      <para>There are four features of <computeroutput>ProductView</computeroutput>'s controls that
        have not yet been introduced in this Guide. They are: radio buttons, a numeric-only edit
        field, menu accelerators, and an image control (in the "About" dialog). </para>
      <section>
        <title>Radiobuttons</title>
        <!-- section 5.3.1 -->
        <indexterm>
          <primary>Radio Button</primary>
        </indexterm>
        <indexterm>
          <primary>Controls</primary>
          <secondary>RadioButton</secondary>
        </indexterm>
        <para> For Radio Buttons to operate automatically - that is, when an "off" button is
          clicked, the "on" button goes off - they must be within a Group Box. This is defined in
          the *.rc file first as a GROUPBOX control with the style WS_GROUP. After this is defined,
          the radio buttons, which must have the AUTORADIOBUTTON style, are placed in the groupbox.
          However, the containment is done through the order of controls in the *.rc file. To
          achieve this using ResEdit, first drag a Group Box control onto the dialog, and set the
          "Group" property to "True". Then drag the radio buttons from the controls palette into the
          group box. Finally, and importantly, set the "Auto" behavior of each radio button to
          "True" (this sets its style in the *rc file to AUTORADIOBUTTON rather than just
          RADIOBUTTON). For a single group, it is not necessary to set the "Group" property to
          "True". However, if there are two or more independent group boxes, then it <emphasis
            role="italic">is</emphasis> required in order to differentiate between the groups. </para>
        <para>When initially displayed, no radiobuttons are "on". In the Product View, radiobuttons
          show whether the size of the product is small, medium or large. Since size is an attribute
          of the particular product being displayed (i.e. it's a field in the data that was
          supposedly read from some database), the correct radiobutton must be turned on. This is
          done in the <emphasis role="italic">showData</emphasis> method. </para>
      </section>
      <!-- end of section 5.3.1 -->
      <section id="chap05-numedit">
        <title>The Numeric Edit Control</title>
        <!-- section 5.3.2 -->
        <para>If you haven't tried entering an invalid number into the List Price or UOM fields of
          Product View, then try it. You'll find that keying a non-digit (including "-" or "+") or
          more that two decimal digits in the Price field (or any decimals in the UOM field) will
          result in a warning balloon being displayed. This behavior is provided by a mixin class
          called <computeroutput>NumberOnlyEditEx.cls</computeroutput>, available from the ooDialog
          "Samples" folder and copied into this User Guide's
            <computeroutput>Exercises\Support</computeroutput> folder for convenience.
          <computeroutput>NumberOnlyEditEx</computeroutput> illustrates how a control can be extended
          through ooRexx's mixin
          capability. The mixin is applied when <computeroutput>NumberOnlyEditEx</computeroutput>
          is "::required" - its first executable statement being:
          <emphasis role="italic">.Edit~inherit(.NumberOnlyEditEx, .EditControl)</emphasis>,
          with "Edit" being the name of ooDialog's Edit Control class. </para>
        <para>Briefly, numeric-only edit controls are set up as follows (full details are in
          the comments at the front of the <computeroutput>NumberOnlyEditEx.cls</computeroutput> file):
          <orderedlist>
            <listitem>
              <para>Specify <computeroutput>::requires
                  "..\Support\NumberOnlyEditEx.cls"</computeroutput> at the top of the dialog class
                file.</para>
            </listitem>
            <listitem>
              <para>Initialize the edit control (the one that's to be restricted to numeric-only entry) in the
                <emphasis role="italic">initDialog</emphasis>
                method by invoking the mixin's <emphasis role="italic">initDecimalOnly</emphasis>
                method on the control instance. In <computeroutput>ProductView</computeroutput> this
                is done for the product price control by this statement:</para>
              <para><computeroutput>
                  prodControls[ecProdPrice]~initDecimalOnly(2,.false)</computeroutput></para>
              <para>The first parameter of <emphasis role="italic">initDecimalOnly</emphasis>
                defines the allowable number of decimal places, the second whether or not a sign is
                allowed. As in <computeroutput>CustomerView</computeroutput> the controls are
                grouped in the directory object <emphasis role="italic">prodControls</emphasis> for
                ease of "exposing" them across methods; also, edit
                control instances have the prefix "ec" in conformance with the
                <link linkend="chap04-convs-names">naming standards</link> mentioned in Chapter 4.
              </para>
            </listitem>
            <listitem>
              <para>For each decimal-only edit control, a character event must be connected to an
                event handler method in the dialog object (ooDialog's edit control
                sends an event to the dialog when a character is entered). In
                  <computeroutput>ProductView</computeroutput>, this is done in the <emphasis
                  role="italic">initDialog</emphasis> method as follows:</para>
              <para><computeroutput>
                  prodControls[ecProdPrice]~connectCharEvent(onChar)</computeroutput></para>
            </listitem>
            <listitem>
              <para>Provide the event handler method. The event handler method <emphasis
                  role="italic">onChar</emphasis> in <computeroutput>ProductView</computeroutput> is
                as follows: <programlisting>
        <![CDATA[
          ::METHOD onChar UNGUARDED
            -- called for each character entered in the price or UOM fields.
            forward to (arg(6))
        ]]>
        </programlisting> The sixth argument to the event handler is the control object
                where the character event occurred, and the event must be forwarded to that object -
                that is, to the eventful edit control. The event is then handled by the mixin class,
                where the numeric-only editing is done. Note that other method names can be used.</para>
            </listitem>
          </orderedlist>
        </para>
      </section>
      <!-- end of section 5.3.2 -->
      <section id="chap05-accels">
        <title>Menu Accelerators</title>
        <!-- Section 5.3.3 -->
        <para>Open the Product View dialog, and then press the Alt key on the keyboard, followed by
          the down-arrow key. The "Actions" menu is first highlighted and then opened. The top menu
          item is "Update Product" - with an underscore
          beneath the "U". Pressing the "U" key will then initiate the Update Product behavior. The
          underlined letter is known as an "accelerator" key. It is produced by placing an ampersand
          (&amp;) immediately before the letter that's to be the accelerator key. In the
            <computeroutput>ProductView.rc</computeroutput> file, you'll see the Update menu item
          defined as <computeroutput>MENUITEM "&amp;Update Product",
            IDM_PROD_UPDATE</computeroutput>. </para>
        <para>Interestingly, if you mouse-click on the "Actions" menu to open it, the "U" is not
          underscored - although pressing the "U" key still initiates the update action. This is
          standard Windows behavior, and ooDialog does not change it (although some third-party
          Windows apps such as Adobe's Reader do preserve the underscore when a menu is
          mouse-opened). </para>
      </section>
      <!-- End of section 5.3.3 -->
      <section id="chap05-about">
        <title>The "About" Dialog</title>
        <!-- section 5.3.4 -->
        <para>Product View has a "Help" menu with one entry: "About...". Clicking this menu item
          surfaces a simple "about" dialog, containing an image of a well-wrapped product.
          Double-clicking the image results in a message box acknowledging the action. This section
          discusses firstly how the image is created, and second making the image "active". The code
          for the About dialog is the class <computeroutput>AboutDialog</computeroutput> towards the end of the
            <computeroutput>ProductView.rex</computeroutput> file.</para>
        <section id="chap05-imagecontrol">
          <title>Creating the Image</title>
          <!-- section 5.3.4.1 -->
          <para>An image is created by placing a bitmap (a file of type "*.bmp") into a "Picture
            Control". The bitmap and Picture control are both defined in the *.rc file, but placing
            the image into the picture control is done in code. </para>
          <section id="chap05-defimage">
            <title id="defimage.title">Defining the Image</title>
            <!-- section 5.3.4.1.1 -->
            <para>Assuming the bitmap image is already created as a bitmap file (a *.bmp file),
              then, using ResEdit, the *.rc file is created as follows (assuming you've already
              created a ResEdit project): <orderedlist>
                <listitem>
                  <para>Select File --> Add a resource... --> Bitmap. Two options are presented:
                    "create from an existing file", or "create a new resource". Click the former,
                    which results in a File Open dialog.</para>
                </listitem>
                <listitem>
                  <para>Select the bitmap file and click "Open". This produces a "Path designation"
                    messagebox with two options: "Absolute path" or "Relative path". It is usually
                    best to choose "relative path". On clicking "OK" ...</para>
                </listitem>
                <listitem>
                  <para>...a bitmap resource (called "IDB_BITMAP1" or some such) is added to the
                    project and the bitmap image is displayed. If you want to change the name, then
                    right-click on the bitmap in the Resources pane and select "Rename". Note that
                    the bitmap file is shown in the bitmap resource's "Path" property</para>
                </listitem>
                <listitem>
                  <para>Finally, drag a Picture Control from the controls palette and place it in
                    the dialog. Then change the Picture Control's "Notify", "Type", and "RealSizeControl"
                    attributes to "True", "Bitmap" and "True" respectively. These attributes define
                    the "styles" of the control to (respectively) issuing a mouse event, allowing a file
                    of type "bmp" to be displayed, and fitting the
                    bitmap to the space available.</para>
                  <para>It's worth mentioning that the Picture Control is one of four types of
                    Static Control - text, graphics, image, and owner-drawn. In the *.rc file, these
                    are defined by their "styles". A "style" is an essential and basic concept in
                    Windows. While many styles are shown in the ooDialog Reference, the full
                    authoritative list of styles is found in the <ulink
                      url="http://msdn.microsoft.com/en-us/library/bb773169%28v=VS.85%29.aspx">
                      <citetitle>Microsoft Control Library</citetitle></ulink>. Look up the Static
                    Control, and you'll find some thirty different styles. <indexterm>
                      <primary>Controls</primary>
                      <secondary>Styles</secondary>
                    </indexterm>
                    <indexterm>
                      <primary>Styles</primary>
                      <secondary>Controls</secondary>
                    </indexterm>
                    <indexterm>
                      <primary>Microsoft</primary>
                      <secondary>Controls Library</secondary>
                    </indexterm>
                    <indexterm>
                      <primary>Controls Library</primary>
                    </indexterm>
                  </para>
                </listitem>
              </orderedlist>
            </para>
          </section>
          <!-- end of section 5.3.4.1.1 -->
          <section>
            <title>Mapping an Image to a Picture Control</title>
            <!-- section 5.3.4.1.2 -->
            <para>As mentioned above, the image (of a parcel) displayed in the About dialog is
              referenced in the *.rc file, and hence is referenced in the *.dll file. What now needs
              to happen is to associate the image with the static control that will contain it. This
              is done in the dialog's <emphasis role="italic">initDialog</emphasis> method as
              follows: <programlisting>
      <![CDATA[
        resImage = .ResourceImage~new( "", self)
        image = resImage~getImage(IDB_PROD_ICON)
        stImage = self~newStatic(IDC_PRODABT_ICON_PLACE)~setImage(image)
      ]]>
    </programlisting> The first statement creates an instance of the
                <computeroutput>ResourceImage</computeroutput> class (see ooDialog Reference chapter
              26.4). The second statement uses the ResourceImages's <emphasis role="italic"
                >getImage</emphasis> method (see ooDialog Reference 26.2.4) to return an instance of
              the <computeroutput>Image</computeroutput> class. The last statement creates a static
              control and sets the image in it. </para>
          </section>
          <!-- end of section 5.3.4.1.2 -->
        </section>
        <!-- End of section 5.3.4.1 -->
        <section>
          <title>Making the Image "Active"</title>
          <!-- Section 5.3.4.2 -->
          <para>Making the image respond to mouse clicks is merely a matter of defining the
            image-static control in the *.rc file as having the style "SS_NOTIFY" which, using
            ResEdit (and as mentioned in <xref linkend="chap05-defimage">), merely requires the
            "Notify" attribute to be set to "True". When the image is double-clicked, the dialog is
            sent an event. This event is connected to the
            <emphasis role="italic">showMsgBox</emphasis> method by the statement
            <emphasis role="italic">self~connectStaticNotify( ... showMsgBox)</emphasis> (see ooDialog Reference 3.7.16).
            The <emphasis role="italic">showMsgBox</emphasis> method then displays a messagebox. </para>
          <para>You may notice the <emphasis role="italic">leaving</emphasis> method. <indexterm>
              <primary>leaving</primary>
              <secondary>method</secondary>
            </indexterm>
            <indexterm>
              <primary>methods</primary>
              <secondary>leaving</secondary>
            </indexterm> This is invoked automatically when the underlying Windows dialog is being
            closed (see ooDialog Reference 3.8.5). Its purpose is to allow for clean-up. In the case
            of the About dialog, the two resources used (an image and a font) are let go. This is
            not really necessary in this simple application, but is a good habit to get into (see
            the discussion at the end of section 26.2 of the ooDialog reference).</para>
        </section>
        <!-- End of section 5.3.4.2 -->
      </section>
      <!-- End of section 5.3.4 -->
    </section>
    <!-- End of section 5.3 -->

<section><title>Code Structure</title>  <!-- section 5.4 -->
<para>Although broadly similar to the code structure in Exercise04, Exercise05
  introduces several new structural concepts (at least new in this Guide). These are: the use of "data
  types", differentiation between view data and application data, more than one dialog in a file,
  externalized strings, and a more complex dialog design. Finally, there is a brief discussion on closing dialogs.</para>

<section><title>Data Types</title>  <!-- Section 5.4.1 -->
<para>Most non-trivial software systems consist of a number of components.
  Each of these could in principle be written in a different programming language - assuming of course that all
  the languages support common invocation mechanisms. Within each component there are typically some number of
  classes, and these interact privately. Between components, which often interact with "data-heavy" invocations,
  it is usual to define specific "data-only" classes, so that everyone can be sure of using the same data structures.
  Examples are: a Customer data class, an Address data class, and a SalesOrder data class.
  Such classes are often referred to as "types" (which in some quarters is a synonym for class).
</para>
<para>Our sample Sales Order application conforms with this idea, and so a number of "data types"
      will be introduced. In Exercise05, the Product Datatype (the class <computeroutput>ProductDT</computeroutput>
  at the end of the <computeroutput>ProductModelData.rex</computeroutput> file)
  specifies the attributes or fields required to fully define product data.
  This class needs no methods, since the data elements of <computeroutput>ProductDT</computeroutput>
  are defined as ooRexx attributes. Indeed, the single method in this class is merely a convenience
  method that lists the contents of a <computeroutput>ProductDT</computeroutput> instance on the
  console. This method is used (for illustration purposes only) in <computeroutput>ProductView</computeroutput>
  at the end of the <emphasis role="italic">saveChanges</emphasis> method. </para>
</section>  <!-- End of section 5.4.1 -->

<section><title>View Data vs Application data</title>  <!-- Section 5.4.2 -->
<para>There is often a difference between data that the user sees or enters on a dialog and the data
          that flows between components in data types. This is similar to the difference between
          data in a normalized database and data as used by application code. For example, on the
          Product View dialog, a price is shown with two decimal digits after a decimal point. Price in the
          <computeroutput>ProductDT</computeroutput> data type, on the other hand, has no decimal places
          - it's expressed in units of 1/100s of the currency unit (that is, in cents if the currency unit is
          the Dollar). Thus the price from the data type must be transformed somewhere for both display and
          user input purposes</para>
<para>The principle for where to do the transformation is simple: do it as close to the screen as
          possible (just as, at the other end, transformation to database formats are done as close
          to the DB programming interface (e.g. SQL) as possible, meaning that most of the
          application code across the system can use the same normative data formats.) Following
          this principle, the first thing the event handler method <emphasis role="italic"
            >saveChanges</emphasis> does is to invoke the dialog's method <emphasis role="italics"
            >xformView2App</emphasis> (transform view to app format). For example, price data may
          have been entered with one or no decimal digits. Conversely, reformatting for display is
          handled in the <emphasis>showData</emphasis> method. The end result is that all other
          methods in <computeroutput>ProductView</computeroutput> can assume that data is in the
          format defined by the data type. And this simplifies things a great deal - especially
          given that one never wants to confuse 10000 for ten thousand dollars when it's really 100! </para>
</section>  <!-- End of section 5.4.2 -->

<section><title>Multiple Dialogs per File</title>  <!-- Section 5.4.3 -->
<para>The file <computeroutput>ProductView.rex</computeroutput> contains two dialogs - the
  main <computeroutput>ProductView</computeroutput> class and the
  <computeroutput>AboutDialog</computeroutput> class.
  Note that the resources for both dialogs are defined in the
      same ResEdit project, and hence in the same *.rc file. Hence both are compiled into the
      <computeroutput>ProductView.dll</computeroutput> file. This means that the single statement
      <computeroutput>.Application~setDefaults("O","ProductView.h",.false)</computeroutput> in
      the <emphasis role="italic">newInstance</emphasis> method of the
      <computeroutput>ProductView</computeroutput> class applies to the
      <computeroutput>About</computeroutput> dialog as well.
</para>
<para>You may notice that the "About" dialog launched in <computeroutput>ProductView</computeroutput>'s
  <emphasis role="italic">about</emphasis> method is modal. That is, the Product View window cannot be
  accessed while the About window is open. This is because "About"
  was launched using the <emphasis role='italic'>execute(..)</emphasis> method. Making an "about
  box" modal seems quite reasonable. But in later chapters some of ooDialog's alternatives to
  <emphasis role='italic'>execute</emphasis> will be used in order to launch non-modal dialogs.
</para>
</section>  <!-- End of section 5.4.3 -->

<section><title>Externalized Strings</title>  <!-- Section 5.4.4 -->
  <para>It is generally deemed to be good practice to externalize any strings that are visible to
          the user. This enables someone who needs to translate the application for use by speakers
          of a different language to do so without touching any executable code. Providing such a
          facility is often called "internationalization" or "I18N" for short. While this Guide does
          not pretend to have addressed all I18N requirements, at least it indicates an
          understanding of the need. Thus the human-readable strings that appear in the
            <computeroutput>HRS</computeroutput> class ("HRS" = "Human-Readable Strings") at the end
          of the <computeroutput>ProductView.rex</computeroutput> file are used for messages in
          messageboxes. Other strings such as the static text on the dialogs, and text in the About
          dialog are hard-coded either in code or in the *.rc file (and hence in the *.dll file).
          While not good practice, this is done in the Exercises for code readability reasons - the
          alternative being to add more code to the dialogs. </para>
</section>  <!-- End of section 5.4.4 -->

<section><title>Dialog Design</title>  <!-- Section 5.4.5 -->
  <para>A program does only what its programmer specifies. But a user could do anything. This is why
          designing dialogs is often quite complicated. What could the user do? What must the dialog
          do? These are two questions that sometimes seem to intertwine in an irresolvable mess. In
            <computeroutput>ProductView</computeroutput>, the most complex piece of behavior is when
          the user chooses the <emphasis role="italic">update</emphasis> menu item. A useful way to
          plot the possible interactions is to use a UML Activity Diagram, with user actions on one
          side and the corresponding program actions on the other. The following figure shows one
          such diagram. </para>
  <figure id="fig0501"><title>ProductView Behavior Diagram</title>
    <mediaobject>
      <imageobject>
        <!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
        <imagedata fileref="Chapter05-image1.jpg" scale="50">
      </imageobject>
    </mediaobject>
  </figure>
        <para>The main thing this diagram illustrates is how the user can go in circles without
          affecting what the code needs to do. This is helped a great deal by providing a "refresh"
          function, so that if the user gets mixed up in entering data, s/he can go back to the
          beginning and start again. </para>
</section>  <!-- End of section 5.4.5 -->

<section id="chap05-dlgCancel"><title>Controlling Dialog Cancel</title>  <!-- Section 5.4.6 -->
<para>Windows provides for three ways for the user to cancel a dialog: by pressing the Esc key,
      by clicking on the "close" icon at the extreme top right of the dialog, or by clicking
      the "close" action on the system menu (click the icon at the extreme top left of the window).
      All three of these actions result in a "cancel" message being sent to the dialog code, and
      the default superclass behavior is silently to close the dialog (see ooDialog Reference 3.8.2).
      In general, since these default
      actions are standard for all Windows dialogs, they should not be over-ridden except perhaps
      to display an "are you sure?" message if, for example, the user is half-way through some unit
      of work.
      </para>
      <para>The Product View code provides a simple illustration of this in that, depending on the
          state of the dialog, a modal "are you sure you want to exit" message is displayed.
          ProductView can be said to have three states, as illustrated by the UML state diagram
          below. In the diagram, ovals are states, and the lines between them are state transitions.
          A solid circle is the start, and a smaller solid circle with a ring around it is the end.  </para>
  <figure id="fig0502">
    <title>ProductView State Diagram</title>
    <mediaobject>
      <imageobject>
        <!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
        <imagedata fileref="Chapter05-image2.jpg" scale="70">
      </imageobject>
    </mediaobject>
  </figure>
        <para>The three states are as follows:
          <orderedlist>
            <listitem>
              <para>The first state is called "closable" - that is, not in the process of being
                updated. This state is in being when the value of the attribute
                <emphasis role="italic">dialogState</emphasis> (defined in the
                <computeroutput>::attribute</computeroutput> directive immediately after the
                <computeroutput>::class</computeroutput> directive) is "closable". </para>
            </listitem>
            <listitem>
              <para>The second state is called "in update" and is in being when the value of the
                <emphasis role="italic">dialogState</emphasis> attribute is "inUpdate". If the user
                selects any of the close actions in this state, then the third
                state is entered. The "InUpdate" state is terminated by the user selecting
                "refresh" or "save changes", either of which causes the dialog to return to the
                "Closable" state. </para>
            </listitem>
            <listitem>
              <para>The third state is the modal "exit messagebox" state which, depending on the user's
                choice, either closes the dialog or returns to the "inUpdate" state.
                If the user selects any of the close actions, then the dialog closes
                immediately. </para>
            </listitem>
          </orderedlist>
        </para>

</section>  <!-- End of section 5.4.6 -->

</section>   <!-- end of section 5.4 -->

</chapter>
