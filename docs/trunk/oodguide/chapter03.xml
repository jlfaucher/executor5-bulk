<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog User Guide XML file.
    #
    # Copyright (c) 2011-2011, Rexx Language Association. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->

<!-- Chapter03 version 00-03 -->

<chapter id="chapThree"><title>Re-Structuring the Code</title>
<indexterm><primary>code structure</primary></indexterm>
<para>
  Our current code is hopeless. It works - but only because it's so very simple.
  The problem is its design - its structure. There are three quite different concerns that must be separated:
  the UI including both presentation and user action; the data (in our case a set of text strings);
  and the "business". What's the "business" of this code? It's picking out (from the data) the
  particular text string to be displayed. In the next exercise, these concerns are separated,
  with no change as far as the user's concerned.
</para>
<para>
  The three areas of concern have a close relationship with the Model-View-Controller (MVC)
  concept (see
  <ulink url="http://en.wikipedia.org/wiki/model-view-controller"><citetitle>Model-View-Controler</citetitle></ulink>)
  The view is the UI, the text data is the model, and picking out which text to display is the controller.
  This model works well for PC-resident applications, but, by the way, does not easily scale to distributed systems, where
  some additional architectural concepts are required (see, for example,
  "Business Component Factory" by Peter Hurzum and Oliver Sims).
</para>
<para>
  You may ask if all three areas are necessary - can't randomly selecting a text string be part of
  the code handling the data - perhaps a method on a data or model class? A good question.
  But there's a useful architectural rule that says that model objects should have a CRUDLV interface.
  CRUDLV (pronounced "cruddlevee") stands for Create, Read, Update, Delete, List, Validate.
  And "Pick at random" is excluded - it's clearly different from a "get" or "read".
  Essentially, a model object (at least in my world view)
  knows where the data is, and makes it available.
  In our case, picking a text string at random is purely a consequence of what we
  want our <emphasis role="italic">application</emphasis> to do.
  Hence (without going into a perhaps esoteric architectural discussion) picking
  a string is in the "business" area of concern. Let's now look at the implementation
  of each of these three areas of concern. In the second part of this chapter,
  we'll further reduce coupling (the rule is: low/loose coupling, high cohesion).
</para>

<section id="chap03-struc"><title>Fixing the Structure</title><!-- section 3.1 -->
<para>
  First, re-run Excercise02a, and then run Exercise03a. To the user, they're identical.
  However, in Exercise03a the code has been re-structured
  so that there are now three different classes, each implementing one of the three
  areas of concern. We'll look at each class in turn, the
  <link linkend='fig0301'>figure</link> below providing a whiteboard-level picture of how the three
  classes interact to produce a "words of wisdom" on the GUI.   Now look at the code
  in Exercise03a. As illustrated in the <link linkend='fig0301'>figure</link>,
  it's split it into three classes: <computeroutput>MyDialog</computeroutput>,
  <computeroutput>WowPicker</computeroutput>, and <computeroutput>WowData</computeroutput>.
  "Wow" in the names is short for "words of wisdom".
  <figure id="fig0301"><title>Exercise03 Structure</title>
    <mediaobject>
      <imageobject>
        <!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
        <imagedata fileref="Exercise03-Image1.jpg" scale="70">
      </imageobject>
    </mediaobject>
  </figure>
</para>
</section>

<section id="chap03-struc-ui"><title>The UI Area of Concern</title><!-- section 3.1.1 -->
<para>
  Look at the <computeroutput>MyDialog</computeroutput> class which implements the UI area of concern.
  The <emphasis role="italic">init</emphasis> method
  is identical to that of Exercise02b except that it also creates an instance of
  <computeroutput>WowPicker</computeroutput> called (unsurprisingly)
  <emphasis role="italic">wowPicker</emphasis>". There's also an
  <emphasis role="italic">expose</emphasis> statement to make the
  <emphasis role="italic">wowPicker</emphasis> object available to other methods.
</para>
<para>
  The <emphasis role="italic">defineDialog</emphasis> method has not changed. But the
  <emphasis role="italic">okClicked</emphasis> method is different - and much shorter:
  <programlisting>
    <![CDATA[
    ::method okClicked
      expose wowPicker
      newText = self~newStatic(902)
      wow = wowPicker~pickWow
      newText~setText(wow)
      return
    ]]>
  </programlisting>
  To get the "words of wisdom" to display, it now merely asks
  <emphasis role="italic">wowPicker</emphasis> for a string to display.
</para>
<para>
  In summary, all knowledge of picking a string, and of the set from which to pick, has been
  exported elsewhere. The <computeroutput>MyDialog</computeroutput> class now addresses
  only the areas of GUI display and GUI interaction. This is crucially important. A good way
  to make a complex task hopelessly complicated is to mix "business" and "data" concerns into
  the "gui" concerns.
</para>
</section>

<section id="chap03-struc-bus"<title>The Business Area of Concern</title><!-- section 3.1.2 -->
<para>
  The class implementing the business area of concern - <computeroutput>WowPicker</computeroutput>
  - is very simple:
  <programlisting>
    <![CDATA[
    ::METHOD init
      expose arrWowSet
      dataSource = .WowData~new
      arrWowSet = dataSource~readWowSet
      return

    ::METHOD pickWow
      expose arrWowSet
      i = random(1,7)
      return arrWowSet[i]
    ]]>
  </programlisting>
  The <emphasis role="italic">init</emphasis> method gets a reference to an instance of
  the class <computeroutput>WowData</computeroutput> - which handles the data area of concern
  - and then gets a set of Words of Wisdom into the variable
  <emphasis role="italic">arrWowSet</emphasis> (of type array). Then in the method
  <emphasis role="italic">pickWow</emphasis> a Words of Wisdom string is picked randomly from
  <emphasis role="italic">arrWowSet</emphasis> and returned.
</para>
</section>
<section id="chap03-struc-dat"><title>The Data Area of Concern</title><!-- section 3.1.3 -->
<para>
  The last class in Exercise03a (<computeroutput>WowData</computeroutput>) is extremely simple.
  Its <emphasis role="italic">init</emphasis> method loads up an array of seven text strings
  into the instance variable <emphasis role="italic">arrWow</emphasis>, and returns that array to a
  caller in its <emphasis role="italic">readWowSet</emphasis> method.
  One can see how this it might be enhanced, for example by providing a method that renews
  the set of "words of wisdom" from a larger set in a disk file. But that is nothing
  to do with ooDialog, so we'll leave it as it is.
</para>
</section>
<section id="chap03-cplg"><title>Reducing Coupling</title><!-- section 3.2 -->
<para>
  The three classes in Exercise03a are reasonably decoupled: the dialog is in one class,
  the business logic (such as it is) in another, and the data in a third.
  Notice however that both <computeroutput>MyDialog</computeroutput> and <computeroutput>WowPicker></computeroutput>
  create a reference to another class (<computeroutput>WowPicker</computeroutput>
  and <computeroutput>WowData</computeroutput> respectively) in order to invoke them.
  Each of these three classes can be called a "main" class, since each is the main (and only!)
  class implementing a separate area of responsibility. In more complex situation, each area
  will have one main class and a number of subsidiary classes - for example, a (main) SalesOrder
  class with subsidiary OrderLine, OrderLines, CustomerDetail, and DeliveryInstructions classes.
</para>
<para>
  Now, when considering more complex applications, it is arguable that it is not the
  responsibility of any main classes to know about the creation of instances of other classes.
  Later we will see that each area of responsibility (GUI, business and data) will have a
  number of classes, each area having one main class. If these three areas are to be as
  independant as possible, then each should know as little as possible about the others.
  Such independence is usefully enhanced if a way is found to move the knowledge of how to
  get references to the main classes to a fourth area. And there is just such an area - the application.
  </para>
  <para>In ooDialog programs, there is often a block of code at the beginning of the
  program file that kicks off a dialog by instantiating an ooDialog class. From there,
  all the behavior is in the dialog classes. This "kick-off" block of code can be used to
  reduce coupling by pre-instantiating the main classes, and storing the
  object references in <computeroutput>.local</computeroutput>. Thus no main class
  has to know the name of any other main class. But, when a main class gets the object reference
  for another main class instance, does't the first class have to know the name used to store
  that reference in <computeroutput>.local</computeroutput>? Well, yes, but even that
  could be fixed - for example by providing the instance references as parameters
  in the <computeroutput>init</computeroutput> invocation. Indeed, one could go further,
  towards the goal of creating a "software component" from each main class plus its subsidiary
  classes. There is further to say on this subject, but not here, where our focus is on ooDialog.
  For this User Guide, the degree of decoupling provided by the <computeroutput>.local</computeroutput> approach will suffice.
  </para>
  <para>
  Exercise 03b illustrates this decoupling, and is found in the zip file
  <emphasis role="italic">Exercise03b.zip</emphasis>. Try running it. Extract the files and
  run the "application" file <emphasis role="italic">Exercise03b-app.rexx</emphasis>.
  Although its behavior is identical to <emphasis role="italic">Exercise02b.rexx</emphasis>,
  the code is now structured into four files. The code in
  <emphasis role="italic">Exercise03b-app.rexx</emphasis> is very simple, as follows:
  <programlisting>
    <![CDATA[
    .local~my.idWowPicker = .WowPicker~new
    .local~my.idWowData = .WowData~new
     dlg = .MyDialog~new

    .local~my.idWowPicker~activate
    .local~my.idWowData~activate
    dlg~activate				-- Must be the last statement.

    ::requires "ooDialog.cls"
    ::requires "exercise03b-gui.rex"
    ::requires "exercise03b-bus.rex"
    ::requires "exercise03b-dat.rex"
    ]]>
  </programlisting>
  The first three statements create the three classes, with the ids of the first two being
  stored in <computeroutput>.local</computeroutput>. Creation of the dialog is done by the
  the third statement (<computeroutput>dlg = .MyDialog~new</computeroutput>). The next three
  statements all send an <emphasis role="italic">activate</emphasis> message to each of the
  three classes. This is because when dealing with complex applications with "main" classes,
  it is very useful to distinguish between two distinct kinds of class setups: firstly the
  technical creation of a class (done by the <emphasis role="italic">init</emphasis> method),
  and secondly the setup of various application-related things that the class needs
  (done by an <emphasis role="italic">activate</emphasis> method.
  </para>
  <para>
  Note the comment on the sixth statement which invokes the dialog's
  <emphasis role="italic">activate</emphasis> method. It says "Must be the last statement".
  This is because the statement that actually surfaces the dialog -
  <emphasis role="italic">self~execute("SHOWTOP", IDI_DLG_OOREXX)</emphasis> is the last
  statement in <computeroutput>MyDialog</computeroutput>'s
  <emphasis role="italic">activate</emphasis> method. And once the dialog is surfaced,
  control never returns to the application (that is, to
  <emphasis role="italic">exercise03b-app.rex</emphasis>).
  </para>
  <para>
  But why move the <emphasis role="italic">self~execute("SHOWTOP"...</emphasis> statement
  into the <emphasis role="italic">activate</emphasis> method of the
  <computeroutput>MyDialog</computeroutput> class? After all, it would work just as well
  if it were the last statement in the app file. The reason is that the business of surfacing
  the dialog window is arguably not that of the application; rather it's the business of the
  dialog class. Thus the application is kept as a simple "kickoff" script, while the real work
  is done by the classes kicked off.
  </para>
  <para>
  There is, however, one important consequence of this move, and that is that, since the
  <emphasis role="italic">self~execute("SHOWTOP"...)</emphasis>
  statement does not return until the dialog is closed, the method blocks on this statement,
  and there is potential for a hang.
  In Exercise03a, this statement was at the end of the "application" part
  of the program, and as there was nothing after it, the block didn't matter.
  But Exercise03b has moved it to <emphasis role="italic">activate</emphasis> method of
  <computeroutput>MyDialog</computeroutput>. This introduces a concurrency issue. If not dealt with,
  then when the user clicks the <emphasis role="italic">More wisdom</emphasis> button, the
  <emphasis role="italic">okClicked</emphasis> method can not run until
  <emphasis role="italic">activate</emphasis> method ends. When it does end (when the user
  closes the window), the <emphasis role="italic">onClicked</emphasis> method runs -
  as many times as the the button was clicked. But the dialog has ended so the
  <emphasis role="italic">self~newStatic(902)</emphasis> statement returns
  <computeroutput>.nil</computeroutput>. The result is error messages on the console
  which look like this:
  <programlisting>
    <![CDATA[
    D:\...Exercises>exercise03b-app
        92 *-* newText~setText(wow)
    Error 97 running D:\...Exercises\Exercise03b-gui.rex line 92:  Object method not found
    Error 97.1:  Object "The NIL object" does not understand message "SETTEXT"
    ]]>
  </programlisting>
  </para>
  <para>
  The reason Exercise03b works is because the <emphasis role="italic">activate</emphasis> method
  (in <emphasis role="italic">Exercise03b-gui.rex</emphasis>) has the
  <emphasis role="italic">unguarded</emphasis> option specified on its method statement.
  Try commenting "unguarded" out and running the exercise without it. You'll experience a hang.
  <para>
  As a general rule, event handling methods such as <emphasis role="italic">okClicked</emphasis>
  should be unguarded. Indeed, Exercise03b runs happily if the "unguarded" option is moved to the
  <emphasis role="italic">okClicked</emphasis> method statement - or indeed (in this case)
  if it's on both method statements.
  </para>
  <para>
  In the next chapter, we leave this particular example, and start building a more realistic application.
  </para>
</section>

</chapter>
