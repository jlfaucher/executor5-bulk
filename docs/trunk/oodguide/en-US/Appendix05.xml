<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "oodguide.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog User Guide XML file.
    #
    # Copyright (c) 2012-2012, Rexx Language Association. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->

<!-- Appendix 05 - The Model-View Framework (MVf)		  v01-01 18Dec12
     A brief overview of the internals of the Model-View Framework (MVF).

     Changes:
     v01-01 18Dec12: First version.

     Notes:
     Include overview of ObjectMgr.

-->

<appendix id="apx-mvfinternals">
  <title id="mvfinternals.title">Model-View Framework Internals</title>
  <indexterm><primary>Model-View Framework</primary><secondary>Internals</secondary></indexterm>
  <para>This appendix provides an overview of the internals of the Model-View Framework
    (MVF) introduced in <xref linkend="chapSeven"/>. It should really be called "Model-View-Data Framework",
    since it also encompasses data components; however, historically such frameworks have
    ommitted the term "data" in their names, and here we lazily conform with history.</para>

  <para>*** Intro to sections here if required. *****</para>

  <!-- Section 1: The Object Manager -->
  <section id="app5ObjectMgr"><title>The Object Manager</title>
    <para>The Model-View Framework (MVF) manages the components that are assembled
    to make up an application. There are two main parts to the MVF:
    first a management object (an ooRexx class)
    called the "Object Manager", and secondly a set of superclasses that provide
    functions common to all components.
    A "component" is a Model, a View, or a Data program. An example is the "ProductView"
    component, which consists of three ooRexx classes: <computeroutput>ProductView</computeroutput>,
    <computeroutput>AboutDialog</computeroutput>, and <computeroutput>HRSpv</computeroutput>.</para>
  <para>
    This component, together with the Product List component, the ProductData component,
    and a Product datatype, make up a Product Data Business Component.
    For each component, one class is made known by name to ObjectMgr by name.
  </para>
  </section>

  <section>
  <para>
    <programlisting>
<![CDATA[
</programlisting>

     showModel(class-inst)  ->  ObjectMgr
     				self~getcreate model


     View components:		subclass RcView
     - newInstance [class method]:
         use arg modelInsanceName, rootDlg
         dlg = .ModelView~new(rc-file, "IDD_...")
         dlg~activate(modelInstancName,rootDlg)
         return dlg

     - activate
         expose modelData
         use arg modelInstanceName, rootDlg
         forward class (super) continue		 Required for MVF
         modelData = RESULT			- personData returned by super
    						- ('forward' returns any result via 'RESULT'.)
         self~popUpAsChild(rootDlg,"SHOWTOP,,icon-resource-id>)

     - initDialog
         expose modelData


     Model components:
     - newInstance (class method):
         use strict arg instanceName
         check id data component is up and running
         get component id of data component from objectMgr
         send "find(instanceName)" to data component - returns "dirData"
         modelId = self~new(dirData)
         return modelId

     - init (instance Method)
         - since no separate setup, 'activate' is same as 'init' so just use 'init'.

     Data components:				- subclassed from GenericFile
     - newInstance (class method):
         use strict arg instanceName		- instanceName is "The".
         dataId = self~new(instanceName)
         return dataId

     - init
         use arg instanceName
         filename = "file-name"; columns = num-columns
         records = self~init:super(fileName, columns)



     Some component X wants to send 'query' to PersonModel. So:
     (a) X sends getComponentId('PersonModel PA150') to ObjectMgr.
     (b) ObjMgr: if exists, then return cmptId
     (c) Else
     Sends 'query' to a PersonModel on Message Sender.
     Messagesender asks ObjectMgr for id of the PersonModel
     If not in object bag, ObjMgr sends 'newInstance' to Model with inst name
     as param.
     .Model~newInstance asks ObjMgr for id for "PersonData The"
     If not found, then set noDataError to .true.
     Else do
       send a "find" to "PersonData The"
       "PersonData The" returns the Model's instance's data.
       If data found, then id = .PersonModel~new(data)
       Return Id (to ObjectMgr)
     end
]]>
    </programlisting>
</para>
  </section>

  <section>The "Requires List"</section>
  <para>To be completed.</para>
</appendix>

































