<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"[
<!ENTITY % BOOK_ENTITIES SYSTEM "oodguide.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog User Guide XML file
    #
    # Copyright (c) 2013-2013 Rexx Language Association. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->

<!-- Chapter07 - A Working Application		 		  v01-00 06Feb13

    Changes:
     v01-00 06Feb13: First version.

    7   *  Towards A Working Application	                                          chapSeven
    7.1   * Introduction                                                              chap07-intro
    7.2   * A 'Model-View Framework'                                                  chap07-mvf
    7.2.1   * Objectives		                                                          chap07-mvf-objs
              - What has to happen to open dialog (get data etc.)
              - Try PersonModel (use MsgSender - more detail later) and Wow4
              - Look at code.
              - now look at OrderMgr - how dialogs now opened.
    7.2.2   * MVF Overview                                                            chap07-mvf-oview
              - Consists of superclasses (Model, View and GenericFile)
                and "manager" objects.
    7.2.2.1   * An Example - The Person Component                                     chap07-mvf-oview-person
    7.2.2.2   * ObjectMgr - Overview only - see appendix 5 for details.               chap07-mvf-oview-objmgr
                Summary of methods used
                - list - Lists a file on the console.
    7.2.2.3   * Model                                                                 chap07-mvf-oview-model
    7.2.2.4   * View                                                                  chap07-mvf-oview-view
                - offsetting: use MsgSender (refer to section 7.3 for more details)
                  e.g. PersonModel - must set Visible = False in resEdit else get a
                  flicker - try it - add WS_VISIBLE to .rc file (default is FALSE)
                  then re-open. Watch the flicker as it moves from default position
                  to offset position. (Note - not used for other dialogs)
                  (Note - it offsets relative to MsgSender - check out why!)
    7.2.2.5   * Data                                                                  chap07-mvf-oview-data
                - Data components are subclassed from GenericFile
                  (in Support file 'genericfile.rex').
                - Data formats
    7.3   * Using the MVF                                                             chap07-mvfuse
    7.3.1     Diff kinds of component; how different kinds use MVF.                   chap07-mvfuse-kinds
                - Anonymous and Singleton Components
                - also Wow4 - shows how MVF can be used when doesn't conform
                   with entity or list.
    7.3.2     Data formats - standard data formats - getRecord,                       chap07-mvf-datafmts
                  getFile on Data component
                - different for Order since have to compose data from two files
                  (no DBMS!)
                - Order Data - two files, OrderHeadersFile.txt and OrderLinesFile.txt
                  The OrderData component merges the two (??)
    7.4     Message Sender - get rid of "stand-alone" testing code.                   chap07-msgsender
    7.5     The Order Form -                                                          chap07-orderform
    7.6     Next Version                                                              chap07-next
            - Say this app not completed - e.g. query method not in super, OrderForm not complete, etc.
            Things to add:
            - drag/drop
            - Complete the OrderForm
            - Dialog offsetting
-->

<chapter id="chapSeven"><title>Towards A Working Application</title>

<section id="chap07-intro"><title>Introduction</title>  <!-- Section 7.1 -->
    <para>This chapter, and the accompanying Exercise, provides much of the infrastructure of an
            application that uses model-view-data component concepts. </para>
  <para> Open the <computeroutput>Exercise07</computeroutput> folder and start the Order Management
      application by double-clicking on <computeroutput>startup.rex</computeroutput>. Try it out.
      Explore the function which, while not complete, is much more so than in the previous exercise. In
      particular, note that application data is now read from files. For example, the Customer data
      is read from the file <computeroutput>CustomerFile.txt</computeroutput>. However, although the
      data can be changed in dialogs, the changed data does not (in this exercise) update the files. </para>
        <para>Also, note that the <emphasis role="bold">Help</emphasis> menu on the main Sales Order
      Management dialog now includes an option <emphasis role="bold">Message Sender</emphasis>
      (discussed in more detail in <xref linkend="ch7-msgsender.title"/>. Click this option and a
      "Message Sender" dialog opens. This sends messages to (invoke methods on) the various
      components, and is a very useful debugging tool that replaces the "stand-alone" function used
      in the previous exercise. For example, try sending a "query" message to the Customer whose key
      is BA0314. To do this, key <emphasis role="bold"><emphasis role="italic">CustomerModel
          BA0314</emphasis></emphasis> in the <emphasis role="bold">Target</emphasis> field ,
        <emphasis role="bold"><emphasis role="italic">query</emphasis></emphasis> in the <emphasis
        role="bold">Method</emphasis> field, and then press <emphasis role="bold">Send</emphasis>.
      The customer's data is returned in the <emphasis role="bold">Reply</emphasis> field as a
      name-value string. </para>
        <para>Now try using the Message Sender to surface a Product dialog - say the view for
      Product CU003. To do this, select <emphasis role="bold">ObjectMgr The</emphasis> in the
        <emphasis role="bold">Target</emphasis> combo-box pull-down, <emphasis role="bold"
        >showModel</emphasis> in the <emphasis role="bold">Method</emphasis> field, and type
        <emphasis role="bold"><emphasis role="italic">ProductModel CU003</emphasis></emphasis> in
      the <emphasis role="bold">Data</emphasis> field. Now press <emphasis role="bold"
        >Send</emphasis>. The Product dialog for instance CU003 appears. </para>
        <para>The "Object Manager" (which should really be called "ComponentManager" since it
      manages application components as opposed to any old ooRexx object) is a support class that
      instantiates components by invoking a component's <emphasis role="bold">newInstance</emphasis>
      class method. It also keeps track of which components are already instantiated. For more
      detail see <xref linkend="chap07-mvf-oview-objmgr"/></para>
        <para>Consider now what has to happen to display a Product View. First, a
        <computeroutput>ProductData</computeroutput> instance must be created, and its data is read
      from disk. Then the appropriate <computeroutput>ProductModel</computeroutput> component is
      instantiated and its data retrieved from the <computeroutput>ProductData</computeroutput>
      component. Finally, an instance of <computeroutput>ProductView</computeroutput> is created and
      its data retrieved from the <computeroutput>ProductModel</computeroutput> component by
      invoking its <computeroutput>query</computeroutput> method. </para>
        <para>This sequence is a pattern that can be applied to most business components, and hence
      can be handled by superclasses so that the application components do not have to provide the
      same duplicated code. The pattern is called the "Model-View Framework", which is discussed in
      the next section.  </para>
</section>     <!-- End of Section 7.1 -->

<section id="chap07-mvf"><title id="ch7-mvf.title">A Model-View Framework</title>		<!-- Section 7.2 -->
  <para>This section presents the externals of the MVF. For a discussion of the internals of the
    MVF, see <xref linkend="apx5-mvf.title"/>.</para>
  
  <section id="chap07-mvf-objs"><title id="ch7-mvf-objs.title">MVF Objective</title>		<!-- Section 7.2.1 -->
  <para>The objective of the Model-View Framework (MVF) is to provide a mechanism whereby
        application components can read and write data and display views without needing to be aware
        of <emphasis role="italic">how</emphasis> this is done. Thus the MVF supports
        view-model-data separation of concerns in application-level components. The MVF comprises
        three superclasses for application components called <computeroutput>Model</computeroutput>,
          <computeroutput>View</computeroutput>, and <computeroutput>GenericFile</computeroutput>
        (the latter for data components), plus two "manager" objects:
          <computeroutput>ObjectMgr</computeroutput>' and
        <computeroutput>ViewMgr</computeroutput>.</para>
  <para>When a user double-clicks on an item in say the Customer List dialog, the confident
    expectation is that a Customer dialog that shows the data associated with the list
    item will be displayed. Now consider what has to happen to make that product dialog
    appear:</para>
    <orderedlist>
    <listitem><para>Create the appropriate data component, which...</para></listitem>
    <listitem><para>... opens the correct file and reads the data.</para></listitem>
    <listitem><para>Create the model component and provide it with its "key" (e.g. customer number).</para></listitem>
    <listitem><para>In the model component, get a reference to the data component.</para></listitem>
    <listitem><para>Invoke a method on the data component to retrieve the data associated with
      the model's key.</para></listitem>
    <listitem><para>Create a view component.</para></listitem>
    <listitem><para>Provide that view component with the data to be displayed in its dialog.</para></listitem>
    <listitem><para>Make the dialog visible.</para></listitem>
    </orderedlist>
  <para>This sequence set of actions assumes that none of the component instances involved are yet
    activated. However, the MVF must also work when some or all are activated. For example,
    if a Customer dialog exists but is minimized, and the user double-clicks on that customer
    in a Customer List dialog, then
    the MVF need only surface the Customer dialog. Thus the MVF distinguishes between a
    number of different states, and relieves the programmer from having to code the
    logic for each component and for each possible state. </para>
  <para>Consider, for example, the code in <computeroutput>OrderMgrView</computeroutput> that
        launches a List View. On the left is the Exercise 6 code, and on the right is the Exercise 7
        code (equivalent or identical statements have been placed on the same line for comparison). <programlisting>
<![CDATA[ 
                                  OrderMgrView
  Exercise 6                                             Exercise 7
  ----------                                             ----------
::METHOD showModel UNGUARDED                            ::METHOD showModel UNGUARDED
                                                          expose idObjectMgr
  use arg record                                          use arg record
  className = record~ID                                   className = record~ID
  viewClassName = className||"View"
  interpret "."||viewClassName||"~newInstance(self)"      r = idObjectMgr~showModel(classname, "a", self)
]]>
    </programlisting> The key difference is that in Exercise 6 the Customer List is launched
        without any concern for the data - because the data is hard-coded in the List View. In
        Exercise 7, on the other hand, the data is read from disk and provided to the List View.
        This is done by the <computeroutput>showModel</computeroutput> method of an MVF component
        called the "Object Manager" (<computeroutput>idObjectMgr</computeroutput>), its id having
        been retrieved from <computeroutput>.local</computeroutput> in the
          <computeroutput>init</computeroutput> method.  </para>
  <para>In the Exercise 7 code, the second parameter in the <computeroutput>showModel</computeroutput> method is "a".
    This indicates that the List View instance is "anonymous". Instance names and "kinds" of component are
    discussed in <xref linkend="ch7-mvfuse-kinds.title"/>. </para>
  <para>Now that the List View has been created, consider what happens when the user double-clicks
        on an item in the list. In Exercise 6, the list data was hard-coded. In Exercise 7 it is
        read from disk by the <computeroutput>CustomerData</computeroutput> class (which subclasses
          <computeroutput>GenericFile</computeroutput>). In both exercises, launching a Customer
        View from the list (when the user double-clicks on a list item) is done by the
          <computeroutput>showCustomer</computeroutput> method as follows (excluding code common to
        both): 
    <programlisting>
<![CDATA[
                           CustomerListView                                     
  Exercise 6                                           Exercise 7
  ----------                                           ----------
::METHOD showCustomer UNGUARDED                      ::METHOD showCustomer UNGUARDED
  ...                                                  ...
  .local~my.idCustomerData  = .CustomerData~new
  .local~my.idCustomerModel = .CustomerModel~new
  .local~my.idCustomerData~activate
  .local~my.idCustomerModel~activate
                                                       objectMgr = .local~my.ObjectMgr
  .CustomerView~newInstance(rootDlg,"CU003")           objectMgr~showModel("CustomerModel", info~text, rootDlg)
  ...                                                  ...
]]>
  </programlisting>
      </para>
    <para>In Exercise 6, before the CustomerView is instantiated, the CustomerData and CustomerModel
        components must be instantiated, and their object IDs stored in
          <computeroutput>.local</computeroutput> for later access by the CustomerView and
        CustomerModel objects. This is needed, although no data is actually read from disk, the
        CustomerView invokes a method on CustomerModel which invokes CustomerData. </para>
      <para>In Exercise 7, on the other hand, the value of
          <computeroutput>info~text</computeroutput> (the index read from the selected ListView row)
        is the Customer Number, and is used as the Customer object's instance name. The single
          <computeroutput>showModel</computeroutput> statement  - a method of the Object Manager -
        then manages or "choreographs" the sequence of method invocations required to surface the
        Customer View dialog, and (if necessary) create the appropriate model and data objects. This
        choreography, using the <computeroutput>Model</computeroutput>,
          <computeroutput>View</computeroutput> and <computeroutput>GenericData</computeroutput>
        superclasses, results in the Customer View being surfaced with its data read from disk and
        displayed. See <xref linkend="apx5-mvf-ops.title"/> for a full description of the way in
        which this is done. </para>

    <para>Finally, note that in Exercise 7, the names of the possible List Model classes (e.g.
          <computeroutput>CustomerListModel</computeroutput>) are hard-coded in the
          <computeroutput>initRecords</computeroutput> method of
          <computeroutput>OrderMgrView</computeroutput> (although these would arguably be better
        placed in some configuration file).</para>
  </section>	<!-- End of Section 7.2.1 -->
  
  <section id="chap07-mvf-oview"><title id="ch7-mvf-oview.title">MVF Overview</title>                                 <!-- Section 7.2.2 -->
  <para>
    The MVF consists of five classes: <computeroutput>ObjectMgr</computeroutput>,
    <computeroutput>ViewMgr</computeroutput>, <computeroutput>Model</computeroutput>,
    <computeroutput>RcView</computeroutput>, <computeroutput>ResView</computeroutput>,
    and <computeroutput>GenericFile</computeroutput>. These are all located in the 
    folder <computeroutput>ooRexx\samples\oodialog\userGuide\exercises\Support</computeroutput>.
    Together, they handle the three different types of application component - view, model, and data. Each model
      gets its data from its data component, and each model has a single view.
      (A production-strength MVF could support multiple views of the same model by providing an
      "Open as..." option for a given icon or list item. This would display a selection of
      views, similar to the "Open with..." function provided by a button-2 click on an
      item in Windows Explorer.)</para>
    <para>MVF requires that each component has a text name, the name being the class name of the
        main class (such as "CustomerModel", "ProductView" or "OrderData") together with an instance
        name. <indexterm>
          <primary>Component</primary>
          <secondary>Name</secondary>
        </indexterm>
        <indexterm>
          <primary>Name</primary>
          <secondary>Component</secondary>
        </indexterm> For components with a "key" such as Customer Number, the instance name is the
        key (e.g. "CustomerModel BA0314"). For components that are "singletons" - that is, there can
        logically be only one instance, the name is "The". An example of a singleton is a data
        component (e.g. "CustomerData The"). Finally, some components - such as lists - are
        anonymous, and their instance names are numbers, as in "CustomerList 3". The instance name
        is important to MVF since its internal logic differs slightly depending on which kind of
        instance name is used - a "key" name, a singleton name, or an anonymous name. (Note that
        this naming convention could be relaxed if components were named in a configuration file;
        however, the distinctions between the different kinds of component would remain.) See <xref
          linkend="ch7-mvfuse-kinds.title"/> for further discussion. </para>
 
    <section id="chap07-mvf-oview-person">		                                        <!-- Section 7.2.2.1 -->
    <title id="ch7-mvf-oview-person.title">An Example - The 'Person' Component</title>
      <indexterm><primary>Person component</primary></indexterm>
      <indexterm><primary>Component</primary><secondary>Person</secondary></indexterm>      
    <para>A key question is, what does the MVF look like to the programmer? This section answers
          this question using the Person component, which has minimal function other than using the
          MVF, as an example. But first, using the Message Sender, try sending a
            <computeroutput>showModel</computeroutput> message to '<computeroutput>ObjectMgr
            The</computeroutput>' with the data '<computeroutput>PersonModel
          PA150</computeroutput>'. The Person dialog appears, and the MVF has handled the task of
          ensuring that both the Data and Model components are active before the View is launched.
          First, MVF checks to see if they are already activated; if not, it instantiates them (the
          Data instance first, then the Model). Second, on instantiation,
            <computeroutput>PersonModel</computeroutput>'s superclass asks the
            <computeroutput>PersonData</computeroutput> instance for its data. Third,
            <computeroutput>PersonView</computeroutput>'s superclass asks
            <computeroutput>PersonModel</computeroutput> for its data. Finally, the dialog for
          Person PA150 appears. </para>
    <para>The code required to use the MVF is shown in the Person component in
            <computeroutput>ooRexx\samples\oodialog\userGuide\exercises\Samples\Person</computeroutput>.
          The requirements for using the MVF are as follows: <itemizedlist>
            <listitem>
              <para><emphasis role="bold">A Data Component </emphasis>(a subclass of
                  <computeroutput>GenericFile</computeroutput>)</para>
              <para><programlisting><![CDATA[::METHOD newInstance CLASS PUBLIC
  ...
  -- Check if an instance has already been created; if so, return .false.
  idData = self~new()
  return idData
    
::METHOD init PRIVATE
  ...
  records = self~init:super(fileName, columns)
  ...]]></programlisting>Data components such as <computeroutput>PersonData</computeroutput> are
                required to provide a <computeroutput>newInstance</computeroutput> class method,
                which is invoked by the MVF. No parameters are provided. This method first checks if
                an instance has already been created. If not, it is created, and its object ID is
                returned to the MVF (i.e. to the caller). </para>
              <para>In the <computeroutput>init</computeroutput> method, the superclass'
                  <computeroutput>init</computeroutput> method is invoked with the filename and the
                number of columns in the file as parameters. Invocation of super with these
                parameters is an MVF requirement.</para>
            </listitem>
            <listitem>
              <para><emphasis role="bold">A Model Component</emphasis> (a subclass of
                  <computeroutput>Model</computeroutput>)</para>
              <para><programlisting><![CDATA[
::METHOD newInstance CLASS PUBLIC
  use strict arg instanceName
    forward class (super) continue	
    modelId = RESULT
    return modelId

 ::METHOD init
   use strict arg myData]]></programlisting>Model components such as
                  <computeroutput>PersonModel</computeroutput> are required to provide a <emphasis
                  role="italic">newInstance</emphasis> class method with one required argument - the
                model's instance name. The method must be forwarded to the
                  <computeroutput>Model</computeroutput> superclass, which retrieves the intended
                instance's data from its data component, then creates an instance of itself with the
                instance data as a parameter. The new instance must then be returned. </para>
            </listitem>
            <listitem>
              <para><emphasis role="bold">A View Component</emphasis> (a subclass of
                  <computeroutput>RcView</computeroutput>, <computeroutput>ResView</computeroutput>,
                or <computeroutput>UdView</computeroutput>)</para>
              <para><programlisting><![CDATA[
::METHOD newInstance CLASS PUBLIC
  use strict arg modelId, rootDlg
  -- create dialog, e.g. "dlg = .PersonView~new(...)"
  dlg~activate(modelId, rootDlg)
  return dlg  
    
::METHOD activate UNGUARDED
  use strict arg modelId, rootDlg
  forward class (super) continue
  personData = RESULT		
]]></programlisting>View components such as <computeroutput>PersonView</computeroutput> must provide
                a <computeroutput>newInstance</computeroutput> class method and an
                  <computeroutput>activate</computeroutput> method. The
                  <computeroutput>newInstance</computeroutput> method is invoked by MVF with the
                view's model id (and also the root dialog - that is, the Order Manager dialog).
                After the dialog is created, MVF requires that
                  <computeroutput>activate</computeroutput>, with the model's id as the first
                argument, be invoked on the new dialog. In the
                  <computeroutput>activate</computeroutput> method, the superclass must be invoked
                using <computeroutput>forward</computeroutput>. The superclass returns the Model's
                data in <computeroutput>RESULT</computeroutput>. Finally, the id of the new dialog
                must be returned.</para>
            </listitem>
          </itemizedlist></para>
    <para>The above is how a "named" component uses MVF. By "named" is meant a component whose
          identity is a combination of its class and a specific "key" such as a Customer Number, or
          Product Number. However, there are three other kinds of component: a "singleton" such as
          the Order Manager, a "form" such as the Order Form, and "anonymous" such as a Customer
          List. These are discussed below in <xref linkend="ch7-mvfuse-kinds.title"/>.</para>
  </section>      <!-- End of 7.2.2.1 -->
    
<section id="chap07-mvf-oview-objmgr"><title id="ch7-mvf-oview-objmgr.title">The Object Manager</title>	<!-- Section 7.2.2.2 -->
  <indexterm><primary>Object Manager</primary><secondary>Methods</secondary></indexterm>
  <indexterm><primary>MVF</primary><secondary>Object Manager</secondary></indexterm>      
          <para>The Object Manager (<computeroutput>ObjectMgr.rex</computeroutput> in the
            <computeroutput>userGuide\exercises\Support</computeroutput> folder) is a "singleton"
          class (there can only logically be one of them) and has the external name "ObjectMgr The".
          It maintains a table (called the "Object Bag") of all instantiated components. The public
          methods of the Object Manager are:</para>
        <para>
          <itemizedlist>
            <listitem>
              <para><computeroutput>getComponentId</computeroutput> (with parameters
                  <computeroutput>className</computeroutput> and
                  <computeroutput>instanceName</computeroutput>) - Returns the id of the requested
                component. If the id is not in the Object Bag, then it sends
                  <computeroutput>newInstance</computeroutput> to
                  <computeroutput>className</computeroutput>. If one or both of these do not exist,
                returns <computeroutput>.false</computeroutput>.</para>
            </listitem>
            <listitem>
              <para><computeroutput>list</computeroutput> - Lists the contents of the ObjectBag in
                the Command Prompt. The instance name for a View component is derived by invoking
                  <computeroutput>identityHash</computeroutput> on its id. The following shows the
                contents of the Object Bag after (a) a CustomerList was double-clicked on the Order
                Management dialog, (b) a Customer in the list was double-clicked, and (c) the <link
                  linkend="ch7-msgsender.title">Message Sender</link> was used to send a 'query'
                message to <emphasis role="italic">ProductModel LM400</emphasis>: <programlisting>
<![CDATA[
Object Bag List:
----------------------------------------------------------------------------
Class-Instance            Model Id                ViewClass-Inst 
------------------------  ------------------------  ------------------------ 
  CUSTOMERLISTVIEW-26701042 a CUSTOMERLISTVIEW        .nil
  PRODUCTMODEL-LM400        a PRODUCTMODEL            .nil
  CUSTOMERVIEW-267047652    a CUSTOMERVIEW            .nil
  CUSTOMERLISTMODEL-1       a CUSTOMERLISTMODEL       CUSTOMERLISTVIEW-26701042
  CUSTOMERDATA-THE          a CUSTOMERDATA            .nil
  PRODUCTDATA-THE           a PRODUCTDATA             .nil
  CUSTOMERMODEL-BA0314      a CUSTOMERMODEL           CUSTOMERVIEW-267047652
  ----------------------------------------------------------------------------
]]></programlisting></para>
            </listitem>
            <listitem>
              <para><computeroutput>showModel</computeroutput>(className, instanceName) - Shows the
                View for the specified Model. If the View exists, then it is surfaced. If not, then
                if the Data component is not already instantiated, it is instantiated. If the Model
                component is not already instantiated, it is instantiated. Then the View is
                instantiated. All instantiations use the <emphasis role="italic"
                  >newInstance</emphasis> method. All dialogs except the "application" dialog (that
                is, Order Manager) are created and/or surfaced using the
                  <computeroutput>showModel</computeroutput> method. </para>
            </listitem>
          </itemizedlist>
        </para>        
  <para>For further information on the Object Manager, including further detail on the flow of
          control when a component is instantiated, see <xref linkend="apx5-mvf-classes-om"
          />.</para>
 
</section>	<!-- End of Section 7.2.2.2 -->
  
  <section id="chap07-mvf-oview-model">
        <title>The 'Model' Superclass</title>
        <!-- Section 7.2.2.3 -->
        <indexterm>
          <primary>Model</primary>
          <secondary>Methods</secondary>
        </indexterm>
        <indexterm>
          <primary>MVF</primary>
          <secondary>Model</secondary>
        </indexterm>
        <indexterm>
          <primary>Superclasses</primary>
          <secondary>Model</secondary>
        </indexterm>
        <para><computeroutput>Model</computeroutput> is the MVF superclass for all model components,
          and provides key methods for subclasses as follows: <itemizedlist>
            <listitem>
              <para><computeroutput>newInstance</computeroutput>
                <indexterm>
                  <primary>newInstance</primary>
                </indexterm> - invoked by the Object Manager (which ensures that the required data
                component is instantiated) with an instance name as the single parameter. The id of
                the data component is retrieved from Object Manager, after which
                  <computeroutput>getRecord</computeroutput> or
                  <computeroutput>getFile</computeroutput> as appropriate is invoked on the data
                component. Then <computeroutput>self~new</computeroutput> is invoked with model's
                data as a parameter. Model also provides an instance attribute
                  <computeroutput>myData</computeroutput> that contains instance data returned from
                the data component.</para>
            </listitem>
            <listitem>
              <para><computeroutput>getInstanceName</computeroutput>
                <indexterm>
                  <primary>getInstanceName</primary>
                </indexterm> is invoked by ObjectMgr-showModel for anonymous components only. It
                adds 1 to a class variable and returns it. Note - for
                  <computeroutput>OrderForm</computeroutput>, the method is over-ridden and a "new
                order number " is returned.</para>
            </listitem>
            <listitem>
              <para><computeroutput>query</computeroutput>
                <indexterm>
                  <primary>Query method</primary>
                </indexterm> A component framework generally requires that components provide
                specific methods defined by the framework. Aside from instance creation methods, a
                "well-known" method is required for MVF to access a model component's data. This
                method has the name "query", and it must conform to a specific protocol as follows:<itemizedlist>
                  <listitem>
                    <para>If a component's <computeroutput>query</computeroutput> method is invoked
                      with no parameters, then it must return a directory containing all the
                      "public" data it has. The directory indexes are the labels for the data as
                      defined in the "database" (although this is not usually the case for real
                      production-strength systems, where the data dictionary for application-level
                      components often differs from the column names in an SQL database).</para>
                    <para>For example, use the Message Sender to send <emphasis role="bold"
                          ><emphasis role="italic">query</emphasis></emphasis> to <emphasis
                        role="bold"><emphasis role="italic">PersonModel PA150</emphasis></emphasis>.
                      A directory is returned by <computeroutput>PersonModel</computeroutput>, and
                      the Message Sender presents the directory in name-value form in its <emphasis
                        role="bold">Reply</emphasis> field as follows: <programlisting><![CDATA[dob: 751513; baseSalary: 38000; number: PA150; jobDescr: Packer; 
familyName: James; firstName: Alfred; 
]]></programlisting></para>
                  </listitem>
                  <listitem>
                    <para>If a component's <computeroutput>query</computeroutput> method is invoked
                      with one parameter, and when that parameter is a directory, an array, or a
                      string, then only those fields specified by name are returned. </para>
                    <para>For example, use the Message Sender to query the first name and family
                      name for "PersonModel PA150". To do this, specify the fields by name
                      (case-sensitive) in the <emphasis role="bold">Data</emphasis> edit field, as
                      follows: <emphasis role="bold"><emphasis role="italic">firstName
                          familyName</emphasis></emphasis> (note - field names are case-sensitive).
                      On pressing the <emphasis role="bold">Send</emphasis> button, the data
                        <emphasis role="bold"><emphasis role="italic">firstName: Alfred; familyName:
                          James;</emphasis></emphasis> is returned as a directory which Message
                      Sender unpacks and presents as a string in the <emphasis role="bold"><emphasis
                          role="italic">Reply</emphasis></emphasis> field. </para>
                    <para>For debugging purposes, <indexterm>
                        <primary>Debugging</primary>
                      </indexterm>
                      <indexterm>
                        <primary>Message Sender</primary>
                        <secondary>Debugging</secondary>
                      </indexterm> you can use MessageSender to send a set of data names as a string
                      (as in the example just given), a directory, or an array. To send as a
                      directory, enclose each name in square brackets, e.g.: <emphasis role="bold"
                          ><emphasis role="italic">[firstName] [familyName]</emphasis></emphasis>.
                      To send as an array, place a vertical bar before each name, e.g: <emphasis
                        role="bold"><emphasis role="italic">| firstName |
                        familyName</emphasis></emphasis>. </para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist></para>
      </section>	<!-- End of Section 7.2.2.3 -->

  <section id="chap07-mvf-oview-view"><title>The 'View' Superclass</title>		<!-- Section 7.2.2.4 -->
        <para><indexterm><primary>View</primary><secondary>Methods</secondary></indexterm>
          <indexterm><primary>MVF</primary><secondary>View</secondary></indexterm>
          <indexterm><primary>Superclasses</primary><secondary>View</secondary></indexterm>
          <indexterm><primary>RcView</primary></indexterm><indexterm><primary>ResView</primary></indexterm>
          <indexterm><primary>UdView</primary></indexterm>
          There are three View superclasses in the
            <computeroutput>Support</computeroutput> folder:
          <computeroutput>RcView</computeroutput>, <computeroutput>ResView</computeroutput>, and
            <computeroutput>UdView</computeroutput>. They are identical except for their
          superclasses - <computeroutput>RcDialog</computeroutput>,
            <computeroutput>ResDialog</computeroutput> and
            <computeroutput>UserDialog</computeroutput> respectively (their function could be
          provided by a single mixin class, and this is planned for a later version of the User
          Guide exercises). Important methods are:</para>
        <para>
          <itemizedlist>
            <listitem>
              <para><computeroutput>activate</computeroutput> - This is invoked by the subclass,
                which must provide the view's model id as the single argument. A
                  <computeroutput>query</computeroutput> message is invoked on the model, which
                returns the model's data as a directory. In addition, this method saves information
                used to tidy up the view in the <computeroutput>leaving</computeroutput> method.
              </para>
            </listitem>
            <listitem>
              <para><computeroutput>leaving</computeroutput><indexterm>
                  <primary>leaving method</primary>
                </indexterm> - This method is automatically invoked by ooDialog when a dialog
                closes. Its only function is to remove the view from the Object Manager's table. </para>
            </listitem>
            <listitem>
              <para><computeroutput>offset</computeroutput><indexterm>
                  <primary>offset method</primary>
                </indexterm> - This method offsets dialogs from the Order Management dialog when
                first opened. Although not used elsewhere in this exercise, the effect can be seen
                using the "Person" component in the <computeroutput>Samples\Person</computeroutput>
                folder. First, use the Message Sender to launch a Person dialog (for example send
                  <emphasis role="bold"><emphasis role="italic">showModel</emphasis></emphasis> to
                  <emphasis role="bold"><emphasis role="italic">ObjectMgr The</emphasis></emphasis>
                with the data <emphasis role="bold"><emphasis role="italic">PersonModel
                    PA150</emphasis></emphasis>). The Person dialog appears offset from the center
                of the screen. Now un-comment the last line
                  (<computeroutput>--self~offset:super</computeroutput>) in the
                  <computeroutput>initDialog</computeroutput> method of
                  <computeroutput>PersonView</computeroutput>, save, re-start the application, and
                launch the Person dialog as before. Note that the dialog "flickers" when opened - it
                seems to open for a fraction of a second in the centre of the screen, then
                re-appears offset from Message Sender. The flicker results from the .rc file
                containing the dialog property WS_VISIBLE (in ResEdit the behavior property
                "visible" is set to true). First it appears in the center of the screen, then moves
                to the offset position. Now remove "<computeroutput>| WS_VISIBLE</computeroutput>"
                from the .rc file, save, and re-run. The Person dialog appears without a flicker
                offset from the Message Sender.</para>
            </listitem>
          </itemizedlist>
        </para>
</section>	<!-- End of Section 7.2.2.4 -->

<section id="chap07-mvf-oview-data">
        <title>The 'GenericFile' Superclass</title>
        <!-- Section 7.2.2.5 -->
        <indexterm>
          <primary>Generic File</primary>
        </indexterm>
        <indexterm>
          <primary>MVF</primary>
          <secondary>GenericFile</secondary>
        </indexterm>
        <indexterm>
          <primary>Superclasses</primary>
          <secondary>GenericFile</secondary>
        </indexterm>
        <indexterm>
          <primary>Superclasses</primary>
          <secondary>GenericFile</secondary>
        </indexterm>
        <para>The data superclass is called "GenericFile", since it acts on any file having the
          defined format (see <xref linkend="chap07-mvfuse-datafmts"/> for a description of the file
          format). The important methods are: <itemizedlist>
            <listitem>
              <para><computeroutput>getRecord</computeroutput><indexterm>
                  <primary>getRecord method</primary>
                </indexterm> - Invoked with a record key (e.g. a Customer Number) as its single
                argument, reads the record from the file defined in the subclass, and returns a
                "record directory". </para>
            </listitem>
            <listitem>
              <para><computeroutput>getFile</computeroutput><indexterm>
                  <primary>getFile method</primary>
                </indexterm> - Returns the file in "file as directory" format. </para>
            </listitem>
            <listitem>
              <para><computeroutput>list</computeroutput><indexterm>
                  <primary>list method</primary>
                </indexterm> - Lists the file on the console.</para>
            </listitem>
          </itemizedlist>See <xref linkend="chap07-mvfuse-datafmts"/> for a description of the
          "record directory" and "file as directory" formats.</para>
      </section>
      <section>
        <title>Compound Data</title><para>"Compound data" is data assembled from two or more files. In Relational Data Base terms, this
          means a join. In this exercise, the only example of compound data is the Order component.
          Thus the <computeroutput>OrderData</computeroutput>
          <indexterm>
            <primary>OrderData class</primary>
          </indexterm>class uses <computeroutput>GenericFile</computeroutput> in a different way
          than other components. Other components can have all their data returned with a single
          invocation of one of <computeroutput>GenericFile</computeroutput>'s methods.
            <computeroutput>OrderData</computeroutput> on the other hand needs not only the order
          data from two files (Order Headers and Order Details), but also selected fields from
          Customer and Product records. In other words, it needs to do a relational "join". And
          since (in this exercise at least) we are not using an SQL database, the joins have to be
          done explicitly by the <computeroutput>OrderData</computeroutput> class. This is done in
          the <computeroutput>init</computeroutput> method, as follows. </para>
        <para>First, the OrderHeaders file is read into an attribute
            <computeroutput>dirOrderHeaders</computeroutput>. Then all order lines are read into an
          attribute <computeroutput>dirOrderLines</computeroutput>. Following this, the
            <computeroutput>addCustomerInfo</computeroutput> method retrieves additional customer
          data (required by <computeroutput>OrderView</computeroutput>) from the Customer Data
          component and that data is added to <computeroutput>dirOrderHeaders</computeroutput>.
          Finally, the <computeroutput>addProductInfo</computeroutput> method invokes the Product
          Data component to do the same for the required Product data (e.g. Product Names).</para>
        <para>Since the Order data is held in two attributes of
            <computeroutput>OrderData</computeroutput>, the
            <computeroutput>getRecord</computeroutput> and <computeroutput>getFile</computeroutput>
          methods are over-ridden, and handled completely by the
            <computeroutput>OrderData</computeroutput> class. While
            <computeroutput>getFile</computeroutput> is very simple - merely returning
            <computeroutput>dirOrderHeaders</computeroutput> (which is sufficient for the Product
          List model and view), the <computeroutput>getRecord</computeroutput> method needs to build
          the data for a single Order from the Order and OrderLines attributes, combining some
          Customer and some Product data not present in the Order Data (for example, Customer
          Discounts and Product Names). Thus it also over-rides its superclass method, and builds a
          directory called "dirOrderRecord" whose format is as follows:<programlisting><![CDATA[   "dirOrderRecord" format (using data values from Order No SO-1234):
    
              Indexes         Items
            +- - - - - - - - - - - - - - - - - - - - - - - - +
            | OrderNo       | SO-1234                        |
            +- - - - - + - - - - - - - - - - - - - - - - - - +
            | CustNo        | AB0784                         |
            +- - - - - + - - - - - - - - - - - - - - - - - - +
            | CustName      | ABC Enterprises Inc.           |
            +- - - - - + - - - - - - - - - - - - - - - - - - +
            | CustAddr      | 2145 Engle Blvd,Hardtown,FL    |
            +- - - - - + - - - - - - - - - - - - - - - - - - +
            | Zip           | 37043                          |
            +- - - - - + - - - - - - - - - - - - - - - - - - + 
            | Cmtd          | N                              |
            +- - - - - + - - - - - - - - - - - - - - - - - - + 
            | CustDisc      | B1                             |
            +- - - - - + - - - - - - - - - - - - - - - - - - + 
            | Disc          | 2                              |
            +- - - - - + - - - - - - - - - - - - - - - - - - + 
            | Date          | 120821                         |
            +- - - - - - - - - - - - - - - - - - - - - - - - +
            | OrderLineHdrs | OrderNo  ProdNo Qty ProdName   |     <a 1D array>
            +- - - - - - - - - - - - - - - - - - - - - - - - +
            | OrderLines    | SO-1234  AB100/W  5 Baffle     |     <a 2D array>
            |               | SO-1234  CF300/X  6 Widget Box |
            |               | SO-1234  EF500/W 15 Slodget    |
            +- - - - - - - - - - - - - - - - - - - - - - - - +]]></programlisting></para>
        <para>Finally, a <computeroutput>listOrders</computeroutput> method is provided, since the
            <computeroutput>list</computeroutput> method of
            <computeroutput>GenericFile</computeroutput> cannot list data from more than one
          file.</para>
      </section>	<!-- End of Section 7.2.2.5 -->



</section>  <!-- End of Section 7.2.2 -->
</section>  <!-- End of Section 7.2   -->

<section id="chap07-mvfuse"><title id="ch7-mvfuse.title">Using the MVF</title>	<!-- Section 7.3 -->

<section id="chap07-mvfuse-kinds"><title id="ch7-mvfuse-kinds.title">Kinds of Component</title>	<!-- Section 7.3.1 -->
  <indexterm><primary>Kind of component</primary></indexterm>
  <indexterm><primary>Component</primary><secondary>Kinds of</secondary></indexterm>
  <para>There are four "kinds" of components in Exercise07: "named", "singleton", "anonymous", and
        "form". <simplelist>
          <member> A "<emphasis role="bold">named</emphasis>" component instance is identified by a
            unique name derived from the instance's data (analogous to a database key). An example
            is <computeroutput>CustomerModel</computeroutput>, where each instance is identified by
            its Customer Number. The external name for such an instance is of the form model class
            name, model instance name - e.g. "CustomerModel AB0784". Note that a "Form" component
            such as the Order Form is of the named component kind, since it is (and must be) given
            its name (such as an order number) when first instantiated. A View component is named by
            its object reference number (that is, the number returned by invoking
              <computeroutput>identityHash</computeroutput> on the view instance). </member>
          <member> "<emphasis role="bold">Singleton</emphasis>" instances are those for which there
            can logically only be a single instance - for example, data components such as
              <computeroutput>CustomerData</computeroutput>, or the Order Manager (which in
            Exercise07 is a view-only component). Their instance name is always "The". </member>
          <member> An "<emphasis role="bold">anonymous</emphasis>" component is one for which there
            can logically be more than one instance, but which do not have any obvious
            distinguishing name. Thus they are initially given the instance name "A". Examples are
            list components such as <computeroutput>CustomerListModel</computeroutput>. Instances of
            an anonymous component are provided with a system-generated number. For example, the
            name of a Customer List Model is a unique number generated by its superclass, starting
            at '1'. For example, to create an instance of
              <computeroutput>CustomerListModel</computeroutput>, the message
              <computeroutput>getComponentId("CustomerListModel","A")</computeroutput> is sent to
              <computeroutput>ObjectMgr</computeroutput> which, on seeing instance name "a" or "A",
            invokes <computeroutput>getInstanceName</computeroutput> on the ListModel class object,
            which is handled by the <computeroutput>Model</computeroutput> superclass.
              <computeroutput>Model</computeroutput> returns a number starting at "1". </member>
          <member> A "<emphasis role="bold">form</emphasis>" instance such as a Sales Order Form or
            a Purchase Request form is a special kind of component. Initially it is anonymous, and
            although when created there is no database record of it, there will be when it's
            completed and the user hits OK. A new number (e.g. an order number) is assigned to a
            form when it is created, and this number is used as the database key when, after
            completion, the form is committed to the database. For example, the Order Form component
            assumes that this will happen, and so its instance name is a unique Sales Order number.
            This is created by the <computeroutput>getInstanceName</computeroutput> class method of
              <computeroutput>OrderFormModel</computeroutput> which over-rides the same method in
            its superclass (<computeroutput>Model</computeroutput>).</member>
        </simplelist>The above classification covers almost all the kinds of dialog found in a
        typical UI environment handling business systems. To test this, consider the "Words of
        Wisdom" business component in Exercise03, which was implemented as a view, a model, and a
        data component. The <computeroutput>.../samples/Wow4</computeroutput> folder contains the
        same set of components, but modified to use the MVF. Code no longer required is commented
        out with the comment "v01-00"; methods or statements added or for MVF use are commented with
        "MVF"; statements changed are commented "v01-00-->MVF"; unchanged statements are commented
        "v01-00 &amp; MVF". <footnote>
          <para>Actually, Wow is somewhat schizophrenic, in that it can be launched either as a
            singleton or as anonymous - that is, with an instance name of "The" or "A". If "The",
            then only one instance is allowed. If "A", then multiple instances can be
            created.</para>
        </footnote>As mentioned above, this whole approach of having component names define the type
        of component is not particularly scalable. A better approach - certainly for
        production-strength apps - is to provide a configuration file that names the classes and
        states what type they are. Such a file might look something like this, and would remove any
        need for using class names as the basis for managing instances: <programlisting><![CDATA[<modelClass name="Product",     type="named", dataClass="ProductDB"/>
<modelClass name="NewOrder",    type="form"/>
<modelClass name="CustomerList",type="anonymous"/>
<modelClass name="SalesOrder",  type="named><viewClass name="MySpecialView"/></modelClass>
<modelClass name="Wow",         type="singleton"
  <viewClass name="WowView">
  <dataClass name="WowData" source="sql">
</modelClass>]]></programlisting></para>

</section>	<!-- End of Section 7.3.1 -->

<section id="chap07-mvfuse-datafmts"><title id="ch7-mvfuse-datafmts.title">Data Formats</title>	<!-- Section 7.3.2 -->
  <!-- 
                - different for Order since have to compose data from two files
                  (no DBMS!)
                - Order Data - two files, OrderHeadersFile.txt and OrderLinesFile.txt
                  The OrderData component merges the two (??)
  -->
      <para>Fields in a file record are separated by a vertical bar character, and field names are
        defined in the first line of the file. All data files have the file extension ".txt".
          <computeroutput>GenericFile</computeroutput> returns a single record (for example a
        Customer record) in a "record directory", whose format is as follows:<programlisting><![CDATA[    "Record Directory" format (using sample data values):
    
              Indexes     Items
            +- - - - - - - - - - - - - -+
            | CustNo   | BA0314         |
            +- - - - - + - - - - - - - -+
            | CustName | LMN & Partners |
            +- - - - - + - - - - - - - -+
            | Zip      | 84394          |
            +- - - - - + - - - - - - - -+
            + ...      | ...            |
            +- - - - - - - - - - - - - -+]]> </programlisting> A complete file (for example the
        Customer File retrieved and displayed by the CustomerList component) is returned in "File as
        Directory" format, as follows: <programlisting><![CDATA[    "File Directory" format (using sample data values):
    
             Indexes    Items
			+- - - - - - - - - - - - - - - - - - - - - - - - +
			|Headers | CustNo  | CustName             | .... |   1D array
			|- - - - + - - - - + - - - - - - - - - - -+ - - -|
			|Records | AB0784  | ABC Enterprises Inc. | .... |   2D array
			|        | - - - - + - - - - - - - - - - -+ - - -|
			|        | AC0027  | Frith Motors Inc.    | .... |
			|        | - - - - + - - - - - - - - - - -+ - - -|
			|        |   ...   + ...                  + ...  |
			|- - - - + - - - - - - - - - - - - - - - -+ - - -+
			|Count   | n |                                       Integer
			+- - - - + - +]]>  </programlisting></para>
      <para>The data format for on Order is a combination of data from three files - OrderData,
        CustomerData, and ProductData - and is described in </para>
</section>	<!-- End of Section 7.3.2 -->
</section>  <!-- End of Section 7.3   -->

<section id="chap07-msgsender"><title id="ch7-msgsender.title">The Message Sender</title>	<!-- Section 7.4 -->
    <indexterm><primary>Message Sender</primary></indexterm>
  <para>The Message Sender is launched from the <emphasis role="bold">Help</emphasis> menu of the
        <emphasis role="bold">Sales Order Management</emphasis> dialog and is used to "send messages
      to" (aka "invoke methods on") components. It illustrates a useful kind of debugging aid, and
      replaces the special component-specific "startup" scripts provided in Exercise 6. While a
      useful aid, it is provided as merely a demonstration of the kind of debugging aid that can be
      deployed when using a component-based architecture. Thus it does not pretend to be
      all-encompassing, and the results of sending some messages may be unpredictable. In addition,
      its display of data returned is limited. For example, a "query" message sent to a List
      component only displays the top-level items, as follows:
      <programlisting><![CDATA[    RECORDS: an Array; COUNT: 5; HEADERS: an Array;]]> </programlisting></para>
    <para>Certain commonly-used target objects and messages are provided in the two combo boxes
        <emphasis role="bold">Target</emphasis> and <emphasis role="bold">Method</emphasis>. For
      repetitive testing of a given component, additional targets and messages can be temporarily
      "stored" in the combo boxes, so saving in typing time. The combo boxes are re-set when the
      Message Sender is closed. </para>
        <para>Finally, in sending to the Object Manager, only the "list" and "showModel" methods are
      supported. </para>
</section>	<!-- End of Section 7.4 -->

<section id="chap07-orderform"><title id="ch7-orderform.title">The Order Form</title>		<!-- Section 7.5 -->
    <indexterm><primary>Order Form dialog</primary></indexterm>
<para>Order Form - use of ControlObjects - multiple dialogs, one main one, one for each tab. Why? To
      allow controls on the form itself. </para>
</section>	<!-- End of Section 7.5 -->

<section id="chap07-next"><title id="ch7-next">Completing the Application</title>               <!-- Section 7.6 -->
<para>At this point, there is more to do to complete the application. For example, completing the
      OrderForm, allowing data to be updated, moving as much generic function as possible to
      superclasses, and removing the need for duplicate view superclasses. It is planned that these
      functions will be addressed in the next version of this document. </para> 
  <para>(Mention the "requires list" somewhere!)</para>
</section>	<!-- End of Section 7.6 -->

</chapter>
