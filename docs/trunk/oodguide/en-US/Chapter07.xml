<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"[
<!ENTITY % BOOK_ENTITIES SYSTEM "oodguide.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog User Guide XML file
    #
    # Copyright (c) 2013-2013 Rexx Language Association. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->

<!-- Chapter07 - A Working Application		 		  v01-00 10Jan13

    Changes:
     v01-00 10Jan13: First version.

    7   *  Towards A Working Application	                                          chapSeven
    7.1   * Introduction                                                              chap07-intro
    7.2   * A 'Model-View Framework'                                                  chap07-mvf
    7.2.1   * Objectives		                                                      chap07-mvf-objs
              - What has to happen to open dialog (get data etc.)
              - Try PersonModel (use MsgSender - more detail later) and Wow4
              - Look at code.
              - now look at OrderMgr - how dialogs now opened.
    7.2.2   * MVF Overview                                                            chap07-mvf-oview
              - Consists of superclasses (Model, View and GenericFile)
                and "manager" objects.
    7.2.2.1 * ObjectMgr - Overview only - see appendix 5 for details.                 chap07-mvf-oview-objmgr
                Summary of methods used
                - list - Lists a file on the console.
    7.2.2.2   * Model                                                                 chap07-mvf-oview-model
    7.2.2.3   * View                                                                  chap07-mvf-oview-view
                - offsetting: use MsgSender (refer to section 7.3 for more details)
                  e.g. PersonModel - must set Visible = False in resEdit else get a
                  flicker - try it - add WS_VISIBLE to .rc file (default is FALSE)
                  then re-open. Watch the flicker as it moves from default position
                  to offset position. (Note - not used for other dialogs)
                  (Note - it offsets relative to MsgSender - check out why!)
    7.2.2.4   * Data                                                                   chap07-mvf-oview-data
                - Data components are subclassed from GenericFile
                  (in Support file 'genericfile.rex').
                - Data formats
    7.3   * Using the MVF                                                             chap07-mvfuse
    7.3.1     Diff kinds of component; how different kinds use MVF.                   chap07-mvfuse-kinds
                - also Wow4 - shows how MVF can be used when doesn't conform
                   with entity or list.
    7.3.2     Data formats - standard data formats - getRecord,                       chap07-mvf-datafmts
                  getFile on Data component
                - different for Order since have to compose data from two files
                  (no DBMS!)
                - Order Data - two files, OrderHeadersFile.txt and OrderLinesFile.txt
                  The OrderData component merges the two (??)
    7.4     Message Sender - get rid of "stand-alone" testing code.                   chap07-msgsender
    7.5     The Order Form -                                                          chap07-orderform
    7.6     Next Version                                                              chap07-next
            - Say this app not completed - e.g. query method not in super, OrderForm not complete, etc.
            Things to add:
            - drag/drop
            - Complete the OrderForm
            - Dialog offsetting
-->

<chapter id="chapSeven"><title>Towards A Working Application</title>

<section id="chap07-intro"><title>Introduction</title>  <!-- Section 7.1 -->
    <para>This chapter, and the accompanying Exercise, provides much of the infrastructure of an
            application that uses model-view-data component concepts. </para>
<para> Open the <computeroutput>Exercise07</computeroutput> folder and start the Order Management
            application by double-clicking on <computeroutput>startup.rex</computeroutput>. Try it
            out. Explore the function which, while not complete, is much more so than in the
            previous exercise. In particular, note that application data is now read from files. For
            example, the Customer data is read from the file
                <computeroutput>CustomerFile.txt</computeroutput> (in which fields in a record are
            separated by a vertical bar character, and field names are defined in the first line of
            the file). However, although the data can be changed in dialogs, the changed data does
            not (in this exercise) update the files. </para>
        <para>Also, note that the "Help" menu on the main Sales Order Management dialog now includes
            an option "Message Sender" (discussed in more detail in <xref
                linkend="ch7-msgsender.title"/>. Click this option and a "Message Sender" dialog
            opens. This sends messages to (invoke methods on) the various components, and is a very
            useful debugging tool that replaces the "stand-alone" function used in the previous
            exercise. For example, try sending a "query" message to the Customer whose key is
            BA0314. To do this, key <computeroutput>CustomerModel BA0314</computeroutput> in the
                <emphasis role="bold">Target</emphasis> field ,
                <computeroutput>query</computeroutput> in the <emphasis role="bold"
                >Method</emphasis> field, and then press <emphasis role="bold">Send</emphasis>. The
            customer's data is returned in the <emphasis role="bold">Reply</emphasis> field as a
            name-value string. </para>
        <para>Now try using the Message Sender to surface a Product dialog - say the view for
            Product CU003. To do this, key <computeroutput>ObjectMgr The</computeroutput>  in the
                <emphasis role="bold">Target</emphasis> field,
                <computeroutput>showModel</computeroutput> in the <emphasis role="bold"
                >Method</emphasis> field, and <computeroutput>ProductModel CU003</computeroutput> in
            the Data field. Now press <emphasis role="bold">Send</emphasis>. The Product dialog for
            instance CU003 appears. </para>
        <para>The "ObjectMgr" (which should really be called "ComponentManager" since it manages
            application components as opposed to any object) is a support class that instantiates
            components by invoking a component's <emphasis role="italic">newInstance</emphasis>
            class method. It also keeps track of which components are already instantiated. For more
            detail see <xref linkend="chap07-mvf-oview-objmgr"/></para>
        <para>Consider now what has to happen to display the Product View. First, a
                <computeroutput>ProductData</computeroutput> instance must be created, and its data
            is read from disk (in this exercise, the whole file is read in). Then the appropriate
                <computeroutput>ProductModel</computeroutput> component is instantiated and its data
            retrieved from the <computeroutput>ProductData</computeroutput> component. Finally, an
            instance of <computeroutput>ProductView</computeroutput> is created and its data
            retrieved from the <computeroutput>ProductModel</computeroutput> component by invoking
            its <emphasis>query</emphasis> method. </para>
        <para>This sequence is a pattern that can be applied to most business components, and hence
            can be handled by superclasses so that the application components do not have to provide
            the same duplicated code. This pattern is called the "Model-View Framework", which is
            discussed in the next section. After that, the Message Sender is discussed in more
            detail, following some details of the Order Form component are addressed. </para>
</section>     <!-- End of Section 7.1 -->

<section id="chap07-mvf"><title id="ch7-mvf.title">A Model-View Framework</title>		<!-- Section 7.2 -->

<section id="chap07-mvf-objs"><title id="ch7-mvf-objs.title">MVF Objective</title>		<!-- Section 7.2.1 -->
    <para>For a discussion of the internals of the MVF, see <xref linkend="apx-mvfinternals"
                />.</para>
        <para>The objective of the ModelView Framework (MVF) is to provide a simple mechanism
                whereby application components can read and write data and display views without
                needing to be aware of how this is done. The MVF also supports the view-model-data
                separation of concerns in application-level components. </para>
            <para>When a user double-clicks on an item in say the Product List dialog, the confident
                expectation is that a product dialog that shows the data associated with the list
                item will be displayed. Now consider what has to happen to make that product dialog
                appear:</para>
            <orderedlist>
                <listitem>
                    <para>Create the appropriate Data component, which...</para>
                </listitem>
                <listitem>
                    <para>... opens the correct data file and reads the data.</para>
                </listitem>
                <listitem>
                    <para>Create the Model component and provide it with its "key" (e.g. product
                        number).</para>
                </listitem>
                <listitem>
                    <para>In the Model component, get a reference to the Data component.</para>
                </listitem>
                <listitem>
                    <para>Invoke a method on the Data component to retrieve the data associated with
                        the Model's key.</para>
                </listitem>
                <listitem>
                    <para>Create a View component.</para>
                </listitem>
                <listitem>
                    <para>Provide that view component with the data to be displayed in the
                        dialog.</para>
                </listitem>
                <listitem>
                    <para>Make the dialog visible.</para>
                </listitem>
            </orderedlist>
<para>This set of actions assumes that none of the component instances involved are yet activated.
                However, the MVF must work when some or all are activated. For example, if a View
                exists but is minimized, then if a user double-clicks on that item in a list, the
                MVF need only surface the view. Thus the MVF distinguishes between a number of
                different states, and relieves the programmer from having to code the logic for
                each component and for each possible state. </para>
    <para> In the previous exercise, the code in <computeroutput>OrderMgrView</computeroutput> 
      that launched (for example) a Customer List View was as follows: 
      <programlisting>
      <![CDATA[
  ::METHOD showModel UNGUARDED
    use arg record
    className = record~ID
    viewClassName = className||"View"
    interpret "."||viewClassName||"~newInstance(self)"
      ]]>
      </programlisting>
    The list data was hard-coded in the list view class, 
    and launching a Customer View from the list was done by the <computeroutput>showCustomer</computeroutput> method:
    <programlisting>
    <![CDATA[
  ::METHOD showCustomer UNGUARDED
    ...
    .local~my.idCustomerData  = .CustomerData~new	-- create Customer Data instance
    .local~my.idCustomerModel = .CustomerModel~new	-- create Customer Model instance
    .local~my.idCustomerData~activate
    .local~my.idCustomerModel~activate
    .CustomerView~newInstance(rootDlg,"CU003")
    ...
    ]]>
    </programlisting>
    The <computeroutput>getData</computeroutput> method of <computeroutput>CustomerView</computeroutput> then 
    invoked <computeroutput>query</computeroutput> on <computeroutput>CustomerModel</computeroutput> 
    (finding its id in <computeroutput>.local</computeroutput>), which in turn invoked <computeroutput>getData</computeroutput>
    on <computeroutput>CustomerData</computeroutput>, which returned hard-coded Customer data. 
    </para>
    <para>Now look at the sequence in Exercise07. First, <computeroutput>OrderMgrView</computeroutput> has the names
        of the possible model classes (e.g. <computeroutput>CustomerListModel</computeroutput>) hard-coded in its
        <computeroutput>initRecords</computeroutput> method (although these could arguably be better placed in a configuration file).
        The <computeroutput>showModel</computeroutput> method is as follows: 
      <programlisting>
      <![CDATA[
  ::METHOD showModel UNGUARDED
    expose idObjectMgr  -- got from .local in the init method
    use arg record
    className = record~ID
    r = idObjectMgr~showModel(classname, "a", self)			
      ]]>
      </programlisting>
    Here, the Object Manager (<computeroutput>idObjectMgr</computeroutput>) handles the task of ensuring that both
        the Data and Model components are active. It checks to see if they are already activated; if not, it instantiates them.
        It then instantiates the appropriate List View component, and launching a Customer View from the list is done as follows:
        The second parameter ("a") in the last statement is the instance name of the List View, and stands for "Anonymous". Instance names are
        discussed in <xref linkend="ch7-mvfuse-kinds.title"/>. The <computeroutput>showCustomer</computeroutput> method in the
        Customer List component, where <computeroutput>info~text</computeroutput> is the Customer Number (also used as the instance name),
        is as follows: 
        <programlisting>
    <![CDATA[
  ::METHOD showCustomer UNGUARDED
    ...
      objectMgr = .local~my.ObjectMgr
      objectMgr~showModel("CustomerModel", info~text, rootDlg)		
    ...
    ]]>
    </programlisting>
        
    </para>
    <para>Now look at Person....</para>

</section>	<!-- End of Section 7.2.1 -->

<section id="chap07-mvf-oview"><title id="ch7-mvf-oview.title">MVF Overview</title>		<!-- Section 7.2.2 -->
<!--              - Consists of superclasses (Model, View and GenericFile)
                and "manager" objects.
              - Overview only - see appendix 5 for details.
-->

<para> The MVF handles the three different types of component - view, model, and data. Each model
                gets its data from its data component, and each model has a single view.
                (A production-strength MVF could support multiple views of the same model by providing an
                "Open as..." option for a given icon or list item. This would display a selection of
                views, similar to the "Open with..." function provided by a button-2 click on an
                item in Windows Explorer.)</para>
<para>MVF requires that each component has a text name, the name being the class name of
                the main class (such as "CustomerModel", "ProductView" or "OrderData") together with
                an instance name.
                <indexterm><primary>Component</primary><secondary>Name</secondary></indexterm>
                <indexterm><primary>Name</primary><secondary>Component</secondary></indexterm>
                For components with a "key" such as Customer Number, the instance
                name is the key (e.g. "CustomerModel BA0314"). For components that are "singletons"
                - that is, there can logically be only one instance, the name is "The". An example
                of a singleton is a data component (e.g. "CustomerData The"). Finally, some
                components - such as lists - are anonymous, and their instance names are numbers, as
                in "CustomerList 3". The instance name is important to MVF since its internal logic
                differs slightly depending on which kind of instance name is used - a "key" name,
                the singleton name, or the anonymous name. (Note that this naming convention could
                be relaxed if components were named in a configuration file; however, the
                distinctions between the different kinds of component would remain - see
                <xref linkend="ch7-mvfuse-kinds.title"/> for further discussion.
            </para>

<section id="chap07-mvf-oview-objmgr"><title id="ch7-mvf-oview-objmgr.title">The Object Manager</title>	<!-- Section 7.2.2.1 -->
<para>Suppose now that some component X wants to send 'query' to the instance "PA150" of PersonModel
                which is subclassed from the support class <computeroutput>Model</computeroutput>
                (MVF support classes are in the <computeroutput>Support</computeroutput> folder). To
                do this, both the Model and the Data components must be instantiated. The following
                pseudocode illustrates how the MVF handles this (excluding error handling):
<programlisting>
  <![CDATA[

]]>
    </programlisting>
  </para>
  <para>For an overview of MVF internals, see <xref linkend="apx-mvfinternals"/></para>
  <para>New superclasses and MVF objects. (mention the "requires list")</para>
</section>	<!-- End of Section 7.2.2.1 -->

<section id="chap07-mvf-oview-model"><title>The 'Model' Superclass</title>		<!-- Section 7.2.2.2 -->
<para>...</para>
<para>The 'Query' Protocol</para>
    <para>A component framework generally requires components to provide specific methods defined by
      the framework. In our case, aside from instance creation methods, a "well-known"
      method is required for the MVF to access a model component's data. This method
      has the name "query", and it must conform to the following protocol:
      <itemizedlist>
        <listitem>
        <para>If a component's <emphasis role="italic">query</emphasis> method
        is invoked with no parameters, then it must return a directory
        containing all the "public" data it has. The directory indexes are
        the labels for the data as defined in the "database" (although this
        is not usually the case for real production-strength systems, where
        the data dictionary for application-level components often differs
        from the column names in an SQL database).</para>
        <para>For example, use the MessageSender to send "query" to "PersonModel
        PA150". A directory is returned by PersonModel, and the Message
        Sender presents the directory in name-value form in its "Reply"
        field as follows: </para>
        <para>dob: 751513; baseSalary: 38000; number: PA150; jobDescr:
        Packer; familyName: James; firstName: Alfred;  </para>
        </listitem>
        <listitem>
        <para>If a component's <emphasis role="italic">query</emphasis> method
        is invoked with one parameter, and when that parameter is a
        directory, an array, or a string, then only those fields specified
        by name are returned. </para>
        <para>For example, use the Message Sender to query the first name and
        family name for "PersonModel PA150". To do this, specify the fields
        by name (case-sensitive) in the "Data" edit field, as follows (but
        without the quotes): "firstName familyName". On pressing the "Send"
        button, the data "firstName: Alfred; familyName: James;" is returned
        as a directory which Message Sender unpacks and presents as a string
        in the Reply field. </para>
        <para>For debugging purposes, you can cause MessageSender to send a set
        of data names as a string (as in the example just given), a
        directory, or an array.  To send as a directory, enclose each name
        in square brackets, e.g.: [firstName] [familyName]. To send as an
        array, place a vertical bar before each name, e.g: | firstName |
        familyName. </para>
        </listitem>
      </itemizedlist>
      Finally, note that although all components in Exercise07 support
      the first of the query protocols (i.e. with no parameters), not all components
      support the second.</para>
</section>	<!-- End of Section 7.2.2.2 -->

<section id="chap07-mvf-oview-view"><title>The 'View' Superclass</title>		<!-- Section 7.2.2.3 -->
<para>
<!-- - offsetting: use MsgSender (refer to section 7.3 for more details)
  e.g. PersonModel - must set Visible = False in resEdit else get a
  flicker - try it - add WS_VISIBLE to .rc file (default is FALSE)
  then re-open. Watch the flicker as it moves from default position
  to offset position. (Note - not used for other dialogs)
  (Note - it offsets relative to MsgSender - check out why!)
-->
</para>
</section>	<!-- End of Section 7.2.2.3 -->

<section id="chap07-mvf-oview-data"><title>The 'GenericFile' Superclass</title>		<!-- Section 7.2.2.4 -->
<para>The data superclass is called "GenericFile", since it acts on any file having
  a defined format. The main methods used by MVF are: ... </para>
  <!--  Diagram of data objects:

Methods of GenericFile are:

readFile - A private method - Given a filename and the number of columns, reads a file and
               returns it in "File As Directory" format. This is stored in the public
               attribute "fileAsDirectory"

 getRecord - Given a "key", returns a file record (or line) as a directory containing
            the record data associated with that key. Format is:
-->

</section>	<!-- End of Section 7.2.2.4 -->



</section>  <!-- End of Section 7.2.2 -->
</section>  <!-- End of Section 7.2   -->

<section id="chap07-mvfuse"><title id="ch7-mvfuse.title">Using the MVF</title>	<!-- Section 7.3 -->
  <para>
    - Underlying operations provided by MVF (i.e. overview of how MVF works).
    - Ref appendix for detail.
  </para>


<section id="chap07-mvfuse-kinds"><title id="ch7-mvfuse-kinds.title">Kinds of Component</title>	<!-- Section 7.3.1 -->
    <para> Note: also "Forms" - take instance name of entity id = e.g. Order Number </para>
    <!--  In addition, diff kinds of component; how different kinds use MVF. - Ref
                "samples\person" and "samples\Wow4". Use MessgeSender to show a view of the
                PersonModel whose key is PA100. Also, WowModel The. - Ref appendix05 for detail of
                MVF. </para>-->
    
</section>	<!-- End of Section 7.3.1 -->

<section id="chap07-mvfuse-datafmts"><title id="ch7-mvfuse-datafmts.title">Data Formats</title>	<!-- Section 7.3.2 -->
  <para>
    <programlisting>
    <![CDATA[

             Indices   Items
            +- - - - - - - - - +
            | index 1 | item 1 |
            +- - - - -+ - - - -+
            | index x | item x |
            +- - - - -+ - - - -+
            | index n | item n |
            +- - - - + - - - - +
    ]]>
    </programlisting>
  </para>

  <para>
  getFile - Returns the file in "File as Directory" format, as follows:
  <programlisting>
    <![CDATA[

    "File as Directory" format (using sample data values):
             Indices    Items
			+- - - - - - - - - - - - - - - - - -+
			|Headers | OrderNo | CustNo  | .... |	1D array
			|- - - - + - - - - + - - - - + - - -|
			|Records | OR123   | CU0003  + .... |   2D array
			|        | - - - - + - - - - + - - -|
			|        | OR345   | CU0145  | .... |
			|        | - - - - + - - - - + - - -|
			|        | etc. ......              |
			|- - - - + - - - - + - - - - + - - -+
			|Count   | n |                          Integer
			+- - - - + - +

    ]]>
  </programlisting>
</para>
</section>	<!-- End of Section 7.3.2 -->
</section>  <!-- End of Section 7.3   -->

<section id="chap07-msgsender"><title id="ch7-msgsender.title">The Message Sender</title>	<!-- Section 7.4 -->
    <indexterm><primary>Message Sender</primary></indexterm>
<para> Message Sender - get rid of "stand-alone" testing code. </para>
        <para>In sending to ObjectMgr, this version only supports "List" and "showModel". </para>
</section>	<!-- End of Section 7.4 -->

<section id="chap07-orderform"><title id="ch7-orderform.title">The Order Form</title>		<!-- Section 7.5 -->
    <indexterm><primary>Order Form dialog</primary></indexterm>
<para>
Order Form - use of ControlObjects - multiple dialogs, one main one, one for each tab. Why? To allow controls on
the form itself.
</para>
</section>	<!-- End of Section 7.5 -->

<section id="chap07-next"><title id="ch7-next">Completing the Application</title>               <!-- Section 7.6 -->
<para>At this point, there is more to do to complete the application. For example,
completing the OrderForm, allowing data to be updated, moving as much generic
function as possible to superclasses, and removing the need for duplciate view superclasses.
It is planned that these functions will be addressed in the next version of this document.
</para>
</section>	<!-- End of Section 7.6 -->

</chapter>
