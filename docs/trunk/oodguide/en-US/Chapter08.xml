<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"[
<!ENTITY % BOOK_ENTITIES SYSTEM "oodguide.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog User Guide XML file
    #
    # Copyright (c) 2013-2013 Rexx Language Association. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<!-- Chapter08 - <Title?>		 		  	  v01-00 26Aug13

    Changes:
     v01-00 10May13: First version.

    8   *  ???	                                           chapEight
    8.1   * Introduction                                   chap08-intro
    8.2   * Direct Manipulation                            chap08-dragdrop
    8.3   * Refactoring the MVF                            chap08-mvfRefactoring
    8.4   * Using the MVF                                  chap08-usingMVF
    8.5   * Event Management                               chap08-eventMgmt
    8.6   * The Order Form                                 chap08-orderForm

    
Topics (in no particular order):
  4. Moving the View supers into a single mixin.
  5. Drag/Drop Customer/Product to OrderForm
-->
<chapter id="chapEight">
  <title>Direct Manipulation or Drag/Drop</title>

<!-- *********************************************************************************************** -->
  <section id="chap08-intro"><title>Introduction</title>    <!-- Section 8.1 -->
    <para>Exercise 8 introduces direct manipulation. Try opening an Order Form, then open a Customer
      dialog. Drag the Customer to an Order Form dialog and drop. The customer details are entered
      automatically into the Order Form. Drag a Product dialog to the OrderForm dialog and product detail is also 
      entered. Drag-drop as it appears to the application developer is discussed in the section 
      <xref linkend="chap08-dragdrop"/>, and further detail is provided in <xref linkend="apx6-dm"/>.</para> 
    <para>However, Exercise 8 also introduces a number of other things. 
      Although not apparent to the user, substantial changes have been made to the MVF 
      class structure. In particular, the unfortunate duplication of code in the three 
      View superclasses of previous exercises is removed. The new structure is discussed in
      <xref linkend="chap08-mvfRefactoring"/>, together with the changes at the application level.</para> 
    <para>You may have noticed in Exercise 7 that the process hangs when you close the
      Order Management dialog without first closing all Order Form dialogs. This problem, and its
      solution, is addressed in <xref linkend="chap08-eventMgmt"/>. </para>
    <para>In addition, further development of the OrderForm function is briefly described.</para>
    <para>
      <xref linkend="chap08-eventMgmt"/>. However, , and this is discussed in  
      (the three Viewmain Suthe , from ... 
    This is </para>
  </section>
  <!-- *********************************************************************************************** -->
  
  <section id="chap08-dragdrop" xreflabel="Direct Manipulation">  <!-- Section 8.2 -->
    <title>Direct Manipulation</title>
    <indexterm><primary>Direct manipulation</primary></indexterm>
    <indexterm><primary>Drag-Drop</primary></indexterm>
    <para>Direct manipulation (or drag-drop) is the use of the mouse to drag dialogs around the screen
      and drop them on other dialogs. But of course it isn't the dialog that's visibly dragged - it's a small icon 
      that represents the dialog. To try this out, first surface a Customer dialog (e.g. by double-clicking
      on an item in the Customer List dialog). Second, create an Order Form dialog by double-clicking on the
      OrderForm icon in the Order Manager dialog. Now put the mouse cursor
      over the Customer dialog then press and hold
      the "primary" button (usually the left mouse button).<footnote><para>The "primary" button defaults to being the left-hand 
        button, but this can be changed in the Windows Mouse Properties so that it's the right-hand button.</para></footnote>
      Start dragging - you'll see the mouse cursor change to a no-entry (or "no-drop") symbol. Drag it over the OrderForm. 
      The mouse cursor changes to a Customer symbol. Now release the mouse button - that it, "drop" the Customer onto 
      the Order Form. The customer details appear on the Order Form. 
    </para>
    <para>Although behind this operation there is some quite complex code (discussed in <xref linkend="apx6-dm"/>, 
      the code within application components
      is very simple. In the drag-drop context, there are two kinds of component: a "source" dialog that is dragged,
      and a "target" dialog that is dragged over and/or dropped upon (dragging more than one component is not supported).
    </para>
    <itemizedlist>
      <listitem>
        <para><emphasis role="italic"><emphasis role="bold">Source Dialog</emphasis></emphasis></para>
        <para>To enable support for dragging from a source dialog, simply provide the following code
          when the dialog is started (typically in the <computeroutput>initDialog</computeroutput>
          method):
          <programlisting><![CDATA[  r = self~dmSetAsSource:super("<cursor file name>")]]></programlisting>
          The cursor file (with file extension "cur") must be given with its path. For example, the
          cursor file name in <computeroutput>CustomerView</computeroutput> is
          <computeroutput>Customer\bmp\Customer.cur</computeroutput>. A cursor file can be created
          using an appropriate tool.<footnote>
            <para>One such tool is <ulink url="http://www.gdgsoft.com/gconvert/index.aspx"
              ><citetitle>GConvert</citetitle></ulink>. However, there are others, and mention
              of this particular product should not be interpreted as a preference.</para>
          </footnote></para></listitem>
      <listitem>
        <para><emphasis role="italic"><emphasis role="bold">Target Dialog</emphasis></emphasis></para>
        <para>In the target two things have to be done. First, when being dragged over, decide whether a drop
          is acceptable, so that the mouse cursor can be set as either no-drop or ok-to-drop. 
          Second, if acceptable, accept the drop if it happens.</para>
        <itemizedlist>
          <listitem><para><emphasis role="bold">Drop acceptable?</emphasis></para>
            <para>Checking if a drop is acceptable is done in the class object of the target's
              model component. For a drop on an Order Form, this is
              <computeroutput>.OrderFormModel</computeroutput> which accepts a drop of a
              <computeroutput>CustomerModel</computeroutput>, as follows:<programlisting><![CDATA[  ::METHOD dmQueryDrop CLASS PUBLIC
     use arg sourceClassName
     if sourceClassName = "CUSTOMERMODEL" then return .true
     else return .false]]></programlisting>Why the class object? Well, in the general case, a user
              might want to drop on some visible representation of a target such as an item in a
              ListView. To get to the right item, the mouse cursor could be dragged over many items.
              If each is asked if a drop is allowed, then each must first be instantiated, and this
              could mean many database accesses. Much better to check with an object that's already
              instantiated - such as the class object (class objects are instantiated when the
              program starts). However, in Exercise 8 only instantiated dialogs (i.e. view objects)
              can be drag-drop targets. </para>
          </listitem>
          <listitem><para><emphasis role="bold">Drop happens</emphasis></para>
            <para>If a drop is acceptable, and if the user then releases the mouse button, then
              the view instance receives a <computeroutput>dmDrop</computeroutput> message, upon
              which the target typically asks the source object for data. For OrderFormView: <programlisting><![CDATA[  ::METHOD dmDrop PUBLIC
     expose cd1
     use strict arg sourceModel, sourceDlg
     cd1~getCustomerData(sourceModel)           -- gets Customer data
     return .true]]>                </programlisting>Note that the variable
              <computeroutput>cd1</computeroutput> is the Customer Details control dialog. The
              method <computeroutput>getCustomerData</computeroutput> invokes
              <computeroutput>query</computeroutput> on the dragged Customer model
              (<computeroutput>sourceModel</computeroutput>) and populates the Customer control
              dialog in <computeroutput>OrderFormView</computeroutput>.  </para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
    <para>Note: If a dialog has a <computeroutput>leaving</computeroutput> method, then it must 
      super to the <computeroutput>View</computeroutput> superclass so that proper tidy-up can be done.
    </para>
  </section>
  
  <!-- *********************************************************************************************** -->
  <section id="chap08-mvfRefactoring" xreflabel="Refactoring the MVF"><title>Refactoring the MVF</title> <!-- Section 8.3 -->
    <para>Exercise 8 introduces a new superclass for components called
        <computeroutput>Component</computeroutput>, which becomes part of the MVF.
        <computeroutput>Component</computeroutput> handles event management on behalf of subclasses.
      In addition, the duplicate View superclasses (<computeroutput>RcView</computeroutput>,
        <computeroutput>ResView</computeroutput>, and <computeroutput>UdView</computeroutput>) are
      replaced by a single <computeroutput>View</computeroutput> superclass. Ideally, and using
      parts of the Customer business component as an example, the desired class structure would be
      as follows (where a blue border indicates an application component, red an ooDialog class,
      green an MVF class, and black an ooRexx class):</para>
      <figure id="fig0801">
        <title>Exercise08 Notional Class Structure</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter08-Image1.jpg" scale="70"/>
          </imageobject>
        </mediaobject>
      </figure>
    <para>However, this structure requires multiple inheritance: each "view" component (such as
        <computeroutput>CustomerView</computeroutput>) subclasses two superclasses -
        <computeroutput>RcDialog</computeroutput> and <computeroutput>View</computeroutput>. But
      this form of multiple inheritance <indexterm>
        <primary>Multiple inheritance</primary>
      </indexterm>is not supported by ooRexx. However, ooRexx <emphasis role="italic"
        >does</emphasis> provide "mixin" classes. A mixin class <indexterm>
        <primary>Mixins</primary>
      </indexterm> is a class that is "mixed into" the single-inheritance class hierarchy. It's a
      very useful way to provide more than one effective superclass. Technically, making a class a
      mixin adds the ability to use the class in the "inherit" option of another class lower down
      the class hierarchy. In all other respects the mixin is a normal class.</para>
    <para>In Exercise 8, the ooRexx mixin facility is used to provide a single "View" mixin class.
      However, we also want <computeroutput>View</computeroutput> effectively to be a subclass of
        <computeroutput>Component</computeroutput>. There are at least two ways of achieving this.
      The solution used here is to make <computeroutput>Component</computeroutput> a mixin as well.
      As long as <computeroutput>View</computeroutput> and
        <computeroutput>Component</computeroutput> do not have the same method names, then all will
      be well. The resulting class hierarchy is as follows: <figure id="fig0802">
        <title>Exercise08 Class Structure</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter08-Image2.jpg" scale="70"/>
          </imageobject>
        </mediaobject>
      </figure>Solid lines are normal "subclass" lines, while dotted lines are mixin "inherits".
      The ooRexx class definitions required for the <computeroutput>Customer</computeroutput>
      business component to operate with the two mixins is as follows (with unnatural spacing to
      show differences more clearly): <programlisting><![CDATA[  ::CLASS Component                          PUBLIC MIXINCLASS Object

   ::CLASS View                               PUBLIC MIXINCLASS PlainBaseDialog

   ::CLASS Model         SUBCLASS Object      PUBLIC INHERIT Component

   ::CLASS GenericFile   SUBCLASS Object      PUBLIC INHERIT Component

   ::CLASS CustomerView  SUBCLASS RcDialog    PUBLIC INHERIT Component View 

   ::CLASS CustomerModel SUBCLASS Model       PUBLIC

   ::CLASS CustomerData  SUBCLASS GenericFile PUBLIC]]>    </programlisting>In summary, to comply
      with MVF, a View application component "inherits" both <computeroutput>View</computeroutput>
      and <computeroutput>Component</computeroutput>, while a Model or Data component inherits only
        <computeroutput>Component</computeroutput>.</para>
  </section> 
  
  <!-- *********************************************************************************************** -->
  <section id="chap08-usingMVF" xreflabel="MVF Re-Factoring"><title>Using the MVF</title>  <!-- Section 8.4 -->
    <para>For the application developer, using the revised MVF is very simple, as follows.</para>
    <para>For <emphasis role="italic"><emphasis role="bold">View</emphasis></emphasis> components
      such as <computeroutput>CustomerView.rex</computeroutput>:</para>
    <itemizedlist>
      <listitem><para>Add to the start of the *.rex file:<programlisting>     <![CDATA[  ::REQUIRES "Support\View.rex"
        ::REQUIRES "Support\Component.rex"]]></programlisting></para></listitem>
      <listitem><para>Make the view class statement to sublass from <computeroutput>View</computeroutput> instead of
          from <computeroutput>RcView</computeroutput>, <computeroutput>ResView</computeroutput>, or
            <computeroutput>UdView</computeroutput>.</para></listitem>
      <listitem><para>Add to the end of the <computeroutput>::CLASS</computeroutput> statement
        <computeroutput>INHERIT View Component</computeroutput>.</para></listitem>
      <listitem><para>In the <computeroutput>init</computeroutput> method, immediately after
         <computeroutput>forward class (super) continue</computeroutput>", add
         <computeroutput>self~initView</computeroutput>. This ensures that the View mixin is 
         properly initialized (just supering <computeroutput>init</computeroutput> results in a run-time error.</para></listitem>
    </itemizedlist>
    <para>For <emphasis role="bold"><emphasis role="italic">Model</emphasis></emphasis> and
        <emphasis role="italic"><emphasis role="bold">Data</emphasis></emphasis> components, there's
      no change; merely ensure there's
      a<programlisting>     <![CDATA[  ::REQUIRES "Support\Model.rex"]]></programlisting>at the
      start of any Model program file, and
      a<programlisting>     <![CDATA[  ::REQUIRES "Support\GenericFile.rex"]]></programlisting> at
      the start of any Data program file. </para>  <!-- End of 8.4.2 -->
  </section>  <!-- End of 8.4 -->
 
  <!-- *********************************************************************************************** -->  
   <section id="chap08-eventMgmt" xreflabel="Event Management">  <!-- Section 8.5-->
   <title>Event Management</title>
   <para>If an Order Form is open when the Order Management application is closed, then the process
      hangs. The reason for this is that the OrderForm's control dialogs must be cleaned up
      explicitly when the Order Form dialog is closed - else the control dialogs are left in limbo,
      and the process cannot close. The solution is to tell all Order Form dialogs to close when the
      user closes the application (that is, when the Order Management dialog is closed). But how
      should this be done? Somehow, all active Order Form dialogs must be told about the
      "application close" event so they can clean up the two control dialogs.</para>
    <para>One solution is for the Order Management dialog to tell each Order Form that the
      application is about to close. Perhaps the Order Management dialog could inquire of the Object
      Manager as to which Order Form dialogs exist, and then send each of them a "close now"
      message. However, a more elegant solution - and one that has much wider potential use - is to
      provide an event management framework. </para>
    <para>A simple event management framework (EMF) is introduce in Exercise 8. The object that
      keeps track of events and who's interested in them is the Event Manager (the file
        <computeroutput>EventMgr.rex</computeroutput> in the
        <computeroutput>Support</computeroutput> folder). The code that "talks" directly to the
      Event Manager is in the <computeroutput>Component</computeroutput> mixin. Application-level
      components merely super event requests, and <computeroutput>Component</computeroutput> does
      the rest.</para>
     <para>The EMF works like this. First, a component (such as the Order Form) decides that it's
      interested in some event - say "AppClosing". When this event occurs, it wants to be sent a
      message so that it can take appropriate action. To express its interest, the component sends
      itself (most usually from its <computeroutput>activate</computeroutput> method ) a
        <computeroutput>registerInterest</computeroutput> message. This has two parameters - the
      event in which it's interested and its object id (i.e. <computeroutput>self</computeroutput>)
      as follows:
      <programlisting><![CDATA[   self~registerInterest("appClosing", self)]]>      </programlisting>This
      message is handled by the <computeroutput>Component</computeroutput> mixin, which forwards the
      message to a "manager" object called the "Event Manager"
        (<computeroutput>EventMgr.rex</computeroutput> in the
        <computeroutput>Exercise08\Support</computeroutput> folder).<footnote>
        <para>Events handled by the Event Manager should not be confused with events generated by
          ooDialog, such as menu selection events.</para>
      </footnote> The Event Manager adds the event to its directory of events. Each index is the
      event name, and each item is an array of objects that have expressed interest in that event.
      Some time later, when the Order Manager dialog is being closed, it asks for the event
      "appClosing" to be triggered:
      <programlisting><![CDATA[   self~triggerEvent("appClosing")]]></programlisting>The
        <computeroutput>Component</computeroutput> mixin sends this to the Event Manager which then
      sends a <computeroutput>notify</computeroutput> message to each component that has registered
      interest in this event. Note that this simple event management framework is fairly generic,
      and can be used for any event by any component. The only constraint is that event names should
      be unique. For example, registering an "AppClosing" event to signal that a dialog is opening
      is likely to have unfortunate consequences (although the Event Manager will be quite happy).  </para>
   </section>
  
  <!-- *********************************************************************************************** -->
  <section id="chap08-orderForm"><title>The Order Form</title> <!-- Section 8.6 -->
    <!--  - added an ok method to catch enter key.
          - use event management for control of close (else hangs)  - see section chap08-eventMgmt
          - added open Product when dbl-click on a line in Order Details.
          
     OrderForm - added function:  
     a. Can now select products and customer and tot up totals.
     b. Dbl-click on order line surfaces the product. 
     c. "Saving" the OrderForm when complete (but this needs write to file which may not be in Ex8!)
     d. Drag/drop (see item 5)
     
    -->
    <para>xxx</para>
  </section>
  
</chapter>
