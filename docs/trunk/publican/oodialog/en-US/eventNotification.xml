<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "oodialog.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog Reference XML file.
    #
    # Copyright (c) 2005-2012, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<section id="clsEventNotification"><title>EventNotification Mixin Class</title>
<indexterm><primary>EventNotification class</primary></indexterm>
<para>
  The event notification class is a <emphasis role="italic">Mixin</emphasis> class that contains methods that connect
  the notification of a Windows <xref linkend="ovvEvents"/> sent to the
  underlying (<xref linkend="ovvUnderlying" />) dialog with a method in the Rexx dialog object. Except as noted below, the
  Rexx programmer adds the method to her dialog subclass. Once the event notification is connected, each time the event
  occurs, the connected method is invoked. The programmer codes the method to take the appropriate action for the event.
</para>
<para>
  In the Windows user interface, as the user interacts with the system, events are generated that specify what the
  action of the user was. Mouse clicks, keyboard presses, moving or sizing windows, all generate events.
</para>
<para>
  Some simple examples of how this works:
<itemizedlist>
<listitem>
<para>
  Push buttons notify their parent dialog of a number of events. The programmer connects one of these events to a method
  in his Rexx dialog. Typically the CLICKED event is connected. Then, the connected method is called each time the
  button is pressed (clicked.)
</para>
</listitem>
<listitem>
<para>
  List boxes, multiple-select list boxes, and combo boxes can be connected to a method that is called each time a line
  in the list box or combo box is selected.
</para>
</listitem>
<listitem>
<para>
  For a scroll bar, the programmer can specify different methods that are called depending on the user action. The user
  can click on the arrow buttons, drag the thumb, or use the page down / page up keys. Each of these events can be
  connected to a method in the Rexx dialog.
</para>
</listitem></itemizedlist>
</para>
<para>
  Whenever a dialog object is instantiated, the ooDialog framework
  automatically (<xref linkend="sctStandardEventMethods" />) makes several event connections. For all other events the Rexx
  programmer, usually, needs to specifically connect the event to his dialog, through one of the event notification
  methods, to be able to respond to the event. In a <xref linkend="clsUserDialog"/>, some of the methods
  that create dialog controls have an option that automatically connects an event to a dialog method. But, for most
  events, say the resize or move events, the connection needs to be made explicitly.  Indeed, except for trivial
  dialogs, most of the programming is deciding which events to be notified of and taking action upon receiving the
  notification.
</para>
<para id="paraWhereToConnectEvents">
  In general, events should be connected before the dialog is shown on the screen, or immediately after the dialog is
  created. There is no reason why the programmer can not place the invocation where ever it makes the most sense.
  Connecting the events in the <xref linkend="mthInitDialog"/>() method is usually sufficient. In a
  <computeroutput>UserDialog</computeroutput>, the <xref linkend="mthDefineDialog"/>() method also
  makes a good place for the connect event methods. If the programmer is overriding the <emphasis
  role="italic">init</emphasis>() method, the connect event methods can be placed there.  In this case, do not invoke
  the connect event method until <emphasis role="bold">after</emphasis> the
 <xref linkend="mthNewDialogObject"/> has been initialized.
</para>

<section id="sctCodingEventHandlers"><title>Coding Event Handlers</title>
<indexterm><primary>coding event handlers</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>coding event handlers</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>coding event handlers</secondary></indexterm>

<para>
  The methods in a Rexx dialog object connected to Windows event notifications are commonly called event handlers
  because the method handles the event. In order to properly code an event handler, the Rexx programmer needs to
  understand somewhat the underlying mechanism of event notification. This is particularly important in ooDialog 4.2.0
  and later with its ability to directly (<xref linkend="ovvEventsDirectReply" />) invoke the event handling method
  from the window message (<xref linkend="ovvWindowMessages" />) processing loop.
</para>
<para>
  When the operating system sends an event notification to the underlying dialog, the operating system waits for a reply
  to the notification in the message processing loop. This is significant because while the operating system is
  waiting, in general, other messages can not be processed by the window. If an application does not reply in a timely
  manner to the notification messages, it can cause the application to appear hung. With today's fast processors there
  are plenty of CPU cycles for an event handler to process and reply to event notifications. But, if an application were
  to do something like sleep for 10 seconds in an event handler, the user would think the application was hung.
</para>
<para>
  Prior to ooDialog 4.2.0, the ooDialog framework could not directly invoke the event handling method in the Rexx dialog
  object. To invoke the method, the framework used a cumbersome process involving queues and interpret. In the message
  processing loop, the framework essentially queued up the method to be invoked <emphasis role="italic">at some later
  time</emphasis> and replied immediately to the notification. Because of this, the event handling method could not
  reply to the event notification, and in fact any return was simply lost. This meant much of the capability of a
  Windows dialog was unavailable. It also meant it did not matter if the method returned in a timely manner.
</para>
<para>
  With ooDialog 4.2.0 and later, the event handling method in the Rexx dialog object is invoked by the interpreter
  directly from the message processing loop in the underlying Windows dialog. This allows the Rexx programmer
  to return (<xref linkend="exampleEventHandler1" />) a value to the notification, to
  synchronize (<xref linkend="exampleEventHandler1" />) the handling of notifications, or to
  veto (<xref linkend="exampleEventHandler3" />) an event. Remember, with this direct invocation of the event handling
  methods, the interpreter is waiting in the message processing loop for the return from the method. Therefore, the
  programmer needs to return from the method in a reasonable amount of time. Do not be overly worried about this, the
  interpreter processes a large number of statements in a very short time. There is adequate time to process and return
  a value in the event handler.
</para>
<para>
  However, having the interpreter waiting for the return of an event handling method could conceivably be a problem for
  some few existing programs. Since, in older ooDialog versions, the return from an event handler method was
  meaningless, some programmers may not have returned from the method in a timely manner, and never realized this was a
  mistake. In addition, there are a large number of event notifications in Windows where the operating system ignores
  the reply. Therefore, the ooDialog framework uses two different ways to invoke the event handling method. The first,
  preferred, method is for the interpreter to invoke the method directly, wait for the return, and then use the return
  to reply to the Windows event notification. The second is to invoke the event handling method using the <emphasis
  role="italic">startWith</emphasis>() method of the <computeroutput>Object</computeroutput> class. This starts the
  event handling method concurrently, and the ooDialog framework replies to the Windows event notification immediately.
</para>
<para>
  In general, whether the ooDialog framework invokes the event handling method and waits for the return, or uses
  <emphasis role="italic">startWith</emphasis>() and replies to the Windows event notification immediately is determined
  using these rules:
</para>
<orderedlist>
<listitem>
<para>
  Event connections made using the event connection methods that existed prior to ooDialog 4.2.0, using the existing
  event keywords, and existing arguments, use <emphasis role="italic">startWith</emphasis> to invoke the event handlers.
  The programmer can not change this. For the purpose of this discussion, these methods will be called existing
  connection methods.
</para>
</listitem>
<listitem>
<para>
  All event connections made using event connection methods introduced after ooDialog 4.1.0 assume the programmer wants
  the event handler invoked directly and for the ooDialog framework to wait for the return. These methods will be called
  new connection methods. For instance, the date <xref linkend="clsDateTimePicker"/> picker control did not
  exist in ooDialog 4.1.0, so its event connection method,
 <xref linkend="mthConnectDateTimePickerEvent"/> falls into this category.
</para>
</listitem>
<listitem>
<para>
  For new connection methods, when the reply to an event notification has a meaning for the notification, the framework
  always invokes the event handler directly and waits for the return. The programmer can not change this. If the
  programmer does not want to reply to the event, then he should simply not connect the event.
</para>
</listitem>
<listitem>
<para>
  All new connection methods have an optional argument that allows the programmer to specify whether she wants the
  framework to wait for the return, or use <emphasis role="italic">startWith</emphasis> and reply immediately. When the
  reply to an event is ignored by the operating system, the optional argument will be used to direct the framework to
  invoke the event handler directly or use <emphasis role="italic">startWith</emphasis>. By default, the framework
  invokes the connected method directly.
</para>
</listitem>
<listitem>
<para>
  Over time, the existing connections will be enhanced to also take an optional argument. This will allow the
  programmer to specify that the framework invoke the event handler directly and wait for the return. This enhancement
  has started, but is far from complete.
</para>
</listitem>
<listitem>
<para>
  The documentation for each event connection method, for each event, will specify how the event handler will be
  invoked.
</para>
</listitem>
</orderedlist>

<para>
  The following code snippets and examples expand on these details.
</para>
<para>
  Best practice would be to always code event handlers as if they are expected to return a value to the operating
  system's event notification message. The considerations would be that the method does not block and that a value is
  returned to the operating system in a reasonable amount of time. In general, the event handler should be unguarded to
  preclude the possibility that some guarded method in the dialog object is executing at the time the event notification
  is generated.
</para>
<para>
  Below is a code snippet for an application that displays the current date and time, with a push button that refreshes
  the display. Note these points about the code snippet. Since the <emphasis role="italic">connectButtonEvent</emphasis>
  method is the replacement for the deprecated (<xref linkend="ovvDeprecated" />) <emphasis
  role="italic">connectButtonNotify</emphasis> it is in essence an existing connection method, using the original
  arguments. Therefore, the method is invoked from the message processing loop using <emphasis
  role="italic">startWith</emphasis>. Because of this, technically, it does not have to be unguarded and does not have
  to return a value. Nevertheless, it is the <emphasis role="italic">correct</emphasis> way to code the event handler.
<programlisting>
<![CDATA[
::method initDialog
  ...
  self~connectButtonEvent(IDC_PB_REFRESH, "CLICKED", updateTime)
  ...

::method updateTime unguarded
  use arg info, hwnd

  now = .DateTime~new
  self~refreshDisplay(now)
  return 0

]]>
</programlisting>

</para>
<para>
  Consider this snippet from a similar program, but where the push button starts a process that calculates the grains of
  sand in the universe. Since it is not expected that the calculation will finish in a reasonable amount of time, an
  early reply is used to return a value in a timely manner. The handler also disables the push button so tha the user
  can not start a second calculation until the first calculation finishes.
<programlisting>
<![CDATA[
::method initDialog
  ...
  self~connectButtonEvent(IDC_PB_CALC_SAND, "CLICKED", onCalculateGrains)
  ...

::method onCalculateGrains unguarded
  use arg info, hwnd

  self~newPushButton(IDC_PB_CALC_SAND)~disable
  reply 0

  number = self~calculateSandInUniverse
  self~refreshDisplay(number)
  self~newPushButton(IDC_PB_CALC_SAND)~enable
  return

]]>
</programlisting>

</para>
<para>
  The following examples are all for events where the event handler must return a value.
</para>
<variablelist>
  <varlistentry id="exampleEventHandler1"><term><emphasis role="bold">Returning Values</emphasis></term>
  <listitem>
  <para>
    The month <xref linkend="clsMonthCalendar"/> control has the
    GETDAYSTATE (<xref linkend="evtMonthCalendarGETDAYSTATE" />) event that is sent to request information on how certain
    days are to be shown. The programmer can customize the calendar by returning a set of days that should be displayed
    in bold. For instance, in a business application paid holidays could be displayed in bold.
  </para>
  <para>
    Since the <emphasis role="italic">connectMonthCalendarEvent</emphasis> method did not exist in ooDialog 4.1.0 and
    the return value for this event is meaningful, the second and third rules above apply.  That is, the interpreter
    invokes the event handler directly, waits for the reply, and the programmer can not change this behavior.
  </para>

<programlisting>
<![CDATA[

::method initDialog
  expose calendar

  calendar = self~newMonthCalendar(IDC_MC_HOLIDAYS)

  -- Connect the GETDAYSTATE event.
  self~connectMonthCalendarEvent(IDC_MC_HOLIDAYS, "GETDAYSTATE", onGetDayState)

  -- Restrict the calendar so that it only displays the year 2011.
  start = .DateTime~fromStandardDate("20110101")
  end = .DateTime~fromStandardDate("20111231")

  ...

::method onGetDayState unguarded
  expose calendar
  use arg startDate, count

  -- Create the array to hold the .DayState objects.
  dayStates = .array~new(count)

  month = startDate~month
  if month == 12 then month = 0

  do i = 1 to count
    j = month + i - 1

    select
      when j ==  1 then dayStates[i] = .DayState~new(17)
      when j ==  2 then dayStates[i] = .DayState~new(21)
      when j ==  3 then dayStates[i] = .DayState~new
      when j ==  4 then dayStates[i] = .DayState~new
      when j ==  5 then dayStates[i] = .DayState~new(30)
      when j ==  6 then dayStates[i] = .DayState~new
      when j ==  7 then dayStates[i] = .DayState~new(4)
      when j ==  8 then dayStates[i] = .DayState~new
      when j ==  9 then dayStates[i] = .DayState~new(5)
      when j == 10 then dayStates[i] = .DayState~new
      when j == 11 then dayStates[i] = .DayState~new(24, 25)
      when j == 12 then dayStates[i] = .DayState~new(23, 30)
      otherwise dayStates[i] = .DayState~new()
    end
  end

  buffer = .DayStates~makeDayStateBuffer(dayStates)
  return buffer

]]>
</programlisting>
  </listitem></varlistentry>
  <varlistentry id="exampleEventHandler2"><term><emphasis role="bold">Event Synchronization</emphasis></term>
  <listitem>
  <para>
    The <xref linkend="clsDateTimePicker"/> (date time picker) control has the
 <xref linkend="mthConnectDateTimePickerEvent"/> event notification that is sent when the drop down calendar
    is shown. This gives the programmer a chance to customize the month calendar that is shown. Since the month calendar
    is not shown until the event handling method returns, replying directly to the notification allows the programmer to
    completely finish the customizations before the month calendar appears on the screen.
  </para>

<programlisting>
<![CDATA[

::method initDialog

  self~connectDateTimePickerEvent(IDC_DTP, "DROPDOWN", onDropDown)
  ...


::method onDropDown unguarded
  use arg idFrom, hwndFrom

  dt = self~newDateTimePicker(IDC_DTP);
  monthCal = dt~getMonthCal
  monthCal~setFirstDayOfWeek(3)
  monthCal~addStyle("NOTODAY")

  return 0

]]>
</programlisting>
  <para>
    In the above example, the <emphasis role="italic">connectDateTimePickerEvent</emphasis> method did not exist in
    ooDialog 4.1.0, but the return value for this event is ignored by the OS. Therefore, the second and fourth rules
    above apply. That is, by default the interpreter invokes the event handler directly and waits for a reply. However
    the programmer can change this behavior if he wants. If there is no reason to have the interpreter wait until the
    event handler finishes, then the programmer could use the fourth optional argument. The
    <computeroutput>.false</computeroutput> value tells the ooDialog framework to use the <emphasis
    role="italic">startWith</emphasis> method to invoke the event handler.
  </para>

<programlisting>
<![CDATA[

::method initDialog

  self~connectDateTimePickerEvent(IDC_DTP, "DROPDOWN", onDropDown, .false)
  ...


::method onDropDown unguarded
  expose userDidSeeCalendar
  use arg idFrom, hwndFrom

  userDidSeeCalendar = .true

]]>
</programlisting>
  </listitem></varlistentry>
  <varlistentry id="exampleEventHandler3"><term><emphasis role="bold">Veto Events</emphasis></term>
  <listitem>
  <para>
    The <xref linkend="clsTab"/> control has the <xref linkend="mthConnectTabEvent"/> event.
    It is sent when the user selects a different tab, and is sent <emphasis role="bold">before</emphasis> the selected
    tab is changed. The programmer can <emphasis role="italic">veto</emphasis> the change to a new tab by returning
    <computeroutput>.false</computeroutput> to the event notification, or allow the change by returning
    <computeroutput>.true</computeroutput>. One reason for preventing the change might be that the user had entered
    invalid data in the current tab page.
  </para>
  <para>
    <emphasis role="bold">Note:</emphasis> Since the <emphasis role="italic">connectTabEvent</emphasis> method is the
    replacement for the <emphasis role="italic">ovvDeprecated</emphasis> <emphasis
    role="italic">connectTabNotify</emphasis> method, it essentially is a method that existed in ooDialog 4.1.0. The
    above rules one and five apply. That is, when the same arguments are used as existed in 4.1.0, the event handler is
    invoked using <emphasis role="italic">startWith</emphasis> and the interpreter does not wait for a return value.
    With this behavior, it is impossible for the programmer to veto the change to a new tab. Therefore the programmer
    has to use the fourth optional argument to change the default behavior. Specifying
    <computeroutput>.true</computeroutput> causes the ooDialog framework to invoke the <emphasis
    role="italic">onTabChanging</emphasis> method directly and wait for the return value.
  </para>
<programlisting>
<![CDATA[

::method defineDialog

  self~connectTabEvent(IDC_TAB, SELCHANGING, onTabChanging, .true)

::method onTabChanging unguarded
  expose tabContent
  use arg idFrom, hwndFrom

  index = self~newTab(idFrom)~selectedIndex + 1
  dlg = tabContent[index]

  if dlg~validate then return .true
  else return .false

]]>
</programlisting>
  <para>
    In the above example, since the <emphasis role="italic">validate</emphasis> method is returning
    <computeroutput>.true</computeroutput> or <computeroutput>.false</computeroutput> the event handler could have been
    coded this way:
  </para>
<programlisting>
<![CDATA[
::method onTabChanging unguarded

  ...

  return dlg~validate
]]>
</programlisting>
  <para>
    The example used:
<programlisting>
<![CDATA[
  if dlg~validate then return .true
  else return .false
]]>
</programlisting>
    to emphasize that the event handler needs to return <computeroutput>.true</computeroutput> or
    <computeroutput>.false</computeroutput>.
  </para>
  </listitem></varlistentry>
  <varlistentry id="exampleEventHandler4"><term><emphasis role="bold">Lengthy Processing</emphasis></term>
  <listitem>
  <para>
    As previously noted, the Rexx programmer does not need to be overly worried about taking to much time to return a
    value from an event handler. In most very case there is plenty of time to process the event and return a value.
    However, sometimes the programmer may want to, or need to, do some lengthy processing in the event handler. For
    these cases, the programmer needs to figure out how to return a value from the event handler and also do the needed
    processing. This is really a <emphasis role="italic">concurrency</emphasis> problem, not an event handling problem.
  </para>
  <para>
    The two common ways to solve this problem would be to use an <emphasis role="italic">early reply</emphasis> or to
    start a <emphasis role="italic">second activity</emphasis> running to do the processing. Using the
    onTabChanging (<xref linkend="exampleEventHandler3" />) event handler above, here are two typical ways to handle the
    event when some lengthy processing is involved. As a hypothetical, say that when the user changes to a new tab, the
    program needs to gather up all the data on the validated page and write it to disk, or send it somewhere. One
    approach would be to validate the page, do an early reply, and then finish up the processing:
  </para>
<programlisting>
<![CDATA[

::method defineDialog

  self~connectTabEvent(IDC_TAB, SELCHANGING, onTabChanging, .true)

::method onTabChanging unguarded
  expose tabContent
  use arg idFrom, hwndFrom

  index = self~newTab(idFrom)~selectedIndex + 1
  dlg = tabContent[index]

  if \ dlg~validate then return .false  -- Tab will not be changed

  reply .true  -- Tab is changed for the user.

  -- Now gather up the data entered on the page we just switched from.
  data = dlg~getUserDataDirectory
  self~writeDataToFile(data)

]]>
</programlisting>
  <para>
    Another approach could be to start a new activity which will run concurrently. It might be coded this way:
  </para>
<programlisting>
<![CDATA[
::method onTabChanging unguarded
  expose tabContent
  use arg idFrom, hwndFrom

  index = self~newTab(idFrom)~selectedIndex + 1
  dlg = tabContent[index]

  if dlg~validate then do
    dp = .DataProcesser~new
    dp~start("processDlgData", dlg)
    return .true
  end
  else do
    return .false
  end
]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="sctMethodsEventNotification"><title>Method Table</title>
<para>
  The following table list the methods of the <computeroutput>EventNotification</computeroutput> class:
</para>
<table id="tblEventNotificationMethods" frame="all">
<title>EventNotification Methods</title>
<tgroup cols="2">
<colspec colwidth="1*" />
<colspec colwidth="3*" />
<thead>
<row>
<entry>Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry><xref linkend="mthAddUserMsg"/></entry>
<entry>Connects an operating system window message with a method in the Rexx dialog object.</entry>
</row>
<row>
<entry><xref linkend="mthConnectActivate"/></entry>
<entry>Connects the window activation event to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectAllSBEvents"/></entry>
<entry>Connects all event notifications from a scroll bar control to a single method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectButtonEvent"/></entry>
<entry>Connect an event notification from a button control to a method in the Rexx Dialog</entry>
</row>
<row>
<entry><xref linkend="mthConnectComboBoxEvent"/></entry>
<entry>Connects an event notification from a combo box to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectCommandEvents"/></entry>
<entry>Connects a command event notification from a dialog control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectDateTimePickerEvent"/></entry>
<entry>Connects an event notification form a date time picker to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectDraw"/></entry>
<entry>Connects the draw item event notification to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectEachSBEvent"/></entry>
<entry>Connects each specified event notification from a scroll bar to a separate method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectEditEvent"/></entry>
<entry>Connects an event notification from an edit control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectFKeyPressDialogObject"/></entry>
<entry>Connects a F Key key press (a F key is typed) with a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectHelp"/></entry>
<entry>Connects the Windows Help event to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectKeyPressDialogObject"/></entry>
<entry>Connects a key press (a key is typed) with a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectListBoxEvent"/></entry>
<entry>Connects an event notification from a list box control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectListViewEvent"/></entry>
<entry>Connects an event notification from a list-view control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectMonthCalendarEvent"/></entry>
<entry>Connects an event notification from a month calendar to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectMove"/></entry>
<entry>Connects the move event notification to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectNotifyEvent"/></entry>
<entry>Connects a generic event notification from a dialog control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectPosChanged"/></entry>
<entry>Connects the position has changed event notification to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectResize"/></entry>
<entry>Connects the size event notification to a method in the Rexx dialog</entry>
</row>
<row>
<entry><xref linkend="mthConnectResizing"/></entry>
<entry>Connects the sizing event notification to a method in the Rexx dialog</entry>
</row>
<row>
<entry><xref linkend="mthConnectScrollBarEvent"/></entry>
<entry>Connects an event notification from a scroll bar control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectSizeMoveEnded"/></entry>
<entry>Connects the size / move ended event notification to a method in the Rexx dialog object.</entry>
</row>
<row>
<entry><xref linkend="mthConnectStaticEvent"/></entry>
<entry>Connects an event notification from a static control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectTabEvent"/></entry>
<entry>Connects an event notification from a tab control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectTrackBarEvent"/></entry>
<entry>Connects an event notification from a track bar control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectTreeViewEvent"/></entry>
<entry>Connects an event notification from a tree view control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectUpDownEvent"/></entry>
<entry>Connects an event notification from an UpDown control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthDefListDragHandler"/></entry>
<entry>Default implementation of a drag and drop handler for a list-view control.</entry>
</row>
<row>
<entry><xref linkend="mthDefTreeDragHandler"/></entry>
<entry>Default implementation of a drag and drop handler for a tree view control.</entry>
</row>
<row>
<entry><xref linkend="mthDisconnectKeyPressDialogObject"/></entry>
<entry>Disconnects a method that was previously connected to key press event.</entry>
</row>
<row>
<entry><xref linkend="mthHasKeyPressConnectionDialogObject"/></entry>
<entry>Queries if a connection to a key press event already exists.</entry>
</row>
</tbody></tgroup>
</table>
</section>

<section id="mthAddUserMsg" xreflabel="addUserMsg"><title>addUserMsg</title>
<indexterm><primary>addUserMsg</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>addUserMsg</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>addUserMsg</secondary></indexterm>
<programlisting>
<![CDATA[
>>--addUserMsg(-rxMsg-,-winMsg-+------+-+------+-+------+-+------+-+------+-)--><
                               +-,-f1-+ +-,-wP-+ +-,-f2-+ +-,-lP-+ +-,-f3-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">addUserMsg</emphasis> method connects a Windows window
  message (<xref linkend="ovvWindowMessages" />) sent to the underlying (<xref linkend="ovvUnderlying" />) dialog with a
  method in the Rexx dialog. This method is designed to be used by ooDialog programmers who are familiar with the
  Windows API. It's use will require access to the Windows documentation (<xref linkend="defWindowsDoc" />) at a
  minimum, and will likely also require access to the Windows header files in the
  Windows platform SDK (<xref linkend="defPlatformSDK" />).
</para>
<para>
  Internally, ooDialog examines every window message the Windows dialog receives. If the window message matches the
  arguments specified to <emphasis role="italic">addUserMsg</emphasis>, ooDialog invokes the method specified by
  <emphasis role="italic">rxMsg</emphasis>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    All arguments, except for <emphasis role="italic">rxMsg</emphasis>, represent non-negative whole numbers. For
    convenience, the programmer can either use the numeric value for these argument, or the numbers can be expressed in
    conventional hexadecimal (<xref linkend="defConventionalHex" />) format.
  </para>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>rxMsg [required]</term>
      <listitem>
      <para>
        The method in the Rexx dialog to invoke when, or if, the window message, <emphasis
        role="italic">winMsg</emphasis> is sent to the underlying dialog.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>winMsg [required]</term>
      <listitem>
      <para>
        The numeric value of the window message to match.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>f1 [optional]</term>
      <listitem>
      <para>
        A filter to apply to the <emphasis role="italic">winMsg</emphasis>. The filter is bitwise <emphasis
        role="italic">anded</emphasis> with <emphasis role="italic">winMsg</emphasis> and if the result equals <emphasis
        role="italic">winMsg</emphasis>, it is considered a match. If omitted a filter of 0xFFFFFFFF is used.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>wP [optional]</term>
      <listitem>
      <para>
        The numeric value of the WPARAM (<xref linkend="ovvWindowMessages" />) parameter in the window message to
        match. This defaults to 0.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>f2 [optional]</term>
      <listitem>
      <para>
        A filter to apply to the <emphasis role="italic">wP</emphasis> argument. The filter is bitwise <emphasis
        role="italic">anded</emphasis> with <emphasis role="italic">wP</emphasis> and if the result equals <emphasis
        role="italic">wP</emphasis>, it is considered a match. If omitted a filter of 0 is used.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>lP [optional]</term>
      <listitem>
      <para>
        The numeric value of the LPARAM (<xref linkend="ovvWindowMessages" />) parameter in the window message to
        match. This defaults to 0.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>f3 [optional]</term>
      <listitem>
      <para>
        A filter to apply to the <emphasis role="italic">lP</emphasis> argument. The filter is bitwise <emphasis
        role="italic">anded</emphasis> with <emphasis role="italic">lP</emphasis> and if the result equals <emphasis
        role="italic">lP</emphasis>, it is considered a match. If omitted a filter of 0 is used.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return value is 0 for success and 1 for failure.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method is not intended for every ooDialog programmer. In particular, it requires some understanding of window
    messages, the message parameters, and bitwise and. If the ooDialog programmer does not know what a bitwise and is,
    that is a good indication that this method is not for them.
  </para>
  <para>
    Details for all window messages and their parameters are available in the Windows
    documentation (<xref linkend="defWindowsDoc" />). The numeric value of the message IDs (and possibly the message
    parameters) can be looked up in the Windows platform SDK (<xref linkend="defPlatformSDK" />).
  </para>
  <para>
    In all cases, it is preferable to use specific connect event methods provided by ooDialog.  Such as
 <xref linkend="mthConnectEditEvent"/>, <xref linkend="mthConnectResize"/>, etc..
    <emphasis role="italic">addUserMsg</emphasis> is provided for those cases where the specific connect event method
    the programmer needs is not present in ooDialog.
  </para>
  <para>
    Note that the arguments the event handling method receives will be the numeric value of the WPARAM and LPARAM
    parameters for the window message. If either WPARAM or LPARAM are pointers, the numeric value will not do the
    ooDialog programmer any good. There is no way in ooDialog Rexx code to access whatever the pointer points to. (The
    exception to this would be if ooDialog already had a connect event method for the specific window message. In which
    case there is no need to use <emphasis role="italic">addUserMsg</emphasis>.)
  </para>
  <para>
    Filters can be used to ensure that only the specific message desired is connected to the Rexx method, or to match
    several messages and connect them to the same Rexx method.
  </para>
  <para>
    Take the window messages WM_KEYDOWN (0x0100) and WM_KEYUP (0x0101.) When
<programlisting>
<![CDATA[

  winMsg == '0x0100'
  f1     == '0xFFFF'
  addUserMsg('onKeyDown', winMsg, f1, 0, 0, 0, 0)

]]>
</programlisting>
    only the WM_KEYDOWN message will match and <emphasis role="italic">onKeyDown</emphasis> is only invoked for that
    message.
  </para>
  <para>
    However, when
<programlisting>
<![CDATA[

  winMsg == '0x0100'
  f1     == '0xFFFE'
  addUserMsg('onKey', winMsg, f1, 0, 0, 0, 0)

]]>
</programlisting>
    both the WM_KEYDOWN and WM_KEYUP messages will match and the <emphasis role="italic">onKey</emphasis> method will be
    invoked for either window message.
  </para>
  <para>
    In a similar fashion, both the LBN_SETFOCUS (0x4) and the LBN_KILLFOCUS (0x5) notifications are sent to a list box
    using the WM_COMMAND (0x0111) message.  For the WM_COMMAND message, the WPARAM parameter contains the control ID in
    the low word of the parameter and the notification code in the high word of the parameter.
  </para>
  <para>
    Say the list box control has an ID of 256 (0xFF,) when
<programlisting>
<![CDATA[

  winMsg == '0x0111'
  f1     == '0xFFFF'

  wP     == '0x000400FF'
  f2     == '0xFFFFFFFF'
  addUserMsg('onSetFocus', winMsg, f1, wP, f2, 0, 0)

]]>
</programlisting>
   only the LBN_SETFOCUS notification sent to the list box with ID of 256 will invoke the <emphasis
   role="italic">onSetFocus</emphasis> method.
  </para>
  <para>
   However, in this case
<programlisting>
<![CDATA[

  winMsg == '0x0111'
  f1     == '0xFFFF'

  wP     == '0x000400FF'
  f2     == '0xFFFEFFFF'
  addUserMsg('onFocus', winMsg, f1, wP, f2, 0, 0)

]]>
</programlisting>
    both the LBN_SETFOCUS and LBN_KILLFOCUS notifications to the listbox will invoke the <emphasis
  role="italic">onFocus</emphasis> method.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect usage is detected.
  </para>
  </listitem></varlistentry>
  <varlistentry id="exampleAddUserMsg"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The WM_CANCELMODE message is sent to cancel certain modes, such as mouse capture. This example shows how an ooDialog
    program that captures the mouse for some reason could add an event handler for the WM_CANCELMODE message and release
    the mouse if the program had currently captured it. This is a hypothetical situation intended to show how to use the
    <emphasis role="italic">addUserMsg</emphasis> method and not necessarily of any practical value.
<programlisting>
<![CDATA[

::method init
    expose mouseIsCaptured
    ...

    WM_CANCELMODE = '0x001F'
    ret = self~addUserMsg('onCancelMode', WM_CANCELMODE, '0xFFFF', 0, 0, 0, 0)
    if ret == 1 then do
        -- Do some error handling stuff.
        -- But, really this is unlikely to happen.
    end

    mouseIsCaptured = .false


::method doCaptureMouse private
    expose mouseIsCaptured

    self~captureMouse
    mouseIsCaptured = .true

    ...  -- more code


::method onCancelMode unguarded
    expose mouseIsCaptured
    use arg wParam, lParam

    -- For WM_CANCELMODE wParam and lParam have no meaning.

    if mouseIsCaptured then do
        self~releaseMouseCapture
        mouseIsCaptured = .false

        ...  -- maybe some more code
    end

    return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>


<section id="evtAddUserMsg"><title>addUserMsg Event Handler</title>
<indexterm><primary>addUserMsg</primary><secondary>events</secondary><tertiary>generic</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onEvent unguarded
  use arg wParam, lParam

  return 0
]]>
</programlisting>

<para>
  The event handler connected through the <xref linkend="mthAddUserMsg"/> is invoked when ooDialog
  internally matches a message sent to the underlying (<xref linkend="ovvUnderlying" />) Windows dialog using the
  arguments specified by the programmer in the invocation of the <emphasis role="italic">addUserMsg</emphasis> method.
</para>
<para>
  The default behavior is for ooDialog to ignore the return value from the event handler and the interpreter does not
  wait for the return in the message processing loop. Currently, this behavior can not be changed. It is possible
  that a future enhancement may allow the programmer to change the behavior.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives two arguments. However, as noted in the remarks for the
 <xref linkend="mthAddUserMsg"/> this does not hold if ooDialog already has a connect event method for
    the window message. In which case, the programmer should use the existing method, rather than <emphasis
    role="italic">addUserMsg</emphasis>.
  </para>
  <variablelist>
    <varlistentry><term>wParam</term>
    <listitem>
    <para>
      The WPARAM (<xref linkend="ovvWindowMessages" />) parameter to the window message that was connected through
      <emphasis role="italic">addUserMsg</emphasis>. This will be the numeric value of WPARAM and may or may not be of
      use to the programmer depending on the specific window message.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>lParam</term>
    <listitem>
    <para>
      The LPARAM (<xref linkend="ovvWindowMessages" />) parameter to the window message that was connected through
      <emphasis role="italic">addUserMsg</emphasis>. Again, this will be the numeric value of LPARAM and may or may not
      be of use to the programmer depending on the specific window message.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    Currently the return value from the event handler is ignored. A possible future enhancement to <emphasis
   role="italic">addUserMsg</emphasis> may make it possible to return a meaningful value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The example (<xref linkend="exampleAddUserMsg" />) for <emphasis role="italic">addUserMsg</emphasis> shows how a
    typical event handler might be coded.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End Generic Event Handler -->

</section>  <!-- End EventNotification::addUserMsg() -->

<section id="mthConnectActivate" xreflabel="connectActivate"><title>connectActivate</title>
<indexterm><primary>connectActivate</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectActivate</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectActivate</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectActivate(--+--------------+--)--------><
                      +--methodName--+
]]>
</programlisting>

<para>
  Connects an <emphasis role="italic">activate</emphasis> <xref linkend="ovvEvents"/> notification sent to
  the underlying dialog with a method in the Rexx dialog. This event notification is sent to both the window being
  activated and the window being deactivated
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The only argument is:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that is invoked each time the dialog gains or loses the activation. The method name
      can not be the empty string. When this argument is omitted the name defaults to <emphasis
      role="italic">onActivate</emphasis>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The <emphasis role="italic">active</emphasis> window is the <emphasis role="italic">top-level</emphasis> window that
    the user is currently working with. The activate notification is only sent to top-level windows. The activate
    notification is always sent in pairs, one notification to the window losing the activation and one to the window
    gaining the activation. The arguments to the event handler for the notification allow the programmer to determine if
    the window is gaining or losing the activation.
  </para>
  <para>
    Common guidelines on where (<xref linkend="paraWhereToConnectEvents" />) to invoke the <emphasis
    role="italic">connectActivate</emphasis> method and on how (<xref linkend="sctCodingEventHandlers" />)
    to code event handlers are included in the documentation for the
    <xref linkend="clsEventNotification"/> class.
  </para>
  <para>
    The interpreter invokes the event handler directly and waits in the window
    message (<xref linkend="ovvWindowMessages" />) processing loop for the return from the event handler. Connecting the
    activate event requires that the programmer reply to the event from the event handler in a timely manner.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    sizing events happen.
  </para>
  <para>
    The underlying dialog receives the WM_ACTIVATE message as the notification for this event.
  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtACTIVATE"><title>Activate Event Handler</title>
<indexterm><primary>dialog object</primary><secondary>events</secondary><tertiary>ACTIVATE</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onActivate unguarded
  use arg status, hwnd, hFocus, isMinimized

  return .false
]]>
</programlisting>

<para>
  The event handler for the ACTIVATE event is invoked when the dialog window is either losing or gaining the active
  window status.
</para>
<para>
  The programmer must return a value from the event handler and the interpreter waits for the return value from the
  event handler.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives four arguments:
  </para>
  <variablelist>
    <varlistentry><term>status</term>
    <listitem>
    <para>
      A keyword that indicates if the dialog is gaining or losing the activation. The keyword will be exactly one of the
      following:
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>ACTIVE</member> <member>CLICKACTIVE</member> <member>INACTIVE</member>
      </simplelist>
    </para>
    <variablelist>
      <varlistentry><term>ACTIVE</term>
      <listitem>
      <para>
        The dialog is gaining the activation through some means other than the user clicking the mouse on the window.
        For example the user may select the window through the ALT-Tab mechanism.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>CLICKACTIVE</term>
      <listitem>
      <para>
        The dialog is gaining the activation through a mouse click.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>INACTIVE</term>
      <listitem>
      <para>
        The dialog is losing the activation.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window handle (<xref linkend="defHandle" />) of the window being activated or deactivated, depending on the
      <emphasis role="italic">status</emphasis> argument. If the keyword is INACTIVE, then this is the handle of the
      window gaining the activation. If the keyword is ACTIVE or CLICKACTIVE, it is the handle of the window losing the
      activation.
    </para>
    <para>
      <emphasis role="bold">Note</emphasis> that this argument may be 0, indicating the operating system did not pass a
      window handle with the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hFocus</term>
    <listitem>
    <para>
      The window handle of the dialog control with the current focus when the dialog is being deactivated.  When the
      dialog is being activated <emphasis role="italic">hFocus</emphasis> will be 0.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>isMinimized</term>
    <listitem>
    <para>
      Specifies the minimized state of the window being activated or deactivated. <emphasis
      role="italic">isMinimized</emphasis> will be <computeroutput>.true</computeroutput> if the window is minimized,
      otherwise <computeroutput>.false</computeroutput>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The event handler for this notification must return <computeroutput>.true</computeroutput> or
    <computeroutput>.false</computeroutput>. A return of true indicates that the notification has been processed and a
    return of false indicates that the notification has not been processed. When the notification has not been processed
    the interpreter passes the notification on to the operating system for its default processing.
  </para>
  <para>
    The default processing done by the operating system includes things like restoring the focus to the dialog control
    that had the focus when the dialog was deactivated, highlighting the text in an edit control if that control has the
    focus, etc.. Under most circumstances, the programmer should return <computeroutput>.false</computeroutput> to allow
    the dialog manager to perform this default processing. If not, the programmer should take care of these details or
    the dialog may not behave as the user expects.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example comes from code ooDialog uses internally to handle a problem with a
 <xref linkend="clsListView"/> control when it is used in a <xref linkend="clsTab"/> control. When
    the dialog is being inactivated the handle of the focused control is saved. When it is being activated, the handle
    of the last focused control is passed on the to <xref linkend="clsControlDialog"/> that contains
    the list-view for processing.

<programlisting>
<![CDATA[

::method onActivate unguarded
  expose listViewPageDialog lastFocused
  use arg flag, hwnd, hFocused, isMinimized

  reply .false

  if flag == 'INACTIVE' then lastFocused = hFocused
  else listViewPageDialog~updateListView(lastFocused)

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Activate Event Handler -->

</section>

<section id="mthConnectAllSBEvents" xreflabel="connectAllSBEvents"><title>connectAllSBEvents</title>
<indexterm><primary>connectAllSBEvents</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectAllSBEvents(-id-,-mName-+------+-+------+-+-----+-+--------------+-)--><
                                   +-,-mn-+ +-,-mx-+ +-,-p-+ +-,-willReply--+

]]>
</programlisting>

<para>
  Connects all scroll bar events to one method.
</para>
<para>
  This method requires that the underlying (<xref linkend="ovvUnderlying" />) scroll bar exists. Therefore, the method
  is best invoked in the <xref linkend="mthInitDialog"/> method.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:</para>
<variablelist>
<varlistentry><term>id [required]</term>
<listitem><para>The ID of the scroll bar
</para></listitem></varlistentry>
<varlistentry><term>mName [required]</term>
<listitem><para>The method that is invoked for all events sent by the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>mn, mx [optional]</term>
<listitem><para> Sets the minimum and maximum values for the range of the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>p [optional]</term>
<listitem><para>Sets the current position of the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>willReply [optional]</term>
<listitem>
<para>
  The <emphasis role="italic">willReply</emphasis> argument controls whether the interpreter
  waits (<xref linkend="sctCodingEventHandlers" />) for the reply from the event handler. The default is
  <computeroutput>.false</computeroutput>, the interpreter will not wait for the reply. If <emphasis
  role="italic">willReply</emphasis> is <computeroutput>.true</computeroutput>, the interpreter waits until the
  event handling method returns a value.
</para>
</listitem></varlistentry>
</variablelist>
</listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectButtonEvent" xreflabel="connectButtonEvent"><title>connectButtonEvent</title>
<indexterm><primary>connectButtonEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectButtonEvent(--id--,--event--+-----------+--+--------------+--)------><
                                       +-,--mName--+  +-,-willReply--+

]]>
</programlisting>

<para>
  Connects a method in the Rexx dialog to the Windows <xref linkend="ovvEvents"/> notification from a
 <xref linkend="clsButton"/> control. The <emphasis role="italic">connectButtonEvent</emphasis> method is used
  for all types of buttons (push button, radio button, or check box.)
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the button control this connection applies to. This can be a symbolic ID or the numeric value
        of the ID.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>event [required]</term>
      <listitem>
      <para>
        A keyword specifying the event to be connected with a method. This can be exactly one of the following, case is
        not significant:
        <variablelist>
          <varlistentry><term>CLICKED</term>
          <listitem>
          <para>
            The button has been clicked.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>DBLCLK</term>
          <listitem>
          <para>
            The button has been double-clicked.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>DISABLE</term>
          <listitem>
          <para>
            The button has been disabled.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>GOTFOCUS</term>
          <listitem>
          <para>
            The button got the input focus.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>LOSTFOCUS</term>
          <listitem>
          <para>
            The button lost the input focus.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>HILITE</term>
          <listitem>
          <para>
            The button has been selected.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>UNHILITE</term>
          <listitem>
          <para>
            The highlighting is to be removed (lost selection).
          </para>
          </listitem></varlistentry>
          <varlistentry><term>HOTITEM</term>
          <listitem>
          <para>
            Notifies the dialog that the mouse has moved over the button, or that the mouse is leaving the area
            over the button.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>PAINT</term>
          <listitem>
          <para>
            The button is to be repainted. This notification is only sent for owner-drawn buttons.
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      </listitem></varlistentry>
      <varlistentry><term>mName [optional]</term>
      <listitem>
      <para>
        The name of the method to invoke whenever the specified notification is received from the button control. Provide
        a method with a matching name. If you omit this argument, a method name is generated automatically. The name
        consists of the event keyword preceded by <computeroutput>on</computeroutput>. For instance:
        <computeroutput>onGotFocus</computeroutput>. The method name can not be the empty string.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>willReply [optional]</term>
      <listitem>
      <para>
        The <emphasis role="italic">willReply</emphasis> argument controls whether the interpreter
        waits (<xref linkend="sctCodingEventHandlers" />) for the reply from the event handler. The default is
        <computeroutput>.false</computeroutput>, the interpreter will not wait for the reply. If <emphasis
        role="italic">willReply</emphasis> is <computeroutput>.true</computeroutput>, the interpreter waits until the
        event handling method returns a value.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>The return codes are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        No error detected.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
      <para>
        The resource ID could not be resolved or the event argument is incorrect.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
      <para>
        The message was not connected correctly. From ooDialog 4.2.0 and on, it is not likely the return value will be
        1.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
    <orderedlist>
    <listitem>
    <para>
      Common guidelines on where (<xref linkend="paraWhereToConnectEvents" />) to invoke the <emphasis
      role="italic">connectComboBoxEvent</emphasis> method and on how (<xref linkend="sctCodingEventHandlers" />)
      to code event handlers are included in the documentation for the
      <xref linkend="clsEventNotification"/> class.
    </para>
    </listitem>
    <listitem>
    <para>
      For all events other than the HOTITEM event, the event-handling methods will receive two arguments. The first arg
      contains information about the specific control and its event. The second arg is the window handle of the button
      control. The low word of the first arg is the control ID and the high word is the event ID. Example:

<programlisting>
<![CDATA[
::method handler unguarded
  use arg info, handle
  id = .DlgUtil~loWord(info)
  eventCode = .DlgUtil~hiWord(info)
  ...

  return 0
]]>
</programlisting>
    </para>
    </listitem>
    <listitem>
    <para>
      The method for the HOTITEM event also receives two arguments. The first arg is the control id. The second arg is
      .true or .false. True if the mouse moved over the button, false if it left the area over the button. Example:

<programlisting>
<![CDATA[
::method onHover unguarded
  use arg id, entering
  say 'onHover() id:' id 'entering:' entering
  ...
  return 0

/* Output might be:

  onHover() id: 1044 entering: 1
  onHover() id: 1044 entering: 0
  onHover() id: 1001 entering: 1
  onHover() id: 1001 entering: 0

*/
]]>
</programlisting>
     </para>
    </listitem>
    </orderedlist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    In order to receive the GOTFOCUS, LOSTFOCUS, and DBLCLK event notifications, the button control has to have the
    NOTIFY (BS_NOTIFY) style.  For user defined dialogs use the NOTIFY style keyword in the
    create ... (<xref linkend="sctCreateMethods" />) method when the button is defined.  For dialogs created from a
    compiled resource or a resource script file use the BS_NOTIFY style for the button resource.  The other event
    notifications are always sent and it is not necessary to add the NOTIFY style for those events.
  </para>
  <para>
    The <emphasis role="italic">connectButtonEvent</emphasis> method is a member of the
    <xref linkend="clsEventNotification"/> mixin class.
  </para>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any of
    the button events occur.
  </para>
  <para>
    In Windows itself, some notifications are sent to the parent dialog using the WM_COMMAND message and others are
    sent using the WM_NOTIFY message.
  </para>
  </listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example displays a message whenever the OK button is selected:</para>
<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  self~init:super(...)
  self~connectButtonEvent("OK", "HILITE")

::method onHilite unguarded
  say "The OK button has been selected"
  return 0
]]>
</programlisting>
</listitem></varlistentry>
</variablelist>

</section>  <!-- End EventNotification::connectionButtonEvent() -->

<section id="mthConnectComboBoxEvent" xreflabel="connectComboBoxEvent"><title>connectComboBoxEvent</title>
<indexterm><primary>connectComboBoxEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectComboBoxEvent(--id--,--event--+---------------+--)---><
                                         +-,--methodName-+

]]>
</programlisting>

<para>The connectComboBoxEvent method connects a particular
WM_NOTIFY message for a combo box with a method. The WM_NOTIFY message
informs the dialog that an event has occurred in the combo box.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The resource ID (<xref linkend="defResourceId" />) of the combo
box for which a notification is to be connected to a method.
</para></listitem></varlistentry>
<varlistentry><term>event</term>
<listitem><para>The event to be connected with a method:
<variablelist>
<varlistentry><term>CHANGE</term>
<listitem><para>The text in the edit control has been altered. This notification is
sent after Windows updated the screen.
</para></listitem></varlistentry>
<varlistentry><term>UPDATE</term>
<listitem><para>The text in the edit control has been altered. This notification is
sent before Windows updates the screen.
</para></listitem></varlistentry>
<varlistentry><term>CLOSEUP</term>
<listitem><para>The list of the combo box has been closed.
</para></listitem></varlistentry>
<varlistentry><term>DROPDOWN</term>
<listitem><para>The list of the combo box is about to be made visible.
</para></listitem></varlistentry>
<varlistentry><term>DBLCLK</term>
<listitem><para>An entry in the combo box list has been selected with a double click.
</para></listitem></varlistentry>
<varlistentry><term>ERRSPACE</term>
<listitem><para>An out-of-memory problem has occurred.
</para></listitem></varlistentry>
<varlistentry><term>GOTFOCUS</term>
<listitem><para>The combo box got the input focus.
</para></listitem></varlistentry>
<varlistentry><term>LOSTFOCUS</term>
<listitem><para>The combo box lost the input focus.
</para></listitem></varlistentry>
<varlistentry><term>SELCHANGE</term>
<listitem><para>Another entry in the combo box list has been selected.
</para></listitem></varlistentry>
<varlistentry><term>SELENDOK</term>
<listitem><para>The list was closed after another entry was selected.
</para></listitem></varlistentry>
<varlistentry><term>SELENDCANCEL</term>
<listitem><para>After the selection of another entry, another control or dialog was
selected, which canceled the selection of the entry.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent whenever the specified notification is
received from the combo control. Provide a method with a matching name. If
you omit this argument, the event is preceded by <computeroutput>On</computeroutput>.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The return codes are:
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The resource ID could not be resolved or the event argument is
incorrect.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No errors were detected.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The message was not connected correctly. The message was not connected
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
<listitem>
<para>
  Common guidelines on where (<xref linkend="paraWhereToConnectEvents" />) to invoke the <emphasis
  role="italic">connectComboBoxEvent</emphasis> method and on how (<xref linkend="sctCodingEventHandlers" />)
  to code event handlers are included in the documentation for the
  <xref linkend="clsEventNotification"/> class.
</para>
<para>
  The event-handling methods receive two arguments: the first is a combination of the ID of the combo box and the ID of
  the notification message. (Extract the low-order word to get the combo box ID.)  The second argument is the window
  handle of the combo box. Example:

<programlisting>
<![CDATA[
::method playSong unguarded
  use arg eventID, handle
  id = .DlgUtil~loWord(eventID)
  if id == self~constDir[IDC_CB_PROFESSIONS] then
    -- take some action
  ...
  return 0
]]>
</programlisting>

</para>
</listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem>
<para>
  The following example invokes method PlaySong whenever the list of the combo box with the resource ID of
  IDC_CB_PROFESSIONS is about to be made visible.  In this case IDC_CB_PROFESSIONS is a
  symbolic ID (<xref linkend="defSymbolicId" />) that has been added to the constDir (<xref linkend="atrConstDir" />)
  directory of the MyDlgClass in another part of the program:

<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method initDialog
  self~connectComboBoxEvent("IDC_CB_PROFESSIONS", "DROPDOWN", "PlaySong")
]]>
</programlisting>

</para>
</listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectCommandEvents" xreflabel="connectCommandEvents"><title>connectCommandEvents</title>
<indexterm><primary>connectCommandEvents</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectCommandEvents</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectCommandEvents</secondary></indexterm>

<programlisting>
<![CDATA[
>>--connectCommandEvents(--id--,--methodName--)--><

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectCommandEvents</emphasis> method connects a Rexx dialog method to the command
  <xref linkend="ovvEvents"/> notifications sent by a Windows dialog control to its parent dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the dialog control, may be symbolic or numeric.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>methodName [required]</term>
    <listitem>
    <para>
      The name of the method to be invoked in the Rexx dialog object each time a command event occurs in the dialog
      control. The method name can not be the empty string.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The specified symbolic ID could not be resolved.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An error. Most likely, either the message table is full, or the interpreter is out of usable memory.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Two arguments are sent to the connected method.  The first contains the notification code in the high word and the
    ID of the control in the low word. The second argument is the window handle of the control.
  </para>
  <para>
    The number of different notification codes and the meanings of the notifications are dependent on the type of dialog
    control specified. Therefore, it is more advisable to use the specific connectXXXEvent() method for the control.
    Such as the <xref linkend="mthConnectListBoxEvent"/>() method.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
    <para>
      Syntax errors are raised when incorrect usage is detected.
    </para>
    <para>
      If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
      command events happen.
    </para>
    <para>
      In Windows itself, command events are sent to the parent dialog using the WM_COMMAND message.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example connects a list box command event notifications to the <emphasis role="italic">onCommand</emphasis>()
    method of the dialog. Note that the notification code 1 corresponds to the list box SELCHANGE event, 4 is the
    SETFOCUS, and 5 is KILLFOCUS events.
<programlisting>
<![CDATA[

::method initDialog
  ...
  self~connectCommandEvents(IDC_LB_FILES, onCommand)

::method onCommand unguarded
  use arg cmdCode, hwnd
  say 'cmdCode:                  ' cmdCode
  say 'hwnd:                     ' hwnd
  say 'hi word notification code:' .DlgUtil~hiWord(cmdCode)
  say 'lo word resource ID:      ' .DlgUtil~loWord(cmdCode)
  say '(List box resource ID)    ' self~constDir[IDC_LB_FILES]
  say
  return 0

/* Output might be:
cmdCode:                   263147
hwnd:                      0x00100AD0
hi word notification code: 4
lo word resource ID:       1003
(List box resource ID)     1003

cmdCode:                   66539
hwnd:                      0x00100AD0
hi word notification code: 1
lo word resource ID:       1003
(List box resource ID)     1003

cmdCode:                   328683
hwnd:                      0x00100AD0
hi word notification code: 5
lo word resource ID:       1003
(List box resource ID)     1003
*/

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectDateTimePickerEvent" xreflabel="connectDateTimePickerEvent"><title>connectDateTimePickerEvent</title>
<indexterm><primary>connectDateTimePickerEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectDateTimePickerEvent(--id-,-evt--+----------+-+------------+-)-------><
                                           +-,--mName-+ +-,-wilReply-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectDateTimePickerEvent</emphasis> method connects an
  <xref linkend="ovvEvents"/> notification message from a date time <xref linkend="clsDateTimePicker"/>
  control to a method in the Rexx dialog.
</para>
<para>
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the date time picker control. May be numeric or symbolic (<xref linkend="defSymbolicId" />).
    </para>
    </listitem></varlistentry>
    <varlistentry><term>evt [required]</term>
    <listitem>
    <para>
      Exactly one of the following keywords. The keyword specifies the event to be connected. For each event, the
      documentation for the event handler, (CloseUp (<xref linkend="evtDateTimePickerCLOSEUP" />),
      DateTimeChange (<xref linkend="evtDateTimePickerDATETIMECHANGE" />), etc.,) will contain additional information about
      the event. Case is not significant:
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>CLOSEUP       </member>
        <member>DATETIMECHANGE</member>
        <member>DROPDOWN      </member>
        <member>FORMAT        </member>
        <member>FORMATQUERY   </member>
        <member>USERSTRING    </member>
        <member>KEYDOWN       </member>
        <member>KILLFOCUS     </member>
        <member>SETFOCUS      </member>
      </simplelist>
      <variablelist>
        <varlistentry><term>CLOSEUP</term>
        <listitem>
        <para>
          Sent by a date and time picker (DTP) control when the user closes the drop-down month calendar. The month
          calendar is closed when the user chooses a date from the month calendar or clicks the drop-down arrow while
          the calendar is open. The return value from the event handler is ignored for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>DATETIMECHANGE</term>
        <listitem>
        <para>
          Sent by a date and time picker (DTP) control whenever a change occurs. The return value from the event
          handler is ignored for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>DROPDOWN</term>
        <listitem>
        <para>
          Sent by a date and time picker (DTP) control when the user activates the drop-down month calendar. The return
          value from the event handler is ignored for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>FORMAT</term>
        <listitem>
        <para>
          Sent by a date and time picker (DTP) control to request text to be displayed in a
          callback (<xref linkend="sctDTPCallback" />) field. The <emphasis role="italic">willReply</emphasis> argument
          is ignored for this event, the event handler must return (<xref linkend="sctCodingEventHandlers" />) a
          reply.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>FORMATQUERY</term>
        <listitem>
        <para>
          Sent by a date and time picker (DTP) control to retrieve the maximum allowable size of the string that will be
          displayed in a callback (<xref linkend="sctDTPCallback" />) field. The <emphasis
          role="italic">willReply</emphasis> argument is ignored for this event, the event handler must
          return (<xref linkend="sctCodingEventHandlers" />) a reply.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>USERSTRING</term>
        <listitem>
        <para>
          Sent by a date and time picker (DTP) control when a user finishes editing a string in the control. This
          notification message is only sent by DTP controls that have the CANPARSE style. The <emphasis
          role="italic">willReply</emphasis> argument is ignored for this event, the event handler must
          return (<xref linkend="sctCodingEventHandlers" />) a reply.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>KEYDOWN</term>
        <listitem>
        <para>
          Sent by a date and time picker (DTP) control when the user types in a
          callback (<xref linkend="sctDTPCallback" />) field. The <emphasis role="italic">willReply</emphasis> argument is
          ignored for this event, the event handler must return (<xref linkend="sctCodingEventHandlers" />) a reply.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>KILLFOCUS</term>
        <listitem>
        <para>
          Notifies a date and time picker control's parent window, (which is the dialog window,) that the control has
          lost the input focus. The return value from the event handler is ignored for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>SETFOCUS</term>
        <listitem>
        <para>
          Notifies a date and time picker control's parent window, (which is the dialog window,) that the control has
          received the input focus. The return value from the event handler is ignored for this event.
        </para>
        </listitem></varlistentry>
      </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mName [optional]</term>
    <listitem>
    <para>
      The name of the method that is to be invoked whenever the specified notification is received from the date time
      picker control. The programmer defines this method. If this argument is omitted, a method name is automatically
      generated that consists of the event keyword preceded by <computeroutput>on</computeroutput>. For instance,
      <computeroutput>onCloseUp</computeroutput>. If the method name is supplied, it can not be the empty string.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <emphasis role="italic">willReply</emphasis> argument controls whether the interpreters waits for the reply
      from the event handler. The default is <computeroutput>.true</computeroutput>, that is, the interpreter waits
      until the event handling method returns a value. If <emphasis role="italic">willReply</emphasis> is
      <computeroutput>.false</computeroutput>, the interpreter will not wait for the reply. However, this argument is
      ignored for the USERSTRING, KEYDOWN, FORMAT, and FORMATQUERY events. If the programmer connects any of these
      events, the interpreter waits for the return from the connected method. This can not be changed.
    </para>
    </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    This method returns <computeroutput>.true</computeroutput> if the event notification was connected correctly,
    otherwise <computeroutput>.false</computeroutput> .
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Common guidelines on where (<xref linkend="paraWhereToConnectEvents" />) to invoke the <emphasis
    role="italic">connectDateTimePickerEvent</emphasis> method and on how (<xref linkend="sctCodingEventHandlers" />)
    to code event handlers are included in the documentation for the
    <xref linkend="clsEventNotification"/> class.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected, including the use of an invalid symbolic ID or an
    unrecognized event keyword.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if the
    connected event happens.
  </para>
  <para>
    The underlying dialog receives the DTN_* messages as the notifications for the date time picker events.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example creates a DTP control in the dialog template of a <computeroutput>UserDialog</computeroutput>
    and then connects the drop down and close up events:
  </para>
<programlisting>
<![CDATA[

::method defineDialog

  self~createDateTimePicker(IDC_DTP_REPORT_DATE,  10, 7, 280, 15, "BORDER SHORT SHOWNONE")

  self~createPushButton(IDOK, 85, 74, 50, 14, "DEFAULT", "Ok")
  self~createPushButton(IDCANCEL, 140, 74, 50, 14, , "Cancel")

  self~connectDateTimePickerEvent(IDC_DTP_REPORT_DATE, "CLOSEUP", onCloseUp)
  self~connectDateTimePickerEvent(IDC_DTP_REPORT_DATE, "DROPDOWN", onDropDown)

]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>

<section id="evtDateTimePickerCLOSEUP"><title>CloseUp Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>CLOSEUP</secondary></indexterm>
<para>
  The event handler for the close up event is invoked when the user closes the drop-down month calendar. The month
  calendar is closed when the user chooses a date from the month calendar or clicks the drop-down arrow while the
  calendar is open.
</para>
<para>
  The programmer can specify for the interpreter to wait, or not wait, for the return from the the event handler by
  using the <emphasis role="italic">willReply</emphasis> argument in the
 <xref linkend="mthConnectDateTimePickerEvent"/> method. The actual value returned from the
  event handler is ignored.
</para>
<para>
  This event notification signals that the DTP control has destroyed the child month calendar control. The DTP control
  creates a new month calendar each time the month calendar needs to be shown and destroys it each time the drop-down is
  closed. The close up notification is sent when the month calendar is destroyed.
</para>
<para>
  The programmer may have instantiated a Rexx month calendar object during the
   DROPDOWN (<xref linkend="evtDateTimePickerDROPDOWN" />) event notification. Once the underlying Windows month calendar is
  destroyed, the Rexx <computeroutput>MonthCalendar</computeroutput> is no longer valid.
</para>

<programlisting>
<![CDATA[
::method onCloseUp unguarded
  use arg idFrom, hwndFrom

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 2 arguments:
  </para>
  <variablelist>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The return value from the event handler is ignored by the operating system.  0 makes a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following is an example event handler for the close up event. When the close up happens, the user may or may not
    have changed the selected date.  The example checks if a new data has been selected and does something if it has
    been changed:

<programlisting>
<![CDATA[

::method onCloseUp unguarded
  expose dtp lastChange
  use arg id, hwnd

  newDate = dtp~getDateTime
  if newDate \= lastChange then do
    lastChange = newDate
    self~updateDateInfo(newDate)
  end

  return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End CloseUp Event Handler -->


<section id="evtDateTimePickerDATETIMECHANGE"><title>DateTimeChange Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>DATETIMECHANGE</secondary></indexterm>
<para>
  The event handler for the date time change event is invoked whenever a change in the underlying DTP control takes
  place
</para>
<para>
  The programmer can specify for the interpreter to wait, or not wait, for the return from the the event handler by
  using the <emphasis role="italic">willReply</emphasis> argument in the
 <xref linkend="mthConnectDateTimePickerEvent"/> method. The actual value returned from the
  date time change event handler is ignored.
</para>

<programlisting>
<![CDATA[
::method onDateTimeChange unguarded
  use arg dateTime, valid, idFrom, hwndFrom

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 4 arguments:
  </para>
  <variablelist>
    <varlistentry><term>dateTime</term>
    <listitem>
    <para>
      The <emphasis role="italic">dateTime</emphasis> argument is a <computeroutput>DateTime</computeroutput> object.
      When the <emphasis role="italic">valid</emphasis> argument is true, <emphasis role="italic">dateTime</emphasis>
      specifies the new displayed date and time in the DTP control. When <emphasis role="italic">valid</emphasis> is
      false, <emphasis role="italic">dateTime</emphasis> will be the exact date and time that the notification was
      received.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>valid</term>
    <listitem>
    <para>
      True or false indicating whether the date time change is valid or not. <emphasis role="italic">valid</emphasis>
      can only be false when the DTP control has the SHOWNONE style and the user has unchecked the check box to indicate
      that no date and time is currently selected.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The return from the event handler is ignored. Returning 0 is sensible.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example updates a static control with the currently selected date and time whenever the user changes
    the date and time:

<programlisting>
<![CDATA[

::method initDialog
  expose dtp staticMsg

  self~connectDateTimePickerEvent(IDC_DTP, "DATETIMECHANGE", onChange)

  dtp = self~newDateTimePicker(IDC_DTP);
  dtp~setFormat("hh':'mm':'ss dddd MMM dd', 'yyyy")

  staticMsg = self~newStatic(IDC_ST1)
  ...

::method onChange unguarded
  expose staticMsg
  use arg dateTime, valid, idFrom, hwndFrom

  if valid then do
    sf = .SimpleFormatter~new(dateTime)
    staticMsg~setText(sf~time 'on' sf~date)
  end
  else do
    staticMsg~setText("No valid date selected.")
  end

  return 0

::class 'SimpleFormatter' public

::method init
  expose dateTime
  use strict arg dateTime

::method date
  expose dateTime

  dayNum = dateTime~usaDate~substr(4, 2)~strip('L', '0')
  year = dateTime~standardDate~left(4)

  return dateTime~dayName || ',' dateTime~monthName dayNum || ',' year

::method time
  expose dateTime

  return dateTime~civilTime

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End DateTimeChange Event Handler -->


<section id="evtDateTimePickerDROPDOWN"><title>DropDown Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>DROPDOWN</secondary></indexterm>
<para>
  The event handler for the drop down event is invoked when the user activates the drop down month calendar. The DTP
  control sends the notification for the event after it has created the child month calendar control.
</para>
<para>
  The programmer can specify for the interpreter to wait, or not wait, for the return from the the event handler by
  using the <emphasis role="italic">willReply</emphasis> argument in the
 <xref linkend="mthConnectDateTimePickerEvent"/> method. The actual value returned from the
  event handler for the drop down event is ignored.
</para>

<programlisting>
<![CDATA[
::method onDropDown unguarded
  use arg idFrom, hwndFrom

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The drop down event handler receives 2 arguments:
  </para>
  <variablelist>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The return from the event handler is ignored. Returning 0 is sensible.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    One reason for handling the drop down event is to adjust the style of the month calendar control when it is
    displayed. Note that the DTP control creates the child month calendar control when it is needed and destroys the
    month calendar when the drop down is closed up. Therefore you can not save a reference to the month calendar object
    and use it later. When the underlying (<xref linkend="ovvUnderlying" />) month calendar control is destroyed the
    Rexx month calendar object is no longer valid.
  </para>
  <para>
    In Windows Vista and later versions of Windows, the DTP control has the
 <xref linkend="mthSetMonthCalStyle"/> method which can be used to set the month calendar's style
    once and the DTP control will then use that style each time it creates the month calendar. Therefore, the technique
    of setting the month calendar style during the drop down event handler is really only needed for Windows XP and
    earlier.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example demonstrates how to change the month calendar style in the drop down event handler. If the
    operating system the program is running on is Vista or later, the whole process is bypassed:

<programlisting>
<![CDATA[

::method initDialog
  expose dtp

  dtp = self~newDateTimePicker(IDC_DTP_APPOINTMENT_TIME);

  if .OS~isAtLeastVista then do
    dtp~setMonthCalStyle("NOCIRCLE NOTRAILING")
  end
  else
    self~connectDateTimePickerEvent(IDC_DTP_APPOINTMENT_TIME, "DROPDOWN", onDropDown)
  do
  ...

::method onDropDown unguarded
  expose dtp
  use arg idFrom, hwndFrom

  -- We know this is not Vista or later, othewise we would not
  -- have gotten the event notification.

  mc = dtp~getMonthCal
  mc~replaceStyle('DAYSTATE MULTI WEEKNUMBERS', "NOCIRCLE NOTODAY")

  return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End DropDown Event Handler -->

<section id="evtDateTimePickerFORMAT"><title>Format Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>FORMAT</secondary></indexterm>
<para>
  The event handler for the format event is invoked when the DTP control requests the text to be displayed in a
  callback (<xref linkend="sctDTPCallback" />) field.
</para>
<para>
  The programmer must return the text to display for the callback field and the interpreter waits for this return. This
  behaviour can not be changed.
</para>

<programlisting>
<![CDATA[
::method onFormat unguarded
  use arg field, dateTime, idFrom, hwndFrom

  return text
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 4 arguments:
  </para>
  <variablelist>
    <varlistentry><term>field</term>
    <listitem>
    <para>
      The text of the callback field identifier.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dateTime</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the currently displayed date and time in the DTP
      control.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The text to display for the specified callback field. The text must be no longer than 63 characters or a syntax
    condition is raised.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The <computeroutput>FORMAT</computeroutput>, FORMATQUERY (<xref linkend="evtDateTimePickerFORMATQUERY" />), and
    KEYDOWN (<xref linkend="evtDateTimePickerKEYDOWN" />) event notifications all work together to provide the
    functionality for call back fields. It is a little difficult to grasp the concepts from small snippets of code, so a
    complete example program is included in the ooDialog samples:
    <computeroutput>samples\oodialog\controls\fiscalReports.rex</computeroutput>.
  </para>
  <para>
    This is an example FORMAT event handler. It comes from the complete
    <computeroutput>fiscalReports.rex</computeroutput> program:

<programlisting>
<![CDATA[

::method onFormat unguarded
  expose periods types currentType currentPeriod
  use arg field, dt, id, hwnd

  select
    when field == 'XX' then do
      ret = self~getPeriodNumber(dt)
    end

    when field == 'XXX' then do
      ret = periods[currentPeriod]
    end

    otherwise do
      ret = types[currentType]
    end
  end
  -- End select

  return ret

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Format Event Handler -->


<section id="evtDateTimePickerFORMATQUERY"><title>FormatQuery Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>FORMATQUERY</secondary></indexterm>
<para>
  The event handler for the format query event is invoked when the DTP control requests the maximum size needed to
  display a string in a call back field (<xref linkend="sctDTPCallback" />).
</para>
<para>
  The programmer must fill in a <xref linkend="clsSize"/> object with the maximum size needed and return a
  value from the event handler. The interpreter waits for this return. This behavior can not be changed.
</para>

<programlisting>
<![CDATA[
::method onFormatQuery unguarded
  use arg field, size, id, hwnd

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 4 arguments:
  </para>
  <variablelist>
    <varlistentry><term>field</term>
    <listitem>
    <para>
      The text of the callback field identifier.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>size</term>
    <listitem>
    <para>
      A <computeroutput>Size</computeroutput> object that is set to the maximum size required to display the
      string in the call back field.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The actual value returned from the event handler is ignored by the operating system. Rather the return signals the
    operating system that the <emphasis role="italic">size</emphasis> argument is now valid to access, and the OS can
    use its values. Returning zero is sensible.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The <computeroutput>FORMATQUERY</computeroutput>, FORMAT (<xref linkend="evtDateTimePickerFORMAT" />), and
    KEYDOWN (<xref linkend="evtDateTimePickerKEYDOWN" />) event notifications all work together to provide the
    functionality for call back fields. It is a little difficult to grasp the concepts from small snippets of code, so a
    complete example program is included in the ooDialog samples:
    <computeroutput>samples\oodialog\controls\fiscalReports.rex</computeroutput>.
  </para>
  <para>
    The following example FORMATQUERY event handler comes from that example program:

<programlisting>
<![CDATA[

::method onFormatQuery unguarded
  expose dtp haveSizes xxSize xxxSize xxxxSize
  use arg field, size, id, hwnd

  if \ haveSizes then do
    xxSize  = self~calcSize('XX')
    xxxSize = self~calcSize('XXX')
    xxxxSize = self~calcSize('XXXX')
    haveSizes = .true
  end

  -- The equateTo() method sets the cx and cy attributes of the receiver .Size
  -- object to the cx and cy attributes of the argument .Size object.
  select
    when field == 'XX' then size~equateTo(xxSize)
    when field == 'XXX' then size~equateTo(xxxSize)
    otherwise size~equateTo(xxxxSize)
  end
  -- End select

  return 0


]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End FormatQuery Event Handler -->


<section id="evtDateTimePickerKEYDOWN"><title>KEYDOWN Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>KEYDOWN</secondary></indexterm>
<para>
  The event handler for the key down event is invoked when the user types a key in a
  call (<xref linkend="sctDTPCallback" />) back field.
</para>
<para>
  The programmer must return a <computeroutput>DateTime</computeroutput> object and the interpreter waits for this
  return. This behavior can not be changed.
</para>

<programlisting>
<![CDATA[
::method onKeyDown unguarded
  use arg field, dateTiem, vKey, idFrom, hwndFrom

  return dateTime
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives xx arguments:
  </para>
  <variablelist>
    <varlistentry><term>field</term>
    <listitem>
    <para>
      The text of the callback field identifier.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dateTime</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the currently displayed date and time in the DTP
      control.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>vKey</term>
    <listitem>
    <para>
      The virtual key code of the key the user typed in the call back field. The <xref linkend="clsVK"/> class
      can be used to map the numeric key code to a symbol, making it easier to work with the codes.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The programmer returns a <computeroutput>DateTime</computeroutput> object. If the return is a date / time different
    than the <emphasis role="italic">dateTime</emphasis> argument, the DTP control's date / time is updated. If it is he
    same, then no action is taken by the DTP control.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    By examining the <emphasis role="italic">dateTime</emphasis> and <emphasis role="italic">vKey</emphasis> arguments
    the programmer can produce custom responses to the user's typed keys. The custom response is achieved by returning a
    <computeroutput>DateTime</computeroutput> object that specifies a different date than the currently displayed date.
    For instance, if the currently displayed date is 8:00 am July 4th 1998 and the user types the <emphasis
    role="italic">home</emphasis> key, the programmer could return a date of 12:00 am January 1st 1998 to set the DTP
    control's display to the first of January in 1998. Likewise, if the user typed the <emphasis
    role="italic">end</emphasis> key the programmer could return December 31 1998 at 11:59 pm to set the display to the
    end of the current year.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The <computeroutput>KEYDOWN</computeroutput>, FORMAT (<xref linkend="evtDateTimePickerFORMAT" />), and
    FORMATQUERY (<xref linkend="evtDateTimePickerFORMATQUERY" />) event notifications all work together to provide the
    functionality for call back fields. It is a little difficult to grasp the concepts from small snippets of code, so a
    complete example program is included in the ooDialog samples:
    <computeroutput>samples\oodialog\controls\fiscalReports.rex</computeroutput>.
  </para>
  <para>
    The following example shows the KEYDOWN event handler from the <computeroutput>fiscalReports.rex</computeroutput>
    example program:

<programlisting>
<![CDATA[

::method onKeyDown unguarded
  use arg field, dt, vKey, idFrom, hwndFrom

  select
    when field == 'XX' then do
      newDT = self~updatePeriodNumber(dt, vKey)
    end

    when field == 'XXX' then do
      newDT = self~updatePeriod(dt, vKey)
    end

    otherwise do
      newDT = self~updateReport(dt, vKey)
    end
  end
  -- End select

  return newDT

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End KEYDOWN Event Handler -->


<section id="evtDateTimePickerKILLFOCUS"><title>KillFocus Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>KILLFOCUS</secondary></indexterm>
<para>
  The event handler for the kill focus event is invoked when the DTP control loses the input focus.
</para>
<para>
  The programmer can specify for the interpreter to wait, or not wait, for the return from the the event handler by
  using the <emphasis role="italic">willReply</emphasis> argument in the
 <xref linkend="mthConnectDateTimePickerEvent"/> method. The actual value returned from the
  event handler for the kill focus event is ignored.
</para>

<programlisting>
<![CDATA[
::method onKillFocus unguarded
  use arg idFrom, hwndFrom

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The kill focus event handler receives 2 arguments:
  </para>
  <variablelist>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The return from the event handler is ignored. Returning 0 is sensible.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End KillFocus Event Handler -->


<section id="evtDateTimePickerSETFOCUS"><title>SetFocus Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>SETFOCUS</secondary></indexterm>
<para>
  The event handler for the set focus event is invoked when the DTP control gains the input focus.
</para>
<para>
  The programmer can specify for the interpreter to wait, or not wait, for the return from the the event handler by
  using the <emphasis role="italic">willReply</emphasis> argument in the
 <xref linkend="mthConnectDateTimePickerEvent"/> method. The actual value returned from the
  event handler for the set focus event is ignored.
</para>

<programlisting>
<![CDATA[
::method onSetFocus unguarded
  use arg idFrom, hwndFrom

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The set focus event handler receives 2 arguments:
  </para>
  <variablelist>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The return from the event handler is ignored. Returning 0 is sensible.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End SetFocus Event Handler -->

<section id="evtDateTimePickerUSERSTRING"><title>UserString Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>USERSTRING</secondary></indexterm>
<para>
  The event handler for the USERSTRING event is invoked when the user has finished editing a string in the DTP control.
  This event notification only occurs when the DTP control has the CANPARSE style.
</para>
<para>
  The programmer must return a value from the event handler and the interpreter waits for this return. This behavior can
  not be changed.
</para>

<programlisting>
<![CDATA[
::method onUserString unguarded
  use arg dateTime, userStr, idFrom, hwndFrom

  return newDateTime
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 4 arguments:
  </para>
  <variablelist>
    <varlistentry><term>dateTime</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that reflects the date and time the DTP control is currently
      displaying.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>userStr</term>
    <listitem>
    <para>
      The string the user has just finished typing into the DTP control.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The event handler must return a <computeroutput>DateTime</computeroutput> object or the
    <computeroutput>.nil</computeroutput> object.
  </para>
  <para>
    After parsing the user string, the programmer returns a new <computeroutput>DateTime</computeroutput> object that
    reflects the new date and time the DTP control should display. If the returned
    <computeroutput>DateTime</computeroutput> object reflects the exact same date and time as the <emphasis
    role="italic">dateTime</emphasis> argument, then the DTP control takes no action. Otherwise, the DTP control updates
    its display to the new date and time.
  </para>
  <para>
    If, and only if, the DTP control has the SHOWNONE style, the programmer can return the
    <computeroutput>.nil</computeroutput> object to change the date and time to <emphasis role="italic">no date and
    time</emphasis> selected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This event notification allows the programmer to provide a custom response to what the user types into the DTP
    control's display field. The programmer parses the string entered by the user and then updates the DTP control in a
    way that corresponds to the entered string.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The distribution of the ooDialog framework contains an example program:
    <computeroutput>samples\oodialog\controls\userStringDTP.rex</computeroutput> that focuses on the USERSTRING
    notification. This example is a portion of the event handler for the USERSTRING event from that program.
  </para>
  <para>
    The DTP control in the program is initially set to the current system date and time. Naturally, as the program runs,
    the system date and time continue to advance. It would be difficult for the user to reset the DTP control to the
    current system date and time, so the program allows the user to type a <emphasis role="italic">r</emphasis> or a
    <emphasis role="italic">c</emphasis> in the DTP to reset its display to the current system date and time:

<programlisting>
<![CDATA[

::method onUserString unguarded
  expose resetting stInvalid
  use arg dt, userStr, id, hwnd

  stInvalid~setText('')

  -- Check for the shortcut to set the DTP to the current date and time.
  upStr = userStr~upper
  if upStr == 'C' | upStr == 'R' | upStr == 'CANCEL' | upStr == 'RESET' then do
    resetting = .true
    return .DateTime~new
  end

  ...

  return newDT

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End UserString Event Handler -->


</section>  <!-- End EventNotification::connectDateTimePickerEvent() -->

<section id="mthConnectDraw" xreflabel="connectDraw"><title>connectDraw</title>
<indexterm><primary>connectDraw</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectDraw</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectDraw</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectDraw--(--+-----+--+---------------+--)---------------><
                    +--id-+  +-,--methodName-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectDraw</emphasis> method connects the draw control event notification with a method
  in the Rexx dialog. This notification is sent to the underlying dialog by an owner-drawn button, combo box, list box,
  or menu, when a visual aspect of the control or menu has changed.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [optional]</term>
      <listitem>
      <para>
        The resource ID of the dialog control whose notification is being connected. This can be symbolic or numeric. If
        the ID is omitted, all drawing event notifications, of all owner-drawn controls in the dialog, will invoke the
        method.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>methodName [optional]</term>
      <listitem>
      <para>
        The name of the method that is to be invoked each time the draw control event occurs. The method name must not be
        the empty string. If this argument is omitted, then the ooDialog framework will connect the notification to the
        <computeroutput>onDraw</computeroutput> method.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The specified symbolic ID could not be resolved.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The notification was not connected correctly.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    The notification for the draw control is only sent to the above mentioned controls when they have the OWNERDRAW
    style.
  </para>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    draw events happen.
  </para>
  <para>
    In Windows itself, the dialog receives this event notification as a WM_DRAWITEM message.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectEachSBEvent" xreflabel="connectEachSBEvent"><title>connectEachSBEvent</title>
<indexterm><primary>connectEachSBEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectEachSBEvent(-id-,-mthWhenUp-,-mthWhenDown-+---------------+--------->
                                                     +-,-mthWhenDrag-+

>--+-------+-+-------+-+-------+--+-----------+-+-----------+-+----------+----->
   +-,-min-+-+-,-max-+ +-,-pos-+  +-,-mthPgUp-+ +-,-mthPgDn-+ +-,-mthTop-+

>--+-------------+-+------------+-+------------+-+-------------+--)------------><
   +-,-mthButtom-+ +-,-mthTrack-+ +-,-mthEndSc-+ +-,-willReply-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectEachSBEvent</emphasis> method connects an
  <xref linkend="ovvEvents"/> notification message from a scroll bar to a method in the Rexx dialog object.
  Optionally, the method can also initialize the scroll bar, (set the range and current position.)
</para>
<para>
  This method requires that the underlying (<xref linkend="ovvUnderlying" />) scroll bar exists. Therefore, the method
  is best invoked in the <xref linkend="mthInitDialog"/> method.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id [required]</term>
<listitem><para>The ID of the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>mthWhenUp [required]</term>
<listitem><para>The method that is called each time the scroll bar is incremented.
</para></listitem></varlistentry>
<varlistentry><term>mthWhenDown [required]</term>
<listitem><para>The method that is called each time the scroll bar is decremented.
</para></listitem></varlistentry>
<varlistentry><term>mthWhenDrag [optional]</term>
<listitem><para> The method that is called each time the scroll bar is dragged with
the mouse.
</para></listitem></varlistentry>
<varlistentry><term>min, max [optional]</term>
<listitem><para> The minimum and maximum values for the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>pos [optional]</term>
<listitem><para>The current or preselected value.
</para></listitem></varlistentry>
<varlistentry><term>mthPgUp [optional]</term>
<listitem><para>The method that is called each time the scroll bar is focused and the
PgUp key is pressed.
</para></listitem></varlistentry>
<varlistentry><term>mthPgDn [optional]</term>
<listitem><para>The method that is called each time the scroll bar is focused and the
PgDn key is pressed.
</para></listitem></varlistentry>
<varlistentry><term>mthTop [optional]</term>
<listitem><para>The method that is called each time the scroll bar is focused and the
Home key is pressed.
</para></listitem></varlistentry>
<varlistentry><term>mthBottom [optional]</term>
<listitem><para>The method that is called each time the scroll bar is focused and the
End key is pressed.
</para></listitem></varlistentry>
<varlistentry><term>mthTrack [optional]</term>
<listitem><para>The method that is called each time the scroll box is dragged.
</para></listitem></varlistentry>
<varlistentry><term>mthEndSc [optional]</term>
<listitem><para>The method that is called each time the scroll box is released after
the dragging.
</para></listitem></varlistentry>
<varlistentry><term>willReply [optional]</term>
<listitem>
<para>
  The <emphasis role="italic">willReply</emphasis> argument controls whether the interpreter
  waits (<xref linkend="sctCodingEventHandlers" />) for the reply from the event handler. The default is
  <computeroutput>.false</computeroutput>, the interpreter will not wait for the reply. If <emphasis
  role="italic">willReply</emphasis> is <computeroutput>.true</computeroutput>, the interpreter waits until the
  event handling method returns a value.
</para>
</listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem>
<para>
  In the following example, scroll bar with symbolic ID IDC_SB is connected to three methods. The range is initialized
  to 1 as the minimum and 20 as the maximum. The current position is set to 6:

<programlisting>
<![CDATA[
::class MyDialog subclass UserDialog
     .
     .
     .
::method initDialog

  self~connectEachSBEvent(IDC_SB,"Increase","Decrease","Drag",1,20,6)

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectEditEvent" xreflabel="connectEditEvent"><title>connectEditEvent</title>
<indexterm><primary>connectEditEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectEditEvent(--id--,--event--+---------------+--)-------><
                                     +-,--methodName-+
]]>
</programlisting>

<para>The connectEditEvent method connects a particular
WM_NOTIFY message for an edit control with a method. The WM_NOTIFY message
informs the dialog that an event has occurred with regard to the edit control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the edit control of which a notification is to be connected
to a method.
</para></listitem></varlistentry>
<varlistentry><term>event</term>
<listitem><para>The event to be connected with a method:
<variablelist>
<varlistentry><term>CHANGE</term>
<listitem><para>The text has been altered. This notification is sent after the screen
has been updated.
</para></listitem></varlistentry>
<varlistentry><term>UPDATE</term>
<listitem><para>The text has been altered. This notification is sent before the screen
is updated.
</para></listitem></varlistentry>
<varlistentry><term>ERRSPACE</term>
<listitem><para>An out-of-memory problem has occurred.
</para></listitem></varlistentry>
<varlistentry><term>MAXTEXT</term>
<listitem><para>The text inserted exceeds the specified number of characters for the
edit control. This notification is also sent when:
<itemizedlist>
<listitem><para>An edit control does not have the ES_AUTOHSCROLL or AUTOSCROLLH style
and the number of characters to be inserted would exceed the width of the
edit control.</para></listitem></itemizedlist>
<itemizedlist>
<listitem><para>The ES_AUTOVSCROLL or AUTOSCROLLV style is not set and the total number
of lines resulting from a text insertion would exceed the height of the edit
control.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
<varlistentry><term>HSCROLL</term>
<listitem><para>The horizontal scroll bar has been used.
</para></listitem></varlistentry>
<varlistentry><term>VSCROLL</term>
<listitem><para>The vertical scroll bar has been used.
</para></listitem></varlistentry>
<varlistentry><term>GOTFOCUS</term>
<listitem><para>The edit control got the input focus.
</para></listitem></varlistentry>
<varlistentry><term>LOSTFOCUS</term>
<listitem><para>The edit control lost the input focus.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent whenever the specified notification is
received from the edit control. Provide a method with a matching name. If
you omit this argument, the event is preceded by <computeroutput>On</computeroutput>.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The return codes are:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>No error detected.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>The resource ID could not be resolved or the event argument is
incorrect.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The message was not connected correctly. The message was not connected
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
<listitem>
  <orderedlist>
  <listitem>
  <para>
    There are some common (<xref linkend="paraWhereToConnectEvents" />) guidelines for the invocation of the event
    connection methods.
  </para>
  </listitem>
  <listitem>
  <para>
    The event-handling method receives two arguments. The first arg contains information about the event. In the
    low-order word is the ID of the edit control. The high-order word contains the event ID. The second arg is the
    handle to the edit control.
  </para>
  <para><emphasis role="bold">Example:</emphasis></para>
  <programlisting>
  <![CDATA[
  ::method Handler unguarded
    use arg info, handle
    id = .DlgUtil~loWord(info)
    eventID = .DlgUtil~hiWord(info
    ...
    return 0
  ]]>
  </programlisting>
  </listitem>
  </orderedlist>
</listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example verifies the input of entry line AMOUNT and resets
it to 0 when a nonnumeric value was entered:
<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  self~init:super(...)
  self~connectEditEvent("AMOUNT", "CHANGE")

::method onChange unguarded
  ec = self~newEdit("AMOUNT")
  if ec~GetText~Space(0) \= "" & ec~GetText~DataType("N") = 0 then do
    ec~setModified(.false)
    ec~select
    ec~replaceSelText("0")
   end
  return 0
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectFKeyPressDialogObject" xreflabel="connectFKeyPress"><title>connectFKeyPress</title>
<indexterm><primary>connectFKeyPress</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectFKeyPress</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectFKeyPress(--methodName--)-------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectFKeyPress</emphasis> method connects a function key press event notification to a
  method in the Rexx dialog object. </para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single arguments is;
    <variablelist>
      <varlistentry><term>methodName [required]</term>
      <listitem>
      <para>
        The name of the method that is to be invoked when the key press event happens. The argument can not be the empty
        string.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The possible return values are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        Success.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-2</term>
      <listitem>
      <para>
        The underlying mechanism in the Windows API that is used to capture key events failed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-6</term>
      <listitem>
      <para>
        The maximum number of connections has been reached.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-7</term>
      <listitem>
      <para>
        The <emphasis role="italic">methodName</emphasis> method is already connected to a key down event for this
        dialog.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks</emphasis></term>
  <listitem>
  <para>
    This method works for function keys F2 through F24. In Windows the F1 key is the help key and the
 <xref linkend="mthConnectHelp"/> method should be used for F1. This method is a convenience method and is
    exactly equivalent to:

<programlisting>
<![CDATA[
::method initDialog
  ...
  keys = .VK~F2 "-" .VK~F24
  self~connectKeyPress(methodName, keys)
]]>
</programlisting>

  </para>
  <para>
    The event handling method receives the same arguments as the
    event (<xref linkend="connectKeyPressEventHandler" />) handler for the <emphasis
    role="italic">connectKeyPress</emphasis> method .
  </para>
  <para>
    Unlike most other methods that connect event notifications, the underlying Windows dialog must exist before this
    method can be used. That means it can be used in <xref linkend="mthInitDialog"/> or any time
    thereafter.  There is a maximum limit of 63 methods, per dialog, that can be connected to key press events.
    Connections can be removed using the <xref linkend="mthDisconnectKeyPressDialogObject"/>
    method if there is no longer a need for a notification of a key press.
  </para>
  <para>
    The dialog control object also has a <xref linkend="mthConnectFKeyPressDialogControlObject"/>()
    method. The method of the dialog object (this method) will capture any F key press event when the dialog is the
    active window. The method of the dialog control object will only capture a F key press when the control has the
    keyboard focus.
  </para>
  <para>
    Due to the nature of key press events, the low-level implementation of capturing the key strokes is different from
    most of the other methods of the <computeroutput>EventNotification</computeroutput> class. There is no single message
    sent to the underlying dialog for a key stroke event.
  </para>
  </listitem>
  </varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    In general error return codes are used to indicate incorrect usage rather than raised syntax conditions. However,
    syntax errors are raised if the <emphasis role="italic">methodName</emphasis> argument is missing or the empty
    string, or invoking this method before the underlying (<xref linkend="ovvUnderlying" />) dialog is created.
  </para>
  <para>
    Raises syntax errors when some incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any F
    Key key press events happen.
  </para>
  <para>
    Due to the nature of key press events, the low-level implementation of capturing the key strokes is different from
    most of the other methods of the <computeroutput>EventNotification</computeroutput> class. There is no single message
    sent to the underlying dialog for a key stroke event.
  </para>
  </listitem>
  </varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example is a variation on the example (<xref linkend="connectKeyPressExample" />) shown for the
 <xref linkend="mthConnectKeyPressDialogObject"/> method. It connects all the function keys to the
    same method and then determines what action to take by examining which key was pressed.

  <programlisting>
  <![CDATA[
  ::method initDialog

    ...

    -- Capture all function key presses.
    self~connectFKeyPress(onFKey)

    ...

  ::method onFKey unguarded
    use arg keyPressed

    select
      when keyPressed == .VK~F2 then self~showCustomerLookupDialog

      when keyPressed = 114 then do
        prodNum = self~newEdit(IDC_EDIT_PRODUCT)~getText
        if prodNum \== "" then self~showProductInfo(prodNum)
      end

      when keyPressed = 115 then self~resetAllFields
      when keyPressed = 116 then self~printInvoice

      otherwise do
        -- Not interested in any other function keys
        nop
      end
    end

    return 0
  ]]>
  </programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectHelp" xreflabel="connectHelp"><title>connectHelp</title>
<indexterm><primary>connectHelp</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectHelp</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectHelp</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectHelp(--+--------------+--)------------><
                  +--methodName--+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectHelp</emphasis> method connects the Windows Help event with a method in the dialog. The Windows Help
  event occurs when the user presses the F1 key.  (Only the Help events generated when the dialog is the active window
  are connected.)
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The only argument is:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that to be invoked when the help event occurs. The name can not be the empty string. When
      this argument is omitted the name defaults to <emphasis role="italic">onHelp</emphasis>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para></listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Note that the Windows help event notification connected by this method is not the same as the help <emphasis
    role="bold">command</emphasis> event notification automatically (<xref linkend="sctStandardEventMethods" />)
    connected when a dialog object is instantiated.
  </para>
  <para>
    The method connected to the Help event will receive the following four arguments in the order listed:
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the dialog, dialog control, or menu item that had the focus when the F1 key was pressed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>type</term>
    <listitem>
    <para>
      Specifies if the ID in argument 1 was from a window (a dialog or dialog control) or from a menu item.  This
      argument will either be <computeroutput>WINDOW</computeroutput> or <computeroutput>MENU
    </computeroutput>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mouseX</term>
    <listitem>
    <para>
      The x coordinate of the mouse at the time the F1 key was pressed.  This value is an absolute screen coordinate
      (pixel) and note that the mouse will not necessarily be over the dialog.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mouseY</term>
    <listitem>
    <para>
      The y coordinate of the mouse at the time the F1 key was pressed.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    help events happen.
  </para>
  <para>
    In Windows itself, the dialog receives this notification as a WM_HELP message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>

<programlisting>
<![CDATA[

::method init
    self~init:super
    ...
    self~connectResize(onResize)
    self~connectHelp(onHelp)
    ...

::method onHelp unguarded
    use arg id, type, mouseX, mouseY
    if type == "MENU" then w = 'Menu id' id; else w = 'Dialog id' id
    say "Help request:"
    say " " w
    say "  Mouse position x:" mouseX "y:" mouseY

    return 0

/* As the user presses the F1 key at various times when the dialog has the focus
 * the output might be as follows:
 */

Help request:
  Dialog id 12
  Mouse position x: 420 y: 106
Help request:
  Menu id 60
  Mouse position x: 204 y: 93
Help request:
  Menu id 65
  Mouse position x: 203 y: 166
Help request:
  Dialog id 14
  Mouse position x: 218 y: 410
Help request:
  Dialog id 80
  Mouse position x: 387 y: 462
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectKeyPressDialogObject" xreflabel="connectKeyPress"><title>connectKeyPress</title>
<indexterm><primary>connectKeyPress</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectKeyPress</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectKeyPress</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectKeyPress(--methodName--,--keys-+------------+--)-----><
                                          +-,--filter--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectKeyPress</emphasis> method connects a key press
  <xref linkend="ovvEvents"/> notification with a method in the Rexx dialog. A single key or multiple keys can be
  connected to the same method.  Multiple methods can be connected for key press events, but only 1 method can be
  connected to any single key.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>methodName [required]</term>
      <listitem>
      <para>
        The name of the method that is to be invoked when the key press event happens. This argument can not be the
        empty string.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>keys [required]</term>
      <listitem>
      <para>
        The key (or keys) for which the key press event is to be connected. A single key or multiple keys can be
        specified. A range of keys can be used.  Each single key or range of keys is separated by a comma.  A range of
        keys is denoted by using the dash character &quot;-&quot;.  White space within the <emphasis
        role="italic">keys</emphasis> argument is ignored. This argument can not be the empty string.
      </para>
      <para>
        The keys are specified by the numeric value defined by Microsoft for its virtual key set.  These numeric values
        are 0 through 255. There are some integer values between 0 and 255 that do not have a virtual key assigned to
        them. For example, 0, 7, 10, 11, and 255 are not used. The <xref linkend="clsVK"/> class contains
        constants for all of the defined virtual keys.
      </para>
      <para>
        In addition, there are a few keywords that can be used to specify some common key ranges. These keywords are:
        <variablelist>
          <varlistentry><term>ALL</term>
          <listitem>
          <para>
            All keys.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>FKEYS</term>
          <listitem>
          <para>
            All Function keys, other than F1.  (In Windows the F1 key is the help key and the
 <xref linkend="mthConnectHelp"/> method should be used for F1.)
          </para>
          </listitem></varlistentry>
          <varlistentry><term>ALPHA</term>
          <listitem>
          <para>
            The keys A though Z.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>NUMERIC</term>
          <listitem>
          <para>
            The keys 0 through 9.  Note that these are the normal number keys, not the keypad numbers on an enhanced
            keyboard.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>ALPHANUMERIC</term>
          <listitem>
          <para>
            The keys A through Z and 0 through 9.
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      <para>
        <emphasis role="bold">Note</emphasis> that case is insignificant for these keywords as is the order of the
        keywords. A keyword not in the list will result in a return of -9. However, if the argument contains other valid
        key tokens, those keys will be connected to the method.  If there are no other valid key tokens, then no
        connection is made.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>filter [optional]</term>
      <listitem>
      <para>
        A (simplistic) filter that is applied to the key press event for the key(s) specified.  The filter is a string of
        keywords separated by blanks. (Case is not significant, neither is the order of the words.  Any words other than
        the specified keywords are ignored.) The possible keywords are: <computeroutput>SHIFT, CONTROL, ALT, AND, NONE,
        VIRTUAL.</computeroutput>
      </para>
      <para>
        The VIRTUAL keyword can be abbreviated to VIRT if desired. The VIRTUAL keyword effects how the test for the
        shift, control, and alt key is performed. By default the physical state of the keyboard is checked to see if the
        control, alt, or shift key is depressed. However, it is common in Windows to use keystroke programs that inject
        keystrokes into other application windows. Testing the physical state of the keyboard will not detect
        combination keystrokes like Ctrl-S, Alt-L, etc., that are inserted by keystroke programs because the physical
        state of the modifier keys control and alt will not be depressed. If the VIRTUAL keyword is used, the test for
        the modifier keys being down will be altered in a way that will detect if the virtual state of the key is down.
        This test will detect key events inserted into the Rexx application by third party keystroke programs.
      </para>
      <para>
        Shift, control, and alt specify that the corresponding key must be down at the time of the key press event. These
        keywords are combined in a boolean expression.  The default is an OR expression. If the AND keyword is present
        then the boolean expression is an AND expression. If the NONE keyword is used, it means that none of the shift,
        control, or alt keys can be down at the time of the key press event.  (When NONE is used, all other words,
        except VIRTUAL, in the string are ignored.)
      </para>
      <para>
        Some examples may make this more clear:
  <programlisting>
  <![CDATA[

  ::method initDialog

    -- Using the below, the onAltCD method would be invoked when the user types
    -- Alt-Shift-C or Alt-Shift-D.  But the method would not be invoked for Alt-C
    -- or Shift-D (or any other key press event.)

    keys = .VK~C "," .VK~D
    self~connectKeyPress(onAltCD, keys, "ALT AND SHIFT")

    -- The below would invoke the onAltCD method any time a C or a D was typed
    -- with either the Alt or the Control key down.  This would include Alt-C,
    -- Alt-Shift-C, Ctrl-Alt-Shift-C, etc..

    self~connectKeyPress(onAltCD, keys, "ALT CONTROL")

    -- The below would invoke the onAltCD method only when Alt-C or Alt-D was
    -- typed.

    self~connectKeyPress(onAltCD, keys, "ALT AND")

    -- The below would invoke the onF4 method only when the F4 key was pressed by
    -- itself. Alt-F4, Ctrl-F4, etc., would not invoke the method.

    self~connectKeyPress(onF4, .VK~F4, "NONE")
  ]]>
  </programlisting>

      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The possible return values are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        Success.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-2</term>
      <listitem>
      <para>
        The underlying mechanism in the Windows API that is used to capture key events failed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-6</term>
      <listitem>
      <para>
        The maximum number of connections has been reached.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-7</term>
      <listitem>
      <para>
        The <emphasis role="italic">methodName</emphasis> method is already connected to a key down event for this
        dialog.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-8</term>
      <listitem>
      <para>
        The <computeroutput>filter</computeroutput> argument is not correct.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-9</term>
      <listitem>
      <para>
        An incorrect format for the <computeroutput>keys</computeroutput>.  Note that it is possible to get a return of
        -9 but still have some keys connected. For instance in the following example the C and D keys would be connected
        and the filter applied. The &quot;"dog&quot;" token would result in -9 being returned:

<programlisting>
<![CDATA[

  keys = .VK~C ", dog," .VK~D
  ret = self~connectKeyPress('onAltCD', keys, "ALT AND SHIFT")
  say 'Got a return of:' ret
  say "Have connection to onAltCD?" self~hasKeyPressConnection('onAltCD')

  -- The output would be:
  Got a return of: -1
  Have connection to onAltCD? 1

]]>
</programlisting>

      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks</emphasis></term>
  <listitem>
  <para>
    Unlike most other methods that connect event notifications, the underlying Windows dialog must exist before this
    method can be used. That means it can be used in <xref linkend="mthInitDialog"/> or any time
    thereafter.  There is a maximum limit of 63 methods, per dialog, that can be connected to key press events.
    Connections can be removed using the <xref linkend="mthDisconnectKeyPressDialogObject"/>
    method if there is no longer a need for a notification of a key press.
  </para>
  <para>
    The dialog control object also has a <xref linkend="mthConnectKeyPressDialogControlObject"/>()
    method.  It is important to note this distinction between the two methods. The method of the dialog object (this
    method) will capture all key press events when the dialog is the active window. This includes key presses when a
    dialog control in the dialog has the focus.
  </para>
  <para>
    The method of the dialog control object will only capture key press events when the specific dialog control has
    the focus. This implies that if you connect the same key press event to both the dialog and to a specific dialog
    control, if the key press event occurs when the dialog control has the focus, you will receive two event
    notifications.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    In general error return codes are used to indicate incorrect usage rather than raised syntax conditions. However,
    syntax errors are raised for missing required arguments, using the empty string for required arguments, or invoking
    this method before the underlying (<xref linkend="ovvUnderlying" />) dialog is created.
  </para>
  <para>
    Raises syntax errors when some incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    draw events happen.
  </para>
  <para>
    Due to the nature of key press events, the low-level implementation of capturing the key strokes is different from
    most of the other methods of the <computeroutput>EventNotification</computeroutput> class. There is no single message
    sent to the underlying dialog for a key stroke event.
  </para>
  </listitem></varlistentry>
  <varlistentry id="connectKeyPressEventHandler"><term><emphasis role="bold">Event Handler Method Arguments:</emphasis></term>
  <listitem>
  <para>
    The ooDialog method connected to the key press event will receive the following five arguments in the order listed:
    <variablelist>
      <varlistentry><term>keyCode</term>
      <listitem>
      <para>
        The numeric code of the key pressed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>shift</term>
      <listitem>
      <para>
        A boolean (true or false) that denotes whether a shift key was down or up at the time of the key press. It will
        be true if a shift key was down and false if the shift key was not down.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>control</term>
      <listitem>
      <para>
        True if a control key was down at the time of the key press, false if it was not.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>alt</term>
      <listitem>
      <para>
        True if an alt key was down at the time of the key press, false if it was not.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>extraInfo</term>
      <listitem>
      <para>
        This argument is a string containing keywords.  It supplies extra information about the keyboard state at the
        time of a key press event. The string will contain some combination of these keywords
        <variablelist>
          <varlistentry><term>numOn</term>
          <listitem>
          <para>
            Num Lock was on at the time of the key press event.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>numOff</term>
          <listitem>
          <para>
            Num Lock was off.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>capsOn</term>
          <listitem>
          <para>
            Caps Lock was on at the time of the key press event.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>capsOff</term>
          <listitem>
          <para>
            Caps Lock was off.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>scrollOn</term>
          <listitem>
          <para>
            Scroll Lock was on at the time of the key press event.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>scrollOff</term>
          <listitem>
          <para>
            Scroll Lock was off.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>lShift</term>
          <listitem>
          <para>
            The left shift key was down at the time of the key press event.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>rShift</term>
          <listitem>
          <para>
            The right shift key was down.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>lControl</term>
          <listitem>
          <para>
            The left control key was down at the time of the key press event.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>rControl</term>
          <listitem>
          <para>
            The right control key was down.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>lAlt</term>
          <listitem>
          <para>
            The left alt key was down at the time of the key press event.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>rAlt</term>
          <listitem>
          <para>
            The right alt key was down.
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry id="connectKeyPressExample"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example is from a fictitious customer order system.  As the user is filling out a customer order using
    the customer order dialog, he has the F2 through F5 short cut keys available.  F2 brings up a customer look up
    dialog. F3 looks up info on the product number entered in an edit control.  F4 resets the form by clearing all the
    fields. F5 is used to print out the finished invoice.

<programlisting>
<![CDATA[
::method initDialog

  ...

  -- Capture F2 key presses, but not Ctrl-F2 or Alt-F2, etc..
  self~connectKeyPress(onF2, .VK~VK_F2, "NONE")

  -- Same idea for F3, F4, and F5.  This uses the actual numeric value for the
  -- keys without bothering to use the VK class to translate.
  self~connectKeyPress(onF3, 114, "NONE")
  self~connectKeyPress(onF4, 115, "NONE")
  self~connectKeyPress(onF5, 116, "NONE")

  ...

::method onF2 unguarded
  self~showCustomerLookupDialog
  return 0

::method onF3 unguarded

  prodNum = self~newEdit(IDC_EDIT_PRODUCT)~getText
  if prodNum \== "" then self~showProductInfo(prodNum)
  return 0

::method onF4 unguarded
  self~resetAllFields
  return 0

::method onF5 unguarded
  self~printInvoice
  return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectListBoxEvent" xreflabel="connectListBoxEvent"><title>connectListBoxEvent</title>
<indexterm><primary>connectListBoxEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectListBoxEvent(--id--,--event--+---------------+--)----><
                                        +-,--methodName-+

]]>
</programlisting>

<para>The connectListBoxEvent method connects a particular
WM_NOTIFY message for a list box with a method. The WM_NOTIFY message
informs the dialog that an event has occurred in the list box.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box of which a notification is to be connected to
a method.
</para></listitem></varlistentry>
<varlistentry><term>event</term>
<listitem><para>The event to be connected with a method:
<variablelist>
<varlistentry><term>DBLCLK</term>
<listitem><para>An entry in the list box has been selected with a double click.
</para></listitem></varlistentry>
<varlistentry><term>ERRSPACE</term>
<listitem><para>An out-of-memory problem has occurred.
</para></listitem></varlistentry>
<varlistentry><term>GOTFOCUS</term>
<listitem><para>The list box got the input focus.
</para></listitem></varlistentry>
<varlistentry><term>LOSTFOCUS</term>
<listitem><para>The list box lost the input focus.
</para></listitem></varlistentry>
<varlistentry><term>SELCANCEL</term>
<listitem><para>The selection in the list box has been canceled.
</para></listitem></varlistentry>
<varlistentry><term>SELCHANGE</term>
<listitem><para>Another list box entry has been selected.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent whenever the specified notification is
received from the list box. Provide a method with a matching name. If you
omit this argument, the event is preceded by <computeroutput>On</computeroutput>.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The return codes are:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>No error detected.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>The resource ID could not be resolved or the event argument is
incorrect.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The message was not connected correctly. The message was not connected
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
<listitem>
<para>
  Common guidelines on where (<xref linkend="paraWhereToConnectEvents" />) to invoke the <emphasis
  role="italic">connectListBoxEvent</emphasis> method and on how (<xref linkend="sctCodingEventHandlers" />)
  to code event handlers are included in the documentation for the
  <xref linkend="clsEventNotification"/> class.
</para>
<para>
  The event-handling methods receive two arguments: the first is a combination of the ID of the listbox and the ID of
  the notification message. (Extract the low-order word to get the listbox ID.)  The second argument is the window
  handle of the listbox. Example:

<programlisting>
<![CDATA[
::method playSong unguarded
  use arg eventID, handle
  id = .DlgUtil~loWord(eventID)
  ...
  return 0
]]>
</programlisting>

</para>
</listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example displays the text of the selected list box entry:
<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  self~connectListBoxEvent(IDC_LB_PLAYLIST, "SELCHANGE", "SelectionChanged")

::method selectionChanged unguarded
  li = self~newListBox(IDC_LB_PLAYLIST)
  say "New selection is:" li~selected
  return 0
]]>
</programlisting>
</para>
</listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectListViewEvent" xreflabel="connectListViewEvent"><title>connectListViewEvent</title>
<indexterm><primary>connectListViewEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>-connectListViewEvent(--id--,--event--+---------------+--)----><
                                        +-,--methodName-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectListViewEvent</emphasis> method connects a particular
  <xref linkend="ovvEvents"/> notification from a list-view control with an event handling method in the Rexx
  dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The ID of the list-view control for which a notification is to be connected. This can be symbolic or numeric.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event [required]</term>
    <listitem>
    <para>
      The event keyword. Use exactly one of the following keywords, case is not significant:
    <variablelist>
      <varlistentry><term>ACTIVATE</term>
      <listitem>
      <para>
        An item is activated by double-clicking the left mouse button.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>BEGINDRAG</term>
      <listitem>
      <para>
        A drag-and-drop operation was initiated. See <xref linkend="mthDefListDragHandler"/> for
        information on how to implement a drag-and-drop handler.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>BEGINRDRAG</term>
      <listitem>
      <para>
        A drag-and-drop operation involving the right mouse button was initiated. See
 <xref linkend="mthDefListDragHandler"/> for information on how to implement a drag-and-drop
        handler.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>BEGINEDIT</term>
      <listitem>
      <para>
        Editing a label has been started. Do not connect this event if you are using the DEFAULTEDIT keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>ENDEDIT</term>
      <listitem>
      <para>
        Label editing has ended. Do not connect this event if you are using the DEFAULTEDIT keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kwListViewDEFAULTEDIT"><term>DEFAULTEDIT</term>
      <listitem>
      <para>
        This keyword connects the event that label editing has been started and the ended event with event handling
        methods supplied by the ooDialog framework. The supplied methods extract the newly entered text from the
        notification and modifies the item label which was edited. If this keyword is not used you must provide your own
        event-handling methods and connect them with the begin edit and end edit events. Otherwise, the edited text is
        lost and the item label remains unchanged.
      </para>
      <para>
        When you specify this event, omit the <emphasis role="italic">methodName</emphasis> argument. This keyword
        tells the ooDialog framework to use its default methods for both the begin and end edit events.
      </para> </listitem></varlistentry>
      <varlistentry><term>CHANGING</term>
      <listitem>
      <para>
        An item is about to change. The notification for this event is sent before the item is changed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>CHANGED</term>
      <listitem>
      <para>
        An item has changed. The notification for this event is sent after the item changed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>CHECKBOXCHANGED</term>
      <listitem>
      <para>
        The check box state of an item changed.  (The check box was checked or unchecked.) This event can only occur if
        the list-view has the check box <xref linkend="mthAddExtendedStyle"/> list-view style.  Use this
        keyword instead of the CHANGED keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>CLICK</term>
      <listitem>
      <para>
        This event is generated when the list-view is clicked with the left mouse button. However, in report view only,
        this excludes the column headers. Connecting the CLICK event is a replacement for the
 <xref linkend="mthConnectNotifyEvent"/> method's CLICK event.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>DBLCLK</term>
      <listitem>
      <para>
        This event is generated when the list-view is double-clicked with the left mouse button. However, in
        report view only, this excludes the column headers. Connecting the DBLCLK event is a replacement for the
 <xref linkend="mthConnectNotifyEvent"/> method's DBLCLK event.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>COLUMNCLICK</term>
      <listitem>
      <para>
        In report view only, a column header has been clicked.  Contrast this with the CLICK keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>DELETE</term>
      <listitem>
      <para>
        An item has been deleted.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>DELETEALL</term>
      <listitem>
      <para>
        All items have been deleted.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>FOCUSCHANGED</term>
      <listitem>
      <para>
        The focus state of an item changed.  (The item gained or lost the focus.) Use this keyword instead of the
        CHANGED keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>INSERTED</term>
      <listitem>
      <para>
        A new item has been inserted.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>KEYDOWN</term>
      <listitem>
      <para>
        A key was pressed inside the list view. This notification is not sent while a label is being edited.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>SELECTCHANGED</term>
      <listitem>
      <para>
        The selection state of an item changed.  (The item was selected or unselected.)  Use this keyword instead of the
        CHANGED keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>SELECTFOCUSCHANGED</term>
      <listitem>
      <para>
        The selection state or the focus state of an item changed.  This event argument combines the selection changed
        and the focus changed event into one connection.  When this event is connected, separate selection changed and
        focus changed events can not be connected.  This keyword can be abbreviated to SELECTFOCUS. Use this keyword
        instead of the CHANGED keyword.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>methodName</term>
    <listitem>
    <para>
      The name of the event handling method. This method is invoked each time the specified event occurs for the list
      view control. The method name can not be the empty string. If you omit this argument, the event handler method
      name is generated for you. This name will be the event keyword, preceded by <computeroutput>On</computeroutput>.
      For example: <emphasis role="italic">onColumnClick</emphasis>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error detected.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The resource ID could not be resolved or the event argument is incorrect.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The event was not connected correctly. The error is likely caused by the message table being full, but could also
      indicate the interpreter is out of memory.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Microsoft continually enhances the Windows User Interface and therefore the dialog controls evolve over time. The
    <computeroutput>connectListViewEvent</computeroutput> method uses several event keywords that provide more
    information, for the same event, than that provided by the original ooDialog implementation.  For instance, the
    CHECKBOXCHANGED, SELECTIONCHANGED, FOCUSCHANGED, and SELECTFOCUSCHANGED keywords all connect the same event as the
    CHANGED keyword.  However, these keyword connections all provide more specific, detailed information in the arguments
    passed to the connected method than that provided by using the CHANGED keyword.
  </para>
  <para>
    Likewise, the <computeroutput>connectListViewEvent</computeroutput> CLICK keyword provides much better information
    than that provided by the <xref linkend="mthConnectNotifyEvent"/>'s CLICK keyword.
  </para>
  <para>
    <emphasis role="bold">Note:</emphasis> If the same event, for the same control, is connected using two different
    connectXXX methods, only one connection will be in effect.  This will be the connection whose connectXXX method is
    invoked first.  For example, take a dialog that has a list-view control with resource ID of 109.  If the mouse click
    event is connected for that control using the <computeroutput>connectNotifyEvent</computeroutput> method and then
    the mouse click event is also connected using the <computeroutput>connectListViewEvent</computeroutput> method, only
    one connection will be active.  Which one is active is dependent on the order of invocation of the connectXXX
    methods.
  </para>
  <para>
    When using <computeroutput>connectListViewEvent</computeroutput> a separate method can be connected to each of the
    CHECKBOXCHANGED, SELECTIONCHANGED, and FOCUSCHANGED events.  These event connections are all replacements for the
    CHANGED event.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example connects the column-clicked event for the list-view EMPLOYEES with method ColumnAction and
    changes the style of the list-view from REPORT to SMALLICON:
  </para>
  <programlisting>
  <![CDATA[
  ::class MyDlgClass subclass UserDialog

  ::method init
    self~init:super(...)
    self~connectListViewEvent("EMPLOYEES", "COLUMNCLICK", "columnAction")

  ::method columnAction unguarded
    use arg id, column
    lc = self~newListView("EMPLOYEES")
    lc~replaceStyle("REPORT", "SMALLICON EDIT SINGLESEL ASCENDING")
    if column > 0 then ...

    return 0
  ]]>
  </programlisting>
  </listitem></varlistentry>
</variablelist>

<section id="evtListViewCLICK"><title>Click / Double Click Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>CLICK</secondary></indexterm>
<indexterm><primary>ListView Event</primary><secondary>DBLCLK</secondary></indexterm>
<para>
  The event handling method for the CLICK event is invoked when the user clicks on the list-view with the left mouse.
  The event handler for the DBLCLK is invoked when the user double clicks on the list-view. This excludes the column
  headers in report view. Both event handlers receive the same arguments.
</para>
<para>
  Note that the user can click on a list-view item, or on the background of the list view. When the click is on the
  background of the list-view then both the <emphasis role="italic">itemIndex</emphasis> and <emphasis
  role="italic">columnIndex</emphasis> will be -1. The method will receive four arguments:
</para>

<programlisting>
<![CDATA[
  ::method onClick unguarded
    use arg id, itemIndex, columnIndex, keyState

    return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term>id</term>
  <listitem>
  <para>
    The resource ID of the list-view control whose item was clicked.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>itemIndex</term>
  <listitem>
  <para>
    The zero-based index of the item that was clicked, or -1 if the background of the list-view was clicked. In report
    view this is often thought of as the row index.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>columnIndex</term>
  <listitem>
  <para>
    The zero-based index of the subitem that was clicked, or -1 if the click was on the background of the list view. In
    report view this is often thought of as the column of row. In all views other than report view, this arg will always
    be 0.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>keyState</term>
  <listitem>
  <para>
    This argument reports the state of the shift, control, and alt keys at the time of the mouse click.  The argument is
    a string of keywords separated by blanks.  The keywords consist of: SHIFT, CONTROL, ALT, or NONE. The presence of a
    keyword indicates the key was held down when the user clicked on the list-view control.  NONE of course indicates
    that none of the keys were down.  If the user managed to hold all three of the keys down at the time of the mouse
    click, the argument would be the string: <emphasis role="italic">SHIFT CONTROL ALT</emphasis>.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="evtListViewCHECKBOXCHANGED"><title>CheckBoxChanged Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>CHECKBOXCHANGED</secondary></indexterm>
<para>
  The event handler for the checkbox changed event is invoked when the user checks or unchecks a checkbox in the
  <computeroutput>ListView</computeroutput> control. The method receives three arguments:
</para>

<programlisting>
<![CDATA[
::method onCheckboxChanged unguarded
  use arg id, itemIndex, state

  return 0
]]>
</programlisting>
<variablelist>
  <varlistentry><term>id</term>
  <listitem>
  <para>
    The resource ID of the list-view control whose item had the checkbox state changed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>itemIndex</term>
  <listitem>
  <para>
    The index of the item whose checkbox was changed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>state</term>
  <listitem><para>This argument reports whether the check box was checked or
  unchecked.  Its value will be either &quot;CHECKED&quot; or &quot;UNCHECKED&quot;
  </para></listitem></varlistentry>
</variablelist>
<para>
  <emphasis role="bold">Example:</emphasis> The following example is from an address book application. A list-view
  control is filled with the information from the address book, one item for each entry.  The check box changed event is
  connected to the <emphasis role="italic">onCheckboxChanged</emphasis> method. The <emphasis
  role="italic">onCheckboxChanged</emphasis> method will receive 3 arguments: the resource ID of the control, the index
  of the item whose check box changed, and the changed state. If the user checks the check box, that entry is added to a
  mail merge being constructed.  If the user unchecks the box, the entry is removed from the mail merge.
</para>
<programlisting>
<![CDATA[
::class MailingListDlg subclass UserDialog

::method initDialog
  expose mailList

  ...
  mailList = self~newListView(IDC_LV_ADDRESSES)
  ...

  -- Since the methodName argument is omitted, ooDialog will construct a default
  -- name of 'onCheckboxChanged'
  self~connectListViewEvent(IDC_LV_ADDRESSES, "CHECKBOXCHANGED")
  ...

::method onCheckboxChanged unguarded
  expose mailList
  use arg id, itemIndex, state

  if state == "CHECKED" then
    self~addToMailMerge(mailList, itemIndex)
  else
    self~removeFromMailMerge(mailList, itemIndex)

  return 0
]]>
</programlisting>

</section>  <!-- End CheckBoxChanged Event Handler -->

<section id="evtListViewSELECTCHANGE"><title>SelectChange Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>SELECTCHANGE</secondary></indexterm>
<para>
  The event handler for the selection changed event is invoked when the selection state of an item changes. The method
  receives three arguments:
</para>

<programlisting>
<![CDATA[
::method onSelectChanged unguarded
  use arg id, itemIndex, state

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term>id</term>
  <listitem>
  <para>
    The resource ID of the list-view control whose item had the selection changed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>itemIndex</term>
  <listitem>
  <para>
    The index of the item whose selection was changed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>state</term>
  <listitem>
  <para>
    This argument reports whether the item was selected or unselected.  Its value will be either
    &quot;SELECTED&quot; or &quot;UNSELECTED&quot;
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="evtListViewFOCUSCHANGED"><title>FocusChanged Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>FOCUSCHANGED</secondary></indexterm>
<para>
  The event handler for the focus changed event is invoked when an item gains or loses focus. The method receives three
  arguments:
</para>

<programlisting>
<![CDATA[
::method onFocusChanged unguarded
  use arg id, itemIndex, state

  return 0
]]>
</programlisting>
<variablelist>
  <varlistentry><term>id</term>
  <listitem>
  <para>
    The resource ID of the list-view control whose item had the focus changed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>itemIndex</term>
  <listitem>
  <para>
    The index of the item which gained or lost the focus.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>state</term>
  <listitem>
  <para>
    This argument reports whether the focus was gained or lost.  Its value will be either &quot;FOCUSED&quot; or
    &quot;UNFOCUSED&quot;
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="evtListViewSELECTFOCUSCHANGED"><title>SelectFocusChanged Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>SELECTFOCUSCHANGED</secondary></indexterm>
<para>
  The event handle for the selection or focus changed event is invoked when either the selection or the focus of an item
  changes. The method receives 3 arguments:
</para>

<programlisting>
<![CDATA[
::method onSelectFocusChanged unguarded
  use arg id, itemIndex, state

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term>id</term>
  <listitem>
  <para>
    The resource ID of the list-view control whose item had the either the focus or the selection changed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>itemIndex</term>
  <listitem>
  <para>
    The index of the item where the state was changed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>state</term>
  <listitem>
  <para>
    This argument reports whether the focus was gained or lost and whether the selection was gained or lost. Its
    value will contain at least one of the keywords: &quot;SELECTED&quot;, &quot;UNSELECTED&quot;,
    &quot;FOCUSED&quot; or &quot;UNFOCUSED&quot;.  It is possible for both the selection and focus changed to be
    reported at once, however sometimes each change is reported separately. (This has nothing to do with ooDialog,
    it is how the operating system sends the messages.)
  </para>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="evtListViewENDEDIT"><title>EndEdit Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>ENDEDIT</secondary></indexterm>
<para>
  The event-handling method connected to ENDEDIT receives two arguments: the item ID of which the label has been edited
  and the newly entered text.
</para>

<programlisting>
<![CDATA[
::method onEndEdit unguarded
  use arg item, newText

  return 0
]]>
</programlisting>

</section>

<section id="evtListViewCOLUMNCLICK"><title>ColumnClick Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>COLUMNCLICK</secondary></indexterm>
<para>
  The event-handling method connected to COLUMNCLICK receives two arguments: the control ID of the list-view control and
  the zero-based column number of which the header button was pressed.
</para>

<programlisting>
<![CDATA[
::method onColumnClick unguarded
  use arg id, column

  return 0
]]>
</programlisting>

</section>

<section id="evtListViewKEYDOWN"><title>KeyDown Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>KEYDOWN</secondary></indexterm>
<para>
  The event-handling method connected to KEYDOWN receives two arguments: the control ID of the list-view control and the
  virtual key code pressed. Use the <xref linkend="mthKey2Name"/> method of the
 <xref linkend="clsVK"/> class to determine which key was pressed.
</para>

<programlisting>
<![CDATA[
::method onKeyDown unguarded
  use arg id, vkey
  say "Key" .VK~key2name(vkey) "was pressed."

  return 0
]]>
</programlisting>

</section>

<section id="evtListViewBEGINDRAG"><title>BeginDrag Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>BEGINDRAG</secondary></indexterm>

<para>
  The event-handling method connected to BEGINDRAG receives three arguments: the control ID of the list-view control,
  the index of the list item to be dragged, and the point where the mouse cursor was pressed (x and y positions,
  separated by a blank).
</para>

<programlisting>
<![CDATA[
::method onBeginDrag unguarded
  use arg id, item, where

  return 0
]]>
</programlisting>
</section>

<section id="evtListViewBEGINRDRAG"><title>BeginRDrag Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>BEGINRDRAG</secondary></indexterm>

<para>
  The event-handling method connected to BEGINRDRAG receives three arguments: the control ID of the list-view control,
  the index of the list item to be dragged, and the point where the mouse cursor was pressed (x and y positions,
  separated by a blank).
</para>

<programlisting>
<![CDATA[
::method onBeginRightDrag unguarded
  use arg id, item, where

  return 0
]]>
</programlisting>
</section>

</section>

<section id="mthConnectMonthCalendarEvent" xreflabel="connectMonthCalendarEvent"><title>connectMonthCalendarEvent</title>
<indexterm><primary>connectMonthCalendarEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectMonthCalendarEvent</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectMonthCalendarEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectMonthCalendarEvent(--id-,-event-+---------+-+------------+--)-------><
                                           +-,-mName-+ +-,-wilReply-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectMonthCalendarEvent</emphasis> method connects an
  <xref linkend="ovvEvents"/> notification message from a month <xref linkend="clsMonthCalendar"/>
  control to a method in the Rexx dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the month calendar control. May be numeric or symbolic (<xref linkend="defSymbolicId" />).
      </para>
      </listitem></varlistentry>
      <varlistentry><term>event [required]</term>
      <listitem>
      <para>
        Exactly one of the following keywords. The keyword specifies the event to be connected. Case is not significant:
      </para>
      <para>
        <simplelist type='vert' columns='3'>
          <member>GETDAYSTATE</member>  <member>SELECT</member>          <member>VIEWCHANGE</member>
          <member>RELEASED</member>     <member>SELCHANGE</member>
        </simplelist>
      </para>
      <variablelist>
        <varlistentry><term>GETDAYSTATE</term>
        <listitem>
        <para>
           Sent by a month calendar control to request information about how individual days should be displayed. This
           notification message is only sent if the month calendar control has the DAYSTATE style. The <emphasis
           role="italic">willReply</emphasis> argument is ignored for this event, the event handler must
           return (<xref linkend="sctCodingEventHandlers" />) a reply.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>RELEASED</term>
        <listitem>
        <para>
          Sent by the month calendar when the control is releasing the mouse capture. The return value from the event
          handler is ignored for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>SELECT</term>
        <listitem>
        <para>
          Sent by a month calendar control when the user makes an explicit date selection within the control. The return
          value from the event handler is ignored for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>SELCHANGE</term>
        <listitem>
        <para>
          Sent by a month calendar control when the currently selected date or range of dates changes. The return value
          from the event handler is ignored for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>VIEWCHANGE</term>
        <listitem>
        <para>
          <emphasis role="bold">Requires Windows Vista or later</emphasis>. Sent by a month calendar control when the
          current view changes. The return value from the event handler is ignored for this event.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
      <varlistentry><term>mName [optional]</term>
      <listitem>
      <para>
        The name of the method that is to be invoked whenever the specified notification is received from the month
        calendar control. The programmer defines this method. If this argument is omitted, a method name is
        automatically generated that consists of the event keyword preceded by <computeroutput>on</computeroutput>. For
        instance, <computeroutput>onGetDayState</computeroutput>. If the method name is supplied, it can not be the
        empty string.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>willReply [optional]</term>
      <listitem>
      <para>
        The <emphasis role="italic">willReply</emphasis> argument controls whether the interpreters waits for the reply
        from the event handler. The default is <computeroutput>.true</computeroutput>, the interpreter waits until the
        event handling method returns a value. If <emphasis role="italic">willReply</emphasis> is
        <computeroutput>.false</computeroutput>, the interpreter will not wait for the reply. However, this argument is
        ignored for the GETDAYSTATE event. If the programmer connects the GETDAYSTATE, the interpreter waits for the
        return from the connected method. This can not be changed.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    This method returns <computeroutput>.true</computeroutput> if the event notification was connected correctly,
    otherwise <computeroutput>.false</computeroutput> .
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Common guidelines on where (<xref linkend="paraWhereToConnectEvents" />) to invoke the <emphasis
    role="italic">connectMonthCalendarEvent</emphasis> method and on how (<xref linkend="sctCodingEventHandlers" />)
    to code event handlers are included in the documentation for the
    <xref linkend="clsEventNotification"/> class.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected, including the use of an invalid symbolic ID or an
    unrecognized event keyword. A syntax error is raised if the programmer tries to connect the VIEWCHANGED event when
    the operating system is not Windows Vista or later.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if the
    connected event happens.
  </para>
  <para>
    The underlying dialog receives the MCN_* messages as the notifications for the month calendar events.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example updates the text of a static control whenever the user selects a new date in the calendar.
  </para>
<programlisting>
<![CDATA[

::method initDialog

  self~connectMonthCalendarEvent(IDC_MC, "SELECT", onSelect)

::method onSelect unguarded
  expose dateText
  use arg startDate, endDate

  dateText~setText(self~formatDate(startDate))
  return 0

]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>


<section id="evtMonthCalendarGETDAYSTATE"><title>GetDayState Event Handler</title>
<indexterm><primary>MonthCalendar class</primary><secondary>events</secondary><tertiary>GETDAYSTATE</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onGetDayState unguarded
  use arg startDate, count, id, hwnd

  return dayStateBuffer
]]>
</programlisting>

<para>
  The event handler for the get day state event is invoked when the month calendar control requests information on how
  to display days in the calendar. The notification is only sent when the month calendar has the DAYSTATE style. The
  programmer must reply to this notification and <emphasis role="bold">must</emphasis> use the
 <xref linkend="clsDayStates"/> class to properly construct the reply. The interpreter waits for the reply.
</para>
<para>
  The reply is a buffer containing a sequential collection of <xref linkend="clsDayState"/> values. Each
  individual day state value specifies how each day in a single month should be displayed. If a day in the day state
  value is turned on, the day is displayed in bold. If a day is not turned on, it is displayed with no emphasis. The
  <computeroutput>DayStates</computeroutput> and <computeroutput>DayState</computeroutput> classes provide methods to
  properly construct the day state values and the buffer containing the values.
</para>
<para>
  Essentially, the programmer constructs a number of day state values and then returns a buffer containing those values.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives three arguments:
  </para>
  <variablelist>
    <varlistentry><term>startDate</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that specifies the start date the month calendar control needs
      day state values for. Each day state value specifies the state for every day in a month, even if the <emphasis
      role="italic">dayState</emphasis> arg is a date in the middle of a month. I.e., if the start date is January 11,
      2011, the first day state value should be for the month of January.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>count</term>
    <listitem>
    <para>
      The number of day state values required.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID for the month calendar control requesting the information.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window handle (<xref linkend="defHandle" />) for the month calendar control requesting the information.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The reply is a buffer containing a sequential collection of <xref linkend="clsDayState"/> values. Each
    individual day state value specifies how each day in a single month should be displayed. If a day in the day state
    value is turned on, the day is displayed in bold. If a day is not turned on, it is displayed with no emphasis. The
    returned buffer must be constructed by using the <xref linkend="clsDayStates"/> class.
  </para>
  <para>
    The <computeroutput>DayStates</computeroutput> and <computeroutput>DayState</computeroutput> classes provide methods
    to properly construct the day state values and the buffer containing the values. Essentially, the programmer
    constructs a number of day state values and then returns a buffer containing those values.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example is used in a application that displays the 1st and the 15th of each month in bold. The start
    date can be ignored in this case because the day state value is the same for any month.

<programlisting>
<![CDATA[

::method initDialog

  -- Connect the GETDAYSTATE event.
  self~connectMonthCalendarEvent(IDC_MC_PAYDAYS, "GETDAYSTATE", onGetDayState)

::method onGetDayState unguarded
  use arg startDate, count, id, hwnd

  dayStates = .array~new(count)
  do i = 1 to count
    dayStates[i] = .DayState~new(1, 15)
  end

  buffer = .DayStates~makeDayStateBuffer(dayStates)
  return buffer

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End GetDayState Event Handler -->


<section id="evtMonthCalendarRELEASED"><title>Released Event Handler</title>
<indexterm><primary>MonthCalendar class</primary><secondary>events</secondary><tertiary>RELEASED</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onReleased unguarded
  use arg id, hwnd

  return 0
]]>
</programlisting>

<para>
  The event handler for the released event is invoked when the month calendar releases the mouse capture. The
  interpreter waits, or does not wait, for the reply as specified by the programmer in the
 <xref linkend="mthConnectMonthCalendarEvent"/> method. The operating system ignores the value
  of the reply.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives two arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the month calendar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window handle (<xref linkend="defHandle" />) for the month calendar control sending the notification
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    Since the return value is ignored by the operating system, any value can be used. Typically, 0 is returned.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Released Event Handler -->


<section id="evtMonthCalendarSELCHANGED"><title>SelChanged Event Handler</title>
<indexterm><primary>MonthCalendar class</primary><secondary>events</secondary><tertiary>SELCHANGED</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onSelChanged unguarded
  use arg selStart, selEnd, id, hwnd

  return 0
]]>
</programlisting>

<para>
  The event handler for the selection changed event is invoked when the currently selected date or range of dates
  changes. This notification is sent when the user explicitly changes the selection within the current month or when the
  selection is implicitly changed by the user navigating to another month. The operating system also sends this
  notification at regular intervals so that the month calendar control can respond to date changes.
</para>
<para>
  The notification is similar to the SELECT (<xref linkend="evtMonthCalendarSELECT" />) notification, except that the SELECT
  notification is only sent when the user explicitly changes the date. This notification is sent when the selected date
  is changed for any reason.
</para>
<para>
  The interpreter waits, or does not wait, for the reply as specified by the programmer in the
 <xref linkend="mthConnectMonthCalendarEvent"/> method. The operating system ignores the value
  of the reply.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives three arguments:
  </para>
  <variablelist>
    <varlistentry><term>selStart</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the new selected date, or the first selected date in a
      range of selected dates.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>selEnd</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the last selected date in a range of selected dates. If
      only a single date is selected, then <emphasis role="italic">selEnd</emphasis> will be the same date as <emphasis
      role="italic">selStart</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the month calendar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window handle (<xref linkend="defHandle" />) for the month calendar control sending the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The return value is ignored by the operating system and the programmer can return any value. Typically 0 is
    returned.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End SelChanged Event Handler -->

<section id="evtMonthCalendarSELECT"><title>Select Event Handler</title>
<indexterm><primary>MonthCalendar class</primary><secondary>events</secondary><tertiary>SELECT</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onSelect unguarded
  use arg selStart, selEnd, id, hwnd

  return 0
]]>
</programlisting>

<para>
  The SELECT event handler is invoked when the user explicitly selects a new date. Contrast this with the
  SELCHANGE (<xref linkend="evtMonthCalendarSELCHANGED" />) event handler which is invoked when the selected date is changed for any
  reason.
</para>
<para>
  The interpreter waits, or does not wait, for the reply as specified by the programmer in the
 <xref linkend="mthConnectMonthCalendarEvent"/> method. The operating system ignores the value
  of the reply.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives four arguments:
  </para>
  <variablelist>
    <varlistentry><term>selStart</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the new selected date, or the first selected date in a
      range of selected dates.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>selEnd</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the last selected date in a range of selected dates. If
      only a single date is selected, then <emphasis role="italic">selEnd</emphasis> will be the same date as <emphasis
      role="italic">selStart</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the month calendar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window handle (<xref linkend="defHandle" />) for the month calendar control sending the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The programmer can return any value because the operating system ignores the returned value. Typically 0 is
    returned.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Select Event Handler -->

<section id="evtMonthCalendarVIEWCHANGE"><title>ViewChange Event Handler</title>
<indexterm><primary>MonthCalendar class</primary><secondary>events</secondary><tertiary>VIEWCHANGE</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onViewChange unguarded
  use arg oldView, newView, id, hwnd

  return 0
]]>
</programlisting>

<para>
  The view change notification is sent when the current view changes. The notification is only sent on Windows Vista or
  later. A syntax exception is raised if the VIEWCHANGE event is connected when the program is not running on Vista or
  later.
</para>
<para>
  The interpreter waits, or does not wait, for the reply as specified by the programmer in the
 <xref linkend="mthConnectMonthCalendarEvent"/> method. The operating system ignores the value
  of the reply.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives four arguments:
  </para>
  <variablelist>
    <varlistentry><term>oldView</term>
    <listitem>
    <para>
      The <emphasis role="italic">oldView</emphasis> argument is a keyword denoting what the previous view was. It will be
      one of: month, year, decade, or century.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>newView</term>
    <listitem>
    <para>
      The <emphasis role="italic">newView</emphasis> argument is a keyword denoting what the view was changed to. It also
      will be one of: month, year, decade, or century.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the month calendar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window handle (<xref linkend="defHandle" />) for the month calendar control sending the notification
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End ViewChange Event Handler -->

</section>  <!-- End EventNotification::connectionMonthCalendarEvent() -->

<section id="mthConnectMove" xreflabel="connectMove"><title>connectMove</title>
<indexterm><primary>connectMove</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectMove</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectMove</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectMove(--+--------------+--)------------><
                  +--methodName--+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectMove</emphasis> method connects a dialog move event notification with a method in
  the Rexx dialog. The notification is sent after the position of the dialog has changed.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The only argument is:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that will be invoked each time the dialog has moved. The name can not be the empty string.
      When this argument is omitted the name defaults to <emphasis role="italic">onMove</emphasis>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    move events happen.
  </para>
  <para>
    The underlying dialog receives this event notification as a WM_MOVE message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>

<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  forward class (super) continue

  self~connectMove(onMove)

::method onMove unguarded
  use arg unUsed, posInfo

  -- The dialog position has changed, print out where we are.
  x = .DlgUtil~loWord(posInfo)
  y = .DlgUtil~hiWord(posInfo)
  say 'At coordinate (' x',' y' ) on the screen. (In pixels.)'

  return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectNotifyEvent" xreflabel="connectNotifyEvent"><title>connectNotifyEvent</title>
<indexterm><primary>connectNotifyEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectNotifyEvent</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectNotifyEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectNotifyEvent(--id--,--event--+---------------+--)-----><
                                       +-,--methodName-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectNotifyEvent</emphasis> method connects one of the generic event notifications from
  a dialog control to a method in the Rexx dialog object.
</para>
<para>
  Most event notifications are specific to the particular type of control that sends them. These generic event
  notifications are common to a number of dialog controls. In general, if one of the dialog control specific event
  connection methods, such as <xref linkend="mthConnectListViewEvent"/> can make a connection
  for the event, then <emphasis role="italic">connectNotifyEvent</emphasis> should not be used. In these cases, the
  dialog control does not send one of the generic event notifications. It sends a notification specific to itself.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem><para>The arguments are:
  <variablelist>
    <varlistentry><term>id</term>
    <listitem><para>The ID of the dialog control of which a notification is to be connected
    to a method.
    </para></listitem></varlistentry>
    <varlistentry><term>event</term>
    <listitem><para>The event to be connected with a method:
    <variablelist>
      <varlistentry><term>OUTOFMEMORY</term>
      <listitem><para>The dialog control went out of memory.
      </para></listitem></varlistentry>
      <varlistentry><term>CLICK</term>
      <listitem><para>The left mouse button was clicked on the dialog control.
      </para></listitem></varlistentry>
      <varlistentry><term>DBLCLK</term>
      <listitem><para>The left mouse button was double-clicked on the dialog control.
      </para></listitem></varlistentry>
      <varlistentry><term>ENTER</term>
      <listitem><para>The return key was pressed in the dialog item.
      </para></listitem></varlistentry>
      <varlistentry><term>RCLICK</term>
      <listitem><para>The right mouse button was clicked on the dialog item.
      </para></listitem></varlistentry>
      <varlistentry><term>RDBLCLK</term>
      <listitem><para>The right mouse button was double-clicked on the dialog control.
      </para></listitem></varlistentry>
      <varlistentry><term>GOTFOCUS</term>
      <listitem><para>The dialog item got the input focus.
      </para></listitem></varlistentry>
      <varlistentry><term>LOSTFOCUS</term>
      <listitem><para>The dialog item lost the input focus.
      </para></listitem></varlistentry>
    </variablelist>
    </para></listitem></varlistentry>
    <varlistentry><term>methodName</term>
    <listitem><para>The message that is to be sent whenever the specified notification is
    received. Provide a method with a matching name. If you omit this argument,
    the event is preceded by <computeroutput>On</computeroutput>.
    </para></listitem></varlistentry>
  </variablelist>
  </para></listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem><para>The return codes are:
  <variablelist>
    <varlistentry><term>0</term>
    <listitem><para>No error detected.
    </para></listitem></varlistentry>
    <varlistentry><term>-1</term>
    <listitem><para>The resource ID could not be resolved or the event argument is
    incorrect.
    </para></listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem><para>The message was not connected correctly. The message was not connected
    </para></listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
    <para>
      The <emphasis role="italic">connectNotifyEvent</emphasis> method is a member of the
      <xref linkend="clsEventNotification"/> mixin class.
    </para>
    <para>
      Syntax errors are raised when incorrect usage is detected.
    </para>
    <para>
      If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if the
      connected event happen.
    </para>
    <para>
      In Windows itself, these events are sent to the parent dialog using the WM_NOTIFY message.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example connects the double-click of the left mouse button on dialog control DLGITEM1 with method
    onDblClk:
<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  self~init:super(...)
  self~connectNotifyEvent(DLGITEM1, "DBLCLK")

::method onDblClk unguarded
  use arg id, hwnd
  say "Control" id " has been double-clicked! It's window handle is:" hwnd

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectPosChanged" xreflabel="connectPosChanged"><title>connectPosChanged</title>
<indexterm><primary>connectPosChanged</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectPosChanged</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectPosChanged</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectPosChanged(--+--------------+--)------><
                        +--methodName--+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectPosChanged</emphasis> method connects the position changed event notification sent
  to a dialog to a method in the Rexx dialog object. This notification is sent to the dialog when its size, position, or
  place in the Z order has changed.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The only argument is:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that will be invoked each time the dialog has moved. The name can not be the empty string.
      When this argument is omitted the name defaults to <emphasis role="italic">onPosChanged</emphasis>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    position changed events happen.
  </para>
  <para>
    In Windows itself, the dialog receives this event notification as a WM_WINDOWPOSCHANGED message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>

<programlisting>
<![CDATA[
::class 'MyDlgClass' subclass UserDialog

::method initDialog
  ...
  self~connectPosChanged("onNewPos")

::method onNewPos unguarded
  rect = self~windowRect
  say "The new dialog window rectangle is:"
  say "  Left:  " rect~left
  say "  Top:   " rect~top
  say "  Right: " rect~right
  say "  Bottom:" rect~bottom

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectResize" xreflabel="connectResize"><title>connectResize</title>
<indexterm><primary>connectResize</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectResize</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectResize</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectResize(--+--------------+--+---------+--)------------><
                    +--methodName--+  +-,-synch-+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectResize</emphasis> method connects a size event notification to the underlying
  dialog with a method in the Rexx dialog. The notification is sent to the dialog after its size has changed.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that is invoked each time the size of the dialog has changed. The method name can not be the
      empty string. When this argument is omitted the name defaults to <emphasis role="italic">onResize</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>synch [optional]</term>
    <listitem>
    <para>
      A boolean value that specifies if the interpreter should invoke the event handler
      directly (<xref linkend="ovvEventsDirectReply" />) or not. The default is <computeroutput>.true</computeroutput>, see
      the remarks. If this behavior is not desired, the <emphasis role="italic">synch</emphasis> argument can be used to
      specify that the interpreter should not wait for a reply.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Typically when the user is resizing a window, there are many event notifications that come quickly. In older
    ooDialog versions, where the notification was placed on a queue to be processed at a later date, this caused a
    number of notifications to be placed on the queue before a single notification was processed. Programs that
    connected the resize event perform poorly when many notifications pile up before they are processed.
  </para>
  <para>
    The poor performance is mostly fixed by having the interpreter invoke the event handler directly, which causes each
    notification to be processed one by one. When <emphasis role="italic">synch</emphasis> is true, all ooDialog
    programs that connect the resize event are likely to perform much better. This is why the default is true.
  </para>
  <para>
    Normally, when the interpreter waits for the event handler to return, a syntax condition is raised if a value is not
    returned from the event handler. The <emphasis role="italic">synch</emphasis> option causes the interpreter to wait
    until the event handler returns, but to not expect a returned value. This provides backwards compatibility for older
    programs where the programmer <emphasis role="bold"><emphasis role="italic">mistakenly</emphasis></emphasis> did not
    return a value from event handlers. Best practice is to <emphasis role="italic">always</emphasis> return a value
    from an event handler. If the operating system ignores the return value, return 0.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    size events happen.
  </para>
  <para>
    The underlying dialog receives the WM_SIZE message as the notification for this event.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example 1:</emphasis></term>
  <listitem>

<programlisting>
<![CDATA[
  dlg = .ResizingDialog~new
  dlg~createCenter(100, 60, "Resize Me", "THICKFRAME")
  dlg~execute("SHOWTOP")

::requires 'ooDialog.cls'

::class 'ResizingDialog' subclass UserDialog

::method init
  forward class (super) continue

  self~connectResize("onSize")

::method onSize unguarded
  use arg sizeEvent, sizeInfo

  -- sizeInfo contains information about the new width and height in pixels.
  w = .DlgUtil~loWord(sizeinfo)
  h = .DlgUtil~hiWord(sizeinfo)
  say "New width=" w ", new height=" h

  return 0
]]>
</programlisting>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example 2:</emphasis></term>
  <listitem>
  <para>
    This example is pulled from the File Viewer (<xref linkend="exampleFileViewer" />) example at the end of the
    &quot;Appearance and Behavior Methods&quot; section. A complete working example is presented there that uses a
    number of the dialog methods.

<programlisting>
<![CDATA[

::method defineDialog
  expose wasMinimized

  wasMinimized = .false
  style = "VSCROLL HSCROLL MULTILINE READONLY"
  self~createEdit(IDC_MULTILINE, 0, 0, 170, 180, style, "cEntry")
  self~connectResize("onSize")
  ...

/* The first arg, sizeEvent, is a flag that the OS sends specifying the type of
 * size event.  We are only interested in these 3 flags:
 *
 * SIZE_RESTORED   = 0
 * SIZE_MINIMIZED  = 1
 * SIZE_MAXIMIZED  = 2
 */
::method onSize unguarded
  expose wasMinimized
  use arg sizeEvent, sizeInfo

  if sizeEvent = 1 then wasMinimized = .true

  if sizeEvent = 0 |  sizeEvent = 2 then do
    if \ wasMinimized then self~resizeEditControl
    wasMinimized = .false
  end

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectResizing" xreflabel="connectResizing"><title>connectResizing</title>
<indexterm><primary>connectResizing</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectResizing</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectResizing</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectResizing(--+--------------+--)--------><
                      +--methodName--+
]]>
</programlisting>

<para>
  Connects a <emphasis role="italic">sizing</emphasis> <xref linkend="ovvEvents"/> notification sent to the
  underlying dialog with a method in the Rexx dialog. The notification is sent to the dialog <emphasis
  role="italic">before</emphasis> its size has changed.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The only argument is:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that is invoked each time the size of the dialog is about to be changed. The method name
      can not be the empty string. When this argument is omitted the name defaults to <emphasis
      role="italic">onResizing</emphasis>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    By processing the sizing event notification, the programmer can monitor the size and position of the drag rectangle
    of the dialog being resized and, if desired, can change its size or position.
  </para>
  <para>
    Common guidelines on where (<xref linkend="paraWhereToConnectEvents" />) to invoke the <emphasis
    role="italic">connectResizing</emphasis> method and on how (<xref linkend="sctCodingEventHandlers" />)
    to code event handlers are included in the documentation for the
    <xref linkend="clsEventNotification"/> class.
  </para>
  <para>
    The interpreter invokes the event handler directly and waits in the window
    message (<xref linkend="ovvWindowMessages" />) processing loop for the return from the event handler. Connecting the
    sizing event requires that the programmer reply to the event from the event handler in a timely manner.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Event Handler:</emphasis></term>
  <listitem>
  <para>
    The event handler for the sizing event is invoked when the user is dragging the sizing border of the dialog to
    change the size of the dialog. The programmer must reply <computeroutput>.true</computeroutput> or
    <computeroutput>.false</computeroutput> to this notification.
  </para>
  <para>
    The event handler receives 2 arguments. The first argument is a <computeroutput>Rect</computeroutput> object with
    the coordinates of the new size for the dialog. The programmer can change the coordinates in the
    <computeroutput>Rect</computeroutput> object and reply <computeroutput>.true</computeroutput>. This causes the
    dialog to be resized to the changed coordinates in the <computeroutput>Rect</computeroutput> object rather than the
    coordinates originally specified.
  </para>
  <para>
    If the programmer replies <computeroutput>.false</computeroutput>, then any changes to the coordinates in the
    <computeroutput>Rect</computeroutput> object are ignored and the dialog's size is changed to the size originally
    specified.
  </para>
  <para>
    A typical event handler would look like this:
  </para>

<programlisting>
<![CDATA[
::method onResizing unguarded
  use arg rect, direction
  ...
  return boolean
]]>
</programlisting>
  <para>
    The arguments to the event handler are:
    <variablelist>
      <varlistentry><term>rect</term>
      <listitem>
      <para>
        A <computeroutput>Rect</computeroutput> object that specifies the size the dialog is about to be changed to.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>direction</term>
      <listitem>
      <para>
        A keyword that specifies which edge of the dialog window is being sized. The keyword will be exactly one of the
        following:
      </para>
      <para>
        <simplelist type='vert' columns='3'>
          <member>BOTTOM</member>   <member>BOTTOMLEFT</member> <member>BOTTOMLEFT</member>
          <member>LEFT</member>     <member>RIGHT</member>      <member>TOP</member>
          <member>TOPLEFT</member>  <member>TOPRIGHT</member>
        </simplelist>
      </para>
      <variablelist>
        <varlistentry><term>BOTTOM</term>
        <listitem>
        <para>
          The bottom edge is being dragged.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>BOTTOMLEFT</term>
        <listitem>
        <para>
          The bottom-left corner is being dragged.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>BOTTOMRIGHT</term>
        <listitem>
        <para>
          The bottom-right corner is being dragged.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>LEFT</term>
        <listitem>
        <para>
          The left edge is being dragged.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>RIGHT</term>
        <listitem>
        <para>
          The right edge is being dragged.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>TOP</term>
        <listitem>
        <para>
          The top edge is being dragged.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>TOPLEFT</term>
        <listitem>
        <para>
          The top-left corner is being dragged.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>TOPRIGHT</term>
        <listitem>
        <para>
          The top-right corner is being dragged.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    sizing events happen.
  </para>
  <para>
    The underlying dialog receives the WM_SIZING message as the notification for this event.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example shows, partially, how to prevent a resizable dialog from being sized smaller than 300 pixels high. A
    complete implementation would also have to handle the TOPLEFT, TOPRIGHT, etc., directions. And, normally, an
    implementation would also enforce a minimum width.
  </para>
  <para>
    A complete implementation can be found in the <computeroutput>dlgAreaDemoThree.rex</computeroutput> example program.

<programlisting>
<![CDATA[
::method init
  ...

  self~connectResizing("onSizing")

::method onSizing unguarded
  use arg rect, direction

  select
    when direction == 'TOP' then do
      if rect~bottom - rect~top < 300 then do
        rect~top = rect~bottom - 300
        return .true
      end
    end
    when direction == 'BOTTOM' then do
      if rect~bottom - rect~top < 300 then do
        rect~bottom = rect~top + 300
        return .true
      end
    end
    ...
    otherwise
      nop
  end

  return .false

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectScrollBarEvent" xreflabel="connectScrollBarEvent"><title>connectScrollBarEvent</title>
<indexterm><primary>connectScrollBarEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectScrollBarEvent(--id--,--event--+---------+-+-------------+--)-------><
                                          +-,-mName-+ +-,-willReply-+

]]>
</programlisting>

<para>
  Connects a method in the Rexx dialog to the Windows <xref linkend="ovvEvents"/> notification from a
  scroll <xref linkend="clsScrollBar"/> control.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
  <varlistentry><term>id [required]</term>
  <listitem>
  <para>
    The resource ID of the scroll bar whose event notification is to be connected. May be numeric or
    symbolic (<xref linkend="defSymbolicId" />).
  </para>
  </listitem></varlistentry>
  <varlistentry><term>event [required]</term>
  <listitem>
  <para>
    A keyword specifying which scroll bar event should be connected. This methods connects either a vertical or a
    horizontal scroll bar. The symbolic keyword names are orientated towards which type the scroll bar is. But the
    values that the scroll bar sends are the same for similar events.
  </para>
  <para>
    I.e., one event is to move 1 unit towards the upper left. For a vertical scroll bar this is one line up (LINEUP),
    for a horizontal scroll bar this is one unit to the left (LINELEFT). But, the numeric value that a scroll bar sends
    for the event is the same. Therefore, the LINEUP and LINELEFT keywords produce the identical effect. If the scroll
    bar is a vertical scroll bar, using the LINELEFT keyword produces the same effect as using the LINEUP keyword. The
    programmer can use whichever keyword makes the most sense.
  </para>
  <para>
    The keyword must be one of the following, case is not significant:
  </para>
  <para>
    <simplelist type='vert' columns='3'>
      <member>LINEUP   </member>
      <member>LINELEFT </member>
      <member>LINEDOWN </member>
      <member>LINERIGHT</member>
      <member>PAGEUP   </member>
      <member>PAGELEFT </member>
      <member>PAGEDOWN </member>
      <member>PAGERIGHT</member>
      <member>POSITION </member>
      <member>DRAG     </member>
      <member>TOP      </member>
      <member>LEFT     </member>
      <member>BOTTOM   </member>
      <member>RIGHT    </member>
      <member>ENDSCROLL</member>
    </simplelist>
    <variablelist>
      <varlistentry><term>LINEUP LINELEFT</term>
      <listitem>
      <para>
        The scroll bar was scrolled to the left or up by one unit.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>LINEDOWN LINERIGHT</term>
      <listitem>
      <para>
        The scroll bar was scrolled to the right or down by one unit.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>PAGELEFT PAGEUP</term>
      <listitem>
      <para>
        The scroll bar was scrolled to the left or up by one page size.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>PAGERIGHT PAGEDOWN</term>
      <listitem>
      <para>
        The scroll bar was scrolled to the right or down by one page size.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>DRAG</term>
      <listitem>
      <para>
        The user is dragging the scroll box. This message is sent repeatedly until the user releases the mouse button.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>TOP LEFT</term>
      <listitem>
      <para>
        The scroll bar was scrolled completely to the top or to the left.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>BOTTOM RIGHT</term>
      <listitem>
      <para>
        The scroll bar was scrolled completely to the bottom or to the right.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>ENDSCROLL</term>
      <listitem>
      <para>
        Scrolling has been ended, that is, the appropriate key or mouse button has been released.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>POSITION</term>
      <listitem>
      <para>
        The scroll box (thumb) of the scroll bar was dragged and the user has released the mouse button.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term>mName [optional]</term>
  <listitem>
  <para>
    The name of the method that is to be invoked whenever the specified notification is received from the scroll bar. If
    this argument is omitted, the method name is automatically generated by concatenating <emphasis
    role="italic">on</emphasis> with the event keyword. For example, <emphasis role="italic">onLineUp</emphasis>.
  </para> </listitem></varlistentry>
  <varlistentry><term>willReply [optional]</term>
  <listitem>
  <para>
    The <emphasis role="italic">willReply</emphasis> argument controls whether the interpreter
    waits (<xref linkend="sctCodingEventHandlers" />) for the reply from the event handler. The default is
    <computeroutput>.false</computeroutput>, the interpreter will not wait for the reply. If <emphasis
    role="italic">willReply</emphasis> is <computeroutput>.true</computeroutput>, the interpreter waits until the
    event handling method returns a value.
  </para>
  </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return codes are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        No error detected.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
      <para>
        The resource ID could not be resolved or the event argument is incorrect.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
      <para>
        The messages was not connected correctly.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks</emphasis></term>
  <listitem>
  <para>
    This method requires that the underlying (<xref linkend="ovvUnderlying" />) scroll bar exists. Therefore, the method
    is best invoked in the <xref linkend="mthInitDialog"/> method. At some later point in the life cycle
    of the dialog is fine. If the method is invoked before the underlying dialog has been created a syntax condition is
    raised.
  </para>
  <para>
    Common guidelines on how (<xref linkend="sctCodingEventHandlers" />) to code event handlers are included in the
    documentation for the <xref linkend="clsEventNotification"/> class.
  </para>
  <para>
    When the user interacts with a scroll bar, the operating system does not reposition the scroll box (thumb.) Rather,
    the operating system relies on the application, (in essence the programmer,) to update the scroll bar position
    during the scroll bar event notification. Therefore, if the scroll bar event is not connected, or the programmer
    does not reposition the scroll box in the event handler, it will appear to the user that the scroll box can not be
    moved.
  </para>
  <para>
    The event handler receives two arguments as shown:

<programlisting>
<![CDATA[
::method onScrollBarEvent unguarded
  use arg posInfo, hwnd

  return 0
]]>
</programlisting>

    The <emphasis role="italic">posInfo</emphasis> argument contains the scroll bar event code in the low word of the
    argument. For the POSITION and the DRAG events, the high word contains the position of the scroll box. For the other
    events, the high word is not used. When the notification comes from a <xref linkend="clsScrollBar"/> bar
    control, the <emphasis role="italic">hwnd</emphasis> argument is the window handle of the scroll bar. When the
    notification does not come from a scroll bar control, <emphasis role="italic">hwnd</emphasis> is 0.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example connects the POSITION event with a method in the Rexx dialog. Since the third argument is
    omitted, the ooDialog framework automatically connects the event to the <emphasis
    role="italic">onPosition</emphasis> method. The event handler extracts the new position from the notification
    arguments and sets the position for the scroll bar. It also displays the new position and the event type. The
    <computeroutput>ScrollBar</computeroutput> class provides the THUMBPOSITION (<xref linkend="sctSBEventCode" />)
    constant, whose value is the value of the POSITION event code.

<programlisting>
<![CDATA[
::class 'SimpleDialog subclass UserDialog

::method initDialog

  self~connectScrollBarEvent(IDC_SB_FILE, "POSITION")

::method onPosition unguarded
  use arg posInfo, hwnd

  pos       = .DlgUtil~hiWord(posData)
  eventCode = .DlgUtil~loWord(posData)

  -- Set the scroll bar to the new position and have it redraw itself.
  self~newScrollBar(IDC_SB_FILE)~setPos(pos, .true)

  say "Pos:" pos
  say "Verify event code:
  say "  THUMBPOSITION:" .ScrollBar~THUMBPOSITION
  say "  This event:   " eventCode

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectSizeMoveEnded" xreflabel="connectSizeMoveEnded"><title>connectSizeMoveEnded</title>
<indexterm><primary>connectSizeMoveEnded</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectSizeMoveEnded</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectSizeMoveEnded</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectSizeMoveEnded(--+--------------+--+--------------+--)---------------><
                           +--methodName--+  +-,-willReply--+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectSizeMoveEnded</emphasis> method connects the Windows exit size / move
  <xref linkend="ovvEvents"/> with an event handling method in the Rexx dialog object. This event is sent exactly
  one time when the user has stopped moving or stopped resizing the dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the event handling method that to be invoked when the the size / move exit event occurs. The name must
      not be the empty string. When this argument is omitted the name defaults to <emphasis
      role="italic">onSizeMoveEnded</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The default behavior is for the interpreter to wait in the window message (<xref linkend="ovvWindowMessages" />)
      processing loop for the return from the event handler, (the default for <emphasis
      role="italic">willReply</emphasis> is <computeroutput>.true</computeroutput>). However, the operating system
      ignores the return from this event notification. Specifying <computeroutput>.false</computeroutput> changes the
      default behavior so that the interpreter does not wait for the return from the event handling method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return values are:
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Unlike most event handlers, the event handling method for the size / move ended event does not receive any
    arguments. As noted above, the Windows operating system ignores the return value to the event notification.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    exit size / move events happen.
  </para>
  <para>
    In Windows itself, the dialog receives this notification as a WM_EXITSIZEMOVE message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example comes from a resizable dialog implemented through the <xref linkend="clsDlgAreaU"/>
    class. It turns off forcing the dialog controls to redraw in the <computeroutput>DlgAreaU</computeroutput> object,
    and only has the controls redraw once when the sizing is finished.

<programlisting>
<![CDATA[

::method init
    expose sizing

    self~init:super
    ...
    self~connectResize('onResize')
    self~connectSizeMoveEnded('onExitSizeMove')
    sizing = .false
    ...


::method defineDialog
  expose u

  u = .dlgAreaU~new(self)
  u~updateOnResize = .false


::method onResize unguarded
  expose u sizing
  use arg ignored, sizeinfo

  sizing = .true

  u~resize(self, sizeinfo)
  return 0

::method onExitSizeMove unguarded
    expose sizing

    if sizing then do
      -- The user has stopped sizing the dialog, we'll now show all the dialog
      -- controls we hid previously, and force the controls to redraw.
      self~showAllControls
      self~update
      sizing = .false
    end

    return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectStaticEvent" xreflabel="connectStaticEvent"><title>connectStaticEvent</title>
<indexterm><primary>connectStaticEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectStaticEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectStaticNotify(--id--,--event--,-+---------------+--)--><
                                          +-,--methodName-+

]]>
</programlisting>

<para>
  <emphasis role="italic">connectStaticEvent</emphasis> connects a notification message from a static control to a
  method, defined by the programmer, in the Rexx dialog object.  Normally, static controls do not send notification
  messages.  A static control will only send the messages when it has the NOTIFY style.  The notification messages
  inform the dialog that an event has occurred with regard to the static control.
</para>
<para>
  For user defined dialogs use the NOTIFY style keyword in the create... (<xref linkend="sctCreateStaticControls" />)
  static control methods when the control is defined. For dialogs created from a compiled resource or a resource script
  file use the SS_NOTIFY style when defining the control in a resource editor.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the static control. May be numeric or symbolic.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event [required]</term>
    <listitem>
    <para>
      A keyword specifying the event to be connected with a method:
      <variablelist>
        <varlistentry><term>CLICK</term>
        <listitem>
        <para>
          The static control has been clicked with the mouse.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>DBLCLK</term>
        <listitem>
        <para>
          The static control has been double-clicked with the mouse.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>DISABLE</term>
        <listitem>
        <para>
          The static control has been disabled.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ENABLE</term>
        <listitem>
        <para>
          The static control has been enabled.
        </para>
        </listitem></varlistentry>
      </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The method that is to be invoked whenever the specified notification is received from the static control. The
      programmer defines this method. The method name can not be the empty string. If this argument is omitted, a
      method name is automatically generated that consists of the event keyword preceded by
      <computeroutput>on</computeroutput>. For instance, <computeroutput>onClick</computeroutput>.
    </para>
    </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
    <para>
      The return codes are:
      <variablelist>
      <varlistentry><term>0</term>
      <listitem>
        <para>
          No error detected.
        </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
        <para>
          The resource ID could not be resolved or the event argument is incorrect.
        </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
        <para>
          The message was not connected correctly. The message was not connected
        </para>
      </listitem></varlistentry>
      </variablelist>
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <orderedlist>
  <listitem>
  <para>
    There are some common (<xref linkend="paraWhereToConnectEvents" />) guidelines for the invocation of the event
    connection methods.
  </para>
  </listitem>
  <listitem>
  <para>
    The defined event-handling method will receive two arguments. The first arg contains information about the
    specific control and its event. The second arg is the window handle of the static control.
  </para>
  <para>
    The low word of the first arg is the control ID and the high word is the event ID.
  </para>
  </listitem>
  </orderedlist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example comes from an application that displays employee statistics.  A single click on the employee
    number field advances the display to the next employee.  A double click on either the employee name or employee job
    duties allows those fields to be edited.
  </para>
<programlisting>
<![CDATA[
::method initDialog

  self~connectStaticEvent(IDC_ST_EMPNO, "CLICK", empLookup)

  self~connectStaticEvent(IDC_ST_EMPJOB, "DBLCLK", editStats)
  self~connectStaticEvent(IDC_ST_EMPNAME, "DBLCLK", editStats)

  first = self~initDatabase
  self~setStats(first)
]]>
</programlisting>
  <para>
    In this example, (a continuation of the above example,) the control ID determines if the user has double clicked on
    the employee job duties field, or the employee name field.  The event ID is not used, or needed. Its purpose in the
    code snippet is simply an example. The same thing applies to the window handle.
  </para>
<programlisting>
<![CDATA[
::method editStats unguarded
  use arg ctrlInfo, ctrlHwnd

  ctrlID = .DlgUtil~loWord(ctrlInfo)
  eventID = .DlgUtil~hiWord(ctrlInfo)

  rec = self~getCurrentRecord

  if self~userUpdate(ctrlID, rec) then self~setStats(rec)

  return 0
]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectTabEvent" xreflabel="connectTabEvent"><title>connectTabEvent</title>
<indexterm><primary>connectTabEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectTabEvent(--id--,--event--+---------------+--+--------------+--)-----><
                                    +-,--methodName-+  +-,--willReply-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectTabEvent</emphasis> method connects a specific
  <xref linkend="ovvEvents"/> notification from a tab control with an event handling method in the Rexx
  dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the tab control whose event notification is to be connected to a method in the Rexx dialog.
        May be numeric or symbolic (<xref linkend="defSymbolicId" />).
      </para>
      </listitem></varlistentry>
      <varlistentry><term>event [required]</term>
      <listitem>
      <para>
        A single keyword indicating which event is to be connected. The event keywords are:
        <variablelist>
          <varlistentry><term>KEYDOWN</term>
          <listitem>
          <para>
            The notification is sent when a key has been pressed while the tab control has the focus.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>SELCHANGE</term>
          <listitem>
          <para>
            A new tab has been selected in the tab control. This method is called after the selection has changed.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>SELCHANGING</term>
          <listitem>
          <para>
            A new tab has been selected in the tab control. This method is called before the selection is changed. The
            programmer can prevent the selected tab being changed at this point if the <emphasis
            role="italic">willReply</emphasis> argument is set to <computeroutput>.true</computeroutput>.
          </para>
          <para>
            The selection is prevented from changing by returning <computeroutput>.false</computeroutput>
            from the event handler for this event. Returning <computeroutput>.true</computeroutput> allows the change.
            Again, <emphasis role="bold">note</emphasis>, that preventing the change is only possible by specifying
            <computeroutput>.true</computeroutput> for the <emphasis role="italic">willReply</emphasis> argument. If
            <emphasis role="italic">willReply</emphasis> is <computeroutput>.false</computeroutput>, the default, the
            reply from the event handling method is ignored.
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      </listitem></varlistentry>
      <varlistentry><term>methodName [optional]</term>
      <listitem>
      <para>
        The method name that is invoked whenever the specified notification is received from the tab control. Provide
        a method with a matching name. If you omit this argument, the method name is automatically generated by the
        ooDialog framework. The generated name will be the event keyword preceded by
        <computeroutput>on</computeroutput>, for example <emphasis role="italic">onSelChanging</emphasis>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>willReply [optional]</term>
      <listitem>
      <para>
        The <emphasis role="italic">willReply</emphasis> argument controls whether the interpreter
        waits (<xref linkend="sctCodingEventHandlers" />) for the reply from the event handler. The default is
        <computeroutput>.false</computeroutput>, the interpreter will not wait for the reply. If <emphasis
        role="italic">willReply</emphasis> is <computeroutput>.true</computeroutput>, the interpreter waits until the
        event handling method returns a value.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return codes are:
    <variablelist>
    <varlistentry><term>0</term>
    <listitem><para>No error detected.
    </para></listitem></varlistentry>
    <varlistentry><term>-1</term>
    <listitem><para>The resource ID could not be resolved or the event argument is
    incorrect.
    </para></listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem><para>The messages was not connected correctly.
    </para></listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Common guidelines on where (<xref linkend="paraWhereToConnectEvents" />) to invoke the <emphasis
    role="italic">connectTabEvent</emphasis> method and on how (<xref linkend="sctCodingEventHandlers" />)
    to code event handlers are included in the documentation for the
    <xref linkend="clsEventNotification"/> class.
  </para>
  <para>
    The event-handling method for the KEYDOWN event receives two arguments: info about the event, the control ID of the
    tab control is in the low order word of this argument. The second argument is the virtual key code that was pressed.
    Use the the <xref linkend="clsVK"/> class to determine which key was pressed. Example:

<programlisting>
<![CDATA[
::method onKeyDown unguarded
  use arg info, vkey

  id = .DlgUtil~loWord(info)

  if vKey == .VK~NEXT | vKey == .VK~PREVIOUS then do
    -- do something ...
  end
  else if vKey == .VK~HOME | vKey == .VK~END then do
    -- do something else ...
  end

  -- Other keys are ignored

  return 0

]]>
</programlisting>

  </para>
  <para>
    The event-handling method for the SELCHANGE event receives two arguments: info about the event, the control ID of
    the tab control is in the low order word of this argument. The second argument is the window handle of the tab
    control. Example:

<programlisting>
<![CDATA[
::method onSelChange unguarded
  use arg info, hwndFrom

  id = .DlgUtil~loWord(info)
  ...

  return 0

]]>
</programlisting>

  </para>
  <para>
    The event-handling method for the SELCHANGING event also receives two arguments. The arguments differ slightly
    depending on the value of <emphasis role="italic">willReply</emphasis>.
  </para>
  <para>
    If <emphasis role="italic">willReply</emphasis> is <computeroutput>.false</computeroutput>, the first argument is
    info about the event, the control ID of the tab control is in the low order word of this argument. The second
    argument is the window handle of the tab control. If <emphasis role="italic">willReply</emphasis> is
    <computeroutput>.true</computeroutput>, the first argument is simply the control ID of the tab. The second argument
    is the window handle of the tab control. Examples

<programlisting>
<![CDATA[

::method initDialog

  self~connectTabEvent(IDC_TAB, "SELCHANGING")

::method onSelChanging unguarded
  use arg info, hwndFrom

  id = .DlgUtil~loWord(info)
  ...

  return 0

/* This example allows the programmer to cancel the pending tab change. */

::method initDialog

  self~connectTabEvent(IDC_TAB, "SELCHANGING", .true)

::method onSelChanging unguarded
  use arg idFrom, hwndFrom

  currentTab = self~newTab(IDC_TAB)~selectedIndex
  if \ self~validateTab(currentTab) then do
    -- The programmer should put up a message explaining
    -- why the page of the tab is not changing ...
    return .false
  end

  return .true

]]>
</programlisting>

  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example invokes the method <emphasis role="italic">onSelChange</emphasis> whenever another tab is
    selected in the tab control:

<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  self~connectTabEvent(IDC_TAB, "SELCHANGE")
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectTrackBarEvent" xreflabel="connectTrackBarEvent"><title>connectTrackBarEvent</title>
<indexterm><primary>connectTrackBarEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectTrackBarEvent(--id--,--event--+---------------+--)---><
                                         +-,--methodName-+

]]>
</programlisting>

<para>The connectTrackBarEvent method connects a particular
WM_NOTIFY message for a trackbar control, which is also called a track bar,
with a method. The WM_NOTIFY message informs the dialog that an event has
occurred with regard to the trackbar control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the trackbar control of which a notification is to be connected
to a method.
</para></listitem></varlistentry>
<varlistentry><term>event</term>
<listitem><para>The event to be connected with a method:
<variablelist>
<varlistentry><term>UP</term>
<listitem><para>The Up or right key has been pressed.
</para></listitem></varlistentry>
<varlistentry><term>DOWN</term>
<listitem><para>The Down or left key has been pressed.
</para></listitem></varlistentry>
<varlistentry><term>TOP</term>
<listitem><para>The Home key has been pressed.
</para></listitem></varlistentry>
<varlistentry><term>BOTTOM</term>
<listitem><para>The End key has been pressed.
</para></listitem></varlistentry>
<varlistentry><term>PAGEUP</term>
<listitem><para>The PgUp key has been pressed.
</para></listitem></varlistentry>
<varlistentry><term>PAGEDOWN</term>
<listitem><para>The PgDn key has been pressed.
</para></listitem></varlistentry>
<varlistentry><term>DRAG</term>
<listitem><para>The trackbar has been moved.
</para></listitem></varlistentry>
<varlistentry><term>POSITION</term>
<listitem><para>The left mouse button has been released, following a DRAG notification.
</para></listitem></varlistentry>
<varlistentry><term>ENDTRACK</term>
<listitem><para>The trackbar movement is completed, that is, the appropriate key or mouse
button has been released.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent whenever the specified notification is
received from the trackbar control. Provide a method with a matching name. If
you omit this argument, the event is preceded by <computeroutput>On</computeroutput>.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The return codes are:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>No error detected.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>The resource ID could not be resolved or the event argument is
incorrect.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The messages was not connected correctly.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example connects the POSITION event (release mouse button
after dragging) with method PosSet, which extracts the new trackbar position
from the notification arguments and displays it together with the event type
for POSITION, which should be 4:
<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method initDialog
  self~InitDialog:super(...)
  self~connectTrackBarEvent("MYSLIDER", "POSITION", posSet)

::method posSet unguarded
  use arg ev_pos, hnd
  pos = .DlgUtil~hiWord(ev_pos)

  say "Verify event code (should be 4):" .DlgUtil~loWord(ev_pos)

  return 0
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

<note><title>Notes</title><para>
<orderedlist>
<listitem><para>The method can only be called after the trackbar was created by Windows.
A good location for this connection is the initDialog method.</para></listitem>
<listitem><para>The event-handling methods receive two arguments: an event-position pair
and the handle to the trackbar control. For some events, you can retrieve the
trackbar position by extracting the high-oder word. Example:
<programlisting>
<![CDATA[
::method handler unguarded
  use arg ev_pos, handle
  position = .DlgUtil~hiWord(ev_pos)

  return 0
]]>
</programlisting></para></listitem>
</orderedlist>
</para></note>
</section>

<section id="mthConnectTreeViewEvent" xreflabel="connectTreeViewEvent"><title>connectTreeViewEvent</title>
<indexterm><primary>connectTreeViewEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>-connectTreeViewEvent(--id--,--event--+----------------+--)---><
                                        +-,--methodName--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectTreeViewEvent</emphasis> method connects a method in a Rexx dialog to a particular
  tree view <xref linkend="ovvEvents"/>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem><para>The arguments are:</para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the tree view control. This can be the numeric or symbolic ID.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event</term>
    <listitem>
    <para>
      A keyword indicating which event is to be connected. The keyword must be one of the following:
      <variablelist>
        <varlistentry><term>BEGINDRAG</term>
        <listitem>
        <para>
          A drag-and-drop operation using the left mouse button was initiated. The documentation for the
 <xref linkend="mthDefTreeDragHandler"/>() method contains further information on how to
          implement a drag-and-drop handler.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>BEGINRDRAG</term>
        <listitem>
        <para>
          A drag-and-drop operation involving the right mouse button was initiated. The documentation for the
 <xref linkend="mthDefTreeDragHandler"/>() method contains further information on how to
          implement a drag-and-drop handler.
        handler.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>BEGINEDIT</term>
        <listitem><para>Editing a label has been started.
        </para></listitem></varlistentry>
        <varlistentry id="evtTreeViewENDEDIT"><term>ENDEDIT</term>
        <listitem><para>Label editing has ended.
        </para></listitem></varlistentry>
        <varlistentry id="evtTreeViewDEFAULTEDIT"><term>DEFAULTEDIT</term>
        <listitem><para>This event connects the notification that label editing has been started
        and ended with a predefined event-handling method. This method extracts the
        newly entered text from the notification and modifies the item of which the
        label was edited. If this event is not connected you must provide your own
        event-handling method and connect it with the BEGINEDIT and ENDEDIT events.
        Otherwise, the edited text is lost and the item remains unchanged.</para>
        <para>When
        you specify this event, omit the <emphasis role="italic">msgToRaise</emphasis> argument.</para>
        </listitem></varlistentry>
        <varlistentry><term>EXPANDING</term>
        <listitem><para>An item is about to expand or collapse. This notification is sent before
        the item has expanded or collapsed.
        </para></listitem></varlistentry>
        <varlistentry><term>EXPANDED</term>
        <listitem><para>An item has expanded or collapsed. This notification is sent after the
        item expanded or collapsed.
        </para></listitem></varlistentry>
        <varlistentry><term>DELETE</term>
        <listitem><para>An item has been deleted.
        </para></listitem></varlistentry>
        <varlistentry><term>KEYDOWN</term>
        <listitem><para>A key was pressed inside the tree view. This notification is not sent
        while a label is being edited.
        </para></listitem></varlistentry>
        <varlistentry><term>SELCHANGING</term>
        <listitem><para>Another item is about to be selected. This notification is sent before
        the selection has changed.
        </para></listitem></varlistentry>
        <varlistentry><term>SELCHANGED</term>
        <listitem><para>Another item was selected. This notification is sent after the selection
        was changed.
        </para></listitem></varlistentry>
      </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>methodName</term>
    <listitem>
    <para>
      The name of the event handling method. This method is invoked each time the specified event occurs for the tree
      view control. If you omit this argument, the method name is generated for you. This name will be the event
      keyword, preceded by <computeroutput>on</computeroutput>. For example: <emphasis
      role="italic">onExpanded</emphasis>. The method name can not be the empty string.
    </para>
    </listitem></varlistentry>
  </variablelist> </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        No error detected.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
      <para>
        The resource ID was symbolic and it could not be resolved, or the event keyword is not correct.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
      <para>
        Some other error and the message was not connected correctly. This may indicate the message table is full, or the
        interpreter is out of usable memory.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Common guidelines on where (<xref linkend="paraWhereToConnectEvents" />) to invoke the <emphasis
    role="italic">connectTreeViewEvent</emphasis> method and on how (<xref linkend="sctCodingEventHandlers" />)
    to code event handlers are included in the documentation for the
    <xref linkend="clsEventNotification"/> class.
  </para>
  <orderedlist>
  <listitem>
  <para>
    The event-handling method connected to ENDEDIT receives two arguments: the item handle of which the label has been
    edited and the newly entered text. Example:

<programlisting>
<![CDATA[

::method onEndEdit unguarded
  use arg item, newText

  return 0
]]>
</programlisting>

  </para>
  </listitem>
  <listitem>
  <para>
    The event-handling method connected to KEYDOWN receives two arguments: the control ID of the tree view control and the
    virtual key code pressed. Use the <xref linkend="mthKey2Name"/>method of the
 <xref linkend="clsVK"/> class to determine which key was pressed. Example:

<programlisting>
<![CDATA[

::method onKeyDown unguarded
  use arg id, vkey
  say "Key" .VK~name2key(vkey) "was pressed."

  return 0
]]>
</programlisting>

  </para>
  </listitem>
  <listitem>
  <para>
    The event-handling method connected to EXPANDED or EXPANDING receives three arguments: the control ID of the tree
    view control, the tree item expanded or collapsed, and a string that indicates whether the item was expanded or
    collapsed. Example:

  <programlisting>
  <![CDATA[
  ::method onExpanding unguarded
    use arg id, item, what
    say "Item with handle" item "is going to be" what

    return 0
  ]]>
  </programlisting>

  </para>
  </listitem>
  <listitem>
  <para>
    The event-handling method connected to BEGINDRAG or BEGINRDRAG receives three arguments: the control ID of the tree
    view control, the tree item to be dragged, and the point where the mouse cursor was pressed (x and y positions,
    separated by a blank). Example:

  <programlisting>
  <![CDATA[

  ::method onBeginDrag unguarded
    use arg id, item, where
    say "Item with handle" item "is in drag-and-drop mode"
    parse var where x y
    say "The drag operation started at point ("x","y")"

    return 0
  ]]>
  </programlisting>

  </para>
  </listitem>
  </orderedlist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
    <para>
      The <emphasis role="italic">connectTreeViewEvent</emphasis> method is a member of the
      <xref linkend="clsEventNotification"/> mixin class.
    </para>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    command events happen.
  </para>
  <para>
    In Windows itself, tree view event notifications are sent to the parent dialog using the WM_NOTIFY message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example connects the selection-changed event for the tree view FileTree with method NewTreeSelection
    and displays the text of the new selection:
  <programlisting>
  <![CDATA[
  ::class MyDlgClass subclass UserDialog

  ::method init
    self~connectTreeViewEvent(IDC_TV_FILES, "SELCHANGED", "newTreeSelection")

  ::method newTreeSelection unguarded
    tc = self~newTreeView(IDC_TV_FILES)
    info. = tc~itemInfo(tc~selected)
    say "New selection is:" info.!text

    return 0
  ]]>
  </programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectUpDownEvent" xreflabel="connectUpDownEvent"><title>connectUpDownEvent</title>
<indexterm><primary>connectUpDownEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectUpDownEvent</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectUpDownEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectUpDownEvent(--id--,--event--+----------------+--)-------------------><
                                       +--,-methodName--+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectUpDownEvent</emphasis> method connects an <xref linkend="ovvEvents"/>
  notification message from a up-down (<xref linkend="clsUpDown" />) control to a method in the Rexx dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the up-down control whose notification message is to be connected to a Rexx dialog's method.
        May be numeric or symbolic (<xref linkend="defSymbolicId" />).
      </para>
      </listitem></varlistentry>
      <varlistentry><term>event [required]</term>
      <listitem>
      <para>
        Exactly one of the following keywords. The keyword specifies the event to be connected and case is not
        significant. Unlike most controls, the up-down control only has one event notification.
      </para>
      <variablelist>
        <varlistentry><term>DELTAPOS</term>
        <listitem>
        <para>
           Sent when the position of the control is about to change. This happens when the user requests a change in the
           value by pressing the control's up or down arrow. The event handler must
           return (<xref linkend="sctCodingEventHandlers" />) a reply for this event. The interpreter waits for that reply.
        </para>
        <para>
          The DELTAPOS notification is sent before the scroll message which actually changes the control's position.
          This allows the programmer to examine, allow, modify, or disallow the change in position.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
      <varlistentry><term>methodName [optional]</term>
      <listitem>
      <para>
        The name of the method that is to be invoked whenever the specified notification is received from the up-down
        control. The programmer defines this method. If this argument is omitted, a method name is automatically
        generated that consists of the event keyword preceded by <computeroutput>on</computeroutput>. For instance,
        <computeroutput>onDeltaPos</computeroutput>. The method name can not be the empty string.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns <computeroutput>.true</computeroutput> if the event was connected correctly, otherwise
   <computeroutput>.false</computeroutput>.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Common guidelines on where (<xref linkend="paraWhereToConnectEvents" />) to invoke the <emphasis
    role="italic">connectUpDownEvent</emphasis> method and on how (<xref linkend="sctCodingEventHandlers" />) to
    code event handlers are included in the documentation for the
    <xref linkend="clsEventNotification"/> class.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected, including the use of an invalid symbolic ID or an
    unrecognized event keyword.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if the
    connected event happens.
  </para>
  <para>
    The underlying dialog receives the UDN_* messages as the notifications for the up-down events.
  </para>
  </listitem></varlistentry>
</variablelist>


<section id="evtUpDownDELTAPOS"><title>DeltaPos Event Handler</title>
<indexterm><primary>UpDown class</primary><secondary>events</secondary><tertiary>DELTAPOS</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onDeltaPos unguarded
  use arg pos, delta, id, hwnd

  return buffer
]]>
</programlisting>

<para>
  The event handler for the up-down DELTAPOS event is invoked when when the position of the control is about to change.
  The arguments the event handler receives allow the programmer to examine the proposed change in position, to modify
  the change, or to cancel the change all together.
</para>
<para>
  The programmer must return a value from the event handler and the interpreter waits for this return. The
 <xref linkend="mthDeltaPosReply"/> class method of the <xref linkend="clsUpDown"/> class is
  used to properly construct the return value from the event handler.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives four arguments:
  </para>
  <variablelist>
    <varlistentry><term>pos</term>
    <listitem>
    <para>
      A signed whole number that contains the up-down control's current position.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>delta</term>
    <listitem>
    <para>
      A signed whole number that contains the proposed change in the up-down control's position. This is positive if the
      user has clicked the up button or used the up arrow key. If the user has clicked the down button or used the down
      arrow key, this number will be negative.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the up-down control whose position is about to change.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window handle (<xref linkend="defHandle" />) of the up-down control whose position is about to change.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    A delta position buffer must be returned by the event handler.  This buffer can only be constructed properly by
    using the <xref linkend="clsUpDown"/> class's <xref linkend="mthDeltaPosReply"/>
    method. The arguments to <emphasis role="italic">deltaPosReply</emphasis> allow the programmer to return a value
    that makes no change to the new position, cancels altogether the change in position, or modifies the resulting new
    position.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example examines the change in position in the up-down control and modifies it so that the position in
    the up-down control is always an even number. Note that the <emphasis role="italic">deltaPosReply</emphasis> method
    ignores the second and third arguments when the first argument is <computeroutput>.false</computeroutput>. So, in
    the code below, if <emphasis role="italic">change</emphasis> remains <computeroutput>.false</computeroutput>, then
    the values of <emphasis role="italic">cancel</emphasis> and <emphasis role="italic">delta</emphasis> do not matter.

<programlisting>
<![CDATA[

::method initDialog
...
  self~connectUpDownEvent(IDC_UPD, "DELTAPOS", onPosChange)
...

::method onPosChange unguarded
  use arg pos, delta, id, hwnd

  change = .false
  cancel = .false

  if ((pos + delta) // 2) <> 0 then do
    change = .true
    if delta > 0 then delta += 1
    else delta -= 1
  end

  return .UpDown~deltaPosReply(change, cancel, delta)

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End DeltaPos Event Handler -->

</section>  <!-- End EventNotification::connectUpDownEvent() -->

<section id="mthDefListDragHandler" xreflabel="defListDragHandler"><title>defListDragHandler</title>
<indexterm><primary>defListDragHandler</primary></indexterm>
<programlisting>
<![CDATA[
>>-defListDragHandler(--id--,--item--,--point--)----------------><

]]>
</programlisting>

<para>
  A list-view control does not handle a drag-and-drop operation itself. It defers that handling to the programmer by
  sending a BEGINGDRAG, (left mouse drag,) or a BEGINRDRAG, (right mouse drag,) event notification. The programmer can
  code his own <xref linkend="ovvEvents"/> handling method and use
 <xref linkend="mthConnectListViewEvent"/>() method to connect the method to the drag-and-drop
  operation.
</para>
<para>
  The <emphasis role="italic">defListDragHandler</emphasis> method is an event handling method supplied by the ooDialog
  framework and the programmer can use this method rather than code his own.
</para>
<para>
  This method implementation allows the user to drag an item from one location to another within an icon view and
  a small icon view. The cursor shape is changed to a crosshair during the drag operation. The user can cancel the drag
  operation by clicking the other mouse button while holding the button that started the drag operation. Note that the
  final icon position is not flexible when the list-view control has the AUTOARRANGE style.
</para>
<para>
  If the programmer wants to implement her own drag-and-drop event handler, she may want to examine the how the
  <emphasis role="italic">defListDragHandler</emphasis> method in the <computeroutput>ooDialog.cls</computeroutput>
  file. In addition the <computeroutput>oodlist.rex</computeroutput> example program uses the <emphasis
  role="italic">defListDragHandler</emphasis>. Running the example program will show the behavior of the current
  <emphasis role="italic">defListDragHandler</emphasis> implementation.
</para>
<para>
  <emphasis role="bold">Example:</emphasis>
<programlisting>
<![CDATA[
::method initDialog

  ...

  self~connectListViewEvent(ID_LV_ICON, "BEGINDRAG", "defListDragHandler")
  -- Drag and drop operations are not automatically handled.
]]>
</programlisting>
</para>
</section>

<section id="mthDefTreeDragHandler" xreflabel="defTreeDragHandler"><title>defTreeDragHandler</title>
<indexterm><primary>defTreeDragHandler</primary></indexterm>
<programlisting>
<![CDATA[
>>-defTreeDragHandler(--id--,--item--,--point--)----------------><

]]>
</programlisting>

<para>
  A tree view control does not handle a drag-and-drop operation itself. It defers that handling to the programmer by
  sending a BEGINGDRAG, (left mouse drag,) or a BEGINRDRAG, (right mouse drag,) event notification. The programmer can
  code his own <xref linkend="ovvEvents"/> handling method and use
 <xref linkend="mthConnectTreeViewEvent"/>() method to connect the method to the drag-and-drop
  operation.
</para>
<para>
  The <emphasis role="italic">defTreeDragHandler</emphasis> method is an event handling method supplied by the ooDialog
  framework and the programmer can use this method rather than code his own.
</para>
<para>
  This method implementation allows the user to move an item, or a node with all its subitems, from one parent node to
  another within the tree view. The cursor shape is changed to a crosshair during the drag operation. If the cursor is
  moved over the item dragged, the cursor shape is changed to a slashed circle. The user can cancel the drag operation
  by clicking the other mouse button while holding the button that started the drag operation.
</para>
<para>
  If the programmer wants to implement her own drag-and-drop event handler, she may want to examine the how the
  <emphasis role="italic">defTreeDragHandler</emphasis> method in the <computeroutput>ooDialog.cls</computeroutput>
  file. In addition both the <computeroutput>oodtree.rex</computeroutput> and
  <computeroutput>propdemo.rex</computeroutput> example programs uses the <emphasis
  role="italic">defTreeDragHandler</emphasis>. Running these example programs will show the behavior of the current
  <emphasis role="italic">defTreeDragHandler</emphasis> implementation.
</para>
<para>
  <emphasis role="bold">Example:</emphasis>
<programlisting>
<![CDATA[
::method initDialog

  ...

  self~connectTreeViewEvent("IDC_TREE","BEGINDRAG", "defTreeDragHandler")
  -- Drag and drop operations are not automatically handled.
]]>
</programlisting>
</para>
</section>

<section id="mthDisconnectKeyPressDialogObject" xreflabel="disconnectKeyPress"><title>disconnectKeyPress</title>
<indexterm><primary>disconnectKeyPress</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>disconnectKeyPress</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>disconnectFKeyPress</secondary></indexterm>
<programlisting>
<![CDATA[
>>--disconnectKeyPress(--+--------------+--)-----><
                         +--methodName--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">disconnectKeyPress</emphasis> method disconnects a key press event from a method that was
  previously connected using <xref linkend="mthConnectKeyPressDialogObject"/>, or
 <xref linkend="mthConnectFKeyPressDialogObject"/>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
      <varlistentry><term>methodName [optional]</term>
      <listitem>
      <para>
        If <emphasis role="italic">methodName</emphasis> is specified, only the key press events connected to that
        method are disconnected. If the argument is omitted, then all key press events for the dialog will be
        disconnected.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The possible return values are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        Success.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-2</term>
      <listitem>
      <para>
        While trying to disconnect the method, the underlying mechanism in the Windows API that is used to capture key
        events had an error. This is unlikely to happen.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-7</term>
      <listitem>
      <para>
        Either the <emphasis role="italic">methodName</emphasis> method is already disconnected, or there are no methods
        connected at all.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The dialog control object also has a <xref linkend="mthDisconnectKeyPressDialogControlObject"/>
    method. The method of the dialog object (this method) can only disconnect key press events that were set with the
    dialog object's versions of <xref linkend="mthConnectKeyPressDialogObject"/> and
 <xref linkend="mthConnectFKeyPressDialogObject"/> methods. This method can not disconnect key press
    events that were set with the dialog control object's versions of
 <xref linkend="mthConnectKeyPressDialogControlObject"/> and
 <xref linkend="mthConnectFKeyPressDialogControlObject"/> methods.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when some incorrect usage is detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example is a variation on the example (<xref linkend="connectKeyPressExample" />) shown for the
 <xref linkend="mthConnectKeyPressDialogObject"/> method. It builds on the fictitious customer
    order system.  The F7 key saves the completed invoice into the system and enters a different phase of the companies
    business process. At this point (for whatever fictitious business reason) the fields can no longer be cleared and
    the user is not allowed to look up customer or product information.  But, the user may still need to print the
    invoice.  To prevent the accidental press of the hot keys causing the wrong action, those key presses are
    disconnected.
  </para>
  <para>
    To demonstrate how key press connections can be added and removed through out the life time of the dialog, this
    example adds the F9 hot key.  F9 starts a new order entry cycle and re-connects the hot keys used during the
    creation of a customer invoice.  When the user then saves the next completed invoice, key press connections are
    removed, when she starts a new invoice key press connections are restored.  This cycle could continue though out the
    day without the user ever closing the main dialog.

<programlisting>
<![CDATA[

::method initDialog

  ...

  -- Capture F2 key presses, but not Ctrl-F2 or Alt-F2, etc..
  self~connectKeyPress(onF2, .VK~F2, "NONE")

  -- Same idea for F3, F4, F5, and F7.  This uses the actual numeric value for
  -- the keys without bothering to use the .VK class to translate.
  self~connectKeyPress(onF3, 114, "NONE")
  self~connectKeyPress(onF4, 115, "NONE")
  self~connectKeyPress(onF5, 116, "NONE")
  self~connectKeyPress(onF7, 118, "NONE")
  self~connectKeyPress(onF9, 120, "NONE")

  ...

::method onF2 unguarded
  self~showCustomerLookupDialog

  return 0

::method onF3 unguarded

  prodNum = self~newEdit(IDC_EDIT_PRODUCT)~getText
  if prodNum \== "" then self~showProductInfo(prodNum)
  return 0

::method onF4
  self~resetAllFields
  return 0

::method onF5
  self~printInvoice
  return 0

::method onF7

  self~saveToDataBase
  self~disconnectKeyPress(onF2)
  self~disconnectKeyPress(onF3)
  self~disconnectKeyPress(onF4)
  return 0

::method onF9

  self~resetAllFields
  self~connectKeyPress(onF2, 112, "NONE")
  self~connectKeyPress(onF3, 114, "NONE")
  self~connectKeyPress(onF4, 115, "NONE")
  return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="mthHasKeyPressConnectionDialogObject" xreflabel="hasKeyPressConnection"><title>hasKeyPressConnection</title>
<indexterm><primary>hasKeyPressConnection</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>hasKeyPressConnection</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>hasKeyPressConnection</secondary></indexterm>
<programlisting>
<![CDATA[
>>--hasKeyPressConnection(--+--------------+--)--><
                            +--methodName--+

]]>
</programlisting>

<para>
  This method is used to query if a connection to a key press event already exists.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>The single optional argument is:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      Query if any key press events are connected to the specified method. If this argument is omitted, the query is if
      any key press events are connected to <emphasis role="bold">any</emphasis> methods.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns <computeroutput>.true</computeroutput> if the method is connected to a key press event or
    <computeroutput>.false</computeroutput> otherwise.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    The dialog control object also has a
 <xref linkend="mthHasKeyPressConnectionDialogControlObject"/> method. The method of the dialog
    object (this method) can only check for connections that were set with the dialog object's versions of
 <xref linkend="mthConnectKeyPressDialogObject"/> and
 <xref linkend="mthConnectFKeyPressDialogObject"/> methods. This method can not check for connections
    that were set with the dialog control object's versions of
 <xref linkend="mthConnectKeyPressDialogControlObject"/> and
 <xref linkend="mthConnectFKeyPressDialogControlObject"/> methods.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example could come from a dialog where the user has the option to use hot keys or not.  When the
    reset button is pushed the state of the dialog fields are reset.  The hot keys enabled check box is set to reflect
    whether hot keys are currently enabled or not.

<programlisting>

<![CDATA[

::method defineDialog

  ...
  self~createCheckBox(IDC_CHECK_FKEYSENABlED, 30, 60, , , , "Hot Keys Enabled")
  ...
  self~createPushButton(IDC_PB_RESET, 60, 135, 45, 15, , "Reset", onReset)
  ...

::method onReset unguarded

  ...
  if self~hasKeyPressConnection then
    self~newCheckBox(IDC_CHECK_FKEYSENABlED)~check
  else
    self~newCheckBox(IDC_CHECK_FKEYSENABlED)~uncheck
  ...
  return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>

</section>
