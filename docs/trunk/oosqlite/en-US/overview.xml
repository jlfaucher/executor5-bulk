<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "oosqlite.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: ooSqlite XML file.
    #
    # Copyright (c) 2012-2024, Rexx Language Association. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<chapter id="chapOverview"><title>Brief Overview</title>
<indexterm><primary>overview</primary></indexterm>
<para>
  ooSQLite is a direct interface to SQLite. SQLite is an in-process library that implements a self-contained,
  serverless, zero-configuration, transactional SQL database <link linkend="ovvDatabaseEngine">engine</link>.
</para>
<para>
  SQLite is an <link linkend="ovvEmbedded">embedded</link> SQL database engine. Unlike most other SQL databases, SQLite
  does not have a separate server process. SQLite reads and writes directly to ordinary disk files. A complete SQL
  database with multiple tables, indices, triggers, and views, is contained in a single disk file. The database file
  format is cross-platform - you can freely copy a database between 32-bit and 64-bit systems or between big-endian and
  little-endian architectures.
</para>
<para>
  ooSQLite provides both an object-orientated <link linkend="chpOOInteface">interface</link> and a classic Rexx <link
  linkend="chpClassicInteface">interface</link> to SQLite. Some people refer to this as a <emphasis
  role="italic">binding</emphasis>. The binding allows a programmer to write applicaions using the Rexx programming
  language that access and use databases through the SQLite database engine.
</para>

<section id="sctGettingStarted"><title>Getting Started</title>
<para>
  If the user of ooSQLite is unfamilar with SQLite itself, the best way to get started is to browse the SQLite <ulink
  url="http://www.sqlite.org/index.html">website</ulink> to get a basic feel for what SQLite is.
</para>
<para>
  To actually use the ooSQLite package in an ooRexx program, simply <emphasis role="italic">require</emphasis> the
  <computeroutput>ooSQLite.cls</computeroutput> in the progam and ensure that
  <computeroutput>ooSQLite.cls</computeroutput> is in a location where the operating system can find it:

<programlisting>
<![CDATA[
::requires 'ooSQLite.cls'
]]>
</programlisting>

  This is no different than using any other external package in ooRexx, such as
  <computeroutput>ooDialog.cls</computeroutput>, <computeroutput>rxftp.cls</computeroutput>,
  <computeroutput>cvsStream.cls</computeroutput>, etc..
</para>
<para>
  Next, the user should familarize herself with the example programs provided by the ooSQLite package. In the
  installation location of ooSQLite are the <computeroutput>examples</computeroutput> and
  <computeroutput>testing</computeroutput> subdirectories. These direcories contain examples meant to be run from the
  command line. The user should run the examples after reading through the source code. The examples are meant to be
  played with. That is, the user should make small changes to the samples and observe what happens. As in any activity,
  experience is the best teacher.
</para>
<para>
  Using the examples should be done in conjunction with reading this reference manual. The best advice would be to read
  the source code in an example and look up each class and method in the example in the reference. Or each function call
  in the example if the reader is more interested in the classic Rexx interface.
</para>
<para>
  If things are unclear, then post a question to the ooRexx user's list. The list is easy to <ulink
  url="http://sourceforge.net/mail/?group_id=119701">subscribe</ulink> to. In addition the <link
  linkend="helpGettingHelp">getting help </link> section of this reference lists a number of other resources for the
  programmer with questions about ooSQLite.
</para>

<section id="sctCommandLineShell"><title>Command Line Shell</title>
<indexterm><primary>command line shell</primary></indexterm>
<indexterm><primary>ooSQLite package</primary><secondary>command line shell</secondary></indexterm>
<para>
  ooSQLite comes with a command line shell executable. <computeroutput>ooSQLite3.exe</computeroutput> on Windows and
  <computeroutput>oosqlite3</computeroutput> on Unix-like systems. This documentation will refer to the command line
  shell as <emphasis role="italic">ooSQLite3.exe</emphasis> as opposed to <emphasis role="italic">oosqlite3</emphasis>
  because it is easy to distinguish that ooSQLite3.exe is an executable. In all cases, ooSQLite3.exe refers to both the
  Windows <emphasis role="italic">and</emphasis> Unix-like command line shell.
</para>
<para>
  The command line shell is a simple program to use and will read any SQLite database file. It is extremely useful when
  first starting out with ooSQLite. Indeed, it is probably very useful at any time for anyone working with SQLite
  databases.
</para>
<para>
  The executable is installed alongside the <computeroutput>ooSQLite.cls</computeroutput> file and the implementation
  library. The installation directory is normally added to the path, putting the command line shell also in the path. As
  long as it is in the path the command line shell can be executed from anywhere on the system.
</para>
<para>
  <emphasis role="bold">Note</emphasis> that the ooSQLite command line shell is the same as the command line shell
  provided by SQLite. The shell source code is simply compiled as part of the ooSQLite build process and renamed. The
  source code is virtually unchanged, so ooSQLite3.exe behaves exactly the same as sqlite3.exe. At this time, the only
  change in ooSQLite3.exe is a few of the startup defaults.
</para>
<para>
  Typically a command line shell is started up and presents some type of a prompt. The user then enters commands, the
  shell executes the command, and then returns to the prompt to await the next command.  ooSQLite3.exe is no different.
  To start it type <emphasis role="italic">ooSQLite3</emphasis>, or <emphasis role="italic">oosqlite3</emphasis> at a
  command prompt:

<programlisting>
<![CDATA[

C:\>ooSQLite3
SQLite version 3.7.13 2012-06-11 02:05:22
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite>

]]>
</programlisting>

  The <emphasis role="italic">.help</emphasis> command gives help on how to use the shell.  Typically, the shell is
  started with the name of a database and the shell opens that database:

<programlisting>
<![CDATA[

C:\>ooSQLite3 phoneBook.rdbx
SQLite version 3.7.13 2012-06-11 02:05:22
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite> .tables
addr_type    contacts     inet_addr    phone_addr   street_addr
sqlite>

]]>
</programlisting>

  To exit the shell type <emphasis role="italic">.exit</emphasis>, or just <emphasis role="italic">.e</emphasis>

<programlisting>
<![CDATA[

sqlite> .e

C:\>

]]>
</programlisting>

</para>
<para>
  As noted, ooSQLite3.exe is the same as the sqlite3.exe command line shell that can be downloaded from <ulink
  url="http://www.sqlite.org/download.html">SQLite</ulink>. There is a wealth of information on the Internet regarding
  the SQLite command shell program. Anything said about sqlite3.exe applies to ooSQLite3.exe. Have fun with
  ooSQLite3.exe, it is an useful tool.
</para>

</section>

</section> <!-- End: Getting Started -->

<section id="sctTermDefs"><title>Definition of Terms</title>
<para>
  A collection of definitions and explanations for terms used in the ooSQLite documentation. These terms may not be
  familiar to the average Rexx programmer.
</para>

<section id="defDatabaseName"><title>Database Name</title>
<para>
  The SQLite database <link linkend="ovvDatabaseEngine">engine</link> tracks the databases opened on a database
  connection by internal names. The main database file opened on a connection has the name &quot;main&quot; and the name
  &quot;temp&quot; refers to the database used for temporary tables. However, SQLite also has the concept of <emphasis
  role="italic">attaching</emphasis> another database file to the current database connection. Attaching a database uses
  a SQL statement with the format of <computeroutput>ATTACH DATABASE expr AS database-name</computeroutput>. The
  expression after the AS keyword is the name used internally by the database engine for the attached database.
</para>
<para>
  Many of the ooSQLite methods and functions have as an argument the database <emphasis role="italic">name</emphasis>. In
  these methods and functions, the <emphasis role="italic">name</emphasis> refers to the internal name used by SQLite, not
  the <emphasis role="italic">file</emphasis> name of the database. This documentation attempts to distinguish between a
  database <emphasis role="italic">file</emphasis> name and the internal database <emphasis role="italic">name</emphasis> by
  always using <emphasis role="italic">file name</emphasis> when refering to the actual database file.
</para>
</section>

<section id="defHandle"><title>Handle</title>
<para>
  A unique reference to a system resource managed by the operating system. In ooSQLite, most handles are references to data
  structures assigned by the SQLite database engine to manage its databases. These can be references to a database
  connection, a prepared statement, an online backup, etc.. Other handles not related to the database engine are also used by
  ooSQLite.
</para>
<para>
  Handles are mostly used in the <link linkend="chpClassicInteface">classic</link> Rexx interface and are required as
  arguments for certain functions. Some handles are also used in the object orientated interface. A handle is an opaque type,
  the Rexx programmer need not be aware of the specific format of a handle. For the classical interface, the ooSQLite package
  provides functions that return handles. When a function requires a handle as an argument, the Rexx programmer needs to
  obtain the handle from one of those provided functions. In the object orientated interface the situation is similar,
  ooSQLite provides methods that return handles and methods that require handles as arguments. To obtain a handle required
  for a method argument, the Rexx programmer needs to obtain the handle from one of the provided methods.
</para>
<para>
  As a general rule, handles obtained from functions in the classic Rexx interface should not be used as handle arguments to
  methods, and vice versa. However, as ooSQLite is enhanced, this may not be an absolute rule. The ooSQLite documentation
  will point out exceptions to this rule if there are any.
</para>
</section>

<section id="defThreadingMode"><title>Threading Mode</title>
<para>
  SQLite itself supports three different threading modes:
</para>

<variablelist>
  <varlistentry><term><emphasis role="bold">Single-thread:</emphasis></term>
  <listitem>
  <para>
    In this mode, all mutexes are disabled and SQLite is unsafe to use in more than a single thread at once.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Multi-thread:</emphasis></term>
  <listitem>
  <para>
    In this mode, SQLite can be safely used by multiple threads provided that no single database connection is used
    simultaneously in two or more threads.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Serialized:</emphasis></term>
  <listitem>
  <para>
    In serialized mode, SQLite can be safely used by multiple threads with no restriction.
  </para>
  </listitem></varlistentry>
</variablelist>
<para>
  SQLite allows the threading mode to be determined at compile-time, start-time, and run-time. However, the ooSQLite
  framework is compiled in serialized threading mode and, currently, provides no way to change this at start-time. Therefore,
  for all intents and purposes, ooSQLite uses the serialized threading mode.
</para>
<para>
  It is possible to change the threading mode to multi-thread for individual database connections when <link
  linkend="mthNewClsOOSQLiteConnection">instantiating</link> a new connection object or <link
  linkend="rtn-oosqlOpen">opening</link> the connection using the classic Rexx interface. However, this is stongly advised
  against. The ooSQLite implementation is done using the assumption that the threading mode is always serialized.
</para>
<para>
  Consult the SQLite documentation on the <ulink url="http://www.sqlite.org/threadsafe.html">threading mode</ulink> for
  more information.
</para>
</section>

</section> <!-- End: Definition of Terms -->

<section id="sctGeneralOOSQLite"><title>Common Concepts</title>
<para>
  There are some common concepts shared throughout ooSQLite whether the programmer is using the object-orientated <link
  linkend="chpOOInteface">interface</link> or the classic Rexx <link linkend="chpClassicInteface">interface</link>. Some
  of these concepts are briefly discussed here.
</para>

<section id="ovvEmbedded"><title>Embedded</title>
<para>
  The ooSQLite package <emphasis role="italic">embedds</emphasis> the SQLite <emphasis role="italic">database
  engine</emphasis> within the package. <emphasis role="italic">Embedding</emphasis> indicates that the SQLite software
  code is compiled directly into the ooSQLite library. This in turn means that ooSQLite does not need any external piece
  to work. There is no need for a SQLite library to be installed on the system. There is no reason why a SQLite library
  can not be installed on the system, but if there is one, ooSQLite will not access it.
</para>
</section>

<section id="ovvDatabaseEngine"><title>Database Engine</title>
<para>
  <emphasis role="italic">Database engine</emphasis> refers to the code that carries out the actual database function.
  For example, MySQL comes with a database engine, but it also comes with components that allow a server to serve up
  connections to the database engine, allow a client to contact the server, etc.. These components are not a part of the
  database engine of MySQL. ooSQLite works by making calls into the SQLite database engine, (which is embedded within
  ooSQLite.) Within this documentation, a reference to <emphasis role="italic">the database engine</emphasis> means the
  SQLite database engine. In places in the documentation, <emphasis role="italic">the SQLite </emphasis> database
  engine is stated explictly. In places where the SQLite part is left off, the SQLite part is implicit.
</para>
</section>

</section> <!-- End: Common Concepts -->


<section id="sctSQLiteFeatues"><title>SQLite Features</title>
<para>
  SQLite has some characteristics and features that are distinct from other database engines. Many of these features
  seem suitable for the types of applications ooRexx programmers want to write.
</para>

<variablelist>
  <varlistentry><term><emphasis role="bold">Zero-Configuration:</emphasis></term>
  <listitem>
  <para>
    SQLite does not need to be "installed" before it is used. There is no "setup" procedure. There is no server process
    that needs to be started, stopped, or configured. There is no need for an administrator to create a new database
    instance or assign access permissions to users. SQLite uses no configuration files. Nothing needs to be done to tell
    the system that SQLite is running. No actions are required to recover after a system crash or power failure. There
    is nothing to troubleshoot.
  </para>
  <para>
    SQLite just works.
  </para>
  <para>
    Other more familiar database engines run great once you get them going. But doing the initial installation and
    configuration can be intimidatingly complex.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Serverless:</emphasis></term>
  <listitem>
  <para>
    Most SQL database engines are implemented as a separate server process. Programs that want to access the database
    communicate with the server using some kind of interprocess communication (typically TCP/IP) to send requests to the
    server and to receive back results. SQLite does not work this way. With SQLite, the process that wants to access the
    database reads and writes directly from the database files on disk. There is no intermediary server process.
  </para>
  <para>
    There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server
    process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a
    "zero-configuration" database engine. Programs that use SQLite require no administrative support for setting up the
    database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.
  </para>
  <para>
    On the other hand, a database engine that uses a server can provide better protection from bugs in the client
    application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single
    persistent process, it is able control database access with more precision, allowing for finer grain locking and
    better concurrency.
  </para>
  <para>
    Most SQL database engines are client/server based. Of those that are serverless, SQLite is probably the only one
    that allows multiple applications to access the same database at the same time.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Single Database File:</emphasis></term>
  <listitem>
  <para>
     A SQLite database is a single ordinary disk file that can be located anywhere in the directory hierarchy. If
     SQLite can read the disk file then it can read anything in the database. If the disk file and its directory are
     writable, then SQLite can change anything in the database. Database files can easily be copied onto a USB memory
     stick or emailed for sharing.
  </para>
  <para>
    Other SQL database engines tend to store data as a large collection of files. Often these files are in a standard
    location that only the database engine itself can access. This makes the data more secure, but also makes it harder
    to access. Some SQL database engines provide the option of writing directly to disk and bypassing the filesystem all
    together. This provides added performance, but at the cost of considerable setup and maintenance complexity.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Cross-Platform Database File:</emphasis></term>
  <listitem>
  <para>
    The SQLite file format is cross-platform. A database file written on one machine can be copied to and used on a
    different machine with a different architecture. Big-endian or little-endian, 32-bit or 64-bit does not matter. All
    machines use the same file format. Furthermore, the developers have pledged to keep the file format stable and
    backwards compatible, so newer versions of SQLite can read and write older database files.
  </para>
  <para>
    Most other SQL database engines require you to dump and restore the database when moving from one platform to
    another and often when upgrading to a newer version of the software.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Compact:</emphasis></term>
  <listitem>
  <para>
    When optimized for size, the whole SQLite library with everything enabled is [footprint | less than 350KiB in size]
    (as measured on an ix86 using the "size" utility from the GNU compiler suite.) Unneeded features can be disabled at
    compile-time to further reduce the size of the library to under 190KiB if desired.
  </para>
  <para>
    Most other SQL database engines are much larger than this. IBM boasts that its recently released CloudScape database
    engine is "only" a 2MiB jar file - an order of magnitude larger than SQLite even after it is compressed! Firebird
    boasts that its client-side library is only 350KiB. That's as big as SQLite and does not even contain the database
    engine. The Berkeley DB library from Oracle is 450KiB and it omits SQL support, providing the programmer with only
    simple key/value pairs.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Manifest typing:</emphasis></term>
  <listitem>
  <para>
    Most SQL database engines use static typing. A datatype is associated with each column in a table and only values
    of that particular datatype are allowed to be stored in that column. SQLite relaxes this restriction by using
    manifest typing. In manifest typing, the datatype is a property of the value itself, not of the column in which the
    value is stored. SQLite thus allows the user to store any value of any datatype into any column regardless of the
    declared type of that column. (There are some exceptions to this rule: An INTEGER PRIMARY KEY column may only store
    integers. And SQLite attempts to coerce values into the declared datatype of the column when it can.)
  </para>
  <para>
    As far as the authors of SQLite can tell, the SQL language specification allows the use of manifest typing.
    Nevertheless, most other SQL database engines are statically typed and so some people feel that the use of manifest
    typing is a bug in SQLite. But the authors of SQLite feel very strongly that this is a feature. The use of manifest
    typing in SQLite is a deliberate design decision which has proven in practice to make SQLite more reliable and
    easier to use, especially when used in combination with dynamically typed programming languages such as Tcl and
    Python. This feature should go very well with ooRexx.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Variable-length records:</emphasis></term>
  <listitem>
  <para>
    Most other SQL database engines allocated a fixed amount of disk space for each row in most tables. They play
    special tricks for handling BLOBs and CLOBs which can be of wildly varying length. But for most tables, if you
    declare a column to be a VARCHAR(100) then the database engine will allocate 100 bytes of disk space regardless of
    how much information you actually store in that column.
  </para>
  <para>
    SQLite, in contrast, use only the amount of disk space actually needed to store the information in a row. If you
    store a single character in a VARCHAR(100) column, then only a single byte of disk space is consumed. (Actually two
    bytes - there is some overhead at the beginning of each column to record its datatype and length.)
  </para>
  <para>
    The use of variable-length records by SQLite has a number of advantages. It results in smaller database files,
    obviously. It also makes the database run faster, since there is less information to move to and from disk. And, the
    use of variable-length records makes it possible for SQLite to employ manifest typing instead of static typing.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Public domain</emphasis></term>
  <listitem>
  <para>
    The source code for SQLite is in the public domain. No claim of copyright is made on any part of the core source
    code. (The documentation and test code is a different matter - some sections of documentation and test logic are
    governed by open-source licenses.) All contributors to the SQLite core software have signed affidavits specifically
    disavowing any copyright interest in the code. This means that anybody is able to legally do anything they want with
    the SQLite source code. This allows ooRexx to directly embedd the database engine in the ooSQLite package.
  </para>
  <para>
    There are other SQL database engines with liberal licenses that allow the code to be broadly and freely used. But
    those other engines are still governed by copyright law. SQLite is different in that copyright law simply does not
    apply.
  </para>
  <para>
    The source code files for other SQL database engines typically begin with a comment describing your license rights
    to view and copy that file. The SQLite source code contains no license since it is not governed by copyright.
    Instead of a license, the SQLite source code offers a blessing:
  </para>
  <para>
    <emphasis role="italic">May you do good and not evil</emphasis>
  </para>
  <para>
    <emphasis role="italic">May you find forgiveness for yourself and forgive others</emphasis>
  </para>
  <para>
    <emphasis role="italic">May you share freely, never taking more than you give.</emphasis>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">SQL language extensions:</emphasis></term>
  <listitem>
  <para>
    SQLite provides a number of enhancements to the SQL language not normally found in other database engines. The
    EXPLAIN keyword and manifest typing have already been mentioned above. SQLite also provides statements such as
    REPLACE and the ON CONFLICT clause that allow for added control over the resolution of constraint conflicts. SQLite
    supports ATTACH and DETACH commands that allow multiple independent databases to be used together in the same query.
    And SQLite defines APIs that allows the user to add new SQL functions and collating sequences.
  </para>
  </listitem></varlistentry>
</variablelist>

</section> <!-- End: SQLite Features -->


</chapter>
