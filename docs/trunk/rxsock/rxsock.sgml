<?xml version="1.0" standalone="no">
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.2//EN"
[
<!ENTITY legalstuff SYSTEM "../shared/legalstuff.sgml">
<!ENTITY notices    SYSTEM "../shared/notices.sgml">
<!ENTITY cpl        SYSTEM "../shared/CPLv1.0.sgml">
<!ENTITY gethelp    SYSTEM "../shared/gethelp.sgml">
<!ENTITY genindex   SYSTEM "genindex.sgml">
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: RxSock TCP/IP Socket Functions Reference
    #
    # Copyright (c) 2005-2007, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<book>
<bookinfo>
<title>Open Object Rexx&trade;</title>
<subtitle>RxSock TCP/IP Socket Functions Reference</subtitle>

&legalstuff;

</bookinfo>

<preface id="preface"><title>About This Book</title>
<para>This book describes the Open Object Rexx&trade; TCP/IP Sockets Function Library.
.</para>
<para>This book is intended for people who plan to develop applications using
Rexx and TCP/IP sockets. Its users range from the novice, who might have experience in some programming
language but no Rexx or sockets experience, to the experienced application developer,
who might have had some experience with Object Rexx and sockets.</para>
<para>This book is a reference rather than a tutorial. It assumes you are already
familiar with object-oriented programming concepts.</para>
<para>Descriptions include the use and syntax of the language and explain how
the language processor &quot;interprets&quot; the language as a program is running.</para>

<section id="relinf"><title>Related Information</title>
<para>See also:
<citetitle pubwork="book">Open Object Rexx: Reference</citetitle></para>
</section>

<section id="readsy"><title>How to Read the Syntax Diagrams</title>
<para>Throughout this book, syntax is described using the structure defined below. </para>
<itemizedlist>
<listitem><para>Read the syntax diagrams from left to right, from top to bottom, following
the path of the line. </para>
<para>The <computeroutput>&gt;&gt;---</computeroutput> symbol
indicates the beginning of a statement.</para>
<para>The <computeroutput>---&gt;</computeroutput> symbol indicates that the statement syntax is continued on the
next line.</para>
<para>The <computeroutput>&gt;---</computeroutput> symbol indicates
that a statement is continued from the previous line.</para>
<para>The <computeroutput>---&gt;&lt;</computeroutput> symbol indicates the end of a statement.</para>
<para>Diagrams of syntactical units other than complete statements start
with the  <computeroutput>&gt;---</computeroutput> symbol and end with
the  <computeroutput>---&gt;</computeroutput> symbol.</para></listitem>
<listitem><para>Required items appear on the horizontal line (the main path).

<programlisting>
<![CDATA[
>>-STATEMENT--required_item------------------------------------><
]]>
</programlisting>

</para></listitem>
<listitem><para>Optional items appear below the main path. </para>

<programlisting>
<![CDATA[
>>-STATEMENT--+---------------+--------------------------------><
              +-optional_item-+
]]>
</programlisting>

</listitem>
<listitem><para>If you can choose from two or more items, they appear vertically, in a
stack. If you must choose one of the items, one
item of the stack appears on the main path.</para>

<programlisting>
<![CDATA[
>>-STATEMENT--+-required_choice1-+-----------------------------><
              +-required_choice2-+
]]>
</programlisting>

</listitem>
<listitem><para>If choosing one of the items is optional, the entire stack appears below
the main path.</para>

<programlisting>
<![CDATA[
>>-STATEMENT--+------------------+-----------------------------><
              +-optional_choice1-+
              +-optional_choice2-+
]]>
</programlisting>

</listitem>
<listitem><para>If one of the items is the default, it appears above the main path and
the remaining choices are shown below. </para>

<programlisting>
<![CDATA[
              +-default_choice--+
>>-STATEMENT--+-----------------+------------------------------><
              +-optional_choice-+
              +-optional_choice-+
]]>
</programlisting>

</listitem>
<listitem><para>An arrow returning to the left above the main line indicates an item that
can be repeated.</para>

<programlisting>
<![CDATA[
              +-----------------+
              V                 |
>>-STATEMENT----repeatable_item-+------------------------------><
]]>
</programlisting>

<para>A repeat arrow above a stack indicates that you can repeat the
items in the stack.</para></listitem>
<listitem><para>A set of vertical bars around an item indicates that the item is a fragment, a part of the syntax diagram that appears in
greater detail below the main diagram.</para>

<programlisting>
<![CDATA[
>>-STATEMENT--| fragment |-------------------------------------><
]]>
</programlisting>

<para><emphasis role="italic">fragment:</emphasis></para>

<programlisting>
|--expansion_provides_greater_detail----------------------------|
</programlisting>
</listitem>
<listitem><para>Keywords appear in uppercase (for example, <computeroutput>PARM1</computeroutput>). They must
be spelled exactly as shown but you can type them in upper, lower, or mixed
case. Variables appear in all lowercase letters (for example, <computeroutput>parmx</computeroutput>). They represent user-supplied names or values.</para></listitem>
<listitem><para>If punctuation marks, parentheses, arithmetic operators, or such symbols
are shown, you must enter them as part of the syntax.</para></listitem></itemizedlist>

<para>The following example shows how the syntax is described:</para>

<programlisting>
<![CDATA[
         +-,------+
         V        |
>>-MAX(----number-+--)-----------------------------------------><
]]>
</programlisting>
</section>

<section><title>A Note About Program Examples in this Document</title>
<para>The program examples in this document are rendered in a mono-spaced
font that is not completely compatible for cut-and-paste functionality.
Pasteing text into an editor could result in some characters outside of
the standard ASCII character set. Specifically, single-qoute and
double-quote characters are sometimes converted incorrectly when
pasted into an editor.</para>

</section>

&gethelp;

</preface>

<chapter><title>What is RxSock?</title>
<indexterm><primary>RxSock description</primary></indexterm>
<indexterm><primary>description, RxSock</primary></indexterm>
<para>RxSock is a Rexx function package providing access to the TCP/IP socket APIs
available to the C programming environment. Most of the functions described in
this reference are similar to the corresponding C functions available in the TCP/IP
socket library.</para>

<para>It is assumed that you are familiar with the basic socket APIs and can reference
those specific to the system. For more information, refer to the book
<indexterm><primary>socket, definition of a</primary></indexterm>
<indexterm><primary>definition of a socket</primary></indexterm>
<indexterm><primary>TCP/IP</primary></indexterm>
<citetitle>Internetworking
with TCP/IP, Volume I: Principles, Protocols and Architecture</citetitle>
by Douglas Comer (Prentice Hall PTR).</para>

<para>The RxSock package requires TCP/IP support to be active on your system.
</para>
</chapter>

<chapter><title>Installation and Removal</title>
<indexterm><primary>installation, RxSock</primary></indexterm>
<indexterm><primary>RxSock installation</primary></indexterm>
<para>The RxSock package is contained in the file rxsock.dll. This file must be placed in
a directory listed in your LIBPATH. To get access to the functions in the RxSock
package, execute the following Rexx code:
<programlisting>
If RxFuncQuery("SockDropFuncs") then
do
   rc = RxFuncAdd("SockLoadFuncs","rxsock","SockLoadFuncs")
   rc = SockLoadFuncs()
end
</programlisting></para>

<para>To unload the DLL, call the SockDropFuncs() function and then exit all CMD.EXE
shells. After exiting all command shells, the DLL is dropped by the system and can
be deleted or replaced.</para>
</chapter>

<chapter><title>Parameters and Return Values</title>
<indexterm><primary>function parameters</primary></indexterm>
<indexterm><primary>parameters, function</primary></indexterm>
<indexterm><primary>function return values</primary></indexterm>
<indexterm><primary>return values, function</primary></indexterm>
<para>Unless otherwise stated, the return values are the same as for the corresponding C
functions. The following standard parameter types are referred to throughout this
reference:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is a socket value, which is an integral number.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>domain</term>
      <listitem><para>is a domain value. Currently, only the domain AF_INET is supported.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>address</term>
      <listitem><para>is the stem of a stem variable with the following values:
      <variablelist>
         <varlistentry>
            <term>address.family</term>
            <listitem><para>must always be AF_INET.
            </para></listitem>
         </varlistentry>
         <varlistentry>
            <term>address.port</term>
            <listitem><para>is a port number.
            </para></listitem>
         </varlistentry>
         <varlistentry>
            <term>address.addr</term>
            <listitem><para>is a dotted decimal address or INADDR_ANY, where appropriate.
	    </para>
            <para>When this parameter is needed, set it the name of a stem variable for the
            function to set (or that the function will read from). For example, if you pass
            the string xxx.! as a parameter, the following variables are set or queried by
            the function:</para>
	    <simplelist>
               <member>"xxx.!family"</member>
               <member>"xxx.!port"</member>
               <member>"xxx.!addr"</member>
	    </simplelist>
            <para>A null address is an address with the family field being AF_INET, the port
            field being 0, and the addr field being 0.0.0.0.
            </para></listitem>
         </varlistentry>
      </variablelist>
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>dotAddress</term>
      <listitem><para>is the standard dotted decimal address. For example, the string 9.23.19.63 is a
      valid address.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>host</term>
      <listitem><para>is the stem of a stem variable with the following values:
      <variablelist>
         <varlistentry>
            <term>host.name</term>
            <listitem><para>is the standard name of the host.
            </para></listitem>
         </varlistentry>
         <varlistentry>
            <term>host.alias.0</term>
            <listitem><para>is the number of aliases for this host.
            </para></listitem>
         </varlistentry>
         <varlistentry>
            <term>host.alias.1</term>
            <listitem><para>is the first alias for this host.
            </para></listitem>
         </varlistentry>
         <varlistentry>
            <term>host.alias.n</term>
            <listitem><para>is the nth alias for this host.
            </para></listitem>
         </varlistentry>
         <varlistentry>
            <term>host.addrtype</term>
            <listitem><para>must always be AF_INET.
            </para></listitem>
         </varlistentry>
         <varlistentry>
            <term>host.addr</term>
            <listitem><para>is a dotted decimal address (default address).
	    <variablelist>
	       <varlistentry>
                  <term>host.addr.0</term>
                  <listitem><para>is the number of addresses for this host.
                  </para></listitem>
               </varlistentry>
               <varlistentry>
                  <term>host.addr.1</term>
                  <listitem><para>is the first address for this host.
                  </para></listitem>
               </varlistentry>
               <varlistentry>
                  <term>host.addr.n</term>
                  <listitem><para>is the nth address for this host.</para>

                  <para>When this parameter is needed, set it the name of a stem variable for the
                  function to set (or that the function will read from). For example, if you pass
                  the string xxx.! as a parameter, the following variables are set or queried by
                  the function:
		  <simplelist>
                     <member>"xxx.!name"</member>
                     <member>"xxx.!alias.0", "xxx.!alias.1" ... "xxx.!alias.n"
		     </member>
                     <member>"xxx.!addrtype"</member>
                     <member>"xxx.!addr"</member>
                     <member>"xxx.!addr.0", "xxx.!addr.1" ... "xxx.!addr.n"
		     </member>
		  </simplelist>
                  </para></listitem>
               </varlistentry>
	    </variablelist>
            </para></listitem>
         </varlistentry>
      </variablelist>
      </para></listitem>
   </varlistentry>
</variablelist>

<section><title>Stem Variables</title>
<indexterm><primary>stem variables, usage of</primary></indexterm>
<indexterm><primary>usage of stem variables</primary></indexterm>
<para>The address and host type of a parameter are stems of a stem variable. Normally,
when you pass a string like addr. as a parameter, you expect the variables
addr.family, addr.port, and addr.addr to be set by the function. In the previous
examples, however, the stem contained an exclamation mark. This exclamation
mark helps prevent the value that follows from getting misused as a normal
variable. Example:
<programlisting>
port = 923
sNew = SockAccept(sOld,"addr.")
say addr.port
</programlisting></para>
<para>In this example, you might expect the say statement to write the port number of
the accepted socket. Instead, it writes the value of the variable, namely addr.923,
because the port variable is set to this value.</para>
<para>Because exclamation marks are rarely used in variables, it is unlikely that the
variable !port is used in your program.
<note><para>Do not use the characters _, 0, and 1 to prefix tail values. 0 and 1 are
difficult to distinguish from O, I, and l.</para></note>
</para>
</section>
</chapter>

<chapter><title>Special Variables</title>
<indexterm><primary>special variables</primary></indexterm>
<indexterm><primary>variables, special</primary></indexterm>
<para>The following variables are maintained by the system: errno and h_errno.
<variablelist>
   <varlistentry>
      <term>Variable <emphasis role="italic">errno</emphasis></term>
      <listitem><para>The variable errno is set after each RxSock call. It can have one of the following
      values or any other numeric value:
      <itemizedlist>
         <listitem><para>EWOULDBLOCK    </para></listitem>
         <listitem><para>EINPROGRESS    </para></listitem>
         <listitem><para>EALREADY       </para></listitem>
         <listitem><para>ENOTSOCK       </para></listitem>
         <listitem><para>EDESTADDRREQ   </para></listitem>
         <listitem><para>EMSGSIZE       </para></listitem>
         <listitem><para>EPROTOTYPE     </para></listitem>
         <listitem><para>ENOPROTOOPT    </para></listitem>
         <listitem><para>EPROTONOSUPPORT</para></listitem>
         <listitem><para>ESOCKTNOSUPPORT</para></listitem>
         <listitem><para>EOPNOTSUPP     </para></listitem>
         <listitem><para>EPFNOSUPPORT   </para></listitem>
         <listitem><para>EAFNOSUPPORT   </para></listitem>
         <listitem><para>EADDRINUSE     </para></listitem>
         <listitem><para>EADDRNOTAVAIL  </para></listitem>
         <listitem><para>ENETDOWN       </para></listitem>
         <listitem><para>ENETUNREACH    </para></listitem>
         <listitem><para>ENETRESET      </para></listitem>
         <listitem><para>ECONNABORTED   </para></listitem>
         <listitem><para>ECONNRESET     </para></listitem>
         <listitem><para>ENOBUFS        </para></listitem>
         <listitem><para>EISCONN        </para></listitem>
         <listitem><para>ENOTCONN       </para></listitem>
         <listitem><para>ESHUTDOWN      </para></listitem>
         <listitem><para>ETOOMANYREFS   </para></listitem>
         <listitem><para>ETIMEDOUT      </para></listitem>
         <listitem><para>ECONNREFUSED   </para></listitem>
         <listitem><para>ELOOP          </para></listitem>
         <listitem><para>ENAMETOOLONG   </para></listitem>
         <listitem><para>EHOSTDOWN      </para></listitem>
         <listitem><para>EHOSTUNREACH   </para></listitem>
         <listitem><para>ENOTEMPTY      </para></listitem>
      </itemizedlist>
      <note><para>The value is set even if the function called does not set the variable, in
      which case the value has no meaning. A value of 0 indicates that no error
      occurred.</para></note>
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>Variable <emphasis role="italic">h_errno</emphasis></term>
      <listitem><para>The variable h_errno is set after each RxSock call. It can have one of the following
      values or any other numeric value:
      <itemizedlist>
         <listitem><para>HOST_NOT_FOUND</para></listitem>
         <listitem><para>TRY_AGAIN     </para></listitem>
         <listitem><para>NO_RECOVERY   </para></listitem>
         <listitem><para>NO_ADDRESS    </para></listitem>
      </itemizedlist>
      <note><para>The value is set even if the function called does not set the variable, in
      which case the value has no meaning. A value of 0 indicates that no error
      occurred.</para></note>
      </para></listitem>
   </varlistentry>
</variablelist>
</para>
</chapter>

<chapter><title>Function Reference</title>
<indexterm><primary>functions, list of</primary></indexterm>
<indexterm><primary>list of functions</primary></indexterm>
<para>The following sections describe how the individual functions contained in RxSock
are invoked from the Rexx programming environment:
<itemizedlist>
   <listitem><para><link linkend="sockloadfuncs">SockLoadFuncs</link></para></listitem>
   <listitem><para><link linkend="sockdropfuncs">SockDropFuncs</link></para></listitem>
   <listitem><para><link linkend="sockversion">SockVersion</link></para></listitem>
   <listitem><para><link linkend="sockaccept">SockAccept</link></para></listitem>
   <listitem><para><link linkend="sockbind">SockBind</link></para></listitem>
   <listitem><para><link linkend="sockclose">SockClose</link></para></listitem>
   <listitem><para><link linkend="sockconnect">SockConnect</link></para></listitem>
   <listitem><para><link linkend="sockgethostbyaddr">SockGetHostByAddr</link></para></listitem>
   <listitem><para><link linkend="sockgethostbyname">SockGetHostByName</link></para></listitem>
   <listitem><para><link linkend="sockgethostid">SockGetHostId</link></para></listitem>
   <listitem><para><link linkend="sockgetpeername">SockGetPeerName</link></para></listitem>
   <listitem><para><link linkend="sockgetsockname">SockGetSockName</link></para></listitem>
   <listitem><para><link linkend="sockgetsockopt">SockGetSockOpt</link></para></listitem>
   <listitem><para><link linkend="sockinit">SockInit</link></para></listitem>
   <listitem><para><link linkend="sockioctl">SockIoctl</link></para></listitem>
   <listitem><para><link linkend="socklisten">SockListen</link></para></listitem>
   <listitem><para><link linkend="sockpsockerrno">SockPSock_Errno</link></para></listitem>
   <listitem><para><link linkend="sockrecv">SockRecv</link></para></listitem>
   <listitem><para><link linkend="sockrecvfrom">SockRecvFrom</link></para></listitem>
   <listitem><para><link linkend="sockselect">SockSelect</link></para></listitem>
   <listitem><para><link linkend="socksend">SockSend</link></para></listitem>
   <listitem><para><link linkend="socksendto">SockSendTo</link></para></listitem>
   <listitem><para><link linkend="socksetsockopt">SockSetSockOpt</link></para></listitem>
   <listitem><para><link linkend="sockshutdown">SockShutDown</link></para></listitem>
   <listitem><para><link linkend="socksockerrno">SockSock_Errno</link></para></listitem>
   <listitem><para><link linkend="socksocket">SockSocket</link></para></listitem>
   <listitem><para><link linkend="socksoclose">SockSoClose</link></para></listitem>
</itemizedlist></para>

<section id="sockloadfuncs"><title>SockLoadFuncs</title>
<indexterm><primary>SockLoadFuncs</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockLoadFuncs</secondary></indexterm>
<indexterm><primary>functions, loading</primary></indexterm>
<indexterm><primary>loading functions</primary></indexterm>
<indexterm><primary>registering functions</primary></indexterm>
<para>The SockLoadFuncs() call loads all RxSock functions.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockLoadFuncs(--+--------+--)----------------------------------------><
                    +--parm--+
]]>
</programlisting>
<para>
All parameters that you supply are only used to bypass copyright information.
</para>
</section>

<section id="sockdropfuncs"><title>SockDropFuncs</title>
<indexterm><primary>SockDropFuncs</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockDropFuncs</secondary></indexterm>
<indexterm><primary>functions, dropping</primary></indexterm>
<indexterm><primary>dropping functions</primary></indexterm>
<para>The SockDropFuncs call drops all RxSock functions.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
SockDropFuncs()
</programlisting>
<para>To unload the dynamic load library (DLL), first call SockDropFuncs() and then exit
all CMD.EXE shells. After exiting all command shells, the DLL is dropped by the
system and can be deleted or replaced.
</para>
</section>

<section id="sockversion"><title>SockVersion</title>
<indexterm><primary>SockVersion</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockVersion</secondary></indexterm>
<indexterm><primary>functions, version of</primary></indexterm>
<indexterm><primary>version of functions</primary></indexterm>
<para>The SockVersion() call provides the version of RxSock.</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockVersion()--------------------------------------------------------><
]]>
</programlisting>
<para><emphasis role="bold">Return Values:</emphasis></para>
<para>The returned value is in the form version.subversion, for example 2.1.
</para>
<para>Prior to Version 1.2, this function did not exist. To check if a former version of
Rxsock is installed, use the following code after loading the function package with
SockLoadFuncs():
<programlisting>
/* oldVersion is 1 if a version of RxSock &lt; 1.2 is loaded */
oldVersion = (1 = RxFuncQuery("SockVersion"))
</programlisting>
</para>
</section>

<section id="sockaccept"><title>SockAccept</title>
<indexterm><primary>SockAccept</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockAccept</secondary></indexterm>
<indexterm><primary>accepting a socket connection</primary></indexterm>
<indexterm><primary>connection, accepting a socket</primary></indexterm>
<para>The SockAccept() call accepts a connection request from a remote host.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockAccept(socket--+-------------+--)--------------------------------><
                       +--, address--+
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the socket descriptor created with the SockSocket() call. It is bound to an
      address using the SockBind() call and must be enabled to accept connections
      using theSockListen() call.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>address</term>
      <listitem><para>is a stem variable that contains the socket address of the connection client
      when the SockAccept() call returns. This parameter is optional.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>SockAccept() is used by a server in a connection-oriented mode to accept a
connection request from a client. The call accepts the first connection on its queue
of pending connection requests. It creates a new socket descriptor with the same
properties as socket and returns it to the caller. This new socket descriptor cannot
be used to accept new connections. Only the original socket can accept more
connection requests.
</para>
<para>If the queue has no pending connection requests, SockAccept() blocks the caller
unless the socket is in nonblocking mode. If no connection requests are queued
and the socket is in nonblocking mode, SockAccept() returns a value of -1 and sets
the return code to the value EWOULDBLOCK.
</para>
<para>You cannot get information on requesters without calling SockAccept(). The
application cannot tell the system from which requesters it will accept connections.
The caller can close a connection immediately after identifying the requester.
</para>
<para>The SockSelect() call can be used to check the socket for incoming connection
requests.
</para>
<para><emphasis role="bold">Return Values:</emphasis></para>
<para>A positive value indicates successful execution of the call. The value -1 indicates an
error. You can get the specific error code by calling SockSock_Errno() or
SockPSock_Errno(). Possible values:</para>
<variablelist>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EINTR</term>
      <listitem><para>Interrupted system call.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EINVAL</term>
      <listitem><para> SockListen() was not called for socket.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EOPNOTSUPP</term>
      <listitem><para>socket is not connection-oriented.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EWOULDBLOCK</term>
       <listitem><para>socket is in nonblocking mode, and there are no connection requests queued.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ECONNABORTED</term>
      <listitem><para>The software caused a connection close.
      </para></listitem>
   </varlistentry>
</variablelist>
<note><para>SockAccept() interfaces with the C function accept().
</para></note>
</section>

<section id="sockbind"><title>SockBind</title>
<indexterm><primary>SockBind</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockBind</secondary></indexterm>
<indexterm><primary>binding to a port</primary></indexterm>
<indexterm><primary>port, binding to a</primary></indexterm>
<para>The SockBind() call binds a local name to the socket.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockBind(socket, address)--------------------------------------------><
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the socket descriptor returned by a previous call to SockSocket().
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>address</term>
      <listitem><para>is a stem variable containing the address that is to be bound to socket.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>SockBind() binds the unique local name address to the socket with descriptor socket.
After calling SockSocket(), a descriptor does not have a name. However, it belongs
to a particular address family that you specified when calling SockSocket().
</para>
<para>Because socket was created in the AF_INET domain, the fields of the stem address
are as follows:
</para>
<para>The family field must be set to AF_INET. The port field is set to the port to which
the application must bind. If port is set to 0, the caller allows the system to assign
an available port. The application can call SockGetSockName() to discover the port
number assigned. The addr field is set to the Internet address. On hosts with more
than one network interface (called multihomed hosts), a caller can select the
interface with which it is to bind.
</para>
<para>Only UDP packets and TCP connection requests from this interface that match the
bound name are routed to the application. This is important when a server offers a
service to several networks. If addr is set to INADDR_ANY, the caller requests
socket be bound to all network interfaces on the host. If you do not specify an
address, the server can accept all UDP packets and TCP connection requests made
to its port, regardless of the network interface on which the requests arrived.
</para>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>The value 0 indicates successful execution of the call. The value -1 indicates an
error. You can get the specific error code by calling SockSock_Errno() or
SockPSock_Errno(). Possible values:</para>
<variablelist>
   <varlistentry>
      <term>EADDRINUSE</term>
      <listitem><para>address is already in use. See the SO_REUSEADDR option described under
      SockGetSockOpt() and the SO_REUSEADDR option described under
      SockSetSockOpt().
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EADDRNOTAVAIL</term>
      <listitem><para>The address specified is not valid on this host. For example, the Internet
      address does not specify a valid network interface.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EAFNOSUPPORT</term>
      <listitem><para>The address family is not supported.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EINVAL</term>
      <listitem><para>socket is already bound to an address.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENOBUFS</term>
      <listitem><para>No buffer space available.
      </para></listitem>
   </varlistentry>
</variablelist>
<note><para>SockBind() interfaces with the C function bind().
</para></note>
</section>

<section id="sockclose"><title>SockClose</title>
<indexterm><primary>SockClose</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockClose</secondary></indexterm>
<indexterm><primary>closing a socket</primary></indexterm>
<para>The SockClose() call shuts down a socket and frees resources allocated to the
socket.
</para>
<para><emphasis role="bold">Syntax</emphasis></para>
<programlisting>
<![CDATA[
>>--SockClose(socket)----------------------------------------------------><
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the descriptor of the socket to be closed.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>If the SO_LINGER option of SockSetSockOpt() is enabled, any queued data is sent.
If this option is disabled, any queued data is flushed.
</para>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>The value 0 indicates successful execution of the call. The value -1 indicates an
error. You can get the specific error code by calling SockSock_Errno() or
SockPSock_Errno(). Possible values are:</para>
<variablelist>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EALREADY</term>
      <listitem><para>The socket socket is in nonblocking mode. A previous connection attempt has
      not completed.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>SockClose() is exactly the same as SockSoClose().
</para>
<note><para>SockClose() interfaces with the C function soclose() or, in the Windows
environments, with closesocket().
</para></note>
</section>

<section id="sockconnect"><title>SockConnect</title>
<indexterm><primary>SockConnect</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockConnect</secondary></indexterm>
<indexterm><primary>connect to a host</primary></indexterm>
<indexterm><primary>host, connect to a</primary></indexterm>
<para>The SockConnect() socket call requests a connection to a remote host.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockConnect(socket, address)-----------------------------------------><
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the socket descriptor used to issue the connection request.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>address</term>
      <listitem><para>is a stem variable containing the address of the socket to which a connection is
      to be established.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>The SockConnect() call performs the following tasks when called for a stream
socket:</para>
<orderedlist>
   <listitem><para>It completes the binding for a socket, if necessary.</para></listitem>
   <listitem><para>It attempts to create a connection between two sockets.</para></listitem>
</orderedlist>
<para>This call is used by the client side of socket-based applications to establish a
connection with a server. The remote server must have a passive open pending,
which means it must successfully call SockBind() and SockListen(). Otherwise,
SockConnect() returns the value -1 and the error value is set to ECONNREFUSED.
</para>
<para>In the Internet communication domain, a timeout occurs if a connection to the
remote host is not established within 75 seconds.
</para>
<para>If the socket is in blocking mode, the SockConnect() call blocks the caller until the
connection is established or an error is received. If the socket is in nonblocking
mode, SockConnect() returns the value -1 and sets the error value to
EINPROGRESS if the connection was successfully initiated. The caller can test the
completion of the connection by calling:</para>
<itemizedlist>
   <listitem><para>SockSelect(), to test for the ability to write to the socket</para></listitem>
   <listitem><para>SockGetsockOpt(), with option SO_ERROR, to test if the connection was
   established</para></listitem>
</itemizedlist>
<para>Stream sockets can call SockConnect() only once.</para>
<para>Datagram or raw sockets normally transfer data without being connected to the
sender or receiver. However, an application can connect to such a socket by calling
SockConnect(). SockConnect() specifies and stores the destination peer address for
the socket. The system then knows to which address to send data and the
destination peer address does not have to be specified for each datagram sent. The
address is kept until the next SockConnect() call. This permits the use of the
SockRecv() and SockSend() calls, which are usually reserved for
connection-oriented sockets. However, data is still not necessarily delivered, which
means the normal features of sockets using connectionless data transfer are
maintained. The application can therefore still use the SockSendTo()and
SockRecvFrom() calls.
</para>
<para>Datagram and raw sockets can call SockConnect() several times. The application
can change their destination address by specifying a new address on the
SockConnect() call. In addition, the socket can be returned to a connectionless
mode by calling SockConnect() with a null destination address. The null address is
created by setting the stem variable address as follows: the family field to
AF_INET, the port field to 0, and the addr field to 0.0.0.0.
</para>
<para>The call to SockConnect returns the value -1, indicating that the connection to the
null address cannot be established. Calling SockSock_Errno() returns the value
EADDRNOTAVAIL.
</para>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>The value 0 indicates successful execution of the call. The value -1 indicates an
error. You can get the specific error code by calling SockSock_Errno() or
SockPSock_Errno(). Possible values are:</para>
<variablelist>
   <varlistentry>
      <term>EADDRNOTAVAIL</term>
      <listitem><para>The calling host cannot reach the specified destination.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EAFNOSUPPORT</term>
      <listitem><para>The address family is not supported.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EALREADY</term>
      <listitem><para>The socket socket is in nonblocking mode. A previous connection attempt has
      not completed.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>The socket socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ECONNREFUSED</term>
      <listitem><para>The destination host rejected the connection request.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EINPROGRESS</term>
      <listitem><para>socket is in nonblocking mode, and the connection cannot be completed
      immediately. EINPROGRESS does not indicate an error.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EINTR</term>
      <listitem><para>Interrupted system call.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EISCONN</term>
      <listitem><para>socket is already connected.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENETUNREACH</term>
      <listitem><para>The network cannot be reached from this host.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ETIMEDOUT</term>
      <listitem><para>Establishing the connection timed out.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENOBUFS</term>
      <listitem><para>There is no buffer space available.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EOPNOTSUPP</term>
      <listitem><para>The operation is not supported on socket.
      </para></listitem>
   </varlistentry>
</variablelist>
<note><para>SockConnect interfaces with the C function connect().
</para></note>
</section>

<section id="sockgethostbyaddr"><title>SockGetHostByAddr</title>
<indexterm><primary>SockGetHostAddr</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockGetHostByAddr</secondary></indexterm>
<indexterm><primary>lookup host information</primary></indexterm>
<indexterm><primary>host information, lookup</primary></indexterm>
<para>The SockGetHostByAddr() call retrieves information about a specific host using its
address.</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockGetHostByAddr(dotAddress, host--+------------+--)----------------><
                                        +--, domain--+
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>dotAddress</term>
      <listitem><para>is the standard dotted decimal address of the host.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>host</term>
      <listitem><para>is a stem variable that is to receive the information on the host.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>domain</term>
      <listitem><para>is the domain AF_INET. This parameter is optional.
      </para></listitem>
   </varlistentry>
</variablelist>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>The value 1 indicates successful execution of the call. The value 0 indicates an
error.</para>
<note><para>SockGetHostByAdress() interfaces with the C function gethostbyaddr().
</para></note>
</section>

<section id="sockgethostbyname"><title>SockGetHostByName</title>
<indexterm><primary>SockGetHostName</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockGetHostByName</secondary></indexterm>
<indexterm><primary>lookup host information</primary></indexterm>
<indexterm><primary>host information, lookup</primary></indexterm>
<para>The SockGetHostByName() call retrieves host information on a specific host using
its name or any alias.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockGetHostByName(nameAddress, host)---------------------------------><
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>nameAddress</term>
      <listitem><para>is the name of a host, for example www.ibm.com.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>host</term>
      <listitem><para>is the name of a stem variable to receive the information on the host.
      </para></listitem>
   </varlistentry>
</variablelist>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>The value 1 indicates successful execution of the call. The value 0 indicates an
error.</para>
<note><para>SockGetHostByName() interfaces with the C function gethostbyname().
</para></note>
</section>

<section id="sockgethostid"><title>SockGetHostId</title>
<indexterm><primary>SockGetHostId</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockGetHostById</secondary></indexterm>
<indexterm><primary>lookup local host ip address</primary></indexterm>
<indexterm><primary>local host ip address, lookup</primary></indexterm>
<para>The SockGetHostId() call retrieves the dotAddress of the local host.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockGetHostId()------------------------------------------------------><
]]>
</programlisting>
<para>The return value is the dotAddress of the local host.
</para>
<note><para>SockGetHostId() interfaces with the C function gethostid().
</para></note>
</section>

<section id="sockgetpeername"><title>SockGetPeerName</title>
<indexterm><primary>SockGetPeerName</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockGetPeerName</secondary></indexterm>
<indexterm><primary>lookup remote connected host name</primary></indexterm>
<indexterm><primary>host name, lookup remote connected</primary></indexterm>
<para>The SockGetPeerName() call gets the name of the peer connected to a socket.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockGetPeerName(socket, address)-------------------------------------><
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>address</term>
      <listitem><para>is a stem variable that will contain the address of the peer connected to socket.
      </para></listitem>
   </varlistentry>
</variablelist>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>The value 0 indicates successful execution of the call. The value -1 indicates an
error. You can get the specific error code by calling SockSock_Errno() or
SockPSock_Errno(). Possible values are:</para>
<variablelist>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENOTCONN</term>
      <listitem><para>socket is not connected.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENOBUFS</term>
      <listitem><para>There is no buffer space available.
      </para></listitem>
   </varlistentry>
</variablelist>
<note><para>SockGetPeerName() interfaces with the C function getpeername().
</para></note>
</section>

<section id="sockgetsockname"><title>SockGetSockName</title>
<indexterm><primary>SockGetSockName</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockGetSockName</secondary></indexterm>
<indexterm><primary>lookup local socket name</primary></indexterm>
<indexterm><primary>local socket name, lookup</primary></indexterm>
<para>The SockGetSockName() call gets the local socket name.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockGetSockName(socket, address)-------------------------------------><
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>address</term>
      <listitem><para>is a stem variable that is to receive the address of the socket returned.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>SockGetSockName() returns the address for socket socket in the stem variable
address. If the socket is not bound to an address, the call returns a null address.
</para>
<para>The returned null address is a stem variable with the family field set to AF_INET,
the port field set to 0, and the addr field set to 0.0.0.0.
</para>
<para>All sockets are explicitly assigned an address after a successful call to SockBind().
Stream sockets are implicitly assigned an address after a successful call to
SockConnect() or SockAccept() if SockBind() was not called.
</para>
<para>The SockGetSockName() call is often used to identify the port assigned to a socket
after the socket has been implicitly bound to a port. For example, an application
can call SockConnect() without previously calling SockBind(). In this case, the
SockConnect() call completes the binding necessary by assigning a port to the
socket.
</para>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>The value 0 indicates successful execution of the call. The value -1 indicates an
error. You can get the specific error code by calling SockSock_Errno() or
SockPSock_Errno(). Possible values are:</para>
<variablelist>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENOBUFS</term>
      <listitem><para>There is no buffer space available.
      </para></listitem>
   </varlistentry>
</variablelist>
<note><para>SockGetSockName() interfaces with the C function getsockname().
</para></note>
</section>

<section id="sockgetsockopt"><title>SockGetSockOpt</title>
<indexterm><primary>SockGetSockOpt</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockGetSockOpt</secondary></indexterm>
<indexterm><primary>retrieve socket options</primary></indexterm>
<indexterm><primary>socket options, retrieve</primary></indexterm>
<para>The SockGetSockOpt() call gets the socket options associated with a socket.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockGetSockOpt(socket, level, optName, optVal)-----------------------><
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>level</term>
      <listitem><para>specifies which option level is queried for the specified optname. The only
      supported level is SOL_SOCKET.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>optname</term>
      <listitem><para>is the name of the specified socket option. Only one option can be specified
      with a call.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>optval</term>
      <listitem><para>is the variable to receive the option values requested. For socket options that
      are Boolean the option is enabled if optval is nonzero and disabled if optval is 0.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>SockGetSockOpt() returns the value of a socket option at the socket level. It can be
requested for sockets of all domain types. Some options are supported only for
specific socket types.
</para>
<para>The following options are recognized for SOL_SOCKET:</para>
<variablelist>
   <varlistentry>
      <term>SO_BROADCAST</term>
      <listitem><para>returns the information whether datagram sockets are able to broadcast
      messages. If this option is enabled, the application can send broadcast
      messages using datagram socket socket, if the interface specified in the
      destination supports broadcasting of packets.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_DEBUG</term>
      <listitem><para>returns the information whether debug information can be recorded for a
      socket.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_DONTROUTE</term>
      <listitem><para>returns the information whether the socket is able to bypass the routing of
      outgoing messages. If this option is enabled, outgoing messages are directed to
      the network interface specified in the network portion of the destination
      address. When enabled, packets can only be sent to directly connected
      networks.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_ERROR</term>
      <listitem><para>returns any error pending at the socket and clears the error status. It can be
      used to check for asynchronous errors at connected datagram sockets or for
      asynchronous errors that are not explicitly returned by one of the socket calls.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_KEEPALIVE</term>
      <listitem><para>returns the information whether stream sockets are able to send keepalive
      packets. TCP uses a timer called the keepalive timer. This timer monitors idle
      connections that might have been disconnected because of a peer crash or
      timeout. If this option is enabled, a keepalive packet is periodically sent to the
      peer.</para>
      <para>This option is mainly used to enable servers to close connections that are no
      longer active as a result of clients ending connections without properly closing
      them.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_LINGER</term>
      <listitem><para>returns the information whether stream sockets are able to linger on close if
      data is present. If this option is enabled and there is data still to be sent when
      SockSoClose() is called, the calling application is blocked during the
      SockSoClose() call until the data is transmitted or the connection has timed
      out. If this option is disabled, the SockSoClose() call returns without blocking
      the caller while TCP is trying to send the data. Although the data transfer is
      usually successful, it cannot be guaranteed because TCP tries to send the data
      only for a specific amount of time.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_OOBINLINE</term>
      <listitem><para>returns the information whether stream sockets are able to receive out-of-band
      data. If this option is enabled, out-of-band data is placed in the normal data
      input queue as it is received. It is then made available to SockRecv() and
      SockRecvFrom() without the MSG_OOB flag being specified in those calls. If
      this option is disabled, out-of-band data is placed in the priority data input
      queue as it is received. It can then only be made available to SockRecv() and
      SockRecvFrom() by specifying the MSG_OOB flag in those calls.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_RCVBUF</term>
      <listitem><para>returns the buffer size for input.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_RCVLOWAT</term>
      <listitem><para>returns the receive low-water mark.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_RCVTIMEO</term>
      <listitem><para>returns the timeout value for a receive operation.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_REUSEADDR</term>
      <listitem><para>returns the information whether stream and datagram sockets are able to reuse
      local addresses. If this option is enabled, the local addresses that are already in
      use can then be bound. This alters the normal algorithm used in the SockBind()
      call. At connection time, the system checks whether the local addresses and
      ports differ from foreign addresses and ports. If not, the error value
      EADDRINUSE is returned.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_SNDBUF</term>
      <listitem><para>returns the size of the send buffer.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_SNDLOWAT</term>
      <listitem><para>returns the send low-water mark. This mark is ignored for nonblocking calls
      and not used in the Internet domain.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_SNDTIMEO</term>
      <listitem><para>returns the timeout value for a send operation.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_TYPE</term>
      <listitem><para>returns the socket type. The integer pointed to by optval is then set to one of
      the following: STREAM, DGRAM, RAW, or UNKNOWN.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_USELOOPBACK</term>
      <listitem><para>bypasses hardware where possible.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>All option values are integral except for SO_LINGER, which contains the following
blank-delimited integers:</para>
<itemizedlist>
   <listitem><para>The l_onoff value. It is set to 0 if the SO_LINGER option is disabled.
   </para></listitem>
   <listitem><para>The l_linger value. It specifies the amount of time, in seconds, to be lingered on
   close. A value of 0 causes SockSoClose() to wait until disconnection completes.
   </para></listitem>
</itemizedlist>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>The value 0 indicates successful execution of the call. The value -1 indicates an
error. You can get the specific error code by calling SockSock_Errno() or
SockPSock_Errno(). Possible values are:</para>
<variablelist>
   <varlistentry>
      <term>EADDRINUSE</term>
      <listitem><para>The address is already in use.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENOPROTOOPT</term>
      <listitem><para>optname or level is not recognized.
      </para></listitem>
   </varlistentry>
</variablelist>
<note><para>SockGetSockOpt() interfaces with the C function getsockopt().
</para></note>
</section>

<section id="sockinit"><title>SockInit</title>
<indexterm><primary>SockInit</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockInit</secondary></indexterm>
<indexterm><primary>initialize a socket</primary></indexterm>
<indexterm><primary>socket, initialize a</primary></indexterm>
<para>The SockInit() call initializes the socket data structures and checks whether the
TCP/IP network is active.</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockInit()-----------------------------------------------------------><
]]>
</programlisting>
<para>SockInit() can be called at the beginning of each program that uses SockSocket().
However, it is not obligatory because each RxSock function is automatically
initialized. For this reason, explicit initialization is not available in all system
environments.
</para>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>The value 0 indicates successful execution of the call. The value 1 indicates an
error.</para>
<note><para>SockInit() interfaces with the C function sock_init().
</para></note>
</section>

<section id="sockioctl"><title>SockIoctl</title>
<indexterm><primary>SockIoctl</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockIoctl</secondary></indexterm>
<indexterm><primary>socket special operations</primary></indexterm>
<indexterm><primary>special operations, socket</primary></indexterm>
<para>The SockIoctl() call performs special operations on the socket.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockIoctl(socket, ioctlCmd, ioctlData)-------------------------------><
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ioctlCmd</term>
      <listitem><para>is the ioctl command to be performed.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ioctlData</term>
      <listitem><para>is a variable containing data associated with the particular command. Its
      format depends on the command requested. Valid commands are:</para>
      <variablelist>
         <varlistentry>
            <term>FIONBIO</term>
            <listitem><para>sets or clears nonblocking input or output for a socket. This command is
            an integer. If the integer is 0, nonblocking input or output on the socket is
            cleared. If the integer is a number other than 0, input or output calls do
            not block until the call is completed.
            </para></listitem>
         </varlistentry>
         <varlistentry>
            <term>FIONREAD</term>
            <listitem><para>gets the number of immediately readable bytes for the socket. This
            command is an integer.
            </para></listitem>
         </varlistentry>
      </variablelist>
      </listitem>
   </varlistentry>
</variablelist>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>The value 0 indicates successful execution of the call. The value -1 indicates an
error. You can get the specific error code SockSock_Errno() or SockPSock_Errno().
Possible values are:</para>
<variablelist>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EINVAL</term>
      <listitem><para>The request is not valid or not supported.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EOPNOTSUPP</term>
      <listitem><para>The operation is not supported on the socket.
      </para></listitem>
   </varlistentry>
</variablelist>
<note><para>SockIoctl() interfaces with the C function ioctl() or, in the Windows
environments, with ioctlsocket().
</para></note>
</section>

<section id="socklisten"><title>SockListen</title>
<indexterm><primary>SockListen</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockListen</secondary></indexterm>
<indexterm><primary>listen on a socket for a connection</primary></indexterm>
<indexterm><primary>connection, listen on a socket for a</primary></indexterm>
<para>The SockListen() call completes the binding necessary for a socket to accept
connections and creates a connection request queue for incoming requests.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockListen(socket, backlog)------------------------------------------><
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>backlog</term>
      <listitem><para>controls the maximum queue length for pending connections.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>SockListen() performs the following tasks:</para>
<orderedlist>
   <listitem><para>1. It completes the binding necessary for socket socket, if SockBind() has not been
   called for the socket.
   </para></listitem>
   <listitem><para>It creates a connection request queue with a length of backlog to queue
   incoming connection requests.
   </para></listitem>
</orderedlist>
<para>When the queue is full, additional connection requests are ignored.
</para>
<para>SockListen() can only be called for connection-oriented sockets.
</para>
<para>SockListen() is called after allocating a socket with SockSocket() and after binding a
name to socket with SockBind(). It must be called before SockAccept().
</para>
<para>SockListen() indicates when it is ready to accept client connection requests. It
transforms an active socket to a passive socket. After it is called, socket cannot be
used as an active socket to initiate connection requests.
</para>
<para>If backlog is smaller than 0, SockListen() interprets the backlog to be 0. If it is
greater than the maximum value defined by the network system, SockListen()
interprets the backlog to be this maximum value.
</para>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>The value 0 indicates successful execution of the call. The value -1 indicates an
error. You can get the specific error code SockSock_Errno() or SockPSock_Errno().
Possible values are:</para>
<variablelist>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EOPNOTSUPP</term>
      <listitem><para>socket is not a socket descriptor that supports the SockListen() call.
      </para></listitem>
   </varlistentry>
</variablelist>
<note><para>SockListen() interfaces with the C function listen().
</para></note>
</section>

<section id="sockpsockerrno"><title>SockPSock_Errno</title>
<indexterm><primary>SockPSock</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockPSock</secondary></indexterm>
<indexterm><primary>error messages, writing</primary></indexterm>
<indexterm><primary>writing error messages</primary></indexterm>
<para>The SockPSock_Errno() call writes a short error message to the standard error
device. It describes the last error encountered during a call to a socket library
function.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockPSock_Errno(--+----------------+--)------------------------------><
                      +--error_string--+
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>error_string</term>
      <listitem><para>is the error string written to the standard error device describing the last error
      encountered. The string printed is followed by a colon, a space, and then the
      message. If it is omitted or empty, only the message is printed. The string is
      optional.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>The error code is acquired by calling SockSock_Errno(). It is set when errors occur.
Subsequent socket calls do not clear the error code.
</para>
<note><para>SockPSock_Errno() interfaces with the C function psock_errno().
</para></note>
</section>

<section id="sockrecv"><title>SockRecv</title>
<indexterm><primary>SockRecv</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockRecv</secondary></indexterm>
<indexterm><primary>recieve data on socket</primary></indexterm>
<indexterm><primary>data on socket, recieve</primary></indexterm>
<para>The SockRecv() call receives data on a connected socket.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockRecv(socket, var, len--+-----------+--)--------------------------><
                               +--, flags--+
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>var</term>
      <listitem><para>is the name of a Rexx variable to receive the data.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>len</term>
      <listitem><para>is the maximum amount of data to be read.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>flags</term>
      <listitem><para>is a blank-delimited list of options:</para>
      <variablelist>
         <varlistentry>
            <term>MSG_OOB</term>
            <listitem><para>reads any out-of-band data on the socket.
            </para></listitem>
         </varlistentry>
         <varlistentry>
            <term>MSG_PEEK</term>
            <listitem><para>peeks at the data on the socket. The data is returned but not removed, so
            the subsequent receive operation sees the same data.
            </para></listitem>
         </varlistentry>
      </variablelist>
      </listitem>
   </varlistentry>
</variablelist>
<para>SockRecv() receives data on a socket with descriptor socket and stores it in the
Rexx variable var. It applies only to connected sockets. For information on how to
use SockRecv() with datagram and raw sockets, see Datagram or raw sockets.
</para>
<para>SockRecv() returns the length of the incoming data. If a datagram is too long to fit
the buffer, the excessive data is discarded. No data is discarded for stream sockets.
If data is not available at socket, the SockRecv() call waits for a message and blocks
the caller unless the socket is in nonblocking mode. See SockIoctl() for a
description of how to set the nonblocking mode.
</para>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>If successful, the length of the data in bytes is returned. The value 0 indicates that
the connection is closed. The value -1 indicates an error. You can get the specific
error code SockSock_Errno() or SockPSock_Errno(). Possible values are:</para>
<variablelist>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EINTR</term>
      <listitem><para>Interrupted system call.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EINVAL</term>
      <listitem><para>Invalid argument.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EWOULDBLOCK</term>
      <listitem><para>socket is in nonblocking mode and no data is available, or the SO_RCVTIMEO
      option has been set for socket and the timeout expired before any data arrived.
      </para></listitem>
   </varlistentry>
</variablelist>
<note><para>SockRecv() interfaces to the C function recv().
</para></note>
</section>

<section id="sockrecvfrom"><title>SockRecvFrom</title>
<indexterm><primary>SockRecvFrom</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockRecvFrom</secondary></indexterm>
<indexterm><primary>recieve data on socket</primary></indexterm>
<indexterm><primary>data on socket, recieve</primary></indexterm>
<para>The SockRecvFrom() call receives data on a socket.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockRecvFrom(socket, var, len--+-----------+--, address)-------------><
                                   +--, flags--+
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>var</term>
      <listitem><para>is the name of a Rexx variable to receive the data.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>len </term>
      <listitem><para>is the maximum amount of data to be read.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>flags</term>
      <listitem><para>is a blank delimited list of options:</para>
      <variablelist>
         <varlistentry>
            <term>MSG_OOB</term>
            <listitem><para>reads any out-of-band data on the socket.
   	  </para></listitem>
	       </varlistentry>
	       <varlistentry>
            <term>MSG_PEEK</term>
            <listitem><para>peeks at the data present on the socket. The data is returned but not
            consumed. The subsequent receive operation thus sees the same data.
   	  </para></listitem>
	       </varlistentry>
      </variablelist>
      </listitem>
   </varlistentry>
   <varlistentry>
      <term>address</term>
      <listitem><para>is a stem variable specifying the address of the sender from which the data is
      received, unless it is a null address.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>SockRecvFrom() receives data on a socket with descriptor socket and stores it in a
Rexx variable named var. It applies to any socket type, whether connected or not.
</para>
<para>SockRecvFrom() returns the length of the incoming message or data. If a datagram
is too long to fit the supplied buffer, the excessive data is discarded. No data is
discarded for stream sockets. If data is not available at socket, the SockRecvFrom()
call waits for a message to arrive and blocks the caller, unless the socket is in
nonblocking mode. See SockIoctl() for a description of how to set the nonblocking
mode.</para>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>If successful, the length of the data in bytes is returned. The value -1 indicates an
error. You can get the specific error code SockSock_Errno() or SockPSock_Errno().
Possible values are:</para>
<variablelist>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EINVAL</term>
      <listitem><para>Invalid argument.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EWOULDBLOCK</term>
      <listitem><para>socket is in nonblocking mode, no data is available, or the SO_RCVTIMEO
      option has been set for socket and the timeout expired before data arrived.
      </para></listitem>
   </varlistentry>
</variablelist>
<note><para>SockRecvFrom() interfaces with the C function recvfrom().
</para></note>
</section>

<section id="sockselect"><title>SockSelect</title>
<indexterm><primary>SockSelect</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockSelect</secondary></indexterm>
<indexterm><primary>monitor a socket</primary></indexterm>
<indexterm><primary>socket, monitor a</primary></indexterm>
<indexterm><primary>status of a socket</primary></indexterm>
<indexterm><primary>socket, status of a</primary></indexterm>
<para>The SockSelect() call monitors the activity on a socket with regard to readability,
readiness for writing, and pending exceptional conditions.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockSelect(reads, writes, excepts--+-------------+--)----------------><
                                       +--, timeout--+
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>reads</term>
      <listitem><para>is the number of sockets to be checked for readability.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>writes</term>
      <listitem><para>is the number of sockets to be checked for readiness for writing.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>excepts</term>
      <listitem><para>is the number of sockets to be checked for pending exceptional conditions. For
      Network Services sockets, the only pending exceptional condition is
      out-of-band data in the receive buffer.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>timeout</term>
      <listitem><para>is the maximum number of seconds the system waits for the selection to
      complete. Set the timeout parameter to 0 for a blocking operation. If the socket
      is ready, the return will be immediate.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>Each parameter specifying a number of sockets is qualified by a stem variable
which is queried and set by this function. The stem variable has the following
format: stem.0 contains the number of sockets, stem.1 the first socket, and so on.
Upon return, the stem variables are reset to the sockets that are ready. If any of the
stem variables are empty (), or no parameter is passed, no sockets for that type
are checked.
</para>
<para>The timeout value must be integral (no fractional values). Nonnumeric and
negative numbers are considered to be 0. If no timeout value is passed, an empty
string () is assumed.
</para>
<para>If the timeout value is 0, SockSelect() does not wait before returning. If the timeout
value is an empty string (), SockSelect() does not time out, but returns when a
socket becomes ready. If the timeout value is in seconds, SockSelect() waits for the
specified interval before returning. It checks all indicated sockets at the same time
and returns as soon as one of them is ready.
</para>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>The number of ready sockets is returned. The value 0 indicates an expired time
limit. In this case, the stem variables are not modified. The value -1 indicates an
error. You can get the specific error code SockSock_Errno() or SockPSock_Errno().
Possible values are:</para>
<variablelist>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EFAULT</term>
      <listitem><para>The address is not valid.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EINVAL</term>
      <listitem><para>Invalid argument.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EINTR</term>
      <listitem><para>Interrupted system call.
      </para></listitem>
   </varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
r.0 = 2                     /* specify 2 sockets for read in stem r. */
r.1 = 101
r.2 = 102
                            /* specify 1 socket for write in stem w. */
w.0 = 1
w.1 = 103
                          /* no sockets for exceptions in stem e.    */
e.0 = 0
rc = SockSelect("r.","w.","e.")
do i = 1 to r.0           /* display sockets ready for read          */
    say "socket" r.i "is ready for reading."
end
</programlisting>
<para>That SockSelect() call can be invoked as:</para>
<programlisting>
rc = SockSelect("r.","w.","")
</programlisting>
<para>or</para>
<programlisting>
rc = SockSelect("r.","w.",)
</programlisting>
<para>The function call SockSelect(, , , x) results in the program pausing for x seconds.
</para>
<note><para>SockSelect() interfaces with the C function select().
</para></note>
</section>

<section id="socksend"><title>SockSend</title>
<indexterm><primary>SockSend</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockSend</secondary></indexterm>
<indexterm><primary>send data on socket</primary></indexterm>
<indexterm><primary>data on socket, send</primary></indexterm>
<para>The SockSend() call sends data to a connected socket.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockSend(socket, data--+-----------+--)------------------------------><
                           +--, flags--+
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>data</term>
      <listitem><para>is the name of a Rexx variable containing the data to be transmitted.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>flags</term>
      <listitem><para>is a blank delimited list of options:</para>
      <variablelist>
         <varlistentry>
            <term>MSG_OOB</term>
            <listitem><para>sends out-of-band data to sockets that support SOCK_STREAM
            communication.
  	  </para></listitem>
         </varlistentry>
         <varlistentry>
            <term>MSG_DONTROUTE</term>
            <listitem><para>turns on the SO_DONTROUTE option for the duration of the send
            operation. This option is usually only used by diagnostic or routing
            programs.
  	  </para></listitem>
         </varlistentry>
      </variablelist>
      </listitem>
   </varlistentry>
</variablelist>
<para>SockSend() sends data to a connected socket with descriptor socket. For information
on how to use SockSend() with datagram and raw sockets, see Datagram or raw
sockets.
</para>
<para>If the socket does not have enough buffer space to hold the data to be sent, the
SockSend() call blocks unless the socket is placed in nonblocking mode. See
SockIoctl() for a description of how to set the nonblocking mode. Use the
SockSelect() call to determine when it is possible to send more data.
</para>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>If successful, the number of bytes of the socket with descriptor socket that is added
to the send buffer is returned. Successful completion does not imply that the data
has already been delivered to the receiver.
</para>
<para>The return value -1 indicates that an error was detected on the sending side of the
connection. You can get the specific error code SockSock_Errno() or
SockPSock_Errno(). Possible values are:</para>
<variablelist>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EINTR</term>
      <listitem><para>Interrupted system call.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EINVAL</term>
      <listitem><para>Invalid argument.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENOBUFS</term>
      <listitem><para>There is no buffer space available to send the message.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EWOULDBLOCK</term>
      <listitem><para>socket is in nonblocking mode, the data cannot be sent without blocking, or the
      SO_SNDTIMEO option has been set for socket and the timeout expired before
      any data was sent.
      </para></listitem>
   </varlistentry>
</variablelist>
<note><para>SockSend() interfaces with the C function send().
</para></note>
</section>

<section id="socksendto"><title>SockSendTo</title>
<indexterm><primary>SockSendTo</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockSendTo</secondary></indexterm>
<indexterm><primary>send data on socket</primary></indexterm>
<indexterm><primary>data on socket, send</primary></indexterm>
<para>The SockSentTo() call sends data to a connected or unconnected socket.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockSendTo(socket, data--+-----------+--, address)-------------------><
                             +--, flags--+
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>data</term>
      <listitem><para>is a string of data to be transmitted.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>flags</term>
      <listitem><para>is a blank delimited list of options:</para>
      <variablelist>
         <varlistentry>
            <term>MSG_OOB</term>
            <listitem><para>sends out-of-band data to sockets that support SOCK_STREAM
            communication.
            </para></listitem>
         </varlistentry>
         <varlistentry>
            <term>MSG_DONTROUTE</term>
            <listitem><para>turns on the SO_DONTROUTE option for the duration of the send
            operation. This option is usually only used by diagnostic or routing
            programs.
            </para></listitem>
         </varlistentry>
      </variablelist>
      </listitem>
   </varlistentry>
   <varlistentry>
      <term>address</term>
      <listitem><para>is a stem variable containing the destination address.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>SockSendTo() sends data to a connected or unconnected socket with descriptor
socket. For unconnected datagram and raw sockets, it sends data to the specified
destination address. For stream sockets, the destination address is ignored.
</para>
<para>Datagram sockets are connected by calling SockConnect(). This call identifies the
peer to send or receive the datagram. After a datagram socket is connected to a
peer, you can still use the SockSendTo() call but you cannot include a destination
address.
</para>
<para>To change the peer address when using connected datagram sockets, issue
SockConnect() with a null address. Specifying a null address removes the peer
address specification. You can then issue either a SockSendTo() call and specify a
different destination address or a SockConnect() call to connect to a different peer.
For more information on connecting datagram sockets and specifying null
addresses, see Datagram or raw sockets.
</para>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>If successful, the number of bytes sent is returned. Successful completion does not
guarantee that the data is delivered to the receiver. The return value -1 indicates
that an error was detected on the sending side. You can get the specific error code
SockSock_Errno() or SockPSock_Errno(). Possible values are:</para>
<variablelist>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EMSGSIZE</term>
      <listitem><para>The message data was too big to be sent as a single datagram.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENOBUFS</term>
      <listitem><para>There is no buffer space available to send the message.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EWOULDBLOCK</term>
      <listitem><para>socket is in nonblocking mode, the data cannot be sent without blocking, or the
      SO_SNDTIMEO option has been set for socket and the timeout expired before
      any data was sent.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENOTCONN</term>
      <listitem><para>The socket is not connected.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EDESTADDRREQ</term>
      <listitem><para>Destination address required.
      </para></listitem>
   </varlistentry>
</variablelist>
<note><para>SockSendTo() interfaces with the C function sendto().
</para></note>
</section>

<section id="socksetsockopt"><title>SockSetSockOpt</title>
<indexterm><primary>SockSetSockOpt</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockSetSockOpt</secondary></indexterm>
<indexterm><primary>set an option of a socket</primary></indexterm>
<indexterm><primary>option of a socket, set an</primary></indexterm>
<para>The SockSetSockOpt() call sets options associated with a socket.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockSetSockOpt(socket, level, optName, optVal)-----------------------><
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>level</term>
      <listitem><para>specifies which option level is set. The only supported level is SOL_SOCKET.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>optname</term>
      <listitem><para>is the name of a specified socket option.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>optval</term>
      <listitem><para>is the variable containing the data needed by the set command. It is optional.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>SockSetSockOpt() sets options associated with a socket with descriptor socket such
as enabling debugging at the socket or protocol level, controlling timeouts, or
permitting socket data broadcasting. Options can exist at the socket or the protocol
level. They are always present at the highest socket level. When setting socket
options, the option level and name must be specified.
</para>
<para>For socket options that are toggles, the option is enabled if optval is nonzero and
disabled if optval is 0.
</para>
<para>The following options are recognized for SOL_SOCKET:</para>
<variablelist>
   <varlistentry>
      <term>SO_BROADCAST</term>
      <listitem><para>enables datagram sockets to broadcast messages. The application can then send
      broadcast messages using datagram socket socket, if the interface specified in
      the destination supports broadcasting of packets.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_DEBUG</term>
      <listitem><para>enables debug information to be recorded for a socket.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_DONTROUTE</term>
      <listitem><para>enables the socket to bypass the routing of outgoing messages. Outgoing
      messages are then directed to the network interface specified in the network
      portion of the destination address. When enabled, packets can only be sent to
      directly connected networks.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_KEEPALIVE</term>
      <listitem><para>enables stream sockets to send keepalive packets, which keep the connection
      alive. TCP uses a timer called the keepalive timer. This timer monitors idle
      connections that might have been disconnected because of a peer crash or
      timeout. If this option is enabled, a keepalive packet is periodically sent to the
      peer.</para>
      <para>This option is mainly used to enable servers to close connections that are no
      longer active as a result of clients ending connections without properly closing
      them.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_LINGER</term>
      <listitem><para>enables stream sockets to linger on close if data is present. If this option is
      enabled and there is data still to be sent when SockSoClose() is called, the
      calling application is blocked during the SockSoClose() call until the data is
      transmitted or the connection has timed out. If this option is disabled, the
      SockSoClose() call returns without blocking the caller while TCP is trying to
      send the data. Although the data transfer is usually successful, it cannot be
      guaranteed because TCP tries to send the data only for a specific amount of
      time.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_OOBINLINE</term>
      <listitem><para>enables stream sockets to receive out-of-band data, which is a logically
      separate data path using the same connection as the normal data path. If this
      option is enabled, out-of-band data is placed in the normal data input queue as
      it is received. It is then made available to SockRecv() and SockRecvFrom()
      without the MSG_OOB flag being specified in those calls. If this option is
      disabled, out-of-band data is placed in the priority data input queue as it is
      received. It can then only be made available to SockRecv() and SockRecvFrom()
      by specifying the MSG_OOB flag in those calls.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_RCVBUF</term>
      <listitem><para>sets the buffer size for input. This option sets the size of the receive buffer to
      the value contained in the buffer pointed to by optval. In this way, the buffer
      size can be tailored for specific application needs, such as increasing the buffer
      size for high-volume connections.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_RCVLOWAT</term>
      <listitem><para>sets the receive low-water mark.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_RCVTIMEO</term>
      <listitem><para>sets the timeout value for a receive operation.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_REUSEADDR</term>
      <listitem><para>enables stream and datagram sockets to reuse local addresses. Local addresses
      that are already in use can then be bound. This alters the normal algorithm
      used in the SockBind() call. At connection time, the system checks whether the
      local addresses and ports differ from foreign addresses and ports. If not, the
      error value EADDRINUSE is returned.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_SNDBUF</term>
      <listitem><para>Sets the buffer size for output. This option sets the size of the send buffer to
      the value contained in the buffer pointed to by optval. In this way, the send
      buffer size can be tailored for specific application needs, such as increasing the
      buffer size for high-volume connections.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_SNDLOWAT</term>
      <listitem><para>sets the send low-water mark. This mark is ignored for nonblocking calls and
      not used in the Internet domain.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_SNDTIMEO</term>
      <listitem><para>sets the timeout value for a send operation.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>SO_USELOOPBACK</term>
      <listitem><para>bypasses hardware where possible.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>Except for SO_LINGER, all values are integral. SO_LINGER expects two blank
delimited integers:</para>
<orderedlist>
   <listitem><para>The l_onoff value. It is set to 0 if the SO_LINGER option is disabled.
   </para></listitem>
   <listitem><para>the l_linger value. The l_linger field specifies the amount of time, in seconds, to
   be lingered on close. A value of 0 causes SockSoClose() to wait until
   disconnection completes.
   </para></listitem>
</orderedlist>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>The value 0 indicates successful execution of the call. The value -1 indicates an
error. You can get the specific error code SockSock_Errno() or SockPSock_Errno().
Possible values are:</para>
<variablelist>
   <varlistentry>
      <term>EADDRINUSE</term>
      <listitem><para>The address is already in use.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENOPROTOOPT</term>
      <listitem><para>optname is not recognized.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EINVAL</term>
      <listitem><para>Invalid argument.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ENOBUFS</term>
      <listitem><para>There is no buffer space available.
      </para></listitem>
   </varlistentry>
</variablelist>
<note><para>SockSetSockOpt() interfaces with the C function setsockopt().
</para></note>
</section>

<section id="sockshutdown"><title>SockShutDown</title>
<indexterm><primary>SockShutDown</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockShutDown</secondary></indexterm>
<indexterm><primary>shutdown a socket</primary></indexterm>
<indexterm><primary>socket, shutdown a</primary></indexterm>
<para>The SockShutDown() call shuts down all, or part, of a full duplex connection. This
call is optional.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockShutDown(socket, howto)------------------------------------------><
]]>
</programlisting>
<para>>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>howto</term>
      <listitem><para>is the condition of the shutdown of socket socket.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>Because data flows in different directions are independent of each other,
SockShutDown() allows you to independently stop data flows in one direction, or
all data flows, with one API call. For example, you can enable yourself to send
data but disable other senders to send data to you.
</para>
<para>The howto parameter sets the condition for shutting down the connection to socket
socket. It can be set to one of the following:</para>
<variablelist>
   <varlistentry>
      <term>0</term>
      <listitem><para>No more data can be received on socket socket.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>1</term>
      <listitem><para>No more output is allowed on socket socket.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>2</term>
      <listitem><para>No more data can be sent or received on socket socket.
      </para></listitem>
   </varlistentry>
</variablelist>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>The value 0 indicates successful execution of the call. The value -1 indicates an
error. You can get the specific error code SockSock_Errno() or SockPSock_Errno().
Possible values are:</para>
<variablelist>
   <varlistentry>
      <term>ENOTSOCK</term>
      <listitem><para>socket is not a valid socket descriptor.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EINVAL</term>
      <listitem><para>    howto was not set to a valid value.
      </para></listitem>
   </varlistentry>
</variablelist>
<note><para>SockShutDown() interfaces with the C function shutdown().
</para></note>
</section>

<section id="socksockerrno"><title>SockSock_Errno</title>
<indexterm><primary>SockSock_Errno</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockSock_Errno</secondary></indexterm>
<indexterm><primary>socket error, get last</primary></indexterm>
<indexterm><primary>error, get last socket</primary></indexterm>
<indexterm><primary>get last socket error</primary></indexterm>
<para>The SockSock_Errno() call returns the last error code set by a socket call.
Subsequent socket API calls do not reset this error code.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockSock_Errno()-----------------------------------------------------><
]]>
</programlisting>
<note><para>SockSock_Errno() interfaces with the C function sock_errno().
</para></note>
</section>

<section id="socksocket"><title>SockSocket</title>
<indexterm><primary>SockSocket</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockSocket</secondary></indexterm>
<indexterm><primary>get a new socket</primary></indexterm>
<indexterm><primary>socket, get a new</primary></indexterm>
<indexterm><primary>new socket, get a</primary></indexterm>
<para>The SockSocket() call creates an end point for communication and returns a socket
descriptor representing the end point. Each socket type provides a different
communication service.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockSocket(domain, type, protocol)-----------------------------------><
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>domain</term>
      <listitem><para>is the communication domain requested. It specifies the protocol family to be
      used. Currently, only the domain AF_INET is supported, which uses
      addresses in the Internet address format.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>type</term>
      <listitem><para>is the type of socket created. The following types are supported:
      <variablelist>
         <varlistentry>
            <term>SOCK_STREAM</term>
            <listitem><para>provides sequenced, two-way byte streams that are reliable and
            connection-oriented. It supports a mechanism for out-of-band data. Stream
            sockets are supported by the Internet (AF_INET) communication domain.
             </para></listitem>
         </varlistentry>
         <varlistentry>
            <term>SOCK_DGRAM</term>
            <listitem><para>provides datagrams, which are connectionless messages of a fixed length
            whose reliability is not guaranteed. Datagrams can be received out of
            order, lost, or delivered several times. Datagram sockets are supported by
            the Internet (AF_INET) communication domain.
             </para></listitem>
         </varlistentry>
         <varlistentry>
            <term>SOCK_RAW</term>
            <listitem><para>provides the interface to internal protocols, such as IP and ICMP. Raw
            sockets are supported by the Internet (AF_INET) communication domain.
             </para></listitem>
         </varlistentry>
      </variablelist>
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>protocol</term>
      <listitem><para>is the protocol to be used with the socket. It can be IPPROTO_UDP,
      IPPROTO_TCP, or 0. If it is set to 0, which is the default, the system selects
      the default protocol number for the domain and socket type requested.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>Sockets are deallocated with the SockClose() call.
</para>
<para><emphasis role="bold">Return values:</emphasis></para>
<para>A non-negative socket descriptor return value indicates successful execution of the
call. The return value -1 indicates an error. You can get the specific error code
SockSock_Errno() or SockPSock_Errno(). Possible values are:</para>
<variablelist>
   <varlistentry>
      <term>EMFILE</term>
      <listitem><para>The maximum number of sockets are currently in use.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EPROTONOSUPPORT</term>
      <listitem><para>The protocol is not supported in the specified domain or the protocol is not
      supported for the specified socket type.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>EPFNOSUPPORT</term>
      <listitem><para>The protocol family is not supported.
      </para></listitem>
   </varlistentry>
   <varlistentry>
      <term>ESOCKTNOSUPPORT</term>
      <listitem><para>The socket type is not supported.
      </para></listitem>
   </varlistentry>
</variablelist>
<note><para>SockSocket() interfaces with the C function socket().
</para></note>
</section>

<section id="socksoclose"><title>SockSoClose</title>
<indexterm><primary>SockSoClose</primary></indexterm>
<indexterm><primary>function</primary>
<secondary>SockSoClose</secondary></indexterm>
<indexterm><primary>closing a socket</primary></indexterm>
<para>The SockSoClose() call shuts down a socket and frees resources allocated to the
socket.
</para>
<para><emphasis role="bold">Syntax:</emphasis></para>
<programlisting>
<![CDATA[
>>--SockSoClose(socket)--------------------------------------------------><
]]>
</programlisting>
<para>where:</para>
<variablelist>
   <varlistentry>
      <term>socket</term>
      <listitem><para>is the socket descriptor of the socket to be closed.
      </para></listitem>
   </varlistentry>
</variablelist>
<para>This function is identical to SockClose().</para>
</section>
</chapter>

&notices;
&cpl;

&genindex;

</book>
