<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "rexxapi.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: Programming Guide XML file.
    #
    # Copyright (c) 2005-2020, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<chapter id="classicapi">
<title>Classic Rexx Application Programming Interfaces</title>
<para>This chapter describes how to interface applications to Rexx or extend
the Rexx language by using Rexx application programming interfaces (APIs).
As used here, the term application refers to programs
written in languages other than Rexx. This is usually the C language. Conventions
in this chapter are based on the C language. Refer to a C programming reference
manual if you need a better understanding of these conventions.</para>
<para>The features described here let an application extend many parts of the
Rexx language or extend an application with Rexx. This includes creating handlers
for subcommands, external functions, and system exits. </para>
<variablelist>
<varlistentry><term>Subcommands</term>
<listitem><para>are commands issued from a Rexx program. A Rexx expression is evaluated
and the result is passed as a command to the currently addressed subcommand
handler. Subcommands are used in Rexx programs running as application macros.
</para></listitem></varlistentry>
<varlistentry><term>Functions</term>
<listitem><para>are direct extensions of the Rexx language. An application can create
functions that extend the native Rexx function set. Functions can be general-purpose
extensions or specific to an application.
</para></listitem></varlistentry>
<varlistentry><term>System exits</term>
<listitem><para>are programmer-defined variations of the operating system.
The application programmer can tailor the Rexx interpreter behavior by
replacing Rexx system requests.
</para></listitem></varlistentry>
</variablelist>
<para>Subcommand, function, and system exit handlers have similar coding, compilation,
and packaging characteristics.</para>
<para>In addition, applications can manipulate the variables in Rexx programs
(see <xref linkend="os2vpi" />),
and execute Rexx routines directly from memory
(see <xref linkend="macrosp" />).</para>

<section id="apigenc"><title>Handler Characteristics</title>
<para>The basic requirements for subcommand, function, and system exit handlers
are: </para>
<itemizedlist>
<listitem><para>Rexx handlers must use the REXXENTRY linkage convention.
Handler functions should be declared with the appropriate type definition
from the rexx.h include file. Using <computeroutput>C++</computeroutput>,
the functions must be declared as <computeroutput>extern "C"</computeroutput>:
<itemizedlist>
<listitem><para>RexxSubcomHandler</para></listitem>
<listitem><para>RexxFunctionHandler</para></listitem>
<listitem><para>RexxExitHandler</para></listitem></itemizedlist></para></listitem>
<listitem><para>A Rexx handler must be packaged as either of the following:
<itemizedlist>
<listitem><para>An exported routine within a loadable library (dynamic-link library (DLL) on Windows,
or shared library on Unix-based systems.).
</para></listitem>
<listitem><para>An entry point within an executable (EXE) module
</para></listitem>
</itemizedlist>
</para></listitem>
<listitem><para>A handler must be registered with Rexx before it can be used. Rexx uses
the registration information to locate and call the handler. For example,
external function registration of a dynamic-link library
external function identifies both the dynamic-link library
and routine that contains the external function. Also note:
<itemizedlist>
<listitem><para>Dynamic-link library handlers are global to the system; any
Rexx program can call them.</para></listitem>
<listitem><para>Executable file handlers are local to the registering process;
only a Rexx program running in the same process as an executable module can call
a handler packaged within that executable module.</para></listitem>
</itemizedlist></para></listitem></itemizedlist>
</section>

<section id="rxstrings"><title>RXSTRINGs</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>RXSTRING data structure</secondary></indexterm>
<indexterm><primary>application programming interfaces</primary>
<secondary>RXSTRING data structure</secondary>
<tertiary>RXSTRING</tertiary></indexterm>
<indexterm><primary>RXSTRING</primary></indexterm>
<indexterm><primary>RXSTRING</primary>
<secondary>definition</secondary></indexterm>
<para>Many of the Rexx application programming interfaces pass Rexx character
strings to and from a Rexx procedure. The RXSTRING data structure is used
to describe Rexx character strings.  An RXSTRING is a content-insensitive,
flat model character string with
a theoretical maximum length of 4 gigabytes. The following structure defines
an RXSTRING:</para>
<example>
<title>RXSTRING</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   size_t          strlength;     /* length of string             */
   char *          strptr;        /* pointer to string            */
} RXSTRING;

typedef RXSTRING *PRXSTRING;      /* pointer to an RXSTRING       */
]]>
</programlisting>
</example>
<para>Many programming interfaces use RXSTRINGs for input-only operations.
These APIs use a constant version of the RXSTRING, the CONSTRXSTRING.</para>
<example>
<title>RXSTRING</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   size_t          strlength;     /* length of string             */
   const char *    strptr;        /* pointer to string            */
} RXSTRING;

typedef CONSTRXSTRING *PCONSTRXSTRING;      /* pointer to a CONSTRXSTRING       */
]]>
</programlisting>
</example>

<para>Notes:</para>
<orderedlist>
<listitem><para>The rexx.h include file contains a number of convenient macros
for setting and testing RXSTRING values.</para></listitem>
<listitem><para>
An RXSTRING can have a value (including the null string,
"") or it can be empty.
<itemizedlist>
<listitem><para>If an RXSTRING has a value, the
<emphasis role="italic">strptr</emphasis> field is not null. The
RXSTRING macro RXVALIDSTRING(string) returns TRUE.</para></listitem>
<listitem><para>If an RXSTRING is the Rexx null string (""), the
<emphasis role="italic">strptr</emphasis> field
is not null and the <emphasis role="italic">strlength</emphasis> field is 0.
The RXSTRING macro RXZEROLENSTRING(string) returns TRUE.</para></listitem>
<listitem><para>If an RXSTRING is empty, the field
<emphasis role="italic">strptr</emphasis> is null. The RXSTRING
macro RXNULLSTRING(string) returns TRUE.</para></listitem>
</itemizedlist>
</para></listitem>
<listitem><para>When the Rexx
interpreter passes an RXSTRING to a subcommand handler, external function,
or exit handler, the interpreter adds a
<indexterm><primary>RXSTRING</primary>
<secondary>null terminated</secondary></indexterm>
null character (hexadecimal zero)
at the end of the RXSTRING data. You can use the C string library functions
on these strings. However, the RXSTRING data can also contain null characters.
There is no guarantee that the first null character encountered in an RXSTRING
marks the end of the string. You use the C string functions only when you
do not expect null characters in the RXSTRINGs, such as file names passed
to external functions. The <emphasis role="italic">strlength</emphasis> field
in the RXSTRING does not include the terminating null character.</para></listitem>
<listitem><para>On calls to subcommand
<indexterm><primary>RXSTRING</primary>
<secondary>returning</secondary></indexterm>
and external functions handlers, as well as to some of the exit handlers,
the Rexx interpreter expects that an RXSTRING value is returned. The Rexx
interpreter provides a default RXSTRING with a
<emphasis role="italic">strlength</emphasis> of 256 for
the returned information. If the returned data is shorter than 256 characters,
the handler can copy the data into the default RXSTRING and set the
<emphasis role="italic">strlength</emphasis> field to the length returned.</para>
<para>If the returned data is longer than 256 characters,
a new RXSTRING can be allocated using
<computeroutput>RexxAllocateMemory(size)</computeroutput>. The
<emphasis role="italic">strptr</emphasis> field must point to the new storage
and the <emphasis role="italic">strlength</emphasis> must
be set to the string length. The Rexx interpreter returns the newly allocated
storage to the system for the handler routine.</para></listitem>
</orderedlist>
</section>

<section id="rxinvk"><title>Calling the Rexx Interpreter</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>invoking the Rexx interpreter</secondary></indexterm>
<indexterm><primary>calling the Rexx interpreter</primary></indexterm>
<indexterm><primary>invoking the Rexx interpreter</primary></indexterm>
<indexterm><primary>Rexx interpreter, invoking</primary></indexterm>
<para>A Rexx program can be run directly from the command prompt
of the operating system, or from within an application.</para>

<section id="invcom"><title>From the Operating System</title>
<para>You can run a Rexx program directly from the operating system
command prompt using Rexx followed by the program name.</para>
</section>

<section id="fwaa"><title>From within an Application</title>
<para>The Rexx interpreter is a dynamic-link library
(DLL) routine (or Unix/Linux shared object). Any application
can call the Rexx interpreter to run a Rexx program. The interpreter is fully
reentrant and supports Rexx procedures running on several threads within the
same process.</para>
<para>A C-language prototype for calling Rexx is in the rexx.h include file.</para>
</section>

<section id="rexxstartfu"><title>The RexxStart Function</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>invoking the Rexx interpreter</secondary>
<tertiary>RexxStart</tertiary></indexterm>
<indexterm><primary>RexxStart</primary></indexterm>
<para>RexxStart calls the Rexx interpreter to run a Rexx procedure. </para>
<programlisting language="C++">
retc = RexxStart(ArgCount, ArgList, ProgramName, Instore, EnvName,
                 CallType, Exits, ReturnCode, Result);
</programlisting>

<section id="rexxstartparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>ArgCount (size_t) - input</term>
<listitem><para>is the number of elements in the
<emphasis role="italic">ArgList</emphasis> array. This is the
value that the <emphasis role="italic">ARG()</emphasis> built-in function in
the Rexx program returns. <emphasis role="italic">ArgCount</emphasis>
includes RXSTRINGs that represent omitted arguments. Omitted
arguments are empty RXSTRINGs (<emphasis role="italic">strptr</emphasis>
is null).</para></listitem></varlistentry>
<varlistentry><term>ArgList (PCONSTRXSTRING) - input</term>
<listitem><para>is an array of CONSTRXSTRING structures that are the Rexx program arguments.
</para></listitem></varlistentry>
<varlistentry><term>ProgramName (const char *) - input</term>
<listitem><para>is the address of the ASCII name of the Rexx procedure. If
<emphasis role="italic">Instore</emphasis> is null,
<emphasis role="italic">ProgramName</emphasis> must contain at least the file name of
the Rexx procedure. You can also provide an extension, drive, and path.
If you do not specify a file extension, the
default is .REX.  A Rexx program can use any extension. If you do not
provide the path and the drive, the Rexx interpreter uses the usual file search
order to locate the file.
</para>
<para>If <emphasis role="italic">Instore</emphasis> is not null,
<emphasis role="italic">ProgramName</emphasis> is the name used in the
PARSE SOURCE instruction. If <emphasis role="italic">Instore</emphasis>
requests a Rexx procedure from the macrospace,
<indexterm><primary>RexxStart</primary>
<secondary>using macrospace programs</secondary></indexterm>
<emphasis role="italic">ProgramName</emphasis> is the macrospace
function name (see <xref linkend="macrosp" />).</para>
</listitem></varlistentry>
<varlistentry><term>Instore (PRXSTRING) - input</term>
<listitem><para>is
an array of two RXSTRING descriptors for in-storage Rexx procedures. If the
<emphasis role="italic">strptr</emphasis> fields of both RXSTRINGs are null,
the interpreter searches for Rexx procedure
<emphasis role="italic">ProgramName</emphasis> in the Rexx macrospace (see
<xref linkend="macrosp" />).
If the procedure is not in the macrospace, the call to RexxStart terminates
with an error return code. </para>
<para>If either <emphasis role="italic">Instore strptr</emphasis> field
is not null, <emphasis role="italic">Instore</emphasis> is used to run a Rexx
procedure directly from storage.</para>
<variablelist>
<varlistentry><term>Instore[0]
<indexterm><primary>RexxStart</primary>
<secondary>using in-storage programs</secondary></indexterm>
</term>
<listitem><para>is an RXSTRING describing a memory buffer that contains the Rexx procedure
source. The source must be an exact image of a Rexx procedure disk file, complete
with carriage returns, line feeds, and end-of-file characters.
</para></listitem></varlistentry>
<varlistentry><term>Instore[1]</term>
<listitem><para>is an RXSTRING containing the translated image of the Rexx procedure.
If <emphasis role="italic">Instore[1]</emphasis> is empty, the Rexx interpreter returns the
translated image in <emphasis role="italic">Instore[1]</emphasis> when the Rexx procedure
finishes running. The translated image may be used in
<emphasis role="italic">Instore[1]</emphasis> on subsequent RexxStart calls.</para>
<para>If <emphasis role="italic">Instore[1]</emphasis> is
not empty, the interpreter runs the translated image directly. The program
source provided in <emphasis role="italic">Instore[0]</emphasis> is used only if the Rexx
procedure uses the SOURCELINE built-in function.
<emphasis role="italic">Instore[0]</emphasis> can be empty if SOURCELINE
is not used. If <emphasis role="italic">Instore[0]</emphasis> is empty
and the procedure uses the SOURCELINE built-in function, SOURCELINE()
returns no lines and any attempt to access the source returns Error 40.</para>
<para>If <emphasis role="italic">Instore[1]</emphasis> is not empty,
but does not contain a valid Rexx translated image, unpredictable results
can occur. The Rexx interpreter might be able to determine that the translated
image is incorrect and translate the source again.</para>
<para><emphasis role="italic">Instore[1]</emphasis> is both an input and
an output parameter.</para>
</listitem></varlistentry>
</variablelist>
<para>If the procedure is executed from disk, the
<emphasis role="italic">Instore pointer</emphasis> must be null.
If the first argument string in <emphasis role="italic">Arglist</emphasis>
is exactly the string "//T" and the <emphasis role="italic">CallType</emphasis>
is RXCOMMAND, the interpreter performs a syntax check on the procedure source,
but does not execute it and does not store any images.</para>
<para>The program calling
RexxStart must release <emphasis role="italic">Instore[1]</emphasis>
using <computeroutput>RexxFreeMemory(ptr)</computeroutput>
when the translated image is no longer needed.</para>
<para>Only the interpreter version that created the image can run the translated
image. Therefore, neither change the format of the translated image of a Rexx
program, nor move a translated image to other systems or save it for later
use. You can, however, use the translated image several times during a single
application execution.</para>
</listitem></varlistentry>
<varlistentry><term>EnvName (const char *) - input</term>
<listitem><para>is the address of the initial ADDRESS environment name. The ADDRESS
environment is a subcommand handler registered using RexxRegisterSubcomExe
or RexxRegisterSubcomDll. <emphasis role="italic">EnvName</emphasis> is used
as the initial setting for the Rexx ADDRESS instruction. </para>
<para>If <emphasis role="italic">EnvName</emphasis> is null, the file
extension is used as the initial ADDRESS environment. The environment name
cannot be longer than 250 characters.</para>
</listitem></varlistentry>
<varlistentry><term>CallType (int) - input</term>
<listitem><para>is the type of the Rexx procedure execution. Allowed execution types
are:
<variablelist>
<varlistentry><term>RXCOMMAND</term>
<listitem><para>The Rexx procedure is a system or application command. Rexx commands
usually have a single argument string. The Rexx PARSE SOURCE instruction
returns <computeroutput>COMMAND</computeroutput> as the second token.
</para></listitem></varlistentry>
<varlistentry><term>RXSUBROUTINE</term>
<listitem><para>The Rexx procedure is a subroutine of another program. The subroutine
can have several arguments and does not need to return a result. The Rexx
PARSE SOURCE instruction returns SUBROUTINE as the second token.
</para></listitem></varlistentry>
<varlistentry><term>RXFUNCTION</term>
<listitem><para>The Rexx procedure is a function called from another program. The subroutine
can have several arguments and must return a result. The Rexx PARSE SOURCE
instruction returns <computeroutput>FUNCTION</computeroutput> as the second
token.</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>Exits (PRXSYSEXIT) - input
<indexterm><primary>RexxStart</primary>
<secondary>using exits</secondary></indexterm>
</term>
<listitem><para>is an array of RXSYSEXIT structures defining exits for the Rexx interpreter
to be used. The RXSYSEXIT structures have the following form:</para>
<indexterm><primary>application programming interfaces</primary>
<secondary>RXSTRING data structure</secondary>
<tertiary>RXSYSEXIT</tertiary></indexterm>
<indexterm><primary>application programming interfaces</primary>
<secondary>RXSYSEXIT data structure</secondary></indexterm>
<indexterm><primary>RXSYSEXIT data structure</primary></indexterm>
<example>
<title>RXSYSEXIT</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   const char *    sysexit_name;  /* name of exit handler        */
   int             sysexit_code;  /* system exit function code   */
} RXSYSEXIT;
]]>
</programlisting>
</example>
<para>The <emphasis role="italic">sysexit_name</emphasis> is the address of an
ASCII exit handler name registered with RexxRegisterExitExe or
RexxRegisterExitDll. <emphasis role="italic">Sysexit_code</emphasis>
is a code identifying the handler exit type. See
<xref linkend="sysex" /> for exit code
definitions. An RXENDLST entry identifies the system-exit list end.
<emphasis role="italic">Exits</emphasis> must be null if exits are not used.</para>
</listitem></varlistentry>
<varlistentry><term>ReturnCode (short *) - output</term>
<listitem><para>is the integer form of the
<emphasis role="italic">Result</emphasis> string. If the
<emphasis role="italic">Result</emphasis> string is a whole number in the range
-(2**15) to 2**15-1, it is converted to an integer and also returned in
<emphasis role="italic">ReturnCode</emphasis>.
</para></listitem></varlistentry>
<varlistentry><term>Result (PRXSTRING) - output</term>
<listitem><para>is the string returned from the Rexx procedure with the Rexx
RETURN or EXIT instruction. A default RXSTRING can be provided for the returned
result. If a default RXSTRING is not provided or the default is too small
for the returned result, the Rexx interpreter allocates an RXSTRING using
<computeroutput>RexxAllocateMemory(size)</computeroutput>. The caller of RexxStart
is responsible for releasing the RXSTRING storage with
<computeroutput>RexxFreeMemory(ptr)</computeroutput>.</para>
<para>The Rexx interpreter
does not add a terminating null to <emphasis role="italic">Result</emphasis>.</para>
</listitem></varlistentry>
</variablelist>
</section>

<section id="rexxstartrc"><title>Return Codes</title>
<para>The possible RexxStart return codes are: </para>
<variablelist>
<varlistentry><term>negative</term>

<listitem><para>Interpreter errors. See the Appendix in the
<citetitle>Open Object Rexx: Reference</citetitle> for the list of Rexx errors.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No errors occurred. The Rexx procedure ran normally.
</para></listitem></varlistentry>
<varlistentry><term>positive</term>
<listitem><para>A system return code that indicates problems finding or loading
the interpreter.
</para></listitem></varlistentry>
</variablelist>
<para>When a macrospace Rexx procedure (see
<xref linkend="macrosp" />) is not loaded
in the macrospace, the return code is -3 (&quot;Program is unreadable&quot;).</para>
</section>

<section id="rexxstartxmp"><title>Example</title>
<indexterm><primary>RexxStart</primary>
<secondary>example using</secondary></indexterm>
<example>
<title>RexxStart</title>
<para>
  The following example for RexxStart should compile and execute on Linux. A few small changes as noted in the example, and
  it should compile and execute on Windows.  This is dependent on having the build environment set up correctly. Note that
  you need to provide a <computeroutput>test.rex</computeroutput> program for the executable to pass to the interpreter:
</para>
<programlisting language="C++">
<![CDATA[
/* rexxStartExample.c

  gcc -D_GNU_SOURCE -std=c99 -pedantic -ldl rexxStartExample.c -lrexx -lrexxapi -o rexxStartExample

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <rexx.h>

int main(int argc, char *argv[]) {
   int           return_code; /* interpreter return code */
   short         rc;          /* converted return code */

   CONSTRXSTRING argr[1];     /* rexx program argument string */
   RXSTRING      retstr;      /* rexx program return value */

   char          return_buffer[250]; /* returned buffer */
   char          rexx_argument[] = "theargument";

   /* build the argument string */
   MAKERXSTRING(argr[0], rexx_argument, strlen(rexx_argument));

   /* set up default return */
   MAKERXSTRING(retstr, return_buffer, sizeof(return_buffer));

   retstr.strptr[0] = 0;

   return_code = RexxStart(1,            // one argument
                           argr,         // here it is
                           "./test.rex", // name of program
                           NULL,         // use disk version
                           "bash",       // default address name
                           RXCOMMAND,    // called as a subcommand
                           NULL,         // no exits
                           &rc,          // where to put rc
                           &retstr);     // where to put returned string

   /* process return value */
   printf("rc %i\n", rc);
   if (retstr.strlength > 0) {
      printf("ret: %s\n", retstr.strptr);
   }

   /* need to return storage? */
   if (RXSTRPTR(retstr) !=  return_buffer) {
      RexxFreeMemory(RXSTRPTR(retstr)); /* release the RXSTRING */
   }
   return 0;
}

/*
  In the above code, change: "./test.rex" to: ".\test.rex" and
  change: "bash" to: "cmd".

  For the VC++ compiler, this command line should work:

  cl rexxStartExample.cpp rexx.lib rexxapi.lib

*/

]]>
</programlisting>
</example>
<para>When RexxStart is executed within an external program (usually
a C program), the main Rexx thread runs on the same thread as the RexxStart
invocation.  When the main thread terminates, the interpreter will wait until
all additional threads created from the main thread terminate before returning
control to the invoking program.</para>
</section>
</section>

<section id="rexxwaitfortermfu"><title>The RexxWaitForTermination Function (Deprecated)</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>invoking the Rexx interpreter</secondary>
<tertiary>RexxWaitForTermination</tertiary></indexterm>
<indexterm><primary>RexxWaitForTermination</primary></indexterm>
<para>RexxWaitForTermination is not supported in 4.0 and will return immediately
if called.  This is maintained for binary compatibility with previous releases.
</para>
</section>

<section id="rexxdidtexxtermfu"><title>The RexxDidRexxTerminate Function (Deprecated)</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>invoking the Rexx interpreter</secondary>
<tertiary>RexxDidRexxTerminate</tertiary></indexterm>
<indexterm><primary>RexxDidRexxTerminate</primary></indexterm>
<para>RexxDidRexxTerminate always returns 1 for 4.0.  This is maintained for
binary compatibility with early releases.
</para>
<programlisting language="C++">
retc = RexxDidRexxTerminate();
</programlisting>
</section>
</section>

<section id="subcom"><title>Subcommand Interface</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>subcommand interface</secondary></indexterm>
<indexterm><primary>subcommand interface</primary>
<secondary>description</secondary></indexterm>
<para>An application can create handlers to process commands from a Rexx program.
Once created, the subcommand handler name can be used with the RexxStart function
or the Rexx ADDRESS instruction. Subcommand handlers must be registered with
the RexxRegisterSubcomExe or RexxRegisterSubcomDll function before they are
used.</para>

<section id="subinv"><title>Registering Subcommand Handlers</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>handler definitions</secondary></indexterm>
<para>A subcommand handler can reside in the same module (executable or DLL)
as an application, or it can reside in a separate dynamic-link library.
It is recommended that an application that runs Rexx procedures
<indexterm><primary>subcommand interface</primary>
<secondary>registering</secondary></indexterm>
with RexxStart uses RexxRegisterSubcomExe to register subcommand handlers.
The Rexx interpreter passes commands to the application subcommand handler
entry point. Subcommand handlers created with RexxRegisterSubcomExe are available
only to Rexx programs called from the registering application.</para>
<para>The RexxRegisterSubcomDll interface creates subcommand handlers that reside
in a dynamic-link library. Any Rexx program using the
Rexx ADDRESS instruction can access a dynamic-link library
subcommand handler. A dynamic-link library subcommand
handler can also be registered directly from a Rexx program using the RXSUBCOM
command.</para>

<section id="createsubcomhandl"><title>Creating Subcommand Handlers</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>handler interface</secondary>
<tertiary>subcommand handler</tertiary></indexterm>
<indexterm><primary>subcommand interface</primary>
<secondary>definition</secondary></indexterm>
<para>  The following example is a sample subcommand handler definition. </para>
<example>
<title>Command handler</title>
<programlisting language="C++">
<![CDATA[
RexxReturnCode REXXENTRY command_handler(
  PCONSTRXSTRING Command,     /* Command string from Rexx            */
  unsigned short *Flags,      /* Returned Error/Failure flags        */
  PRXSTRING Retstr);          /* Returned RC string                  */
]]>
</programlisting>
</example>
<para>where:</para>
<variablelist>
<varlistentry><term>Command</term>
<listitem><para>is the command string created by Rexx. </para>
<para><emphasis role="italic">command</emphasis> is a null-terminated
RXSTRING containing the issued command.</para>
</listitem></varlistentry>
<varlistentry><term>Flags</term>
<listitem><para>is the subcommand completion status. The subcommand handler can indicate
success, error, or failure status. The subcommand handler can set
<emphasis role="italic">Flags</emphasis> to one of the following values:
<variablelist>
<varlistentry><term>RXSUBCOM_OK</term>
<listitem><para>The subcommand completed normally. No errors occurred during subcommand
processing and the Rexx procedure continues when the subcommand handler returns.
</para></listitem></varlistentry>
<varlistentry><term>RXSUBCOM_ERROR
<indexterm><primary>subcommand interface</primary>
<secondary>subcommand errors</secondary></indexterm>
</term>
<listitem><para>A subcommand error occurred. RXSUBCOM_ERROR indicates a subcommand
error occurred; for example, incorrect command options or syntax.</para>
<para>If the
subcommand handler sets <emphasis role="italic">Flags</emphasis> to
RXSUBCOM_ERROR, the Rexx interpreter
raises an ERROR condition if SIGNAL ON ERROR or CALL ON ERROR traps have been
created. If TRACE ERRORS has been issued, Rexx traces the command when the
subcommand handler returns.</para>
</listitem></varlistentry>
<varlistentry><term>RXSUBCOM_FAILURE
<indexterm><primary>subcommand interface</primary>
<secondary>subcommand failures</secondary></indexterm>
</term>
<listitem><para>A subcommand failure occurred. RXSUBCOM_FAILURE indicates that general
subcommand processing errors have occurred. For example, unknown commands
usually return RXSUBCOM_FAILURE. </para>
<para>If the subcommand handler sets <emphasis role="italic">Flags</emphasis>
to RXSUBCOM_FAILURE, the Rexx interpreter raises a FAILURE condition
if SIGNAL ON FAILURE or CALL ON FAILURE traps have been created. If TRACE
FAILURES has been issued, Rexx traces the command when the subcommand handler
returns.</para>
</listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>Retstr
<indexterm><primary>subcommand interface</primary>
<secondary>subcommand return code</secondary></indexterm>
</term>
<listitem><para>is the address of an RXSTRING for the return code. It is a
character string return code that is assigned to the Rexx special variable
RC when the subcommand handler returns to Rexx. The Rexx interpreter provides
a default 256-byte RXSTRING in <emphasis role="italic">Retstr</emphasis>.
A longer RXSTRING can be allocated with
<computeroutput>RexxAllocateMemory(size)</computeroutput> if the return string is
longer than the default RXSTRING. If the subcommand handler sets
<emphasis role="italic">Retstr</emphasis> to an empty RXSTRING (a null
<emphasis role="italic">strptr</emphasis>), Rexx assigns the string 0 to RC.
</para></listitem></varlistentry>
</variablelist>

<section id="subcomhandlxmp"><title>Example</title>
<indexterm><primary>subcommand interface</primary>
<secondary>subcommand handler example</secondary></indexterm>
<example>
<title>Subcommand handler</title>
<programlisting language="C++">
<![CDATA[
RexxReturnCode REXXENTRY Edit_Commands(
  PCONSTRXSTRING Command,     /* Command string passed from the caller    */
  unsigned short *Flags,      /* pointer too short for return of flags    */
  PRXSTRING Retstr)           /* pointer to RXSTRING for RC return        */
{
  int         command_id;                /* command to process         */
  int         rc;                        /* return code                */
  const char *scan_pointer;              /* current command scan       */
  const char *target;                    /* general editor target      */

  scan_pointer = Command->strptr;      /* point to the command       */
                                       /* resolve command            */
  command_id = resolve_command(&scan_pointer);

  switch (command_id) {                /* process based on command   */

    case   LOCATE:                     /* locate command             */

                                       /* validate rest of command   */
      if (rc = get_target(&scan_pointer, &target)) {
        *Flags = RXSUBCOM_ERROR;       /* raise an error condition   */
        break;                         /* return to Rexx             */
      }
      rc = locate(target);             /* locate target in the file  */
      *Flags = RXSUBCOM_OK;            /* not found is not an error  */
      break;                           /* finish up                  */

...

      default:                         /* unknown command            */
        rc = 1;                        /* return code for unknown    */
        *Flags = RXSUBCOM_FAILURE;     /* this is a command failure  */
        break;
  }

  sprintf(Retstr->strptr, "%d", rc);   /* format return code string  */
                                       /* and set the correct length */
  Retstr->strlength = strlen(Retstr->strptr);
  return 0;                            /* processing completed       */
}
]]>
</programlisting>
</example>
</section>
</section>
</section>

<section id="rxxfin"><title>Subcommand Interface Functions</title>
<para>The following sections explain the functions for registering and using
subcommand handlers.</para>

<section id="screg"><title>RexxRegisterSubcomDll</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>subcommand interface</secondary>
<tertiary>RexxRegisterSubcomDll</tertiary></indexterm>
<indexterm><primary>RexxRegisterSubcomDll</primary></indexterm>
<indexterm><primary>subcommand interface</primary>
<secondary>RexxRegisterSubcomDll</secondary></indexterm>
<para>RexxRegisterSubcomDll registers a subcommand handler that resides in
a dynamic-link library routine.</para>
<programlisting language="C++">
retc = RexxRegisterSubcomDll(EnvName, ModuleName, EntryPoint,
                             UserArea, DropAuth);
</programlisting>

<section id="rexxregistersubcomdllparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>EnvName (const char *) - input</term>
<listitem><para>is the address of an ASCII subcommand handler name.
</para></listitem></varlistentry>
<varlistentry><term>ModuleName (const char *) - input</term>
<listitem><para>is the address of an ASCII dynamic-link library
name. <emphasis role="italic">ModuleName</emphasis> is the DLL file containing
the subcommand handler routine.
</para></listitem></varlistentry>
<varlistentry><term>EntryPoint (const char *) - input</term>
<listitem><para>is the address of an ASCII dynamic-link library
procedure name. <emphasis role="italic">EntryPoint</emphasis> is the name of
the exported routine within <emphasis role="italic">ModuleName</emphasis>
that Rexx calls as a subcommand handler.
</para></listitem></varlistentry>
<varlistentry><term>UserArea (const char *) - input</term>
<listitem><para>is the address of an area of user-defined information.
The user-defined information is a buffer the size of two pointer values.
The
bytes <emphasis role="italic">UserArea</emphasis> buffer is saved with
the subcommand handler registration. <emphasis role="italic">UserArea</emphasis>
can be null if there is no user information to be saved. The
RexxQuerySubcom function can retrieve the saved user information.
</para></listitem></varlistentry>
<varlistentry><term>DropAuth (size_t) - input</term>
<listitem><para>is the drop authority.
<emphasis role="italic">DropAuth</emphasis> identifies the processes that
can deregister the subcommand handler. The possible
<emphasis role="italic">DropAuth</emphasis> values are:
<variablelist>
<varlistentry><term>RXSUBCOM_DROPPABLE</term>
<listitem><para>Any process can deregister the subcommand handler with RexxDeregisterSubcom.
</para></listitem></varlistentry>
<varlistentry><term>RXSUBCOM_NONDROP</term>
<listitem><para>Only a
<indexterm><primary>thread</primary></indexterm>
thread within the same process as the thread that registered
the handler can deregister the handler with RexxDeregisterSubcom.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="rxsubcomrc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXSUBCOM_OK</entry>
<entry>0</entry>
<entry>A subcommand has executed successfully.</entry>
</row>
<row>
<entry>RXSUBCOM_DUP</entry>
<entry>10</entry>
<entry>A duplicate handler name has been successfully registered.
There is either an executable handler with the same name registered in another
process, or a DLL handler with the same name registered in another DLL. (To
address this subcommand, you must specify its library name.)</entry>
</row>
<row>
<entry>RXSUBCOM_NOTREG</entry>
<entry>30</entry>
<entry>Registration was unsuccessful due to duplicate handler
and module names (RexxRegisterSubcomExe or RexxRegisterSubcomDll); the subroutine
environment is not registered (other Rexx subcommand functions).</entry>
</row>
<row>
<entry>RXSUBCOM_NOEMEM</entry>
<entry>1002</entry>
<entry>There is insufficient memory available to complete this
request.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>

<section id="screg2"><title>RexxRegisterSubcomExe</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>subcommand interface</secondary>
<tertiary>RexxRegisterSubcomExe</tertiary></indexterm>
<indexterm><primary>RexxRegisterSubcomExe</primary></indexterm>
<indexterm><primary>subcommand interface</primary>
<secondary>RexxRegisterSubcomExe</secondary></indexterm>
<para>RexxRegisterSubcomExe registers a subcommand handler that resides within
the application code.</para>
<programlisting language="C++">
retc = RexxRegisterSubcomExe(EnvName, EntryPoint, UserArea);
</programlisting>

<section id="rxregsubcomparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>EnvName (const char *) - input</term>
<listitem><para>is the address of an ASCII subcommand handler name.
</para></listitem></varlistentry>
<varlistentry><term>EntryPoint (REXXPFN) - input</term>
<listitem><para>is the address of the subcommand handler entry point within the
application executable code.
</para></listitem></varlistentry>
<varlistentry><term>UserArea (const char *) - input</term>
<listitem><para>is the address of an area of user-defined information.
The user-defined information is a buffer the size of two pointer values.
The
bytes <emphasis role="italic">UserArea</emphasis> buffer is saved with
the subcommand handler registration. <emphasis role="italic">UserArea</emphasis>
can be null if there is no user information to be saved. The
RexxQuerySubcom function can retrieve the saved user information.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="rxsubcomregrc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXSUBCOM_OK</entry>
<entry>0</entry>
<entry>A subcommand has executed successfully.</entry>
</row>
<row>
<entry>RXSUBCOM_DUP</entry>
<entry>10</entry>
<entry>A duplicate handler name has been successfully registered.
 There is either an executable handler with the same name registered in another
process, or a DLL handler with the same name registered in another DLL. (To
address this subcommand, you must specify its library name.)</entry>
</row>
<row>
<entry>RXSUBCOM_NOTREG</entry>
<entry>30</entry>
<entry>Registration was unsuccessful due to duplicate handler
and library names (RexxRegisterSubcomExe or RexxRegisterSubcomDll); the subroutine
environment is not registered (other Rexx subcommand functions).</entry>
</row>
<row>
<entry>RXSUBCOM_NOEMEM</entry>
<entry>1002</entry>
<entry>There is insufficient memory available to complete this
request.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="rxsubcomregremark"><title>Remarks</title>
<para>If <emphasis role="italic">EnvName</emphasis>
is the same as a subcommand handler already registered
with RexxRegisterSubcomDll, RexxRegisterSubcomExe returns RXSUBCOM_DUP.
This is not an error condition. It means that RexxRegisterSubcomExe has successfully
registered the new subcommand handler.</para>
<para>A Rexx procedure can register dynamic-link library
subcommand handlers with the RXSUBCOM command. For example: </para>
<example>
<title>RXSUBCOM</title>
<programlisting>
<![CDATA[
                               /* register Dialog Manager       */
                               /* subcommand handler            */
"RXSUBCOM REGISTER ISPCIR ISPCIR ISPCIR"
Address ispcir                 /* send commands to dialog mgr   */
]]>
</programlisting>
</example>
<para>The RXSUBCOM command registers the Dialog Manager subcommand handler ISPCIR
as routine ISPCIR in the ISPCIR dynamic-link library.</para>
</section>

<section id="rxsubcomregxmp"><title>Example</title>
<indexterm><primary>RexxStart</primary>
<secondary>exit example</secondary></indexterm>
<example>
<title>RexxStart</title>
<programlisting language="C++">
<![CDATA[
const char  *user_info[2];       /* saved user information     */

user_info[0] = global_workarea;      /* save global work area for  */
user_info[1] = NULL;                 /* re-entrance                */

rc = RexxRegisterSubcomExe("Editor", /* register editor handler    */
    &Edit_Commands,                  /* located at this address    */
    user_info);                      /* save global pointer        */

]]>
</programlisting>
</example>
</section>
</section>

<section id="scdrp"><title>RexxDeregisterSubcom</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>subcommand interface</secondary>
<tertiary>RexxDeregisterSubcom</tertiary></indexterm>
<indexterm><primary>RexxDeregisterSubcom</primary></indexterm>
<indexterm><primary>subcommand interface</primary>
<secondary>RexxDeregisterSubcom</secondary></indexterm>
<para>RexxDeregisterSubcom deregisters a subcommand handler.</para>
<programlisting language="C++">
retc = RexxDeregisterSubcom(EnvName, ModuleName);
</programlisting>

<section id="rxderegsubcomparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>EnvName (const char *) - input</term>
<listitem><para>is the address of an ASCII subcommand handler name.
</para></listitem></varlistentry>
<varlistentry><term>ModuleName (const char *) - input</term>
<listitem><para>is the address of an ASCII dynamic-link library
name. <emphasis role="italic">ModuleName</emphasis>
is the name of the dynamic-link library containing the registered
subcommand handler. When <emphasis role="italic">ModuleName</emphasis>
is null, RexxDeregisterSubcom searches the RexxRegisterSubcomExe subcommand
handler list for a handler within the current process. If RexxDeregisterSubcom
does not find a RexxRegisterSubcomExe handler, it searches the RexxRegisterSubcomDll
subcommand handler list.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="rxderegsubcomrc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXSUBCOM_OK</entry>
<entry>0</entry>
<entry>A subcommand has executed successfully.</entry>
</row>
<row>
<entry>RXSUBCOM_NOTREG</entry>
<entry>30</entry>
<entry>Registration was unsuccessful due to duplicate handler
and dynalink names (RexxRegisterSubcomExe or RexxRegisterSubcomDll); the subroutine
environment is not registered (other Rexx subcommand functions).</entry>
</row>
<row>
<entry>RXSUBCOM_NOCANDROP</entry>
<entry>40</entry>
<entry>The subcommand handler has been registered as &quot;not
droppable.&quot;</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="rxderegsubcomremark"><title>Remarks</title>
<para>The handler is removed from the active subcommand handler list.</para>
</section>
</section>

<section id="scqry"><title>RexxQuerySubcom</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>subcommand interface</secondary>
<tertiary>RexxQuerySubcom</tertiary></indexterm>
<indexterm><primary>RexxQuerySubcom</primary></indexterm>
<indexterm><primary>subcommand interface</primary>
<secondary>RexxQuerySubcom</secondary></indexterm>
<para>RexxQuerySubcom
queries a subcommand handler and retrieves saved user information.</para>
<programlisting language="C++">
retc = RexxQuerySubcom(EnvName, ModuleName, Flag, UserWord);
</programlisting>

<section id="rxquerysubcomparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>EnvName (const char *) - input</term>
<listitem><para>is the address of an ASCII subcommand handler name.
</para></listitem></varlistentry>
<varlistentry><term>ModuleName (const char *) - input</term>
<listitem><para>is the address of an ASCII dynamic-link library
name. <emphasis role="italic">ModuleName</emphasis> restricts the query to a
subcommand handler within
the <emphasis role="italic">ModuleName</emphasis> dynamic-link library. When
<emphasis role="italic">ModuleName</emphasis> is null, RexxQuerySubcom
searches the RexxRegisterSubcomExe
subcommand handler list for a handler within the current process. If RexxQuerySubcom
does not find a RexxRegisterSubcomExe handler, it searches the RexxRegisterSubcomDll
subcommand handler list.
</para></listitem></varlistentry>
<varlistentry><term>Flag (unsigned short *) - output</term>
<listitem><para>is the subcommand handler registration flag.
<emphasis role="italic">Flag</emphasis> is the
<emphasis role="italic">EnvName</emphasis> subcommand handler registration
status. When RexxQuerySubcom
returns RXSUBCOM_OK, the <emphasis role="italic">EnvName</emphasis>
subcommand handler is currently
registered. When RexxQuerySubcom returns RXSUBCOM_NOTREG, the
<emphasis role="italic">EnvName</emphasis> subcommand handler is not registered.
</para></listitem></varlistentry>
<varlistentry><term>UserWord (char *) - output</term>
<listitem><para>is the address of an area that receives the user information
saved with RexxRegisterSubcomExe or RexxRegisterSubcomDll.  The userarea must
be large enough to store two pointer values.
<emphasis role="italic">UserWord</emphasis> can
be null if the saved user information is not required.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="rxquerysubcomrc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXSUBCOM_OK</entry>
<entry>0</entry>
<entry>A subcommand has executed successfully.</entry>
</row>
<row>
<entry>RXSUBCOM_NOTREG</entry>
<entry>30</entry>
<entry>Registration was unsuccessful due to duplicate handler
and dynalink names (RexxRegisterSubcomExe or RexxRegisterSubcomDll); the subroutine
environment is not registered (other Rexx subcommand functions).</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="rxquerysubcomxmp"><title>Example</title>
<example>
<title>Command handlers</title>
<programlisting language="C++">
<![CDATA[
RexxReturnCode REXXENTRY Edit_Commands(
  PCONSTRXSTRING  Command,    /* Command string passed from the caller    */
  unsigned short *Flags,      /* pointer too short for return of flags    */
  PRXSTRING       Retstr)     /* pointer to RXSTRING for RC return        */
{
  char            *user_info[2];       /* saved user information     */
  char            *global_workarea;    /* application data anchor    */
  unsigned short   query_flag;         /* flag for handler query     */


  rc = RexxQuerySubcom("Editor",       /* retrieve application work  */
      NULL,                            /* area anchor from Rexx      */
      &query_flag,
      user_info);

  global_workarea = user_info[0];      /* set the global anchor      */
]]>
</programlisting>
</example>
</section>
</section>
</section>
</section>

<section id="os2xfun"><title>External Function Interface</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>external function interface</secondary></indexterm>
<indexterm><primary>external function interface</primary>
<secondary>description</secondary></indexterm>
<para>There are two types of Rexx external functions: </para>
<itemizedlist>
<listitem><para>Routines written in Rexx</para></listitem>
<listitem><para>Routines written in other platform-supported native code (compiled) languages
</para></listitem></itemizedlist>
<para>External functions written in Rexx do not need to be registered. These
functions are found by a disk search for a Rexx procedure file that matches
the function name.</para>
<para>There are two styles of native code routines supported by Open Object Rexx.
Registered External Functions are an older style of routine that is only capable
of dealing with String data.  These routines do not have access to any of the
object-oriented features of the language.  The registered external functions
are described here, but should be considered only if compatibility with older
versions of Open Object Rexx or other Rexx interpreters is a consideration.</para>
<para>The newer style functions have access to Rexx objects and a fuller set of
APIs for interfacing with the interpreter runtime.  These functions are the
preferred method for writing Open Object Rexx extensions are defined in
<xref linkend="buildinglibs" />.
</para>
<section id="xffmt"><title>Registering External Functions</title>
<para>An external function can reside in the same module (executable
or library)
as an application, or in a separate loadable library.
RexxRegisterFunctionExe registers external functions within an application
module. External functions registered with RexxRegisterFunctionExe are available
only to Rexx programs called from the registering application.</para>
<para>The RexxRegisterFunctionDll interface registers external functions that
reside in a dynamic-link library. Any Rexx program can
access such an external function after it is registered. It can also be registered
directly from a Rexx program using the Rexx RXFUNCADD built-in function.</para>

<section id="xffmtc"><title>Creating External Functions</title>
<indexterm><primary>external function interface</primary>
<secondary>writing</secondary></indexterm>
<para>The following is a sample external function definition:</para>
<example>
<title>External functions</title>
<programlisting language="C++">
<![CDATA[
size_t REXXENTRY SysLoadFuncs(
     const char *Name,                   /* name of the function       */
     size_t      Argc,                   /* number of arguments        */
     CONSTRXSTRING  Argv[],              /* list of argument strings   */
     const char *Queuename,              /* current queue name         */
     PRXSTRING   Retstr)                 /* returned result string     */
]]>
</programlisting>
</example>
<para>where:</para>
<variablelist>
<varlistentry><term>Name</term>
<listitem><para>is the address of an ASCII function name used to call the
external function.
</para></listitem></varlistentry>
<varlistentry><term>Argc</term>
<listitem><para>is the number of elements in the
<emphasis role="italic">Argv</emphasis> array.
<emphasis role="italic">Argv</emphasis> contains
<emphasis role="italic">Argc</emphasis> RXSTRINGs.
</para></listitem></varlistentry>
<varlistentry><term>Argv</term>
<listitem><para>is an array of null-terminated CONSTRXSTRINGs for the function arguments.
</para></listitem></varlistentry>
<varlistentry><term>Queuename</term>
<listitem><para>is the name of the currently defined external Rexx data queue.
</para></listitem></varlistentry>
<varlistentry><term>Retstr</term>
<listitem><para>is the address of an RXSTRING for the returned value.
<emphasis role="italic">Retstr</emphasis> is
a character string function or subroutine return value. When a Rexx program
calls an external function with the Rexx CALL instruction,
<emphasis role="italic">Retstr</emphasis> is
assigned to the special Rexx variable RESULT. When the Rexx program calls
an external function with a function call,
<emphasis role="italic">Retstr</emphasis> is used directly
within the Rexx expression.</para>
<para>The Rexx interpreter provides a default 256-byte
RXSTRING in <emphasis role="italic">Retstr</emphasis>. A longer RXSTRING
can be allocated with <computeroutput>RexxAllocateMemory(size)</computeroutput>
if the returned string is longer than 256 bytes.
The Rexx interpreter releases <emphasis role="italic">Retstr</emphasis> with
<computeroutput>RexxFreeMemory(ptr)</computeroutput> when
the external function completes.</para>
</listitem></varlistentry>
<varlistentry><term>Returns
<indexterm><primary>external function interface</primary>
<secondary>returned results</secondary></indexterm>
</term>
<listitem><para>is an integer return code from the function. When the external function
returns <computeroutput>0</computeroutput>, the function completed successfully.
<emphasis role="italic">Retstr</emphasis> contains
the return value. When the external function returns a nonzero return code,
the Rexx interpreter raises Rexx error 40, &quot;Incorrect call to routine&quot;.
The <emphasis role="italic">Retstr</emphasis> value is ignored. </para>
<para>If the external function does not
have a return value, the function must set
<emphasis role="italic">Retstr</emphasis> to an empty RXSTRING
(null <emphasis role="italic">strptr</emphasis>). When an external function
called as a function does not return a value, the interpreter raises error 44,
&quot;Function or message did not return data&quot;. When an external function
called with the Rexx CALL instruction does not return a value, the Rexx
interpreter drops (unassigns) the special variable RESULT.</para>
</listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="xfclg"><title>Calling External Functions</title>
<para>RexxRegisterFunctionExe external functions are local to the registering
process. Another process can call the RexxRegisterFunctionExe to make these
functions local to this process. RexxRegisterFunctionDll functions, however,
are available to all processes. The function names cannot be duplicated.</para>

<section id="callextfuxmp"><title>Example</title>
<indexterm><primary>external function interface</primary>
<secondary>simple function</secondary></indexterm>
<example>
<title>External functions</title>
<programlisting language="C++">
<![CDATA[
size_t REXXENTRY SysMkDir(
     const char *Name,                 /* name of the function       */
     size_t      Argc,                 /* number of arguments        */
     CONSTRXSTRING  Argv[],            /* list of argument strings   */
     const char *Queuename,            /* current queue name         */
     PRXSTRING   Retstr)               /* returned result string     */
{
  ULONG  rc;                           /* Return code of function    */

  if (Argc != 1)                       /* must be 1 argument         */
    return 40;                         /* incorrect call if not      */

                                       /* make the directory         */
  rc = !CreateDirectory(Argv[0].strptr, NULL);

  sprintf(Retstr->strptr, "%d", rc);   /* result: <> 0 failed        */
                                       /* set proper string length   */
  Retstr->strlength = strlen(Retstr->strptr);
  return 0;                            /* successful completion      */
}
]]>
</programlisting>
</example>
</section>
</section>

<section id="xfapis"><title>External Function Interface Functions</title>
<indexterm><primary>external function interface</primary>
<secondary>interface functions</secondary></indexterm>
<para>The following sections explain the functions for registering and using
external functions.</para>

<section id="xfreg"><title>RexxRegisterFunctionDll</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>external function interface</secondary>
<tertiary>RexxRegisterFunctionDll</tertiary></indexterm>
<indexterm><primary>external function interface</primary>
<secondary>RexxRegisterFunctionDll</secondary></indexterm>
<indexterm><primary>RexxRegisterFunctionDll</primary></indexterm>
<para>RexxRegisterFunctionDll registers an external function that resides in
a dynamic-link library routine.</para>
<programlisting language="C++">
retc = RexxRegisterFunctionDll(FuncName, ModuleName, EntryPoint);
</programlisting>

<section id="regfudllparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>FuncName (const char *) - input</term>
<listitem><para>is the address of an external function name. The function name
must not exceed 1024 characters.
</para></listitem></varlistentry>
<varlistentry><term>ModuleName (const char *) - input</term>
<listitem><para>is the address of an ASCII library
name. <emphasis role="italic">ModuleName</emphasis> is the library file containing
the external function routine.
</para></listitem></varlistentry>
<varlistentry><term>EntryPoint (const char *) - input</term>
<listitem><para>is the address of an ASCII dynamic-link procedure
name. <emphasis role="italic">EntryPoint</emphasis> is the name of the exported
external function routine within <emphasis role="italic">ModuleName</emphasis>.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="regfudllrc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXFUNC_OK</entry>
<entry> 0</entry>
<entry>The call to the function completed successfully.</entry>
</row>
<row>
<entry>RXFUNC_NOEMEM</entry>
<entry>1002</entry>
<entry>Memory allocation failure, or related.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="regfudllremark"><title>Remarks</title>
<para>Starting with ooRexx 5.0.0, on Windows, External functions that
reside in a dynamic-link library routine no longer require a
module-definition (.DEF) file that lists the external functions in
the EXPORT section.
</para>
<para>A Rexx procedure can register dynamic-link library-external
functions with the RXFUNCADD built-in function. For example: </para>
<example>
<title>RXFUNCADD</title>
<programlisting>
<![CDATA[
                               /* register function SysLoadFuncs  */
                               /* in dynamic link library RexxUTIL*/
Call RxFuncAdd "SysLoadFuncs", "RexxUTIL", "SysLoadFuncs"
Call SysLoadFuncs              /* call to load other functions    */
]]>
</programlisting>
</example>
<para>RXFUNCADD registers the external function SysLoadFuncs as routine
SysLoadFuncs in the rexxutil library. SysLoadFuncs registers
additional functions in rexxutil with RexxRegisterFunctionDll. See the
SysLoadFuncs routine below for a function registration example.</para>
</section>

<section id="regfudllxmp"><title>Example</title>
<example>
<title>External functions</title>
<programlisting language="C++">
<![CDATA[
static const char *RxFncTable[] =      /* function package list      */
{
      "SysCls",
      "SysCurpos",
      "SysCurState",
      "SysDriveInfo",
}


size_t REXXENTRY SysLoadFuncs(
     const char *Name,                   /* name of the function       */
     size_t      Argc,                   /* number of arguments        */
     CONSTRXSTRING  Argv[],              /* list of argument strings   */
     const char *Queuename,              /* current queue name         */
     PRXSTRING   Retstr)                 /* returned result string     */
{
  INT    entries;                      /* Number of entries          */
  INT    j;                            /* counter                    */

  Retstr->strlength = 0;               /* set null string return     */

  if (Argc > 0)                        /* check arguments            */
    return 40;                         /* too many, raise an error   */

                                       /* get count of arguments     */
  entries = sizeof(RxFncTable)/sizeof(const char *);
                                       /* register each function in  */
  for (j = 0; j < entries; j++) {      /* the table                  */
    RexxRegisterFunctionDll(RxFncTable[j],
          "RexxUTIL", RxFncTable[j]);
  }
  return 0;                            /* successful completion      */
}
]]>
</programlisting>
</example>
</section>
</section>

<section id="xfreg2"><title>RexxRegisterFunctionExe</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>external function interface</secondary>
<tertiary>RexxRegisterFunctionExe</tertiary></indexterm>
<indexterm><primary>external function interface</primary>
<secondary>RexxRegisterFunctionExe</secondary></indexterm>
<indexterm><primary>external function interface</primary>
<secondary>simple registration</secondary></indexterm>
<indexterm><primary>RexxRegisterFunctionExe</primary></indexterm>
<para>RexxRegisterFunctionExe registers an external function that resides within
the application code.</para>
<programlisting language="C++">
retc = RexxRegisterFunctionExe(FuncName, EntryPoint);
</programlisting>

<section id="regfuexeparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>FuncName (const char *) - input</term>
<listitem><para>is the address of an external function name. The function name must
not exceed 1024 characters.
</para></listitem></varlistentry>
<varlistentry><term>EntryPoint (REXXPFN) - input</term>
<listitem><para>is the address of the external function entry point within the executable
application file. Functions registered with RexxRegisterFunctionExe are
local to the current process. Rexx procedures in the same
process as the RexxRegisterFunctionExe issuer can call local external functions.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="regfuexerc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXFUNC_OK</entry>
<entry> 0</entry>
<entry>The call to the function completed successfully.</entry>
</row>
<row>
<entry>RXFUNC_DEFINED</entry>
<entry>10</entry>
<entry>The requested function is already registered.</entry>
</row>
<row>
<entry>RXFUNC_NOMEM</entry>
<entry>20</entry>
<entry>There is not enough memory to register a new function.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>

<section id="xfdrg"><title>RexxDeregisterFunction</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>external function interface</secondary>
<tertiary>RexxDeregisterFunction</tertiary></indexterm>
<indexterm><primary>external function interface</primary>
<secondary>RexxDeregisterFunction</secondary></indexterm>
<indexterm><primary>RexxDeregisterFunction</primary></indexterm>
<para>RexxDeregisterFunction deregisters an external function.</para>
<programlisting language="C++">
retc = RexxDeregisterFunction(FuncName);
</programlisting>

<section id="deregfuparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>FuncName (const char *) - input</term>
<listitem><para>is the address of an external function name to be deregistered.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="deregfurc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXFUNC_DEFINED</entry>
<entry>10</entry>
<entry>The requested function is already registered.</entry>
</row>
<row>
<entry>RXFUNC_NOTREG</entry>
<entry>30</entry>
<entry>The requested function is not registered.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>

<section id="xfqry"><title>RexxQueryFunction</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>external function interface</secondary>
<tertiary>RexxQueryFunction</tertiary></indexterm>
<indexterm><primary>external function interface</primary>
<secondary>RexxQueryFunction</secondary></indexterm>
<indexterm><primary>RexxQueryFunction</primary></indexterm>
<para>RexxQueryFunction queries the existence of a registered external function.</para>
<programlisting language="C++">
retc = RexxQueryFunction(FuncName);
</programlisting>

<section id="queryfuparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>FuncName (const char *) - input</term>
<listitem><para>is the address of an external function name to be queried.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="queryfurc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXFUNC_OK</entry>
<entry> 0</entry>
<entry>The call to the function completed successfully.</entry>
</row>
<row>
<entry>RXFUNC_NOTREG</entry>
<entry>30</entry>
<entry>The requested function is not registered.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="queryfuremark"><title>Remarks</title>
<para>RexxQueryFunction returns RXFUNC_OK only if the requested function is
available to the current process. If not, the RexxQueryFunction searches the
external RexxRegisterFunctionDll function list.</para>
</section>
</section>
</section>
</section>

<section id="sysex"><title>Registered System Exit Interface</title>
<indexterm><primary>exits</primary></indexterm>
<indexterm><primary>application programming interfaces</primary>
<secondary>exit interface</secondary></indexterm>
<indexterm><primary>application programming interfaces</primary>
<secondary>exit handler</secondary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>description</secondary></indexterm>
<para>The Rexx system exits let the programmer create a customized Rexx operating
environment. You can set up user-defined exit handlers to process specific
Rexx activities.</para>
<para>Applications can create exits for: </para>
<itemizedlist>
<listitem><para>The administration of resources at the beginning and the end
of interpretation</para></listitem>
<listitem><para>Linkages to external functions and subcommand handlers</para></listitem>
<listitem><para>Special language features; for example, input and output to
standard resources</para></listitem>
<listitem><para>Polling for halt and external trace events</para></listitem>
</itemizedlist>
<para>Exit handlers are similar to subcommand handlers and external functions.
Applications must register named exit handlers with the Rexx interpreter.
Exit handlers can reside in dynamic-link libraries or
within an executable application module.
</para>

<section id="writesysexithandl"><title>Writing System Exit Handlers</title>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>definition</secondary></indexterm>
<para>The following is a sample exit handler
definition: </para>
<example>
<title>Rexx_IO_exit</title>
<programlisting language="C++">
<![CDATA[
int REXXENTRY Rexx_IO_exit(
     int   ExitNumber,    /* code defining the exit function    */
     int   Subfunction,   /* code defining the exit subfunction */
     PEXIT ParmBlock);    /* function-dependent control block   */
]]>
</programlisting>
</example>
<para>where:</para>
<variablelist>
<varlistentry><term>ExitNumber</term>
<listitem><para>is the major function code defining the type of exit call.
</para></listitem></varlistentry>
<varlistentry><term>Subfunction</term>
<listitem><para>is the subfunction code defining the exit event for the call.
</para></listitem></varlistentry>
<varlistentry><term>ParmBlock</term>
<listitem><para>is a pointer to the exit parameter list. </para>
<para>The exit parameter list
contains exit-specific information. See the exit descriptions following the
parameter list formats. </para>

<note>
<para>Some exit subfunctions do not have
parameters. <emphasis role="italic">ParmBlock</emphasis> is set to null for exit subfunctions without
parameters.</para></note>
</listitem></varlistentry>
</variablelist>

<section id="exitrc"><title>Exit Return Codes</title>
<para>Exit handlers return an integer value that signals one of the following
actions: </para>
<variablelist>
<varlistentry><term>RXEXIT_HANDLED</term>
<listitem><para>The exit handler processed the exit subfunction and updated the subfunction
parameter list as required. The Rexx interpreter continues with processing
as usual.
</para></listitem></varlistentry>
<varlistentry><term>RXEXIT_NOT_HANDLED</term>
<listitem><para>The exit handler did not process the exit subfunction. The Rexx interpreter
processes the subfunction as if the exit handler were not called.
</para></listitem></varlistentry>
<varlistentry><term>RXEXIT_RAISE_ERROR</term>
<listitem><para>A fatal error occurred in the exit handler. The Rexx interpreter raises
Rexx error 48 (&quot;Failure in system service&quot;).
</para></listitem></varlistentry>
</variablelist>
<para>For example, if an application creates an input/output exit handler, one
of the following happens: </para>
<itemizedlist>
<listitem><para>When the exit handler returns RXEXIT_NOT_HANDLED for an RXSIOSAY
subfunction, the Rexx interpreter writes the output line to STDOUT.</para></listitem>
<listitem><para>When the exit handler returns RXEXIT_HANDLED for an RXSIOSAY subfunction,
the Rexx interpreter assumes the exit handler has handled all required output.
The interpreter does not write the output line to STDOUT.</para></listitem>
<listitem><para>When the exit handler returns RXEXIT_RAISE_ERROR for an RXSIOSAY
subfunction, the interpreter raises Rexx error 48, &quot;Failure in system
service&quot;.</para></listitem>
</itemizedlist>
</section>

<section id="exitparm"><title>Exit Parameters</title>
<para>Each exit subfunction has a different parameter list. All RXSTRING exit
subfunction parameters are passed as null-terminated RXSTRINGs. The RXSTRING
value can also contain null characters.</para>
<para>For some exit subfunctions, the exit handler can return an RXSTRING
character result in the parameter list. The interpreter provides a default 256-byte
RXSTRING for the result string. If the result is longer than 256 bytes,
a new RXSTRING can be allocated using
<computeroutput>RexxAllocateMemory(size)</computeroutput>. The Rexx interpreter
returns the RXSTRING storage for the exit handler.</para>
</section>

<section id="identifyexithandl"><title>Identifying Exit Handlers to Rexx</title>
<para>System exit handlers must be registered with RexxRegisterExitDll or
RexxRegisterExitExe. The system exit handler registration is similar to the
subcommand handler registration.</para>
<para> The Rexx system exits are enabled with the
RexxStart function parameter <emphasis role="italic">Exits</emphasis>.
<emphasis role="italic">Exits</emphasis> is a pointer to
an array of RXSYSEXIT structures. Each RXSYSEXIT structure in the array contains
a Rexx exit code and the address of an ASCII exit handler name. The RXENDLST
exit code marks the exit list end.</para>
<indexterm><primary>application programming interfaces</primary>
<secondary>RXSTRING data structure</secondary>
<tertiary>RXSYSEXIT</tertiary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXSYSEXIT data structure</secondary></indexterm>
<example>
<title>RXSYSEXIT</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   const char *    sysexit_name;       /* name of exit handler        */
   int             sysexit_code;       /* system exit function code   */
} RXSYSEXIT;
]]>
</programlisting>
</example>
<para>The Rexx interpreter calls the registered exit handler named in
<emphasis role="italic">sysexit_name</emphasis> for all of the
<emphasis role="italic">sysexit_code</emphasis> subfunctions.</para>

<section id="identifyexithandlxmp"><title>Example</title>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>sample exit</secondary></indexterm>
<example>
<title>RXSYSEXIT</title>
<programlisting language="C++">
<![CDATA[
...
{
const char *user_info[2];              /* saved user information     */
RXSYSEXIT   exit_list[2];              /* system exit list           */

  user_info[0] = global_workarea;      /* save global work area for  */
  user_info[1] = NULL;                 /* re-entrance                */

  rc = RexxRegisterExitExe("EditInit", /* register exit handler      */
      &Init_exit,                      /* located at this address    */
      user_info);                      /* save global pointer        */

                                       /* set up for RXINI exit      */
  exit_list[0].sysexit_name = "EditInit";
  exit_list[0].sysexit_code = RXINI;
  exit_list[1].sysexit_code = RXENDLST;

  return_code = RexxStart(1,           /* one argument               */
                          argv,        /* argument array             */
                          "CHANGE.ED", /* Rexx procedure name        */
                          NULL,        /* use disk version           */
                          "Editor",    /* default address name       */
                          RXCOMMAND,   /* calling as a subcommand    */
                          exit_list,   /* exit list                  */
                          &rc,         /* converted return code      */
                          &retstr);    /* returned result            */

                                       /* process return value       */
...
}

int REXXENTRY Init_exit(
     int   ExitNumber,    /* code defining the exit function    */
     int   Subfunction,   /* code defining the exit subfunction */
     PEXIT ParmBlock)     /* function dependent control block   */
{
  char            *user_info[2];       /* saved user information     */
  char            *global_workarea;    /* application data anchor    */
  unsigned short   query_flag;         /* flag for handler query     */

]]>
</programlisting>
<programlisting language="C++">
<![CDATA[
  rc = RexxQueryExit("EditInit",       /* retrieve application work  */
      NULL,                            /* area anchor from Rexx      */
      &query_flag,
      user_info);

  global_workarea = user_info[0];      /* set the global anchor      */

  if (global_workarea->rexx_trace)     /* trace at start?            */
                                       /* turn on macro tracing      */
    RexxSetTrace(global_workarea->rexx_pid, global_workarea->rexx_tid);
  return RXEXIT_HANDLED;               /* successfully handled       */
}
]]>
</programlisting>
</example>
</section>
</section>
</section>

<section id="sysexitdef"><title>System Exit Definitions</title>
<para>The Rexx interpreter supports the following system exits: </para>
<variablelist>
<varlistentry><term>RXFNC
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXFNC exit</secondary></indexterm>
</term>
<listitem><para>External function call exit.
<variablelist>
<varlistentry><term>RXFNCCAL</term>
<listitem><para>Call an external function.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXCMD
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXCMD exit</secondary></indexterm>
</term>
<listitem><para>Subcommand call exit.
<variablelist>
<varlistentry><term>RXCMDHST</term>
<listitem><para>Call a subcommand handler.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXMSQ
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXMSQ exit</secondary></indexterm>
</term>
<listitem><para>External data queue exit.
<variablelist>
<varlistentry><term>RXMSQPLL</term>
<listitem><para>Pull a line from the external data queue.
</para></listitem></varlistentry>
<varlistentry><term>RXMSQPSH</term>
<listitem><para>Place a line in the external data queue.
</para></listitem></varlistentry>
<varlistentry><term>RXMSQSIZ</term>
<listitem><para>Return the number of lines in the external data queue.
</para></listitem></varlistentry>
<varlistentry><term>RXMSQNAM</term>
<listitem><para>Set the active external data queue name.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXSIO
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXSIO exit</secondary></indexterm>
</term>
<listitem><para>Standard input and output exit.
<variablelist>
<varlistentry><term>RXSIOSAY</term>
<listitem><para>Write a line to the standard output stream for the SAY instruction.
</para></listitem></varlistentry>
<varlistentry><term>RXSIOTRC</term>
<listitem><para>Write a line to the standard error stream for the Rexx trace or Rexx
error messages.
</para></listitem></varlistentry>
<varlistentry><term>RXSIOTRD</term>
<listitem><para>Read a line from the standard input stream for PULL or PARSE PULL.
</para></listitem></varlistentry>
<varlistentry><term>RXSIODTR</term>
<listitem><para>Read a line from the standard input stream for interactive debugging.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXHLT
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXHLT exit</secondary></indexterm>
</term>
<listitem><para>Halt processing exit.
<variablelist>
<varlistentry><term>RXHLTTST</term>
<listitem><para>Test for a HALT condition.
</para></listitem></varlistentry>
<varlistentry><term>RXHLTCLR</term>
<listitem><para>Clear a HALT condition.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXTRC
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXTRC exit</secondary></indexterm>
</term>
<listitem><para>External trace exit.
<variablelist>
<varlistentry><term>RXTRCTST</term>
<listitem><para>Test for an external trace event.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXINI
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXINI exit</secondary></indexterm>
</term>
<listitem><para>Initialization exit.
<variablelist>
<varlistentry><term>RXINIEXT</term>
<listitem><para>Allow additional Rexx procedure initialization.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXTER
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXTER exit</secondary></indexterm>
</term>
<listitem><para>Termination exit.
<variablelist>
<varlistentry><term>RXTEREXT</term>
<listitem><para>Process Rexx procedure termination.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
<para>The following sections describe each exit subfunction, including: </para>
<itemizedlist>
<listitem><para>The service the subfunction provides</para></listitem>
<listitem><para>When Rexx calls the exit handler</para></listitem>
<listitem><para>The default action when the exit is not provided or the exit handler does
not process the subfunction</para></listitem>
<listitem><para>The exit action</para></listitem>
<listitem><para>The subfunction parameter list</para></listitem>
</itemizedlist>

<section id="rxfnch"><title>RXFNC</title>
<indexterm><primary>external function exit</primary></indexterm>
<indexterm><primary>RXFNC exit</primary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXFNC exit</secondary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>external function exit</secondary></indexterm>
<para>  Processes
calls to external functions. </para>

<para></para>
<variablelist>
<varlistentry><term>RXFNCCAL</term>
<listitem><para>Processes calls to external functions. </para>
<itemizedlist>
<listitem><para>When called: When Rexx calls an external subroutine
or function.</para></listitem>
<listitem><para>Default action: Call the external routine using
the usual external function search order.</para></listitem>
<listitem><para>Exit action: Call the external routine, if possible.</para></listitem>
<listitem><para>Continuation: If necessary, raise Rexx error 40
(&quot;Incorrect call to routine&quot;), 43 (&quot;Routine not found&quot;),
or 44 (&quot;Function or message did not return data&quot;).</para></listitem>
<listitem><para>Parameter list: </para>
<example>
<title>RXFUNC parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   struct {
      unsigned rxfferr  : 1;           /* Invalid call to routine.    */
      unsigned rxffnfnd : 1;           /* Function not found.         */
      unsigned rxffsub  : 1;           /* Called as a subroutine if   */
                                       /* TRUE.  Return values are    */
                                       /* optional for subroutines,   */
                                       /* required for functions.     */
   } rxfnc_flags ;

   const char *      rxfnc_name;       /* Pointer to function name.   */
   unsigned short    rxfnc_namel;      /* Length of function name.    */
   const char *      rxfnc_que;        /* Current queue name.         */
   unsigned short    rxfnc_quel;       /* Length of queue name.       */
   unsigned short    rxfnc_argc;       /* Number of args in list.     */
   PCONSTRXSTRING    rxfnc_argv;       /* Pointer to argument list.   */
                                       /* List mimics argv list for   */
                                       /* function calls, an array of */
                                       /* RXSTRINGs.                  */
   RXSTRING          rxfnc_retc;       /* Return value.               */
} RXFNCCAL_PARM;
]]>
</programlisting>
</example>
<para>The name of the external function is defined
by <emphasis role="italic">rxfnc_name</emphasis> and
<emphasis role="italic">rxfnc_namel</emphasis>. The arguments to the
function are in <emphasis role="italic">rxfnc_argc</emphasis> and
<emphasis role="italic">rxfnc_argv</emphasis>. If you
call the named external function with the Rexx CALL instruction (rather than
using a function call), the flag <emphasis role="italic">rxffsub</emphasis>
is TRUE.</para>
<para>The exit
handler can set <emphasis role="italic">rxfnc_flags</emphasis>
to indicate whether the external function
call was successful. If neither <emphasis role="italic">rxfferr</emphasis> nor
<emphasis role="italic">rxffnfnd</emphasis> is
TRUE, the exit handler successfully called the external function. The error
flags are checked only when the exit handler handles the request.</para>
<para>The exit handler sets <emphasis role="italic">rxffnfnd</emphasis>
to TRUE when the exit handler cannot locate
the external function. The interpreter raises Rexx error 43, &quot;Routine not
found&quot;. The exit handler sets <emphasis role="italic">rxfferr</emphasis>
to TRUE when the exit handler
locates the external function, but the external function returned an error
return code. The Rexx interpreter raises error 40,
&quot;Incorrect call to routine.&quot;</para>
<para>The exit handler returns the external function result in the
<emphasis role="italic">rxfnc_retc</emphasis> RXSTRING.
The Rexx interpreter raises error 44, &quot;Function
or method did not return data,&quot; when the external routine is called as
a function and the exit handler does not return a result. When the external
routine is called with the Rexx CALL instruction, a result is not
required.</para></listitem></itemizedlist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="rxcmdh"><title>RXCMD</title>
<indexterm><primary>external command exit</primary></indexterm>
<indexterm><primary>host command exit</primary></indexterm>
<indexterm><primary>RXCMD exit</primary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXCMD exit</secondary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>host command exit</secondary></indexterm>
<para>Processes calls to subcommand handlers. </para>
<para></para>
<variablelist>
<varlistentry><term>RXCMDHST</term>
<listitem><para>Calls a named subcommand handler.</para>
<itemizedlist>
<listitem><para>When called: When Rexx procedure issues a command.</para></listitem>
<listitem><para>Default action: Call the named subcommand handler
specified by the current Rexx ADDRESS setting.</para></listitem>
<listitem><para>Exit action: Process the call to a named subcommand
handler.</para></listitem>
<listitem><para>Continuation: Raise the ERROR or FAILURE condition
when indicated by the parameter list flags.</para></listitem>
<listitem><para>Parameter list: </para>
<example>
<title>RXCMD parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   struct {                            /* Condition flags             */
      unsigned rxfcfail : 1;           /* Command failed.  Trap with  */
                                       /* CALL or SIGNAL on FAILURE.  */
      unsigned rxfcerr  : 1;           /* Command ERROR occurred.     */
                                       /* Trap with CALL or SIGNAL on */
                                       /* ERROR.                      */
   } rxcmd_flags;
   const char *      rxcmd_address;    /* Pointer to address name.    */
   unsigned short    rxcmd_addressl;   /* Length of address name.     */
   const char *      rxcmd_dll;        /* dll name for command.       */
   unsigned short    rxcmd_dll_len;    /* Length of dll name.  0 ==>  */
                                       /* executable file.            */
   CONSTRXSTRING     rxcmd_command;    /* The command string.         */
   RXSTRING          rxcmd_retc;       /* Pointer to return code      */
                                       /* buffer.  User allocated.    */
} RXCMDHST_PARM;
]]>
</programlisting>
</example>
<para>The <emphasis role="italic">rxcmd_command</emphasis> field contains
the issued command. <emphasis role="italic">Rxcmd_address</emphasis>,
<emphasis role="italic">rxcmd_addressl</emphasis>,
<emphasis role="italic">rxcmd_dll</emphasis>, and
<emphasis role="italic">rxcmd_dll_len</emphasis> fully define the current
ADDRESS setting. <emphasis role="italic">Rxcmd_retc</emphasis> is an RXSTRING
for the return code value assigned to Rexx special variable RC.</para>
<para>The exit handler can set <emphasis role="italic">rxfcfail</emphasis>
or <emphasis role="italic">rxfcerr</emphasis>
to TRUE to raise an ERROR or FAILURE condition.</para></listitem>
</itemizedlist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="rxmsqh"><title>RXMSQ</title>
<indexterm><primary>external queue exit</primary></indexterm>
<indexterm><primary>queue exit</primary></indexterm>
<indexterm><primary>RXMSQ exit</primary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXMSQ exit</secondary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>queue exit</secondary></indexterm>
<para>External data queue exit. </para>
<variablelist>
<varlistentry><term>RXMSQPLL</term>
<listitem><para>Pulls a line from the external data queue. </para>
<itemizedlist>
<listitem><para>When called: When a Rexx PULL instruction, PARSE
PULL instruction, or LINEIN built-in function reads a line from the external
data queue.</para></listitem>
<listitem><para>Default action: Remove a line from the current Rexx
data queue.</para></listitem>
<listitem><para>Exit action: Return a line from the data queue that
the exit handler provided.</para></listitem>
<listitem><para>Parameter list: </para>
<example>
<title>RXMSQ parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   RXSTRING          rxmsq_retc;       /* Pointer to dequeued entry   */
                                       /* buffer.  User allocated.    */
} RXMSQPLL_PARM;
]]>
</programlisting>
</example>
<para>The exit handler returns the queue line in
the <emphasis role="italic">rxmsq_retc</emphasis> RXSTRING.</para>
</listitem></itemizedlist>
</listitem></varlistentry>
<varlistentry><term>RXMSQPSH</term>
<listitem><para>Places a line in the external data queue. </para>
<itemizedlist>
<listitem><para>When called: When a Rexx PUSH instruction, QUEUE
instruction, or LINEOUT built-in function adds a line to
the data queue.</para></listitem>
<listitem><para>Default action: Add the line to the current Rexx
data queue.</para></listitem>
<listitem><para>Exit action: Add the line to the data queue that
the exit handler provided.</para></listitem>
<listitem><para>Parameter list: </para>
<example>
<title>RXMSQ parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   struct {                            /* Operation flag              */
      unsigned rxfmlifo : 1;           /* Stack entry LIFO when TRUE, */
                                       /* FIFO when FALSE.            */
   } rxmsq_flags;
   CONSTRXSTRING     rxmsq_value;      /* The entry to be pushed.     */
} RXMSQPSH_PARM;
]]>
</programlisting>
</example>
<para>The <emphasis role="italic">rxmsq_value</emphasis> RXSTRING contains
the line added to the queue. It is the responsibility of the exit handler
to truncate the string if the exit handler data queue has a maximum length
restriction. <emphasis role="italic">Rxfmlifo</emphasis>
is the stacking order (LIFO or FIFO).</para></listitem></itemizedlist>
</listitem></varlistentry>
<varlistentry><term>RXMSQSIZ</term>
<listitem><para>Returns the number of lines in the external data queue.</para>
<itemizedlist>
<listitem><para>When called: When the Rexx QUEUED built-in function
requests the size of the external data queue.</para></listitem>
<listitem><para>Default action: Request the size of the current
Rexx data queue.</para></listitem>
<listitem><para>Exit action: Return the size of the data queue that
the exit handler provided.</para></listitem>
<listitem><para>Parameter list: </para>
<example>
<title>RXMSQ parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   size_t            rxmsq_size;       /* Number of Lines in Queue    */
} RXMSQSIZ_PARM;
]]>
</programlisting>
</example>
<para>The exit handler returns the number of queue
lines in <emphasis role="italic">rxmsq_size</emphasis>.</para>
</listitem></itemizedlist>
</listitem></varlistentry>
<varlistentry><term>RXMSQNAM</term>
<listitem><para>Sets the name of the active external data queue.
<itemizedlist>
<listitem><para>When called: Called by
the RXQUEUE("SET", <emphasis role="italic">newname</emphasis>)
 built-in function.</para></listitem>
<listitem><para>Default action: Change the current default queue
to <emphasis role="italic">newname</emphasis>.</para></listitem>
<listitem><para>Exit action: Change the default queue name for the
data queue that the exit handler provided.</para></listitem>
<listitem><para>Parameter list:</para>
<example>
<title>RXMSQ parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   CONSTRXSTRING     rxmsq_name;       /* RXSTRING containing         */
                                       /* queue name.                 */
} RXMSQNAM_PARM;
]]>
</programlisting>
</example>
<para><emphasis role="italic">rxmsq_name</emphasis> contains the new queue
name.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="rxsioh"><title>RXSIO</title>
<indexterm><primary>external I/O exit</primary></indexterm>
<indexterm><primary>session I/O exit</primary></indexterm>
<indexterm><primary>RXSIO exit</primary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXSIO exit</secondary></indexterm>
<para>Standard input and output. </para>
<note>
<para>The PARSE LINEIN instruction
and the LINEIN, LINEOUT, LINES, CHARIN, CHAROUT, and CHARS built-in functions
do not call the RXSIO exit handler.</para></note>
<para></para>
<variablelist>
<varlistentry><term>RXSIOSAY</term>
<listitem><para>Writes a line to the standard output stream. </para>
<itemizedlist>
<listitem><para>When called: When the SAY instruction writes a line
to the standard output stream.</para></listitem>
<listitem><para>Default action: Write a line to the standard output
stream (STDOUT).</para></listitem>
<listitem><para>Exit action: Write a line to the output stream that
the exit handler provided.</para></listitem>
<listitem><para>Parameter list:</para>
<example>
<title>RXSIO parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   CONSTRXSTRING      rxsio_string;     /* String to display.          */
} RXSIOSAY_PARM;
]]>
</programlisting>
</example>
<para>The output line is contained in
<emphasis role="italic">rxsio_string</emphasis>. The output line can be of any
length. It is the responsibility of the
exit handler to truncate or split the line if necessary.</para></listitem>
</itemizedlist>
</listitem></varlistentry>
<varlistentry><term>RXSIOTRC</term>
<listitem><para>Writes trace and error message output to the standard error
stream.
<itemizedlist>
<listitem><para>When called: To output lines of trace output and
Rexx error messages.</para></listitem>
<listitem><para>Default action: Write a line to the standard error
stream (.ERROR).</para></listitem>
<listitem><para>Exit action: Write a line to the error output stream
that the exit handler provided.</para></listitem>
<listitem><para>Parameter list:</para>
<example>
<title>RXSIO parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   CONSTRXSTRING       rxsio_string;     /* Trace line to display.      */
} RXSIOTRC_PARM;
]]>
</programlisting>
</example>
<para>The output line is contained in
<emphasis role="italic">rxsio_string</emphasis>. The output line can be of any
length. It is the responsibility of the
exit handler to truncate or split the line if necessary.</para></listitem>
</itemizedlist>
</para></listitem></varlistentry>
<varlistentry><term>RXSIOTRD</term>
<listitem><para>Reads from standard input stream.
<itemizedlist>
<listitem><para>When called: To read from the standard input stream
for the Rexx PULL and PARSE PULL instructions.</para></listitem>
<listitem><para>Default action: Read a line from the standard input
stream (STDIN).</para></listitem>
<listitem><para>Exit action: Return a line from the standard input
stream that the exit handler provided.</para></listitem>
<listitem><para>Parameter list:</para>
<example>
<title>RXSIO parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   RXSTRING          rxsiotrd_retc;    /* RXSTRING for input.         */
} RXSIOTRD_PARM;
]]>
</programlisting>
</example>
<para>The input stream line is returned in the
<emphasis role="italic">rxsiotrd_retc</emphasis> RXSTRING.</para>
</listitem></itemizedlist>
</para></listitem></varlistentry>
<varlistentry><term>RXSIODTR</term>
<listitem><para>Interactive debug input.
<itemizedlist>
<listitem><para>When called: To read from the debug input stream
for interactive debug prompts.</para></listitem>
<listitem><para>Default action: Read a line from the standard input
stream (STDIN).</para></listitem>
<listitem><para>Exit action: Return a line from the standard debug
stream that the exit handler provided.</para></listitem>
<listitem><para>Parameter list: </para>
<example>
<title>RXSIO parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   RXSTRING          rxsiodtr_retc;    /* RXSTRING for input.         */
} RXSIODTR_PARM;
]]>
</programlisting>
</example>
<para>The input stream line is returned in the
<emphasis role="italic">rxsiodtr_retc</emphasis> RXSTRING.</para>
</listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="hltcon"><title>RXHLT</title>
<indexterm><primary>external HALT exit</primary></indexterm>
<indexterm><primary>RXHLT exit</primary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXHLT exit</secondary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>external HALT exit</secondary></indexterm>
<para>HALT condition processing. </para>
<para>Because the RXHLT exit handler
is called after every Rexx instruction, enabling this exit slows Rexx program
execution. The RexxSetHalt function can halt a Rexx program without
between-instruction polling.</para>
<variablelist>
<varlistentry><term>RXHLTTST</term>
<listitem><para>Tests the HALT indicator.
<itemizedlist>
<listitem><para>When called: When the interpreter polls externally
raises HALT conditions. The exit will be called after completion of every
Rexx instruction.</para></listitem>
<listitem><para>Default action: The interpreter uses the system
facilities for trapping Cntrl-Break signals.</para></listitem>
<listitem><para>Exit action: Return the current state of the HALT
condition (either TRUE or FALSE).</para></listitem>
<listitem><para>Continuation: Raise the Rexx HALT condition if the
exit handler returns TRUE.</para></listitem>
<listitem><para>Parameter list:</para>
<example>
<title>RXHLT parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   struct {                            /* Halt flag                   */
      unsigned rxfhhalt : 1;           /* Set if HALT occurred.       */
   } rxhlt_flags;
} RXHLTTST_PARM;
]]>
</programlisting>
</example>
<para>If the exit handler sets <emphasis role="italic">rxfhhalt</emphasis> to
TRUE, the HALT condition is raised in the Rexx program.</para>
<para>The Rexx program can retrieve the reason string using the CONDITION("D")
built-in function.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
<varlistentry><term>RXHLTCLR</term>
<listitem><para>Clears the HALT condition.
<itemizedlist>
<listitem><para>When called: When the interpreter has recognized
and raised a HALT condition, to acknowledge processing of the HALT condition.</para></listitem>
<listitem><para>Default action: The interpreter resets the Cntrl-Break
signal handlers.</para></listitem>
<listitem><para>Exit action: Reset exit handler HALT state to FALSE.</para></listitem>
<listitem><para>Parameters: None.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="rxtrch"><title>RXTRC</title>
<indexterm><primary>external trace exit</primary></indexterm>
<indexterm><primary>RXTRC exit</primary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXTRC exit</secondary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>tracing exit</secondary></indexterm>
<para>Tests the external trace indicator. </para>
<note>
<para>Because the RXTRC exit
is called after every Rexx instruction, enabling this exit slows Rexx procedure
execution. The RexxSetTrace function can turn on Rexx tracing without the
between-instruction polling.</para></note>
<para></para>
<variablelist>
<varlistentry><term>RXTRCTST</term>
<listitem><para>Tests the external trace indicator.
<itemizedlist>
<listitem><para>When called: When the interpreter polls for an external
trace event. The exit is called after completion of every Rexx instruction.</para></listitem>
<listitem><para>Default action: None.</para></listitem>
<listitem><para>Exit action: Return the current state of external
tracing (either TRUE or FALSE).</para></listitem>
<listitem><para>Continuation: When the exit handler switches from
FALSE to TRUE, the Rexx interpreter enters the interactive Rexx debug mode
using TRACE ?R level of tracing. When the exit handler switches from TRUE
to FALSE, the Rexx interpreter exits the interactive debug mode.</para></listitem>
<listitem><para>Parameter list:</para>
<example>
<title>RXTRC parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   struct {
      unsigned rxftrace : 1;        /* External trace setting        */
   } rxtrc_flags;
} RXTRCTST_PARM;
]]>
</programlisting>
</example>
<para>If the exit handler switches <emphasis role="italic">rxftrace</emphasis>
to TRUE, Rexx switches on the interactive debug mode. If the exit handler
switches <emphasis role="italic">rxftrace</emphasis> to FALSE, Rexx switches
off the interactive debug mode.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="rxinih"><title>RXINI</title>
<indexterm><primary>RXINI exit</primary></indexterm>
<indexterm><primary>initialization exit</primary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXINI exit</secondary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>initialization exit</secondary></indexterm>
<para>Initialization processing. This exit is called as the last step of Rexx
program initialization. </para>
<variablelist>
<varlistentry><term>RXINIEXT</term>
<listitem><para>Initialization exit.
<itemizedlist>
<listitem><para>When called: Before the first instruction of the
Rexx procedure is interpreted.</para></listitem>
<listitem><para>Default action: None.</para></listitem>
<listitem><para>Exit action: The exit handler can perform additional
initialization. For example:
<itemizedlist>
<listitem><para>Use RexxVariablePool to initialize application-specific
variables.</para></listitem>
<listitem><para>Use RexxSetTrace to switch on the interactive Rexx debug mode.
</para></listitem>
</itemizedlist>
</para></listitem>
<listitem><para>Parameters: None.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="rxterh"><title>RXTER</title>
<indexterm><primary>RXTER exit</primary></indexterm>
<indexterm><primary>termination exit</primary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RXTER exit</secondary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>termination exit</secondary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>exit functions</secondary></indexterm>
<para>Termination processing.</para>
<para>The RXTER exit is called as the first step of Rexx program termination.</para>
<variablelist>
<varlistentry><term>RXTEREXT</term>
<listitem><para>Termination exit.
<itemizedlist>
<listitem><para>When called: After the last instruction of the Rexx
procedure has been interpreted.</para></listitem>
<listitem><para>Default action: None.</para></listitem>
<listitem><para>Exit action: The exit handler can perform additional
termination activities. For example, the exit handler can use RexxVariablePool
to retrieve the Rexx variable values.</para></listitem>
<listitem><para>Parameters: None.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="sysexitiffu"><title>System Exit Interface Functions</title>
<para>The system exit functions are similar to the subcommand handler functions.
The system exit functions are:</para>

<section id="exreg3"><title>RexxRegisterExitDll</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>exit interface</secondary>
<tertiary>RexxRegisterExitDll</tertiary></indexterm>
<indexterm><primary>RexxRegisterExitDll</primary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RexxRegisterExitDll</secondary></indexterm>
<para>RexxRegisterExitDll registers an exit handler that resides in a
dynamic-link library routine.</para>
<programlisting language="C++">
retc = RexxRegisterExitDll(ExitName, ModuleName, EntryPoint,
                           UserArea, DropAuth);
</programlisting>

<section id="regexitdllparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>ExitName (const char *) - input</term>
<listitem><para>is the address of an ASCII exit handler name.
</para></listitem></varlistentry>
<varlistentry><term>ModuleName (const char *) - input</term>
<listitem><para>is the address of an ASCII dynamic-link library
name. <emphasis role="italic">ModuleName</emphasis>
is the DLL file containing the exit handler routine.
</para></listitem></varlistentry>
<varlistentry><term>EntryPoint (const char *) - input</term>
<listitem><para>is the address of an ASCII dynamic-link procedure
name. <emphasis role="italic">EntryPoint</emphasis> is the routine within
<emphasis role="italic">ModuleName</emphasis> that Rexx
calls as an exit handler.
</para></listitem></varlistentry>
<varlistentry><term>UserArea (const char *) - input</term>
<listitem><para>is the address of an area of user-defined information.
The user-defined information is a buffer the size of two pointer values.
The
bytes <emphasis role="italic">UserArea</emphasis> buffer is saved with
the subcommand handler registration. <emphasis role="italic">UserArea</emphasis>
can be null if there is no user information to be saved. The
RexxQueryExit function can retrieve the saved user information.
</para></listitem></varlistentry>
<varlistentry><term>DropAuth (size_t) - input</term>
<listitem><para>is the drop authority.
<emphasis role="italic">DropAuth</emphasis> identifies the processes that
can deregister the exit handler. Possible
<emphasis role="italic">DropAuth</emphasis> values are:
<variablelist>
<varlistentry><term>RXEXIT_DROPPABLE</term>
<listitem><para>Any process can deregister the exit handler with
RexxDeregisterExit.
</para></listitem></varlistentry>
<varlistentry><term>RXEXIT_NONDROP</term>
<listitem><para>Only a
<indexterm><primary>thread</primary></indexterm>
thread within the same process as the thread that registered
the handler can deregister the handler with RexxDeregisterExit.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="regexitdllrc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXEXIT_OK</entry>
<entry> 0</entry>
<entry>The system exit function executed successfully.</entry>
</row>
<row>
<entry>RXEXIT_DUP</entry>
<entry> 10</entry>
<entry>A duplicate handler name has been successfully registered.
 There is either an executable handler with the same name registered in another
process, or a DLL handler with the same name registered in another DLL. (To address this exit
handler, you must specify its library name.)</entry>
</row>
<row>
<entry>RXEXIT_NOEMEM</entry>
<entry> 1002</entry>
<entry>There is insufficient memory available to complete this
request.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>

<section id="exreg2"><title>RexxRegisterExitExe</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>exit interface</secondary>
<tertiary>RexxRegisterExitExe</tertiary></indexterm>
<indexterm><primary>RexxRegisterExitExe</primary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RexxRegisterExitExe</secondary></indexterm>
<para>RexxRegisterExitExe registers an exit handler that resides within the
application code.</para>
<programlisting language="C++">
retc = RexxRegisterExitExe(ExitName, EntryPoint, UserArea);
</programlisting>

<section id="regexitexeparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>ExitName (const char *) - input</term>
<listitem><para>is the address of an ASCII exit handler name.
</para></listitem></varlistentry>
<varlistentry><term>EntryPoint (REXXPFN) - input</term>
<listitem><para>is the address of the exit handler entry point within the
application executable file.
</para></listitem></varlistentry>
<varlistentry><term>UserArea (const char *) - input</term>
<listitem><para>is the address of an area of user-defined information.
The user-defined information is a buffer the size of two pointer values.
The
bytes <emphasis role="italic">UserArea</emphasis> buffer is saved with
the subcommand handler registration. <emphasis role="italic">UserArea</emphasis>
can be null if there is no user information to be saved. The
RexxQueryExit function can retrieve the user information.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="regexitexerc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXEXIT_OK</entry>
<entry> 0</entry>
<entry>The system exit function executed successfully.</entry>
</row>
<row>
<entry>RXEXIT_DUP</entry>
<entry> 10</entry>
<entry>A duplicate handler name has been successfully registered.
 There is either an executable handler with the same name registered in another
process, or a DLL handler with the same name registered in another DLL. (To
address this exit handler, you must specify its library name.)</entry>
</row>
<row>
<entry>RXEXIT_NOTREG</entry>
<entry> 30</entry>
<entry>Registration was unsuccessful due to duplicate handler
and DLL names
(RexxRegisterExitExe or RexxRegisterExitDll); the exit handler is not registered
(other Rexx exit handler functions).</entry>
</row>
<row>
<entry>RXEXIT_NOEMEM</entry>
<entry> 1002</entry>
<entry>There is insufficient memory available to complete this
request.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="regexitexeremark"><title>Remarks</title>
<para>If <emphasis role="italic">ExitName</emphasis> has the same name as a
handler registered with RexxRegisterExitDll,
RexxRegisterExitExe returns RXEXIT_DUP, which means that the new exit handler
has been properly registered.</para>
</section>

<section id="regexitexexmp"><title>Example</title>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>registration example</secondary></indexterm>
<example>
<title>SYSEXIT</title>
<programlisting language="C++">
<![CDATA[
const char      *user_info[2];       /* saved user information     */

user_info[0] = global_workarea;      /* save global work area for  */
user_info[1] = NULL;                 /* re-entrance                */

rc = RexxRegisterExitExe("IO_Exit",  /* register editor handler    */
    &Edit_IO_Exit,                   /* located at this address    */
    user_info);                      /* save global pointer        */

]]>
</programlisting>
</example>
</section>
</section>

<section id="exdrp"><title>RexxDeregisterExit</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>exit interface</secondary>
<tertiary>RexxDeregisterExit</tertiary></indexterm>
<indexterm><primary>RexxDeregisterExit</primary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RexxDeregisterExit</secondary></indexterm>
<para>RexxDeregisterExit deregisters an exit handler.</para>
<programlisting language="C++">
retc = RexxDeregisterExit(ExitName, ModuleName);
</programlisting>

<section id="deregexitparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>ExitName (const char *) - input</term>
<listitem><para>is the address of an ASCII exit handler name.
</para></listitem></varlistentry>
<varlistentry><term>ModuleName (const char *) - input</term>
<listitem><para>is the address of an ASCII dynamic-link library
name. <emphasis role="italic">ModuleName</emphasis> restricts the query to an
exit handler within the <emphasis role="italic">ModuleName</emphasis>
library. When <emphasis role="italic">ModuleName</emphasis>
is null, RexxDeregisterExit searches the RexxRegisterExitExe exit handler
list for a handler within the current process. If RexxDeregisterExit does
not find a RexxRegisterExitExe handler, it searches the RexxRegisterExitDll
exit handler list.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="deregexitrc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXEXIT_OK</entry>
<entry> 0</entry>
<entry>The system exit function executed successfully.</entry>
</row>
<row>
<entry>RXEXIT_NOTREG</entry>
<entry> 30</entry>
<entry>Registration was unsuccessful due to duplicate handler
and DLL names
(RexxRegisterExitExe or RexxRegisterExitDll); the exit handler is not registered
(other Rexx exit handler functions).</entry>
</row>
<row>
<entry>RXEXIT_NOCANDROP</entry>
<entry> 40</entry>
<entry>The exit handler has been registered as &quot;not droppable.&quot;</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="deregexitremark"><title>Remarks</title>
<para>The handler is removed from the exit handler list.</para>
</section>
</section>

<section id="exqry"><title>RexxQueryExit</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>exit interface</secondary>
<tertiary>RexxQueryExit</tertiary></indexterm>
<indexterm><primary>RexxQueryExit</primary></indexterm>
<indexterm><primary>SYSEXIT interface</primary>
<secondary>RexxQueryExit</secondary></indexterm>
<para>RexxQueryExit queries an exit handler and retrieves saved user
information.</para>
<programlisting language="C++">
retc = RexxQueryExit(ExitName, ModuleName, Flag, UserWord);
</programlisting>

<section id="queryexitparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>ExitName (const char *) - input</term>
<listitem><para>is the address of an ASCII exit handler name.
</para></listitem></varlistentry>
<varlistentry><term>ModuleName (const char *) - input</term>
<listitem><para>restricts the query to an exit handler within the
<emphasis role="italic">ModuleName</emphasis> dynamic-link library. When
<emphasis role="italic">ModuleName</emphasis> is null, RexxQueryExit
searches the RexxRegisterExitExe exit handler list for a handler within the
current process. If RexxQueryExit does not find a RexxRegisterExitExe handler,
it searches the RexxRegisterExitDll exit handler list.
</para></listitem></varlistentry>
<varlistentry><term>Flag (unsigned short *) - output</term>
<listitem><para>is the <emphasis role="italic">ExitName</emphasis> exit handler
registration status. When RexxQueryExit returns RXEXIT_OK, the
<emphasis role="italic">ExitName</emphasis> exit handler is currently registered.
When RexxQueryExit returns RXEXIT_NOTREG, the
<emphasis role="italic">ExitName</emphasis> exit handler is not registered.
</para></listitem></varlistentry>
<varlistentry><term>UserWord (char *) - output</term>
<listitem><para>is the address of an area to receive the user information saved
with RexxRegisterExitExe or RexxRegisterExitDll.  The referenced area must be
large enough to store two pointer values.
<emphasis role="italic">UserWord</emphasis> can be
null if the saved user information is not required.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="queryexitrc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXEXIT_OK</entry>
<entry> 0</entry>
<entry>The system exit function executed successfully.</entry>
</row>
<row>
<entry>RXEXIT_NOTREG</entry>
<entry> 30</entry>
<entry>Registration was unsuccessful due to duplicate handler
and DLL names
(RexxRegisterExitExe or RexxRegisterExitDll); the exit handler is not registered
(other Rexx exit handler functions).</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="queryrexitxmp"><title>Example</title>
<example>
<title>Command handler</title>
<programlisting language="C++">
<![CDATA[
int REXXENTRY Edit_IO_Exit(
  int       Code,       /* Major exit code                          */
  int       SubCode     /* Minor exit code                          */
  PEXIT     Parms)      /* Exit-specific parameters                 */
{
  char            *user_info[2];       /* saved user information     */
  char            *global_workarea;    /* application data anchor    */
  unsigned short   query_flag;         /* flag for handler query     */


  rc = RexxQueryExit("IO_Exit",        /* retrieve application work  */
      NULL,                            /* area anchor from Rexx.     */
      &query_flag,
      user_info);

  global_workarea = user_info[0];      /* set the global anchor      */
...
}
]]>
</programlisting>
</example>
</section>
</section>
</section>
</section>

<section id="os2vpi"><title>Variable Pool Interface</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>variable pool interface</secondary></indexterm>
<indexterm><primary>variable pool interface</primary>
<secondary>description</secondary></indexterm>
<para>Application programs can use the Rexx Variable Pool Interface to manipulate
the variables of a currently active Rexx procedure.</para>

<section id="iftypes"><title>Interface Types</title>
<para>Three of the Variable Pool Interface functions (set, fetch, and drop) have
dual interfaces.</para>

<section id="symbolicif"><title>Symbolic Interface</title>
<indexterm><primary>variable pool interface</primary>
<secondary>symbolic interface</secondary></indexterm>
<para>The symbolic interface uses normal Rexx variable rules when interpreting
variables. Variable names are valid Rexx symbols (in mixed case if desired)
including compound symbols. Compound symbols are referenced with tail substitution.
The functions that use the symbolic interface are RXSHV_SYSET, RXSHV_SYFET,
and RXSHV_SYDRO.</para>
</section>

<section id="directif"><title>Direct Interface</title>
<indexterm><primary>variable pool interface</primary>
<secondary>direct interface</secondary></indexterm>
<para>The direct interface uses no substitution or case translation. Simple symbols
must be valid Rexx variable names. A valid Rexx variable name: </para>
<itemizedlist>
<listitem><para>Does not begin with a digit or period.</para></listitem>
<listitem><para>Contains only uppercase A to Z, the digits 0 - 9, or the
characters _, ! or ? before the first period of the name.</para></listitem>
<listitem><para>Can contain any characters after the first period of the name.
</para></listitem>
</itemizedlist>
<para>Compound variables are specified using the derived name of the variable.
 Any characters (including blanks) can appear after the first period of the
name. No additional variable substitution is used. RXSHV_SET, RXSHV_FETCH,
and RXSHV_DROP use the direct interface.</para>
</section>
</section>

<section id="varpoolrestr"><title>RexxVariablePool Restrictions</title>
<indexterm><primary>variable pool interface</primary>
<secondary>restrictions</secondary></indexterm>
<para>The RexxVariablePool interface is only available
from subcommand handlers,
external functions, and exit handlers.  The interface will access the
variable context that initiated the call to the handler code and is only available
if made from the same thread.</para>
</section>

<section id="varpooliffu"><title>RexxVariablePool Interface Function</title>
<para>Rexx procedure variables are accessed using the RexxVariablePool function.</para>

<section id="variablepool"><title>RexxVariablePool</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>variable pool interface</secondary>
<tertiary>RexxVariablePool</tertiary></indexterm>
<indexterm><primary>variable pool interface</primary>
<secondary>RexxVariablePool</secondary></indexterm>
<indexterm><primary>RexxVariablePool</primary></indexterm>
<para>RexxVariablePool accesses variables of a currently active Rexx procedure.</para>
<programlisting language="C++">
retc = RexxVariablePool(RequestBlockList);
</programlisting>

<section id="variablepoolparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>RequestBlockList (PSHVBLOCK) - input
<indexterm><primary>variable pool interface</primary>
<secondary>shared variable pool request block</secondary></indexterm>
</term>
<listitem><para>is a linked list of shared variable request blocks (SHVBLOCK).
Each block is a separate variable access request.
</para></listitem></varlistentry>
</variablelist>
<para>The SHVBLOCK has the following form:</para>
<indexterm><primary>application programming interfaces</primary>
<secondary>RXSTRING data structure</secondary>
<tertiary>SHVBLOCK</tertiary></indexterm>
<indexterm><primary>application programming interfaces</primary>
<secondary>SHVBLOCK</secondary></indexterm>
<indexterm><primary>SHVBLOCK</primary></indexterm>
<indexterm><primary>variable pool interface</primary>
<secondary>SHVBLOCK data structure</secondary></indexterm>
<example>
<title>SHVBLOCK</title>
<programlisting language="C++">
<![CDATA[
typedef struct shvnode {
    struct shvnode    *shvnext;
    CONSTRXSTRING      shvname;
    RXSTRING           shvvalue;
    size_t             shvnamelen;
    size_t             shvvaluelen;
    unsigned char      shvcode;
    unsigned char      shvret;
}   SHVBLOCK;
]]>
</programlisting>
</example>
<para>where:</para>
<variablelist>
   <varlistentry><term>shvnext</term>
   <listitem><para>is the address of the next SHVBLOCK in the request list.
   <emphasis role="italic">shvnext</emphasis> is null for the last request block.
   </para></listitem></varlistentry>
   <varlistentry><term>shvname
   <indexterm><primary>variable pool interface</primary>
   <secondary>returning variable names</secondary></indexterm>
   </term>
   <listitem><para>is an RXSTRING containing a Rexx variable name.
   <emphasis role="italic">shvname</emphasis> usage
   varies with the SHVBLOCK request code: </para>
   <variablelist>
      <varlistentry><term>RXSHV_SET  </term>
      <term>RXSHV_SYSET</term>
      <term>RXSHV_FETCH</term>
      <term>RXSHV_SYFET</term>
      <term>RXSHV_DROPV</term>
      <term>RXSHV_SYDRO</term>
      <term>RXSHV_PRIV </term>
      <listitem><para><emphasis role="italic">shvname</emphasis> is an RXSTRING
      pointing to the name of the Rexx variable
      that the shared variable request block accesses.
      </para></listitem></varlistentry>
      <varlistentry><term>RXSHV_NEXTV </term>
      <listitem><para><emphasis role="italic">shvname</emphasis> is an RXSTRING
      defining an area of storage to receive the name of the next variable.
      <emphasis role="italic">shvnamelen</emphasis> is the length of the
      RXSTRING area. If the variable name is longer than the
      <emphasis role="italic">shvnamelen</emphasis> characters,
      the name is truncated and the RXSHV_TRUNC bit of
      <emphasis role="italic">shvret</emphasis> is set.
      On return, <emphasis role="italic">shvname.strlength</emphasis> contains
      the length of the variable name;
      <emphasis role="italic">shvnamelen</emphasis> remains unchanged.</para>
      <para>If <emphasis role="italic">shvname</emphasis> is an empty RXSTRING
      (<emphasis role="italic">strptr</emphasis> is null), the Rexx interpreter
      allocates and returns an RXSTRING to hold the variable name.
      If the Rexx interpreter
      allocates the RXSTRING, an RXSHV_TRUNC condition cannot occur. However,
      RXSHV_MEMFL errors are possible for these operations. If an RXSHV_MEMFL
      condition occurs, memory is not allocated for that request block.
      The RexxVariablePool caller must release the storage with
      <computeroutput>RexxFreeMemory(ptr)</computeroutput>. </para>
      <note>
      <para>The RexxVariablePool does not add a terminating null character
      to the variable name.</para></note>
      </listitem></varlistentry>
   </variablelist>
   </listitem></varlistentry>
   <varlistentry><term>shvvalue
   <indexterm><primary>variable pool interface</primary>
   <secondary>returning variable value</secondary></indexterm>
   </term>
   <listitem><para>An RXSTRING containing a Rexx variable value. The meaning of <emphasis role="italic">shvvalue</emphasis> varies with the SHVBLOCK request code:</para>
   <variablelist>
      <varlistentry><term>RXSHV_SET
      <indexterm><primary>variable pool interface</primary>
      <secondary>setting variables</secondary></indexterm>
      </term>
      <term>RXSHV_SYSET</term>
      <listitem><para><emphasis role="italic">shvvalue</emphasis> is the value
      assigned to the Rexx variable in
      <emphasis role="italic">shvname</emphasis>.
      <emphasis role="italic">shvvaluelen</emphasis> contains the length of the
      variable value.
      </para></listitem></varlistentry>
      <varlistentry><term>RXSHV_FETCH</term>
      <term>RXSHV_SYFET
      <indexterm><primary>variable pool interface</primary>
      <secondary>fetching variables</secondary></indexterm>
      </term>
      <term>RXSHV_PRIV
      <indexterm><primary>variable pool interface</primary>
      <secondary>fetching private information</secondary></indexterm>
      </term>
      <term>RXSHV_NEXT
      <indexterm><primary>variable pool interface</primary>
      <secondary>fetching next variable</secondary></indexterm>
      </term>
      <listitem><para><emphasis role="italic">shvvalue</emphasis> is a buffer
      that is used by the Rexx interpreter to return the value of the Rexx variable
      <emphasis role="italic">shvname</emphasis>.
      <emphasis role="italic">shvvaluelen</emphasis> contains
      the length of the value buffer. On return,
      <emphasis role="italic">shvvalue.strlength</emphasis> is
      set to the length of the returned value but
      <emphasis role="italic">shvvaluelen</emphasis> remains unchanged.
      If the variable value is longer than the
      <emphasis role="italic">shvvaluelen</emphasis> characters,
      the value is truncated and the RXSHV_TRUNC bit of
      <emphasis role="italic">shvret</emphasis> is set.
      On return, <emphasis role="italic">shvvalue.strlength</emphasis>
      is set to the length of the returned
      value; <emphasis role="italic">shvvaluelen</emphasis> remains unchanged.
      </para>
      <para>If <emphasis role="italic">shvvalue</emphasis> is an empty
      RXSTRING (<emphasis role="italic">strptr</emphasis> is null), the Rexx
      interpreter allocates and returns an RXSTRING to hold the variable value.
      If the Rexx interpreter allocates the RXSTRING, an RXSHV_TRUNC condition
      cannot occur. However, RXSHV_MEMFL errors are possible for these
      operations. If an RXSHV_MEMFL condition occurs, memory is not allocated
      for that request block. The RexxVariablePool caller must release the
      storage with <computeroutput>RexxFreeMemory(ptr)</computeroutput>.</para>
      <note>
      <para>The RexxVariablePool does not add a terminating null character to
      the variable value.</para></note>
      </listitem></varlistentry>
      <varlistentry><term>RXSHV_DROPV
      <indexterm><primary>variable pool interface</primary>
      <secondary>dropping a variable</secondary></indexterm>
      </term>
      <term>RXSHV_SYDRO</term>
      <listitem><para><emphasis role="italic">shvvalue</emphasis> is not used.
      </para></listitem></varlistentry>
   </variablelist>
   </listitem></varlistentry>
   <varlistentry><term>shvcode
   <indexterm><primary>variable pool interface</primary>
   <secondary>return codes</secondary></indexterm>
   </term>
   <listitem><para>The shared variable block request code. Valid request codes
   are: </para>
   <variablelist>
      <varlistentry><term>RXSHV_SET</term>
      <term>RXSHV_SYSET </term>
      <listitem><para>Assign a new value to a Rexx procedure variable.
      </para></listitem></varlistentry>
      <varlistentry><term>RXSHV_FETCH</term>
      <term>RXSHV_SYFET </term>
      <listitem><para>Retrieve the value of a Rexx procedure variable.
      </para></listitem></varlistentry>
      <varlistentry><term>RXSHV_DROPV</term>
      <term>RXSHV_SYDRO </term>
      <listitem><para>Drop (unassign) a Rexx procedure variable.
      </para></listitem></varlistentry>
      <varlistentry><term>RXSHV_PRIV </term>
      <listitem><para>Fetch the private information of the Rexx procedure. The
      following information items can be retrieved by name: </para>
      <variablelist>
         <varlistentry><term>PARM</term>
         <listitem><para>The number of arguments supplied to the Rexx procedure.
         The number is formatted as a character string.
         </para></listitem></varlistentry>
         <varlistentry><term>PARM.n</term>
         <listitem><para>The nth argument string to the Rexx procedure. If the
         nth argument was not supplied to the procedure (either omitted or
         fewer than n parameters were specified), a null string is returned.
         </para></listitem></varlistentry>
         <varlistentry><term>QUENAME</term>
         <listitem><para>The current Rexx data queue name.
         </para></listitem></varlistentry>
         <varlistentry><term>SOURCE</term>
         <listitem><para>The Rexx procedure source string used for the PARSE
         SOURCE instruction.</para></listitem></varlistentry>
         <varlistentry><term>VERSION</term>
         <listitem><para>The Rexx interpreter version string used for the PARSE
         SOURCE instruction.</para></listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
      <varlistentry><term>RXSHV_NEXTV </term>
      <listitem><para>Fetch the next variable, excluding variables hidden by
      PROCEDURE instructions. The variables are not returned in any specified order.</para>
      <para>The Rexx interpreter
      maintains an internal pointer to its list of variables. The variable pointer
      is reset to the first Rexx variable whenever:</para>
      <itemizedlist>
      <listitem><para>An external program returns control to the interpreter</para></listitem>
      <listitem><para>A set, fetch, or drop RexxVariablePool function is used</para></listitem>
      </itemizedlist>
      <para>RXSHV_NEXTV returns both the name and the value of Rexx variables
      until the end of the variable list is reached. If no Rexx variables are left
      to return, RexxVariablePool sets the RXSHV_LVAR bit in
      <emphasis role="italic">shvret</emphasis>.</para>
      </listitem></varlistentry>
   </variablelist>
   </listitem></varlistentry>
   <varlistentry><term>shvret
   <indexterm><primary>variable pool interface</primary>
   <secondary>return codes</secondary></indexterm>
   </term>
   <listitem><para>The individual shared variable request return code.
   <emphasis role="italic">shvret</emphasis> is
   a 1-byte field of status flags for the individual shared variable request.
   The <emphasis role="italic">shvret</emphasis> fields for all request
   blocks in the list are ORed together
   to form the RexxVariablePool return code. The individual status conditions
   are: </para>
   <variablelist>
      <varlistentry><term>RXSHV_OK</term>
      <listitem><para>The request was processed without error (all flag bits are FALSE).
      </para></listitem></varlistentry>
      <varlistentry><term>RXSHV_NEWV</term>
      <listitem><para>The named variable was uninitialized at the time of the call.
      </para></listitem></varlistentry>
      <varlistentry><term>RXSHV_LVAR</term>
      <listitem><para>No more variables are available for an RXSHV_NEXTV operation.
      </para></listitem></varlistentry>
      <varlistentry><term>RXSHV_TRUNC</term>
      <listitem><para>A variable value or variable name was truncated because the supplied
      RXSTRING was too small for the copied value.
      </para></listitem></varlistentry>
      <varlistentry><term>RXSHV_BADN</term>
      <listitem><para>The variable name specified in
      <emphasis role="italic">shvname</emphasis> was invalid for the
      requested operation.
      </para></listitem></varlistentry>
      <varlistentry><term>RXSHV_MEMFL</term>
      <listitem><para>The Rexx interpreter was unable to obtain the storage
      required to complete the request.
      </para></listitem></varlistentry>
      <varlistentry><term>RXSHV_BADF</term>
      <listitem><para>The shared variable request block contains an invalid function code.
      </para></listitem></varlistentry>
   </variablelist>
   </listitem></varlistentry>
</variablelist>
<para>The Rexx interpreter processes each request block in the order provided.
RexxVariablePool returns to the caller after the last block is processed or
a severe error occurred (such as an out-of-memory condition).</para>
<para>The RexxVariablePool function return code is a composite return code for
the entire set of shared variable requests. The return codes for all of the
individual requests are ORed together to form the composite return code. Individual
shared variable request return codes are returned in the shared variable request
blocks.</para>
</section>

<section id="variablepoolrc"><title>RexxVariablePool Return Codes</title>
<variablelist>
<varlistentry><term>0 to 127</term>
<listitem><para>RexxVariablePool has processed the entire shared variable
request block list. </para>
<para>The RexxVariablePool function return code is a composite return code
for the entire set of shared variable requests. The low-order 6 bits of the
<emphasis role="italic">shvret</emphasis> fields for all request blocks are
ORed together to form the composite
return code. Individual shared variable request status flags are returned
in the shared variable request block <emphasis role="italic">shvret</emphasis>
field.</para>
</listitem></varlistentry>
<varlistentry><term>RXSHV_NOAVL</term>
<listitem><para>The variable pool interface was not enabled when the call was
issued.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="variablepoolxmp"><title>Example</title>
<indexterm><primary>variable pool interface</primary>
<secondary>RexxVariablePool example</secondary></indexterm>
<example>
<title>RexxVariablePool</title>
<programlisting language="C++">
<![CDATA[
/*********************************************************************/
/*                                                                   */
/* SetRexxVariable - Set the value of a Rexx variable                */
/*                                                                   */
/*********************************************************************/

int SetRexxVariable(
  const char *name,                    /* Rexx variable to set       */
  char       *value)                   /* value to assign            */
{
  SHVBLOCK   block;                    /* variable pool control block*/

  block.shvcode = RXSHV_SYSET;         /* do a symbolic set operation*/
  block.shvret=(UCHAR)0;               /* clear return code field    */
  block.shvnext=(PSHVBLOCK)0;          /* no next block              */
                                       /* set variable name string   */
  MAKERXSTRING(block.shvname, name, strlen(name));
                                       /* set value string           */
  MAKERXSTRING(block.shvvalue, value, strlen(value));
  block.shvvaluelen=strlen(value);     /* set value length           */
  return RexxVariablePool(&block);     /* set the variable           */
}
]]>
</programlisting>
</example>
</section>
</section>
</section>
</section>

<section id="rexxmemfuncts">
<title>Dynamically Allocating and De-allocating Memory</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>system memory interface</secondary></indexterm>
<para>For several functions of the Rexx-API it is necessary or possible to
dynamically allocate or free memory. Depending on the operating system,
compiler and Rexx interpreter, the method for these allocations and de-
allocations vary. To write system independent code, Open Object Rexx comes with
two API function calls called RexxAllocateMemory() and RexxFreeMemory().
These functions are wrapper for the corresponding compiler or operating
system memory functions.</para>

<section id="rexxallocmem"><title>The RexxAllocateMemory() Function</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>system memory interface</secondary>
<tertiary>RexxAllocateMemory</tertiary></indexterm>
<indexterm><primary>RexxAllocateMemory</primary></indexterm>
<programlisting language="C++">
<![CDATA[
void * REXXENTRY RexxAllocateMemory( size_t size );
]]>
</programlisting>

<para>where:
<variablelist>
<varlistentry>
<term><emphasis role="italic">size</emphasis></term>
<listitem><para>is the number of bytes of requested memory.</para></listitem>
</varlistentry>
</variablelist></para>

<para><emphasis role="bold">Return Codes</emphasis></para>

<para>Returns a pointer to the newly allocated block of memory, or NULL if no
memory could be allocated.</para>
</section>

<section id="rexxfreemem"><title>The RexxFreeMemory() Function</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>system memory interface</secondary>
<tertiary>RexxFreeMemory</tertiary></indexterm>
<indexterm><primary>RexxFreeMemory</primary></indexterm>
<programlisting language="C++">
<![CDATA[
RexxReturnCode REXXENTRY RexxFreeMemory( void *MemoryBlock );
]]>
</programlisting>

<para>where:
<variablelist>
<varlistentry>
<term><emphasis role="italic">MemoryBlock</emphasis></term>
<listitem>
<para>is a void pointer to the block of memory allocated by the ooRexx
interpreter, or allocated by a previous call to RexxAllocateMemory().</para>
</listitem>
</varlistentry>
</variablelist></para>

<para><emphasis role="bold">Return Codes</emphasis></para>

<para>RexxFreeMemory() always returns 0.</para>
</section>

</section>

<section id="queueif"><title>Queue Interface</title>
<indexterm><primary>queue interface</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>application programming interfaces</primary>
<secondary>queue interface</secondary></indexterm>
<para>Application programs can use the Rexx Queue Interface to establish and
manipulate named queues. Named queues prevent different Rexx programs that
are running in a single session from interfering with each other. Named queues
also allow Rexx programs running in different sessions to synchronize execution
and pass data. These queuing services are entirely separate from the Windows InterProcess
Communications queues.</para>

<section id="queueiffu"><title>Queue Interface Functions</title>
<para>The following sections explain the functions for creating and using named
queues.</para>

<section id="rcreque"><title>RexxCreateQueue</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>queue interface</secondary>
<tertiary>RexxCreateQueue</tertiary></indexterm>
<indexterm><primary>RexxCreateQueue</primary></indexterm>
<indexterm><primary>queue interface</primary>
<secondary>RexxCreateQueue</secondary></indexterm>
<para>RexxCreateQueue creates a new (empty) queue.</para>
<programlisting language="C++">
retc = RexxCreateQueue(Buffer, BuffLen, RequestedName, DupFlag);
</programlisting>

<section id="createqueueparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>Buffer (char *) - input</term>
<listitem><para>is the address of the buffer where the ASCII name of the created queue
is returned.
</para></listitem></varlistentry>
<varlistentry><term>BuffLen  (size_t) - input</term>
<listitem><para>is the size of the buffer.
</para></listitem></varlistentry>
<varlistentry><term>RequestedName  (const char *) - input</term>
<listitem><para>is the address of an ASCII queue name. If no queue of that name exists,
a queue is created with the requested name. If the name already exists, a
queue is created, but Rexx assigns an arbitrary name to it. In addition, the
DupFlag is set. The maximum length for a queue name is 1024 characters.</para>
<para>When RequestedName is null, Rexx
provides a name for the created queue.</para>
<para>In all cases, the actual queue
name is passed back to the caller.</para>
</listitem></varlistentry>
<varlistentry><term>DupFlag  (size_t *) - output</term>
<listitem><para>is the duplicate name indicator. This flag is set when the requested
name already exists.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="createqueuerc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXQUEUE_OK</entry>
<entry> 0</entry>
<entry>The system queue function completed successfully.</entry>
</row>
<row>
<entry>RXQUEUE_STORAGE</entry>
<entry> 1</entry>
<entry>The name buffer is not large enough for the queue name.</entry>
</row>
<row>
<entry>RXQUEUE_BADQNAME</entry>
<entry> 5</entry>
<entry>The queue name is not valid, or you tried to create
or delete a queue named SESSION.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="createqueueremark"><title>Remarks</title>
<para>Queue names must conform to the same syntax rules as Rexx variable names.
Lowercase characters in queue names are translated to uppercase.</para>
</section>
</section>

<section id="ropenque"><title>RexxOpenQueue</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>queue interface</secondary>
<tertiary>RexxOpenQueue</tertiary></indexterm>
<indexterm><primary>RexxOpenQueue</primary></indexterm>
<indexterm><primary>queue interface</primary>
<secondary>RexxOpenQueue</secondary></indexterm>
<para>RexxOpenQueue creates a new (empty) queue if a queue by the given
name does not already exist.  In contrast to RexxCreateQueue, RexxOpenQueue will not
create a differently named queue if the indicated queue name already exists.
</para>
<programlisting language="C++">
retc = RexxOpenQueue(RequestedName, CreatedFlag);
</programlisting>

<section id="openqueueparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>RequestedName  (const char *) - input</term>
<listitem><para>is the address of an ASCII queue name. If no queue of that name exists,
a queue is created with the requested name.  and the CreatedFlag will be set to TRUE.
If the name already exists, this
will just return a successful return code.
The maximum length for a queue name is 1024 characters.</para>
</listitem></varlistentry>
<varlistentry><term>CreateFlag  (size_t *) - output</term>
<listitem><para>indicates whether RexxOpenQueue created the indicated queue.  If zero
on return, then the named queue already existed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="openqueuerc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXQUEUE_OK</entry>
<entry> 0</entry>
<entry>The system queue function completed successfully.</entry>
</row>
<row>
<entry>RXQUEUE_STORAGE</entry>
<entry> 1</entry>
<entry>The name buffer is not large enough for the queue name.</entry>
</row>
<row>
<entry>RXQUEUE_BADQNAME</entry>
<entry> 5</entry>
<entry>The queue name is not valid, or you tried to create
or delete a queue named SESSION.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="openqueueremark"><title>Remarks</title>
<para>Queue names must conform to the same syntax rules as Rexx variable names.
Lowercase characters in queue names are translated to uppercase.</para>
</section>
</section>

<section id="rdelque"><title>RexxDeleteQueue</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>queue interface</secondary>
<tertiary>RexxDeleteQueue</tertiary></indexterm>
<indexterm><primary>RexxDeleteQueue</primary></indexterm>
<indexterm><primary>queue interface</primary>
<secondary>RexxDeleteQueue</secondary></indexterm>
<para>RexxDeleteQueue deletes a queue.</para>
<programlisting language="C++">
retc = RexxDeleteQueue(QueueName);
</programlisting>

<section id="delqueueparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>QueueName (const char *) - input</term>
<listitem><para>is the address of the ASCII name of the queue to be deleted.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="delqueuerc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXQUEUE_OK</entry>
<entry> 0</entry>
<entry>The system queue function completed successfully.</entry>
</row>
<row>
<entry>RXQUEUE_BADQNAME</entry>
<entry> 5</entry>
<entry>The queue name is not valid, or you tried to create
or delete a queue named SESSION.</entry>
</row>
<row>
<entry>RXQUEUE_NOTREG</entry>
<entry> 9</entry>
<entry>The queue does not exist.</entry>
</row>
<row>
<entry>RXQUEUE_ACCESS</entry>
<entry> 10</entry>
<entry>The queue cannot be deleted because it is busy.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="delqueueremark"><title>Remarks</title>
<para>If a queue is busy (for example, wait is active), it is not deleted.</para>
</section>
</section>

<section id="rqueexists"><title>RexxQueueExists</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>queue interface</secondary>
<tertiary>RexxQueryExists</tertiary></indexterm>
<indexterm><primary>RexxQueueExists</primary></indexterm>
<indexterm><primary>queue interface</primary>
<secondary>RexxQueueExists</secondary></indexterm>
<para>RexxQueueExists tests if name queue exists.</para>
<programlisting language="C++">
retc = RexxQueueExists(QueueName);
</programlisting>

<section id="queueexistsparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>QueueName (const char *) - input</term>
<listitem><para>is the address of the ASCII name of the queue to be queried.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="queueexistsrc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXQUEUE_OK</entry>
<entry> 0</entry>
<entry>The system queue function completed successfully.</entry>
</row>
<row>
<entry>RXQUEUE_BADQNAME</entry>
<entry> 5</entry>
<entry>The queue name is not valid, or you tried to create
or delete a queue named SESSION.</entry>
</row>
<row>
<entry>RXQUEUE_NOTREG</entry>
<entry> 9</entry>
<entry>The queue does not exist.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>

<section id="rqueque"><title>RexxQueryQueue</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>queue interface</secondary>
<tertiary>RexxQueryQueue</tertiary></indexterm>
<indexterm><primary>RexxQueryQueue</primary></indexterm>
<indexterm><primary>queue interface</primary>
<secondary>RexxQueryQueue</secondary></indexterm>
<para>RexxQueryQueue returns the number of entries remaining in the named queue.</para>
<programlisting language="C++">
retc = RexxQueryQueue(QueueName, Count);
</programlisting>

<section id="queryqueueparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>QueueName (const char *) - input</term>
<listitem><para>is the address of the ASCII name of the queue to be queried.
</para></listitem></varlistentry>
<varlistentry><term>Count (size_t *) - output</term>
<listitem><para>is the number of entries in the queue.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="queryqueuerc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXQUEUE_OK</entry>
<entry> 0</entry>
<entry>The system queue function completed successfully.</entry>
</row>
<row>
<entry>RXQUEUE_BADQNAME</entry>
<entry> 5</entry>
<entry>The queue name is not valid, or you tried to create
or delete a queue named SESSION.</entry>
</row>
<row>
<entry>RXQUEUE_NOTREG</entry>
<entry> 9</entry>
<entry>The queue does not exist.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>

<section id="raddque"><title>RexxAddQueue</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>queue interface</secondary>
<tertiary>RexxAddQueue</tertiary></indexterm>
<indexterm><primary>RexxAddQueue</primary></indexterm>
<indexterm><primary>queue interface</primary>
<secondary>RexxAddQueue</secondary></indexterm>
<para>RexxAddQueue adds an entry to a queue.</para>
<programlisting language="C++">
retc = RexxAddQueue(QueueName, EntryData, AddFlag);
</programlisting>

<section id="addqueueparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>QueueName (const char *) - input</term>
<listitem><para>is the address of the ASCII name of the queue to which data is
to be added.
</para></listitem></varlistentry>
<varlistentry><term>EntryData  (PCONSTRXSTRING) - input</term>
<listitem><para>is the address of a CONSTRXSTRING containing the data to be added
to the queue.
</para></listitem></varlistentry>
<varlistentry><term>AddFlag  (size_t) - input</term>
<listitem><para>is the LIFO/FIFO flag. When AddFlag is
<computeroutput>RXQUEUE_LIFO</computeroutput>, data is added LIFO (Last In,
First Out) to the queue. When AddFlag is
<computeroutput>RXQUEUE_FIFO</computeroutput>, data is
added FIFO (First In, First Out).
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="addqueuerc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXQUEUE_OK</entry>
<entry> 0</entry>
<entry>The system queue function completed successfully.</entry>
</row>
<row>
<entry>RXQUEUE_BADQNAME</entry>
<entry> 5</entry>
<entry>The queue name is not valid, or you tried to create
or delete a queue named SESSION.</entry>
</row>
<row>
<entry>RXQUEUE_PRIORITY</entry>
<entry> 6</entry>
<entry>The order flag is not equal to RXQUEUE_LIFO or RXQUEUE_FIFO.</entry>
</row>
<row>
<entry>RXQUEUE_NOTREG</entry>
<entry> 9</entry>
<entry>The queue does not exist.</entry>
</row>
<row>
<entry>RXQUEUE_MEMFAIL</entry>
<entry> 12</entry>
<entry>There is insufficient memory available to complete the
request.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>

<section id="rpulfque"><title>RexxPullFromQueue</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>queue interface</secondary>
<tertiary>RexxPullFromQueue</tertiary></indexterm>
<indexterm><primary>RexxPullFromQueue</primary></indexterm>
<indexterm><primary>queue interface</primary>
<secondary>RexxPullFromQueue</secondary></indexterm>
<para>RexxPullFromQueue removes the top entry from the queue and returns it to the
caller.
</para>
<programlisting language="C++">
retc = RexxPullFromQueue(QueueName, DataBuf, DateTime, WaitFlag);
</programlisting>

<section id="pullfromqueueparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>QueueName (const char *) - input</term>
<listitem><para>is the address of the ASCII name of the queue from which data is to
be pulled.
</para></listitem></varlistentry>
<varlistentry><term>DataBuf  (PRXSTRING) - output</term>
<listitem><para>is the address of an RXSTRING for the returned value.
</para></listitem></varlistentry>
<varlistentry><term>DateTime  (REXXDATETIME *) - output</term>
<listitem><para>is the address of the entry's date and time stamp.  If the
date and time stamp is not needed, DateTime may be NULL.
</para></listitem></varlistentry>
<varlistentry><term>WaitFlag  (size_t) - input</term>
<listitem><para>is the wait flag. When WaitFlag is
<computeroutput>RXQUEUE_NOWAIT</computeroutput> and the queue is empty,
RXQUEUE_EMPTY is returned. Otherwise, when WaitFlag is
<computeroutput>RXQUEUE_WAIT</computeroutput>, Rexx waits until
a queue entry is available and returns that entry to the caller.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="pullfromqueuerc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXQUEUE_OK</entry>
<entry> 0</entry>
<entry>The system queue function completed successfully.</entry>
</row>
<row>
<entry>RXQUEUE_BADQNAME</entry>
<entry> 5</entry>
<entry>The queue name is not valid, or you tried to create
or delete a queue named SESSION.</entry>
</row>
<row>
<entry>RXQUEUE_BADWAITFLAG</entry>
<entry> 7</entry>
<entry>The wait flag is not equal to RXQUEUE_WAIT or RXQUEUE_NOWAIT.</entry>
</row>
<row>
<entry>RXQUEUE_EMPTY</entry>
<entry> 8</entry>
<entry>Attempted to pull the item off the queue but it was
empty.</entry>
</row>
<row>
<entry>RXQUEUE_NOTREG</entry>
<entry> 9</entry>
<entry>The queue does not exist.</entry>
</row>
<row>
<entry>RXQUEUE_MEMFAIL</entry>
<entry> 12</entry>
<entry>There is insufficient memory available to complete the
request.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>


<section id="rclearque"><title>RexxClearQueue</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>queue interface</secondary>
<tertiary>RexxClearQueue</tertiary></indexterm>
<indexterm><primary>RexxClearQueue</primary></indexterm>
<indexterm><primary>queue interface</primary>
<secondary>RexxClearQueue</secondary></indexterm>
<para>RexxClearQueue clears all entries from a named queue.</para>
<programlisting language="C++">
retc = RexxClearQueue(QueueName);
</programlisting>

<section id="clearqueueparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>QueueName (const char *) - input</term>
<listitem><para>is the address of the ASCII name of the queue to be cleared.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="clearqueuerc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXQUEUE_OK</entry>
<entry> 0</entry>
<entry>The system queue function completed successfully.</entry>
</row>
<row>
<entry>RXQUEUE_BADQNAME</entry>
<entry> 5</entry>
<entry>The queue name is not valid, or you tried to create
or delete a queue named SESSION.</entry>
</row>
<row>
<entry>RXQUEUE_NOTREG</entry>
<entry> 9</entry>
<entry>The queue does not exist.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>

<section id="rpulque"><title>RexxPullQueue (Deprecated)</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>queue interface</secondary>
<tertiary>RexxPullQueue</tertiary></indexterm>
<indexterm><primary>RexxPullQueue</primary></indexterm>
<indexterm><primary>queue interface</primary>
<secondary>RexxPullQueue</secondary></indexterm>
<para>RexxPullQueue removes the top entry from the queue and returns it to the
caller.  RexxPullQueue is deprecated in favor of its more portable
replacement RexxPullFromQueue (<xref linkend="rpulfque" />).
</para>
<programlisting language="C++">
retc = RexxPullQueue(QueueName, DataBuf, DateTime, WaitFlag);
</programlisting>

<section id="pullqueueparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>QueueName (const char *) - input</term>
<listitem><para>is the address of the ASCII name of the queue from which data is to
be pulled.
</para></listitem></varlistentry>
<varlistentry><term>DataBuf  (PRXSTRING) - output</term>
<listitem><para>is the address of an RXSTRING for the returned value.
</para></listitem></varlistentry>
<varlistentry><term>DateTime  (PDATETIME) - output</term>
<listitem><para>is the address of the entry's date and time stamp.
</para></listitem></varlistentry>
<varlistentry><term>WaitFlag  (size_t) - input</term>
<listitem><para>is the wait flag. When WaitFlag is
<computeroutput>RXQUEUE_NOWAIT</computeroutput> and the queue is empty,
RXQUEUE_EMPTY is returned. Otherwise, when WaitFlag is
<computeroutput>RXQUEUE_WAIT</computeroutput>, Rexx waits until
a queue entry is available and returns that entry to the caller.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="pullqueuerc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXQUEUE_OK</entry>
<entry> 0</entry>
<entry>The system queue function completed successfully.</entry>
</row>
<row>
<entry>RXQUEUE_BADQNAME</entry>
<entry> 5</entry>
<entry>The queue name is not valid, or you tried to create
or delete a queue named SESSION.</entry>
</row>
<row>
<entry>RXQUEUE_BADWAITFLAG</entry>
<entry> 7</entry>
<entry>The wait flag is not equal to RXQUEUE_WAIT or RXQUEUE_NOWAIT.</entry>
</row>
<row>
<entry>RXQUEUE_EMPTY</entry>
<entry> 8</entry>
<entry>Attempted to pull the item off the queue but it was
empty.</entry>
</row>
<row>
<entry>RXQUEUE_NOTREG</entry>
<entry> 9</entry>
<entry>The queue does not exist.</entry>
</row>
<row>
<entry>RXQUEUE_MEMFAIL</entry>
<entry> 12</entry>
<entry>There is insufficient memory available to complete the
request.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="pullqueueremark"><title>Remarks</title>
<para>The caller is responsible for freeing the returned memory that DataBuf
points to.</para>
</section>
</section>
</section>
</section>

<section id="os2ari"><title>Halt and Trace Interface</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>halt and trace interface</secondary></indexterm>
<indexterm><primary>queue interface</primary>
<secondary>description</secondary></indexterm>
<para>The halt and trace functions raise a Rexx HALT condition or change the
Rexx interactive debug mode while a Rexx procedure is running. You might prefer
these interfaces to the RXHLT and RXTRC system exits. The system exits require
an additional call to an exit routine after each Rexx instruction completes,
possibly causing a noticeable performance degradation. The Halt and Trace
functions, on the contrary, are a single request to change the halt or trace
state and do not degrade the Rexx procedure performance.</para>

<section id="halttraceiffu"><title>Halt and Trace Interface Functions</title>
<para>The Halt and Trace functions are:</para>

<section id="rsh"><title>RexxSetHalt</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>halt and trace interface</secondary>
<tertiary>RexxSetHalt</tertiary></indexterm>
<indexterm><primary>RexxSetHalt</primary></indexterm>
<indexterm><primary>queue interface</primary>
<secondary>RexxSetHalt</secondary></indexterm>
<para>RexxSetHalt raises a HALT condition in a running Rexx program.</para>
<programlisting language="C++">
retc = RexxSetHalt(ProcessId, ThreadId);
</programlisting>

<section id="sethaltparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>ProcessId (process_id_t) - input</term>
<listitem><para>is the process ID of the target Rexx procedure.
<emphasis role="italic">ProcessId</emphasis> is
the application process that called the RexxStart function.
</para></listitem></varlistentry>
<varlistentry><term>ThreadId (thread_id_t) - input</term>
<listitem><para>is the thread
<indexterm><primary>thread</primary></indexterm>
ID of the target Rexx procedure. <emphasis role="italic">ThreadId</emphasis> is
the application thread that called the RexxStart function. If
<emphasis role="italic">ThreadId</emphasis>=0, all the threads of the process
are canceled.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="sethaltrc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXARI_OK</entry>
<entry> 0</entry>
<entry>The function completed successfully.</entry>
</row>
<row>
<entry>RXARI_NOT_FOUND</entry>
<entry> 1</entry>
<entry>The target Rexx procedure was not found.</entry>
</row>
<row>
<entry>RXARI_PROCESSING_ERROR</entry>
<entry> 2</entry>
<entry>A failure in Rexx processing occurred.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="sethaltremark"><title>Remarks</title>
<para>This call is not processed if the target Rexx program is running with the
RXHLT exit enabled.</para>
</section>
</section>

<section id="osrst"><title>RexxSetTrace</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>halt and trace interface</secondary>
<tertiary>RexxSetTrace</tertiary></indexterm>
<indexterm><primary>RexxSetTrace</primary></indexterm>
<indexterm><primary>queue interface</primary>
<secondary>RexxSetTrace</secondary></indexterm>
<para>RexxSetTrace turns on the interactive debug mode for a Rexx procedure.</para>
<programlisting language="C++">
retc = RexxSetTrace(ProcessId, ThreadId);
</programlisting>

<section id="settraceparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>ProcessId (process_id_t) - input</term>
<listitem><para>is the process ID of the target Rexx procedure.
<emphasis role="italic">ProcessId</emphasis> is
the application process that called the RexxStart function.
</para></listitem></varlistentry>
<varlistentry><term>ThreadId (thread_id_t) - input</term>
<listitem><para>is the thread
<indexterm><primary>thread</primary></indexterm>
ID of the target Rexx procedure.
<emphasis role="italic">ThreadId</emphasis> is
the application thread that called the RexxStart function. If
<emphasis role="italic">ThreadId</emphasis>=0, all the threads of the process
are traced.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="settracerc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXARI_OK</entry>
<entry> 0</entry>
<entry>The function completed successfully.</entry>
</row>
<row>
<entry>RXARI_NOT_FOUND</entry>
<entry> 1</entry>
<entry>The target Rexx procedure was not found.</entry>
</row>
<row>
<entry>RXARI_PROCESSING_ERROR</entry>
<entry> 2</entry>
<entry>A failure in Rexx processing occurred.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="settraceremark"><title>Remarks</title>
<para>A RexxSetTrace call is not processed if the Rexx procedure is using the
RXTRC exit.</para>
</section>
</section>

<section id="osrrt"><title>RexxResetTrace</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>halt and trace interface</secondary>
<tertiary>RexxResetTrace</tertiary></indexterm>
<indexterm><primary>RexxResetTrace</primary></indexterm>
<indexterm><primary>queue interface</primary>
<secondary>RexxResetTrace</secondary></indexterm>
<para>RexxResetTrace turns off the interactive debug mode for a Rexx procedure.</para>
<programlisting language="C++">
retc = RexxResetTrace(ProcessId,ThreadId);
</programlisting>

<section id="resettraceparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>ProcessId (process_id_t) - input</term>
<listitem><para>is the process ID of the target Rexx procedure.
<emphasis role="italic">ProcessId</emphasis> is
the application process that called the RexxStart function.
</para></listitem></varlistentry>
<varlistentry><term>ThreadId (thread_id_t) - input</term>
<listitem><para>is the thread ID of the target Rexx procedure.
<emphasis role="italic">ThreadId</emphasis> is
the application thread that called the RexxStart function. If
<emphasis role="italic">ThreadId</emphasis>=0, the trace of all threads of
the process is reset.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="resettracerc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXARI_OK</entry>
<entry> 0</entry>
<entry>The function completed successfully.</entry>
</row>
<row>
<entry>RXARI_NOT_FOUND</entry>
<entry> 1</entry>
<entry>The target Rexx procedure was not found.</entry>
</row>
<row>
<entry>RXARI_PROCESSING_ERROR</entry>
<entry> 2</entry>
<entry>A failure in Rexx processing occurred.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="resettraceremark"><title>Remarks</title>
<para></para>
<itemizedlist>
<listitem><para>A RexxResetTrace call is not processed if the Rexx procedure uses the
RXTRC exit.</para></listitem>
<listitem><para>Interactive debugging is not turned off unless the interactive debug mode
was originally started with RexxSetTrace.</para></listitem></itemizedlist>
</section>
</section>
</section>
</section>

<section id="macrosp"><title>Macrospace Interface</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>macrospace interface</secondary></indexterm>
<indexterm><primary>macrospace interface</primary>
<secondary>description</secondary></indexterm>
<para>The macrospace can improve the performance of Rexx procedures by maintaining
Rexx procedure images in memory for immediate load and execution. This is
useful for frequently-used procedures and functions such as editor macros.</para>
<para>Programs registered in the Rexx macrospace are available to all processes.
You can run them by using the RexxStart function or calling them as functions
or subroutines from other Rexx procedures.</para>
<para>Procedures in the macrospace are called in the same way as other Rexx external
functions. However, the macrospace Rexx procedures can be placed at the front
or at the very end of the external function search order.</para>
<para>Procedures in the macrospace are stored without source code information
and therefore cannot be traced.</para>
<para>Rexx procedures in the macrospace can be saved to a disk file. A saved
macrospace file can be reloaded with a single call to RexxLoadMacroSpace.
An application, such as an editor, can create its own library of frequently-used
functions and load the entire library into memory for fast access. Several
macrospace libraries can be created and loaded.</para>

<note>
<para>The <computeroutput>TRACE</computeroutput> keyword instruction cannot
be used in the Rexx macrospace. Since macrospace uses the tokenized format,
it is not possible to get the source code from macrospace to trace a function.
</para></note>

<section id="sorder"><title>Search Order</title>
<para>When RexxAddMacro loads a Rexx procedure into the macrospace, the position
in the external function search order is specified. Possible values are:</para>
<variablelist>
<varlistentry><term>RXMACRO_SEARCH_BEFORE</term>
<listitem><para>The Rexx interpreter locates a function registered with
RXMACRO_SEARCH_BEFORE before any registered functions or external Rexx files.
</para></listitem></varlistentry>
<varlistentry><term>RXMACRO_SEARCH_AFTER</term>
<listitem><para>The Rexx interpreter locates a function registered with
RXMACRO_SEARCH_AFTER after any registered functions or external Rexx files.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="macrospacelibstor"><title>Storage of Macrospace Libraries</title>
<para>The Rexx macrospace is stored in separate process using a daemon process.
Macrospace routines are retrieved using interprocess call (IPC) mechanisms.
A package file that is loaded in the local process might be preferable to
loading routines in the macrospace.</para>
</section>

<section id="macrospaceiffu"><title>Macrospace Interface Functions</title>
<para>The functions to manipulate macrospaces are:</para>

<section id="addmacro"><title>RexxAddMacro</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>macrospace interface</secondary>
<tertiary>RexxAddMacro</tertiary></indexterm>
<indexterm><primary>RexxAddMacro</primary></indexterm>
<indexterm><primary>macrospace interface</primary>
<secondary>RexxAddMacro</secondary></indexterm>
<para>RexxAddMacro loads a Rexx procedure into the macrospace.</para>
<programlisting language="C++">
retc = RexxAddMacro(FuncName, SourceFile, Position);
</programlisting>

<section id="addmacroparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>FuncName (const char *) - input</term>
<listitem><para>is the address of the ASCII function name. Rexx procedures in
the macrospace are called using the assigned function name.
</para></listitem></varlistentry>
<varlistentry><term>SourceFile (const char *) - input</term>
<listitem><para>is the address of the ASCII file specification for the Rexx procedure
source file. When a file extension is not supplied, .CMD is used. When the full
path is not specified, the current directory and path are searched.
</para></listitem></varlistentry>
<varlistentry><term>Position (size_t) - input</term>
<listitem><para>is the position in the Rexx external function search order.
Possible values are:
<variablelist>
<varlistentry><term>RXMACRO_SEARCH_BEFORE</term>
<listitem><para>The Rexx interpreter locates the function before any registered
functions or external Rexx files.
</para></listitem></varlistentry>
<varlistentry><term>RXMACRO_SEARCH_AFTER</term>
<listitem><para>The Rexx interpreter locates the function after any registered
functions or external Rexx files.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="addmacrorc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="5*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="4*" />
<tbody>
<row>
<entry>RXMACRO_OK</entry>
<entry>0</entry>
<entry>The call to the function completed successfully.</entry>
</row>
<row>
<entry>RXMACRO_NO_STORAGE</entry>
<entry>1</entry>
<entry>There was not enough memory to complete the requested
function.</entry>
</row>
<row>
<entry>RXMACRO_SOURCE_NOT_FOUND</entry>
<entry>7</entry>
<entry>The requested file was not found.</entry>
</row>
<row>
<entry>RXMACRO_INVALID_POSITION</entry>
<entry>8</entry>
<entry>An invalid search-order position request flag was used.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para></para>
</section>
</section>

<section id="dropmacro"><title>RexxDropMacro</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>macrospace interface</secondary>
<tertiary>RexxDropMacro</tertiary></indexterm>
<indexterm><primary>RexxDropMacro</primary></indexterm>
<indexterm><primary>macrospace interface</primary>
<secondary>RexxDropMacro</secondary></indexterm>
<para>RexxDropMacro removes a Rexx procedure from the macrospace.</para>
<programlisting language="C++">
retc = RexxDropMacro(FuncName);
</programlisting>

<section id="dropmacroparm"><title>Parameter</title>
<para></para>
<variablelist>
<varlistentry><term>FuncName (const char *) - input</term>
<listitem><para>is the address of the ASCII function name.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="dropmacrorc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXMACRO_OK</entry>
<entry>0</entry>
<entry>The call to the function completed successfully.</entry>
</row>
<row>
<entry>RXMACRO_NOT_FOUND</entry>
<entry>2</entry>
<entry>The requested function was not found in the macrospace.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>

<section id="clearmacrospace"><title>RexxClearMacroSpace</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>macrospace interface</secondary>
<tertiary>RexxClearMacroSpace</tertiary></indexterm>
<indexterm><primary>RexxClearMacroSpace</primary></indexterm>
<indexterm><primary>macrospace interface</primary>
<secondary>RexxClearMacroSpace</secondary></indexterm>
<para>RexxClearMacroSpace removes all loaded Rexx procedures from the
macrospace.</para>
<programlisting language="C++">
retc = RexxClearMacroSpace();
</programlisting>

<section id="clearmacrospacerc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXMACRO_OK</entry>
<entry>0</entry>
<entry>The call to the function completed successfully.</entry>
</row>
<row>
<entry>RXMACRO_NOT_FOUND</entry>
<entry>2</entry>
<entry>The requested function was not found in the macrospace.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="clearmacrospaceremark"><title>Remarks</title>
<para>RexxClearMacroSpace must be used with care. This function removes all functions
from the macrospace, including functions loaded by other processes.</para>
</section>
</section>

<section id="savemacrospace"><title>RexxSaveMacroSpace</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>macrospace interface</secondary>
<tertiary>RexxSaveMacroSpace</tertiary></indexterm>
<indexterm><primary>RexxSaveMacroSpace</primary></indexterm>
<indexterm><primary>macrospace interface</primary>
<secondary>RexxSaveMacroSpace</secondary></indexterm>
<para>RexxSaveMacroSpace saves all or part of the macrospace Rexx procedures
to a disk file.</para>
<programlisting language="C++">
retc = RexxSaveMacroSpace(FuncCount, FuncNames, MacroLibFile);
</programlisting>

<section id="savemacrospaceparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>FuncCount (size_t) - input</term>
<listitem><para>Number of Rexx procedures to be saved.
</para></listitem></varlistentry>
<varlistentry><term>FuncNames (const char **) - input</term>
<listitem><para>is the address of a list of ASCII function names.
<emphasis role="italic">FuncCount</emphasis> gives
the size of the function list.
</para></listitem></varlistentry>
<varlistentry><term>MacroLibFile (const char *) - input</term>
<listitem><para>is the address of the ASCII macrospace file name. If
<emphasis role="italic">MacroLibFile</emphasis> already exists, it is
replaced with the new file.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="savemacrospacerc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="5*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="4*" />
<tbody>
<row>
<entry>RXMACRO_OK</entry>
<entry>0</entry>
<entry>The call to the function completed successfully.</entry>
</row>
<row>
<entry>RXMACRO_NOT_FOUND</entry>
<entry>2</entry>
<entry>The requested function was not found in the macrospace.</entry>
</row>
<row>
<entry>RXMACRO_EXTENSION_REQUIRED</entry>
<entry>3</entry>
<entry>An extension is required for the macrospace file name.</entry>
</row>
<row>
<entry>RXMACRO_FILE_ERROR</entry>
<entry>5</entry>
<entry>An error occurred accessing a macrospace file.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="savemacrospaceremark"><title>Remarks</title>
<para>When <emphasis role="italic">FuncCount</emphasis> is 0 or
<emphasis role="italic">FuncNames</emphasis> is null, RexxSaveMacroSpace
saves all functions in the macrospace.</para>
<para>Saved macrospace files can be used only with the same interpreter version
that created the images. If RexxLoadMacroSpace is called to load a saved macrospace
and the release level or service level is incorrect, RexxLoadMacroSpace fails.
The Rexx procedures must then be reloaded individually from the original source
programs.</para>
</section>
</section>

<section id="loadmacrospace"><title>RexxLoadMacroSpace</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>macrospace interface</secondary>
<tertiary>RexxLoadMacroSpace</tertiary></indexterm>
<indexterm><primary>RexxLoadMacroSpace</primary></indexterm>
<indexterm><primary>macrospace interface</primary>
<secondary>RexxLoadMacroSpace</secondary></indexterm>
<para>RexxLoadMacroSpace loads all or part of the Rexx procedures from a saved
macrospace file.</para>
<programlisting language="C++">
retc = RexxLoadMacroSpace(FuncCount, FuncNames, MacroLibFile);
</programlisting>

<section id="loadmacrospaceparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>FuncCount (size_t) - input</term>
<listitem><para>is the number of Rexx procedures to load from the saved
macrospace.
</para></listitem></varlistentry>
<varlistentry><term>FuncNames (const char **) - input</term>
<listitem><para>is the address of a list of Rexx function names.
<emphasis role="italic">FuncCount</emphasis> gives
the size of the function list.
</para></listitem></varlistentry>
<varlistentry><term>MacroLibFile (const char *) - input</term>
<listitem><para>is the address of the saved macrospace file name.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="loadmacrospacerc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="5*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="4*" />
<tbody>
<row>
<entry>RXMACRO_OK</entry>
<entry>0</entry>
<entry>The call to the function completed successfully.</entry>
</row>
<row>
<entry>RXMACRO_NO_STORAGE</entry>
<entry>1</entry>
<entry>There was not enough memory to complete the requested
function.</entry>
</row>
<row>
<entry>RXMACRO_NOT_FOUND</entry>
<entry>2</entry>
<entry>The requested function was not found in the macrospace.</entry>
</row>
<row>
<entry>RXMACRO_ALREADY_EXISTS</entry>
<entry>4</entry>
<entry>Duplicate functions cannot be loaded from a macrospace
file.</entry>
</row>
<row>
<entry>RXMACRO_FILE_ERROR</entry>
<entry>5</entry>
<entry>An error occurred accessing a macrospace file.</entry>
</row>
<row>
<entry>RXMACRO_SIGNATURE_ERROR</entry>
<entry>6</entry>
<entry>A macrospace save file does not contain valid function
images.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<section id="loadmacrospaceremark"><title>Remarks</title>
<para>When <emphasis role="italic">FuncCount</emphasis> is 0 or
<emphasis role="italic">FuncNames</emphasis> is null, RexxLoadMacroSpace
loads all Rexx procedures from the saved file.</para>
<para>If a RexxLoadMacroSpace call replaces an existing macrospace Rexx procedure,
the entire load request is discarded and the macrospace remains unchanged.</para>
</section>
</section>

<section id="querymacro"><title>RexxQueryMacro</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>macrospace interface</secondary>
<tertiary>RexxQueryMacro</tertiary></indexterm>
<indexterm><primary>RexxQueryMacro</primary></indexterm>
<indexterm><primary>macrospace interface</primary>
<secondary>RexxQueryMacro</secondary></indexterm>
<para>RexxQueryMacro searches the macrospace for a specified function.</para>
<programlisting language="C++">
retc = RexxQueryMacro(FuncName, Position)
</programlisting>

<section id="querymacroparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>FuncName (const char *) - input</term>
<listitem><para>is the address of an ASCII function name.
</para></listitem></varlistentry>
<varlistentry><term>Position (unsigned short *) - output</term>
<listitem><para>is the address of an unsigned short integer flag. If the
function is loaded in the macrospace,
<emphasis role="italic">Position</emphasis> is set to the search-order position
of the current function.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="querymacrorc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="4*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="5*" />
<tbody>
<row>
<entry>RXMACRO_OK</entry>
<entry>0</entry>
<entry>The call to the function completed successfully.</entry>
</row>
<row>
<entry>RXMACRO_NOT_FOUND</entry>
<entry>2</entry>
<entry>The requested function was not found in the macrospace.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>

<section id="reordermacro"><title>RexxReorderMacro</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>macrospace interface</secondary>
<tertiary>RexxReorderMacro</tertiary></indexterm>
<indexterm><primary>RexxReorderMacro</primary></indexterm>
<indexterm><primary>macrospace interface</primary>
<secondary>RexxReorderMacro</secondary></indexterm>
<para>RexxReorderMacro changes the search order position of a loaded macrospace
function.</para>
<programlisting language="C++">
retc = RexxReorderMacro(FuncName, Position)
</programlisting>

<section id="reordermacroparm"><title>Parameters</title>
<para></para>
<variablelist>
<varlistentry><term>FuncName (const char *) - input</term>
<listitem><para>is the address of an ASCII macrospace function name.
</para></listitem></varlistentry>
<varlistentry><term>Position (ULONG) - input</term>
<listitem><para>is the new search-order position of the macrospace function.
Possible values are:
<variablelist>
<varlistentry><term>RXMACRO_SEARCH_BEFORE</term>
<listitem><para>The Rexx interpreter locates the function before any registered
functions or external Rexx files.
</para></listitem></varlistentry>
<varlistentry><term>RXMACRO_SEARCH_AFTER</term>
<listitem><para>The Rexx interpreter locates the function after any registered
functions or external Rexx files.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="reordermacrorc"><title>Return Codes</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3">
<colspec colnum="1" colwidth="5*" />
<colspec colnum="2" colwidth="1*" />
<colspec colnum="3" colwidth="4*" />
<tbody>
<row>
<entry>RXMACRO_OK</entry>
<entry>0</entry>
<entry>The call to the function completed successfully.</entry>
</row>
<row>
<entry>RXMACRO_NOT_FOUND</entry>
<entry>2</entry>
<entry>The requested function was not found in the macrospace.</entry>
</row>
<row>
<entry>RXMACRO_INVALID_POSITION</entry>
<entry>8</entry>
<entry>An invalid search-order position request flag was used.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
</section>
</section>

<!-- ooRexx doesn't support WSH anymore
<section id="wshintf"><title>Windows Scripting Host Interface</title>
<indexterm><primary>apartment-threading and Windows Scripting Host</primary></indexterm>
<indexterm><primary>Windows Scripting Host interface</primary></indexterm>
<para>The purpose of this section is to describe any behaviors specific to Object
Rexx that the designer of a Windows Scripting Host (WSH) should be
aware of. It is assumed that the reader is already familiar with how to do
that, or has the appropriate documentation at hand. For further information,
see "Windows Scripting Host Engine", in
<citetitle pubwork="book">Open Object Rexx: Reference</citetitle>.</para>

<section id="wshconcy"><title>Concurrency</title>
<indexterm><primary>concurrency and Windows Scripting Host</primary></indexterm>
<indexterm><primary>multithreading and Windows Scripting Host</primary></indexterm>
<para>Object Rexx is a multithreaded program. (See Concurrency, in
<citetitle>Object Rexx for Windows: Reference</citetitle>.)
The closest Windows model is the free-threaded model for dealing with multiple threads.
The WSH controls are typically apartment-threaded. Therefore, since Object
Rexx does not restrict its callers to any particular thread, and it passes
on any exterior calls in the thread context in which it was received, then
for all practical purposes it should be treated as an apartment-threaded
program.</para>
</section>

<section id="wshfnosp"><title>WSH Features</title>

<section id="wq74"><title>COM Interfaces</title>
<indexterm><primary>COM interfaces for Windows Scripting Host</primary></indexterm>
<para>There are several interfaces that a WSH engine can use. Object Rexx does
not support all of them; some are supported, but created dynamically. Since
the dynamically-supported interfaces will not appear in an OLE viewer, they
are listed here.</para>
<para>The following interfaces are fully supported:</para>
<itemizedlist>
<listitem><para>IUnknown</para></listitem>
<listitem><para>IActiveScriptParse</para></listitem>
<listitem><para>IActiveScriptError</para></listitem>
<listitem><para>IActiveScriptParseProcedure</para></listitem>
<listitem><para>IObjectSafety</para></listitem></itemizedlist>
<para>While Object Rexx has code for all of the methods of an interface that
it supports, all methods may not be implemented. The methods that are not
implemented will return E_NOTIMPL.</para>
<para> The following interfaces are supported:</para>
<itemizedlist>
<listitem><para>IDispatch
<itemizedlist>
<listitem><para>GetIDsOfNames</para></listitem>
<listitem><para>Invoke</para></listitem></itemizedlist></para></listitem>
<listitem><para>IDispatchEx
<itemizedlist>
<listitem><para>GetDispID - but does not support dynamic creation of properties
or methods.</para></listitem>
<listitem><para>InvokeEx - but does not support dynamic creation of properties
or methods.</para></listitem>
<listitem><para>GetMemberName</para></listitem>
<listitem><para>GetNextDispID</para></listitem></itemizedlist></para></listitem>
<listitem><para>IActiveScript
<itemizedlist>
<listitem><para>SetScriptSite</para></listitem>
<listitem><para>GetScriptState</para></listitem>
<listitem><para>SetScriptState</para></listitem>
<listitem><para>Close</para></listitem>
<listitem><para>AddNamedItem</para></listitem>
<listitem><para>AddTypeLib</para></listitem>
<listitem><para>GetScriptDispatch</para></listitem>
</itemizedlist>
</para></listitem>
</itemizedlist>
</section>

<section id="wshscdeb"><title> Script Debugging</title>
<para>Object Rexx does not support the WSH Script Debugging facilities. For the
best techniques for debugging an Object Rexx script, refer to the section
on the Trace keyword in "Keyword Instructions", in
<citetitle pubwork="book">Open Object Rexx: Reference</citetitle>.</para>
</section>

<section id="wshdcom"><title>DCOM</title>
<para>Object Rexx does not support DCOM.</para>
</section>
</section>
</section>
-->
</chapter>
