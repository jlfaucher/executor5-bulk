<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "rexxextensions.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: RexxExtensions Library XML File
    #
    # Copyright (c) 2010-2017, Rexx Language Association. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<chapter id="csvstream">
<title>csvStream Class</title>
<para>
The csvStream class extends the Stream class to read &amp; write CSV files directly to Collection Objects.
</para>
<para>
The csvStream Class is a subclass of the Stream Class.
</para>

<section>
<title>Translation of data involved in the csvStream class</title>
<para>
CSV file literals are surrounded by quotes "". These are removed by CSVLineIn and inserted by CSVLineOut.
Quotes within CSV data are represented self escaped ie: " appears as "". These are translated by the CSVLineIn 
and CSVLineOut methods. CSVLineOut encapsulates non-numeric fields in "" unless they already are.
CSV literal strings can contain line-end sequences. To create multi-line fields use the line-end character provided 
by the operating system dependant ooRexx local variable .endofline.
</para>
</section>

<section>
<title>Methods The csvStream Class defines</title>
<indexterm><primary>Methods, csvStream</primary></indexterm>
<indexterm><primary>csvStream</primary>
<secondary>Methods</secondary></indexterm>
<simplelist type="vert" columns="1">
   <member>CLOSE (overrides stream class method)</member>
   <member>CSVLINEIN</member>
   <member>CSVLINEOUT</member>
   <member>GETHEADERS</member>
   <member>SETHEADERS</member>
   <member>INIT (overrides stream class method)</member>
   <member>OPEN (overrides stream class method)</member>
   <member>STATE (overrides stream class method)</member>
   <member>DESCRIPTION (overrides stream class method)</member>
</simplelist>
</section>


<section>
<title>Attributes of the csvStream Class</title>
<indexterm><primary>csvStream</primary>
<secondary>Attributes</secondary></indexterm>
<simplelist type="vert" columns="1">
   <member>HEADERS~FIELD(n)~NAME</member>
   <member>HEADERS~FIELD(n)~LITERAL</member>
   <member>SKIPHEADERS</member>
   <member>DELIMITER</member>
   <member>QUALIFIER</member>
   <member>STRIPOPTION</member>
   <member>STRIPCHAR</member>
</simplelist>
</section>

<section>
<title>Methods Inherited from the Stream Class</title>
<indexterm><primary>csvStream</primary>
<secondary>Inherited methods</secondary></indexterm>
<simplelist type="vert" columns="1">
   <member>ARRAYIN</member>
   <member>ARRAYOUT</member>
   <member>CHARIN</member>
   <member>CHAROUT</member>
   <member>CHARS</member>
   <member>COMMAND</member>
   <member>DESCRIPTION</member>
   <member>FLUSH</member>
   <member>LINEIN</member>
   <member>LINEOUT</member>
   <member>LINES</member>
   <member>MAKEARRAY</member>
   <member>POSITION</member>
   <member>QUALIFY</member>
   <member>QUERY</member>
   <member>SAY</member>
   <member>SEEK</member>
   <member>STATE</member>
   <member>SUPPLIER</member>
</simplelist>
</section>

<section>
<title>Methods inherited from the Object class</title>
<indexterm><primary>csvStream</primary>
<secondary>Inherited methods</secondary></indexterm>
<simplelist type="vert" columns="1">
   <member>NEW (Class method)</member>
   <member>Operator methods: =, ==, \=, &gt;&lt;, &lt;&gt;, \==</member>
   <member>CLASS</member>
   <member>COPY</member>
   <member>DEFAULTNAME></member>
   <member>HASMETHOD</member>
   <member>OBJECTNAME</member>
   <member>OBJECTNAME=</member>
   <member>REQUEST</member>
   <member>RUN</member>
   <member>SETMETHOD</member>
   <member>START</member>
   <member>STRING</member>
   <member>UNSETMETHOD</member>
</simplelist>
<note><para>
The Stream class also has available class methods that its metaclass, the Class class, defines.
</para></note>
</section>

<section>
<title>Methods</title>
<indexterm><primary>csvStream</primary>
<secondary>Methods</secondary></indexterm>

<section>
<title id="mthcsvastreamclose">Close Method</title>
<indexterm><primary>csvStream</primary>
<secondary>CLOSE method</secondary></indexterm>
<indexterm><primary>CLOSE method</primary>
<secondary>scvStream</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/csvstream_close.svg" scale="50" />
</imageobject>
</mediaobject>

<para>
Closes the stream that receives the message. CLOSE returns READY: if closing the stream is 
successful, or an appropriate error message. If you have tried to close an unopened file, then the 
CLOSE method returns a null string (""). If you specified headersExist when you created this instance 
then the headers will be updated to the stream at this point if they have been changed.
</para>
</section>

<section>
<title>CSVLineIn Method</title>
<indexterm><primary>csvStream</primary>
<secondary>CSVLINEIN method</secondary></indexterm>
<indexterm><primary>CSVLINEIN method</primary>
<secondary>scvStream</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/csvstream_csvlinein.svg" scale="50" />
</imageobject>
</mediaobject>

<para>
Reads and returns a row of CSV data from the stream. Note that a row of data may be stored in more 
than one logical line of the stream. An array is returned, the nth element of which contains the nth field 
from the Row.
</para>
<para>
Two other attributes exist after performing a CSVLineIn
</para>
<para>
<emphasis>Rawdata</emphasis> is a String Object containing the raw text that the row consists of.
</para>
<para>
<emphasis>Values</emphasis> is a Table Object mapping field data onto field-names. This is only available if headersExist is 
specified on the init method.
</para>
<para>
<emphasis>Badly formed CSV data.</emphasis>
Where the data read in by CSVLineIn is not well formed CSV data the results are unpredictable.    
The class can detect some errors in the incoming data, and where such an error is detected the 
STATE method will return ERROR and the DESCRIPTION method will give extra error information.
Where the provenance of the data is outside your control it would be well to check the STATE after every 
CSVLineIn.  Subsequent calls to CSVLineIn may be able to recover and return subsequent rows from the file 
but this should not be expected to be the norm.  Subsequent calls to CSVLineIn after an error will not
return the STATE to READY.  It will remain at ERROR until the Stream class resets it (ie: when you close
the CSVStream)
</para>
</section>

<section>
<title>CSVLineOut Method</title>
<indexterm><primary>csvStream</primary>
<secondary>CSVLINEOUT method</secondary></indexterm>
<indexterm><primary>CSVLINEOUT method</primary>
<secondary>scvStream</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/csvstream_csvlineout.svg" scale="50" />
</imageobject>
</mediaobject>

<para>
Writes a row of CSV data to a stream. Note that a row of data may be stored in more than one logical 
line of the stream. If the stream was instantiated with headersExist as .true then the collection-object 
may be a directory, table or stem object mapping headers onto CSV fields. Otherwise the collection-object must 
be an array or a collection with a makeArray method and the nth element of the collection will be 
placed in the nth field of the CSV file. Any occurrences of the Nil Object are stored as null strings in 
the file.
</para>
<note><para>
If the collection object is a Stem then a tail of 0 is ignored as by convention the 0 tail stores the 
number of tails on the stem.
</para></note>
</section>

<section>
<title>GetHeaders Method</title>
<indexterm><primary>csvStream</primary>
<secondary>GETHEADERS method</secondary></indexterm>
<indexterm><primary>GETHEADERS method</primary>
<secondary>scvStream</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/csvstream_getheaders.svg" scale="50" />
</imageobject>
</mediaobject>

<para>
Returns a csvStreamHeader object.
</para>
<para>
Get headers will return a csvStreamHeader object containing details of the column header names and whether 
they are literal values or not. Column header names that exist before the csvStream is opened are present as soon 
as the file is opened, but literal information will not be present till the first CSVLineIn or CSVLineOut is issued.
</para>
</section>

<section>
<title>INIT Method</title>
<indexterm><primary>csvStream</primary>
<secondary>INIT method</secondary></indexterm>
<indexterm><primary>INIT method</primary>
<secondary>scvStream</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/csvstream_init.svg" scale="50" />
</imageobject>
</mediaobject>

<para>
Initializes a stream object for a stream named name, but does not open the stream.
</para>
<para>
The second optional parameter if passed a value of 'H' (or .true) indicates that the first row of the 
stream is (or is to be) a row of headers containing the names of the CSV fields. Note that header fields 
are case sensitive. This means that 'name' and 'Name' and 'NAME' will all be treated as separate 
columns.
</para>
</section>

<section>
<title>OPEN Method</title>
<indexterm><primary>csvStream</primary>
<secondary>OPEN method</secondary></indexterm>
<indexterm><primary>OPEN method</primary>
<secondary>scvStream</secondary></indexterm>
<para>
Parameters are as the Stream class Open Method
</para>
<para>
Opens the stream to which you send the message and returns READY:. If the method is unsuccessful, it
returns an error message string in the same form that the DESCRIPTION method uses.
See the Stream Class Open Method for a fuller description.
</para>

<section>
<title>Changing the behaviour of a csvStream object</title>
<para>
Before issuing the Open message, you can affect the csvStream's behaviour by setting the attribute skipHeaders 
to .false. This will mean that the first row returned by CSVLineIn on a csvStream where headers exist is the 
header row, rather than the default behaviour which is to return the first row of data.
</para>
<para>
After issuing the OPEN message to a csvStream which has been opened with headers exist, the class will attempt 
to learn the nature of the fields by analysing the data. You can teach it by setting the headers field attributes name 
and literal. For instance:
</para>
<example>
<title>Describing header fields</title>
<programlisting>
/* set the name of the second field to 'Height' */
MyCsvStream~headers~field(2)~name='Height'

/* tell the stream to treat the 
third column as literal data rather than numeric */
MyCsvStream~headers~field(3)~literal= .true
</programlisting>
</example>
<para>
By default the delimiter csvStream expects is a comma (after all CSV stands for Comma Separated Variables) 
and literals are qualified by a double inverted comma. However you can create and read files with other delimiters 
or qualifiers by changing the attributes delimiter and qualifier after instantiating A csvStream object. For 
instance, to use ; as a delimiter and ' as a qualifier do the following:
</para>
<example>
<title>Describing field delimiters</title>
<programlisting>
MyCsvStream = .csvStream~new
MyCsvStream~delimiter=";"
MyCsvStream~qualifier="'" 
</programlisting>
</example>
<para>
If the attribute StripOption is set to 'L', 'T' or 'B' then data is stripped using that option before 
CSVLineIn inserts it in the returned array. The default of 'N' means no stripping is performed. One 
can specify which character to strip using the attribute stripChar which defaults to blank.
</para>
<example>
<title>Setting the strip option</title>
<programlisting>
MyCsvStream~StripOption = 'T' /* strip trailing blanks */
</programlisting>
</example>
<para>
or
</para>
<example>
<title>Removing leading zeros</title>
<programlisting>
MyCsvStream~StripOption = 'L' 
MyCsvStream~stripChar = '0' /* strip Leading zeroes */
</programlisting>
</example>
</section>
</section>

<section>
<title>SetHeaders Method</title>
<indexterm><primary>csvStream</primary>
<secondary>SETHEADERS method</secondary></indexterm>
<indexterm><primary>SETHEADERS method</primary>
<secondary>scvStream</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/csvstream_setheaders.svg" scale="50" />
</imageobject>
</mediaobject>

<para>
Passed a csvStreamHeader object will apply it to the csvStream. Together with Get Headers this allows you to 
base one CSV file on another.
</para>
</section>
</section>

<section>
<title>Attributes</title>

<section>
<title>DELIMETER Attribute</title>
<indexterm><primary>csvStream</primary>
<secondary>DELIMETER attribute</secondary></indexterm>
<indexterm><primary>DELIMETER attribute</primary>
<secondary>scvStream</secondary></indexterm>
<para>
This is the character which delimits the fields (as long as it does not appear within a 
literal). In a standard CSV file it is a comma ,. See Changing the behaviour of a 
csvStream object under the OPEN method for an example of changing the delimiter.
</para>
</section>

<section>
<title>HEADERS Attribute</title>
<indexterm><primary>csvStream</primary>
<secondary>HEADERS attribute</secondary></indexterm>
<indexterm><primary>HEADERS attribute</primary>
<secondary>scvStream</secondary></indexterm>
<para>
Access is available to the Field definition table for files with headers. There are two 
entries, NAME &amp; LITERAL. NAME is the Name for that particular column. If 
LITERAL is .true then that column will be treated as a literal even if the data in it is 
numeric. If any entry in a column is non-numeric then the entire column is treated as 
a literal. See Changing the behaviour of a csvStream object under the OPEN method 
for an example of accessing the table.
</para>
</section>

<section>
<title>QUALIFIER Attribute</title>
<indexterm><primary>csvStream</primary>
<secondary>QUALIFIER attribute</secondary></indexterm>
<indexterm><primary>QUALIFIER attribute</primary>
<secondary>scvStream</secondary></indexterm>
<para>
The Qualifier is the character that surrounds literal fields. Delimiters that appear 
within literal fields are ignored. In a standard CSV file the qualifier is a double 
quotation mark ("). See Changing the behaviour of a csvStream object under the 
OPEN method for an example of changing the qualifier.
</para>
</section>

<section>
<title>SKIPHEADERS Attribute</title>
<indexterm><primary>csvStream</primary>
<secondary>SKIPHEADERS attribute</secondary></indexterm>
<indexterm><primary>SKIPHEADERS attribute</primary>
<secondary>scvStream</secondary></indexterm>
<para>
See <emphasis>Changing the behaviour of a csvStream object</emphasis> under the OPEN method.
</para>
</section>
</section>

<section>
<title>Examples</title>
<indexterm><primary>csvStream</primary>
<secondary>Example code</secondary></indexterm>
<example>
<title>Files without headers</title>
<programlisting>
<![CDATA[
csv = .csvStream~new('c:\MyData.csv') /* 2nd arg defaults to no headers */
/* csv~skipHeaders = .false                UnNoOp to return header line */

csv~open('write')                       /*=File looks like this=*/
csv~CSVLineOut(.array~of('red','stop')) /* "red","stop"         */
csv~CSVLineOut(.array~of('green','go')) /* "green","go"         */
csv~close                               /*======================*/ 

csv~open('read')                        /*=======Returns========*/
do while csv~chars > 0                  /* New record           */
   dataArr = csv~CSVLineIn              /* field 1: red         */
   say 'New record'                     /* field 2: stop        */
   do I = 1 to dataArr~last             /* New record           */
   say 'field' I':' dataArr[I]          /* field 1: green       */
   end                                  /* field 2: go          */
end                                     /*======================*/
csv~close

::requires 'csvstream.cls'
</programlisting>
<para>
Files with headers:
</para>
<programlisting>
csv = .csvStream~new('c:\headered.csv',.true)
csv~open          /* Stream class defaults to both ie:readWrite */
myTable = .table~new
myTable~put('red','colour')
myTable~put('stop','action')
csv~CSVLineout(myTable)
myTable~put('green','colour')
myTable~put('go','action')
csv~CSVLineout(myTable) 
csv~close

Csv~open('read')                        /*=======Returns========*/
Do while csv~chars > 0                  /* new record           */
   Csv~csvLineIn                        /* colour: red          */
   Say 'new record'                     /* action: stop         */ 
   Do field over csv~values             /* new record           */
      Say field':' csv~values~at(field) /* colour: green        */
   End                                  /* action: go           */
End                                     /*======================*/
csv~close

::requires 'csvstream.cls'
</programlisting>
<para>
Example with error checking 
</para>
<programlisting>
csv = .csvStream~new('c:\BadData.csv')

csv~open('read')
if csv~state = 'READY'
then do              
   do while csv~chars > 0             
      dataArr = csv~CSVLineIn
      if csv~state = 'ERROR'
      then do
         say 'BAD DATA IN CSV FILE -' csv~description
         leave
      end
      say 'New record'                
      do I = 1 to dataArr~last        
      say 'field' I':' dataArr[I]     
      end                             
   end
   csv~close
end
else say 'COULD NOT OPEN CSV FILE -' csv~description                                

::requires 'csvstream.cls'
]]>
</programlisting>
</example>
</section>
</chapter>

