<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog Reference SGML file.
    #
    # Copyright (c) 2005-2010, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<chapter id="chpDialogObject"><title>The Dialog Object</title>
<indexterm><primary>The Dialog Object</primary></indexterm>
<para>
  All instantiated Rexx dialog objects have a broad base of methods in common. These methods are the same for all
  dialogs regardless of the class of the dialog or how the <link linkend="ovvDialogTemplate">dialog template</link> is
  created.
</para>
<para>
  The dialog object here is an abstract concept, used to make it simpler to understand the basic concepts. To
  instantiate a dialog object you create a subclass of one of the concrete dialog classes provided by the ooDialog
  framework, such as the <link linkend="clsUserDialog">UserDialog Class</link>, <link linkend="clsResDialog">ResDialog
  Class</link>, or <link linkend="clsRcDialog">RcDialog Class</link>. This chapter provides the reference for the
  constants, attributes, and methods that are common to all dialog objects. See the specific dialog subclass for methods
  that are unique to the subclass.
</para>

<section id="sctMethodsDlgObject"><title>Method Table</title>
<para>
  The following table lists the class methods, attributes, and instance methods that all dialogs have in common:
<table id="tblMethodsDlgObject" frame="all"> <title>Dialog Object Method Reference</title>
<tgroup cols="2">
<thead>
<row>
<entry>Dialog Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
<entry align="center"><emphasis role="bold"></emphasis></entry>
</row>
<row>
<entry><link linkend="mthNewDialogObject">new</link></entry>
<entry>Instantiates a new dialog object.</entry>
</row>
<row>
<entry><link linkend="mthClsGetFontName">getFontName</link></entry>
<entry>Returns the default font for all dialogs.</entry>
</row>
<row>
<entry><link linkend="mthClsGetFontSize">getFontSize</link></entry>
<entry>Returns the default font size for all dialogs.</entry>
</row>
<row>
<entry><link linkend="mthClsSetDefaultFont">setDefaultFont</link></entry>
<entry>Sets the default font name and size for all dialogs.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Attributes</emphasis></entry>
<entry align="center"><emphasis role="bold"></emphasis></entry>
</row>
<row>
<entry><link linkend="atrAutoDetect">autoDetect</link></entry>
<entry>If automatic data field detection is on or off.</entry>
</row>
<row>
<entry><link linkend="atrAutomaticMethods">automaticMethods</link></entry>
<entry>A queue containing the methods that are started concurrently before the execution of the dialog. </entry>
</row>
<row>
<entry><link linkend="atrBkgBitmap">bkgBitmap</link></entry>
<entry>The handle to a bitmap that is displayed as the dialog's background.</entry>
</row>
<row>
<entry><link linkend="atrBkgBrushBmp">bkgBrushBmp</link></entry>
<entry>The handle to a bitmap brush that is used to draw the dialog's background.</entry>
</row>
<row>
<entry><link linkend="atrConstDir">constDir</link></entry>
<entry>A directory object that maps symbolic resource IDS to their numeric IDs</entry>
</row>
<row>
<entry><link linkend="atrDlgHandle">dlgHandle</link></entry>
<entry>The window handle of the dialog.</entry>
</row>
<row>
<entry><link linkend="wbdoFactorX">factorX</link></entry>
<entry>The horizontal size of one dialog unit in pixels. (Inaccurate.)</entry>
</row>
<row>
<entry><link linkend="wbdoFactorY">factorY</link></entry>
<entry>The vertical size of one dialog unit in pixels. (Inaccurate.)</entry>
</row>
<row>
<entry><link linkend="wbdoSizeX">sizeX</link></entry>
<entry>The width of the dialog in dialog units. (Inaccurate.)</entry>
</row>
<row>
<entry><link linkend="wbdoSizeY">sizeY</link></entry>
<entry>The height of the dialog in dialog units. (Inaccurate.)</entry>
</row>
<row>
<entry><link linkend="wbdoPixelCX">pixelCX</link></entry>
<entry>The width of the dialog in pixels.</entry>
</row>
<row>
<entry><link linkend="wbdoPixelCY">pixelCY</link></entry>
<entry>The height of the dialog in pixels.</entry>
</row>
<row>
<entry><link linkend="wbdoHwnd">hwnd</link></entry>
<entry>The window handle of the dialog.</entry>
</row>
<row>
<entry><link linkend="wbdoInitCode">initCode</link></entry>
<entry>Reflects if the object initialization was successful.</entry>
</row>
<row>
<entry><link linkend="atrFontName">fontName</link></entry>
<entry>Name of the dialog's font.</entry>
</row>
<row>
<entry><link linkend="atrFontSize">fontSize</link></entry>
<entry>Point size of the dialog's font.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
<entry align="center"><emphasis role="bold"></emphasis></entry>
</row>
<row>
<entry>AbsRect2LogRect</entry>
<entry><link linkend="absrect2logrect">AbsRect2LogRect</link></entry>
</row>
<row>
<entry>addAutoStartMethod</entry>
<entry><link linkend="mthAddAutoStartMethod">addAutoStartMethod</link></entry>
</row>
<row>
<entry>AddComboEntry</entry>
<entry><link linkend="h000307">AddComboEntry</link></entry>
</row>
<row>
<entry>AddListEntry</entry>
<entry><link linkend="h000380">AddListEntry</link></entry>
</row>
<row>
<entry>addUserMsg</entry>
<entry><link linkend="mthAddUserMsg">addUserMsg</link></entry>
</row>
<row>
<entry>BackgroundBitmap</entry>
<entry><link linkend="h001053">BackgroundBitmap</link></entry>
</row>
<row>
<entry>BackgroundColor</entry>
<entry><link linkend="background">BackgroundColor</link></entry>
</row>
<row>
<entry>Cancel</entry>
<entry><link linkend="mthCancel">Cancel</link></entry>
</row>
<row>
<entry>CaptureMouse</entry>
<entry><link linkend="capturemouse">CaptureMouse</link></entry>
</row>
<row>
<entry>Center</entry>
<entry><link linkend="h001370">Center</link></entry>
</row>
<row>
<entry>ChangeBitmapButton</entry>
<entry><link linkend="h000170">ChangeBitmapButton</link></entry>
</row>
<row>
<entry>ChangeComboEntry</entry>
<entry><link linkend="h000352">ChangeComboEntry</link></entry>
</row>
<row>
<entry>ChangeListEntry</entry>
<entry><link linkend="h000425">ChangeListEntry</link></entry>
</row>
<row>
<entry>Clear</entry>
<entry><link linkend="clear">Clear</link></entry>
</row>
<row>
<entry>ClearButtonRect</entry>
<entry><link linkend="h000622">ClearButtonRect</link></entry>
</row>
<row>
<entry>ClearMessages</entry>
<entry><link linkend="h000763">ClearMessages</link></entry>
</row>
<row>
<entry>ClearRect</entry>
<entry><link linkend="h000640">ClearRect</link></entry>
</row>
<row>
<entry>ClearWindowRect</entry>
<entry><link linkend="h000631">ClearWindowRect</link></entry>
</row>
<row>
<entry>ClientToScreen</entry>
<entry><link linkend="clienttoscreen">ClientToScreen</link></entry>
</row>
<row>
<entry>CombineELwithSB</entry>
<entry><link linkend="h000816">CombineELwithSB</link></entry>
</row>
<row>
<entry>ComboAddDirectory</entry>
<entry><link linkend="h000362">ComboAddDirectory</link></entry>
</row>
<row>
<entry>ComboDrop</entry>
<entry><link linkend="h000372">ComboDrop</link></entry>
</row>
<row>
<entry><link linkend="mthConnectAllSBEvents">connectAllSBEvents</link></entry>
<entry>Connects all event notifications from a scroll bar control to a single method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="mthInstallAnimatedButton">installAnimatedButton</link></entry>
<entry>Installs an animated button and runs it concurrently with the main activity.</entry>
</row>
<row>
<entry><link linkend="mthInstallBitmapButton">installBitmapButton</link></entry>
<entry>installBitmapButton</entry>
</row>
<row>
<entry>connectButtonEvent</entry>
<entry><link linkend="mthConnectButtonEvent">connectButtonEvent</link></entry>
</row>
<row>
<entry>connectCheckBox</entry>
<entry><link linkend="mthConnectCheckBox">connectCheckBox</link></entry>
</row>
<row>
<entry>connectComboBox</entry>
<entry><link linkend="mthConnectComboBox">connectComboBox</link></entry>
</row>
<row>
<entry><link linkend="mthConnectCommandEvents">connectCommandEvents</link></entry>
<entry>Connects a command event notification from a dialog control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="mthConnectDraw">connectDraw</link></entry>
<entry>Connects the draw item event notification to a method in the Rexx dialog.</entry>
</row>
<row>
<entry>connectEdit</entry>
<entry><link linkend="mthConnectEdit">connectEdit</link></entry>
</row>
<row>
<entry><link linkend="mthConnectFKeyPressBaseDialog">connectFKeyPress</link></entry>
<entry>Connects a F key press (a F key is typed) with a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="mthConnectHelp">connectHelp</link></entry>
<entry>Connects the Windows Help event to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="mthConnectKeyPressBaseDialog">connectKeyPress</link></entry>
<entry>Connects a key press (a key is typed) with a method in the Rexx dialog.</entry>
</row>
<row>
<entry>connectListBox</entry>
<entry><link linkend="mthConnectListBox">connectListBox</link></entry>
</row>
<row>
<entry>ConnectListControl</entry>
<entry><link linkend="connectlistcontrol">ConnectListControl</link></entry>
</row>
<row>
<entry>ConnectSliderControl</entry>
<entry><link linkend="connectslidercontrol">ConnectSliderControl</link></entry>
</row>
<row>
<entry>ConnectTreeControl</entry>
<entry><link linkend="connecttreecontrol">ConnectTreeControl</link></entry>
</row>
<row>
<entry><link linkend="mthConnectUpDownEvent">connectUpDownEvent</link></entry>
<entry>Connects an event notification from an UpDown control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="mthConnectMouseCapture">connectMouseCapture</link></entry>
<entry>Connects the losing the mouse capture event notification to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="mthConnectMove">connectMove</link></entry>
<entry>Connects the move event notification to a method in the Rexx dialog.</entry>
</row>
<row>
<entry>ConnectMultiListBox</entry>
<entry><link linkend="mthConnectMultiListBox">ConnectMultiListBox</link></entry>
</row>
<row>
<entry><link linkend="mthConnectPosChanged">connectPosChanged</link></entry>
<entry>Connects the position has changed event notification to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="mthConnectRadioButton">connectRadioButton</link></entry>
<entry>Creates and connects a data attribute to an uderlying radio button control.</entry>
</row>
<row>
<entry><link linkend="mthConnectResize">connectResize</link></entry>
<entry>Connects the size event notification to a method in the Rexx dialog</entry>
</row>
<row>
<entry><link linkend="mthConnectButtonEvent">connectButtonEvent</link></entry>
<entry>Connect an event notification from a button control to a method in the Rexx Dialog</entry>
</row>
<row>
<entry><link linkend="mthConnectCommandEvents">connectCommandEvents</link></entry>
<entry>Connects a command event notification from a dialog control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="mthConnectComboBoxEvent">connectComboBoxEvent</link></entry>
<entry>Connects an event notification from a combo box to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="mthConnectNotifyEvent">connectNotifyEvent</link></entry>
<entry>Connects a generic event notification from a dialog control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="mthConnectEditEvent">connectEditEvent</link></entry>
<entry>Connects an event notification from an edit control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="mthConnectListBoxEvent">connectListBoxEvent</link></entry>
<entry>Connects an event notification from a list box control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="mthConnectListViewEvent">connectListViewEvent</link></entry>
<entry>Connects an event notification from a list view control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="mthConnectScrollBarEvent">connectScrollBarEvent</link></entry>
<entry>Connects an event notification from a scroll bar control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="mthConnectTrackBarEvent">connectTrackBarEvent</link></entry>
<entry>Connects an event notification from a track bar control to a method in the Rexx dialog. </entry>
</row>
<row>
<entry>connectStaticEvent</entry>
<entry><link linkend="mthConnectStaticEvent">connectStaticEvent</link></entry>
</row>
<row>
<entry><link linkend="mthConnectTabEvent">connectTabEvent</link></entry>
<entry>Connects an event notification from a tab control to a method in the Rexx dialog.</entry> </row>
<row>
<entry><link linkend="mthConnectTreeViewEvent">connectTreeViewEvent</link></entry>
<entry>Connects an event notification from a tree view control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="mthDefListDragHandler">defListDragHandler</link></entry>
<entry>Default implementation of a drag and drop handler for a list view control.</entry>
</row>
<row>
<entry><link linkend="mthDefTreeDragHandler">defTreeDragHandler</link></entry>
<entry>Default implementation of a drag and drop handler for a tree view control.</entry>
</row>
<row>
<entry><link linkend="mthConnectEachSBEvent">connectEachSBEvent</link></entry>
<entry>Connects each specified event notification from a scroll bar to a separate method in the Rexx dialog.</entry>
</row>
<row>
<entry>CreateBrush</entry>
<entry><link linkend="h001026">CreateBrush</link></entry>
</row>
<row>
<entry><link linkend="mthCreateFontEx">createFontEx</link></entry>
<entry>Retrieves a handle to a logical font from the system font manager</entry>
</row>
<row>
<entry>CreatePen</entry>
<entry><link linkend="h001035">CreatePen</link></entry>
</row>
<row>
<entry>Cursor_AppStarting</entry>
<entry><link linkend="cursorappstarting">Cursor_AppStarting</link></entry>
</row>
<row>
<entry>Cursor_Arrow</entry>
<entry><link linkend="cursorarrow">Cursor_Arrow</link></entry>
</row>
<row>
<entry>Cursor_Cross</entry>
<entry><link linkend="cursorcross">Cursor_Cross</link></entry>
</row>
<row>
<entry>Cursor_No</entry>
<entry><link linkend="cursorno">Cursor_No</link></entry>
</row>
<row>
<entry>CursorPos</entry>
<entry><link linkend="cursorpos">CursorPos</link></entry>
</row>
<row>
<entry>Cursor_Wait</entry>
<entry><link linkend="cursorwait">Cursor_Wait</link></entry>
</row>
<row>
<entry>DeleteComboEntry</entry>
<entry><link linkend="h000326">DeleteComboEntry</link></entry>
</row>
<row>
<entry>DeleteFont</entry>
<entry><link linkend="mthDeleteFont">DeleteFont</link></entry>
</row>
<row>
<entry>DeleteListEntry</entry>
<entry><link linkend="h000399">DeleteListEntry</link></entry>
</row>
<row>
<entry>DeleteObject</entry>
<entry><link linkend="h001017">DeleteObject</link></entry>
</row>
<row>
<entry>DetermineSBPosition</entry>
<entry><link linkend="detersb">DetermineSBPosition</link></entry>
</row>
<row>
<entry><link linkend="wbdoEnable">enable</link></entry>
<entry>Enables the dialog.</entry>
</row>
<row>
<entry><link linkend="wbdoDisable">disable</link></entry>
<entry>Disables the dialog.</entry>
</row>
<row>
<entry><link linkend="mthIsVisible">isVisible</link></entry>
<entry>Tests if the dialog is visible.</entry>
</row>
<row>
<entry><link linkend="mthIsEnabled">isEnabled</link></entry>
<entry>Tests if the dialog is enabled.</entry>
</row>
<row>
<entry><link linkend="wbdoHide">hide</link></entry>
<entry>Makes the dialog invisible and repaints it.</entry>
</row>
<row>
<entry><link linkend="wbdoShowfast">showFast</link></entry>
<entry>Marks the dialog as visible.</entry>
</row>
<row>
<entry><link linkend="wbdoHideFast">hideFast</link></entry>
<entry>Marks the dialog as invisible</entry>
</row>
<row>
<entry><link linkend="wbdoDisplay">display</link></entry>
<entry>Shows or hides the dialog.</entry>
</row>
<row>
<entry><link linkend="wbdoUpdate">update</link></entry>
<entry>Invalidates the entire client area of the dialog.</entry>
</row>
<row>
<entry><link linkend="wbdoDraw">draw</link></entry>
<entry>Redraws the entire client area of the dialog immediately.</entry>
</row>
<row>
<entry><link linkend="wbdoRedrawClient">redrawClient</link></entry>
<entry>Redraws the entire client area of the dialog immediately.</entry>
</row>
<row>
<entry><link linkend="wbdoRedraw">redraw</link></entry>
<entry>Redraws the entire dialog window and all its child windows immediately.</entry>
</row>
<row>
<entry><link linkend="wbdoGetID">getID</link></entry>
<entry>Retrieves the identification number of the dialog.</entry>
</row>
<row>
<entry><link linkend="wbdoGetStyleRaw">getStyleRaw</link></entry>
<entry>Retrieves the numeric value of the dialog's style flags.</entry>
</row>
<row>
<entry><link linkend="wbdoGetExStyleRaw">getExStyleRaw</link></entry>
<entry>Retrieves the numeric value of the dialog's extended style flags.</entry>
</row>
<row>
<entry><link linkend="wbdoSetText">setText</link></entry>
<entry>Sets the text of the dialog.</entry>
</row>
<row>
<entry><link linkend="wbdoGetText">getText</link></entry>
<entry>Gets the text of the dialog.</entry>
</row>
<row>
<entry><link linkend="wbdoTitleEquals">title=</link></entry>
<entry>Sets the text of the dialog.</entry>
</row>
<row>
<entry><link linkend="wbdoSetTitle">setTitle</link></entry>
<entry>Sets the text of the dialog.</entry>
</row>
<row>
<entry><link linkend="wbdoTitle">title</link></entry>
<entry>Gets the text of the dialog.</entry>
</row>
<row>
<entry><link linkend="wbdoGetTextSizePx">getTextSizePx</link></entry>
<entry>Calculates the size needed for a string in pixels <emphasis role="bold">(preferred method.)</emphasis></entry>
</row>
<row>
<entry><link linkend="wbdoGetTextSizeScreen">getTextSizeScreen</link></entry>
<entry>Calculates the size needed for a string in pixels.</entry>
</row>
<row>
<entry><link linkend="wbdoSetRect">setRect</link></entry>
<entry>Moves and resizes the dialog, optionally, only one or the other.</entry>
</row>
<row>
<entry><link linkend="wbdoResizeTo">resizeTo</link></entry>
<entry>Resizes the dialog to the size specified in pixels.</entry>
</row>
<row>
<entry><link linkend="wbdoMoveTo">moveTo</link></entry>
<entry>Moves the dialog to the position specified in pixels.</entry>
</row>
<row>
<entry><link linkend="wbdoGetRealSize">getRealSize</link></entry>
<entry>Returns the size of the window in pixels as a <computeroutput>Size</computeroutput> object.</entry>
</row>
<row>
<entry><link linkend="wbdoGetRealPos">getRealPos</link></entry>
<entry>Returns the position of the window in pixels as a <computeroutput>Point</computeroutput> object.</entry>
</row>
<row>
<entry><link linkend="wbdoGetSize">getSize</link></entry>
<entry>Returns the size of the window in dialog units <emphasis role="bold">(not accurate.)</emphasis></entry>
</row>
<row>
<entry><link linkend="wbdoSendMessage">sendMessage</link></entry>
<entry>Sends a Windows message to the underlying window and returns its response as a whole number.</entry>
</row>
<row>
<entry><link linkend="wbdoSendMessageHandle">sendMessageHandle</link></entry>
<entry>Sends a Windows message to the underlying window and returns its response as a handle.</entry>
</row>
<row>
<entry>DisableItem</entry>
<entry><link linkend="h001229">DisableItem</link></entry>
</row>
<row>
<entry>disconnectKeyPress</entry>
<entry><link linkend="mthDisconnectKeyPressBaseDialog">disconnectKeyPress</link></entry>
</row>
<row>
<entry>DisplaceBitmap</entry>
<entry><link linkend="h000726">DisplaceBitmap</link></entry>
</row>
<row>
<entry>DrawAngleArc</entry>
<entry><link linkend="h001215">DrawAngleArc</link></entry>
</row>
<row>
<entry>DrawArc</entry>
<entry><link linkend="h001212">DrawArc</link></entry>
</row>
<row>
<entry>DrawBitmap</entry>
<entry><link linkend="h001143">DrawBitmap</link></entry>
</row>
<row>
<entry>DrawButton</entry>
<entry><link linkend="h000606">DrawButton</link></entry>
</row>
<row>
<entry>DrawLine</entry>
<entry><link linkend="h001188">DrawLine</link></entry>
</row>
<row>
<entry>DrawPie</entry>
<entry><link linkend="h001216">DrawPie</link></entry>
</row>
<row>
<entry>DrawPixel</entry>
<entry><link linkend="h001200">DrawPixel</link></entry>
</row>
<row>
<entry>Dump</entry>
<entry><link linkend="dumpdialog">Dump</link></entry>
</row>
<row>
<entry>EnableItem</entry>
<entry><link linkend="h001221">EnableItem</link></entry>
</row>
<row>
<entry>EndAsyncExecution</entry>
<entry><link linkend="h000068">EndAsyncExecution</link></entry>
</row>
<row>
<entry><link linkend="mthEnsureVisibleClsPlainBaseDialog">ensureVisible</link></entry>
<entry>Causes the dialog to reposition itself so that it is entirely on the visible screen.</entry>
</row>
<row>
<entry>execute</entry>
<entry><link linkend="mthExecute">execute</link></entry>
</row>
<row>
<entry>executeAsync</entry>
<entry><link linkend="mthExecuteAsync">executeAsync</link></entry>
</row>
<row>
<entry>FillDrawing</entry>
<entry><link linkend="h001217">FillDrawing</link></entry>
</row>
<row>
<entry>FindComboEntry</entry>
<entry><link linkend="h000335">FindComboEntry</link></entry>
</row>
<row>
<entry>FindListEntry</entry>
<entry><link linkend="h000408">FindListEntry</link></entry>
</row>
<row>
<entry>FocusItem</entry>
<entry><link linkend="focusitem">FocusItem</link></entry>
</row>
<row>
<entry>FontColor</entry>
<entry><link linkend="h000997">FontColor</link></entry>
</row>
<row>
<entry>FontToDC</entry>
<entry><link linkend="mthFontToDC">FontToDC</link></entry>
</row>
<row>
<entry>ForegroundWindow</entry>
<entry><link linkend="foregroundwindow">ForegroundWindow</link></entry>
</row>
<row>
<entry>FreeButtonDC</entry>
<entry><link linkend="h001105">FreeButtonDC</link></entry>
</row>
<row>
<entry>FreeDC</entry>
<entry><link linkend="freedc">FreeDC</link></entry>
</row>
<row>
<entry>FreeWindowDC</entry>
<entry><link linkend="h001086">FreeWindowDC</link></entry>
</row>
<row>
<entry>Get</entry>
<entry><link linkend="h000086">Get</link></entry>
</row>
<row>
<entry>GetArcDirection</entry>
<entry><link linkend="h001213">GetArcDirection</link></entry>
</row>
<row>
<entry>Sets a data attribute of the Rexx dialog using the data from a connected Windows dialog control.</entry>
<entry><link linkend="mthGetDataAttribute">getDataAttribute</link></entry> </row>
<row>
<entry>GetBitmapSizeX</entry>
<entry><link linkend="h001127">GetBitmapSizeX</link></entry>
</row>
<row>
<entry>GetBitmapSizeY</entry>
<entry><link linkend="h001135">GetBitmapSizeY</link></entry>
</row>
<row>
<entry>GetBmpDisplacement</entry>
<entry><link linkend="h000737">GetBmpDisplacement</link></entry>
</row>
<row>
<entry>GetButtonDC</entry>
<entry><link linkend="h001077">GetButtonDC</link></entry>
</row>
<row>
<entry>GetButtonRect</entry>
<entry><link linkend="h000703">GetButtonRect</link></entry>
</row>
<row>
<entry>GetClientRect</entry>
<entry><link linkend="mthGetClientRect">GetClientRect</link></entry>
</row>
<row>
<entry>GetCheckBox</entry>
<entry><link linkend="h000490">GetCheckBox</link></entry>
</row>
<row>
<entry>GetComboEntry</entry>
<entry><link linkend="gcem">GetComboEntry</link></entry>
</row>
<row>
<entry>GetComboItems</entry>
<entry><link linkend="h000336">GetComboItems</link></entry>
</row>
<row>
<entry>GetComboLine</entry>
<entry><link linkend="h000482">GetComboLine</link></entry>
</row>
<row>
<entry>GetControlID</entry>
<entry><link linkend="mthGetControlID">GetControlID</link></entry>
</row>
<row>
<entry>GetCurrentComboIndex</entry>
<entry><link linkend="h000344">GetCurrentComboIndex</link></entry>
</row>
<row>
<entry>GetCurrentListIndex</entry>
<entry><link linkend="h000417">GetCurrentListIndex</link></entry>
</row>
<row>
<entry>getData</entry>
<entry><link linkend="mthGetData">getData</link></entry>
</row>
<row>
<entry>getDataStem</entry>
<entry><link linkend="mthGetDataStem">getDataStem</link></entry>
</row>
<row>
<entry>GetDC</entry>
<entry><link linkend="getdc">GetDC</link></entry>
</row>
<row>
<entry>getEditData</entry>
<entry><link linkend="mthGetEditData">getEditData</link></entry>
</row>
<row>
<entry>GetFocus</entry>
<entry><link linkend="getfocus">GetFocus</link></entry>
</row>
<row>
<entry>getFont</entry>
<entry><link linkend="mthGetFont">getFont</link></entry>
</row>
<row>
<entry>GetItem</entry>
<entry><link linkend="mthGetItem">GetItem</link></entry>
</row>
<row>
<entry>GetListEntry</entry>
<entry><link linkend="glem">GetListEntry</link></entry>
</row>
<row>
<entry>GetListItemHeight</entry>
<entry><link linkend="getlistitemheight">GetListItemHeight</link></entry>
</row>
<row>
<entry>GetListItems</entry>
<entry><link linkend="h000409">GetListItems</link></entry>
</row>
<row>
<entry>GetListLine</entry>
<entry><link linkend="h000474">GetListLine</link></entry>
</row>
<row>
<entry>GetListWidth</entry>
<entry><link linkend="getlistwidth">GetListWidth</link></entry>
</row>
<row>
<entry>GetMouseCapture</entry>
<entry><link linkend="getmousecapture">GetMouseCapture</link></entry>
</row>
<row>
<entry>GetMultiList</entry>
<entry><link linkend="h000506">GetMultiList</link></entry>
</row>
<row>
<entry>GetPixel</entry>
<entry><link linkend="h001211">GetPixel</link></entry>
</row>
<row>
<entry>GetPos</entry>
<entry><link linkend="mthGetPos">GetPos</link></entry>
</row>
<row>
<entry>GetRadioButton</entry>
<entry><link linkend="h000498">GetRadioButton</link></entry>
</row>
<row>
<entry>GetRect</entry>
<entry><link linkend="getrect">GetRect</link></entry>
</row>
<row>
<entry>GetSBPos</entry>
<entry><link linkend="h000790">GetSBPos</link></entry>
</row>
<row>
<entry>GetSBRange</entry>
<entry><link linkend="h000782">GetSBRange</link></entry>
</row>
<row>
<entry><link linkend="mthGetSelf">getSelf</link></entry>
<entry>Returns the window handle of the dialog.</entry>
</row>
<row>
<entry><link linkend="mthGetTextSizeDlgClsPlainBaseDialog">getTextSizeDlg</link></entry>
<entry>Calculates the size needed to display a string in dialog units.</entry>
</row>
<row>
<entry><link linkend="mthGetTextSizeDu">getTextSizeDu</link></entry>
<entry>
  Calculates the size needed to display a string in dialog units <emphasis role="bold">(preferred
  method.)</emphasis>
</entry>
</row>
<row>
<entry>getControlData</entry>
<entry><link linkend="mthGetControlData">getControlData</link></entry>
</row>
<row>
<entry>GetWindowDC</entry>
<entry><link linkend="h001062">GetWindowDC</link></entry>
</row>
<row>
<entry>GetWindowRect</entry>
<entry><link linkend="h000712">GetWindowRect</link></entry>
</row>
<row>
<entry>HandleMessages</entry>
<entry><link linkend="h000756">HandleMessages</link></entry>
</row>
<row>
<entry>hasKeyPressConnection</entry>
<entry><link linkend="mthHasKeyPressConnectionBaseDialog">hasKeyPressConnection</link></entry>
</row>
<row>
<entry>HScrollPos</entry>
<entry><link linkend="hscrollpos">HScrollPos</link></entry>
</row>
<row>
<entry>Help</entry>
<entry><link linkend="mthHelp">Help</link></entry>
</row>
<row>
<entry>HideItem</entry>
<entry><link linkend="mthHideItem">HideItem</link></entry>
</row>
<row>
<entry>HideItemFast</entry>
<entry><link linkend="h001285">HideItemFast</link></entry>
</row>
<row>
<entry>HideWindow</entry>
<entry><link linkend="h001253">HideWindow</link></entry>
</row>
<row>
<entry>HideWindowFast</entry>
<entry><link linkend="h001261">HideWindowFast</link></entry>
</row>
<row>
<entry><link linkend="mthInitAutoDetection">initAutoDetection</link></entry>
<entry>Switches automatic data field detection on or off.</entry>
</row>
<row>
<entry>InitDialog</entry>
<entry><link linkend="mthInitDialog">InitDialog</link></entry>
</row>
<row>
<entry>IsMouseButtonDown</entry>
<entry><link linkend="ismousebuttondown">IsMouseButtonDown</link></entry>
</row>
<row>
<entry><link linkend="mthLeaving">leaving</link></entry>
<entry>A method automatically invoked when the underlying dialog is being closed.</entry>
</row>
<row>
<entry>InsertComboEntry</entry>
<entry><link linkend="h000316">InsertComboEntry</link></entry>
</row>
<row>
<entry>InsertListEntry</entry>
<entry><link linkend="h000389">InsertListEntry</link></entry>
</row>
<row>
<entry>IsDialogActive</entry>
<entry><link linkend="h000721">IsDialogActive</link></entry>
</row>
<row>
<entry>IsMaximized</entry>
<entry><link linkend="mthIsMaximized">IsMaximized</link></entry>
</row>
<row>
<entry>IsMinimized</entry>
<entry><link linkend="mthIsMinimized">IsMinimized</link></entry>
</row>
<row>
<entry><link linkend="mthGetControlText">getControlText</link></entry>
<entry>Gets the text of the specified dialog control</entry>
</row>
<row>
<entry>ListAddDirectory</entry>
<entry><link linkend="h000448">ListAddDirectory</link></entry>
</row>
<row>
<entry>ListDrop</entry>
<entry><link linkend="h000458">ListDrop</link></entry>
</row>
<row>
<entry>LoadBitmap</entry>
<entry><link linkend="h000667">LoadBitmap</link></entry>
</row>
<row>
<entry>LogRect2AbsRect</entry>
<entry><link linkend="logrect2absrect">LogRect2AbsRect</link></entry>
</row>
<row>
<entry>Maximize</entry>
<entry><link linkend="mthMaximize">Maximize</link></entry>
</row>
<row>
<entry>Minimize</entry>
<entry><link linkend="mthMinimize">Minimize</link></entry>
</row>
<row>
<entry>Move</entry>
<entry><link linkend="move">Move</link></entry>
</row>
<row>
<entry>MoveItem</entry>
<entry><link linkend="h001322">MoveItem</link></entry>
</row>
<row>
<entry>newPushButton</entry>
<entry><link linkend="mthNewPushButton">newPushButton</link></entry>
</row>
<row>
<entry>newCheckBox</entry>
<entry><link linkend="mthNewCheckBox">newCheckBox</link></entry>
</row>
<row>
<entry>newComboBox</entry>
<entry><link linkend="mthNewComboBox">newComboBox</link></entry>
</row>
<row>
<entry>newEdit</entry>
<entry><link linkend="mthNewEdit">newEdit</link></entry>
</row>
<row>
<entry>newGroupBox</entry>
<entry><link linkend="mthNewGroupBox">newGroupBox</link></entry>
</row>
<row>
<entry>newListBox</entry>
<entry><link linkend="mthNewListBox">newListBox</link></entry>
</row>
<row>
<entry>newListView</entry>
<entry><link linkend="mthNewListView">newListView</link></entry>
</row>
<row>
<entry>newProgressBar</entry>
<entry><link linkend="mthNewProgressBar">newProgressBar</link></entry>
</row>
<row>
<entry>newRadioButton</entry>
<entry><link linkend="mthNewRadioButton">newRadioButton</link></entry>
</row>
<row>
<entry>newScrollBar</entry>
<entry><link linkend="mthNewScrollBar">newScrollBar</link></entry>
</row>
<row>
<entry>newTrackBar</entry>
<entry><link linkend="mthNewTrackBar">newTrackBar</link></entry>
</row>
<row>
<entry>newStatic</entry>
<entry><link linkend="mthNewStatic">newStatic</link></entry>
</row>
<row>
<entry>newTab</entry>
<entry><link linkend="mthNewTab">newTab</link></entry>
</row>
<row>
<entry>newTreeView</entry>
<entry><link linkend="mthNewTreeView">newTreeView</link></entry>
</row>
<row>
<entry><link linkend="mthNoAutoDetection">noAutoDetection</link></entry>
<entry>Turns automatic data field detection off</entry>
</row>
<row>
<entry><link linkend="mthAutoDetection">autoDetection</link></entry>
<entry>Turns automatic data field detection on</entry>
</row>
<row>
<entry>ObjectToDC</entry>
<entry><link linkend="h000928">ObjectToDC</link></entry>
</row>
<row>
<entry>OK</entry>
<entry><link linkend="mthOk">OK</link></entry>
</row>
<row>
<entry>OpaqueText</entry>
<entry><link linkend="h000842">OpaqueText</link></entry>
</row>
<row>
<entry>PeekDialogMessage</entry>
<entry><link linkend="peekdialogmessage">PeekDialogMessage</link></entry>
</row>
<row>
<entry>popup</entry>
<entry><link linkend="mthPopup">popup</link></entry>
</row>
<row>
<entry>popupAsChild</entry>
<entry><link linkend="mthPopupAsChild">popupAsChild</link></entry>
</row>
<row>
<entry>Rectangle</entry>
<entry><link linkend="h001115">Rectangle</link></entry>
</row>
<row>
<entry>RedrawButton</entry>
<entry><link linkend="h000684">RedrawButton</link></entry>
</row>
<row>
<entry>RedrawRect</entry>
<entry><link linkend="h000653">RedrawRect</link></entry>
</row>
<row>
<entry>RedrawWindow</entry>
<entry><link linkend="redrawwindow">RedrawWindow</link></entry>
</row>
<row>
<entry>RedrawWindowRect</entry>
<entry><link linkend="h000693">RedrawWindowRect</link></entry>
</row>
<row>
<entry>ReleaseMouseCapture</entry>
<entry><link linkend="releasemousecapture">ReleaseMouseCapture</link></entry>
</row>
<row>
<entry>RemoveBitmap</entry>
<entry><link linkend="h000676">RemoveBitmap</link></entry>
</row>
<row>
<entry>Resize</entry>
<entry><link linkend="resize">Resize</link></entry>
</row>
<row>
<entry>ResizeItem</entry>
<entry><link linkend="h001301">ResizeItem</link></entry>
</row>
<row>
<entry>Restore</entry>
<entry><link linkend="mthRestore">Restore</link></entry>
</row>
<row>
<entry>RestoreCursorShape</entry>
<entry><link linkend="restorecursorshape">RestoreCursorShape</link></entry>
</row>
<row>
<entry>Run</entry>
<entry><link linkend="h000041">Run</link></entry>
</row>
<row>
<entry>ScreenToClient</entry>
<entry><link linkend="screentoclient">ScreenToClient</link></entry>
</row>
<row>
<entry>Scroll</entry>
<entry><link linkend="scroll">Scroll</link></entry>
</row>
<row>
<entry>ScrollBitmapFromTo</entry>
<entry><link linkend="h001172">ScrollBitmapFromTo</link></entry>
</row>
<row>
<entry>ScrollButton</entry>
<entry><link linkend="h000913">ScrollButton</link></entry>
</row>
<row>
<entry>ScrollInButton</entry>
<entry><link linkend="h000896">ScrollInButton</link></entry>
</row>
<row>
<entry>ScrollText</entry>
<entry><link linkend="h000879">ScrollText</link></entry>
</row>
<row>
<entry><link linkend="mthSendMessageToControl">sendMessageToControl</link></entry>
<entry>Sends a Windows message to a dialog control and returns its response as a whole number.</entry>
</row>
<row>
<entry><link linkend="mthSendMessageToControlH">sendMessageToControlH</link></entry>
<entry>Sends a Windows message to a dialog control and returns its response as a handle.</entry>
</row>
<row>
<entry><link linkend="mthSendMessageToWindow">sendMessageToWindow</link></entry>
<entry>Sends a Windows message to a window and returns its response as a whole number.</entry>
</row>
<row>
<entry><link linkend="mthSendMessageToWindowH">sendMessageToWindowH</link></entry>
<entry>Sends a Windows message to a window and returns its response as a handle.</entry>
</row>
<row>
<entry>SetArcDirection</entry>
<entry><link linkend="h001214">SetArcDirection</link></entry>
</row>
<row>
<entry><link linkend="mthSetDataAttribute">setDataAttribute</link></entry>
<entry>Sets the state of a dialog control using the value of a data attribute of the Rexx dialog.</entry>
</row>
<row>
<entry>SetCheckBox</entry>
<entry><link linkend="h000557">SetCheckBox</link></entry>
</row>
<row>
<entry>SetComboLine</entry>
<entry><link linkend="h000548">SetComboLine</link></entry>
</row>
<row>
<entry><link linkend="mthSetControlText">setControlText</link></entry>
<entry>Sets the text for the specified dialog control</entry>
</row>
<row>
<entry>SetCursorPos</entry>
<entry><link linkend="setcursorpos">SetCursorPos</link></entry>
</row>
<row>
<entry>SetCurrentComboIndex</entry>
<entry><link linkend="h000345">SetCurrentComboIndex</link></entry>
</row>
<row>
<entry>SetCurrentListIndex</entry>
<entry><link linkend="h000418">SetCurrentListIndex</link></entry>
</row>
<row>
<entry>setData</entry>
<entry><link linkend="mthSetData">setData</link></entry>
</row>
<row>
<entry>setDataStem</entry>
<entry><link linkend="mthSetDataStem">setDataStem</link></entry>
</row>
<row>
<entry>setEditData</entry>
<entry><link linkend="mthSetEditData">setEditData</link></entry>
</row>
<row>
<entry>SetFocus</entry>
<entry><link linkend="setfocus">SetFocus</link></entry>
</row>
<row>
<entry>SetFocusToWindow</entry>
<entry><link linkend="setfocustowindow">SetFocusToWindow</link></entry>
</row>
<row>
<entry><link linkend="wedoGetFont">getFont</link></entry>
<entry>Returns the font used by the dialog.</entry>
</row>
<row>
<entry><link linkend="wedoSetFont">setFont</link></entry>
<entry>Sets a new font to be used by the dialog.</entry>
</row>
<row>
<entry>SetForegroundWindow</entry>
<entry><link linkend="setforegroundwindow">SetForegroundWindow</link></entry>
</row>
<row>
<entry>SetGroup</entry>
<entry><link linkend="mthSetGroup">SetGroup</link></entry>
</row>
<row>
<entry>SetHScrollPos</entry>
<entry><link linkend="sethscrollpos">SetHScrollPos</link></entry>
</row>
<row>
<entry>SetVScrollPos</entry>
<entry><link linkend="setvscrollpos">SetVScrollPos</link></entry>
</row>
<row>
<entry>SetItemFont</entry>
<entry><link linkend="sifm">SetItemFont</link></entry>
</row>
<row>
<entry>SetListColumnWidth</entry>
<entry><link linkend="setlistcolumnwidth">SetListColumnWidth</link></entry>
</row>
<row>
<entry>SetListItemHeight</entry>
<entry><link linkend="setlistitemheight">SetListItemHeight</link></entry>
</row>
<row>
<entry>SetListLine</entry>
<entry><link linkend="h000539">SetListLine</link></entry>
</row>
<row>
<entry>SetListWidth</entry>
<entry><link linkend="setlistwidth">SetListWidth</link></entry>
</row>
<row>
<entry>SetListTabulators</entry>
<entry><link linkend="h000435">SetListTabulators</link></entry>
</row>
<row>
<entry>SetMultiList</entry>
<entry><link linkend="h000575">SetMultiList</link></entry>
</row>
<row>
<entry>SetRadioButton</entry>
<entry><link linkend="h000566">SetRadioButton</link></entry>
</row>
<row>
<entry>SetSBPos</entry>
<entry><link linkend="h000791">SetSBPos</link></entry>
</row>
<row>
<entry>SetSBRange</entry>
<entry><link linkend="h000770">SetSBRange</link></entry>
</row>
<row>
<entry>SetTabStop</entry>
<entry><link linkend="mthSetTabStop">SetTabStop</link></entry>
</row>
<row>
<entry>setControlData</entry>
<entry><link linkend="mthSetControlData">setControlData</link></entry>
</row>
<row>
<entry>SetWindowRect</entry>
<entry><link linkend="mthSetWindowRect">SetWindowRect</link></entry>
</row>
<row>
<entry>SetWindowTitle</entry>
<entry><link linkend="h000246">SetWindowTitle</link></entry>
</row>
<row>
<entry>show</entry>
<entry><link linkend="mthShowClsPlainBaseDialog">show</link></entry>
</row>
<row>
<entry>ShowItem</entry>
<entry><link linkend="mthShowItem">ShowItem</link></entry>
</row>
<row>
<entry>ShowItemFast</entry>
<entry><link linkend="h001293">ShowItemFast</link></entry>
</row>
<row>
<entry>ShowWindow</entry>
<entry><link linkend="h001269">ShowWindow</link></entry>
</row>
<row>
<entry>ShowWindowFast</entry>
<entry><link linkend="h001277">ShowWindowFast</link></entry>
</row>
<row>
<entry>TabToNext</entry>
<entry><link linkend="tabtonext">TabToNext</link></entry>
</row>
<row>
<entry>TabToPrevious</entry>
<entry><link linkend="tabtoprevious">TabToPrevious</link></entry>
</row>
<row>
<entry>TiledBackgroundBitmap</entry>
<entry><link linkend="h001045">TiledBackgroundBitmap</link></entry>
</row>
<row>
<entry>TransparentText</entry>
<entry><link linkend="h000841">TransparentText</link></entry>
</row>
<row>
<entry>ToTheTop</entry>
<entry><link linkend="h000109">ToTheTop</link></entry>
</row>
<row>
<entry>validate</entry>
<entry><link linkend="mthValidate">validate</link></entry>
</row>
<row>
<entry>VScrollPos</entry>
<entry><link linkend="vscrollpos">VScrollPos</link></entry>
</row>
<row>
<entry>Write</entry>
<entry><link linkend="h000866">Write</link></entry>
</row>
<row>
<entry>WriteDirect</entry>
<entry><link linkend="h000840">WriteDirect</link></entry>
</row>
<row>
<entry>WriteToButton</entry>
<entry><link linkend="h000852">WriteToButton</link></entry>
</row>
<row>
<entry>WriteToWindow</entry>
<entry><link linkend="h000826">WriteToWindow</link></entry>
</row>
</tbody></tgroup>
</table>
</para>
</section>

<section id="sctDialogClassMethods"><title>Class Methods</title>
<indexterm><primary>class methods</primary>
<secondary>dialog object</secondary></indexterm>

<section id="mthNewDialogObject"><title>new (Class method)</title>
<indexterm><primary>new</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>new method</secondary></indexterm>
<programlisting>
<![CDATA[
>>--new(--+---------+--,--id--+-------------+--+----------+--)------------------><
          +-library-+         +-,--dlgData.-+  +-,--hFile-+


]]>
</programlisting>

<para>
  Although the dialog object is an abstract class that the programmer will not instantiate directly, the programmer
  should understand the arguments of the dialog object's <emphasis role="italic">new</emphasis>() method. Recall that
  in ooRexx, when a new object is instantiated, the <emphasis role="italic">new</emphasis> method invokes the <emphasis
  role="italic">init</emphasis>() method of the object, using the arguments sent to the <emphasis
  role="italic">new</emphasis>() method. So, the arguments of the <emphasis role="italic">new</emphasis> method are also
  the arguments of the <emphasis role="italic">init</emphasis> method.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    The dialog object is abstract, the programmer can not directly instantiate a workable dialog object. Rather, the
    programmer instantiates one of the conrete subclasses. Such as a subclass of a <link
    linkend="clsRcDialog">RcDialog</link> or a <link linkend="clsResDialog">ResDialog</link>.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>library [optional]</term>
      <listitem>
      <para>
        The name of the file containing the dialog template. Subclasses that do not use a file containing the dialog
        template, such as the <computeroutput>UserDialog</computeroutput>, pass an empty string for this argument.
      </para> </listitem></varlistentry>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the dialog within the resource file. This may be numeric or <link
        linkend="defSymbolicId">symbolic</link>.
      </para>
      </listitem></varlistentry>
      <varlistentry id="termDialogDataStem"><term>dlgData. [optional]</term>
      <listitem>
      <para>
        A dialog data stem variable (don't forget the trailing period) that contains data used to initialize the
        underlying dialog's controls. This is part of the automatic <link linkend="sctUnderstandingDataAttributes">data
        detection</link> feature. When <link linkend="mthInitAutoDetection">automatic</link> data detecion is off, using
        this argument does nothing.
      </para>
      <para>
        Each index of the data stem should be the resource ID of one of the dialog's controls. The value at that index
        is used to set the state of the corresponding, connected, dialog control when the underlying dialog is created.
        If the stem does not contain an index for a connected dialog control, then the state of that control is set to
        the empty string. The ooDialog framework keeps track of the data stem argument when it is used. If a data stem
        argument is used, when the dialog is closed with the <emphasis role="italic">ok</emphasis> command, the data of
        each connected dialog control is copied to the stem at the index corresponding to the dialog control's resource
        ID.
      </para>
      <para>
        <emphasis role="bold">Note:</emphasis> when the argument is used the behavior of automatic data detection is
        changed in this way. When the underlying dialog is created, the data stem <emphasis role="bold">only</emphasis>
        is used to set the state of the dialog controls. The values of the <link
        linkend="sctUnderstandingDataAttributes">data attributes</link> are ignored. However, when the dialog closes
        with the <emphasis role="italic">ok</emphasis> command, the values of both the data attributes <emphasis
        role="bold">and</emphasis> the data stem indexes are updated.
      </para>
      </listitem></varlistentry>
      <varlistentry id="termHFile"><term>hFile [optional]</term>
      <listitem>
      <para>
        A file, (often called a <link linkend="defHeaderFile">header</link> file,) defining <link
        linkend="defSymbolicID">symbolic IDs</link> for resources. The symbolic IDs defined within the file will be
        added to the <link linkend="atrConstDir">constDir</link> directory.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry id="exampleDialogObjectnew"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example shows how a header file, symbolic IDs, and the data stem can be used in instantiating a new
    object that is a subclass of the ResDialog. Assume <computeroutput>resources.h</computeroutput> is a file in the
    same directory as the program file and contains the following:

<programlisting> <![CDATA[
/* resources.h */
  #define IDD_BUILD_DLG           100
  #define IDC_EDITFIELD_INCLUDE   110
  #define IDC_COMBOBOX_PROJECT    120
  #define IDC_RADIO_DEBUG         130
  #define IDC_RADIO_RELEASE       131
  #define IDC_CHECKBOX_CLEAN      140
  #define IDI_DLG_ICON            514

]]>
</programlisting>
  </para>
  <para>
    The dialog (a fictitious build dialog) will have an edit control, a combo box, two radio buttons, and a check box.
    The <computeroutput>dlgData.</computeroutput> stem will be used to initialize the stae of the controls using the
    symbolic IDs defined in the header file.

<programlisting>
<![CDATA[
/* BuildDlg.rex */
  DlgData.IDC_EDITFIELD_INCLUDE = "C:\sdk\include"
  DlgData.IDC_COMBOBOX_PROJECT = "Calculator"
  DlgData.RADIO_DEBUG = 0
  DlgData.RADIO_RELEASE = 1
  DlgData.CHECKBOX_CLEAN = 0

  dlg = .BuildDialog~new("dlg.dll", IDD_BUILD_DLG, DlgData, "resources.h")
  if dlg~initCode <> 0 then do
    say "Error starting dialog.  initCode:" dlg~initCode
    return dlg~initCode
  end

  dlg~execute("NORMAL", IDI_DLG_ICON)
  ...

]]>
</programlisting>
  </para>
  <para>
    At this point the dialog is shown, the edit control will contain &quot;C:\sdk\include&quot;, the combo box will have the
    Calculator project selected, the release radio button will be checked, (the debug radio button will not be checked,)
    and the clean check box will not be checked.
  </para>
  <para>
    The user interacts with the dialog and selects ok to close it.  Now the state of the dialog when it was closed can
    be determined by checking the <computeroutput>dlgData.</computeroutput> stem values.

<programlisting>
<![CDATA[
  ...

  if DlgData.CHECKBOX_CLEAN == 1 then doClean()

  includePath = DlgData.IDC_EDITFIELD_INCLUDE
  if DlgData.RADIO_RELEASE == 1 then
    success = doReleaseBuild(includePath)
  else
    success = doDebugBuild(includePath)

  return success

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthClsSetDefaultFont"><title>setDefaultFont (Class method)</title>
<indexterm><primary>setDefaultFont</primary></indexterm>
<programlisting>
<![CDATA[
>>--setDefaultFont(--fontName--,--fontSize--)----------------------------------><

]]>
</programlisting>

<para>
  This method changes the default dialog font used for all dialogs. The default dialog font is used whenever a
  dynamically defined dialog template does not specify a font. Since it is very unusual for a resource script to not
  specify a font, this mostly effects the <link linkend="clsUserDialog">UserDialog</link> classes. Binary compiled
  dialog templates (<link linkend="clsResDialog">ResDialog</link>) can not be changed, so the default dialog font has no
  meaning for a ResDialog.
</para>
<para>
  Currently the default font is <computeroutput>MS Shell Dlg</computeroutput> with a size of
  <computeroutput>8</computeroutput>.  MS Shell Dlg is not a true font name, but rather a pseudo name
  that signals the operating system to use a standard font for the specific version of Windows.  In other
  words, on Windows 2000, MS Shell Dlg will cause the operating system to use the standard font for
  dialogs on Windows 2000.  On XP, the operating system will use the standard XP dialog font.  (The two
  fonts are different.)  By using this font for the default, ooDialog produces dialogs that match what is
  most common on the current operating system.
</para>
<para>
  Of course, when the ooDialog programmer specifies a font in either the <link
  linkend="mthCreate">create</link>() or the <link linkend="mthCreateCenter">createCenter</link>()
  methods then the defualt font is ignored. Once the default font is changed in a process then all
  dynamic dialogs, that don't specify a font, that are created afterwards will use the new default font.
</para>
<para>
  The actual font used by a dialog directly effects the value of a <link linkend="defDialogUnit">dialog
  unit</link>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
    <para>The arguments are:
    <variablelist>
      <varlistentry><term>fontName</term>
      <listitem>
        <para>
          The family name to use for the default font, for example
          <computeroutput>Tahoma</computeroutput>.
        </para>
      </listitem></varlistentry>
      <varlistentry><term>fontSize</term>
      <listitem>
        <para>
          The size of the font, for example, <computeroutput>10</computeroutput>.
        </para>
      </listitem></varlistentry>
    </variablelist>
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
    <para>
      This method does not return a value.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
    <para>
      This example shows a change to the oostddlg.rex sample program.  The default font is changed to
      Tahoma pt 10.  This causes all the <link linkend="sctStandardDialogs">Standard Dialogs</link> to
      be created using this font.
      <programlisting>
      <![CDATA[

      /*--------------------------------------------------------------------------*/
      /*                                                                          */
      /* oodialog\samples\oostddlg.rex   Standard Dialog demonstration            */
      /*                                                                          */
      /*--------------------------------------------------------------------------*/

      .PlainBaseDialog~setDefaultFont("Tahoma", 10)
      say
      say 'Starting standard dialog demonstration...'

      ...
      ]]>
      </programlisting>
    </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::setDefaultFont() [class method?] -->


<section id="mthClsGetFontName"><title>getFontName (Class method)</title>
<indexterm><primary>getFontName</primary>
<secondary>PlainBaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getFontName----------------------------------------------------><

]]>
</programlisting>
<para>
  Returns the current default dialog font name. The default dialog font is used whenever a dialog
  template, used in a dynamically defined dialog, does not specify a font.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
    <para>
      There are no arguments.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
    <para>
      This method returns the current default font family name. For instance, MS Shell Dlg.
    </para>
  </listitem></varlistentry>
  <varlistentry id="exampleGetFontNameCls"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
    <para>
      The following example temporarily changes the default font to run the accounting program. The
      accounting program uses a large number of dynamically defined dialogs. It does not specify the
      dialog font for any of the dialogs. Before starting the program, the default font is changed to 10
      pt Tahoma. Then, all the dialogs created while the accounting program is executing will be created
      using 10 pt Tahoma.  When the accounting program is done, the old default is restored.
      <programlisting>
      <![CDATA[
      oldName = .PlainBaseDialog~getFontName
      oldSize = .PlainBaseDialog~getFontSize
      .PlainBaseDialog~setDefaultFont("Tahoma", 10)

      ret = excuteAccounting("Daily")

      .PlainBaseDialog~setDefaultFont(oldName, oldSize)
      ]]>
      </programlisting>
    </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::getFontName() [class method] -->

<section id="mthClsGetFontSize"><title>getFontSize (Class method)</title>
<indexterm><primary>getFontSize</primary>
<secondary>PlainBaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getFontSize----------------------------------------------------><

]]>
</programlisting>
<para>
  Returns the current default dialog font size. The default dialog font is used whenever a dialog template, used in a
  dynamically defined dialog, does not specify a font.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
    <para>
      There are no arguments.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
    <para>
      This method returns the current default font size. For instance, 8.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
    <para>
      See the previous <link linkend="exampleGetFontNameCls">getFontName</link>() example.
    </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::getFontName() [class method] -->

</section>

<section id="sctDialogAttributes"><title>Attributes</title>
<indexterm><primary>dialog object attributes</primary></indexterm>
<para>
  This section describes the attributes of the dialog object.
</para>

<section id="atrConstDir"><title>constDir (Attribute)</title>
<indexterm><primary>constDir</primary></indexterm>
<indexterm><primary>ResourceUtils class</primary>
<secondary>constDir</secondary></indexterm>
<indexterm><primary>dialog object</primary>
<secondary>constDir</secondary></indexterm>
<programlisting>
<![CDATA[
>>--constDir---------------------------------------------------><

>>--constDir[symbol]-=-numericValue----------------------------><

]]>
</programlisting>

<para>
  A directory object whose indexes are <link linkend="defSymbolicId">symbolic resource ID</link>s. The entry for each
  index is the numeric value of the <link linkend="defResourceId">resource ID</link>.  Once a symbolic ID is added to
  the <emphasis role="italic">constDir</emphasis> directory, the symbolic ID can be used in place of the numeric value
  in any method of the ooDialog classes that requires a resource ID.
</para>
<para>
  The use of the <emphasis role="italic">constDir</emphasis> is mostly transparent to the programmer and handled
  automatically by the ooDialog framework. See the remarks section for how entries are added to the <emphasis
  role="italic">constDir</emphasis>. Internally, the framework uses the <emphasis role="italic">constDir</emphasis> to
  resolve a symbolic ID used in an method invocation to its numeric value.  This is completely transparent to the
  programmer.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    The <emphasis role="italic">constDir</emphasis> attribute is inherited from the <link
    linkend="clsResourceUtils">ResourceUtils</link> class.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">constDir get:</emphasis></term>
  <listitem>
  <para>
    details about get
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">constDir set:</emphasis></term>
  <listitem>
  <para>
    Setting the <emphasis role="italic">constDir</emphasis> attribute is private and in general should not be done by
    the programmer. The ooDialog framework automatically sets the attribute to a
    <computeroutput>Directory</computeroutput> object when a new dialog or menu object is created.
  </para> </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    A few symbolic IDs are pre-defined by ooDialog and are present in the <computeroutput>constDir</computeroutput>
    directory of all dialogs.  See the table, <link linkend="oodsymbolicids">Symbolic IDs Used by ooDialog</link>, for a
    list of these IDs.  The programmer can add symbolic IDs to this directory by using <link
    linkend="defPoundDefine">#define</link> statements in a resource script or a <link linkend="defHeaderFile">header
    file</link>.  Of course, symbolic IDs can also be added directly in the program as the following code snippet shows:
  </para>

<programlisting>
<![CDATA[

::method init
  forward class (super) continue

  self~constDir["ID_GB"] = 101
  self~constDir["ID_CB_REGINA"] = 107
  self~constDir["ID_CB_REGINALD"] = 111
  self~constDir["ID_CB_OOREXX"] = 115

...

::method defineDialog

  self~createGroupBox(ID_GB, 10, 20, 150, 90, "BORDER", "Pick an interpreter")
  self~createCheckBox(ID_CB_REGINA, "cb1", 30, 40, , , "GROUP", "Regina")
  self~createCheckBox(ID_CB_REGINALD, "cb2", 30, 60, , , , "Reginald")
  self~createCheckBox(ID_CB_OOREXX, "cb3", 30, 80, , , , "ooRexx")

...

::method ok

  oorexxCB = self~newCheckBox(ID_CB_OOREXX)
  if oorexxCB~checked then
    say "You picked the right interpreter."

]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End ResourceUtils::constDir() [attribute]  -->

<section id="atrAutoDetect"><title>autoDetect (Attribute)</title>
<indexterm><primary>autoDetect</primary></indexterm>
<indexterm><primary>PlainBaseDialog class</primary>
<secondary>autoDetect</secondary></indexterm>
<indexterm><primary>dialog object</primary>
<secondary>autoDetect</secondary></indexterm>

<programlisting>
<![CDATA[
>>--autoDetect-----------------------------------------------------><

>>--autoDetect-=-onOff---------------------------------------------><

]]>
</programlisting>

<para>
  xx
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    xx
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">autoDetect get:</emphasis></term>
  <listitem>
  <para>
    details about get
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">autoDetect set:</emphasis></term>
  <listitem>
  <para>
    details about set
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Additional comments.
  </para></listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example ...
<programlisting>
<![CDATA[


]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::autoDetect() [attribute]  -->

<section id="atrAutomaticMethods"><title>automaticMethods (Attribute)</title>
<indexterm><primary>automaticMethods</primary></indexterm>
<indexterm><primary>PlainBaseDialog class</primary>
<secondary>automaticMethods</secondary></indexterm>
<programlisting>
<![CDATA[
>>--automaticMethods-----------------------------------------------------><

>>--automaticMethods-=-varName-------------------------------------------><

]]>
</programlisting>

<para>
  xx
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    xx
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">automaticMethods get:</emphasis></term>
  <listitem>
  <para>
    details about get
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">automaticMethods set:</emphasis></term>
  <listitem>
  <para>
    details about set
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Additional comments.
  </para></listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example ...
<programlisting>
<![CDATA[


]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::automaticMethods() [attribute]  -->

<section id="atrBkgBitmap"><title>bkgBitmap (Attribute)</title>
<indexterm><primary>bkgBitmap</primary></indexterm>
<indexterm><primary>PlainBaseDialog class</primary>
<secondary>bkgBitmap</secondary></indexterm>
<programlisting>
<![CDATA[
>>--bkgBitmap-----------------------------------------------------><

>>--bkgBitmap-=-varName-------------------------------------------><

]]>
</programlisting>

<para>
  xx
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    xx
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">bkgBitmap get:</emphasis></term>
  <listitem>
  <para>
    details about get
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">bkgBitmap set:</emphasis></term>
  <listitem>
  <para>
    details about set
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Additional comments.
  </para></listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example ...
<programlisting>
<![CDATA[


]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::bkgBitmap() [attribute]  -->

<section id="atrBkgBrushBmp"><title>bkgBrushBmp (Attribute)</title>
<indexterm><primary>bkgBrushBmp</primary></indexterm>
<indexterm><primary>PlainBaseDialog class</primary>
<secondary>bkgBrushBmp</secondary></indexterm>
<programlisting>
<![CDATA[
>>--bkgBrushBmp-----------------------------------------------------><

>>--bkgBrushBmp-=-varName-------------------------------------------><

]]>
</programlisting>

<para>
  xx
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    xx
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">bkgBrushBmp get:</emphasis></term>
  <listitem>
  <para>
    details about get
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">bkgBrushBmp set:</emphasis></term>
  <listitem>
  <para>
    details about set
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Additional comments.
  </para></listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example ...
<programlisting>
<![CDATA[


]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::bkgBrushBmp() [attribute]  -->

<section id="atrDlgHandle"><title>dlgHandle (Attribute)</title>
<indexterm><primary>dlgHandle</primary></indexterm>
<indexterm><primary>PlainBaseDialog class</primary>
<secondary>dlgHandle</secondary></indexterm>
<programlisting>
<![CDATA[
>>--dlgHandle-----------------------------------------------------><

>>--dlgHandle-=-varName-------------------------------------------><

]]>
</programlisting>

<para>
  xx
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    xx
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">dlgHandle get:</emphasis></term>
  <listitem>
  <para>
    details about get
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">dlgHandle set:</emphasis></term>
  <listitem>
  <para>
    details about set
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Additional comments.
  </para></listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example ...
<programlisting>
<![CDATA[


]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::dlgHandle() [attribute]  -->

<section id="atrFontName"><title>fontName (Attribute)</title>
<indexterm><primary>fontName</primary></indexterm>
<indexterm><primary>dialog object</primary>
<secondary>fontName</secondary></indexterm>
<indexterm><primary>PlainBaseDialog class</primary>
<secondary>fontName</secondary></indexterm>
<programlisting>
<![CDATA[
>>--fontName----------------------------------------------------><

>>--fontName=---------------------------------------------------><

]]>
</programlisting>

<para>
  Prior to the creation of the underlying Windows dialog, the font name attribute specifies the name of the font that
  will be used to create the dialog. This font is used in a <link linkend="clsUserDialog"></link> when the font is not
  specified in the <link linkend="mthCreate">create</link>() or the <link
  linkend="mthCreateCenter">createCenter</link>() methods, or in a <link linkend="clsRcDialog">RcDialog</link> where the
  font is not specified in the resource script file. With a binary compiled dialog resource (<link
  linkend="clsResDialog">ResDialog</link>) the font has already been specified when the dialog template
  was compiled and can not be changed. Therefore the font name attribute has no effect on a ResDialog prior to the
  execution of the dialog.
</para>
<para>
  After the creation of the dialog, the attribute always reflects the font name that was actually used the underlying
  dialog was created. The public <link linkend="mthSetDlgFont">setDlgFont</link>() method can be used to set both the
  font name and font size attributes at the same time.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    The <emphasis role="italic">fontName</emphasis> attribute is a member of the <link
    linkend="clsPlainBaseDialog">PlainBaseDialog</link> class.
  </para>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">fontName get:</emphasis>[public]</term>
  <listitem>
  <para>
    Returns the name of the font as a string.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">fontName set:</emphasis>[private]</term>
  <listitem>
  <para>
    Sets the font name to that specified. The name must be less than 256 characters long.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    In order to accurately caclulate <link linkend="defDialogUnit">dialog units</link> in methods such as <link
    linkend="mthGetTextSizeDu">getTexSizeDu</link>(), it is important that the <emphasis
    role="italic">fontName</emphasis> and <link linkend="atrFontSize">fontSize</link> attributes match the actual font
    that the dialog will use. Therefore, whenever dialog unit calculations are going to be made before the underlying
    dialog is created, it is important to set these attributes to match the font that will be used in the dialog. This
    must be done before the dialog unit calculations.
  </para>
  <para>
    <emphasis role="bold">Note</emphasis> that the font name and font size attributes are set in the super class init()
    method to the value of the <link linkend="mthClsSetDefaultFont">default</link> dialog font.  Therefore, to have any
    effect, setting the font name attribute has to be done after the super class init() is finished.
  </para></listitem></varlistentry>
  <varlistentry id="exampleFontName"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example is a portion of the code used to to create a message box dialog using a variable font.
    The calcSizes() method is not shown, but in that method the size and position of the controls, and
    the overall size of the dialog, are calculated in relation to the size needed for the message.
  <programlisting>
  <![CDATA[
    fontName = "Tahoma"
    fontSize = 20
    message = "Drive z: is a network drive and is not accesible."
    title = "Disk Drive Error"

    dlg = .MessageBox~new( , , message, title, fontName, fontSize)
    if dlg~initCode = 0 then do
      dlg~execute("SHOWTOP", 14)
    end

  return 0
  -- End of entry point.

  ::requires "oodWin32.cls"

  ::class 'MessageBox' subclass UserDialog

  ::method init
    expose cx cy message title fontName fontSize

    a = .array~new(2)
    if arg(1, 'E') then a[1] = arg(1)
    if arg(2, 'E') then a[2] = arg(2)

    message = arg(3)
    title = arg(4)
    if arg(5, 'E') then do
      fontName = arg(5)
      fontSize = arg(6)
    end

    forward class (super) arguments (a) continue
    if self~initCode <> 0 then return

    if arg(5, 'E') then do
      self~fontName = fontName
      self~fontSize = fontSize
    end

    self~calcSizes()
    self~createCenter(cx, cy, title)
  ]]>
  </programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::fontName [attribute] -->

<section id="atrFontSize"><title>fontSize (Attribute)</title>
<indexterm><primary>fontSize</primary>
<secondary>PlainBaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--fontSize----------------------------------------------------><

>>--fontSize=---------------------------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">fontSize</emphasis> attribute is the counterpart to the <link
  linkend="atrFontName">fontName</link> attribute. The description and remarks for the <emphasis
  role="italic">fontName</emphasis> attribute apply equally well to the <emphasis role="italic">fontSize</emphasis>
  attribute.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    The <emphasis role="italic">fontSize</emphasis> attribute is a member of the <link
    linkend="clsPlainBaseDialog">PlainBaseDialog</link> class.
  </para>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">fontSize get:</emphasis>[public]</term>
  <listitem>
  <para>
    Returns the point size of the font.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">fontSize set:</emphasis>[private]</term>
  <listitem>
  <para>
    Sets the point size of the font name to the non-negative number specified. Although 0 is accepted, setting the point
    size to 0 is not advised.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the remarks for the <link linkend="atrFontName">fontName</link> attribute.
  </para></listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    See the <link linkend="exampleFontName">fontName</link>() example, which also uses the fontSize attribute.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::fontSize [attribute] -->

<section id="wbdoInitCode"><title>initCode (Attribute)</title>
<programlisting>
<link linkend="atrInitCode">initCode</link>

<![CDATA[
>>--initCode-----------------------------------------------------><

>>--initCode-=-code----------------------------------------------><

]]>
</programlisting>
</section>

<section id="wbdoHwnd"><title>hwnd (Attribute)</title>
<programlisting>
WindowBase::<link linkend="atrHwnd">hwnd</link>

<![CDATA[
>>--hwnd-----------------------------------------------------><

]]>
</programlisting>
</section>

<section id="wbdoSizeX"><title>sizeX (Attribute)</title>
<programlisting>
WindowBase::<link linkend="atrSizeX">sizeX</link>

<![CDATA[
>>--sizeX-----------------------------------------------------><

>>--sizeX-=-dialogUnits---------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoSizeY"><title>sizeY (Attribute)</title>
<programlisting>
WindowBase::<link linkend="atrSizeY">sizeY</link>

<![CDATA[
>>--sizeY-----------------------------------------------------><

>>--sizeY-=-dialogUnits---------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoFactorX"><title>factorX (Attribute)</title>
<programlisting>
WindowBase::<link linkend="atrFactorX">factorX</link>

>>--factorX-----------------------------------------------------><

>>--factorX-=-ratio---------------------------------------------><

</programlisting>
</section>

<section id="wbdoFactorY"><title>factorY (Attribute)</title>
<programlisting>
WindowBase::<link linkend="atrFactorY">factorY</link>

>>--factorY-----------------------------------------------------><

>>--factorY-=-ratio---------------------------------------------><

</programlisting>
</section>

<section id="wbdoPixelCX"><title>pixelCX (Attribute)</title>
<programlisting>
<link linkend="atrPixelCX">pixelCX</link>

<![CDATA[
>>--pixelCX-----------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoPixelCY"><title>pixelCY (Attribute)</title>
<programlisting>
<link linkend="atrPixelCY">pixelCY</link>

<![CDATA[
>>--pixelCY-----------------------------------------------------><
]]>
</programlisting>
</section>

</section>  <!-- End Attributes Section -->

<section id="sctPrepDialog"><title>Preparing and Running the Dialog</title>
<indexterm><primary>preparing and running dialogs</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>preparing and running</secondary></indexterm>
<para>
  This section documents the methods used to prepare and initialize a dialog, show it, execute it, and stop it.
</para>

<section id="mthSetDlgFont"><title>setDlgFont</title>
<indexterm><primary>setDlgFont</primary>
<secondary>PlainBaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--setDlgFont(--fontName--+-----------+--)------------------------------------><
                           +-,-fontSize+
]]>
</programlisting>

<para>
  Sets the font that to be used for the underlying Windows dialog, when it is created.  This is primarily of use in a
  <link linkend="clsUserDialog">UserDialog</link> or a subclasses of a <emphasis role="italic">UserDialog</emphasis>.
  This method sets the <link linkend="atrFontName">fontName</link> and <link linkend="atrFontSize">fontSize</link>
  attributes.
</para>
<para>
  In a <link linkend="clsResDialog">ResDialog</link>, the font of the compiled binary resource will always be used, and
  the font set by this method has no bearing. In a <link linkend="clsRcDialog">RcDialog</link>, if the resource script
  file specifies the font, that font will be used. Likewise, in a <link linkend="clsUserDialog">UserDialog</link>, if
  the programmer specifies a font in the <emphasis role="italic">create</emphasis>() method call, (or the <emphasis
  role="italic">createCenter</emphasis>() method call,) the specified font over-rides what is set by this method.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.  The font name must be less than 256 characters in
    length.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>fontName</term>
    <listitem>
    <para>
      Required. The name of the font, such as Tahoma.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>fontSize</term>
    <listitem>
    <para>
      Optional. The point size of the font, such as 10. The default point size when this argument is omitted is 8.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    This method always returns 0.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Additional comments.
  </para></listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example ...
<programlisting>
<![CDATA[

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::setDlgFont() -->

<section id="mthInitDialog"><title>InitDialog</title>
<indexterm><primary>InitDialog</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~InitDialog--------------------------------------><


]]>
</programlisting>

<para>The InitDialog method is called after the Windows dialog
has been created. It is useful for setting data fields and initializing combo
and list boxes. Do not use Set... methods because
the <link linkend="mthSetData">setData</link> method is executed automatically afterwards
and sets the values of all dialog items from the attributes. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>The method is designed to be overwritten in subclasses; it cannot be
called from outside the class.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem>
<para>
  The following example shows how to use <emphasis role="italic">initDialog</emphasis> to initialize dialog controls,
  in this case a list box:

<programlisting>
<![CDATA[
::class 'MyDialog' subclass RcDialog
::method initDialog

  lb = self~newListBox(IDC_LISTBOX)

  lb~add("this is the first line")
  lb~add("and this one the second")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000041"><title>run</title>
<indexterm><primary>run</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Run---------------------------------------------><


]]>
</programlisting>

<para>
  The Run method dispatches messages from the Windows dialog until the user terminates the dialog by one of the
  following actions:
</para>
<itemizedlist>
<listitem><para>Press the OK button (the push button with ID 1)</para></listitem>
<listitem><para>Press the Cancel button (the push button with ID 2)</para></listitem>
<listitem><para>Press the Enter key (if OK or Cancel is the default button)</para></listitem>
<listitem><para>Press the Esc key</para></listitem></itemizedlist>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>Run is a protected method. You cannot call this method directly; it
is called by <link linkend="mthExecute">execute</link>.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthExecute"><title>execute</title>
<indexterm><primary>execute</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>execute</secondary></indexterm>
<programlisting>
<![CDATA[
>>--execute(--+-------------+--+---------+--)------------------><
              +--showOption-+  +-,--icon-+


]]>
</programlisting>

<para>
  The <emphasis role="italic">execute</emphasis> method, creates the <link linkend="ovvUnderlying">underlying</link>
  dialog, <link linkend="mthShowClsPlainBaseDialog">shows</link> it, starts the <link
  linkend="mthAddAutoStartMethod">automatic</link> methods, if any, and destroys the underlying dialog when the user
  closes it. If <link linkend="mthInitAutoDetection">auto detection</link> is on, the dialog <link
  linkend="sctUnderstandingDataAttributes">data</link> is passed to the underlying dialog before execution and received
  from it after the dialog is terminated.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>showOption [optional]</term>
    <listitem>
    <para>
      Zero or one of the following keywords to specify how the dialog is shown. This keyword is used in the automatic
      invocation of the <link linkend=mthShowClsPlainBaseDialog>show</link> method. Case is not significant. If this
      argument is omitted, the NORMAL keyword is used:
      <variablelist>
        <varlistentry><term>NORMAL</term>
        <listitem>
        <para>
          Makes the dialog visible in its default position and window size. This has the effect of restoring the dialog size
          and position if it is minimized or maximized. This is the default if the argument is omitted.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>DEFAULT</term>
        <listitem>
        <para>
          DEFAULT is an alias for NORMAL. The two keywords are functionally identical.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>SHOWTOP</term>
        <listitem>
        <para>
          Makes the dialog visible and the topmost window. Note that the dialog size and position are not restored if the
          dialog is minimized or maximized.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>HIDE</term>
        <listitem>
        <para>
          Makes the dialog invisible.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>MIN</term>
        <listitem>
        <para>
          Minimizes the dialog and activates the next window in the window order.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>MAX</term>
        <listitem>
        <para>
          Maximizes, and makes visible if necessary, the dialog.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>INACTIVE</term>
        <listitem>
        <para>
          Makes the dialog visible without changing the active window.  When the NORMAL keyword is used, the dialog is shown
          and becomes the active window. The INACTIVE keyword makes the dialog visible without changing the focuse from the
          current active window.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>RESTORE</term>
        <listitem>
        <para>
          Makes the dialog visible and restores it to its original size and position if it was minimized or maximized. An
          application should specify this flag when restoring a minimized window.
        </para>
        </listitem></varlistentry>
      </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>icon [optional]</term>
    <listitem>
    <para>
      The resource ID of the <link linkend="defDialogIcon">dialog's icon</link>. May be numeric or <link
      linkend="defSymbolicID">symbolic</link>.  If an icon ID is not supplied, the default ooDialog icon will be used.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">TERM:</emphasis></term>
  <listitem>
  <para>
    Although any of the show keywords can be used, for the <emphasis role="italic">execute</emphasis> method the
    SHOWTOP, HIDE, and MAX keywords make the most sense. SHOWTOP is the usual keyword.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return value is one of the following codes:
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      Some error ocurred, the dialog was not executed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The user terminated the dialog using an ok command.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>2</term>
    <listitem>
    <para>
      The user terminated the dialog using a cancel comamnd.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    If another ooDialog dialog has been started by the Rexx program, it is disabled when <emphasis
    role="italic">execute</emphasis> is invoked. This in effect makes the dialog a <link
    linkend="defModalModeless">modal</link> dialog. To start a <emphasis role="italic">modeless</emphasis> dialog use
    the <link linkend="mthPopup">popup</link> or <link linkend="mthPopupAsChild">popupAsChild</link> methods.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example instantiates a new <link linkend="clsUserDialog">UserDialog</link> subclass object. The dialog
    <link linkend="ovvDialogTemplate">template</link> is started by the <emphasis role="italic">create</emphasis>
    method and finished in the <emphasis role="italic">defineDialog</emphasis> method. Then the <emphasis
    role="italic">execute</emphasis> method runs the dialog as the topmost window.  The <link
    linkend="defDialogIcon">dialog icon</link> is set to one of the pre-defined icons supplied by ooDialog.
  </para>
  <para>
    When the user terminates the dialog, the return from <emphasis role="italic">execute</emphasis> is checked to
    determine how the user closed the dialog. Typically, if the user canceled the dialog, any changes in the dialog are
    ignored:

<programlisting>
<![CDATA[
dlg = .MyDialog~new(...)
dlg~create(...)

ret = dlg~execute("SHOWTOP", IDI_DLG_OOREXX)
if ret == 1 then do
  -- The user closed the dialog with the ok command.
  ...
end
else do
  -- The user canceled the dialog.
  ...
end

::class 'MyDialog' subclass UserDialog

...

::method defineDialog

  self~createStaticText(...)
  self~createEdit(...)
  self~createPushButton(...)
  ...

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthExecuteAsync"><title>executeAsync</title>
<indexterm><primary>executeAsync</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ExecuteAsync--+--------------+------------------->
                             +-(--sleeptime-+

>--+-----------------------------------------------+-----------><
   +-+----------------------------------------+--)-+
     +-,--+--------------------+--+---------+-+
          |    +-DEFAULT--+    |  +-,--icon-+
          +-"--+-NORMAL---+--"-+
               +-SHOWTOP--+
               +-HIDE-----+
               +-MIN------+
               +-MAX------+
               +-INACTIVE-+


]]>
</programlisting>

<para>The executeAsync method does the same as execute,
except that it dispatches messages asynchronously. Therefore the executeAsync
method returns immediately after the dialog has been started. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>sleeptime</term>
<listitem><para>The time slice, in milliseconds, until the next message is processed.
</para></listitem></varlistentry>
<varlistentry><term>show</term>
<listitem><para>See <link linkend=mthShowClsPlainBaseDialog>Show</link>.
</para></listitem></varlistentry>
<varlistentry><term>icon</term>
<listitem><para>The resource ID of the <link linkend="defDialogIcon">dialog's
icon</link>.  If an icon ID is not supplied, the default ooDialog icon will be
used.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The dialog was started.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>An error occurred. Do not call the EndAsyncExecution method in this
case.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example starts a dialog and runs the statements between
executeAsync and EndAsyncExecution asynchronously to the dialog:

<programlisting>
<![CDATA[
ret = MyDialog~executeAsync(1000, "SHOWTOP")
if ret = 0 then do
   ...
   /* Object Rexx statements to run while the dialog is executing */
   ...
   MyDialog~EndAsyncExecution
end
else do
   call errorDialog "Could not start dialog"
end
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000068"><title>EndAsyncExecution</title>
<indexterm><primary>EndAsyncExecution</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~EndAsyncExecution-------------------------------><


]]>
</programlisting>

<para>The EndAsyncExecution method is used to complete
the asynchronous execution of a dialog. It does not terminate the dialog but
waits until the user terminates it. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The dialog was not executed.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The dialog was terminated using the OK button.
</para></listitem></varlistentry>
<varlistentry><term>2</term>
<listitem><para>The dialog was terminated using the Cancel button.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>See the example in <link linkend="mthExecuteAsync">executeAsync</link>.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthPopup"><title>popup</title>
<indexterm><primary>popup</primary></indexterm>
<programlisting>
<![CDATA[
                          +-DEFAULT--+
>>-aBaseDialog~popup(--"--+----------+--"--+-------------------------------+--)-><
                          +-NORMAL---+     +-,--+-----------+--+---------+-+
                          +-SHOWTOP--+          +-sleeptime-+  +-,--icon-+
                          +-HIDE-----+
                          +-MIN------+
                          +-MAX------+
                          +-INACTIVE-+


]]>
</programlisting>

<para>The popup method starts a dialog, dispatches messages
asynchronously, and returns immediately after the dialog is started.</para>
<para>A dialog started with popup is independent of any other dialog. This means
that a dialog already started in the same process is not disabled by Popup.
You can therefore use popup to produce nonmodal dialogs.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>show</term>
<listitem><para>See <link linkend=mthShowClsPlainBaseDialog>Show</link>.
</para></listitem></varlistentry>
<varlistentry><term>sleeptime</term>
<listitem><para>The time, in milliseconds, until the next message is processed.
</para></listitem></varlistentry>
<varlistentry><term>icon</term>
<listitem><para>The resource ID of the <link linkend="defDialogIcon">dialog's
icon</link>.  If an icon ID is not supplied, the default ooDialog icon will be
used.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example starts a dialog and runs the statements after
popup asynchronously to the dialog. This means that the dialog reacts to an
event like pressing a button and calls the connected method while the DO loop
is being processed:</para>

<programlisting>
<![CDATA[
MyDialog~popup("SHOWTOP", 250)
do i = 1 to 1000
   say "Iteration" i
   call msSleep 100
end
]]>
</programlisting>
<para>This example could also be part of a method handling an event
of a dialog, for example dialog A. The newly started dialog MyDialog is independent
of dialog A. If dialog A is closed, MyDialog remains unaffected and active.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthPopupAsChild"><title>popupAsChild</title>
<indexterm><primary>popupAsChild</primary></indexterm>
<programlisting>
<![CDATA[
                                            +-DEFAULT--+
>>-aBaseDialog~popupAsChild(--parent--,--"--+----------+--"----->
                                            +-NORMAL---+
                                            +-SHOWTOP--+
                                            +-HIDE-----+
                                            +-MIN------+
                                            +-MAX------+
                                            +-INACTIVE-+

>--+-------------------------------+--)------------------------><
   +-,--+-----------+--+---------+-+
        +-sleeptime-+  +-,--icon-+


]]>
</programlisting>

<para>The popupAsChild method starts a dialog as a child
dialog of another dialog, dispatches messages asynchronously, and returns
immediately after the dialog is started.</para>
<para>A dialog started with popupAsChild and its parent dialog can be active
at the same time. This means that the parent dialog is not disabled by the
child dialog. You can therefore use popupAsChild to produce nonmodal dialogs.
However, the child dialog is automatically terminated when the parent dialog
is closed.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>parent</term>
<listitem><para>An object of the PlainBaseDialog class or one of its descendants that
is the parent of the newly started dialog.
</para></listitem></varlistentry>
<varlistentry><term>show</term>
<listitem><para>See <link linkend=mthShowClsPlainBaseDialog>Show</link>.
</para></listitem></varlistentry>
<varlistentry><term>sleeptime</term>
<listitem><para>The time, in milliseconds, until the next message is processed.
</para></listitem></varlistentry>
<varlistentry><term>icon</term>
<listitem><para>The resource ID of the <link linkend="defDialogIcon">dialog's
icon</link>.  If an icon ID is not supplied, the default ooDialog icon will be
used.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example starts a dialog and runs the statements after
popupAsChild asynchronously to the dialog. This means that the dialog reacts
to an event like pressing a button and calls the connected method while the
DO loop is being processed. The new dialog is started as a child of MyParent
and is therefore closed when the MyParent dialog is closed:</para>

<programlisting>
<![CDATA[
MyParent = .UserDialog~new
...
MyParent~popup("SHOWTOP")
...
MyDialog~popupAsChild(MyParent, "SHOWTOP", 250)
do i = 1 to 1000
   say "Iteration" i
   call msSleep 100
   if i = 800 then MyParent~Finished = 1  /* close both dialogs when i = 800 */
end
]]>
</programlisting>
<para>This example could also be part of a method handling an event
of a dialog, for example dialog A. The newly started dialog MyDialog is independent
of dialog A. If dialog A is closed, MyDialog remains unaffected and active.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000721"><title>IsDialogActive</title>
<indexterm><primary>IsDialogActive</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~IsDialogActive----------------------------------><


]]>
</programlisting>

<para>The IsDialogActive method returns 1 if the Windows dialog still exists. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example tests whether the dialog is active:

<programlisting>
<![CDATA[
if MyDialog~IsDialogActive then ...
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000756"><title>HandleMessages</title>
<indexterm><primary>HandleMessages</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~HandleMessages----------------------------------><


]]>
</programlisting>

<para>The HandleMessages method handles dialog messages
synchronously. It is called by <link linkend="mthExecute">execute</link>. HandleMessages
is a dispatcher that receives Windows events and posts the message that
is set to handle the event.</para>
</section>

<section id="peekdialogmessage"><title>PeekDialogMessage</title>
<indexterm><primary>PeekDialogMessage</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~PeekDialogMessage-------------------------------><


]]>
</programlisting>

<para>The PeekDialogMessage method returns the first
pending message of the dialog's message queue without removing it from
the message queue.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The first pending message or an empty string.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000763"><title>ClearMessages</title>
<indexterm><primary>ClearMessages</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ClearMessages-----------------------------------><


]]>
</programlisting>

<para>The ClearMessages method clears all pending dialog
messages.</para>
</section>

</section>

<section id="sctDataAttributes"><title>Data Attribute Methods</title>
<indexterm><primary>data attributes</primary></indexterm>
<indexterm><primary>connecting data attributes</primary></indexterm>
<indexterm><primary>get and set data methods</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>data attributes</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>get and set data methods</secondary></indexterm>

<section id="sctUnderstandingDataAttributes"><title>Understanding Data Attributes</title>
<indexterm><primary>dialog object</primary><secondary>understanding data attributes</secondary></indexterm>
<para>
  This section contains methods for working with <emphasis role="bold">data attributes</emphasis>. It contains methods
  to create a connection between the underlying dialog control and an attribute of the Rexx dialog object, methods for
  <emphasis role="bold">getting</emphasis> and <emphasis role="bold">setting</emphasis> the <emphasis
  role="bold">data</emphasis>, and methods to deal with <emphasis role="bold">automatic data detection</emphasis>. The
  data attribute is used to reflect the value associated with the underlying dialog control. For instance, the value of
  an <link linkend="clsEdit">edit</link> control could be thought of as the text of the control.
</para>
<para>
  In order to better understand the data attribute methods, it is userful to first discuss this concept in general.
  During the <link linkend="sctHistory">original</link> development of ooDialog the abstraction used was that there were
  only two objects.  One was the Rexx dialog object and the other was the <link
  linkend="ovvUnderlying">underlying</link> system dialog that the user sees on the screen. Dialog controls were not
  thought of as objects, but rather as the <emphasis role="bold">data</emphasis> of the underlying dialog. In this
  abstraction, the <emphasis role="bold">value</emphasis> of the data was the <emphasis role="bold">state</emphasis> of
  the dialog control.
</para>
<para>
  For instance, a radio button can be either checked or not checked. Therefore, its value could be 0 (not checked) or 1
  (checked.) Thus the data of the radio button would be a 1 or a 0. Using this abstraction of two objects, the Rexx
  dialog and the underlying on screen dialog, then leads to the idea of exchanging, or transferring, the data between
  the two objects. Or, typically, getting and setting the data of the underlying dialog. To facilitate this exchange of
  data, for each <emphasis role="bold">data item</emphasis>, (a dialog control,) in the underlying dialog an attribute
  is added to the Rexx dialog object. This attribute is then used to transfer data between the Rexx dialog object and
  the underlying dialog control. The value of each data attribute is a single string which represents the state of the
  dialog control.
</para>
<para>
  The operation of <emphasis role="bold">connecting</emphasis> a dialog control is the action of creating the attribute
  (the data attribute) in the Rexx dialog object, and internally mapping the attribute to the specified dialog control
  in the underlying dialog. The operation of <emphasis role="bold">seting data</emphasis> then becomes the action of
  setting the state of the underlying dialog control to match the value of the corresponding attribute of the Rexx
  dialog object. The operation of <emphasis role="bold">getting data</emphasis> becomes the action of setting the value
  of the attribute in the Rexx dialog object to match the state of the corresponding dialog control in the underlying
  dialog.
</para>
<para id="paraAutomaticDataDetection">
  The term <emphasis role="italic">automatic data field detection</emphasis> is used for this process of creating and
  connecting data attributes. In addition to creating and connecting the data attributes, if automatic data field
  detection is on, when the underling dialog is created, the state of its controls are automatically set to the values
  of the data attributes. Likewise, when the dialog is closed, the values of the data attributes in the Rexx dialog are
  set to the state of their correspondaing controls in the underlying dialog.
</para>
<para>
  Automatic data detection is implemented in all three main classes of dialogs, the <link
  linkend="clsUserDialog">UserDialog</link>, <link linkend="clsResDialog">ResDialog</link>, and <link
  linkend="clsRcDialog">RcDialog</link>, and of course their subclasses. Automatic data detection can be turned on or
  off. By default it is <emphasis role="bold">on</emphasis>. The best way to turn automatic data field detection off is
  to over-ride the <link linkend="mthInitAutoDetection">initAutoDetection</link>() method in your class.
</para>
<para>
  Some dialog controls are not considered to be <emphasis role="italic">data</emphasis> and therefore data attributes
  are not created for those controls. (This is a quirk going back to the original implementation of of ooDialog.) The
  non-data controls are those, in general, that the user would not change or update in a dialog. <link
  linkend="clsButton">Push buttons</link>, <link linkend="clsGroupBox">group boxes</link>, and <link
  linkend="clsStatic">static</link> controls are all considered non-data controls. There are no data attribute methods
  for these controls.
</para>
<para>
  When automatic data detection is turned off, the programmer can use the <link
  linkend="sctConnectDataMethods">connect...</link> attribute methods to manually create and connect the data attribute
  for any control. However, with automatic detection off, the ooDialog framework will not set the state of the dialog
  controls to match the values of the connected attributes when the underlying dialog is created. Likewise, when the
  dialog ends the connected attributes of the Rexx dialog object are not updated to the state of the dialog controls.
  But, the programmer can use the <link linkend="mthSetData">setData</link>() and <link
  linkend="mthGetData">getData</link>() methods to do this herself.
</para>
<para>
  The implementation of automatic data detection in the three main classes of dialogs is slightly different in each
  class due to the differences in the classes:

  <variablelist>
    <varlistentry><term><emphasis role="bold">UserDialog:</emphasis></term>
    <listitem>
    <para>
      In a <link linkend="clsUserDialog">UserDialog</link> the <link linkend="sctConnectDataMethods">connect...</link>
      attribute methods are called automatically from the <link linkend="sctCreateMethods">create...</link> methods of the
      <computeroutput>UserDialog</computeroutput>. Each of the create... methods takes an optional argument that allows
      the programmer to specify the data attribute name. If that argument is omitted, the attribute name is <link
      linkend="sctDataAttributeNames">automatically</link> generated. This behavior is only when automatic data
      detection is on. When it is off, no data connection is made, even if the argument name is specified.
    </para>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">RcDialog</emphasis></term>
    <listitem>
    <para>
      A <link linkend="clsRcDialog">RcDialog</link> is actually a subclass of the
      <computeroutput>UserDialog</computeroutput>. Therefore, when automatic data detection is on, the connect...
      attribute methods are invoked automatically during the creation of each dialog control. The difference is that
      there is no option to specify the attribute name, the name is <emphasis role="bold">always</emphasis> generated
      automatically.
    </para>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">ResDialog</emphasis></term>
    <listitem>
    <para>
      With a <link linkend="clsResDialog">ResDialog</link> the data connections are made after the underlying dialog is
      created. Internally, the numeric resource ID and text of each control in the dialog is determined. Then, a data
      attribute for each control is created and connected. Again, there is no way for the programmer to specify the data
      attribute name, it is always automatically constructed.
    </para>
    </listitem></varlistentry>
  </variablelist>
  Obviously, the data attribute itself can not be accessed until it is created. For each type of class this is at a
  subtly different point in the life cycle of the dialog.
</para>
<para>
  In summary: When automatic data field detection is on, the ooDialog framework automatically creates an attribute in
  the dialog object for each dialog control in the underlying dialog. The attribute is connected to the control through
  an internal mapping maintained by the framework. Once the connection is made, it can be used to get or set the
  <emphasis role="italic">data</emphasis> of the control.  The data of a control is a string representation of the
  control's state. When each underlying dialog is created, the state of all its controls is set to the value of its
  connected data attribute. When the underlying dialog is closed by the user, the process is reversed. Each data
  attribute is updated to reflect the state of the dialog control when the dialog was closed. For the most part, the
  name of the data attribute is generated automatically by the framework. When automatic data field detection is off,
  none of this is done, but there are methods the programmer can use to manually do the same things.
</para>
</section>

<section id="sctDataAttributeNames"><title>Data Attribute Names</title>
<indexterm><primary>data attribute names</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>data attribute names</secondary></indexterm>
<para>
  Except when the programmer explicitly names the data attribute in one of the <link
  linkend="sctConnectDataMethods">connect...</link> methods, or one of the <link
  linkend="sctCreateMethods">create...</link> methods of the <computeroutput>UserDialog</computeroutput>, the data
  attribute names are generated internally. Even when the name is explicitly specified by the programmer, if the name is
  not a valid method name or is a duplicate method name, the attribute name is generated internally. The rules for how
  the attribute names are generated can be a little difficult to grasp. The following list is intended to be complete
  description of the rules in all circumstances.

  <variablelist>
    <varlistentry id="termConnectAutoNames"><term><emphasis role="bold">connect... data attribute methods:</emphasis></term>
    <listitem>
    <para>
      When the programmer uses one of the <link linkend="sctConnectDataMethods">connect...</link> methods, the attribute
      name can be omitted, or the name specified could not be valid. For these cases, the internally generated name is
      created in this way:
    </para>
    <para>
      If the name is omitted, then the name is created by prepending <computeroutput>DATA</computeroutput> with the
      resource ID argument. Recall that the resource ID argument can possibly be a symbolic ID. Example:

<programlisting>
<![CDATA[
  -- The attribute name will be DATA202
  self~connectEdit(202)

  -- The attribute name will be DATAIDC_EDIT_FNAME
  self~connectEdit(IDC_EDIT_FNAME)
]]>
</programlisting>
    </para>
    <para>
      Whether the attribute name was specified or not, before the attribute is actually added to the dialog object, the
      name is checked to see that it is a valid method name, that it is not the empty string, and not a duplicate of an
      already existing method name in the dialog. When the check fails, the name is created by prepending
      <computeroutput>DATA</computeroutput> with the <emphasis role="bold">numeric</emphasis> value of the
      resource ID argument. This is true even when the id argument is specified as a symbolic ID. Example:

<programlisting>
<![CDATA[
  self~constDir[IDC_EDIT_FNAME] = 344

  -- The attribute name will be DATA202
  self~connectEdit(202, "COPY")

  -- The attribute name will be DATA344
  self~connectEdit(IDC_EDIT_FNAME, 'FNAME+ADDRESSBOOK')

]]>
</programlisting>
    </para>
    </listitem></varlistentry>
    <varlistentry id="termCreateAutoNames"><term><emphasis role="bold">UserDialog create... methods:</emphasis></term>
    <listitem>
    <para>
      In the typical <computeroutput>UserDialog</computeroutput>all cotrols are added to the dialog by using one of the
      <link linkend="sctCreateMethods">create...</link> methods. This is similar to using one of the connect... methods.
      The attribute name argument can be omitted, or the specified attribute name might not be valid. For these cases,
      the internally generated name is created in this way:
    </para>
    <para>
      If the name is omitted, and the dialog control is <emphasis role="bold">not</emphasis> a check box or radio
      button, then the name is created by prepending <computeroutput>DATA</computeroutput> with the numeric value of the
      resource ID argument. Example:

<programlisting>
<![CDATA[
  self~constDir[IDC_EDIT_FNAME] = 344

  -- The attribute name will be DATA344
  self~createEdit(344, 10, 10, 100, 12, "AUTOSCROLLH MULTILINE")

  -- The attribute name will be DATA344
  self~createEdit(IDC_EDIT_FNAME, 10, 10, 100, 12, "AUTOSCROLLH MULTILINE")
]]>
</programlisting>
    </para>
    <para>
      If the name is omitted and the dialog control <emphasis role="bold">is</emphasis> a check box or radio button,
      then the name is created from the text of the <emphasis role="bold">label</emphasis> of the button. First all
      spaces, ampersands, and colons, if any, are removed from the label. The result is used for the attribute name.
      Examples:

<programlisting>
<![CDATA[
  self~constDir[IDC_CHK_LN] = 200
  self~constDir[IDC_CHK_MAIL] = 201
  self~constDir[IDC_CHK_RECEIPT] = 202

  -- The attribute name will be USELASTNAME
  self~createCheckBox(IDC_CHK_LN, 10, 10, 80, 12, "GROUP", "&Use last name")

  -- The attribute name will be MAILITEM
  self~createCheckBox(IDC_CHK_MAIL, 10, 27, 80, 12, "RBUTTON RIGHT", "Mail item:")

  -- The attribute name will be RECEIPT
  self~createCheckBox(IDC_CHK_RECEIPT, 10, 45, 80, 12, , "Receipt")
]]>
</programlisting>
    </para>
    <para>
      Whether the attribute name was specified or generated by the framework, the name is always checked to see if it is
      the empty string, not a valid method name, or a duplicate of an already existing method name in the dialog.  When
      the check fails, then the name is created by prepending <computeroutput>DATA</computeroutput> with the <emphasis
      role="bold">numeric</emphasis> value of the resource ID argument. This is true even when the id argument is
      specified as a symbolic ID. Examples:

<programlisting>
<![CDATA[
  self~constDir[IDC_EDIT_CLASS] = 344
  self~constDir[IDC_CHK_DEFAULTNAME] = 201
  self~constDir[IDC_CHK_COPY] = 202

  -- The attribute name will be DATA344 (CLASS is an existing method name.)
  self~createEdit(IDC_EDIT_CLASS, 10, 10, 100, 12, "AUTOSCROLLH MULTILINE", "Class")

  -- The attribute name will be DATA201 (defaultName is an existing method name.)
  self~createCheckBox(IDC_CHK_DEFAULTNAME, 10, 27, 80, 12, , "Default Name")

  -- The attribute name will be DATA202
  self~createCheckBox(IDC_CHK_COPY, 10, 45, 80, 12, , "&Copy")

]]>
</programlisting>
    </para>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">ResDialog:</emphasis></term>
    <listitem>
    <para>
      For a <computeroutput>ResDialog</computeroutput>, the attribute names are always generated by the ooDialog
      framework, there is no way for the programmer to specify the name. When the underlying dialog is created, the
      numeric resource ID and the text of all the dialog controls is collected. For <emphasis
      role="bold">each</emphasis> control, the data attribute is created using the <emphasis role="bold">text</emphasis>
      of the control.
    </para>
    <para>
      <emphasis role="bold">Note</emphasis> this important detail: every dialog control can have text associated with it
      when compiled from a <link linkend="defResourceScript">resource script</link>. Although for many controls, text is
      not usually associated with them, it is always possible that they do have text.
    </para>
    <para>
      The text of the control has all spaces, ampersands, and colons removed. The result is checked as usual. If it is
      the empty string, or not a valid method name, or a duplicate of an existing method name, then the attribute name
      is changed to <computeroutput>DATA</computeroutput> prepended to the resource ID. The attribute name then follows
      the pattern(s) already seen. Examples:

<programlisting>
<![CDATA[
  -- For an edit control with resource ID 344 and no associated text:
  DATA344

  -- For a check box with resource ID 400 and a label of "Compile":
  COMPILE

  -- For a radio button with resource ID 200 and a label of "&Copy":
  DATA200

  -- For a tree view with resource 320 and text associated of "C: Drive"
  CDRIVE

  -- Same tree view with no text assoicate, (the usual case):
  DATA320

  -- etc..

]]>
</programlisting>
    </para>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">RcDialog:</emphasis></term>
    <listitem>
    <para>
      Although a <computeroutput>RcDialog</computeroutput> is actually a subclass of a
      <computeroutput>UserDialog</computeroutput> and the dialog controls are added to the dialog <link
      linkend="ovvDialogTemplate">template</link> through the <link linkend="sctCreateMethods">create...</link> methods,
      the generated attribute names have a different pattern. If the resource ID of the control in the <link
      linkend="defResourceScript">resource script</link> file is a symbolic ID, then the attribute name will be the
      symbolic ID. On the other hand, if the resource ID is numeric in the resource script file, then the attribute name
      will be <computeroutput>DATA</computeroutput> prepended to the numeric ID. Example:

<programlisting>
<![CDATA[
  -- For this resource script file:

//
// Dialog resources
//
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
IDD_DIALOG1 DIALOGEX 0, 0, 237, 131
STYLE  DS_MODALFRAME | WS_VISIBLE | WS_BORDER | WS_CAPTION | WS_DLGFRAME | WS_SYSMENU
CAPTION "Dialog"
FONT 8, "MS Shell Dlg 2", 400, 0, 1
{
    EDITTEXT        1003, 27, 22, 116, 47, WS_GROUP | ES_AUTOHSCROLL | ES_MULTILINE
    EDITTEXT        IDC_EDIT2, 27, 84, 116, 12, ES_AUTOHSCROLL
    AUTOCHECKBOX    "Hello There", IDC_CHK_TEST, 27, 109, 52, 10
    DEFPUSHBUTTON   "OK", IDOK, 125, 107, 50, 14
    PUSHBUTTON      "Cancel", IDCANCEL, 177, 107, 50, 14
    LTEXT           "Just a test of a static control", IDC_ST_TEST, 163, 28, 54, 24, SS_LEFT
}

  -- The attribute names will be:

  DATA1003
  IDC_EDIT2
  IDC_CHK_TEST

]]>
</programlisting>
    </para>
    <para>
      However, as always, the attribute name is checked to be a valid method name, not the empty string, and not a
      duplicate of an existing method name. If the resource script file is valid, it can not be the empty string.
      Usually, programmers do not name their symbolic IDs in a fashion that would conflict with an existing method name,
      but there is no reason why they could not. If the check fails, then the attribute name will once again be
      <computeroutput>DATA</computeroutput> prepended to the <emphasis role="bold">numeric</emphasis> value of the
      resource ID.  Example:

<programlisting>
<![CDATA[
  -- For this resource script file:

#define COPY 1004

//
// Dialog resources
//
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
IDD_DIALOG1 DIALOGEX 0, 0, 237, 131
STYLE  DS_MODALFRAME | WS_VISIBLE | WS_BORDER | WS_CAPTION | WS_DLGFRAME | WS_SYSMENU
CAPTION "Dialog"
FONT 8, "MS Shell Dlg 2", 400, 0, 1
{
    EDITTEXT        1003, 27, 22, 116, 47, WS_GROUP | ES_AUTOHSCROLL | ES_MULTILINE
    EDITTEXT        IDC_EDIT2, 27, 84, 116, 12, ES_AUTOHSCROLL
    AUTOCHECKBOX    "Hello There", COPY, 27, 109, 52, 10
    DEFPUSHBUTTON   "OK", IDOK, 125, 107, 50, 14
    PUSHBUTTON      "Cancel", IDCANCEL, 177, 107, 50, 14
    LTEXT           "Just a test of a static control", IDC_ST_TEST, 163, 28, 54, 24, SS_LEFT
}

  -- The attribute names will be:

  DATA1003
  IDC_EDIT2
  DATA1004

]]>
</programlisting>
    </para>
    </listitem></varlistentry>
  </variablelist>
</para>

</section>

<section id="sctDataAttributeProblems"><title>Problems with Data Attributes</title>
<indexterm><primary>data attribute problems</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>data attribute problems</secondary></indexterm>
<para>
  In the author's mind, there are a number of problems with the whole data attribute concept. In no particular oder,
  some of them are brought up here.
</para>
<para>
  The abstraction that there are only two objects, the Rexx dialog object and the underlying operating system dialog, is
  a little outdated. In this abstraction, the state of a dialog control can only be represented by a single string, and
  the state must be transferred back and forth through the dialog object. The abstraction works somewhat for simple
  controls like a check box, a radio button, or an edit control. However it quickly starts to break down with more
  complex controls like tree views and list views. Indeed, when the more complicated controls were added to ooDialog,
  there were no get and set data methods implemente for them.  There is no <emphasis
  role="italic">getTreeViewData</emphasis> or <emphasis role="italic">setListViewData</emphasis> method.
</para>
<para>
  A more flexible abstraction is that everything is an object, that all the dialog controls are objects. In this
  abstraction, the state of a dialog control is set or queried directly through methods of the dialog control object.
  Current development in ooDialog is done using this abstraction.
</para>
<para>
  Presumably the automatic data field detection was done to make things easier for the Rexx programmer. However, the
  whole process is actually quite confusing. The data attributes themselves are not visible in the program, which often
  makes it difficult to read and understand a program. When the attribute names are generated automatically, it is often
  quite difficult to know exactly what the name is.
</para>
<para>
  With auto detection on, the states of the dialog controls are set to the data (values) of the corresponding data
  attributes. This is done <emphasis role="bold">after</emphasis> <link linkend="mthInitDialog">initDialog</link>() is
  invoked. The consequence of this is that, if the programmer explicitly sets the state of the dialog controls in the
  <emphasis role="italic">initDialog</emphasis>() method, the ooDialog framwork will then <emphasis
  role="bold">reset</emphasis> the state of all the dialog controls afterwards. This can be disconcerting to the
  programmer if automatic data field detection is not understood.
</para>

</section>

<section id="mthInitAutoDetection"><title>initAutoDetection</title>
<indexterm><primary>initAutoDetection</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>initAutoDetection</secondary></indexterm>
<programlisting>
<![CDATA[
>>-initAutoDetection-------------------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">initAutoDetection</emphasis> method is invoked automatically by the ooDialog framework
  when any dialog is first instantiated. The default implementation of <emphasis
  role="italic">initAutoDetection</emphasis> turns <link linkend="paraAutomaticDataDetection">automatic data field
  detection</link> on.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    This method is private. It is meant to be over-ridden by the programmer in her subclass to change the default
    behavior of turning automatic data field detection on.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example overrides <emphasis role="italic">initAutoDetection</emphasis> method to switch off auto
    detection:

<programlisting>
<![CDATA[
::class 'AddressBookDialog' subclass ResDialog
::method initAutoDetection
   self~noAutoDetection
]]>
</programlisting>
  </para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthNoAutoDetection"><title>noAutoDetection</title>
<indexterm><primary>noAutoDetection</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>noAutoDetection</secondary></indexterm>
<programlisting>
<![CDATA[
>>--noAutoDetection--------------------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">noAutoDetection</emphasis> method switches off <link
  linkend="paraAutomaticDataDetection">automatic</link> data detection.
</para>
</section>

<section id="mthAutoDetection"><title>autoDetection</title>
<indexterm><primary>autoDetection</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>autoDetection</secondary></indexterm>
<programlisting>
<![CDATA[
>>--autoDetection----------------------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">autoDetection</emphasis> method switches on <link
  linkend="paraAutomaticDataDetection">automatic</link> data detection.
</para>
</section>

<section id="sctConnectDataMethods"><title>Connect Data Attribute Methods</title>
<indexterm><primary>connect data attribute methods</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connect data attribute methods</secondary></indexterm>
<para>
  The methods in this section are used to manually create and connect a <link
  linkend="sctUnderstandingDataAttributes">data attribute</link>. Their purpose is to manually do what is done when
  <link linkend="mthInitAutoDetection">automatic</link> data field detection is on. They should only be used when
  automatic detection is off.
</para>

<section id="mthConnectEdit"><title>connectEdit</title>
<indexterm><primary>connectEdit</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectEdit</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectEdit(--id--+------------------+--)------------------><
                      +-,--attributeName-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectEdit</emphasis> method creates a new <link
  linkend="sctUnderstandingDataAttributes">data</link> attribute in the Rexx dialog object and connects it to the
  underlying edit control using its resource id.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the edit control to be connected. Can be numeric or symbolic.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>attributeName [optional]</term>
    <listitem>
    <para>
      The name of the data attribute to be created. If this argument is omitted or invalid, the attribute name is
      generated <link linkend="termConnectAutoNames">automatically</link>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      A symbolic ID was used and it could not be resolved.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The data attribute was created but it was not connected. (The data connection table is full.)
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
    <listitem>
    <para>
      The attribute has to be synchronized with the edit control manually. This can be done globally with the <link
      linkend="mthSetData">setData</link> and <link linkend="mthGetData">getData</link> methods. For a finer grain of
      control use the <link linkend="mthSetDataAttribute">setDataAttribute</link>() or <link
      linkend="mthGetDataAttribute">getDataAttribute</link>() methods.
    </para>
    <para>
      The <emphasis role="italic">data</emphasis> of an edit control is defined to be the text entered in the control.
      If there is no text, the data is the empty string.
    </para>
    <para>
      The <emphasis role="italic">connectEdit</emphasis> should only be used when automatic data <link
      linkend="paraAutomaticDataDetection">detection</link> is off.
    </para>
    </listitem></varlistentry>
  <varlistentry id="exampleConnectEdit"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    In the following example, the edit control with symbolic resource ID IDC_EDIT is connected to the Rexx dialog
    object's <emphasis role="italic">NAME</emphasis> attribute. The connection process creates the data attribute. The
    string: <emphasis role="italic">Put your name here</emphasis> is assigned to the newly created data attribute. When
    the dialog is executed, the underlying edit control is manually synchronized with the attribute. This has the
    effect of setting the text of the edit control to the value of the attribute, which is the string, Put your name
    here.
  </para>
  <para>
    When the dialog is closed by the user with an <emphasis role="italic">ok</emphasis> command, the data attribute is
    manually synchronized with the state of the edit control. The state of an edit control is defined to be the text
    within the control. This synchronization has the effect of copying whatever text is in the edit control to the data
    attribute. Then, when the dialog has terminated, the name the user entered is displayed. (Of course the user may not
    have entered her name. What is displayed is whatever the text in the edit control was when the dialog was closed.)

<programlisting>
<![CDATA[

  dlg = .NameDlg~new("nameExample.dll", IDD_DIALOG1, , "nameExample.h" )

  if dlg~initCode == 0 then do
    dlg~noAutoDetection
    dlg~connectEdit(IDC_EDIT, "NAME")
    dlg~name = "Put your name here"

    ret = dlg~execute("SHOWTOP", IDI_DLG_OOREXX)

    if ret == 1 then say "The user's name is:" dlg~name
    else say "The user canceled."
  end

return 0

::requires "ooDialog.cls"

::class 'NameDlg' subclass ResDialog

::method initDialog
  self~setDataAttribute("NAME")

::method ok
  self~getDataAttribute("NAME")
  self~ok:super

]]>
  </programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectComboBox"><title>connectComboBox</title>
<indexterm><primary>connectComboBox</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectComboBox</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectComboBox(--id--+------------------+-----------------><
                          +-,-attributeName--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectComboBox</emphasis> method creates a <link
  linkend="sctUnderstandingDataAttributes">data attribute</link> in the Rexx dialog object and connects it to a
  combo box control in the underlying dialog using its resource id.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the combo box control to be connected. Can be numeric or symbolic.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>attributeName [optional]</term>
    <listitem>
    <para>
      The name of the data attribute to be created. If this argument is omitted or invalid, the attribute name is
      generated <link linkend="termConnectAutoNames">automatically</link>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      A symbolic ID was used and it could not be resolved.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The data attribute was created but it was not connected. (The data connection table is full.)
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
    <listitem>
    <para>
      The attribute has to be synchronized with the combo box control manually. This can be done globally with the <link
      linkend="mthSetData">setData</link> and <link linkend="mthGetData">getData</link> methods. For a finer grain of
      control use the <link linkend="mthSetDataAttribute">setDataAttribute</link>() or <link
      linkend="mthGetDataAttribute">getDataAttribute</link>() methods.
    </para>
    <para>
      The <emphasis role="italic">data</emphasis> of a <link linkend="clsComboBox">combo box</link> is defined to be the
      text in the selection field or the selected list item.
    </para>
    <para>
      The <emphasis role="italic">connectComboBox</emphasis> should only be used when automatic data <link
      linkend="paraAutomaticDataDetection">detection</link> is off.
    </para>
    </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The <link linkend="exampleConnectEdit">example</link> for the <emphasis role="italic">connectEdit</emphasis> method
    demonstrates all the pertinent steps to manually connect and use a data attribute for a dialog control. Simply
    substitute a combo box for the edit control.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectCheckBox"><title>connectCheckBox</title>
<indexterm><primary>connectCheckBox</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectCheckBox</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connctChectBox(--id--+-------------------+--)--------------><
                         +-,--attributeName--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectCheckBox</emphasis> method connects a check box in the underlying dialog, through
  its resource ID, to a newly created <link linkend="sctUnderstandingDataAttributes">data attribute</link>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the check box control to be connected. Can be numeric or symbolic.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>attributeName [optional]</term>
    <listitem>
    <para>
      The name of the data attribute to be created. If this argument is omitted or invalid, the attribute name is
      generated <link linkend="termConnectAutoNames">automatically</link>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      A symbolic ID was used and it could not be resolved.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The data attribute was created but it was not connected. (The data connection table is full.)
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
    <listitem>
    <para>
      The attribute has to be synchronized with the check box control manually. This can be done globally with the <link
      linkend="mthSetData">setData</link> and <link linkend="mthGetData">getData</link> methods. For a finer grain of
      control use the <link linkend="mthSetDataAttribute">setDataAttribute</link>() or <link
      linkend="mthGetDataAttribute">getDataAttribute</link>() methods.
    </para>
    <para>
      The <emphasis role="italic">data</emphasis> of a <link linkend="clsCheckBox">check box</link> is defined to be the
      its check state. For normal check boxes this is 0 for not checked and 1 for checked. Three-state check boxes have
      the additional indeterminate state. The value for the indeterminate state is 2.
    </para>
    <para>
      The <emphasis role="italic">connectCheckBox</emphasis> method should only be used when automatic data <link
      linkend="paraAutomaticDataDetection">detection</link> is off.
    </para>
    </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The <link linkend="exampleConnectEdit">example</link> for the <emphasis role="italic">connectEdit</emphasis> method
    demonstrates all the pertinent steps to manually connect and use a data attribute for a dialog control. Simply
    substitute a check box for the edit control.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectRadioButton"><title>connectRadioButton</title>
<indexterm><primary>connectRadioButton</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectRadioButton</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectRadioButton(--id--+-------------------+-------------><
                             +-,--attributeName--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectRadioButton</emphasis> method uses the resource id of a radio button control to
  connect the control in the underlying dialog to a newly created <link
  linkend="sctUnderstandingDataAttributes">data attribute</link> in the Rexx dialog object.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the radio button control to be connected. Can be numeric or symbolic.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>attributeName [optional]</term>
    <listitem>
    <para>
      The name of the data attribute to be created. If this argument is omitted or invalid, the attribute name is
      generated <link linkend="termConnectAutoNames">automatically</link>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      A symbolic ID was used and it could not be resolved.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The data attribute was created but it was not connected. (The data connection table is full.)
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
    <listitem>
    <para>
      The attribute has to be synchronized with the radio button control manually. This can be done globally with the
      <link linkend="mthSetData">setData</link> and <link linkend="mthGetData">getData</link> methods. For a finer grain
      of control use the <link linkend="mthSetDataAttribute">setDataAttribute</link>() or <link
      linkend="mthGetDataAttribute">getDataAttribute</link>() methods.
    </para>
    <para>
      The <emphasis role="italic">data</emphasis> of a <link linkend="clsRadioButton">radio button</link> is defined to
      be the its check state. This is 0 for not checked and 1 for checked.
    </para>
    <para>
      The <emphasis role="italic">connectRadioButton</emphasis> method should only be used when automatic data <link
      linkend="paraAutomaticDataDetection">detection</link> is off.
    </para>
    </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The <link linkend="exampleConnectEdit">example</link> for the <emphasis role="italic">connectEdit</emphasis> method
    demonstrates all the pertinent steps to manually connect and use a data attribute for a dialog control. Simply
    substitute a radio button for the edit control.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectListBox"><title>connectListBox</title>
<indexterm><primary>connectListBox</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectListBox</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectListBox(--id--+-------------------+--)--------------><
                         +-,--attributeName--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectListBox</emphasis> method uses the resource ID to connect a list box in the
  underlying dialog to a newly created <link linkend="sctUnderstandingDataAttributes">data attribute</link> in the Rexx
  dialog object.
  The value of the attribute is the number of the selected line. Therefore, if the attribute value is 3, the third line
  is currently selected or will be selected, depending on whether you set data to the dialog or receive it. See <link
  linkend="mthConnectEdit">connectEdit</link> for a more detailed description.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the list box to be connected. Can be numeric or symbolic.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>attributeName [optional]</term>
    <listitem>
    <para>
      The name of the data attribute to be created. If this argument is omitted or invalid, the attribute name is
      generated <link linkend="termConnectAutoNames">automatically</link>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      A symbolic ID was used and it could not be resolved.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The data attribute was created but it was not connected. (The data connection table is full.)
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
    <listitem>
    <para>
      The attribute has to be synchronized with the list box manually. This can be done globally with the
      <link linkend="mthSetData">setData</link> and <link linkend="mthGetData">getData</link> methods. For a finer grain
      of control use the <link linkend="mthSetDataAttribute">setDataAttribute</link>() or <link
      linkend="mthGetDataAttribute">getDataAttribute</link>() methods.
    </para>
    <para>
      The <emphasis role="italic">data</emphasis> of a <emphasis role="bold">single-selection</emphasis> <link
      linkend="clsListBox">list box</link> is defined to be text of the selected item in the list box.
    </para>
    <para>
      The <emphasis role="italic">data</emphasis> of a <emphasis role="bold">multi-selection</emphasis> <link
      linkend="clsListBox">list box</link> is defined to be a string containing the item numbers of its selected items,
      separated by a blank. For a multi-selection list box the string could contain any number of list items depending
      on what the user has selected, (for getting data,) or what the programmer is setting to be selected, (for setting
      data.)
    </para>
    <para>
      The <emphasis role="italic">connectListBox</emphasis> method should only be used when automatic data <link
      linkend="paraAutomaticDataDetection">detection</link> is off.
    </para>
    </listitem></varlistentry>
  <varlistentry id="exampleConnectListBoxSingle"><term><emphasis role="bold">Example Single Selection:</emphasis></term>
  <listitem>
  <para>
    This example shows how to use the <emphasis role="italic">connectListBox</emphasis> method with a single-selection
    list box. It is very similar to the <link linkend="exampleConnectEdit">example</link> for the <emphasis
    role="italic">connectEdit</emphasis> method. The code can be copied and pasted into the appropriate files to create
    a working example.

<programlisting>
<![CDATA[

/* singleSelection.rex */

  dlg = .SingleSelectionDlg~new("singleSelection.rc", IDD_SINGLE_SELECTION_DLG, , "singleSelection.h" )
  if dlg~initCode == 0 then do
    dlg~noAutoDetection
    dlg~connectListBox(IDC_LB_STATES, "LISTBOX")
    dlg~listBox = "California"

    ret = dlg~execute("SHOWTOP", IDI_DLG_OOREXX)

    if ret == 1 then say "The user's home state is:" dlg~listBox
    else say "The user canceled."
  end

return 0

::requires "ooDialog.cls"

::class 'SingleSelectionDlg' subclass RcDialog

::method initDialog

  states = self~getStateArray
  listBox = self~newListBox(IDC_LB_STATES)

  do state over states
    listBox~add(state)
  end

  self~setDataAttribute("LISTBOX")

::method ok
  self~getDataAttribute("LISTBOX")
  self~ok:super


::method getStateArray private

  a = .array~of(...)
  return a

/* End of singleSelection.rex */


/* Place this code in a file named "singleSelection.h" */

#ifndef IDC_STATIC
#define IDC_STATIC (-1)
#endif

#define IDD_SINGLE_SELECTION_DLG                 100
#define IDC_LB_STATES                           1003

/* Place this code in a file called singleSelection.rc. Two lines will wrap below:
 * The line that begins "STYLE DS_3DLOOK" is all one line until the line that
 * begins with "CAPTION" Likewise the "LISTBOX" line is all one line until the
 * "DEFPUSHBUTTON" line. These lines will need to be fixed after the copy and
 * paste.
 */


#include <windows.h>
#include "singleSelection.h"

LANGUAGE 0, SUBLANG_NEUTRAL
IDD_SINGLE_SELECTION_DLG DIALOG 0, 0, 186, 148
STYLE DS_3DLOOK | DS_CENTER | DS_MODALFRAME | DS_FIXEDSYS | WS_VISIBLE | WS_BORDER | WS_CAPTION | WS_DLGFRAME | WS_POPUP | WS_SYSMENU
CAPTION "Home State"
FONT 8, "Ms Shell Dlg 2"
{
    CTEXT           "Select Your Home State", IDC_STATIC, 29, 12, 127, 11, SS_CENTER
    LISTBOX         IDC_LB_STATES, 25, 31, 137, 84, WS_TABSTOP | WS_VSCROLL | LBS_NOINTEGRALHEIGHT | LBS_SORT | LBS_NOTIFY
    DEFPUSHBUTTON   "OK", IDOK, 71, 124, 50, 14
    PUSHBUTTON      "Cancel", IDCANCEL, 126, 124, 50, 14
}

/* Use this code to replace the .array~of(...) statement in the Rexx program. */
  a = .array~of( -
                "Alabama", -
                "Alaska", -
                "American Samoa", -
                "Arizona", -
                "Arkansas", -
                "California", -
                "Colorado", -
                "Connecticut", -
                "Delaware", -
                "District of Columbia", -
                "Florida", -
                "Georgia", -
                "Guam", -
                "Hawaii", -
                "Idaho", -
                "Illinois", -
                "Indiana", -
                "Iowa", -
                "Kansas", -
                "Kentucky", -
                "Louisiana", -
                "Maine", -
                "Maryland", -
                "Massachusetts", -
                "Michigan", -
                "Minnesota", -
                "Mississippi", -
                "Missouri", -
                "Montana", -
                "Nebraska", -
                "Nevada", -
                "New Hampshire", -
                "New Jersey", -
                "New Mexico", -
                "New York", -
                "North Carolina", -
                "North Dakota", -
                "Northern Marianas Islands", -
                "Ohio", -
                "Oklahoma", -
                "Oregon", -
                "Pennsylvania", -
                "Puerto Rico", -
                "Rhode Island", -
                "South Carolina", -
                "South Dakota", -
                "Tennessee", -
                "Texas", -
                "Utah", -
                "Vermont", -
                "Virginia", -
                "Virgin Islands", -
                "Washington", -
                "West Virginia", -
                "Wisconsin", -
                "Wyoming")

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
  <varlistentry id="exampleConnectListBoxMulti"><term><emphasis role="bold">Example Mulit Selection:</emphasis></term>
  <listitem>
  <para>
    This example shows how to use the <emphasis role="italic">connectListBox</emphasis> method with a multi-selection
    list box. It is also very similar to the <link linkend="exampleConnectEdit">example</link> for the <emphasis
    role="italic">connectEdit</emphasis> method.

<programlisting>
<![CDATA[

/* multiSelection.rex */

  dlg = .MultiSelectionDlg~new("multiSelection.rc", IDD_MULTI_SELECTION_DLG, , "multiSelection.h" )
  if dlg~initCode == 0 then do
    dlg~noAutoDetection
    dlg~connectListBox(IDC_LB_STATES, "LISTBOX")
    dlg~listBox = "4 6 7 49"

    ret = dlg~execute("SHOWTOP", IDI_DLG_OOREXX)

    if ret == 1 then do
      indexes = dlg~listBox~makeArray(" ")
      states = getStateArray()

      say "The user has visited these states:"
      do index over indexes
        say " " states[index]
      end
    end
    else do
      say "The user canceled."
    end
  end

return 0

::requires "ooDialog.cls"

::class 'MultiSelectionDlg' subclass RcDialog

::method initDialog

  states = getStateArray()
  listBox = self~newListBox(IDC_LB_STATES)

  do state over states
    listBox~add(state)
  end

  self~setDataAttribute("LISTBOX")

::method ok
  self~getDataAttribute("LISTBOX")
  self~ok:super


::routine getStateArray public
  a = .array~of(...)
  return a

/* Place this code in a file called multiSelection.rc. Two lines will wrap below:
 * The line that begins "STYLE DS_3DLOOK" is all one line until the line that
 * begins with "CAPTION" Likewise the "LISTBOX" line is all one line until the
 * "DEFPUSHBUTTON" line. These lines will need to be fixed after the copy and
 * paste.
 */

#include <windows.h>
#include "multiSelection.h"

LANGUAGE 0, SUBLANG_NEUTRAL
IDD_MULTI_SELECTION_DLG DIALOG 0, 0, 186, 148
STYLE DS_3DLOOK | DS_CENTER | DS_MODALFRAME | DS_FIXEDSYS | WS_VISIBLE | WS_BORDER | WS_CAPTION | WS_DLGFRAME | WS_POPUP | WS_SYSMENU
CAPTION "Visted States"
FONT 8, "Ms Shell Dlg 2"
{
    CTEXT           "Select the states you've visited", IDC_STATIC, 29, 12, 127, 11, SS_CENTER
    LISTBOX         IDC_LB_STATES, 25, 31, 137, 84, WS_TABSTOP | WS_VSCROLL | LBS_MULTIPLESEL | LBS_NOINTEGRALHEIGHT | LBS_SORT | LBS_NOTIFY
    DEFPUSHBUTTON   "OK", IDOK, 71, 124, 50, 14
    PUSHBUTTON      "Cancel", IDCANCEL, 126, 124, 50, 14
}


/* Place this code in a file called multiSelection.h */

/* Use this code to replace the .array~of(...) statement in the Rexx program. */
  a = .array~of( -
                "Alabama", -
                "Alaska", -
                "American Samoa", -
                "Arizona", -
                "Arkansas", -
                "California", -
                "Colorado", -
                "Connecticut", -
                "Delaware", -
                "District of Columbia", -
                "Florida", -
                "Georgia", -
                "Guam", -
                "Hawaii", -
                "Idaho", -
                "Illinois", -
                "Indiana", -
                "Iowa", -
                "Kansas", -
                "Kentucky", -
                "Louisiana", -
                "Maine", -
                "Maryland", -
                "Massachusetts", -
                "Michigan", -
                "Minnesota", -
                "Mississippi", -
                "Missouri", -
                "Montana", -
                "Nebraska", -
                "Nevada", -
                "New Hampshire", -
                "New Jersey", -
                "New Mexico", -
                "New York", -
                "North Carolina", -
                "North Dakota", -
                "Northern Marianas Islands", -
                "Ohio", -
                "Oklahoma", -
                "Oregon", -
                "Pennsylvania", -
                "Puerto Rico", -
                "Rhode Island", -
                "South Carolina", -
                "South Dakota", -
                "Tennessee", -
                "Texas", -
                "Utah", -
                "Vermont", -
                "Virginia", -
                "Virgin Islands", -
                "Washington", -
                "West Virginia", -
                "Wisconsin", -
                "Wyoming")

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="connecttreecontrol"><title>ConnectTreeControl</title>
<indexterm><primary>ConnectTreeControl</primary></indexterm>
<programlisting>
<![CDATA[
>>-anAdvancedControl~ConnectTreeControl(--id--+------------------+--)-><
                                              +-,--attributeName-+


]]>
</programlisting>

<para>The ConnectTreeControl method creates a new attribute
and connects it to the tree view <emphasis role="italic">id</emphasis>.
The attribute has to be synchronized
manually with the tree view. You can do this globally using the
<link linkend="mthSetData">setData</link> and
<link linkend="mthGetData">getData</link> methods
or methods provided by the TreeControl class.
A tree view can contain many items. When the dialog data is set, the first
tree view item containing the same text as the text stored in the connected
attribute, is selected. When the data is received, the attribute receives
the text of the selected tree view item. Usually, the connection is made automatically
and you do not have to use this method.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:</para>
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the tree view that you want to connect.
</para></listitem></varlistentry>
<varlistentry><term>attributeName</term>
<listitem><para>An unused valid Rexx symbol because an attribute with exactly this name
is added to the dialog object by this method. Blank spaces, ampersands (&amp;),
and colons (:) are removed from the attributeName.</para>
<para>If this argument is omitted, is not valid, or already exists, the following
occurs:</para>
<itemizedlist>
<listitem><para>If the ID is numeric, an attribute with the name DATAid is
used, where <emphasis role="italic">id</emphasis> is the value of the
first argument.</para></listitem></itemizedlist>
<itemizedlist>
<listitem><para>If  the ID is symbolic, the attribute is named as the ID.
</para></listitem></itemizedlist>
</listitem></varlistentry>
</variablelist>
</listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>In the following example, the tree view with ID 202 is associated with
the attribute FileName. Then TEST.REX is assigned to the newly created attribute.
Then the dialog is executed, which preselects TEST.REX in the tree view, if
it exits. After the dialog is terminated, the selected entry of the tree view
is copied to the attribute FileName.
<programlisting>
<![CDATA[
MyDialog~ConnectTreeControl(202, "FileName")
MyDialog~FileName="TEST.REX"
MyDialog~execute("SHOWTOP")
say MyDialog~FileName
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="connectlistcontrol"><title>ConnectListControl</title>
<indexterm><primary>ConnectListControl</primary></indexterm>
<programlisting>
<![CDATA[
>>-anAdvancedControl~ConnectListControl(--id--+------------------+--)-><
                                              +-,--attributeName-+


]]>
</programlisting>

<para>The ConnectListControl method creates a new attribute
and connects it to the list view <emphasis role="italic">id</emphasis>.
The <emphasis role="italic">attributeName</emphasis> is
a string containing the numbers of the selected lines. The numbers are separated
by blanks. Therefore, if value of the attribute after
<link linkend="mthGetData">getData</link> is "3 5 6", the third,
fifth, and sixth items are currently selected,
or will be selected when <link linkend="mthSetData">setData</link>
is executed. For further information, refer to
<link linkend="connecttreecontrol">ConnectTreeControl</link>.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>In the following example, the list view with ID 202 is associated with
the attribute Customers. The first, 14th, and 29th entries in the list are
preselected.
<programlisting>
<![CDATA[
MyDialog~ConnectListControl(202, "Customers")
MyDialog~Customers="1 14 29"
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="connectslidercontrol"><title>ConnectSliderControl</title>
<indexterm><primary>ConnectSliderControl</primary></indexterm>
<programlisting>
<![CDATA[
>>-anAdvancedControl~ConnectSliderControl(--id--+------------------+--)-><
                                                +-,--attributeName-+


]]>
</programlisting>

<para>The ConnectSliderControl method creates a new attribute
and connects it to the track bar <emphasis role="italic">id</emphasis>.
The <emphasis role="italic">attributeName</emphasis> is
the numerical position of the slider. For further information, refer to
<link linkend="connecttreecontrol">ConnectTreeControl</link>.</para>
</section>

<section id="connecttabcontrol"><title>ConnectTabControl</title>
<indexterm><primary>ConnectTabControl</primary></indexterm>
<programlisting>
<![CDATA[
>>-anAdvancedControl~ConnectTabControl(--id--+------------------+--)-><
                                             +-,--attributeName-+


]]>
</programlisting>

<para>The ConnectTabControl method creates a new attribute
and connects it to the tab control <emphasis role="italic">id</emphasis>.
The <emphasis role="italic">attributeName</emphasis> is
the text of the active tab. For further information, refer to
<link linkend="connecttreecontrol">ConnectTreeControl</link>.</para>
</section>

<section id="mthConnectMultiListBox"><title>ConnectMultiListBox</title>
<indexterm><primary>ConnectMultiListBox</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectMultiListBox(--id--+------------------+--->
                                         +-,--attributeName-+

>--)-----------------------------------------------------------><


]]>
</programlisting>

<para>The ConnectMultiListBox method connects a list
box to a newly created attribute. The list box has the multiple-selection
style enabled (by setting the <emphasis role="italic">MULTI</emphasis> option when adding this list
box), that is, you can select more than one item at the same time. The value
of the attribute is a string containing the numbers of the selected lines.
The numbers are separated by blank spaces. Therefore, if the attribute value
is 3 5 6, the third, fifth, and sixth item are currently selected, or will
be selected if setData is executed. See <link linkend="mthConnectEdit">connectEdit</link> for a more
detailed description. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example defines a list box with the name of the four seasons.
It then preselects the items Summer and Winter. After execution of the dialog, it parses the value of the attribute.

<programlisting>
<![CDATA[
MyDialog = .ResDialog~new(...)
MyDialog~noAutoDetection
MyDialog~addListBox(205, ..., "MULTI")
MyDialog~ConnectMultiListBox(205, "ListBox")
seasons.1="Spring"
seasons.2="Summer"
seasons.3="Autumn"
seasons.4="Winter"
do season over seasons
  MyDialog~AddListEntry(205, season)
end
MyDialog~ListBox="2 4"
MyDialog~execute("SHOWTOP")
selItems = MyDialog~ListBox
do until anItem =""
   parse var selItems anItem selItems
   say "You selected: "seasons.anItem
end
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

</section>  <!-- End Connect Attribute Methods Section -->

<section id="mthGetData"><title>getData</title>
<indexterm><primary>getData</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetData-----------------------------------------><


]]>
</programlisting>

<para>
  The <emphasis role="italic">getData</emphasis> method receives <link
  linkend="sctUnderstandingDataAttributes">data</link> from the underlying Windows dialog and copies it to the
  associated dialog object data attributes.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example continues the <link linkend="mthSetData">setData</link> example:

<programlisting>
<![CDATA[
     .
     .
     .
MyDialog~connectEdit(102, "ENTRYLINE_1")
MyDialog~connectCheckBox(201, )
MyDialog~ConnectListbox(203, "LISTBOX_DAYS")
     .
     .
     .
/* process the dialog */
     .
     .
     .
MyDialog~getData            /* retrieve dialog item value */
say MyDialog~ENTRYLINE_1
say MyDialog~DATA201
say MyDialog~LISTBOX_DAYS
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthSetData"><title>setData</title>
<indexterm><primary>setData</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetData-----------------------------------------><


]]>
</programlisting>

<para>
The setData method transfers the values of the dialog object <link linkend="sctUnderstandingDataAttributes">data
  attributes</link> to the underlying dialog controls.
</para>
<para>
  <emphasis role="bold">Note</emphasis> that this method transfers the data for every connected attribute. This may not
  always be desirable. For instance the focused node of a tree-view control may be changed. For finely grained control
  of which values are transfered the programmer should use the <link linkend="mthSetControlData">setControlData</link>() or <link
  linkend="mthSetDataAttribute">setAttribute</link>() methods. Both of these methods transfer the value of a single object attribute
  that is specified by the programmer.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem>
  <para>
    Dialog items with ID 102, 201 and 203 are connected to the attributes
    <computeroutput>ENTRYLINE_1</computeroutput>, <computeroutput>DATA201</computeroutput>, and
    <computeroutput>LISTBOX_DAYS</computeroutput>. Attribute <computeroutput>DATA201</computeroutput> is
    generated by the connectCheckBox method. Then the attributes are initialized with some values. This
    does not change the dialog window, unless you run the setData method.
<programlisting>
<![CDATA[
     .
     .
     .
MyDialog~connectEdit(102, "ENTRYLINE_1")
MyDialog~connectCheckBox(201,)
MyDialog~ConnectListbox(203, "LISTBOX_DAYS")
     .
     .
     .
MyDialog~ENTRYLINE_1="Memorial Day"
MyDialog~DATA201=1
MyDialog~LISTBOX_DAYS="Monday"

MyDialog~setData
]]>
</programlisting>
  </para>
</listitem></varlistentry>
</variablelist>
</section>

<section id="mthGetEditData"><title>getEditData</title>
<indexterm><primary>getEditData</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~getEditData(--id--)----------------------------><


]]>
</programlisting>

<para>The getEditData method returns the value of the
given entry line. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the entry line.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthSetEditData"><title>setEditData</title>
<indexterm><primary>setEditData</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~setEditData(--id--,--aString--)----------------><


]]>
</programlisting>

<para>The setEditData method puts the value of a string
into an entry line. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the entry line.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The value to be assigned to the entry line.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>Assume that three methods are connected to push buttons. The SetToDefault
method overrides the value in the Windows dialog entry line 234 with the
value 256 but does not change its associated attribute. Using setEditData
has the same effect as a change to the entry line made by the user. The associated
attribute in the Object Rexx object (<computeroutput>DATA234</computeroutput>) still has the original
value. Thus it is possible to undo the changes or confirm them.

<programlisting>
<![CDATA[
::method SetToDefault
   self~setEditData(234, "256")

::method AcceptValues
   self~getDataAttribute(DATA234)

::method UndoChanges
   self~setDataAttribute(DATA234)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000474"><title>GetListLine</title>
<indexterm><primary>GetListLine</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetListLine(--id--)-----------------------------><


]]>
</programlisting>

<para>The GetListLine method returns the value of the
currently selected list item. If you need the index of the item, use the <link linkend="h000417">GetCurrentListIndex</link> method. If no item is selected, a null string
is returned. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000539"><title>SetListLine</title>
<indexterm><primary>SetListLine</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetListLine(--id--,--aString--)-----------------><


]]>
</programlisting>

<para>The SetListLine method assigns the value of a string
to the list box. Thus the item with the value of <emphasis role="italic">aString</emphasis> becomes
selected. The first item is selected if the string is not found in the list
box. This method does not apply to a multiple selection list box (see <link linkend="h000575">SetMultiList</link>). </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The value of the item to be selected.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example selects item &quot;New York&quot; in list box 232:

<programlisting>
<![CDATA[
MyBaseDialog~SetListLine(232, "New York")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000506"><title>GetMultiList</title>
<indexterm><primary>GetMultiList</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetMultiList(--id--)----------------------------><


]]>
</programlisting>

<para>The GetMultiList method can be applied
to a multiple-selection list box. It returns a string containing the indexes
of up to 1000 selected items. The numbers are separated by blanks. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the multiple-selection list box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example shows how to handle a multiple-selection list
box. It parses the returned string as long as it contains an index.

<programlisting>
<![CDATA[
selLines = MyDialog~GetMultiList(555)
do until selLines = ""
   parse var selLines aLine selLines
   say aLine
end
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000575"><title>SetMultiList</title>
<indexterm><primary>SetMultiList</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetMultiList(--id--,--data--)-------------------><


]]>
</programlisting>

<para>The SetMultiList method selects one or more lines
in a multiple-selection list box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the multiple-selection list box.
</para></listitem></varlistentry>
<varlistentry><term>data</term>
<listitem><para>The indexes (separated by blanks) of the lines to be selected.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example selects the lines 2, 5, and 6 of list box 345:

<programlisting>
<![CDATA[
MyDialog~SetMultiList(345, "2 5 6")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000482"><title>GetComboLine</title>
<indexterm><primary>GetComboLine</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetComboLine(--id--)----------------------------><


]]>
</programlisting>

<para>The GetComboLine method returns the value of the
currently selected list item of a combo box. If you need the index of the
item, use the <link linkend="h000344">GetCurrentComboIndex</link> method. If no item is selected,
a null string is returned. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000548"><title>SetComboLine</title>
<indexterm><primary>SetComboLine</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetComboLine(--id--,--aString--)----------------><


]]>
</programlisting>

<para>The SetComboLine method assigns a string to the
given combo box. Thus the item with the value of <emphasis role="italic">aString</emphasis> becomes
selected. If <emphasis role="italic">aString</emphasis> is not found in the
combo box, then the first item is selected. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The value of the item to be selected.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000498"><title>GetRadioButton</title>
<indexterm><primary>GetRadioButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetRadioButton(--id--)--------------------------><


]]>
</programlisting>

<para>The GetRadioButton method returns 1 if the radio
button is selected, 0 if it is not selected. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the radio button.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000566"><title>SetRadioButton</title>
<indexterm><primary>SetRadioButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetRadioButton(--id--,--data--)-----------------><


]]>
</programlisting>

<para>The SetRadioButton method marks the radio button
if the given data value is 1, and removes the mark if the value is 0. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the radio button.
</para></listitem></varlistentry>
<varlistentry><term>data</term>
<listitem><para>1 to select the button or 0 to deselect it.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000490"><title>GetCheckBox</title>
<indexterm><primary>GetCheckBox</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetCheckBox(--id--)-----------------------------><


]]>
</programlisting>

<para>The GetCheckBox method returns the value of a check
box: 1 if the check box is selected (has a check mark), 0 if it is not selected. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the check box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000557"><title>SetCheckBox</title>
<indexterm><primary>SetCheckBox</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetCheckBox(--id--,--data--)--------------------><


]]>
</programlisting>

<para>The SetCheckBox method puts a check mark in the
check box if the given data value is 1 and removes the check mark if the value
is 0. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the check box.
</para></listitem></varlistentry>
<varlistentry><term>data</term>
<listitem><para>The value 1 to check the box or 0 to remove the check mark.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthGetControlData"><title>getControlData</title>
<indexterm><primary>getControlData</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>getControlData</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getControlData(--id--)-------------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">getControlData</emphasis> method gets the <link
  linkend="sctUnderstandingDataAttributes">data</link> of a dialog control, regardless of the type of the control. The
  control <emphasis role="bold">should</emphasis> have been previously connected to a data attribute.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the dialog control. May be symbolic or numeric.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return Value:</emphasis></term>
  <listitem>
  <para>
    The return will be the string value of the control data. This is dependent on the type of the control. For an edit
    control it will be the text entered in the control, for a radio button it will be 0 or 1, depending on if the radio
    button is unchecked or checked, for a tree view it will be the text of the selected item in the tree, etc..
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    If the control has not been previously connected to a data attribute, the implementation of this method assumes the
    control is an edit control and returns the text of the control. Since all windows have text value, which may be the
    empty string, this is okay. However this is not the intent of this method. The method is intended to only be used
    with controls connected to a data attribute.
  </para>
  <para>
    It appears that the original intent of this method was to be used for controls such as tree views, list views, tabs,
    etc.. When these controls were added to ooDialog, no corresponding getTreeViewData(), getProgressBarData(), etc.,
    methods were implemented. The generic <emphasis role="italic">setControlData</emphasis>() method works for all
    connected controls, but it works best if the programmer knows the type of control.
  </para>
  <para>
    A better method to use, if the programmer is insistent on thinking in terms of data attributes, is probably to use
    the <link linkend="mthData">data</link>() method of the dialog control <link
    linkend="chpDialogControlObject">object</link>.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthSetControlData"><title>setControlData</title>
<indexterm><primary>setControlData</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>setControlData</secondary></indexterm>
<programlisting>
<![CDATA[
>>--setControlData(--id--,--dataString--)----------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">setControlData</emphasis> method sets the <link
  linkend="sctUnderstandingDataAttributes">data</link> of a dialog contol. You do not have to know what kind of control
  it is. The dialog control <emphasis role="bold">should</emphasis> have been previously connected to a data attribute.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the dialog control. May be numeric or symbolic.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dataString [required]</term>
    <listitem>
    <para>
      The data that is assigned to the control. The format <emphasis role="bold">should</emphasis> match the type of
      the control.
    </para>
    </listitem></varlistentry>
  </variablelist> </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    If the control has not been previously connected to a data attribute, the implementation of this method assumes the
    control is an edit control and sets the text of the control to <emphasis role="italic">dataString</emphasis>. Since
    all windows can have their text set, this is okay. However the outcome is dependent on the type of control. Setting
    the text of a check box will change its label, setting the text of a tree view control will do nothing. The method
    is intended to only be used with controls connected to a data attribute.
  </para>
  <para>
    Likewise, if the format of <emphasis role="italic">dataString</emphasis> does not match the type of control, the
    results are unpredictable. It appears that the original intent of this method was to be used for controls such as
    tree views, list views, tabs, etc.. When these controls were added to ooDialog, no corresponding setTreeViewData(),
    setTabData(), etc., methods were implemented. The generic <emphasis role="italic">setControlData</emphasis>() method
    works for all connected controls, but it works best if the programmer knows the type of control.
  </para>
  <para>
    A better method to use, if the programmer is insistent on thinking in terms of data attributes, is probably to use
    the <link linkend="mthDataEquals">data=</link> method of the dialog control <link
    linkend="chpDialogControlObject">object</link>.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example sets dialog control with resource ID of 123 to the (string) data &quot;1 2 3&quot;. This is
    meaningful if the control is an edit control, or if it is a list box that contains the line &quot;1 2 3&quot;.
    However, for other controls it is probably meaningless.

<programlisting>
<![CDATA[
MyDialog~setControlData(123, "1 2 3")
]]>
</programlisting>

  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthGetDataAttribute"><title>getDataAttribute</title>
<indexterm><primary>getDataAttribute</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>getDataAttribute</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getDataAttribute(--attributeName--)------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">getDataAttribute</emphasis> method transfers the data of a dialog control to the
  connected <link linkend="sctUnderstandingDataAttributes">data attribute</link> of the Rexx dialog object.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>attributeName [required]</term>
    <listitem>
    <para>
      The name of the data attribute that receives the data of the underlying dialog control.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example shows how to get the data of a dialog control and synchronize its connected data
    attribute.

<programlisting>
<![CDATA[
  self~getDataAttribute("FIRSTNAME")
  if self~firstName \= "" then ...
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthSetDataAttribute"><title>setDataAttribute</title>
<indexterm><primary>setDataAttribute</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>setDataAttribute</secondary></indexterm>
<programlisting>
<![CDATA[
>>--setDataAttribute(--attributeName--)-----------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">setDataAttribute</emphasis> method transfers the value of a connected <link
  linkend="sctUnderstandingDataAttributes">data attribute</link> of the Rexx dialog object to the underlying dialog
  control.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>attributeName [required]</term>
    <listitem>
    <para>
      The name of the data attribute whose value is transferred to the underlying dialog control.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example copies the value of the data attribute DATA101 to the connected dialog control

  <programlisting>
  <![CDATA[
    self~setDataAttribute("DATA101")
  ]]>
  </programlisting>
  </para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthSetDataStem"><title>setDataStem</title>
<indexterm><primary>setDataStem</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>setDataStem</secondary></indexterm>
<programlisting>
<![CDATA[
>>--setDataStem(--dataStem.--)---------------------------------><

]]>
</programlisting>

<para>
  Sets the <emphasis role="italic">data,</emphasis> (the state,) of a number of Windows dialog controls to the values
  specified by the stem. Each index of <emphasis role="italic">dataStem.</emphasis> is the resource ID of a dialog
  control. The control with that ID, within the dialog, has its state set to match the value of the stem variable at
  that index. The resource ID can be specified using either numeric resource IDs or symbolic resource IDs.
</para>
<para>
  This method only works for controls that have been connected to a <link
  linkend="sctUnderstandingDataAttributes">data</link> attributue. Either by automatic data <link
  linkend="paraAutomaticDataDetection">detection</link>, or througt one of the <link
  linkend="sctConnectDataMethods">connect...</link> methods. Every connected control has its state set when this method
  is invoked.  If the data stem, <emphasis role="italic">data.</emphasis> has no matching index for a connected control,
  that control's state is set to the empty string.  Any indexes in the data stem that do not match the resource ID of a
  registered control are ignored.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
    <variablelist>
    <varlistentry><term>dataStem.</term>
    <listitem><para>
      A stem variable containing the values used to set a dialog control's state. Remember the trailing period.
    </para></listitem></varlistentry>
    </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example initializes the dialog controls with IDs 21, 22, and 23, provided they have been connected
    previously:
<programlisting>
<![CDATA[
     .
     .
     .
dlgStem.21="Windows 95"
dlgStem.22="0"
dlgStem.23="1 2 3"
self~setDataStem(dlgStem.)
]]>
</programlisting>
   </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthGetDataStem"><title>getDataStem</title>
<indexterm><primary>getDataStem</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>getDataStem</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getDataStem(--dataStem.--)---------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">getDataStem</emphasis>() method is the reverse of the <link
  linkend="mthSetDataStem">setDataStem</link>() method.  The method gets the <emphasis role="italic">data</emphasis> of
  all the dialog controls in the underlying dialog that have been connected to a <link
  linkend="sctUnderstandingDataAttributes">data attribute</link> of the Rexx dialog object. The data of each control is
  copied to the specified stem.
</para>
<para>
  A stem index for each  connected control is set.  The stem index is the numeric ID for the control.  The value at that
  index is the data of the matching dialog control.  In addition, if the <link linkend="atrConstDir">constDir</link>
  directory has a symbolic ID for the numeric ID of the control, a stem index of the symbolic ID is also set.  This of
  course only works reliably if the Rexx programmer uses unique numeric IDs for all resouces.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
    <variablelist>
    <varlistentry><term>dataStem. [required]</term>
    <listitem>
    <para>
      The name of a stem variable in which the data is returned.  Remember the trailing period.
    </para>
    </listitem></varlistentry>
    </variablelist>
  </listitem></varlistentry>
</variablelist>
</section>

</section>

<!-- <section id="sctConnectingEvents"><title>Connecting Events</title> START -->
&connectingEvents;
<!-- <section id="sctConnectingEvents"><title>Connecting Events</title> END   -->


<section id="sctStandardEventMethods"><title>Standard Event Handling Methods</title>
<indexterm><primary>standard event handler methods</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>standard event handlers</secondary></indexterm>
<para>
  The ooDialog framework provides some default command <link linkend="ovvEvents">event</link> handling methods. At this
  time there are 3 handlers, one for the <emphasis role="italic">ok</emphasis>, the <emphasis
  role="italic">cancel</emphasis>, and the <emphasis role="italic">help</emphasis> command events. These 3 specific
  command events are generated when a <link linkend="clsButton">button</link>, with the correct <link
  linkend="defResourceId">resource ID</link>, is clicked or pushed. They can also be generated when a <link
  linkend="chpMenus">menu</link> item, again with the correct resource ID, is selected. The cancel event is also
  generated, in a dialog, when the user closes the dialog using the close icon in the title bar, or presses the escape
  key.
</para>
<para>
  When a new dialog object is instantiated, ooDialog uses the <link
  linkend="clsEventNotification">EventNotification</link> class to automatically connect the notifications for these
  events to the methods documented in this section. <link linkend="defSymbolicId">Symbolic</link> IDs are also defined
  and placed in the <link linkend="atrConstDir">constDir</link>. This table summarizes these 3 events, their resource
  IDs, symbolic IDs, and event handling methods:
  <table id="tblStandEventHandlers" frame="all">
  <title>Standard Event Handling</title>
  <tgroup cols="4">
  <thead>
  <row>
  <entry>Event</entry>
  <entry>Resource ID</entry>
  <entry>Symbolic ID</entry>
  <entry>Default Method</entry>
  </row>
  </thead>
  <tbody>
  <row>
  <entry>ok</entry>
  <entry>1</entry>
  <entry>IDOK</entry>
  <entry><link linkend="mthOk">ok</link></entry>
  </row>
  <row>
  <entry>cancel</entry>
  <entry>2</entry>
  <entry>IDCANCEL</entry>
  <entry><link linkend="mthCancel">cancel</link></entry> </row>
  <row>
  <entry>help</entry>
  <entry>9</entry>
  <entry>IDHELP</entry>
  <entry><link linkend="mthHelp">help</link></entry>
  </row>
  </tbody></tgroup>
  </table>
</para>
<para>
  Note that the help <emphasis role="bold">command</emphasis> event notification discussed here is not the same as the
  Windows help event notification connected through the <link linkend="mthConnectHelp">connectHelp</link>() method.
</para>

<section id="mthOk"><title>ok</title>
<indexterm><primary>ok</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>ok</secondary></indexterm>
<programlisting>
<![CDATA[
>>--ok---------------------------------------------------------><

]]>
</programlisting>

<para>
  A default <emphasis role="italic">ok</emphasis> method is provided by the ooDialog framework. The
  <computeroutput>ok</computeroutput> event notification is <link linkend="sctStandardEventMethods">automatically</link>
  connected to this method. This method is meant to be overridden by the programmer if the default implementation is not
  sufficient for the needs of the program.
</para>
<para>
  The method is invoked in response to the <computeroutput>ok</computeroutput> command event. The default implementation
  calls the <link linkend="mthValidate">validate</link>() method to determine if the dialog should close or not. If
  <emphasis role="italic">validate</emphasis> returns true the dialog is closed. If it returns false, the dialog
  continues to execute. The default implementation of <emphasis role="italic">validate</emphasis> always returns true.
</para>
<para>
  The programmer might want to override the <emphasis role="italic">ok</emphasis> method in his subclass. In general,
  there is probaly no need to. Anything done in the overridden <emphasis role="italic">ok</emphasis> method, could just
  as easily be done by overriding the <link linkend="mthValidate">validate</link>() and / or the <link
  linkend="mthLeaving"></link>() methods.

  TODO NEED TO DECIDE EXACTLY WHAT TO DOCUMENT OR NOT DOCUMENT HERE

  If you do, forward the OK message to the parent class after processing has finished. Set the self~finished attribute
  to 1 or 0 and return it. The dialog continues executing if you return the value 0. See also <link
  linkend="mthValidate">validate</link>.
</para>
<para>
  <emphasis role="bold">Example:</emphasis>
</para>
<para>
  The following example shows how to override the OK method.  It checks that the user really wants to quite.
<programlisting>
<![CDATA[

::method ok unguarded

  dateTime = .DateTime~new
  currentTime = dateTime~civilTime

  buttons   = "OKCANCEL"
  defButton = "DEFBUTTON1"
  icon      = "INFORMATION"
  msg       = "It is now:" currentTime
  title     = "Quitting Now"

  if dateTime~hours < 16 then do
    break = .endOfLine~copies(2)

    icon = "WARNING"
    defButton = "DEFBUTTON2"
    chide = "It is NOT 4:00 pm." break "Are you SURE you should quite!"

    msg ||= break || chide
  end

  ret = messageDialog(msg, self~hwnd, title, buttons, icon, defButton)

  if ret == 1 then return self~ok:super
  else return 0

]]>
</programlisting>
  As noted above, rather than override the <emphasis role="italic">ok</emphasis> method the same code could have been
  put into the <emphasis role="italic">validate</emphasis> method.

<programlisting>
<![CDATA[

::method validate unguarded

  dateTime = .DateTime~new
  currentTime = dateTime~civilTime

  buttons   = "OKCANCEL"
  defButton = "DEFBUTTON1"
  icon      = "INFORMATION"
  msg       = "It is now:" currentTime
  title     = "Quitting Now"

  if dateTime~hours < 16 then do
    break = .endOfLine~copies(2)

    icon = "WARNING"
    defButton = "DEFBUTTON2"
    chide = "It is NOT 4:00 pm." break "Are you SURE you should quite!"

    msg ||= break || chide
  end

  ret = messageDialog(msg, self~hwnd, title, buttons, icon, defButton)

  if ret == 1 then return .true
  else return .false

]]>
</programlisting>
</para>
</section>

<section id="mthCancel"><title>cancel</title>
<indexterm><primary>cancel</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>cancel</secondary></indexterm>
<programlisting>
<![CDATA[
>>--cancel-----------------------------------------------------><

]]>
</programlisting>

<para>
  A default <emphasis role="italic">cancel</emphasis> method is provided by the ooDialog framework. The
  <computeroutput>cancel</computeroutput> event notification is <link
  linkend="sctStandardEventMethods">automatically</link> connected to this method. This method is meant to be overridden
  by the programmer if the default implementation is not sufficient for the needs of the program.
</para>
<para>
  The method is invoked in response to the <computeroutput>cancel</computeroutput> command event. The default
  implementation sets the <link linkend="atrInitCode">initCode</link> attribute to 2 and causes the dialog to be closed.
</para>
<para>
  The programmer might want to override the <emphasis role="italic">cancel</emphasis> method in her subclass. If the
  method is overridden, it should be an UNGUARDED method.

  TODO NEED TO DECIDE EXACTLY WHAT TO DOCUMENT OR NOT DOCUMENT HERE

  If you do, forward the Cancel message to the parent class after processing has finished. Set the self~finished
  attribute to 1 or 0 and return it. The dialog continues executing if you return the value 0.
</para>
</section>

<section id="mthHelp"><title>help</title>
<indexterm><primary>help</primary></indexterm>
<programlisting>
<![CDATA[
>>--help-------------------------------------------------------><

]]>
</programlisting>

<para>
  A default <emphasis role="italic">help</emphasis> method is provided by the ooDialog framework. The
  <computeroutput>help</computeroutput> event notification is <link
  linkend="sctStandardEventMethods">automatically</link> connected to this method. This method is meant to be overridden
  by the programmer. The default implementation does nothing and returns 0. The programmer could override this method to
  display some form of help to the user.
</para>
</section>

<section id="mthValidate"><title>validate</title>
<indexterm><primary>validate</primary>
<secondary>dialog object</secondary></indexterm>
<programlisting>
<![CDATA[
>>--validate---------------------------------------------------><


]]>
</programlisting>

<para>
  The <emphasis role="italic">validate</emphasis> method is a method that is intended to be overridden by the
  programmer. Its purpose would be to validate the user's input and decide whether or not to close the dialog. The
  default <link linkend="mthOk">ok</link> method implementation calls <emphasis role="italic">validate</emphasis>. If
  the return is true, the <emphasis role="italic">ok</emphasis> method will close the dialog. If the return is false,
  the dialog is not closed.
</para>
<para>
  The default implementation of <emphasis role="italic">validate</emphasis> provided by the ooDialog framework does
  nothing and always returns true.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    In the following example of an override of <emphasis role="italic">validate</emphasis>, a check is done to determine
    if the edit control with resource ID 203 is empty. If it is empty, validate returns false, which indicates that the
    dialog cannot be closed.

<programlisting>
<![CDATA[
::class 'MyDialog' subclass ResDialog

::method validate unguarded
   if self~newEdit(203)~getText = "" then return .false
   else return .true
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthLeaving"><title>leaving</title>
<indexterm><primary>leaving</primary></indexterm>
<programlisting>
<![CDATA[
>>--leaving----------------------------------------------------><


]]>
</programlisting>

<para>
  The <emphasis role="italic">leaving</emphasis> method is invoked automatically when the underlying Windows dialog is
  being closed.  It is intended to be over-ridden by the programmer, if desired.  The default implementation does
  nothing. Over-ridding the method gives the programmer a chance to do some final clean up.
</para>
</section>

</section>


<section id="sctInstantiateControls"><title>Instantiating Dialog Controls</title>
<para>
  The methods in this section are used to instantiate one of the concrete <link linkend="chpDialogControlObject">dialog
  control</link> objects. The dialog control objects can not be instantiated directly by the programmer in Rexx code.
  Dialog controls are instantiated indirectly through the dialog object.
</para>
<para>
  <emphasis role="bold">All</emphasis> dialog control objects are obtained through one of the methods in this section.
  The methods all have the same format:

<programlisting>
<![CDATA[
controlObject = dialogObject~new[ControlName](resourceID, categoryPageID)

]]>
</programlisting>
  where <emphasis role="italic">[ControlName]</emphasis> is the name Microsoft uses for the control and <emphasis
  role="italic">categoryPageID</emphasis> is optional. <emphasis role="italic">categoryPageID</emphasis> is the page
  number the control is on in a <computeroutput>CategoryDialog</computeroutput>, or one of its subclasses. Dialog
  control objects can only be instantiated after the <link linkend="ovvUnderlying">underlying</link> dialog has been
  created. For any error, all the methods return the <emphasis role="italic">.nil</emphasis> object.
</para>

<section id="mthNewStatic"><title>newStatic</title>
<indexterm><primary>newStatic</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newStatic</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newStatic(--id--+------------+--)--------------------------><
                    +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newStatic</emphasis> method returns an object of the <link
  linkend="clsStatic">Static</link> control class. This object represents the static control in the underlying dialog
  with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the static dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the static control class or <emphasis role="italic">.nil</emphasis> on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Often static controls are give a resource ID of -1 because they do not usually need to be changed after the
    underlying dialog is created. However, if the programmer needs to manipulate a static control in any way, then the
    control has to have a positive resource ID.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example gets a new static control object that represents the static control in the underlying dialog
    with the symbolic ID of IDC_ST_NAME. Provided the underlying dialog control exists, it is resized and its text,
    background color, and foreground color is changed:

  <programlisting>
  <![CDATA[
  ::class 'MyDlgClass' subclass RcDialog

  ::method reArrange
    di = self~newStatic(IDC_ST_NAME)
    if di == .nil then return
    di~setRect(.Rect~new(0, 0, 100, 25), "NOMOVE HIDE")
    di~setText("Processing layout update!")
    di~setColor(7,4)
    di~show
    ...
  ]]>
  </programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthNewPushButton"><title>newPushButton</title>
<indexterm><primary>newPushButton</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newPushButton</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newPushButton(--id--+------------+--)----------------------><
                        +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newPushButton</emphasis> method returns an object of the <link
  linkend="clsButton">Button</link> control class. This object represents the push button control in the underlying
  dialog with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the push button dialog control. May be numeric or <link
      linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the button control class or <emphasis role="italic">.nil</emphasis> on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example displays the state of the push button in the underlying dialog with the resource ID of 1:

<programlisting>
<![CDATA[
::class 'MyDlgClass' subclass RcDialog

::method currentState
  pushButton = self~newPushButton(1)
  if pushButton == .nil then return .false
  say "State is" pushButton~state
  return .true

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthNewRadioButton"><title>newRadioButton</title>
<indexterm><primary>newRadioButton</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newRadioButton</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newRadioButton(--id--+------------+--)---------------------><
                         +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newRadioButton</emphasis> method returns an object of the <link
  linkend="clsRadioButton">RadioButton</link> control class. This object represents the radio button control in the underlying dialog
  with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the radio button dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the radio button control class or <emphasis role="italic">.nil</emphasis> on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example displays a message if the radio button with a symbolic ID of IDC_RB_CHOICE is selected:

<programlisting>
<![CDATA[
::class 'MyDlgClass' subclass ResDialog

::method currentState
  rb = self~newRadioButton(IDC_RB_CHOICE)
  if rb == .nil then return .false
  if rb~checked then say "The radio button is selected!"
  return .true

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthNewCheckBox"><title>newCheckBox</title>
<indexterm><primary>newCheckBox</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newCheckBox</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newCheckBox(--id--+------------+--)------------------------><
                      +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newCheckBox</emphasis> method returns an object of the <link
  linkend="clsCheckBox">CheckBox</link> control class. This object represents the check box control in the underlying dialog
  with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the check box dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the check box control class or <emphasis role="italic">.nil</emphasis> on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example determines the check state of a <link linkend="termThreeStateStyle">3STATE</link> check box
    and displays a message announcing the state:

<programlisting>
<![CDATA[
::class 'MyDlgClass' subclass ResDialog

::method currentState
  checkBox = self~newCheckBox(304)
  if checkBox == .nil then return .false
  if checkBox~checked then say "The check box is checked!"
  else if checkBox~isIndeterminate then say "The check box is in the indeterminate state!"
  else say "The check box is not checked!"
  return .true

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthNewGroupBox"><title>newGroupBox</title>
<indexterm><primary>newGroupBox</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newGroupBox</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newGroupBox(--id--+------------+--)------------------------><
                      +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newGroupBox</emphasis> method returns an object of the <link
  linkend="clsGroupBox">GroupBox</link> control class. This object represents the group box control in the underlying dialog
  with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the group box dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Although a group box control is actually a type of a button control, usually they do not need to be manipulated
    after the underlying dialog is created and are often given a resource ID of -1. In order to obtain a new group box
    object, the underlying group box control in the dialog has to have a positive resource ID.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the group box control class or <emphasis role="italic">.nil</emphasis> on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example shows how the text (label) of a group box could be changed during program execution:

<programlisting>
<![CDATA[
::class 'MyPhoneBook' subclass ResDialog

::method onUseFull
  gb = self~newGroupBox(IDC_GB_TELEPHONE)
  chkBox = self~newCheckBox(IDC_CHK_USE_FULL)
  if chkBox~checked then do
    gb~setText("Phone Numbers (including area code)")
  end
  else do
    gb~setText("Phone Numbers")
  end

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


<section id="mthNewEdit"><title>newEdit</title>
<indexterm><primary>newEdit</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newEdit</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newEdit(--id--+------------+--)----------------------------><
                  +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newEdit</emphasis> method returns an object of the <link
  linkend="clsEdit">Edit</link> control class. This object represents the edit control in the underlying dialog
  with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the edit dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the edit control class or <emphasis role="italic">.nil</emphasis> on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example validates that the user has filled in the last name field in a dialog form:

<programlisting>
<![CDATA[
::class 'MyDlgClass' subclass RcDialog

::method validate
  editCtrl = self~newEdit(IDC_EDIT_LNAME)
  if editCtrl == .nil then return .false
  if editCtrl~getText~space(0) == "" then return .false
  else return .true
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


<section id="mthNewComboBox"><title>newComboBox</title>
<indexterm><primary>newComboBox</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newComboBox</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newComboBox(--id--+------------+--)------------------------><
                      +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newComboBox</emphasis> method returns an object of the <link
  linkend="clsComboBox">ComboBox</link> control class. This object represents the combo box control in the underlying dialog
  with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the combo box dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the combo box control class or <emphasis role="italic">.nil</emphasis> on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example comes from a fictious accounting program. In one of the dialogs for the program, when the user
    selects a specific city, say San Diego, the zip code combo box is populated with the valid zip codes for that city.
    In the program, <link linkend="defSymbolicId">symbolic ID</link>s have been used for the controls.  The valid zip
    codes are passed into the method as an array.

<programlisting>
<![CDATA[
::class "BillingDlg" subclass RcDialog

...

::method setZipCodes
  use strict arg codes

  combo = self~newComboBox(IDC_COMBO_ZIP)
  if combo == .nil then return .false

  lowest = 99999
  combo~deleteAll
  do zipCode over codes
    combo~add(zipCode)
    if zipCode < lowest then do
      lowest = zipCode
    end
  end
  combo~select(lowest)
  return .true


]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


<section id="mthNewListBox"><title>newListBox</title>
<indexterm><primary>newListBox</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newListBox</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newListBox(--id--+------------+--)-------------------------><
                     +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newListBox</emphasis> method returns an object of the <link
  linkend="clsListBox">ListBox</link> control class. This object represents the list box control in the underlying dialog
  with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the list box dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the list box control class or <emphasis role="italic">.nil</emphasis> on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example updates the list box with a symbolic id of <computeroutput>IDC_LB_AREAS</computeroutput> by
    first deleting all items in the list box, then adding some new items and preselecting the item with the text of
    &quot;City&quot;:

<programlisting>
<![CDATA[

::class 'MyDlgClass' subclass RCDialog

::method updateList
  lb = self~newListBox(IDC_LB_AREAS)
  if lb == .nil then return 0
  lb~deleteAll
  lb~add("Town")
  lb~add("City")
  lb~add("Green")
  lb~add("Forest")
  lb~select("City")

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


<section id="mthNewScrollBar"><title>newScrollBar</title>
<indexterm><primary>newScrollBar</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newScrollBar</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newScrollBar(--id--+------------+--)-----------------------><
                       +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newScrollBar</emphasis> method returns an object of the <link
  linkend="clsScrollBar">ScrollBar</link> control class. This object represents the scroll bar control in the underlying dialog
  with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the scroll bar dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the scroll bar control class or <emphasis role="italic">.nil</emphasis> on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example sets a new range and a new position for the horizontal scroll bar with the resource ID of 317:

<programlisting>
<![CDATA[
::class 'MyDlgClass' subclass RcDialog

::method focusPage
  hScrollBar = self~newScrollBar(317)
  if hScrollBar == .nil then return .false
  hScrollBar~setRange(0, 1000, 0)
  hScrollBar~setPos(500, 1)
  return .true
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


<section id="mthNewTrackBar"><title>newTrackBar</title>
<indexterm><primary>newTrackBar</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newTrackBar</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newTrackBar(--id--+------------+--)------------------------><
                      +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newTrackBar</emphasis> method returns an object of the <link
  linkend="clsTrackBar">TrackBar</link> control class. This object represents the track bar control in the underlying
  dialog
  with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the track bar dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the track bar control class or <emphasis role="italic">.nil</emphasis> on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Prior to the effort to <link linkend="termMethodNameUnification">unify</link> the class and method names in
    ooDialog, the track bar control was called a slider. This may have been the most egregious misnomer in ooDialog and
    the term <emphasis role="italic">slider</emphasis> is no longer used.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    In the following example, the initialization of the dialog controls is broken down into sub-steps to make the
    program more readable and easier to understand. The initialization of the a track bar control is shown:

<programlisting>
<![CDATA[
::class 'MyDlgClass' subclass ResDialog

::method initDialog
  self~initTheListView
  self~initTheButtons
  self~initTheTrackBar

::method initTheTrackBar private
  trackBar = self~newTrackBar(IDC_TB_REPEAT_RATE)
  if trackBar == .nil then return

  trackBar~clearSelRange(.false)
  trackBar~setMax(200, .false)
  trackBar~setTickFrequency(50)
  trackBar~setTickAt(75)
  trackBar~setSelStart(20, .false)
  trackBar~setSelEnd(180, .true)
  trackBar~pos = 167

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


<section id="mthNewProgressBar"><title>newProgressBar</title>
<indexterm><primary>newProgressBar</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newProgressBar</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newProgressBar(--id--+------------+--)---------------------><
                         +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newProgressBar</emphasis> method returns an object of the <link
  linkend="clsProgressBar">ProgressBar</link> control class. This object represents the progress bar control in the underlying dialog
  with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the progress bar dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the progress bar control class or <emphasis role="italic">.nil</emphasis> on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example initializes the progress bar with symbolic resource ID to use a step value of 50 and sets its
    range to 1 through 2,147,483,647. As the program does its work, it updates the progress bar position incrementally
    based on the amount of work it calculates was done since the last update:

<programlisting>
<![CDATA[
::class 'MyDlgClass' subclass ResDialog

::method initDialog
  pb = self~newProgressBar(IDC_PBAR_PROGRESS)
  if pb == .nil then return
  pb~setStep(50)
  pb~setFullRange(1, 2147483647)

::method updateProgress private
  use strict arg amount
  self~newProgressBar(IDC_PBAR_PROGRESS)~setPos(amount)

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthNewListView"><title>newListView</title>
<indexterm><primary>newListView</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newListView</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newListView(--id--+------------+--)------------------------><
                      +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newListView</emphasis> method returns an object of the <link
  linkend="clsListView">ListView</link> control class. This object represents the list view control in the underlying dialog
  with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the list view dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the list view control class or <emphasis role="italic">.nil</emphasis> on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example :

<programlisting>
<![CDATA[
::class 'MyDlgClass' subclass RcDialog

::method initDialog
  lc = self~newListView(IDC_LV_EMPLOYEES)
  if lc == .nil then return
  lc~~add(101222)~~add(,"Smith")~~add(, ,"John")
  lc~~add(101223)~~add(,"Michael")~~add(, ,"Carl")

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


<section id="mthNewTreeView"><title>newTreeView</title>
<indexterm><primary>newTreeView</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newTreeView</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newTreeView(--id--+------------+--)------------------------><
                      +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newTreeView</emphasis> method returns an object of the <link
  linkend="clsTreeView">TreeView</link> control class. This object represents the tree view control in the underlying dialog
  with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the tree view dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the tree view control class or <emphasis role="italic">.nil</emphasis> on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example :

<programlisting>
<![CDATA[
::class 'MyDlgClass' subclass ResDialog

::method initDialog

  tc = self~newTreeView(101)
  if tc == .nil then return

  tc~add("Root 1")
  tc~add(  ,"Item 1")
  tc~add(  ,"Item 2")
  tc~add(  ,"Item 3")
  tc~add("Root 2", , ,"EXPANDED")
  tc~add(  ,"Item 4", , ,"BOLD")
  tc~add(  ,"Item 5")
  tc~add(  ,"Subroot")
  tc~add(  ,    ,"Item 6",3)

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthNewTab"><title>newTab</title>
<indexterm><primary>newTab</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newTab</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newTab(--id--+------------+--)-----------------------------><
                 +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newTab</emphasis> method returns an object of the <link
  linkend="clsTab">Tab</link> control class. This object represents the tab control in the underlying dialog
  with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the tab dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the tab control class or <emphasis role="italic">.nil</emphasis> on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example initializes the tab control with symbolic ID IDC_TAB to have 5 tabs:

<programlisting>
<![CDATA[
::class 'MyDlgClass' subclass ResDialog

::method initDialog
  self~newTab(IDC_TAB)~addSequence("Design", "Implementation", -
                                   "Test", "Review", "Release")

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthNewMonthCalendar"><title>newMonthCalendar</title>
<indexterm><primary>newMonthCalendar</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newMonthCalendar</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newMonthCalendar(--id--+------------+--)-------------------><
                           +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newMonthCalendar</emphasis> method returns an object of the <link
  linkend="clsMonthCalendar">MonthCalendar</link> control class. This object represents the month calendar control in
  the underlying dialog with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the month calendar dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the month calendar control class or <emphasis role="italic">.nil</emphasis> on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example is from a program that takes applications from people to participate in a clinical trial of a
    new drug. When the applicant agrees to the terms for participating, the program checks that the applicant meets the
    necessary qualifications. One of which is that the applicant be at least 50 years of age:

<programlisting>
<![CDATA[

::method onAgree

  earliestAcceptableYear = .DateTime~new~addYears(-50)

  calendar = self~newMonthCalendar(IDC_MC_BIRTHDATE)

  if calendar~date > earliestAcceptableYear then do
    msg = "You must be 50 or over to participate in this clinical trial."
    ret = MessageDialog(msg, self~dlgHandle, "Not Qualified", "OK", "WARNING")
    return .false
  end

  ...  -- More checks

  return .true

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


<section id="mthNewDateTimePicker"><title>newDateTimePicker</title>
<indexterm><primary>newDateTimePicker</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newDateTimePicker</secondary></indexterm>
<programlisting>
<![CDATA[
>>-newDateTimePicker(--id--+------------+--)-------------------><
                           +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newDateTimePicker</emphasis> method returns a date and time picker object that represents
  the date and time picker control with the specified resource ID in the underlying dialog. See the <link
  linkend="clsDateTimePicker">DateTimePicker</link> class for details about date and time picker controls.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem><para>The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The <link linkend="defResourceId">resource ID</link> of the date and time picker. This may be <link
      linkend="defSymbolicId">symbolic</link> or numeric.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>category [optional]</term>
    <listitem>
    <para>
      The number of the page containing the control in a <link linkend="clsCategoryDialog">category dialog</link>, if
      appropriate. Specifying this argument in a dialog that is not a category dialog will likely cause the method to
      fail.
    </para>
    </listitem></varlistentry>
  </variablelist> </para></listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    A date and time picker object on success, or <emphasis role="italic">.nil</emphasis>.nil if the method fails for any
    reason.
  </para>
</listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example checks that user is not trying to schedule an appointment in the past:

<programlisting>
<![CDATA[
::class 'OnlineAppointmentDlg' subclass ResDialog

::method ok

  dtp = self~newDateTimePicker(IDC_DTP_APPOINTMENT)

  if dtp~getDateTime < .DateTime~new then do
    msg = "Appointments can not be scheduled in the past!"
    ret = MessageDialog(msg, self~dlgHandle, "Appointment Error", "OK", "ERROR")
    return 0
  end

  return self~ok:super

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthNewUpDown"><title>newUpDown</title>
<indexterm><primary>newUpDown</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>newUpDown</secondary></indexterm>
<programlisting>
<![CDATA[
>>--newUpDown(--id--+------------+--)--------------------------><
                        +-,--pageID--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">newUpDown</emphasis> method returns an object of the <link
  linkend="clsUpDown">UpDown</link> control class. This object represents the up down control in the underlying dialog
  with the specified resource ID.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the up down dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pageID [optional]</term>
    <listitem>
    <para>
      The page number in the <link linkend="clsCategoryDialog">CategoryDialog</link> containing the requested dialog
      control. If this argument is specified for a non-category dialog, this method will most likely fail.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    An object of the <computeroutput>UpDown</computeroutput> class or <emphasis role="italic">.nil</emphasis> on any
    error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example initializes the up down control with symbolic ID IDC_UPD :

<programlisting>
<![CDATA[
::method initDialog

  upDown = self~newUpDown(IDC_UPD)
  upDown~setRange(1, 20000)
  upDown~setPosition(64)
  upDown~redraw

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


</section>


<section id="sctWindowBaseDO"><title>Basic Window Methods</title>
<indexterm><primary>dialog object</primary><secondary>basic window methods</secondary></indexterm>
<para>
  Recall that in the Windows graphical user interface, everything is a window. The <link
  linkend="clsWindowBase">WindowBase</link> class is a mixin class that contains methods common to all windows. Since a
  dialog is a window, it inherits the <emphasis role="italic">WindowBase</emphasis> class. This section lists all the
  basic window methods for the dialog object.
</para>

<section id="wbdoEnable"><title>enable</title>
<programlisting>
WindowBase::<link linkend="mthEnable">enable</link>

<![CDATA[
>>--enable-----------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoDisable"><title>disable</title>
<programlisting>
WindowBass::<link linkend="mthDisable">disable</link>

<![CDATA[
>>-disable-----------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoIsVisible"><title>isVisible</title>
<programlisting>
WindowBase::<link linkend="mthIsVisible">isVisible</link>

<![CDATA[
>>--isVisible--------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoIsEnabled"><title>isEnabled</title>
<programlisting>
WindowBase::<link linkend="mthIsEnabled">isEnabled</link>

<![CDATA[
>>--isEnabled--------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoHide"><title>hide</title>
<programlisting>
WindowBase::<link linkend="mthHide">hide</link>

<![CDATA[
>>--hide-------------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoShowFast"><title>showFast</title>
<programlisting>
WindowBase::<link linkend="mthShowFast">showFast</link>

<![CDATA[
>>--showFast---------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoHideFast"><title>hideFast</title>
<programlisting>
WindowBase::<link linkend="mthHideFast">hideFast</link>

<![CDATA[
>>--hideFast---------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoDisplay"><title>display</title>
<programlisting>
WindowBase::<link linkend="mthDisplay">display</link>

<![CDATA[
]]>
</programlisting>
</section>

<section id="wbdoUpdate"><title>update</title>
<programlisting>
WindowBase::<link linkend="mthUpdate">update</link>

<![CDATA[
]]>
</programlisting>
</section>

<section id="wbdoDraw"><title>draw</title>
<programlisting>
WindowBase::<link linkend="mthDraw">draw</link>

<![CDATA[
>>--draw-------------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoRedrawClient"><title>redrawClient</title>
<programlisting>
WindowBase::<link linkend="mthRedrawClient">redrawClient</link>

<![CDATA[
>>--redrawClient(--+------------+--)---------------------------><
                   +--eraseBkg--+
]]>
</programlisting>
</section>

<section id="wbdoRedraw"><title>redraw</title>
<programlisting>
WindowBase::<link linkend="mthRedraw">redraw</link>

<![CDATA[
>>--redraw-----------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoGetID"><title>getID</title>
<programlisting>
WindowBase::<link linkend="mthGetID">getID</link>

<![CDATA[
>>--getID------------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoGetStyleRaw"><title>getStyleRaw</title>
<programlisting>
WindowBase::<link linkend="mthGetStyleRaw">getStyleRaw</link>

<![CDATA[
>>--getStyleRaw------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoGetExStyleRaw"><title>getExStyleRaw</title>
<programlisting>
WindowBase::<link linkend="mthGetExStyleRaw">getExStyleRaw</link>

<![CDATA[
>>--getExStyleRaw----------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoSetText"><title>setText</title>
<programlisting>
WindowBase::<link linkend="mthSetText">setText</link>

<![CDATA[
>>--setText(--newText--)---------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoGetText"><title>getText</title>
<programlisting>
WindowBase::<link linkend="mthGetText">getText</link>

<![CDATA[
>>--getText----------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoTitleEquals"><title>title=</title>
<programlisting>
WindowBase::<link linkend="mthTitleEquals">title=</link>

<![CDATA[
>>--title-=--newText-------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoSetTitle"><title>setTitle</title>
<programlisting>
WindowBase::<link linkend="mthSetTitle">setTitle</link>

<![CDATA[
>>--setTitle(--newText--)--------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoTitle"><title>title</title>
<programlisting>
WindowBase::<link linkend="mthTitle">title</link>

<![CDATA[
>>--title------------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoGetTextSizePx"><title>getTextSizePx</title>
<programlisting>
WindowBase::<link linkend="mthGetTextSizePx">getTextSizePx</link>

<![CDATA[
>>--getTextSizePx(-text--)-------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoGetTextSizeScreen"><title>getTextSizeScreen</title>
<programlisting>
WindowBase::<link linkend="mthGetTextSizeScreen">getTextSizeScreen</link>

<![CDATA[
>>--getTextSizeScreen(-text--+---------+--+------------+--+-------------+-)----><
                             +-,-type--+  +-,-fontSrc--+  +-,-fontSize--+
]]>
</programlisting>
</section>

<section id="wbdoSetRect"><title>setRect</title>
<programlisting>
WindowBase::<link linkend="mthSetRect">setRect</link>

<![CDATA[
Form 1:

>>--setRect(--rectangle--+------------+--)-------------------------------------><
                         +-,-showOpts-+

Form 2:

>>--setRect(--point--,--size--+------------+--)--------------------------------><
                              +-,-showOpts-+

Form 3:

>>--setRect(--x-,--y-,--cx-,--cy--+------------+--)----------------------------><
                                  +-,-showOpts-+

Generic form:

>>--setRect(--ptSizeRectangle--+------------+--)-------------------------------><
                               +-,-showOpts-+
]]>
</programlisting>
</section>

<section id="wbdoResizeTo"><title>resizeTo</title>
<programlisting>
WindowBase::<link linkend="mthResizeTo">resizeTo</link>

<![CDATA[
Form 1:

>>--resizeTo(--size--)-----------------------------------------><

Form 2:

>>--resizeTo(--cx,--cy--)--------------------------------------><

Generic form:

>>--resizeTo(--newSize--)--------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoMoveTo"><title>moveTo</title>
<programlisting>
WindowBase::<link linkend="mthMoveTo">moveTo</link>

<![CDATA[
Form 1:

>>--moveTo(--point--+--------------+--)------------------------><
                    +--,-showOpts--+
Form 2:

>>--moveTo(--x,--y--+--------------+--)------------------------><
                    +--,-showOpts--+
Generic form:

>>--moveTo(--newPos--+--------------+--)-----------------------><
                     +--,-showOpts--+
]]>
</programlisting>
</section>

<section id="wbdoGetRealSize"><title>getRealSize</title>
<programlisting>
WindowBase::<link linkend="mthGetRealSize">getRealSize</link>

<![CDATA[
>>--getRealSize------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoGetRealPos"><title>getRealPos</title>
<programlisting>
WindowBase::<link linkend="mthGetSize">getRealPos</link>

<![CDATA[
>>--getRealPos-------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wbdoGetSize"><title>getSize</title>
<programlisting>
WindowBase::<link linkend="mthGetSize">getSize</link>

<![CDATA[
>>--getSize----------------------------------------------------><
]]>
</programlisting>
</section>


</section> <!-- END Section Basic Window Methods  -->


<section id="sctWindowExtensionsDO"><title>Extended Window Methods</title>
<indexterm><primary>dialog object</primary><secondary>extended window methods</secondary></indexterm>
<para>
  The methods implemented by <link linkend="clsWindowExtensions">WindowExtensions</link> class are listed in this
  section. The class name, <emphasis role="italic">WindowExtensions</emphasis> would seem to imply that the methods were
  common to all windows. However, the methods of this class are really just extensions to the original ooDialog
  framework, and many of the methods are not window specific methods.
</para>

<section id="wedoGetFont"><title>getFont</title>
<programlisting>
WindowExtensions::<link linkend="mthGetFont">getFont</link>

<![CDATA[
>>--getFont----------------------------------------------------><
]]>
</programlisting>
</section>

<section id="wedoSetFont"><title>setFont</title>
<programlisting>
WindowExtensions::<link linkend="mthSetFont">setFont</link>

<![CDATA[
>>--setFont(--fontHandle--+---------+--)-------------------------><
                          +-,redraw-+
]]>
</programlisting>
</section>

<section id="wedoCreateFontEx"><title>createFontEx</title>
<programlisting>
WindowExtensions::<link linkend="mthCreateFontEx">createFontEx</link>

<![CDATA[
>>--createFontEx(--fontName-+--------------+--+---------------+--)-------------><
                            +-,-pointSize--+  +-,-additional--+
]]>
</programlisting>
</section>

</section> <!-- END Section Extended Window Methods  -->


<section id="comboboxmeth"><title>Combo Box Methods</title>
<indexterm><primary>combo box methods</primary></indexterm>
<para>The following methods belong to combo boxes.</para>

<section id="h000307"><title>AddComboEntry</title>
<indexterm><primary>AddComboEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~AddComboEntry(--id--,--aString--)---------------><


]]>
</programlisting>

<para>The AddComboEntry method adds a string to the list
of a combo box. The new item becomes the last one, if the list does not have
the SORT flag set. In the case of a sorted list, the
new item is inserted at the proper position. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of a combo box.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The data to be inserted as a new line.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example adds the new line, <computeroutput>Another item</computeroutput>, to
the list of combo box 103:

<programlisting>
<![CDATA[
MyDialog~AddComboEntry(103, "Another item")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000316"><title>InsertComboEntry</title>
<indexterm><primary>InsertComboEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~InsertComboEntry(--id--,--+-------+--,--string--)-><
                                         +-index-+


]]>
</programlisting>

<para>The InsertComboEntry method inserts a string into
the list of a combo box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index (line number) where you want to insert the new item. If this
argument is omitted, the new item is inserted after the currently selected
item.
</para></listitem></varlistentry>
<varlistentry><term>string</term>
<listitem><para>The data string to be inserted.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>This statement inserts <computeroutput>The new third line</computeroutput> after the second
line into the list of combo box 103:

<programlisting>
<![CDATA[
MyDialog~InsertComboEntry(103, 2, "The new third line")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000326"><title>DeleteComboEntry</title>
<indexterm><primary>DeleteComboEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DeleteComboEntry(--id--,--index--)--------------><


]]>
</programlisting>

<para>The DeleteComboEntry method deletes a string from
the combo box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The line number of the item to be deleted. Use the FindComboEntry method
(see page<link linkend="h000335">FindComboEntry</link>) to retrieve the index of
an item.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example shows a method that deletes the item that is passed
to the method in the form of a text string from combo box 203:

<programlisting>
<![CDATA[
      .
      .
      .
::method DeleteFromCombo
   use arg delStr
   idx = self~FindComboEntry(203, delStr)
   self~DeleteComboEntry(203, idx)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000335"><title>FindComboEntry</title>
<indexterm><primary>FindComboEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~FindComboEntry(--id--,--aString--)--------------><


]]>
</programlisting>

<para>The FindComboEntry method returns the index corresponding
to a given text string in the combo box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The string of which you search the index in the combo box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>See <link linkend="h000326">DeleteComboEntry</link> for an example.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="gcem"><title>GetComboEntry</title>
<indexterm><primary>GetComboEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetComboEntry(--id--,--index--)-----------------><


]]>
</programlisting>

<para>The GetComboEntry method returns the string at
index of the combo box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index of the list entry to be retrieved
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
<![CDATA[
if dlg~GetComboEntry(203,5)="JOHN"
then ...
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000336"><title>GetComboItems</title>
<indexterm><primary>GetComboItems</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetComboItems(--id--)---------------------------><


]]>
</programlisting>

<para>The GetComboItems method returns the number of
items in the combo box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000344"><title>GetCurrentComboIndex</title>
<indexterm><primary>GetCurrentComboIndex</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetCurrentComboIndex(--id--)--------------------><


]]>
</programlisting>

<para>The GetCurrentComboIndex method returns the index
of the currently selected item within the list. See <link linkend="h000482">GetComboLine</link> for
information on how to retrieve the selected combo box item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example displays the line number of the currently selected
combo box item within entry line 240:</para>

<programlisting>
<![CDATA[
::class MyListDialog subclass UserDialog
     .
     .
     .
::method init
   self~Init:super
   self~ConnectList(230, "ListSelected")
     .
     .
     .
::method ListSelected
   line = self~GetCurrentComboIndex(230)
   setEditData(240, line)
]]>
</programlisting>
<para>Method <computeroutput>ListSelected</computeroutput> is called
each time the selected item within the combo box changes.</para>
</listitem></varlistentry>
</variablelist>
</section>

<section id="h000345"><title>SetCurrentComboIndex</title>
<indexterm><primary>SetCurrentComboIndex</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetCurrentComboIndex(--id--+----------+--)------><
                                          +-,--index-+


]]>
</programlisting>

<para>The SetCurrentComboIndex method selects the item
with the given index within the list. If called without an index, all items
in the list are deselected. See <link linkend="h000548">SetComboLine</link> for information on
how to select a combo box item using a data value. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index within the combo box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000352"><title>ChangeComboEntry</title>
<indexterm><primary>ChangeComboEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ChangeComboEntry(--id--,--+-------+--,--aString--)-><
                                         +-index-+


]]>
</programlisting>

<para>The ChangeComboEntry method changes the value of
a given entry in a combo box to a new string. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index number of the item you want to replace. To retrieve the index,
use the FindComboEntry or GetCurrentComboIndex method (see page <link linkend="h000335">FindComboEntry</link> or <link linkend="h000344">GetCurrentComboIndex</link>).
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The new text.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>In the following example, method <computeroutput>ChangeButtonPressed</computeroutput> changes
the currently selected line of combo box 230 to the value in entry line 250:

<programlisting>
<![CDATA[
     .
     .
     .
::method ChangeButtonPressed
   idx = self~GetCurrentComboEntry(230)
   str = self~getEditData(250)
   self~ChangeComboEntry(230, idx, str)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000362"><title>ComboAddDirectory</title>
<indexterm><primary>ComboAddDirectory</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ComboAddDirectory(--id--,--drvpath--,------------->

      +---------------+
      V               |
>--"----+-READWRITE-+-+--"--)-----------------------------------><
        +-READONLY--+
        +-HIDDEN----+
        +-SYSTEM----+
        +-DIRECTORY-+
        +-ARCHIVE---+


]]>
</programlisting>

<para>The ComboAddDirectory method adds all or selected
file names in the given directory to the combo box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
<varlistentry><term>drvpath</term>
<listitem><para>The drive, path, and name pattern.
</para></listitem></varlistentry>
<varlistentry><term>fileAttributes</term>
<listitem><para>Specify the file attributes that the files must have in order to be
added:
<variablelist>
<varlistentry><term>READWRITE</term>
<listitem><para>Normal read/write files (same as none).
</para></listitem></varlistentry>
<varlistentry><term>READONLY</term>
<listitem><para>Files that have the read-only bit.
</para></listitem></varlistentry>
<varlistentry><term>HIDDEN</term>
<listitem><para>Files that have the hidden bit.
</para></listitem></varlistentry>
<varlistentry><term>SYSTEM</term>
<listitem><para>Files that have the system bit.
</para></listitem></varlistentry>
<varlistentry><term>DIRECTORY</term>
<listitem><para>Files that have the directory bit.
</para></listitem></varlistentry>
<varlistentry><term>ARCHIVE</term>
<listitem><para>Files that have the archive bit.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example fills the combo box list with the names of all
read/write files with extension .REX in the given directory:

<programlisting>
<![CDATA[
MyDialog~ComboAddDirectory(203, drive":\"path"\*.rex", "READWRITE")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000372"><title>ComboDrop</title>
<indexterm><primary>ComboDrop</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ComboDrop(--id--)-------------------------------><


]]>
</programlisting>

<para>The ComboDrop method deletes all items from the
list of the given combo box.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="listboxmeth"><title>List Box Methods</title>
<indexterm><primary>list box methods</primary></indexterm>
<para>The following methods deal with list boxes.</para>

<section id="getlistwidth"><title>GetListWidth</title>
<indexterm><primary>GetListWidth</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetListWidth(--id--)----------------------------><


]]>
</programlisting>

<para>The GetListWidth method returns the scrollable
width of a list box, in dialog units. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box of which you want to know the scrollable width.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The width of the scrollable area of the list box, in dialog units.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="setlistwidth"><title>SetListWidth</title>
<indexterm><primary>SetListWidth</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetListWidth(--id--,--scrollwidth--)------------><


]]>
</programlisting>

<para>The SetListWidth method sets the scrollable width
of a list box, in dialog units. If the scrollable width is greater than the
width of the list box and the &quot;HSCROLL&quot; (WS_HSCROLL in the resource
script) style is defined for the list box (see <link linkend="mthAddListBox">addListBox</link>), a
horizontal scroll bar is displayed. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box for which you want to set the scrollable width.
</para></listitem></varlistentry>
<varlistentry><term>scrollwidth</term>
<listitem><para>The width of the scrollable area of the list box, in dialog units.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="setlistcolumnwidth"><title>SetListColumnWidth</title>
<indexterm><primary>SetListColumnWidth</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetListColumnWidth(--id--,--columnwidth--)------><


]]>
</programlisting>

<para>The SetListColumnWidth method sets the width of
all columns in a list box, in dialog units.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box for which you want to set the column width.
</para></listitem></varlistentry>
<varlistentry><term>columnwidth</term>
<listitem><para>The width of the columns in the list box, in dialog units.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000380"><title>AddListEntry</title>
<indexterm><primary>AddListEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~AddListEntry(--id--,--aString--)----------------><


]]>
</programlisting>

<para>The AddListEntry method adds a string to the given
list box. See also <link linkend="h000307">AddComboEntry</link>. The line is added at the end (by
default), or in sorted order if the list box was defined with the sorted flag. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of a list box.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The data to be inserted as a new line.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000389"><title>InsertListEntry</title>
<indexterm><primary>InsertListEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~InsertListEntry(--id--,--+-------+--,--aString--)-><
                                        +-index-+


]]>
</programlisting>

<para>The InsertListEntry method inserts a string into
the given list box. See also <link linkend="h000316">InsertComboEntry</link>. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index (line number starting with 1) of the item after which the
new item is inserted. If this argument is omitted, the new item is inserted
after the currently selected item.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The text string to be inserted.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000399"><title>DeleteListEntry</title>
<indexterm><primary>DeleteListEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DeleteListEntry(--id--,--index--)---------------><


]]>
</programlisting>

<para>The DeleteListEntry method deletes an item from
a list box. See also <link linkend="h000326">DeleteComboEntry</link>. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The line number of the item to be deleted. Use <link linkend="h000408">FindListEntry</link> to
retrieve the index of an item. If this argument is omitted, the currently
selected item is deleted.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000408"><title>FindListEntry</title>
<indexterm><primary>FindListEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~FindListEntry(--id--,--aString--)---------------><


]]>
</programlisting>

<para>The FindListEntry method returns the index of the
given string within the given list box. The first item has index 1, the second
has index 2, and so forth. If the list box does not contain the string, 0
is returned. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The item text you are looking for.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example shows a method that adds the contents of an entry
line (214) to the list box (215) if no item with the same value is already
contained in it:

<programlisting>
<![CDATA[
      .
      .
      .
::method PutEntryInList
   str = self~getEditData(214)
   if self~FindListEntry(215, str) = 0 then
      self~AddListEntry(215, str)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="glem"><title>GetListEntry</title>
<indexterm><primary>GetListEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetListEntry(--id--,--index--)------------------><


]]>
</programlisting>

<para>The GetListEntry method returns the string at index of the list. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index of the list entry to be retrieved.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
<![CDATA[
if dlg~GetListEntry(203,5)="JOHN"
then ...
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000409"><title>GetListItems</title>
<indexterm><primary>GetListItems</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetListItems(--id--)----------------------------><


]]>
</programlisting>

<para>The GetListItems method returns the number of items
in the list box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="getlistitemheight"><title>GetListItemHeight</title>
<indexterm><primary>GetListItemHeight</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetListItemHeight(--id--)-----------------------><


]]>
</programlisting>

<para>The GetListItemHeight method returns the height
of the items in a list box, in dialog units. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box of which you want to know the item height.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The height of the list box items, in dialog units.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="setlistitemheight"><title>SetListItemHeight</title>
<indexterm><primary>SetListItemHeight</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetListItemHeight(--id--,--itemheight--)--------><


]]>
</programlisting>

<para>The SetListItemHeight method sets the height for
all items in a list box, in dialog units. It determines the space between
the individual list box items.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box for which you want to set the item height.
</para></listitem></varlistentry>
<varlistentry><term>itemheight</term>
<listitem><para>The height of the items in the list box, in dialog units.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>A number smaller than 0 if the height that you specify is not valid.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000417"><title>GetCurrentListIndex</title>
<indexterm><primary>GetCurrentListIndex</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetCurrentListIndex(--id--)---------------------><


]]>
</programlisting>

<para>The GetCurrentListIndex method returns the index
of the currently selected list box item, or 0 if no item is selected. See <link linkend="h000474">GetListLine</link> for information on how to retrieve the selected list box
item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000418"><title>SetCurrentListIndex</title>
<indexterm><primary>SetCurrentListIndex</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetCurrentListIndex(--id--+----------+--)-------><
                                         +-,--index-+


]]>
</programlisting>

<para>The SetCurrentListIndex selects the item with the
given index in the list. If called without an index, all items in the list
are deselected. See <link linkend="h000539">SetListLine</link> for information on how to select
a list box item using a data value. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index within the list box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000425"><title>ChangeListEntry</title>
<indexterm><primary>ChangeListEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ChangeListEntry(--id--,--+-------+--,--aString--)-><
                                        +-index-+


]]>
</programlisting>

<para>The ChangeListEntry method changes the contents
of a line in a list box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index of the item that you want to replace. If this argument is
omitted, the currently selected item is changed.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The new text of the item.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000435"><title>SetListTabulators</title>
<indexterm><primary>SetListTabulators</primary></indexterm>
<programlisting>
<![CDATA[
                                          +-,---+
                                          V     |
>>-aBaseDialog~SetListTabulators(--id--,----tab-+--)-----------><


]]>
</programlisting>

<para>The SetListTabulators method sets the tabulators
for a list box. Thus you can use items containing tab characters ("09"x),
which is useful for formatting the list in more than one column. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>tab</term>
<listitem><para>The positions of the tabs relative to the left edge of the list box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example creates a four-column list and adds a tab-formatted
row to the list. The tabulator positions are 10, 20, and 30.

<programlisting>
<![CDATA[
MyDialog~SetListTabulators(102, 10, 20, 30)
MyDialog~AddListEntry(102, var1  "09"x
var2  "09"x  ,
                           var3  "09"x  var4)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000448"><title>ListAddDirectory</title>
<indexterm><primary>ListAddDirectory</primary></indexterm>
<programlisting>
<![CDATA[
                                                        +---------------+
                                                        V               |
>>-aBaseDialog~ListAddDirectory(--id--,--drvPath--,--"----+-READWRITE-+-+--"--)-><
                                                          +-READONLY--+
                                                          +-HIDDEN----+
                                                          +-SYSTEM----+
                                                          +-DIRECTORY-+
                                                          +-ARCHIVE---+


]]>
</programlisting>

<para>The ListAddDirectory method adds all or selected
file names of a given directory to the list box. See <link linkend="h000362">ComboAddDirectory</link> for
more information.</para>
</section>

<section id="h000458"><title>ListDrop</title>
<indexterm><primary>ListDrop</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ListDrop(--id--)-------------------------------><


]]>
</programlisting>

<para>The ListDrop method removes all items from the
list box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="man0020"><title>Scroll Bar Methods</title>
<indexterm><primary>scroll bar methods</primary></indexterm>
<para>The following methods are used to set or get the behavior of a scroll bar.
You can connect scroll bars with numerical entry fields to edit the value
with the mouse.</para>

<section id="h000782"><title>GetSBRange</title>
<indexterm><primary>GetSBRange</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetSBRange(--id--)-----------------------------><


]]>
</programlisting>

<para>The GetSBRange method returns the range of a scroll
bar control. It returns the two values (minimum and maximum) in one string,
separated by a blank. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the scroll bar.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example demonstrates how to get the minimum and the maximum
values of the scroll bar:

<programlisting>
<![CDATA[
     .
     .
     .
::method DumpSBRange
SBrange = self~GetSBRange(234)
parse var SBrange SBmin SBmax
say SBmin " - " SBmax
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000770"><title>SetSBRange</title>
<indexterm><primary>SetSBRange</primary></indexterm>
<programlisting>
<![CDATA[
                                                   +-1------+
>>-aBaseDialog~SetSBRange(--id--,--min--,--max--,--+--------+--)-><
                                                   +-redraw-+


]]>
</programlisting>

<para>The SetSBRange method sets the range of a scroll
bar control. It sets the minimum and maximum values. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is not intended to be used outside of the BaseDialog class.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of a scroll bar control.
</para></listitem></varlistentry>
<varlistentry><term>min</term>
<listitem><para>The minimum value.
</para></listitem></varlistentry>
<varlistentry><term>max</term>
<listitem><para>The maximum value.
</para></listitem></varlistentry>
<varlistentry><term>redraw</term>
<listitem><para>A flag indicating whether (1) or not (0) the scroll bar should be redrawn.
The default is 1.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example allows the scroll bar to take values between 1
and 10:

<programlisting>
<![CDATA[
MyDialog~SetSBRange(234, 1, 10, 1)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000790"><title>GetSBPos</title>
<indexterm><primary>GetSBPos</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetSBPos(--id--)-------------------------------><


]]>
</programlisting>

<para>The GetSBPos method returns the current value of
a scroll bar control. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the scroll bar.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000791"><title>SetSBPos</title>
<indexterm><primary>SetSBPos</primary></indexterm>
<programlisting>
<![CDATA[
                                         +-1------+
>>-aBaseDialog~SetSBPos(--id--,--pos--,--+--------+--)--------><
                                         +-redraw-+


]]>
</programlisting>

<para>The SetSBPos method sets the current value of a
scroll bar control. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>pos</term>
<listitem><para>The value to which you want to set the scroll bar. It must be within
the defined range.
</para></listitem></varlistentry>
<varlistentry><term>redraw</term>
<listitem><para>A flag indicating whether (1) or not (0) the scroll bar should be redrawn.
The default is 1.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000816"><title>CombineELwithSB</title>
<indexterm><primary>CombineELwithSB</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~CombineELwithSB(--elid--,--sbid--+-------------------------+--)-><
                                                +-,--+------+--+--------+-+
                                                     +-step-+  +-,--pos-+


]]>
</programlisting>

<para>
  The CombineELwithSB method connects an entry line with a scroll bar such that each time the slider of the scroll bar
  is moved, the value of the entry field is changed. This method must be used in a method registered with <link
  linkend="mthConnectEachSBEvent">connectEachSBEvent</link>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>elid</term>
    <listitem>
    <para>
      The ID of the entry line.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>sbid</term>
    <listitem>
    <para>
      The ID of the scroll bar.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>step</term>
    <listitem>
    <para>
      The size of one step.  If, for example, step is 3 and the current position is 4, the next position is 7.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pos</term>
    <listitem>
    <para>
      If the step value is zero, this sets the position of the scroll bar and entry line. Use it in the method
      registered for drag.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example continues the example of ConnectScrollBar. In the registered methods an entry line (251) is
    combined with the scroll bar (255).

<programlisting>
<![CDATA[
::method Increase
self~CombineELwithSB(251,255,+20)
::method Decrease
self~CombineELwithSB(251,255,-20)
::method Drag
use arg wparam, lparam                  /* wparam=position */
self~CombineELwithSB(251,255,0,wparam)
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="detersb"><title>DetermineSBPosition</title>
<indexterm><primary>DetermineSBPosition</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DetermineSBPosition(--id--,--posdata--+----------------------------+--)-><
                                                     +-,--+--------+--+---------+-+
                                                          +-single-+  +-,--page-+


]]>
</programlisting>

<para>The DetermineSBPosition method calculates and sets
the new scroll bar position based on the position data retrieved from the
scroll bar and the step information.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>posdata</term>
<listitem><para>The position information sent with the connected scroll bar event.
</para></listitem></varlistentry>
<varlistentry><term>single</term>
<listitem><para>This number is added (or subtracted if negative) to the current position
for a single step. If omitted, the single step size is 1.
</para></listitem></varlistentry>
<varlistentry><term>page</term>
<listitem><para>This number is added (or subtracted if negative) to the current position
for a page step. If omitted, the page step size is 10.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The new scroll bar position.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example demonstrates how to update the scroll bar position.
Each time the ScrollBarEventHandler is called by an event for scroll bar SB_SIZE,
the position of the scroll bar is calculated and updated. <computeroutput>posdata</computeroutput> is
sent along with the scroll bar event.

<programlisting>
<![CDATA[
   /* Method ScrollBarEventHandler is connected to item SB_SIZE */
::method ScrollBarEventHandler
    use arg posdata, sbwnd
    pos = self~DetermineSBPosition("SB_SIZE",posdata,1,25)
    return pos

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="man0024"><title>Methods to Query Operating System Values</title>
<indexterm><primary>methods for handles, sizes, and positions</primary></indexterm>
<indexterm><primary>methods to query OS values</primary></indexterm>
<para>The methods in this section return information known to, or used by, the
operating system when it works with dialogs or dialog controls.  This includes
things like window handles, window sizes, and window positions.  It also
includes things like the width of a scroll bar or the number of monitors
attached to the system.
</para>

<section id="mthGetSelf"><title>getSelf</title>
<indexterm><primary>getSelf</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetSelf----------------------------------------><


]]>
</programlisting>

<para>The getSelf method returns the handle of the Windows Dialog associated
with the ooDialog dialog instance. A handle is a unique reference to a
particular Windows object. Handles are used within some of the methods to work
on a specific Windows object.
</para>
<note><title><emphasis role="bold">Note</emphasis></title><para>
Prior to ooRexx 3.2.0, the <computeroutput>getSelf</computeroutput> method was
not documented.  The <link linkend="h000086">Get</link> method was documented as
if it were the <computeroutput>getSelf</computeroutput> method. The
<computeroutput>Get</computeroutput> method returns the handle to the most
recently created dialog.  In an application with more than one dialog this may
not be the same as the Windows dialog associated with the instance object the
programmer is working with.
</para></note>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>Below is an example demonstrating these Windows handles and how
they are related.  Assume <computeroutput>showHandles</computeroutput> is a
method of a subclass of BaseDialog and that staticDlg is a saved reference to
another ooDialog object and that the static dialog was just created.  The
<computeroutput>showHandles</computeroutput> method is connected to a push
button and then displays the handles when the user clicks that button.
<programlisting> <![CDATA[
::method showHandles
  expose staticDlg

  hwndTop = self~get
  hwndMyDialogHandle = self~dlgHandle
  hwndMySelf = self~getSelf
  hwndStatic = staticDlg~dlgHandle
  say "Top dialog:      " hwndTop
  say "Self (dlgHandle):" hwndMyDialogHandle
  say "Self (getSelf):  " hwndMySelf
  say "Static dialog:   " hwndStatic

]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Output:</emphasis></term>
<listitem><para>The above might write to the console something like the following:
<programlisting>
<![CDATA[
  Top dialog:       787096
  Self (dlgHandle): 4522228
  Self (getSelf):   4522228
  Static dialog:    787096
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000086"><title>Get</title>
<indexterm><primary>Get</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Get--------------------------------------------><


]]>
</programlisting>

<para>The <computeroutput>Get</computeroutput> method returns the handle of the
Windows Dialog associated with the top ooDialog dialog. A handle is a unique
reference to a particular Windows object. Handles are used within some of the
methods to work on a specific Windows object.
</para>
<note><title>Note</title><para>
If more than one ooDialog exists, the top dialog and the dialog whose method is
executing may not be the same.  When more than one dialog exists, the top dialog
is the one that was created last.
</para></note>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>Below is an example demonstrating that the top dialog and the
executing dialog may not be the same.  Assume display is a method of a subclass
of BaseDialog and that staticDlg is a saved reference to another ooDialog
object.
<programlisting>
<![CDATA[
::method display
  expose staticDlg

  hwndTop = self~get
  hwndSelf = self~dlgHandle
  hwndStatic = staticDlg~dlgHandle
  say "Top dialog:   " hwndTop
  say "Self:         " hwndSelf
  say "Static dialog:" hwndStatic

]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Output:</emphasis></term>
<listitem><para>The above might write to the console something like the following:
<programlisting>
<![CDATA[
  Top dialog:    787096
  Self:          4522228
  Static dialog: 787096
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthGetItem"><title>GetItem</title>
<indexterm><primary>GetItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetItem(--id--+---------+--)-------------------><
                             +-,--hDlg-+


]]>
</programlisting>

<para>The GetItem method returns the handle of a particular
dialog item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog element.
</para></listitem></varlistentry>
<varlistentry><term>hDlg</term>
<listitem><para>The handle of the dialog. If it is omitted, the main dialog handle is
used.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example returns the handle of a push button:

<programlisting>
<![CDATA[
hndPushButton = MyDialog~GetItem(101)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthGetControlID"><title>GetControlID</title>
<indexterm><primary>GetControlID</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetControlID(--hWnd--)-------------------------><


]]>
</programlisting>

<para>Given a valid window handle to a dialog control, the
<computeroutput>GetControlID</computeroutput> method returns the resource ID of
the control.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hWnd</term>
<listitem><para>The window handle of the dialog control.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>Negative values indicate an error.
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The <computeroutput>hWnd</computeroutput> argument is not a
valid window handle.
</para></listitem></varlistentry>
<varlistentry><term>less than -1</term>
<listitem><para>The value is the negated Operating System Error code.  The
absolute value of the return can be used to look up the error reason in the
Windows documentation.
</para></listitem></varlistentry>
<varlistentry><term>other</term>
<listitem><para>The resource ID of the dialog control.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following is a complete working example.  It allows the user
to check a check box with the F2 key and uncheck it with the F3 key.  The F2 and
F3 key press events are connected to the <computeroutput>check</computeroutput>
and <computeroutput>uncheck</computeroutput> methods.  When the user presses the
F2 key, the program determines which control has the focus, uses the returned
window handle to get the control ID, and then uses the ID to check the check
box.  And the same approach if the F3 key is pressed.
</para>
<para>Note that in this dialog, there are only four controls that can have the
focus.  If the OK button has the focus, then nothing is done.  In a more complex
application, the programmer would probably check that the resource ID matches
one of the check boxes instead.
<programlisting> <![CDATA[

/* Simple Grocery List */

  dlg = .SimpleDialog~new
  dlg~constDir[IDC_GB_LIST] = 101
  dlg~constDir[IDC_CB_MILK] = 102
  dlg~constDir[IDC_CB_BREAD] = 103
  dlg~constDir[IDC_CB_FRUIT] = 104
  dlg~constDir[IDC_CB_CEREAL] = 105

  if dlg~initCode = 0 then do
    dlg~create(30, 30, 150, 150, "The Simple Grocery List", "VISIBLE")
    dlg~execute("SHOWTOP")
  end

-- End of entry point.
::requires "oodWin32.cls"

::class SimpleDialog subclass UserDialog

::method check

  hWnd = self~getFocus
  id = self~getControlID(hWnd)
  if id == self~constDir[IDOK] then return

  self~newCheckBox(id)~check

::method unCheck

  id = self~getControlID(self~getFocus)
  if id == self~constDir[IDOK] then return

  self~newCheckBox(id)~uncheck

::method defineDialog

  self~addGroupBox(10, 20, 130, 90, "Check Needed Groceries", "", IDC_GB_LIST);
  self~createCheckBox(IDC_CB_MILK, , 30, 35, , , "Milk", "GROUP");
  self~createCheckBox(IDC_CB_BREAD, , 30, 55, , , "Bread", "NOTAB");
  self~createCheckBox(IDC_CB_FRUIT, , 30, 75, , , "Fruit", "NOTAB");
  self~createCheckBox(IDC_CB_CEREAL, , 30, 95, , , "Cereal", "NOTAB");

  self~createPushButton(IDOK, 105, 120, 35, 15, "GROUP", "OK")

::method initDialog

  -- We know that the key code for F2 is 113 so we don't need to use the
  -- VirtualKeyCodes class.  We use the 'none' filter so that only a F2 or F3
  -- key press is captured.  (Not Alt-F2, or Shift-F2, etc..)
  self~connectKeyPress(check, 113, "NONE")
  self~connectKeyPress(unCheck, 114, "NONE")

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthDlgUnit2pixel"><title>dlgUnit2pixel</title>
<indexterm><primary>dlgUnit2pixel</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>dlgUnit2pixel</secondary></indexterm>
<programlisting>
<![CDATA[
>>--dlgUnit2pixel(--du--)--------------------------------------><

]]>
</programlisting>

<para>
  Takes a dimension expressed in dialog units of this dialog and tranforms it to a dimension expressed in pixels.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>du [required] [In/Out]</term>
    <listitem>
    <para>
      The object to transform, can be either a <link linkend="clsPoint">Point</link>, <link
      linkend="clsSize">Size</link>, or <link linkend="clsRect">Rect</link>  On input, the unit of measurement is
      assumed to be dialog units and on return the dialog units will have been converted to pixels
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns true on success and false on error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method accurately converts dialog units of this dialog to pixels. Do not use <link
    linkend="atrFactorX">factorX</link> and <link linkend="atrFactorY">factorY</link> for the conversion as they are
    <link linkend="ovvInaccurate">inaccurate</link>.
  </para>
  <para>
    Normally, this method is invoked prior to the creation of the underlying dialog. In order to be accurate, the
    <link linkend="atrFontName">fontName</link> and <link linkend="atrFontSize">fontSize</link> attributes must
    reflect the actual font the dialog will use.  Use the <link linkend="mthSetDlgFont">setDlgFont</link>() method if
    necessary.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    TODO NEED EXAMPLE
<programlisting>
<![CDATA[

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End dialog object::dlgUnit2pixel() -->

<section id="mthPixel2dlgUnit"><title>pixel2dlgUnit</title>
<indexterm><primary>pixel2dlgUnit</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>pixel2dlgUnit</secondary></indexterm>
<programlisting>
<![CDATA[
>>--pixel2dlgUnit(--pixels--)----------------------------------><

]]>
</programlisting>

<para>
  Takes a dimension expressed in pixels and tranforms it to a dimension expressed in dialog units of this dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
  <variablelist>
    <varlistentry><term>pixels [required] [In/Out]</term>
    <listitem>
    <para>
      The object to transform, can be either a <link linkend="clsPoint">Point</link>, <link
      linkend="clsSize">Size</link>, or <link linkend="clsRect">Rect</link>  On input, the unit of measurement is
      assumed to be pixels and on return the pixels will have been converted to dialog units.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    True on succes, false on error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method accurately converts pixels to the correct dialog units of this dialog. Do not use <link
    linkend="atrFactorX">factorX</link> and <link linkend="atrFactorY">factorY</link> as they are <link
    linkend="ovvInaccurate">inaccurate</link>.
  </para>
  <para>
    However, if this method is invoked prior to the creation of the underlying dialog, the <link
    linkend="atrFontName">fontName</link> and <link linkend="atrFontSize">fontSize</link> attributes must reflect the
    actual font the dialog will use.  Use the <link linkend="mthSetDlgFont">setDlgFont</link>() method if necessary.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example shows how to position controls in a <link linkend="clsUserDialog">UserDialog</link> relative to a
    static image control. The pixel size of the picture is known.  That size is then coverted to dialog units so the
    other controls can be positioned correctly.
<programlisting>
<![CDATA[

::method defineDialog

  -- Be sure the font name and size attributes are correct.  We are using MS
  -- Shell Dlg 2 with a point size of 8 to create the dialog:
  self~setDlgFont("MS Shell Dlg 2", 8)

  caption = "Conrad, King of the Hill"

  -- The values used for the size and width of the image are ignored by the OS
  -- when the REALSIZEIMAGE style is used.  The OS will addjust the size of the
  -- static control to match the actual size of the bitmap.
  self~createStaticImage(IDC_BMP_PICTURE, 10, 10, 20, 17, "BITMAP REALSIZEIMAGE")

  -- We know the real size of the bitmap in pixels:
  size = .Size~new(265, 282)

  -- Convert the pixels to dialog units so we can position the other controls.
  self~pixel2dlgUnit(size)

  -- Position the caption, 5 dialog units below the picture, aligned with the
  -- left edge of the picture.
  yPos = 10 + size~height + 5
  self~createStaticText(IDC_ST_DESCRIPTION, 10, yPos, 176, 20, "TEXT LEFT", caption)

  -- Position the Ok button top aligned with the caption and aligne with the
  -- right edge of the picture.
  xPos = 10 + size~width - 50
  self~createPushButton(IDOK, xPos, yPos, 50, 14, "DEFAULT", "Ok", ok)

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End dialog object::pixel2dlgUnit() -->

<section id="mthGetPos"><title>getPos</title>
<indexterm><primary>GetPos</primary>
<secondary>DialogControl class</secondary></indexterm>
<indexterm><primary>GetPos</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getPos-----------------------------------------------------><

]]>
</programlisting>

<para>
  The getPos method returns the coordinates of the upper left corner a window, either a dialog or a
  dialog control, in dialog units.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The horizontal and vertical position, separated by a blank.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example dialog control:</emphasis></term>
<listitem><para>The following example repositions the tree view control FILES to the
upper left corner of  the window and displays the new position:
<programlisting>
<![CDATA[
obj = MyDialog~newTreeView("FILES")
if obj = .Nil then return
obj~Move(1,1)
parse value obj~getPos with x y
say "New horizontal position of window is" x "and new vertical position is" y
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example dialog:</emphasis></term>
<listitem><para>The following example moves the window towards the top left
of the screen.
<programlisting>
<![CDATA[
parse value self~getPos with px py
self~Move(px - 10, py - 10)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000703"><title>GetButtonRect</title>
<indexterm><primary>GetButtonRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetButtonRect(--id--)--------------------------><


]]>
</programlisting>

<para>The GetButtonRect method returns the size and position
of the given button. The four values (left, top, right, bottom) are returned
in one string separated by blanks. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000712"><title>GetWindowRect</title>
<indexterm><primary>GetWindowRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetWindowRect(--hwnd--)------------------------><


]]>
</programlisting>

<para>The GetWindowRect method returns the size and position
of the given window. The four values (left, top, right, bottom) are returned
in one string separated by blanks. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of the window.  There are a number of ways to get the
window handle of objects used in ooDialog. For instance, use the <link
linkend="h000086">getSelf</link> method to retrieve the window handle of the
dialog instance.  Use the  <link linkend="h000086">Get</link> method to retrieve
the window handle of the most recently created dialog.  To get the window handle
to a dialog control, the <link linkend="mthGetItem">GetItem</link> method can be
used.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

</section>

<section id="man0027"><title>Appearance and Behavior Methods</title>
<indexterm><primary>appearance methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<indexterm><primary>enable methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<indexterm><primary>disable methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<indexterm><primary>hide methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<indexterm><primary>show methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<para>
  The methods listed in this section are related to the appearance or the behavior of the dialog or its
  controls. The section contains methods related to size, position, visibility, and title.
</para>
<para>
  Some of the methods come in two flavors, normal (for example, ShowWindow and fast (for example,
  ShowWindowFast). The fast extension indicates that the method does not redraw the control or window
  immediately. After modifying several items, invoke the update method (see page <link
  linkend="mthUpdate">update</link>) to redraw the dialog.
</para>


<section id="mthGetTextSizeDu"><title>getTextSizeDu</title>
<indexterm><primary>getTextSizeDu</primary></indexterm>
<indexterm><primary>PlainBaseDialog class</primary>
<secondary>getTextSizeDu</secondary></indexterm>
<indexterm><primary>dialog object</primary>
<secondary>getTextSizeDu</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getTextSizeDu(--text--)----------------------------------------------------><

]]>
</programlisting>

<para>
  Calculates the size the given string will occupy in the dialog.  The size is returned in <link
  linkend="defDialogUnit">dialog units</link>.  To calculate the size in pixels use the <link
  linkend="mthGetTextSizePx">getTextSizePx</link>() method. The <link
  linkend="mthGetTextSizeDlgClsPlainBaseDialog">getTextSizeDlg</link>() method is similiar to <emphasis
  role="italic">getTextSizeDu</emphasis>, but should only be used when necessary
</para>
<para>
  The primary use of this method would be in laying out the dialog template in a <link
  linkend="clsUserDialog">UserDialog</link> before the underlying dialog is created.  To be sure the calculation is
  correct, ensure that the <link linkend="atrFontName">dialog font attributes</link> are set to the font that will be
  used by the dialog when it is created. The attributes can be set directly or by using the <link
  linkend="mthSetDlgFont">setDlgFont</link>() method.
<programlisting>
<![CDATA[

  dlg~setDlgFont("fontName", fontSize)
  dlg~getTextSizeDu("some text")
]]>
</programlisting>
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
    <para>The only argument is:
    <variablelist>
      <varlistentry><term>text</term>
      <listitem>
        <para>
          Calculate the size for this string.
        </para>
      </listitem></varlistentry>
    </variablelist>
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
    <para>
      The size needed for the string is returned as a <link linkend="clsSize">Size</link> object.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
    <para>
      This example calculates the size needed to display a static message.  It then uses that size to initialize a .Rect
      object with the coordinates of where to place the static control in the dialog. Note that a .Rect object normally
      defines a bounding rectangle. But, in this case the rectangle is used to specify the upper left corner and the
      width and the height of the rectangle.
      <programlisting>
      <![CDATA[
    ::method calcSizes private
      expose msgRect okRext

      -- Get the size needed for the message, place the static
      -- control at (10, 10) in the dialog.

      size = self~getTextSizeDu(message)
      msgRect = .Rect~new(10, 10, size~width, size~height)
      ...

      -- Get a reactangle for the ok push button, we know we
      -- want the width and height to be 40 and 14.

      okRect = .Rect~new(0, 0, 40, 14)

      -- Now calculate its position in relation to the message.
      -- This aligns the right edge of the button with the right
      -- edge of the message and places it 5 dialog units below
      -- the button.

      okRect~left = msgRect~left + msgRect~right  - 40
      okRect~top  = msgRect~top  + msgRect~bottom + 5
      ...

    ::method defineDialog
      expose message msgRect okRect

      -- Create our dialog controls.
      r = msgRect
      self~createStaticText(IDC_STATIC, r~left, r~top, r~right, r~bottom, , message)

      r = okRect
      self~createPushButton(IDOK, r~left, r~top, r~right, r~bottom, "DEFAULT", "Ok")

      ]]>
      </programlisting>
    </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::getTextSizeDu() -->


<section id="mthGetTextSizeDlgClsPlainBaseDialog"><title>getTextSizeDlg</title>
<indexterm><primary>getTextSizeDlg</primary>
<secondary>dialog object</secondary></indexterm>
<indexterm><primary>PlainBaseDialog class</primary>
<secondary>getTextSizeDlg</secondary></indexterm>
<indexterm><primary>dialog object</primary>
<secondary>getTextSizeDlg</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getTextSizeDlg(--text--+-------------+--+-------------+--+---------+--)----><
                           +-,-fontname--+  +-,-fontSize--+  +-,-hwnd--+
]]>
</programlisting>

<para>
  Calculates the size, (width and height,) in <link linkend="defDialogUnit">dialog units</link> for a given string.
</para>
<para>
  <emphasis role="bold">Note:</emphasis> this method replaces the deprecated <link
  linkend="deprecatedDialogMethods">deprecated</link> <emphasis role="italic">getTextSize</emphasis> method of the
  dialog object. The convoluted arguments to this method are needed to retain backwards compatibility with that method.
  The <link linkend="mthGetTextSizeDu">getTextSizeDu</link>() method should be used if at all possible.
</para>
<para>
  In general, dialog units are only of value in laying out the dialog controls before the underlying dialog is
  created.  Once the underlying dialog is created, it makes more sense to work with pixels. Since dialog units are tied
  directly to the font actually used by a specific dialog, specifying a font different from that used by the dialog will
  usually give incorrect results. Likewise, specifying a window handle other than the window handle of the dialog will
  also give incorrect results. Because of this, the optional arguments are usually not of much use, making <emphasis
  role="italic">getTextSizeDu</emphasis> is easier to use.
</para>
<para>
  One exception to this, is when the text size is being calculated for a dialog control that the programmer intends to
  set to a font different than the dialog font. In this case, specify the name and size of the font that the dialog
  control will use.
</para>
<para>
  If this method is used to aid in the lay out of the dialog controls, to be sure the calculation is correct, the <link
  linkend="atrFontName">dialog font attributes</link> must be set to the font that will be used by the dialog when it is
  created. The attributes can be set directly or by using the <link linkend="mthSetDlgFont">setDlgFont</link>() method.
<programlisting> <![CDATA[

  dlg~setDlgFont("fontName", fontSize)
  size = dlg~getTextSizeDlg("some text")
]]>
</programlisting>
</para>
<para>
  The ooDialog programmer is <emphasis role="bold">strongly</emphasis> encouraged to use the <link
  linkend="mthGetTextSizeDu"></link>() rather than this method.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
    <para>The arguments are:
    <variablelist>
      <varlistentry><term>text</term>
      <listitem>
        <para>
          The string whose size is desired.  If none of the optional arguments are specified then the
          dialog font is used to calculate the size.
        </para>
      </listitem></varlistentry>
      <varlistentry><term>fontName</term>
      <listitem>
        <para>
          Optional. The name of the font to use to calculate the size needed for the string.  Use This argument when the
          string will be displayed in a dialog control that is using a font <emphasis role="bold">different</emphasis>
          than the dialog font.  When this argument is used, then the specified font is always used in the calculation.
        </para>
      </listitem></varlistentry>
      <varlistentry><term>fontSize</term>
      <listitem>
        <para>
          Optional. The size of the font named by the fontName argument. This argument is always ignored when the
          fontName argument is omitted. If the fontName is specified and this argument is omitted then the default font
          size is used. (Currently the default size is 8.)
        </para>
      </listitem></varlistentry>
      <varlistentry><term>hwnd</term>
      <listitem>
        <para>
          Optional. A valid window handle. The font of this window is used to calculate the text size. This argument is
          always ignored when the fontName argument is specified.  As per the notes above the Rexx programmer is
          encouraged not to use this argument.
        </para>
      </listitem></varlistentry>
    </variablelist>
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
    <para>
      The size needed for the string is returned in a <link linkend="clsSize">Size</link> object.
    </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::getTextSizeDlg() -->


<section id="background"><title>BackgroundColor</title>
<indexterm><primary>BackgroundColor</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~BackgroundColor(--color--)---------------------><


]]>
</programlisting>

<para>The BackgroundColor method sets the background
color of a dialog. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>color</term>
<listitem><para>A color-palette index specifying the background color. For information
on the color numbers, refer to <link linkend="sctTermDefs">Definition of Terms</link>.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id=mthShowClsPlainBaseDialog><title>show</title>
<indexterm><primary>show</primary><secondary>dialog object</secondary></indexterm>
<programlisting>
<![CDATA[
>>--show(--+--------+--)---------------------------------------><
           +--opts--+

]]>
</programlisting>

<para>
  Sets the dialog window's show state.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Argument:</emphasis></term>
  <listitem>
  <para>
    The single, optional, <emphasis role="italic">opts</emphasis> argument can be zero or one of the following keywords,
    case is not significant:
  <variablelist>
    <varlistentry><term>NORMAL</term>
    <listitem>
    <para>
      Makes the dialog visible in its default position and window size. This has the effect of restoring the dialog size
      and position if it is minimized or maximized. This is the default if the argument is omitted.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>DEFAULT</term>
    <listitem>
    <para>
      DEFAULT is an alias for NORMAL. The two keywords are functionally identical.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>SHOWTOP</term>
    <listitem>
    <para>
      Makes the dialog visible and the topmost window. Note that the dialog size and position are not restored if the
      dialog is minimized or maximized.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>HIDE</term>
    <listitem>
    <para>
      Makes the dialog invisible.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>MIN</term>
    <listitem>
    <para>
      Minimizes the dialog and activates the next window in the window order.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>MAX</term>
    <listitem>
    <para>
      Maximizes, and makes visible if necessary, the dialog.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>INACTIVE</term>
    <listitem>
    <para>
      Makes the dialog visible without changing the active window.  When the NORMAL keyword is used, the dialog is shown
      and becomes the active window. The INACTIVE keyword makes the dialog visible without changing the focuse from the
      current active window.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>RESTORE</term>
    <listitem>
    <para>
      Makes the dialog visible and restores it to its original size and position if it was minimized or maximized. An
      application should specify this flag when restoring a minimized window.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The <emphasis role="italic">show</emphasis> method is invoked automatically by the methods that run a dialog, <link
    linkend="mthExecute">execute</link>, <link linkend="mthPopup">popup</link>, etc.. Once the dialog is running this
    method can be used to hide, maximize, or otherwise change the show state as described by the keywords. There are
    also a number of conveninece methods that do similiar things, <link linkend="mthHide">hide</link>, <link
    linkend="mthDisplay">display</link>, <link linkend="mthMinimize">minimize</link>, <link
    linkend="mthRestore">restore</link>, and so on.
  </para>
  <para>
    The <emphasis role="italic">show</emphasis> method over-rides the <link linkend="mthShowClsWindowBase">show</link>
    method of the <link linkend="clsWindow">WindowBase</link> class, which takes no arguments. The primary purpose of
    the dialog object <emphasis role="italic">show</emphasis> method is to allow flexibility in how the dialog is
    initialy shown when it is run.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns true if the window was previously visible and false if the window was previously hidden.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following statement makes the dialog invisible:

<programlisting>
<![CDATA[
  dlg~show("HIDE")
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="h000109"><title>ToTheTop</title>
<indexterm><primary>ToTheTop</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ToTheTop----------------------------------------><


]]>
</programlisting>

<para>The ToTheTop method makes the dialog the topmost
dialog. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem>
<para>
  The following example uses the <emphasis role="italic">toTheTop</emphasis> method to make the user aware of an alarm event:

<programlisting>
<![CDATA[
aDialog = .MyDialog~new
msg = .Message~new(aDialog, "Remind")
a = .Alarm~new("17:30:00", msg)

::class MyDialog subclass ResDialog
      .
      .
      .
::method remind
  self~setControlText(102, "Don&apos;t forget to go home!")
  self~toTheTop
]]>
</programlisting>

<note><title>Note</title><para>
The Message and Alarm classes
are built-in classes of Object Rexx.
See the <citetitle>Open Object Rexx: Reference</citetitle> for further information.
</para></note>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthEnsureVisibleClsPlainBaseDialog"><title>ensureVisible</title>
<indexterm><primary>ensureVisible</primary>
<secondary>BaseDialog class</secondary></indexterm>

<programlisting>
<![CDATA[
>>-aBaseDialog~EnsureVisible-----------------------------------><


]]>
</programlisting>

<para>The <computeroutput>ensureVisible</computeroutput> method causes the
dialog to reposition itself so that the entire dialog is on the visible screen.
If the entire dialog is already on the visible screen then no action is taken.
</para>
<para>This is useful in a number of situations.  It allows the programmer to
move or resize the dialog and not have to worry that the dialog is off the
screen.  After finishing the move or resizing, the programmer can invoke the
ensureVisible method and know that the dialog is entirely on the screen.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The method takes no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method always returns 0.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example reads in the previous size and position of
the dialog and then opens the dialog in the position that the user had closed
it.  If the INI file is corrupted, or had been accidently edited, or a number of
other things, it is possible that sizing and positioning the dialog using the
values from the INI file will place the dialog of the screen.  Invoking
<computeroutput>ensureVisible</computeroutput> will cause the dialog to
reposition itself so that it is completely on the screen, but only if needed.
If the dialog is already completely on the screen, then no action is taken.

<programlisting>
<![CDATA[

  if \.useDefault then
      do
          -- Read oorexxtry.ini position & size the dialog based on its values
          handle = self~getSelf()
          k1 = SysIni('oorexxtry.ini','oorexxtry','k1')
          k2 = SysIni('oorexxtry.ini','oorexxtry','k2')
          k3 = SysIni('oorexxtry.ini','oorexxtry','k3')
          k4 = SysIni('oorexxtry.ini','oorexxtry','k4')
          if k1 = 'ERROR:' | k2 = 'ERROR:' | k3 = 'ERROR:' | k4 = 'ERROR:' then
              nop -- First execution will not find the ini file
          else
              do
                  self~setWindowRect(handle,k1,k2,k3-k1,k4-k2)
                  self~ensureVisible
              end
      end

]]>
</programlisting>

</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthMinimize"><title>Minimize</title>
<indexterm><primary>Minimize</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Minimize----------------------------------------><


]]>
</programlisting>

<para>The <computeroutput>Minimize</computeroutput> method minimizes the dialog
to the taskbar.  This is the identical to the user clicking the minimize button
on the dialog window.  This method will minimize the dialog even if it does not
have the <computeroutput>MINIMIZEBOX</computeroutput> style when it is created.
</para>
<para>This is a convenience method.  It is functionally equivalent to using the
<link linkend=mthShowClsPlainBaseDialog>Show</link> method with the <computeroutput>MIN
</computeroutput> keyword.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The method takes no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Minimizing was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Minimizing failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>This example creates a secondary dialog to display the contents
of a file.  The secondary dialog is show full screen (maximized.)  At the same
time the parent dialog is minimized to the taskbar.  The complete program
listing is available (see the <link linkend="exampleFileViewer">File
Viewer</link> example.)

<programlisting>
<![CDATA[

::method onView
  expose viewDlg editCntrl

  fileName = editCntrl~getText
  viewDlg = .Viewer~new( , "fileView.h", self, fileName)
  if viewDlg~initCode = 0 then do
    self~disableItem(IDC_PB_VIEW)

    viewDlg~create(30, 30, 170, 180, "Viewer", "MAXIMIZEBOX MINIMIZEBOX")
    viewDlg~popUpAsChild(self, "HIDE", , IDI_DLG_APPICON)

    -- The underlying Windows dialog has to be created before it can be maximized.
    j = SysSleep(.1)

    viewDlg~maximize
    self~minimize
  end

]]>
</programlisting>

</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthMaximize"><title>Maximize</title>
<indexterm><primary>Maximize</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Maximize----------------------------------------><


]]>
</programlisting>

<para>The <computeroutput>Maximize</computeroutput> method maximizes the dialog
on the screen.  This is the identical to the user clicking the maximize button
on the dialog window.  This method will maximize the dialog even if it does not
have the <computeroutput>MAXIMIZEBOX</computeroutput> style when it is created.
</para>
<para>This is a convenience method.  It is functionally equivalent to using the
<link linkend=mthShowClsPlainBaseDialog>Show</link> method with the <computeroutput>MAX
</computeroutput> keyword.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The method takes no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Maximizing was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Maximizing failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following code snippet minimizes the dialog to the taskbar.
It is used in the FileViewer example.  The complete program listing is available
(see the <link linkend="exampleFileViewer">File Viewer</link> example.)

<programlisting>
<![CDATA[

::method onView
  expose viewDlg editCntrl

  ...

  if viewDlg~initCode = 0 then do
    ...

    viewDlg~maximize
    self~minimize
  end

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthRestore"><title>Restore</title>
<indexterm><primary>Restore</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Restore-----------------------------------------><


]]>
</programlisting>

<para>The <computeroutput>Restore</computeroutput> method restores a minimized
or maximized dialog to its original position.  This is the identical to the user
taking action to restore the dialog window.  The programmer can use this method
to restore a dialog window that he previously minimized or maximized.
</para>
<para>This is a convenience method.  It is functionally equivalent to using the
<link linkend=mthShowClsPlainBaseDialog>Show</link> method with the <computeroutput>RESTORE
</computeroutput> keyword.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The method takes no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Restoring was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Restoring failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example checks if the parent dialog is minimized
and, if it is, the <computeroutput>Restore</computeroutput> method is used to
show the dialog in the size and position it was prior to being minimized.  The
complete program listing for this code snippet is available (see the <link
linkend="exampleFileViewer">File Viewer</link> example.)

<programlisting>
<![CDATA[
::method cancel
  expose parent
  parent~enableItem(IDC_PB_VIEW)
  if parent~isMinimized then parent~restore
  return self~cancel:super

]]>
</programlisting>

</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthIsMinimized"><title>IsMinimized</title>
<indexterm><primary>IsMinimized</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~IsMinimized-------------------------------------><


]]>
</programlisting>

<para>The <computeroutput>IsMinimized</computeroutput> method is used to check
if a dialog is currently minimized.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The method takes no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>.true</term>
<listitem><para>The dialog is minimized.
</para></listitem></varlistentry>
<varlistentry><term>.false</term>
<listitem><para>The dialog is not minimized.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example checks if the parent dialog is minimized
and, if it is, the <computeroutput>Restore</computeroutput> method is used to
show the dialog in the size and position it was prior to being minimized.  The
complete program listing that this code snippet comes from is available (see the
<link linkend="exampleFileViewer">File Viewer
</link> example.)

<programlisting>
<![CDATA[
::method cancel
  expose parent
  parent~enableItem(IDC_PB_VIEW)
  if parent~isMinimized then parent~restore
  return self~cancel:super

]]>
</programlisting>

</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthIsMaximized"><title>IsMaximized</title>
<indexterm><primary>IsMaximized</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~IsMaximized-------------------------------------><


]]>
</programlisting>

<para>The <computeroutput>IsMaximized</computeroutput> method is used to check
if a dialog is currently maximized.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The method takes no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>.true</term>
<listitem><para>The dialog is maximized.
</para></listitem></varlistentry>
<varlistentry><term>.false</term>
<listitem><para>The dialog is not maximized.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following code snippet would check if the dialog is
maximized and, if it is, restore it to the position and size it was prior to
being maximized.

<programlisting>
<![CDATA[
  if self~isMaximized then self~restore

]]>
</programlisting>

</para></listitem></varlistentry>
</variablelist>
</section>

<section id="focusitem"><title>FocusItem</title>
<indexterm><primary>FocusItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~FocusItem(--id--)------------------------------><


]]>
</programlisting>

<para>The FocusItem method sets the input focus to a
particular dialog item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog item to set the focus to
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method always returns 1.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="tabtonext"><title>TabToNext</title>
<indexterm><primary>TabToNext</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~TabToNext--------------------------------------><


]]>
</programlisting>

<para>The TabToNext method sets the input focus to the next dialog control
with a tab stop.  This performs the same action as if the user pressed the
tab key in the dialog.  Like many of the other methods, TabToNext is a method
of both a BaseDialog and a DialogControl.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>The focus was changed, but the control with the previous focus
could not be determined.
</para></listitem></varlistentry>
<varlistentry><term>Other</term>
<listitem><para>The handle to the control with the previous focus.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="tabtoprevious"><title>TabToPrevious</title>
<indexterm><primary>TabToPrevious</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~TabToPrevious----------------------------------><


]]>
</programlisting>

<para>This method is the reverse of TabToNext and sets the input focus to
the previous dialog control with a tab stop.  This performs the same action
as if the user pressed the shift-tab key in the dialog.  TabToPrevious is a
method of both a BaseDialog and a DialogControl.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>The focus was changed, but the control with the previous focus
could not be determined.
</para></listitem></varlistentry>
<varlistentry><term>Other</term>
<listitem><para>The handle to the control with the previous focus.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthSetGroup"><title>SetGroup</title>
<indexterm><primary>SetGroup</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetGroup(--id--,--+-----------+--)---------------><
                                 +-wantStyle-+

]]>
</programlisting>

<para>Add or remove the <link linkend="wsgroup">group style</link> for the
specified control.  The group style controls how the user can navigate through
the dialog using the keyboard.  For most dialogs this does not change while the
dialog is executing.  However, in some dialogs the programmer may want to change
the navigation depending on the options the user selects.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The resource ID of the dialog control that will gain or lose the
group style.
</para></listitem></varlistentry>
<varlistentry><term>wantStyle</term>
<listitem><para>A boolean (.true or .false) to indicate whether the dialog
control should have or not have the group style.  True (the default) indicates
the control should have the group style and false indicates the control should
not have the style.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>Negative values indicate the function failed, non-negative
values indicate success.
<variablelist>
<varlistentry><term>-4 or less</term>
<listitem><para>The value is the negated Operating System Error code.  The
absolute value of the return can be used to look up the error reason in the
Windows documentation.
</para></listitem></varlistentry>
<varlistentry><term>-3</term>
<listitem><para>The second argument to the method is not a boolean.
</para></listitem></varlistentry>
<varlistentry><term>-2</term>
<listitem><para>There is an (internal) problem with the dialog or the dialog
handle.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>The resource ID of the control is not correct.
</para></listitem></varlistentry>
<varlistentry><term>0 or greater</term>
<listitem><para>The window style of the dialog control prior to adding or
removing the group style.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthSetTabStop"><title>SetTabStop</title>
<indexterm><primary>SetTabStop</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetTabStop(--id--,--+-----------+--)-------------><
                                   +-wantStyle-+

]]>
</programlisting>

<para>Add or remove the <link linkend="wstabstop">tab stop style</link> for the
specified control.  When  a control has the tabstop style, the user can set the
focus to the control by using the tab key.  When a control does not have this
style, the tab key will skip over the control.  Adding or removing this style
during the execution of a dialog allows the programmer to alter how the user
navigates through the dialog controls.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The resource ID of the dialog control that will gain or lose the
tabstop style.
</para></listitem></varlistentry>
<varlistentry><term>wantStyle</term>
<listitem><para>A boolean (.true or .false) to indicate whether the dialog
control should have or not have the tabstop style.  True (the default) indicates
the control should have the tabstop style and false indicates the control should
not have the style.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>Negative values indicate the function failed, non-negative
values indicate success.
<variablelist>
<varlistentry><term>-4 or less</term>
<listitem><para>The value is the negated Operating System Error code.  The
absolute value of the return can be used to look up the error reason in the
Windows documentation.
</para></listitem></varlistentry>
<varlistentry><term>-3</term>
<listitem><para>The second argument to the method is not a boolean.
</para></listitem></varlistentry>
<varlistentry><term>-2</term>
<listitem><para>There is an (internal) problem with the dialog or the dialog
handle.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>The resource ID of the control is not correct.
</para></listitem></varlistentry>
<varlistentry><term>0 or greater</term>
<listitem><para>The window style of the dialog control prior to adding or
removing the tabstop style.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001221"><title>EnableItem</title>
<indexterm><primary>EnableItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~EnableItem(--id--)-----------------------------><


]]>
</programlisting>

<para>The EnableItem method enables the given dialog
item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the item
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001229"><title>DisableItem</title>
<indexterm><primary>DisableItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DisableItem(--id--)----------------------------><


]]>
</programlisting>

<para>The DisableItem method disables the given dialog
item. A disabled dialog item is usually indicated by a gray instead of a black
title or text; it cannot be changed by the user. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the item
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthHideItem"><title>HideItem</title>
<indexterm><primary>HideItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~HideItem(--id--)-------------------------------><


]]>
</programlisting>

<para>The HideItem method makes the given item disappear
from the screen and thus unavailable to the user. In fact, the item is still
in the dialog and you can transfer its data. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the item
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001285"><title>HideItemFast</title>
<indexterm><primary>HideItemFast</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~HideItemFast(--id--)---------------------------><


]]>
</programlisting>

<para>The HideItemFast method hides an item without redrawing
its area. It is similar to the <link linkend="mthHideItem">HideItem</link> method,
but it is faster because the item's area is not redrawn. The HideItemFast method is used when more than one item state is modified.
After the operations, you can manually redraw the dialog window, using the <link linkend="mthUpdate">update</link> method. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the item
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthShowItem"><title>ShowItem</title>
<indexterm><primary>ShowItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ShowItem(--id--)-------------------------------><


]]>
</programlisting>

<para>The ShowItem method makes the given dialog item
reappear on the screen. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the item
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001293"><title>ShowItemFast</title>
<indexterm><primary>ShowItemFast</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ShowItemFast(--id--)---------------------------><


]]>
</programlisting>

<para>The ShowItemFast method shows an item without redrawing
its area. It is the counterpart to the <link linkend="h001285">HideItemFast</link> method.</para>
</section>

<section id="h001253"><title>HideWindow</title>
<indexterm><primary>HideWindow</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~HideWindow(--hwnd--)---------------------------><


]]>
</programlisting>

<para>The HideWindow method hides a whole dialog window
or a dialog item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>A handle to the window or dialog item. Use the <link
linkend="mthGetSelf">getSelf</link> or <link linkend="mthGetItem">GetItem</link>
method to get a handle.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example gets the window handle of the top dialog
(which is not necessarily the executing dialog, see the <link
linkend="h000086">Get</link> method) and hides the whole dialog:

<programlisting>
<![CDATA[
hwnd = MyDialog~Get
MyDialog~HideWindow(hwnd)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001261"><title>HideWindowFast</title>
<indexterm><primary>HideWindowFast</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~HideWindowFast(--hwnd--)-----------------------><


]]>
</programlisting>

<para>The HideWindowFast method is similar to the <link linkend="h001253">HideWindow</link> method, but it is faster because the window's
or item's area is not redrawn. The HideWindowFast method
is used when more than one state is modified. After the operations, you can
manually redraw the dialog window, using the <link linkend="mthUpdate">update</link> method. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>A handle to the window or dialog item
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001269"><title>ShowWindow</title>
<indexterm><primary>ShowWindow</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ShowWindow(--hwnd--)---------------------------><


]]>
</programlisting>

<para>The ShowWindow method shows the window or item
again. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of a window or an item
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001277"><title>ShowWindowFast</title>
<indexterm><primary>ShowWindowFast</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ShowWindowFast(--hwnd--)-----------------------><


]]>
</programlisting>

<para>The ShowWindowFast method is the counterpart to
the <link linkend="h001261">HideWindowFast</link> method.</para>
</section>

<section id="mthSetWindowRect"><title>SetWindowRect</title>
<indexterm><primary>SetWindowRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetWindowRect(--hwnd--,--x--,--y--,--width--,--height-->

>--+-----------------------------+--)--------------------------------><
   |       +----------------+    |
   |       V                |    |
   +-,--"----+-NOMOVE-----+-+--"-+
             +-NOSIZE-----+
             +-HIDEWINDOW-+
             +-SHOWWINDOW-+
             +-NOREDRAW---+


]]>
</programlisting>

<para>The SetWindowRect method sets new coordinates for
a specific window. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to the dialog that is to be repositioned.
</para></listitem></varlistentry>
<varlistentry><term>x, y</term>
<listitem><para>The new position of the upper left corner, in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>width</term>
<listitem><para>The new width of the window, in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>height</term>
<listitem><para>The new height of the window, in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>showOptions</term>
<listitem><para>This argument can be one or more of the following keywords, separated
by blanks:
<variablelist>
<varlistentry><term>NOMOVE</term>
<listitem><para>The upper left position of the window has not changed.
</para></listitem></varlistentry>
<varlistentry><term>NOSIZE</term>
<listitem><para>The size of the window has not changed.
</para></listitem></varlistentry>
<varlistentry><term>HIDEWINDOW</term>
<listitem><para>The window is to be made invisible.
</para></listitem></varlistentry>
<varlistentry><term>SHOWWINDOW</term>
<listitem><para>The window is to be made visible.
</para></listitem></varlistentry>
<varlistentry><term>NOREDRAW</term>
<listitem><para>The window is to be repositioned without redrawing it.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Repositioning was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Repositioning failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="redrawwindow"><title>RedrawWindow</title>
<indexterm><primary>RedrawWindow</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~RedrawWindow(--hwnd--)-------------------------><


]]>
</programlisting>

<para>The RedrawWindow method redraws a specific dialog. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to the dialog that is to be redrawn.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Redrawing was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Redrawing failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001301"><title>ResizeItem</title>
<indexterm><primary>ResizeItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ResizeItem(--id--,--width--,--height--+-------------------------+--)-><
                                                     +-,--"--+-HIDEWINDOW-+--"-+
                                                             +-SHOWWINDOW-+
                                                             +-NOREDRAW---+


]]>
</programlisting>

<para>The ResizeItem method changes the size of a dialog
item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog item you want to resize
</para></listitem></varlistentry>
<varlistentry><term>width, height</term>
<listitem><para>The new size in dialog units
</para></listitem></varlistentry>
<varlistentry><term>showOptions</term>
<listitem><para>This argument can be one of the following keywords:
<variablelist>
<varlistentry><term>HIDEWINDOW</term>
<listitem><para>Hides the item
</para></listitem></varlistentry>
<varlistentry><term>SHOWWINDOW</term>
<listitem><para>Shows the item
</para></listitem></varlistentry>
<varlistentry><term>NOREDRAW</term>
<listitem><para>Resizes the item without updating the display. Use the <link linkend="mthUpdate">update</link> method to manually update the display.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example resizes a dialog item:

<programlisting>
<![CDATA[
MyDialog~ResizeItem(123, 40, 30, "SHOWWINDOW")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001322"><title>MoveItem</title>
<indexterm><primary>MoveItem</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~MoveItem(--id--,--xPos--,--yPos--+-------------------------+--)-><
                                                +-,--"--+-HIDEWINDOW-+--"-+
                                                        +-SHOWWINDOW-+
                                                        +-NOREDRAW---+


]]>
</programlisting>

<para>The MoveItem method moves a dialog item to another
position within the dialog window. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog item you want to move
</para></listitem></varlistentry>
<varlistentry><term>xPos, yPos</term>
<listitem><para>The new position in dialog units relative to the dialog window
</para></listitem></varlistentry>
<varlistentry><term>showOptions</term>
<listitem><para>This argument can be one of the following keywords:
<variablelist>
<varlistentry><term>HIDEWINDOW</term>
<listitem><para>Hides the dialog
</para></listitem></varlistentry>
<varlistentry><term>SHOWWINDOW</term>
<listitem><para>Shows the dialog
</para></listitem></varlistentry>
<varlistentry><term>NOREDRAW</term>
<listitem><para>Moves the dialog item without updating the display. Use the <link linkend="mthUpdate">update</link> method
to manually update the display.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001370"><title>Center</title>
<indexterm><primary>Center</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Center(--"--+-HIDEWINDOW-+--"--)---------------><
                           +-SHOWWINDOW-+
                           +-NOREDRAW---+


]]>
</programlisting>

<para>The Center method moves the dialog to the screen
center. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument can be one of:
<variablelist>
<varlistentry><term>HIDEWINDOW</term>
<listitem><para>Hides the dialog
</para></listitem></varlistentry>
<varlistentry><term>SHOWWINDOW</term>
<listitem><para>Shows the dialog
</para></listitem></varlistentry>
<varlistentry><term>NOREDRAW</term>
<listitem><para>Center the dialog without updating the display. Use the <link linkend="mthUpdate">update</link> method
to manually update the display.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthGetControlText"><title>getControlText</title>
<indexterm><primary>getControlText</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>getControlText</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getControlText(--id--)-------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">getControlText</emphasis> method gets the text of the specified dialog control.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
    <para>
      Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>The only argument is:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The text of the dialog control, which may be the empty string.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    All windows can have text associated with them, although some times it is simply the empty string. For different
    types of windows the text serves different purposes and is called various things. For buttons the text is often
    called labels, for dialogs and main windows the text is often called the window title.
  </para>
  <para>
    If the empty string is returned, the programmer can check the <emphasis role="italic">.SystemErrorCode</emphasis>
    for error.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthSetControlText"><title>setControlText</title>
<indexterm><primary>setControlText</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>setControlText</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getControlText(--id--,--text--)-------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">setControlText</emphasis> method sets the text of the specified dialog control to that
  specified.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
    <para>
      Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>text [required]</term>
    <listitem>
    <para>
      The new text for the dialog control.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return codes can be:
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      Success
    </para>
    </listitem></varlistentry>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      Error.
     </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    All windows can have text associated with them, although some times it is simply the empty string. For different
    types of windows the text serves different purposes and is called various things. For buttons the text is often
    called labels, for dialogs and main windows the text is often called the window title.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="h000246"><title>SetWindowTitle</title>
<indexterm><primary>SetWindowTitle</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetWindowTitle(--hwnd--,--aString--)-----------><


]]>
</programlisting>

<para>The SetWindowTitle method changes the title of
a window. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of the window whose title you want to change
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The new title text
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="exampleFileViewer"><title>FileViewer Example Program</title>
<indexterm><primary>FileViewer.rex</primary>
<secondary>example code</secondary></indexterm>

<para>The FileViewer program is a complete working program that uses many of the
methods of the base dialog.  Portions of this program are presented as examples
in the documentation for these methods. The complete program is shown here as a
reference to how the code snippets all fit together.
</para>
<para>The documentation for the individual methods used in the program has
additional commentary that will help in understanding how the program works.
<itemizedlist>
<listitem>
<para>
  <link linkend="mthNewDialogObject">new</link>: This program uses a header file,
  <computeroutput>fileView.h</computeroutput> to define symbolic IDs for the dialog controls. The name of the file is one
  of the arguments used to create a new instance of a dialog object. (As in all Rexx classes, the arguments used in the
  <emphasis role="italic">new</emphasis> method are passed on to the <emphasis role="italic">init</emphasis> method of
  the class.)
</para>
</listitem>
<listitem><para><link linkend="mthExecute">execute</link>: Two dialogs are created
in the example.  The first dialog allows the user to enter the name of a file to
view.  Then the file itself is displayed in a second dialog.  Each dialog uses a
different application icon. The <computeroutput>execute</computeroutput> method
documentation has more detail on the application icon.
</para></listitem>
<listitem><para><link linkend="mthInitDialog">InitDialog</link> This method is called
after the underlying Windows dialog has been created, but before it is shown on
the screen.  In the viewer dialog the <computeroutput>init</computeroutput>
method is overridden and the text of the read-only multi-line edit control is
set to the contents of the file.  In both dialogs, this method is used to get
and save a reference to the edit control of the dialog.
</para></listitem>
<listitem><para><link linkend="h001229">DisableItem</link>: When the user clicks
the &quot;View File&quot; button, the button is disabled until the user is
finished viewing the file.  When a button is disabled it can not be clicked by
the user.
</para></listitem>
<listitem><para><link linkend="h001221">EnableItem</link>: When the user closes
the secondary viewer dialog, the &quot;View File&quot; button is enabled so the
user can choose to view another file.
</para></listitem>
<listitem><para><link linkend="mthPopupAsChild">popupAsChild</link>: The viewer
dialog is executed using this method so that both dialogs run independently,
both dialogs stay enabled.  The <computeroutput>HIDE</computeroutput> keyword is
used for the show argument.  This creates the dialog as invisible and prevents
unnecessary screen flicker.
</para></listitem>
<listitem><para><link linkend="mthMaximize">Maximize</link>: Note that there is
a 100 millisecond sleep right before the <computeroutput>Maximize method
</computeroutput> is invoked.  This allows Windows to finish creating the
dialog.  The <computeroutput>InitDialog</computeroutput> method will have
already finished executing and the contents of the file are loaded into the
multi-line edit control.  Then, <computeroutput>Maximize</computeroutput>
resizes the dialog to take up the whole screen and shows it.  The dialog appears
on the user's screen, with the file displayed, in one screen drawing.  This
reduces the flicker on the screen.
</para></listitem>
<listitem><para><link linkend="mthMinimize">Minimize</link>: When the viewer
dialog is maximized, the main dialog is minimized to the task bar.
</para></listitem>
<listitem><para><link linkend="mthInitAutoDetection">initAutoDetection</link>:
Because the contents of the file are loaded into the multi-line edit control
during <computeroutput>InitDialog</computeroutput>, auto detection must be
turned off.  Otherwise, after <computeroutput>InitDialog</computeroutput>
finishes executing, auto detection would set the empty string as the text for
the control.  The program overrides this method to turn auto detection off.
</para></listitem>
<listitem><para><link linkend="mthNoAutoDetection">noAutoDetection</link>: Used
in turning auto detection off.
</para></listitem>
<listitem><para><link linkend="mthConnectResize">connectResize</link>: When the
viewer dialog is resized, the <computeroutput>onSize</computeroutput> method is
invoked.  The size of the multi-line edit control is then changed so it
completely takes up the client area of the dialog.  (The client area of a window
is where all the child windows are drawn.  In this case the edit control is the
only child window.)  Since the dialog is not resizeable by the user (it does not
have a sizing border) the only time the size can change is when the dialog is
maximized, minimized, or restored.
</para></listitem>
<listitem><para><link linkend="mthHideItem">HideItem</link>: The edit control in
the viewer dialog is created invisible.  Again, this helps reduce flicker.
</para></listitem>
<listitem><para><link linkend="mthGetItem">GetItem</link>: The window handle of
the edit control is obtained by this method ...
</para></listitem>
<listitem><para><link linkend="mthGetClientRect">GetClientRect</link>: ... then
the size of the client area of the viewer dialog is obtained using this method.
Then ..
</para></listitem>
<listitem><para><link linkend="mthSetWindowRect">SetWindowRect</link>: ... the
size of the edit control window is set using to the size of the dialog's client
area.
</para></listitem>
<listitem><para><link linkend="mthShowItem">ShowItem</link>: The
<computeroutput>ShowItem</computeroutput> method is used to make the edit
control visible when the dialog is initially shown.
</para></listitem>
<listitem><para><link linkend="mthIsMinimized">IsMinimized</link>: When the
viewer dialog is closed, this method checks to see if the main dialog is still
minimized.  Since the dialogs run independently the user may have already
restored this dialog.
</para></listitem>
<listitem><para><link linkend="mthRestore">Restore</link>: If the main dialog is
still minimized, then this method restores it to its normal position.
</para></listitem>
</itemizedlist>
</para>

<programlisting>
<![CDATA[

/* fileView.h  Simple symbolic ID definitions  */

#define IDD_DIALOG1          100
#define IDC_ST_TYPE          105
#define IDC_ENTRYLINE        106
#define IDC_MULTILINE        107
#define IDC_PB_VIEW          111

/* FileViewer.rex  Simple Dialog to view files full screen */

  dlg = .FileView~new( , "fileView.h")
  if dlg~initCode = 0 then do
    dlg~createCenter(170, 90, "The File Viewer Dialog", "VISIBLE MAXIMIZEBOX MINIMIZEBOX")
    dlg~execute("SHOWTOP", IDI_DLG_OOREXX)
  end

-- End of entry point.
::requires "OODWin32.cls"

::class FileView subclass UserDialog inherit AdvancedControls

::method defineDialog

  self~createStaticText(IDC_ST_TYPE, 10, 25, 150, 10, "", " Enter the name of a file to view:")
  self~addEntryLine(IDC_ENTRYLINE, , 10, 35, 150, 10, "AUTOSCROLLH")

  -- When the view button is pushed, another dialog will show the file.
  self~createPushButton(IDC_PB_VIEW, 10, 55, 35, 15, "DEFAULT GROUP", "View File", onView)
  self~createPushButton(IDOK, 130, 55, 35, 15, , "Quit")

::method initDialog
  expose editCntrl
  editCntrl = self~newEdit(IDC_ENTRYLINE)

::method onView
  expose viewDlg editCntrl

  fileName = editCntrl~getText
  viewDlg = .Viewer~new( , "fileView.h", self, fileName)
  if viewDlg~initCode = 0 then do
    self~disableItem(IDC_PB_VIEW)

    viewDlg~create(30, 30, 170, 180, "Viewer", "MAXIMIZEBOX MINIMIZEBOX")
    viewDlg~popUpAsChild(self, "HIDE", , IDI_DLG_APPICON)

    -- The underlying Windows dialog has to be created before it can be maximized.
    j = msSleep(100)

    viewDlg~maximize
    self~minimize
  end

::class 'Viewer' subclass UserDialog inherit AdvancedControls

::method init
  expose parent filename
  use arg data, header, parent, fileName
  forward class (super)

::method initAutoDetection
  self~noAutoDetection

::method defineDialog
  expose wasMinimized

  wasMinimized = .false
  style = "VSCROLL HSCROLL MULTILINE READONLY"
  self~addEntryLine(IDC_MULTILINE, "cEntry", 0, 0, 170, 180, style)
  self~connectResize("onSize")

::method initDialog
  expose editControl fileName isHidden

  self~hideItem(IDC_MULTILINE)
  isHidden = .true

  editControl = self~newEdit(IDC_MULTILINE)
  fObj = .stream~new(fileName)
  text = fObj~charin(1, fObj~chars)
  fObj~close
  if text == "" then text = "   No file  "
  editControl~setText(text)

::method onSize
  expose wasMinimized
  use arg sizeEvent sizeInfo

  if sizeEvent = 1 then wasMinimized = .true

  if sizeEvent = 0 |  sizeEvent = 2 then do
    if \ wasMinimized then self~resizeEditControl
    wasMinimized = .false
  end

::method resizeEditControl
  expose editControl isHidden

  hWnd = self~getItem(IDC_MULTILINE)
  parse value self~getClientRect with wx wy wcx wcy

  self~setWindowRect(hWnd, 0, 0, wcx, wcy)

  if isHidden then do
    self~showItem(IDC_MULTIINE)
    isHidden = .false
  end

::method cancel
  expose parent
  parent~enableItem(IDC_PB_VIEW)
  if parent~isMinimized then parent~restore
  return self~cancel:super

]]>
</programlisting>
</section>

</section>

<section id="man0016"><title>Window draw Methods</title>
<indexterm><primary>draw methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<para>The methods listed below are used to draw, redraw, and clear window areas.</para>

<section id="h000606"><title>DrawButton</title>
<indexterm><primary>DrawButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DrawButton(--id--)-----------------------------><


]]>
</programlisting>

<para>The DrawButton method draws the given button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000653"><title>RedrawRect</title>
<indexterm><primary>RedrawRect</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
                                                                               +-0--------+
>>-aBaseDialog~RedrawRect(--+------+--,--left--,--top--,--right--,--bottom--,--+----------+--)-><
                            +-hwnd-+                                           +-erasebkg-+


]]>
</programlisting>

<para>The RedrawRect method immediately redraws a rectangle
within the client area of a dialog. You can specify whether the background
of the dialog is to be erased before redrawing. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to the dialog in which parts of the client area are to be
redrawn. See <link linkend="h000086">Get</link> or <link linkend="mthGetItem">GetItem</link> for
information on how to get a window handle. If you omit this argument, the
handle of the dialog instance is used.
</para></listitem></varlistentry>
<varlistentry><term>left, top</term>
<listitem><para>The upper left corner of the rectangle relative to the client area,
in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>right, bottom</term>
<listitem><para>The lower right corner of the rectangle relative to the client area,
in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>erasebkg</term>
<listitem><para>If this argument is 1 or 0, the background of the dialog is erased before
redrawing. The default is 0.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Redrawing was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Redrawing failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000684"><title>RedrawButton</title>
<indexterm><primary>RedrawButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~RedrawButton(--id--+-------------+--)----------><
                                  +-,--erasebkg-+


]]>
</programlisting>

<para>The RedrawButton method redraws the given button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
<varlistentry><term>erasebkg</term>
<listitem><para>Determines whether (1) or not (0) the background of the drawing area
should be erased before redrawing. The default is 0.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000693"><title>RedrawWindowRect</title>
<indexterm><primary>RedrawWindowRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~RedrawWindowRect--+-----------------------------+--><
                                 +-(--hwnd--+-------------+--)-+
                                            +-,--erasebkg-+


]]>
</programlisting>

<para>The RedrawWindowRect method redraws the given window
rectangle. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to the window. See <link linkend="h000086">Get</link>
or <link linkend="mthGetItem">GetItem</link> for information on how to get a window
handle. If you omit this argument, the handle of the dialog instance is used.
</para></listitem></varlistentry>
<varlistentry><term>erasebkg</term>
<listitem><para>Determines whether (1) or not (0) the background of the
drawing area should be erased before redrawing. The default is 0.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000640"><title>ClearRect</title>
<indexterm><primary>ClearRect</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ClearRect(--hwnd--,--left--,--top--,--right--,--bottom--)--><


]]>
</programlisting>

<para>The ClearRect method clears the given rectangle
of a window. The values are in pixels. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of the window. See <link
linkend="mthGetSelf">getSelf</link> or <link linkend="mthGetItem">GetItem</link>
for information on obtaining a window handle.
</para></listitem></varlistentry>
<varlistentry><term>left</term>
<listitem><para>The horizontal value of the upper-left corner of the rectangle
</para></listitem></varlistentry>
<varlistentry><term>top</term>
<listitem><para>The vertical value of the upper left corner
</para></listitem></varlistentry>
<varlistentry><term>right</term>
<listitem><para>The horizontal value of the lower right corner
</para></listitem></varlistentry>
<varlistentry><term>bottom</term>
<listitem><para>The vertical value of the lower right corner
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example clears a rectangle of the size 20 by 20:

<programlisting>
<![CDATA[
hwnd=MyDialog~getSelf
MyDialog~ClearRect(hwnd, 2, 4, 22, 24)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000622"><title>ClearButtonRect</title>
<indexterm><primary>ClearButtonRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ClearButtonRect(--id--)------------------------><


]]>
</programlisting>

<para>The ClearButtonRect method erases the draw area
of the given button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the push button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000631"><title>ClearWindowRect</title>
<indexterm><primary>ClearWindowRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ClearWindowRect(--hwnd--)----------------------><


]]>
</programlisting>

<para>The ClearWindowRect method erases the draw area
of the given window. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of the window. See <link
linkend="mthGetSelf">getSelf</link>, <link linkend="h000086">Get</link>, or
<link linkend="mthGetItem">GetItem</link> for some methods to get a window handle.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example gets the window handle of a dialog control
with resource ID of 211 and then clears the dialog control window:

<programlisting>
<![CDATA[
hwnd = MyDialog~GetItem(211)
MyDialog~ClearWindowRect(hwnd)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="sctBitmapMethods"><title>Bitmap Methods</title>
<indexterm><primary>bitmap methods</primary></indexterm>
<para>The methods listed in this section deal with using bitmaps.</para>

<section id="mthInstallBitmapButton"><title>installBitmapButton</title>
<indexterm><primary>installBitmapButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~installBitmapButton(--id--,--+------------+--,--bmpNormal-->
                                            +-msgToRaise-+

>--+----------------------------------------------------------------------------+--)-><
   +-,--bmpFocused--+---------------------------------------------------------+-+
                    +-,--bmpSelected--+-------------------------------------+-+
                                      +-,--bmpDisabled--+-----------------+-+
                                                        +-,--styleOptions-+


]]>
</programlisting>

<para>The installBitmapButton method connects a bitmap
and a method with a push button. The given bitmaps are displayed instead of
a Windows push button.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button.
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent to this object when the button is clicked.
</para></listitem></varlistentry>
<varlistentry><term>bmpNormal</term>
<listitem><para>The name (alphanumeric), resource ID (numeric), or handle (<emphasis role="italic">INMEMORY</emphasis> option) of a bitmap file. This bitmap is displayed when the button is
not selected, not focused, and not disabled. It is used for the other button
states in case the other arguments are omitted.
</para></listitem></varlistentry>
<varlistentry><term>bmpFocused</term>
<listitem><para>This bitmap is displayed when the button is focused. The focused button
is activated when the Enter key is pressed.
</para></listitem></varlistentry>
<varlistentry><term>bmpSelected</term>
<listitem><para>This bitmap is displayed while the button is clicked and held.
</para></listitem></varlistentry>
<varlistentry><term>bmpDisabled</term>
<listitem><para>This bitmap is displayed when the button is disabled.
</para></listitem></varlistentry>
<varlistentry><term>styleOptions</term>
<listitem><para>One of the following keywords:
<variablelist>
<varlistentry><term>FRAME</term>
<listitem><para>Draws a frame around the button.  When using this option, the bitmap
button behaves like a normal Windows button, except that a bitmap is
shown instead of a text.
</para></listitem></varlistentry>
<varlistentry><term>USEPAL</term>
<listitem><para>Stores the colors of the bitmap file as the system color palette.  This
option is needed when the bitmap was created with a palette other than the
default Windows color palette. Use it for one button only,
because only one color palette can be active at any time. <emphasis role="italic">USEPAL</emphasis> is
invalid for a bitmap loaded from a DLL.
</para></listitem></varlistentry>
<varlistentry><term>INMEMORY</term>
<listitem><para>This option must be used if the named bitmaps are already loaded into
memory by using the <link linkend="h000667">LoadBitmap</link> method. In this case, bmpNormal, bmpFocused, bmpSelected, and bmpDisabled specify a bitmap handle instead of a file.
</para></listitem></varlistentry>
<varlistentry><term>STRETCH</term>
<listitem><para>If this option is specified and the extent of the bitmap is smaller
than the extent of the button rectangle, the bitmap is adapted to match the
extent of the button. STRETCH has no effect for bitmaps
loaded through a DLL.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example connects a button with four bitmaps and a method:

<programlisting>
<![CDATA[
      .
      .
      .
::method initDialog
  self~installBitmapButton(204, "BmpButtonClicked", ,
                           "AddBut_n.bmp", "AddBut_f.bmp", ,
                           "AddBut_s.bmp", "AddBut_d.bmp", "FRAME")
::method BmpButtonClicked
      .
      .
      .
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
<para>See also method <link linkend="h000170">ChangeBitmapButton</link>.</para>
</section>

<section id="h000170"><title>ChangeBitmapButton</title>
<indexterm><primary>ChangeBitmapButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ChangeBitmapButton(--id--,--bmpNormal----------------------->

>--+--------------------------------------------------------------------+-->
   +-,bmpFocused--+---------------------------------------------------+-+
                  +-,bmpSelected--+---------------------------------+-+
                                  +-,bmpDisabled--+---------------+-+
                                                  +-,styleOptions-+

>--)----------------------------------------------------------------------><


]]>
</programlisting>

<para>The ChangeBitmapButton method changes the bitmaps
of a bitmap button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are the same as for <link linkend="mthInstallBitmapButton">installBitmapButton</link>,
except for the first argument (msgToRaise), which is skipped in this method.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example replaces the current bitmap with a new
bitmap:

<programlisting>
<![CDATA[
MyDialog~ChangeBitmapButton(501, "NewBB.bmp")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001127"><title>GetBitmapSizeX</title>
<indexterm><primary>GetBitmapSizeX</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetBitmapSizeX(--id--)-------------------------><


]]>
</programlisting>

<para>The GetBitmapSizeX method returns the horizontal
bitmap extension. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the bitmap button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001135"><title>GetBitmapSizeY</title>
<indexterm><primary>GetBitmapSizeY</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetBitmapSizeY(--id--)-------------------------><


]]>
</programlisting>

<para>The GetBitmapSizeY method returns the vertical
bitmap extension. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the bitmap button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001143"><title>DrawBitmap</title>
<indexterm><primary>DrawBitmap</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DrawBitmap(--+------+--,--id---------------------->
                            +-hwnd-+

>--+----------------------------------------------------------+-->
   +-,--px--,--py--+----------------------------------------+-+
                   +-,--srcx--,--srcy--+------------------+-+
                                       +-,--xlen--,--ylen-+

>--)------------------------------------------------------------><


]]>
</programlisting>

<para>The DrawBitmap method draws the bitmap of a button.
You can also use this method to move a bitmap or a part of it. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to the window.  If this argument is omitted, the handle for
the button is used automatically.
</para></listitem></varlistentry>
<varlistentry><term>id</term>
<listitem><para>The ID of the button that has the owner-draw option set
</para></listitem></varlistentry>
<varlistentry><term>px, py</term>
<listitem><para>The upper-left corner of the target space within the button (default
is 0)
</para></listitem></varlistentry>
<varlistentry><term>srcx, srcy</term>
<listitem><para>The upper-left corner within the bitmap (default is 0)
</para></listitem></varlistentry>
<varlistentry><term>xlen, yLen</term>
<listitem><para>The extension of the bitmap or a part of it (default is the whole bitmap)
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001172"><title>ScrollBitmapFromTo</title>
<indexterm><primary>ScrollBitmapFromTo</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ScrollBitmapFromTo(--id--,--fromX--,--fromY--,--toX--,--toY--,-->

>--stepX--,--stepY--,--delay--,--displace--)------------------><


]]>
</programlisting>

<para>The ScrollBitmapFromTo method scrolls a bitmap
from one position to another within an owner-drawn button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
<varlistentry><term>fromX, fromY</term>
<listitem><para>The starting position
</para></listitem></varlistentry>
<varlistentry><term>toX, toY</term>
<listitem><para>The target position
</para></listitem></varlistentry>
<varlistentry><term>stepX, stepY</term>
<listitem><para>The width of one step
</para></listitem></varlistentry>
<varlistentry><term>delay</term>
<listitem><para>The time in milliseconds this method waits after each move before doing
the next move. This determines the speed at which the bitmap moves.
</para></listitem></varlistentry>
<varlistentry><term>displace</term>
<listitem><para>If set to 1 the internal position of the bitmap (bitmap displacement)
is updated after each incremental move. <link linkend="h000726">DisplaceBitmap</link> is
called after each step to adjust the bitmap position.  If the dialog is redrawn,
the bitmap is shown at the correct position, but the drawing is slower.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001045"><title>TiledBackgroundBitmap</title>
<indexterm><primary>TiledBackgroundBitmap</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~TiledBackgroundBitmap(--bmpFilename--)---------><


]]>
</programlisting>

<para>The TiledBackgroundBitmap method sets a bitmap
as the background brush (<trademark class="registered">Windows NT</trademark> only). If the bitmap size is
less than the size of the background, the bitmap is drawn repetitively. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>bmpFilename</term>
<listitem><para>The name of a bitmap file
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001053"><title>BackgroundBitmap</title>
<indexterm><primary>BackgroundBitmap</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~BackgroundBitmap(--bmpFilename------------------->

>--+-------------+--)------------------------------------------><
   +-,--"USEPAL"-+


]]>
</programlisting>

<para>The BackgroundBitmap method sets a bitmap as the
dialog's background picture. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>bmpFilename</term>
<listitem><para>The name of a bitmap file
</para></listitem></varlistentry>
<varlistentry><term>option</term>
<listitem><para>Set the last argument to USEPAL if you want
to use the color palette of the bitmap. See <link linkend="mthInstallBitmapButton">installBitmapButton</link> for more
information.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000726"><title>DisplaceBitmap</title>
<indexterm><primary>DisplaceBitmap</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DisplaceBitmap(--id--,--x--,--y--)-------------><


]]>
</programlisting>

<para>The DisplaceBitmap method sets the position of
a bitmap within a button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of a button
</para></listitem></varlistentry>
<varlistentry><term>x</term>
<listitem><para>The horizontal displacement in screen pixels. A negative value can be
used.
</para></listitem></varlistentry>
<varlistentry><term>y</term>
<listitem><para>The vertical displacement (negative allowed)
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example moves the bitmap within a button
four screen pixels to the right and three pixels upward:

<programlisting>
<![CDATA[
MyBaseDialog~DisplaceBitmap(244, 4, -3)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000737"><title>GetBmpDisplacement</title>
<indexterm><primary>GetBmpDisplacement</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetBmpDisplacement(--id--)---------------------><


]]>
</programlisting>

<para>The GetBmpDisplacement method gets the position
of a bitmap within a button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example shows how to use the <link linkend="h000703">GetButtonRect</link> and <link linkend="h000737">GetBmpDisplacement</link> methods:

<programlisting>
<![CDATA[
bRect = MyBaseDialog~GetButtonRect(244)
parse var bRect left top right bottom
bmpPos = MyBaseDialog~GetBmpDisplacement(244)
parse var bmpPos x y
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthAddAutoStartMethod"><title>addAutoStartMethod</title>
<indexterm><primary>addAutoStartMethod</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~addAutoStartMethod(--+---------+--,--MethodName--+---------------+--)-><
                                    +-InClass-+                 +-,--Parameters-+


]]>
</programlisting>

<para>The addAutoStartMethod method adds a method name
and parameters to a special internal queue. All methods in this queue will
be started automatically and run concurrently when the dialog is executed.
The given method (MethodName) in the given class (InClass) is started concurrently with the dialog when
the dialog is activated using the <link linkend="mthExecute">execute</link> or <link linkend="mthExecuteAsync">executeAsync</link> method. This is useful for processing animated
buttons. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>InClass</term>
<listitem><para>The class where the method is defined. If this argument is omitted,
the method is assumed to be defined in the dialog class.
</para></listitem></varlistentry>
<varlistentry><term>MethodName</term>
<listitem><para>The name of the method
</para></listitem></varlistentry>
<varlistentry><term>Parameters</term>
<listitem><para>All parameters that are passed to this method
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example installs the ExecuteB method
of the MyAnimatedButton class so that it is processed
concurrently with the dialog execution:

<programlisting>
<![CDATA[
MyDialog~addAutoStartMethod("MyAnimatedButton", "ExecuteB")

::class MyAnimatedButton
::method ExecuteB
     .
     .
     .
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthInstallAnimatedButton"><title>installAnimatedButton</title>
<indexterm><primary>installAnimatedButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~installAnimatedButton(--id,--+------------+--,--->
                                            +-msgToRaise-+

>--+-----------+--,--bmpFrom--,--+-------+--,--moveX--,--moveY--,-->
   +-AutoClass-+                 +-bmpTo-+

>--+-------+--,--+-------+--,--delay--,--+------+--,--+------+--)-><
   +-sizeX-+     +-sizeY-+               +-xNow-+     +-yNow-+


]]>
</programlisting>

<para>The installAnimatedButton method installs an animated
button and runs it concurrently with the main activity. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The name of a method within the same class. This method is called each
time the button is clicked.
</para></listitem></varlistentry>
<varlistentry><term>AutoClass</term>
<listitem><para>The class that controls the animation (default is <link linkend="anibut">AnimatedButton Class</link>)
</para></listitem></varlistentry>
<varlistentry><term>bmpFrom</term>
<listitem><para>The ID of the first bitmap in the animation sequence within a binary
resource. It can also be the name of an array stored in the .local directory
containing handles of bitmaps to be animated and bmpTo is omitted. See <link linkend="h000667">LoadBitmap</link> for how to get bitmap
handles. The array starts at index 1.
</para></listitem></varlistentry>
<varlistentry><term>bmpTo</term>
<listitem><para>The ID of the last bitmap in the animation sequence within a binary
resource. If omitted, bmpFrom is expected to be the
name of an array stored in .local that holds the bitmap handles of the bitmaps
that are to be animated.
</para></listitem></varlistentry>
<varlistentry><term>moveX, moveY</term>
<listitem><para>Size of one move (in pixels)
</para></listitem></varlistentry>
<varlistentry><term>sizeX, sizeY</term>
<listitem><para>Size of the bitmaps (if omitted, the size of the bitmaps is retrieved)
</para></listitem></varlistentry>
<varlistentry><term>delay</term>
<listitem><para>The time in milliseconds the method waits after each move
</para></listitem></varlistentry>
<varlistentry><term>xnow, ynow</term>
<listitem><para>The starting position of the bitmap
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example defines and runs an animated button. The example
loads ten bitmaps (&quot;anibmp1.bmp&quot; to &quot;anibmp10.bmp&quot;) into memory
and stores them into the array "My.Bitmaps" that is stored in the .local directory.
The name "My.Bitmaps" is specified as the <computeroutput>bmpfrom</computeroutput> and <computeroutput>bmpto</computeroutput> is omitted. After the dialog execution the bitmaps are removed from
memory again. The sample also uses a different animation class (".MyAnimation")
which subclasses from .AnimatedButton and overrides method HitRight which
plays a tune each time the animated bitmap hits the right border.
</para></listitem></varlistentry>
</variablelist>

<programlisting>
<![CDATA[
/* store array in .local */
.Local["My.Bitmaps"] = .array~new(10)
/* load 10 bitmaps into .local array */
do i= 1 to 10
  .Local["My.Bitmaps"][i] = Dialog~LoadBitmap("anibmp"i".bmp")
  /* you could also use .My.Bitmaps[i] =  ... */
end

/* connect bitmap sequence and .MyAnimated class with button IDANI */
Dialog~installAnimatedButton("IDANI", ,.MyAnimation,"My.Bitmaps", ,1,1, , ,100)

...
Dialog~execute
...

/* Free the bitmap previously loaded */
do bmp over .Local["My.Bitmaps"] /* You could also use do bmp over .My.Bitmaps */
   Dialog~RemoveBitmap(bmp)
end


::class MyAnimation subclass AnimatedButton

/* play sound.wav whenever the bitmap hits the right border */

::method HitRight
   ret = Play("sound.wav", yes)
   return self~super:hitright
]]>
</programlisting>
</section>

</section>

<section id="man0021"><title>Device Context Methods</title>
<indexterm><primary>device context methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<para>The methods listed below are used to retrieve and release a device context.</para>
<para>A device context is associated with a window, a dialog, or a push button,
and is a drawing area managed by a window. A device context stores information
about the graphic objects (bitmaps, lines, pixels, ...) that are displayed
and the tools (pen, brush, font, ...) that are used to display them.</para>

<section id="h001062"><title>GetWindowDC</title>
<indexterm><primary>GetWindowDC</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetWindowDC(--hwnd--)--------------------------><


]]>
</programlisting>

<para>The GetWindowDC method returns the device context
of a window. Do not forget to free the device context after you have completed
the operations (see <link linkend="h001086">FreeWindowDC</link>). </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of the window
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001077"><title>GetButtonDC</title>
<indexterm><primary>GetButtonDC</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetButtonDC(--id--)----------------------------><


]]>
</programlisting>

<para>The GetButtonDC method returns the device context
of a button. Do not forget to free the device context after you have completed
the operations (see <link linkend="h001105">FreeButtonDC</link>). </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001086"><title>FreeWindowDC</title>
<indexterm><primary>FreeWindowDC</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~FreeWindowDC(--hwnd--,--dc--)------------------><


]]>
</programlisting>

<para>The FreeWindowDC method frees the device context
of a window. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The window handle
</para></listitem></varlistentry>
<varlistentry><term>dc</term>
<listitem><para>The device context previously received by the <link linkend="h001062">GetWindowDC</link> method
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001105"><title>FreeButtonDC</title>
<indexterm><primary>FreeButtonDC</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~FreeButtonDC(--id--,--dc--)--------------------><


]]>
</programlisting>

<para>The FreeButtonDC method releases the device context
of a button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
<varlistentry><term>dc</term>
<listitem><para>The device context previously received by the <link linkend="h001077">GetButtonDC</link> method
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="man0022"><title>Text Methods</title>
<indexterm><primary>text methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<para>
  The following methods are used to display text dynamically in a window area and to modify the state of
  a device context. See <link linkend="h001062">GetWindowDC</link>, <link linkend="getdc">GetDC</link>,
  and <link linkend="h001077">GetButtonDC</link> for information on how to retrieve a device context.
</para>

<section id="h000866"><title>Write</title>
<indexterm><primary>Write</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Write(--xPos--,--yPos--,--text---------------------------------->

>--+------------------------------------------------------------------------+-->
   |    +-"SYSTEM"-+                                                        |
   +-,--+----------+--+---------------------------------------------------+-+
        +-fontName-+  |    +-10-------+                                   |
                      +-,--+----------+--+------------------------------+-+
                           +-fontSize-+  |       +-----------------+    |
                                         |       V +-OPAQUE------+ |    |
                                         +-,--"----+-THIN--------+-+--"-+
                                                   +-EXTRALIGHT--+
                                                   +-LIGHT-------+
                                                   +-MEDIUM------+
                                                   +-SEMIBOLD----+
                                                   +-EXTRABOLD---+
                                                   +-BOLD--------+
                                                   +-HEAVY-------+
                                                   +-UNDERLINE---+
                                                   +-ITALIC------+
                                                   +-STRIKEOUT---+
                                                   +-TRANSPARENT-+
                                                   +-CLIENT------+

>--)--------------------------------------------------------------------------><


]]>
</programlisting>

<para>The Write method enables you to write text to the
dialog in the given font and size, to the given position. This method does
not take a handle or an ID; it always writes to the dialog window. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>See <link linkend="h000826">WriteToWindow</link> for a description of the other arguments.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000879"><title>ScrollText</title>
<indexterm><primary>ScrollText</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ScrollText(--hwnd--,--text--,--+----------+--,--+----------+-->
                                              +-fontName-+     +-fontSize-+

>--,--+--------------------------+------------------------------------------->
      |    +----------------+    |
      |    V                |    |
      +-"----+-THIN-------+-+--"-+
             +-EXTRALIGHT-+
             +-LIGHT------+
             +-MEDIUM-----+
             +-SEMIBOLD---+
             +-EXTRABOLD--+
             +-BOLD-------+
             +-HEAVY------+
             +-UNDERLINE--+
             +-ITALIC-----+
             +-STRIKEOUT--+

>--,--displaceY--,--step--,--sleep--,--color--)-----------------------------><


]]>
</programlisting>

<para>The ScrollText method scrolls text in a window
with the given size, font, and color. The text is scrolled from right to left.
If the method is started concurrently, call it a second time to
stop scrolling.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:</para>
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of the window in which the text is scrolled
</para></listitem></varlistentry>
<varlistentry><term>text</term>
<listitem><para>A text string that is scrolled
</para></listitem></varlistentry>
<varlistentry><term>displaceY</term>
<listitem><para>The vertical displacement of the text relative to the top of the window's
client area (default 0)
</para></listitem></varlistentry>
<varlistentry><term>step</term>
<listitem><para>The size of one step in screen pixels (default 4)
</para></listitem></varlistentry>
<varlistentry><term>sleep</term>
<listitem><para>The time in milliseconds that the program waits after each movement
(default 10). This determines the speed.
</para></listitem></varlistentry>
<varlistentry><term>color</term>
<listitem><para>The color of the text (default 0, black)
</para></listitem></varlistentry>
</variablelist>
<para>See <link linkend="h000826">WriteToWindow</link> for a description of the other
arguments.</para>
</listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example scrolls the string &quot;Hello world!&quot; from left
to right within the given window. The text is located two pixels below the
top of the client area, one move is 3 screen pixels, and the delay time after
each movement is 15 ms.</para>

<programlisting>
<![CDATA[
MyDialog~ScrollText(hwnd, "Hello world!", , , , 2, 3, 15)
]]>
</programlisting>
</listitem></varlistentry>
</variablelist>

<note><title>Note</title><para>
Only one sleep interval can be set for multiple scrolling
texts within one process. All scrolling text in one process is synchronized
with the first given interval.
</para></note>
</section>

<section id="h000896"><title>ScrollInButton</title>
<indexterm><primary>ScrollInButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ScrollInButton(--id--,--text--,--+----------+--,-->
                                                +-fontName-+

>--+----------+--,--+--------------------------+---------------->
   +-fontSize-+     |    +----------------+    |
                    |    V                |    |
                    +-"----+-THIN-------+-+--"-+
                           +-EXTRALIGHT-+
                           +-LIGHT------+
                           +-MEDIUM-----+
                           +-SEMIBOLD---+
                           +-EXTRABOLD--+
                           +-BOLD-------+
                           +-HEAVY------+
                           +-UNDERLINE--+
                           +-ITALIC-----+
                           +-STRIKEOUT--+

>--,--displaceY--,--step--,--sleep--,--color--)---------------><


]]>
</programlisting>

<para>The ScrollInButton method scrolls text within a
button. It is similar to the <link linkend="h000879">ScrollText</link> method, except
that you have to pass an ID instead of a window handle.</para>
</section>

<section id="h000913"><title>ScrollButton</title>
<indexterm><primary>ScrollButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ScrollButton(--id--,--xPos--,--yPos--,--left--,--top-->

>--,--right--,--bottom--)-------------------------------------><


]]>
</programlisting>

<para>The ScrollButton method moves the rectangle within
a button. It is used to move bitmaps within buttons. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
<varlistentry><term>xPos, yPos</term>
<listitem><para>The new position of the rectangle (in pixels)
</para></listitem></varlistentry>
<varlistentry><term>left, top, right, bottom</term>
<listitem><para>The extension of the rectangle
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="sifm"><title>SetItemFont</title>
<indexterm><primary>SetItemFont</primary></indexterm>
<programlisting>
<![CDATA[
                                                    +-1--------+
>>--aBaseDialog~SetItemFont(--id--,--fonthandle--,--+----------+--)--><
                                                    +--redraw--+


]]>
</programlisting>

<para>
  The SetItemFont method changes the font for a particular dialog item.
</para>
<para>
  The best place to call this method is within <link linkend="mthInitDialog">InitDialog</link>. If the
  font is no longer needed, for instance, when the dialog is closed or another font has been assigned to
  the dialog item, you should free the font resource by calling <link
  linkend="mthDeleteFont">DeleteFont</link>. A good place to do this is the <link
  linkend="mthLeaving">leaving</link> method.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog item.
</para></listitem></varlistentry>
<varlistentry><term>fonthandle</term>
<listitem><para>The handle returned by <link linkend="mthCreateFontEx">createFontEx</link>.
</para></listitem></varlistentry>
<varlistentry><term>redraw</term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Do not redraw the item.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Redraw the item, which is the default.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example sets a 12-point Arial font for item 101.
<programlisting>
<![CDATA[
::method InitDialog
     .
     .
     .
   hFont=self~createFontEx("Arial",12)
   self~SetItemFont(101,hFont,0)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
<para></para>
</section>

</section>

<section id="sctMenuMethodsDlgObject"><title>Menu Methods</title>
<indexterm><primary>dialog object</primary>
<secondary>menu methods</secondary></indexterm>
<para>
  Prior to ooDialog version 4.1.0, menus were really only minimally supported, through a few methods of the dialog
  class.  In ooDialog 4.1.0 true <link linkend="chpMenus">menu</link> objects were introduced.  Therefore the menu
  methods of the dialog, other than <link linkend="mthGetMenuBar">getMenuBar</link>() and <link
  linkend="mthHasMenuBar">hasMenuBar</link>(), are deprecated.  Use the methods of the menu classes directly to work
  with menus. The listing of the <link linkend="deprecatedDialogMethods">deprecated dialog methods</link> documents all
  the method to use to replace each deprecated method.
</para>

<section id="mthGetMenuBar"><title>getMenuBar</title>
<indexterm><primary>getMenuBar</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getMenuBar----------------------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">getMenuBar</emphasis> method returns the <link
  linkend="chpMenus">menu</link> object attached to the dialog, or <emphasis
  role="bold">.nil</emphasis> if there is no menu attached.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>
  There are no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
  If a menu is attached to the dialog, the Rexx menu object is returned.  If no menu is attached, then
  <emphasis role="bold">.nil</emphasis> is returned.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
  This snippet of code comes from a program where the user can customize the interface to use a menu or
  to not use a menu.  When writes should be disabled, the method checks for a menu and if present
  disables the appropriate menu items.
<programlisting>
<![CDATA[
::method onDisableWrites
    if self~hasMenuBar then do
        menu = self~getMenuBar
        menu~disable(IDM_WRITE_TO_FILE)
        menu~disable(IDM_WRITE_TO_MEMORY)
        menu~disable(IDM_WRITE_TO_SOCKET)
    end
    return 0
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthHasMenuBar"><title>hasMenuBar</title>
<indexterm><primary>hasMenuBar</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--hasMenuBar----------------------------------------------><

]]>
</programlisting>

<para>
  Tests if the dialog has a menu bar attached.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>
  There are no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
  True if a menu is attached to the dialog, otherwise false.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
  See the example for the <link linkend="mthGetMenuBar">getMenuBar</link>() method.
</para></listitem></varlistentry>
</variablelist>
</section>

</section>

<section id="sctSendingWindowsMessages"><title>Sending Windows Messages</title>

<section id="wbdoSendMessage"><title>sendMessage</title>
<programlisting>
WindowBase::<link linkend="mthSendMessage">sendMessage</link>

<![CDATA[
>>--sendMessage(--id--,--msg--,--wParam--,--lParam--)----------><
]]>
</programlisting>
</section>

<section id="wbdoSendMessageHandle"><title>sendMessageHandle</title>
<programlisting>
<link linkend="mthSendMessageHandle">sendMessageHandle</link>

<![CDATA[
>>--sendMessageHandle(--id--,--msg--,--wParam--,--lParam--)----><
]]>
</programlisting>
</section>

<section id="mthSendMessageToWindow"><title>sendMessageToWindow</title>
<indexterm><primary>sendMessageToControl</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>sendMessageToControl</secondary></indexterm>
<programlisting>
<![CDATA[
>>--sendMessageToWindow(--hwnd--,--msg--,--wParam--,--lParam--)----------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">sendMessageToWindow</emphasis> method sends a Windows message to a window and returns the
  response as a whole number.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  <para>
    This method requires an <link linkend="ovvWindowMessages">understanding</link> of Windows messages.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>msg [required]</term>
    <listitem>
    <para>
      The Windows message ID. This may be numeric or a string in <link linkend="defConventionalHex">conventional</link>
      hexadecimal formt.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>wParam [required]</term>
    <listitem>
    <para>
      The WPARAM message parameter.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>lParam [required]</term>
    <listitem>
    <para>
      The LPARAM message parameter.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The underlying windows's response to the message, as a whole number.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method returns the response as a whole number. This will not be usable if the response is a window <link
    linkend="defHandle">handle</link>. For those cases, use the <link
    linkend="mthSendMessageToWindowH">sendMessageToWindowH</link>() method.
  </para>
  </listitem></varlistentry>
  <varlistentry id="exampleSendMessageToWindow"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example sets a new font for the date time picker's month calendar and returs the font it was using.
    Note that the same thing can be done by using the <link linkend="mthGetMonthCalFont">getMonthCalFont</link> and
    <link linkend="mthSetMonthCalfont"></link> methods of the <link linkend="clsDateTimePicker"></link> class. In most
    cases, there is really no need for the Rexx programmer to use the <emphasis
    role="italic">sendMessageToWindow</emphasis> or <emphasis role="italic">sendMessageToWindowH</emphasis> methods.

<programlisting>
<![CDATA[
::method changeCalendarFont private
  use strict arg hNewFont

  hwnd = self~newDateTimePicker(IDC_DTP_SCHEDULER)~hwnd

  hOldFont = self~sendMessageToWindowH(hwnd, "0x100A", 0, 0)
  self~sendMessageToWindow(hwnd, "0x1009", hNewFont, 1)

  return hOldFont
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthSendMessageToWindowH"><title>sendMessageToWindowH</title>
<indexterm><primary>sendMessageToWindowH</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>sendMessageToWindowH</secondary></indexterm>
<programlisting>
<![CDATA[
>>--sendMessageToWindowH(--hwnd,--msg--,--wParam--,--lParam--)-----------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">sendMessageToWindowH</emphasis> method sends a Windows message to a window and returns the
  response as a <link linkend="defHandle">handle</link>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  <para>
    This method requires an <link linkend="ovvWindowMessages">understanding</link> of Windows messages.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>hwnd [required]</term>
    <listitem>
    <para>
      The <link linkend="defHandle">handle</link> of the window the message is sent to.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>msg [required]</term>
    <listitem>
    <para>
      The Windows message ID. This may be numeric or a string in <link linkend="defConventionalHex">conventional</link>
      hexadecimal formt.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>wParam [required]</term>
    <listitem>
    <para>
      The WPARAM message parameter.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>lParam [required]</term>
    <listitem>
    <para>
      The LPARAM message parameter.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The underlying windows's response to the message, as a handle.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method returns the response as a handle. This will not be of much use if the windows's response is a whole
    number. For those cases, use the <link linkend="mthSendMessageToWindow">sendMessageToWindow</link>() method.
  </para> </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The <emphasis role="italic">sendMessageToWinow</emphasis> <link linkend="exampleSendMessageToWindow">example</link>
    also uses the <emphasis role="italic">sendMessageToWindowH</emphasis> method.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthSendMessageToControl"><title>sendMessageToControl</title>
<indexterm><primary>sendMessageToControl</primary></indexterm>
<programlisting>
<![CDATA[
>>--sendMessageToControl(--id--,--msg--,--wParam--,--lParam--)-----------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">sendMessageToControl</emphasis> method sends a Windows message to a dialog control and
  returns the response as a whole number.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  <para>
    This method requires an <link linkend="ovvWindowMessages">understanding</link> of Windows messages.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>msg [required]</term>
    <listitem>
    <para>
      The Windows message ID. This may be numeric or a string in <link linkend="defConventionalHex">conventional</link>
      hexadecimal formt.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>wParam [required]</term>
    <listitem>
    <para>
      The WPARAM message parameter.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>lParam [required]</term>
    <listitem>
    <para>
      The LPARAM message parameter.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The underlying dialog control's response to the message, as a whole number.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method returns the response as a whole number. This will not be usable if the response is a window <link
    linkend="defHandle">handle</link>. For those cases, use the <link
    linkend="mthSendMessageToControlH">sendMessageToControlH</link>() method.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example checks the radio button with resource ID 9001.

<programlisting>
<![CDATA[
MyDialog~sendMessageToControl(9001, "0x000000F1", 1, 0)
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthSendMessageToControlH"><title>sendMessageToControlH</title>
<indexterm><primary>sendMessageToControlH</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>sendMessageToControlH</secondary></indexterm>
<programlisting>
<![CDATA[
>>--sendMessageToControlH(--id--,--msg--,--wParam--,--lParam--)----------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">sendMessageToControlH</emphasis> method sends a Windows message to a dialog control and
  returns the response as a window handle.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  <para>
    This method requires an <link linkend="ovvWindowMessages">understanding</link> of Windows messages.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the dialog control. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>msg [required]</term>
    <listitem>
    <para>
      The Windows message ID. This may be numeric or a string in <link linkend="defConventionalHex">conventional</link>
      hexadecimal formt.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>wParam [required]</term>
    <listitem>
    <para>
      The WPARAM message parameter.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>lParam [required]</term>
    <listitem>
    <para>
      The LPARAM message parameter.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The underlying dialog control's response to the message, as a window handle.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method returns the response as a window <link linkend="defHandle">handle</link>. This will not be of much use
    if the dialog control's response is a whole number. For those cases, use the <link
    linkend="mthSendMessageToControl">sendMessageToControl</link>() method.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example changes the font of the list view control with symbolic ID of IDC_LV_ADDRESSES and returns
    the old font. Note that this is exactly what the <link linkend="mthGetFont">getFont</link>() and <link
    linkend="mthSetFont">setFont</link> methods do. In most cases, there is really no need for the Rexx programmer to
    use the <emphasis role="italic">sendMessageToControl</emphasis> or <emphasis
    role="italic">sendMessageToControlH</emphasis> methods.

<programlisting>
<![CDATA[
::method changeFont private
  use strict arg newFont

  oldFont = self~sendMessageToControlH(IDC_LV_ADDRESSES, "0x0031", 0, 0)
  self~sendMessageToControl(IDC_LV_ADDRESSES, "0x0030", newFont, 1)

  return oldFont
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

</section>  <!-- End Sending Windows Messages Section -->


<section id="deprecatedDialogMethods"><title>Deprecated Methods</title>
<indexterm><primary>Deprecated</primary><secondary>dialog object methods</secondary></indexterm>
<para>
  <link linkend="ovvDeprecated">Deprecated</link> dialog methods and their replacement methods are listed in this
  section.
</para>

<section><title>assignWindow</title>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>assignWindow</tertiary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>assignWindow</secondary><tertiary>dialog object</tertiary></indexterm>
<para>
  This method is deprecated and always returns 0, <emphasis role="italic">the assignment failed</emphasis>. To work with
  a dialog or dialog control object, construct the proper ooDialog object. This ensures that the object has the correct
  methods. To control a window not owned by your program use the <emphasis role="italic">find</emphasis>() method of the
  <emphasis role="italic">WindowsManger</emphasis> class. The <emphasis role="italic">WindowsManager</emphasis>is part
  of the <emphasis role="italic">WinSystm.cls</emphasis> package. In certain cases it may be desirable to invoke a
  method common to all windows when only the window <link linkend="defHandle">handle</link> is known.  For these cases
  use a <link linkend="clsWindow">Window</link> object.
</para>
</section>

<section><title>checkMenuItem</title>
<indexterm><primary>Deprecated</primary><secondary>checkMenuItem</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>checkMenuItem</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>.  Use the <link linkend="chpMenus">menu</link>
  object methods directly.
</para>
</section>

<section><title>connectAnimatedButton</title>
<indexterm><primary>Deprecated</primary><secondary>connectAnimatedButton</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>connectAnimatedButton</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthInstallAnimatedButton">installAnimatedButton</link>() method.
</para>
</section>

<section><title>connectBitmapButton</title>
<indexterm><primary>Deprecated</primary><secondary>connectBitmapButton</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>connectBitmapButton</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthInstallBitmapButton">installBitmapButton</link>() method.
</para>
</section>

<section><title>deInstall</title>
<indexterm><primary>Deprecated</primary><secondary>deInstall</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>deInstall</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>.  It does nothing and always returns 0. In older
  versions of ooDialog, the <emphasis role="italic">deInstall</emphasis>() method was used to deregister the
  external functions with the API manager. This mechanism is no longer needed using the modern APIs introduced in
  ooRexx 4.0.0.
</para>
</section>

<section><title>disableMenuItem</title>
<indexterm><primary>Deprecated</primary><secondary>disableMenuItem</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>disableMenuItem</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>.  Use the <link linkend="chpMenus">menu</link>
  object methods directly.
</para>
</section>

<section><title>dump</title>
<indexterm><primary>Deprecated</primary><secondary>dump</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>dump</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>.  It will simply print: &quot;dump() deprecated.&quot; In
  older versions of ooDialog, the <emphasis role="italic">dump</emphasis>() method would print out information tied to
  the undocumented internal implementation of ooDialog. Since the internal implementation has changed, this information
  no longer exists.
</para>
</section>

<section><title>enableMenuItem</title>
<indexterm><primary>Deprecated</primary><secondary>enableMenuItem</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>enableMenuItem</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>.  Use the <link linkend="chpMenus">menu</link>
  object methods directly.
</para>
</section>

<section><title>getButtonControl</title>
<indexterm><primary>Deprecated</primary><secondary>getButtonControl</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getButtonControl</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewPushButton">newPushButton</link>() method.
</para>
</section>

<section><title>getCheckControl</title>
<indexterm><primary>Deprecated</primary><secondary>getCheckControl</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getCheckControl</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewCheckBox">newCheckBox</link>() method.
</para>
</section>

<section><title>getComboBox</title>
<indexterm><primary>Deprecated</primary><secondary>getComboBox</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getComboBox</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewComboBox">newComboBox</link>() method.
</para>
</section>

<section><title>getEditControl</title>
<indexterm><primary>Deprecated</primary><secondary>getEditControl</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getEditControl</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewEdit">newEdit</link>() method.
</para>
</section>

<section><title>getGroupBox</title>
<indexterm><primary>Deprecated</primary><secondary>getGroupBox</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getGroupBox</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewGroupBox">newGroupBox</link>() method.
</para>
</section>

<section><title>getListBox</title>
<indexterm><primary>Deprecated</primary><secondary>getListBox</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getListBox</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewListBox">newListBox</link>() method.
</para>
</section>

<section><title>getListControl</title>
<indexterm><primary>Deprecated</primary><secondary>getListControl</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getListControl</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewListView">newListView</link>() method.
</para>
</section>

<section><title>getProgressBar</title>
<indexterm><primary>Deprecated</primary><secondary>getProgressBar</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getProgressBar</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewProgressBar">newProgressBar</link>() method.
</para>
</section>

<section><title>getRadioControl</title>
<indexterm><primary>Deprecated</primary><secondary>getRadioControl</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getRadioControl</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewRadioButton">newRadioButton</link>() method.
</para>
</section>

<section><title>getScrollBar</title>
<indexterm><primary>Deprecated</primary><secondary>getScrollBar</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getScrollBar</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewScrollBar">newScrollBar</link>() method.
</para>
</section>

<section><title>getSliderControl</title>
<indexterm><primary>Deprecated</primary><secondary>getSliderControl</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getSliderControl</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewTrackBar">newTrackBar</link>() method.
</para>
</section>

<section><title>getStaticControl</title>
<indexterm><primary>Deprecated</primary><secondary>getStaticControl</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getStaticControl</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewStatic">newStatic</link>() method.
</para>
</section>

<section><title>getTabControl</title>
<indexterm><primary>Deprecated</primary><secondary>getTabControl</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getTabControl</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewTab">newTab</link>() method.
</para>
</section>

<section><title>getTreeControl</title>
<indexterm><primary>Deprecated</primary><secondary>getTreeControl</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getTreeControl</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewTreeView">newTreeView</link>() method.
</para>
</section>

<section><title>getTextSize</title>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getTextSize</tertiary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>getTextSize</secondary><tertiary>dialog object</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>.  Replace this method with, preferably, the <link
  linkend="mthGetTextSizeDu">getTextSizeDu</link>() method, or the <link
  linkend="mthGetTextSizeDlgClsPlainBaseDialog">getTextSizeDlg</link>() method if absolutely necessary.
</para>
<para>
  This method never worked correctly, the previous documentation for this method was incorrect and /
  or misleading. That has been fixed in the <emphasis role="italic">getTextSizeDu</emphasis>() and <emphasis
  role="italic">getTextSizeDlg</emphasis>() methods.
</para>
</section>

<section><title>getStaticControl</title>
<indexterm><primary>Deprecated</primary><secondary>getStaticControl</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getStaticControl</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewStatic">newStatic</link>() method.
</para>
</section>

<section><title>getButtonControl</title>
<indexterm><primary>Deprecated</primary><secondary>getButtonControl</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getButtonControl</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewPushButton">newPushButton</link>() method.
</para>
</section>

<section><title>getRadioControl</title>
<indexterm><primary>Deprecated</primary><secondary>getRadioControl</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getRadioControl</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewRadioButton">newRadioButton</link>() method.
</para>
</section>

<section><title>getCheckControl</title>
<indexterm><primary>Deprecated</primary><secondary>getCheckControl</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getCheckControl</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthNewCheckBox">newCheckBox</link>() method.
</para>
</section>

<section><title>getMenuItemState</title>
<indexterm><primary>Deprecated</primary><secondary>getMenuItemState</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getMenuItemState</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>.  Use the <link linkend="chpMenus">menu</link>
  object methods directly.
</para>
</section>

<section><title>getSystemMetrics</title>
<indexterm><primary>Deprecated</primary><secondary>getSystemMetrics</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>getSystemMetrics</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method the functionally equivalent <link
  linkend="mthGetSystemMetricsClsDlgUtil">getSystemMetrics()</link> method of the <emphasis
  role="italic">.DlgUtil</emphasis>class.
</para>
</section>

<section><title>grayMenuItem</title>
<indexterm><primary>Deprecated</primary><secondary>grayMenuItem</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>grayMenuItem</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>.  Use the <link linkend="chpMenus">menu</link>
  object methods directly.
</para>
</section>

<section><title>itemText</title>
<indexterm><primary>Deprecated</primary><secondary>itemText</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>itemText</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthSetControlText">setControlText</link>() method. <emphasis role="bold">Note</emphasis> that this method has
  always been present in ooDialog, but was never previously documented.
</para>
</section>

<section><title>setMenuItemRadio</title>
<indexterm><primary>Deprecated</primary><secondary>setMenuItemRadio</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>setMenuItemRadio</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>.  Use the <link linkend="chpMenus">menu</link>
  object methods directly.
</para>
</section>

<section><title>setStaticText</title>
<indexterm><primary>Deprecated</primary><secondary>setStaticText</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>setStaticText</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>. Replace this method with the <link
  linkend="mthSetControlText">setControlText</link>() method.
</para>
</section>

<section><title>uncheckMenuItem</title>
<indexterm><primary>Deprecated</primary><secondary>uncheckMenuItem</secondary></indexterm>
<indexterm><primary>Deprecated</primary><secondary>dialog object</secondary><tertiary>uncheckMenuItem</tertiary></indexterm>
<para>
  This method is <link linkend="ovvDeprecated">deprecated</link>.  Use the <link linkend="chpMenus">menu</link>
  object methods directly.
</para>
</section>

</section>

</chapter>
