<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog Reference SGML file.
    #
    # Copyright (c) 2008-2011, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->

<section id="clsDialogExtensions"><title>DialogExtensions Mixin Class</title>
<indexterm><primary>DialogExtensions Class</primary></indexterm>
<para>
  x
</para>

<section id="sctMethodsDialogExtensions"><title>Method Table</title>

<para>
  The following table provides links to the documentation for the methods DialogExtensions Mixin Class:
</para>
<table id="tblDialogExtensionsMethods" frame="all">
<title>DialogExtensions Methods</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry><link linkend="mthAddAutoStartMethod">addAutoStartMethod</link></entry>
<entry>xx</entry>
</row>
<row>
<entry><link linkend="mthBackgroundBitmap">backgroundBitmap</link></entry>
<entry>xx</entry>
</row>
<row>
<entry><link linkend="mthCaptureMouse">captureMouse</link></entry>
<entry>xx</entry>
</row>
<row>
<entry><link linkend="mthChangeBitmapButton">changeBitmapButton</link></entry>
<entry>Changes the bitmap of a bitmap button.</entry>
</row>
<row>
<entry><link linkend="mthDimBitmap">dimBitmap</link></entry>
<entry>Draws a bitmap step by step.</entry>
</row>
<row>
<entry><link linkend="mthCreateBrushClsDialogExtensions">createBrush</link></entry>
<entry>xx</entry>
</row>
<row>
<entry><link linkend="mthDimBitmap">dimBitmap</link></entry>
<entry>xx</entry>
</row>
<row>
<entry><link linkend="mthDisplaceBitmap">displaceBitmap</link></entry>
<entry>Sets the position of the bitmap within a bitmap button.</entry>
</row>
<row>
<entry><link linkend="mthDrawBitmap">drawBitmap</link></entry>
<entry>Draws the bitmap for a bitmap button at the specified position.</entry>
</row>
<row>
<entry><link linkend="mthGetBitmapPosition">getBitmapPosition</link></entry>
<entry>Retrieves the postion, as a point, of the upper left corner of a bitmap within a bitmap button.</entry>
</row>
<row>
<entry><link linkend="mthGetBitMapSizeX">getBitmapSizeX</link></entry>
<entry>Retrieves the width of the bitmap that is set for a bitmap button.</entry>
</row>
<row>
<entry><link linkend="mthGetBitMapSizeY">getBitmapSizeY</link></entry>
<entry>Retrieves the height of the bitmap that is set for a bitmap button.</entry>
</row>
<row>
<entry><link linkend="mthGetBmpDisplacement">getBmpDisplacement</link></entry>
<entry>Retrieves the position of the bitmap within a bitmap button.</entry>
</row>
<row>
<entry><link linkend="mthInstallAnimatedButton">installAnimatedButton</link></entry>
<entry>xx</entry>
</row>
<row>
<entry><link linkend="mthInstallBitmapButton">installBitmapButton</link></entry>
<entry>xx</entry>
</row>
<row>
<entry><link linkend="mthScrollBitmapFromTo">scrollBitmapFromTo</link></entry>
<entry>Scrolls the bitmap within the bitmap button from one position to another.</entry>
</row>
<row>
<entry><link linkend="mthScrollButton">scrollButton</link></entry>
<entry>Moves a rectangle within the button and redraws the uncovered area with the button background color.</entry>
</row>
<row>
<entry><link linkend="mthScrollText">scrollText</link></entry>
<entry>Scrolls text in the button with the given font, size, and color.</entry>
</row>
<row>
<entry><link linkend="mthSetBitmapPosition">setBitmapPosition</link></entry>
<entry>Sets the postion of the upper left corner of a bitmap within the bitmap button.</entry>
</row>
<row>
<entry><link linkend="mthTiledBackgroundBitmap">tiledBackgroundBitmap</link></entry>
<entry>xx</entry>
</row>
</tbody></tgroup>
</table>
</section>


<section id="mthAddAutoStartMethod"><title>addAutoStartMethod</title>
<indexterm><primary>addAutoStartMethod</primary></indexterm>
<programlisting>
<![CDATA[
>>--addAutoStartMethod(--+---------+--,--methodName--+---------------+--)------><
                         +-inClass-+                 +-,--parameters-+


]]>
</programlisting>

<para>The addAutoStartMethod method adds a method name
and parameters to a special internal queue. All methods in this queue will
be started automatically and run concurrently when the dialog is executed.
The given method (MethodName) in the given class (InClass) is started concurrently with the dialog when
the dialog is activated using the <link linkend="mthExecute">execute</link> or <link linkend="mthExecuteAsync">executeAsync</link> method. This is useful for processing animated
buttons. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>inClass</term>
<listitem><para>The class where the method is defined. If this argument is omitted,
the method is assumed to be defined in the dialog class.
</para></listitem></varlistentry>
<varlistentry><term>methodName</term>
<listitem><para>The name of the method
</para></listitem></varlistentry>
<varlistentry><term>parameters</term>
<listitem><para>All parameters that are passed to this method
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example installs the ExecuteB method
of the MyAnimatedButton class so that it is processed
concurrently with the dialog execution:

<programlisting>
<![CDATA[
MyDialog~addAutoStartMethod("MyAnimatedButton", "ExecuteB")

::class MyAnimatedButton
::method ExecuteB
     .
     .
     .
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthCaptureMouse"><title>captureMouse</title>
<indexterm><primary>captureMouse</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>captureMouse</secondary></indexterm>
<indexterm><primary>DialogExtensions</primary><secondary>captureMouse</secondary></indexterm>
<programlisting>
<![CDATA[
>>--captureMouse(--+------+--)-------------------><
                   +--id--+
]]>
</programlisting>

<para>
  Sets the mouse capture to this dialog window, or optionally a dialog control window belonging to this dialog.  Once a
  window has captured the mouse, all mouse input is directed to the window even when the mouse is moved outside the
  boundaries of the window.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single optional argument is:
    <variablelist>
      <varlistentry><term>id [optional]</term>
      <listitem>
      <para>
        Sets the mouse capture to the dialog control with this resource ID. The control must belong to this dialog. See
        the remarks section. The ID may be numeric or <link linkend="defSymbolicID">symbolic</link>.
      </para> </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The handle to the window that previously captured the mouse, or 0 if the mouse was not captured before.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    <emphasis role="italic">captureMouse</emphasis> can capture mouse input either when the mouse is over the dialog,
    or when the mouse button was pressed while the mouse was over the dialog and the button is still down. Only one
    window at a time can capture the mouse.
  </para>
  <para>
    If the mouse cursor is over a window created by another thread, the system will direct mouse input to the specified
    window only if a mouse button is down.
  </para>
  <para>
    Only the foreground window can capture the mouse. Also, even if the foreground window has captured the mouse, the
    user can still click another window, bringing it to the foreground.
  </para>
  <para>
    ooDialog has always had the functionality to set the mouse capture to a dialog control window. However, it is
    difficult to imagine any scenario, in ooDialog, where this could be of any use.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::captureMouse() -->


<section id="mthChangeBitmapButton"><title>changeBitmapButton</title>
<indexterm><primary>changeBitmapButton</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>changeBitmapButton</secondary></indexterm>
<programlisting>
<![CDATA[

>>--changeBitmapButton(--id--,--normal--+-----------+--+------------+---------->
                                        +-,-focused-+  +-,-selected-+

>--+------------+--+---------+--)----------------------------------------------><
   +-,-disabled-+  +-,-style-+
]]>
</programlisting>

<para>
  Changes the bitmaps for an already <link linkend="mthInstallBitmapButton">installed</link> bitmap button and
  optionally immediately redraws the button.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID for the bitmap button whose bitmaps are being changed. May be numeric or <link
      linkend="defSymbolicID">symbolic</link> .
      </para>
      </listitem></varlistentry>
      <varlistentry><term>normal [required]</term>
      <listitem>
      <para>
        The bitmap to use for the normal state ofthe button. See the remarks for information on how the bitmap may be
        specified.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>focused [optional]</term>
      <listitem>
      <para>
        The bitmap to use for the focused state ofthe button. See the remarks for information on how the bitmap may be
        specified. If this argument is omitted, the normal bitmap is used for the focused state.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>selected [optional]</term>
      <listitem>
      <para>
        The bitmap to use for the selected state ofthe button. See the remarks for information on how the bitmap may be
        specified. If this argument is omitted, the normal bitmap is used for the selected state.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>disabled [optional]</term>
      <listitem>
      <para>
        The bitmap to use for the disabled state of the button. See the remarks for information on how the bitmap may be
        specified. If this argument is omitted, the normal bitmap is used for the disabled state.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>style [optional]</term>
      <listitem>
      <para>
        A list of 0 or more of the following keywords separated by spaces, case is not significant:
      </para>
      <para>
        <simplelist type='vert' columns='3'>
          <member>FRAME   </member>
          <member>USEPAL  </member>
          <member>INMEMORY</member>
          <member>STRETCH </member>
          <member>NODRAW  </member>
        </simplelist>
        <variablelist>
          <varlistentry><term>FRAME</term>
          <listitem>
          <para>
            With this option, when the ooDialog framework draws the bitmap button, it attempts to draw it with the 3D
            effect. Note that the drawing method is outdated and will give a somewhat different appearance to the button
            than that of buttons in modern Windows versions.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>USEPAL</term>
          <listitem>
          <para>
            Uses the colors of the bitmap for the normal state to create a system color palette. Use this option when
            the bitmap was created with a palette other than the default Windows color palette. This palette is used
            when drawing all of the bitmap states so when different bitmaps are used for the different states, they
            should all use the same colors.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>INMEMORY</term>
          <listitem>
          <para>
            The bitmaps can be loaded into memory through the <link linkend="mthLoadBitmap">loadBitmap</link> method. In
            this case, the programmer uses the bitmap handle to specify the bitmaps and <emphasis
            role="bold">must</emphasis> use the INMEMORY keyword.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>STRETCH</term>
          <listitem>
          <para>
            If the size of the bitmap is smaller than the size of the button rectangle, the bitmap is stretched to match
            the size of the button. This option has no effect on bitmaps loaded from a dynamic-link library.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>NODRAW</term>
          <listitem>
          <para>
            By default, when the button bitmaps are changed, the button is immediately redrawn. If this keyword is used,
            the button is not redrawn immediately. The next time the button needs to be redrawn, it will be redrawn
            using the new bitmaps.
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return values are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        Success.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
      <para>
        The resource ID could not be resolved.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
      <para>
        Error.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The arguments specifying the bitmaps can be a bitmap file name, a bitmap <link linkend="defHandle">handle</link>, or
    the resource number of a bitmap compiled into the resource DLL of a <link linkend="clsResDialog">ResDialog</link>.
    The bitmap arguments must all be the same type. I.e. all file names, all resource IDs, or all handles. If the bitmap
    arguments are handles the style argument must contain the INMEMORY keyword.
  </para>
  <para>
    The bitmap button must have already been assigned bitmaps, if there are no assigned bitmaps this method fails. All
    of the existing assigned bitmaps are removed, the programmer must reasign all 4 bitmaps, even if the bitmap for some
    state is the same as the previous bitmap.
  </para>
  <para>
    In ooDialog a bitmap button is an owner-drawn button that uses the supplied bitmap(s) for the button. ooDialog
    internally handles the drawing of the button.
  </para>
  <para>
    Up to 4 bitmaps can be assigned to the button. These bitmaps are drawn for the different button states: normal,
    focused, selected and disabled. The normal bitmap must be supplied and that bitmap is used for any of the other
    states if no bitmap for the state is supplied.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
<programlisting>
<![CDATA[

  self~changeBitmap("IDOK", "AddBut_n.bmp", "AddBut_f.bmp", -
                    "AddBut_s.bmp", "AddBut_d.bmp", "FRAME")

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::changeBitmapButton() -->


<section id="mthClearControlRect"><title>clearControlRect</title>
<indexterm><primary>clearControlRect</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>clearControlRect</secondary></indexterm>
<indexterm><primary>DialogExtensions class</primary><secondary>clearControlRect</secondary></indexterm>
<programlisting>
<![CDATA[
>>--clearControlRect(--id--)---------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">clearControlRect</emphasis> clears the client area of the specified dialog control by
  redrawing the area with the background brush set to the default background color of a dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource id of the dialog control that is to be cleared. May be numeric or <link
        linkend="defSymbolicID">symbolic</link>.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    0 on success, or 1 on any error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The client area of the control is not really <emphasis role="italic">cleared</emphasis>, but rather the dialog
    background is painted over the top of the area. Most dialog controls do not have a border, but if the control does
    have a border, the border is not cleared because it is outside of the client area.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End dialog object::clearControlRect() -->


<section id="mthClearRectClsDialogExtensions"><title>clearRect</title>
<indexterm><primary>clearRect</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>clearRect</secondary></indexterm>
<indexterm><primary>DialogExtensions class</primary><secondary>clearRect</secondary></indexterm>
<programlisting>
<![CDATA[
Form 1:

>>--clearRect(--hwnd--,--rectangle--)------------><


Form 2:

>>--clearRect(--hwnd--,--pt1--,--pt2--)----------><


Form 3:

>>--clearRect(--hwnd--,--x-,--y-,--cx-,--cy--)---><


Generic form:

>>--clearRect(--hwnd--,--rectCoordinates--)------><


]]>
</programlisting>

<para>
  The <emphasis role="italic">clearRect</emphasis> method clears the specified rectangular within the client area of a
  window. The rectangle is <emphasis role="italic">cleared</emphasis> by redrawing it with the background brush set to
  the typical background color for dialog boxes and three dimensional elements.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>hwnd [required]</term>
      <listitem>
      <para>
        The <link linkend="defHandle">handle</link> of the window containing the rectangle to be cleared.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>rectCoordinates [required]</term>
      <listitem>
      <para>
        The coordinates of the rectangle to be cleared. The coordinates specify the upper left and lower right corners
        of the rectangle. The corners can be specified using either a <link linkend="clsRect">rect</link> object, two
        <link linkend="clsPoint">point</link> objects, or the individual x and y coordinates of each corner.
      </para>
      <para>
        The cooridnates are specified as <link linkend="defClientArea">client-area</link> coordinates, in pixels.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    0 on success, 1 on error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The rectangle is not really cleared, but rather is redrawn using the normal background color for a dialog box.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example is a complete program, it can be copy and pasted into a file and executed. Running the program and
    reading the code should give a better understanding of the <emphasis role="italic">clearRect</emphasis> method than
    a text description alone.

<programlisting>
<![CDATA[

/* Shows clearRect() at work. */

  dlg = .Simple~new
  dlg~execute("SHOWTOP")

  return 0
-- End of entry point.

::requires "ooDialog.cls"

::class 'Simple' subclass UserDialog

::method init

  forward class (super) continue
  self~createCenter(245, 132, "clearRect() Example")

::method defineDialog

  self~createGroupBox(100, 10, 13, 107, 70, , "Test Group Box")
  self~createListView(200, 130, 13, 107, 70, "REPORT")

  self~createPushButton(300, 115, 108, 65, 14, , "Clear Group Box", onClear)
  self~createPushButton(IDOK, 185, 108, 50, 14, "DEFAULT", "Ok")

::method initDialog
  expose list gb pb

  list = self~newListView(200)

  list~insertColumn(0, "Text", 40)
  list~insertColumn(1, "Number", 30)
  do i = 1 to 3
    list~addRow(i, , "Line", i)
  end

  gb = self~newGroupBox(100)
  pb = self~newPushButton(300)

::method onClear unguarded
  expose list gb pb

  text = pb~getText
  select
    when text == "Clear Group Box" then do
      text = "Clear List View"
      r = gb~clientRect
      r~right %= 2
      r~bottom %= 2
      self~clearRect(gb~hwnd, r)
    end
    when text == "Clear List View" then do
      text = "Refresh"
      self~clearRect(list~hwnd, 10, 10, 55, 80)
    end
    otherwise do
      text = "Clear Group Box"
      gb~redrawClient
      list~redrawClient
    end
  end
  -- End select

  pb~setText(text)


]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End dialog object::clearRect() -->


<section id="mthClearWindowRect"><title>clearWindowRect</title>
<indexterm><primary>clearWindowRect</primary></indexterm>
<programlisting>
<![CDATA[
>>--clearWindowRect(--hwnd--)--------------------><


]]>
</programlisting>

<para>The clearWindowRect method erases the draw area
of the given window. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of the window. See <link
linkend="mthGetSelf">getSelf</link>, <link linkend="mthGet">get</link>, or
<link linkend="mthGetControlHandle">getControlHandle</link> for some methods to get a window handle.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example gets the window handle of a dialog control with the symbolic resource ID of
IDC_PB_DONE and then clears the dialog control window:

<programlisting>
<![CDATA[
hwnd = self~getControlHandle(IDC_PB_DONE)
MyDialog~clearWindowRect(hwnd)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthCreateBrushClsDialogExtensions"><title>createBrush</title>
<indexterm><primary>createBrush</primary><secondary>DialogExtensions</secondary></indexterm>
<indexterm><primary>DialogExtensions</primary><secondary>createBrush</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>createBrush</secondary></indexterm>
<programlisting>
<![CDATA[
>>--createBrush(--+---------+--+------------------+--)-------------------------><
                  +--color--+  +-,-brushSpecifier-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">createBrush</emphasis> method creates a logical brush that has the specified style, color,
  and pattern.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    Both arguments are optional. If both arguments are omitted then a hollow brush is created. Otherwise, the arguments
    are:
  <variablelist>
    <varlistentry><term>color [optional]</term>
    <listitem>
    <para>
      The color <link linkend="defColor">number</link>. When this argument is omitted and <emphasis
      role="italic">brushSpecifier</emphasis> is used, the color number defaults to 1.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>brushSpecifier [optional]</term>
    <listitem>
    <para>
      If this argument is omitted a solid brush using the color specified is created.  Otherwise, this argument can be
      the name of a bitmap file, the resource ID of a bitmap compiled in the resource only DLL of a <link
      linkend="clsResDialog">ResDialog</link>, or one of the following keywords. The keywords create a hatched brush. A
      bitmap file name will cause the bitmap to be loaded into memory and then used for the brush. Case is not
      significant in the keywords.
    </para>
    <para>
    <simplelist type='vert' columns='2'>
      <member>UPDIAGONAL  </member>
      <member>CROSS       </member>
      <member>DIAGCROSS   </member>
      <member>DOWNDIAGONAL</member>
      <member>HORIZONTAL  </member>
      <member>VERTICAL    </member>
    </simplelist>
    <variablelist>
      <varlistentry><term>UPDIAGONAL</term>
      <listitem>
      <para>
        A 45-degree upward, left-to-right hatch.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>CROSS</term>
      <listitem>
      <para>
        A horizontal and vertical crosshatch.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>DIAGCROSS</term>
      <listitem>
      <para>
        A 45-degree crosshatch.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>DOWNDIAGONAL</term>
      <listitem>
      <para>
        A 45-degree downward, left-to-right hatch.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>HORIZONTAL</term>
      <listitem>
      <para>
        A horizontal hatch.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>VERTICAL</term>
      <listitem>
      <para>
        A vertical hatch.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    A brush is a bitmap that the operating system uses to paint the interiors of filled shapes. After the programmer
    creates a brush, it can then be selected into a device context using the <link
    linkend="mthObjectToDC">objectToCD</link>() method. When the brush is no longer needed use the <link
    linkend="mthDeleteObject">deleteObject</link>() method to release the operating resources used by the brush.
  </para>
  <para>
    When <emphasis role="italic">brushSpecifier</emphasis> is a non-negative whole number, it is taken to be the
    resource ID of a bitmap compiled in to the resource only DLL of a <computeroutput>ResDialog</computeroutput>. If the
    dialog is not a <computeroutput>ResDialog</computeroutput>, or if there is no matching bitmap in the DLL, the method
    fails. Note that, technically, if the dialog is not a <computeroutput>ResDialog</computeroutput>, the
    <computeroutput>ooDialog.dll</computeroutput> is searched for the bitmap. However, since there are currently no
    bitmaps compiled in to <computeroutput>ooDialog.dll</computeroutput>, the restriction that the dialog must be a
    <computeroutput>ResDialog</computeroutput> is essentially correct.
  </para>
  <para>
    The <emphasis role="italic">createBrush</emphasis> method here is almost identical to the <link
    linkend="mthCreateBrush">createBrush</link> method of the <link
    linkend="clsWindowExtensions">WindowExtensions</link> class. The method documented here is a method of the <link
    linkend="clsDialogExtensions">DialogExtensions</link> class and is therefore inherited only by the <link
    linkend="chpDialogObject">dialog</link> object.
  </para>
  <para>
    In the dialog object, the <emphasis role="italic">createBrush</emphasis> method of the
    <computeroutput>DialogExtensions</computeroutput> class over-rides the <emphasis
    role="italic">createBrush</emphasis> method of the <computeroutput>WindowExtensions</computeroutput> class.
    Therefore, this documentation is essentially the dialog object's <emphasis role="italic">createBrush</emphasis>
    documentation. The <link linkend="mthCreateBrush">createBrush</link> documentation is for the dialog control
    object's <emphasis role="italic">createBrush</emphasis> method.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


<section id="mthDetermineSBPosition"><title>determineSBPosition</title>
<indexterm><primary>determineSBPosition</primary></indexterm>
<programlisting>
<![CDATA[
>>-determineSBPosition(--id--,--posdata--+----------+--+--------+--)-----------><
                                         +-,-single-+  +-,-page-+

]]>
</programlisting>

<para>The determineSBPosition method calculates and sets
the new scroll bar position based on the position data retrieved from the
scroll bar and the step information.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>posdata</term>
<listitem><para>The position information sent with the connected scroll bar event.
</para></listitem></varlistentry>
<varlistentry><term>single</term>
<listitem><para>This number is added (or subtracted if negative) to the current position
for a single step. If omitted, the single step size is 1.
</para></listitem></varlistentry>
<varlistentry><term>page</term>
<listitem><para>This number is added (or subtracted if negative) to the current position
for a page step. If omitted, the page step size is 10.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The new scroll bar position.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example demonstrates how to update the scroll bar position.
Each time the ScrollBarEventHandler is called by an event for scroll bar SB_SIZE,
the position of the scroll bar is calculated and updated. <computeroutput>posdata</computeroutput> is
sent along with the scroll bar event.

<programlisting>
<![CDATA[
   /* Method ScrollBarEventHandler is connected to item SB_SIZE */
::method ScrollBarEventHandler
    use arg posdata, sbwnd
    pos = self~determineSBPosition("SB_SIZE",posdata,1,25)
    return pos

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthDimBitmap"><title>dimBitmap</title>
<indexterm><primary>dimBitmap</primary></indexterm>
<indexterm><primary>DialogExtensions class</primary><secondary>dimBitmap</secondary></indexterm>
<programlisting>
<![CDATA[
>>--dimBitmap(--id-,-bmp-,-cx-,-cy--+---------+--+---------+--+---------+--)---><
                                    +-,-stepX-+  +-,-stepY-+  +-,-steps-+

]]>
</programlisting>

<para>
  Draws a bitmap on the client area of a button control step by step.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the button. May be numeric or symbolic.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>bmp [required]</term>
      <listitem>
      <para>
        A handle to the bitmap loaded with <link linkend="mthLoadBitmap">loadBitmap</link>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>cx, cy [required]</term>
      <listitem>
      <para>
        The width and height of the bitmap.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>stepx, stepy [optional]</term>
      <listitem>
      <para>
        The number of pixels to increment the x and y position of the bitmap at each step. The default is 2 pixels for
        both <emphasis role="italic">cx</emphasis> and <emphasis role="italic">cy</emphasis>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>steps [optional]</term>
      <listitem>
      <para>
        The number of iterations used to draw the bitmap. The bitmap is redrawn at each step. The default is 10.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns 0 on success and -1 if an error is detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method is only intended to be used with button controls. It will fail if the resource ID argument specifies a
    dialog control that is not a button.
  </para>
  <para>
    The <link linkend="ovvUnderlying">underlying</link> Windows dialog must exist to use this method.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect usage is detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


<section id="mthDisplaceBitmap"><title>displaceBitmap</title>
<indexterm><primary>displaceBitmap</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>displaceBitmap</secondary></indexterm>
<programlisting>
<![CDATA[
>>--displaceBitmap(--id--,--x--,--y--)-----------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">displaceBitmap</emphasis> method sets the position of a bitmap within the <link
  linkend="defClientArea">client</link> area of a bitmap button.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
    <varlistentry><term>x [required]</term>
    <listitem>
    <para>
      The x co-ordinate of the top left corner of the bitmap within the client area of the bitmap button.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>y [required]</term>
    <listitem>
    <para>
      The y co-ordinate of the upper left corner of the bitmap within the client area of the bitmap button.
    </para>
    </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Both the x and y coordinates are in pixels and can have negative values.
  </para>
  <para>
    Recall that client area coordinates are specified in relation to the (0, 0) point of the client area of a window.
    Negative values then place the bitmap outside of the client area of the bitmap
  </para>
  <para>
    The <link linkend="mthSetBitmapPosition">setBitmapPosition</link> method is most likely a better method to
    use than the <emphasis role="italic">displaceBitmap</emphasis>.  It accepts eithe a
    <computeroutput>Point</computeroutput> object or the individual x and y coordinates to specify the position of the
    bitmap. <emphasis role="italic">Set position</emphasis> more accurately describes what the method does than
    <emphasis role="italic">displace</emphasis>.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example moves the bitmap within the associated bitmap button 4 screen pixels to the right and 3
    pixels upward. Contrast this with the <link linkend="exampleSetBitmapPosition">setBitmapPosition</link> example:
<programlisting>
<![CDATA[

  parse value self~getBmpDisplacement(IDC_PB_BITMAP1) with dx dy
  if dx <> -1 then do
    dx += 4
    dy -=3
    self~displaceBitmap(IDC_PB_BITMAP1, dx, dy)
  end

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::displaceBitmap() -->


<section id="mthDrawBitmap"><title>drawBitmap</title>
<indexterm><primary>drawBitmap</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>drawBitmap</secondary></indexterm>
<indexterm><primary>DialogExtensions class</primary><secondary>drawBitmap</secondary></indexterm>
<programlisting>
<![CDATA[

>>--drawBitmap(--+-------+--,--id--+-----+--+-----+--+--------+--+--------+---->
                 +--hwnd-+         +-,-x-+ -+-,-y-+ -+-,-bmpX-+  +-,-bmpY-+

>--+---------+--+----------+--)------------------------------------------------><
   +-,-width-+  +-,-height-+

]]>
</programlisting>

<para>
  Draws all, or part of, the bitmap for a bitmap button at the specified position.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>hwnd [optional]</term>
      <listitem>
      <para>
        The window <link linkend="defHandle">handle</link> of the bitmap button. This argument is, and has always been,
        ignored. It is simply retained for backwards compatibility.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the bitmap button. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>x, y [optional]</term>
      <listitem>
      <para>
        The client area <link linkend="defScreenCoordinates">coordinates</link> where the upper left corner of the
        bitmap is to be drawn, in pixels. The default is (0, 0).
      </para>
      </listitem></varlistentry>
      <varlistentry><term>bmpX, bmpY [optional]</term>
      <listitem>
      <para>
        The coordinates in the bitmap for the upper left corner of the portion that is to be drawn. The default is (0,
        0). This, along with the <emphasis role="italic">width</emphasis> and <emphasis role="italic">height</emphasis>
        arguments, can be used to draw only a portion of the bitmap. For instance, to draw only the lower right quadrant
        of the bitmap, this argument could be set to the mid point of the bitmap.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>width [optional]</term>
      <listitem>
      <para>
        The width, starting from ()<emphasis role="italic">bmpX</emphasis>, <emphasis role="italic">bmpY</emphasis>) of
        the bitmap of the portion for the bitmap being drawn. If omitted or 0, the remaining width of the bitmap is
        drawn.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>height [optional]</term>
      <listitem>
      <para>
        The height, starting from ()<emphasis role="italic">bmpX</emphasis>, <emphasis role="italic">bmpY</emphasis>) of
        the bitmap for the portion of the bitmap being drawn. If omitted or 0, the remaining height of the bitmap is
        drawn.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns 0 on success or 1 for error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method is only for bitmaps that have been assigned to a bitmap button through the <link
    linkend="mthInstallBitmapButton">installBitmapButton</link> method. If there is no bitmap assigned to the button
    then 1 is returned.
  </para>
  <para>
    Unlike the <link linkend="mthSetBitmapPosition">setBitmapPosition</link> method, which permanently sets the
    position for the bitmap, the <emphasis role="italic">drawBitmap</emphasis> immediately draws the bitmap, or part of
    it, at the specified position. If the button needs to be redrawn, maybe because the window was covered and then
    uncovered, the bitmap is drawn at the position set with <emphasis role="italic">setBitmapPosition</emphasis>.
    <emphasis role="italic">drawBitmap</emphasis> is used by <link
    linkend="mthScrollBitmapFromTo">scrollBitmapFromTo</link>, for example.
  </para>
  <para>
    You can use the <emphasis role="italic">drawBitmap</emphasis> method to animate a bitmap by providing a bitmap that
    contains several images and use the offset and extension arguments to display a single image of the bitmap.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::drawBitmap() -->


<section id="mthDrawButton"><title>drawButton</title>
<indexterm><primary>drawButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-drawButton(--id--)----------------------------><


]]>
</programlisting>

<para>The drawButton method draws the given button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthEndAsyncExecution"><title>endAsyncExecution</title>
<indexterm><primary>endAsyncExecution</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>endAsyncExecution</secondary></indexterm>
<indexterm><primary>DialogExtensions</primary><secondary>endAsyncExecution</secondary></indexterm>
<programlisting>
<![CDATA[
>>--endAsyncExecution----------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">endAsyncExecution</emphasis> method is used to end the asynchronous execution of a dialog
  started using the <link linkend="mthExecuteAsync">executedAsync</link> method. The <emphasis
  role="italic">endAsyncExecution</emphasis> method does not return until the user closes the dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The method does not take any arguments.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return values are the same as for the <link linkend="mthExecute">execute</link> method and are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        Some error ocurred, the dialog was not executed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
      <para>
        The user terminated the dialog using an ok command.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>2</term>
      <listitem>
      <para>
        The user terminated the dialog using a cancel comamnd.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Every dialog that is started using the <link linkend="mthExecuteAsync">executeAsync</link> method must have a
    matching <emphasis role="italic">endAsyncExecution</emphasis> invocation. This is the only way to ensure the proper
    termination of the dialog. This does not apply of course if the invocation of <emphasis
    role="italic">executeAsync</emphasis> failed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The <link linkend="exampleExecuteAsync">executeAsync</link> example shows the proper use of the <emphasis
  role="italic">endAsyncExecution</emphasis> method.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::endAsyncExecution() -->


<section id="mthExecuteAsync"><title>executeAsync</title>
<indexterm><primary>executeAsync</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>executeAsync</secondary></indexterm>
<indexterm><primary>DialogExtensions</primary><secondary>executeAsync</secondary></indexterm>
<programlisting>
<![CDATA[
>>--executeAsync(--+-----------+--+---------------+--+---------+--)------------><
                   +--ignored--+  +-,--showOption-+  +-,--icon-+
]]>
</programlisting>

<para>
  The <emphasis role="italic">executeAsync</emphasis> method creates the <link linkend="ovvUnderlying">underlying</link>
  Windows dialog, starts it executing, and shows it in the same way as the <link linkend="mthExecute">execute</link>
  method does. However, <emphasis role="italic">executeAsync</emphasis> does not wait for the dialog to be closed,
  rather it returns immediately. This allows the programmer to execute other Rexx statements asynchronously with the
  dialog execution. The <link linkend="mthEndAsyncExecution">endAsyncExecution</link> method is used to halt the
  asynchronously execution and wait for the dialog to be closed.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>ignored [optional]</term>
      <listitem>
      <para>
        This argument is completely ignored. It is a hold over from older versions of ooDialog, versions prior to 4.0.0.
        However, for backwards program compatibility the argument must be returned. The programmer should omitt the
        argument altogether, or could put in any value as a place holder.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>showOption [optional]</term>
      <listitem>
      <para>
        Zero or one of the following keywords to specify how the dialog is shown. This keyword is used in the automatic
        invocation of the <link linkend="mthShowClsPlainBaseDialog">show</link> method. Case is not significant. If this
        argument is omitted, the NORMAL keyword is used:
        <variablelist>
          <varlistentry><term>NORMAL</term>
          <listitem>
          <para>
            Makes the dialog visible in its default position and window size. This has the effect of restoring the dialog size
            and position if it is minimized or maximized. This is the default if the argument is omitted.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>DEFAULT</term>
          <listitem>
          <para>
            DEFAULT is an alias for NORMAL. The two keywords are functionally identical.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>SHOWTOP</term>
          <listitem>
          <para>
            Makes the dialog visible and the topmost window.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>HIDE</term>
          <listitem>
          <para>
            Makes the dialog invisible.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>MIN</term>
          <listitem>
          <para>
            Minimizes the dialog and activates the next window in the window order.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>MAX</term>
          <listitem>
          <para>
            Maximizes, and makes visible if necessary, the dialog.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>INACTIVE</term>
          <listitem>
          <para>
            Makes the dialog visible without changing the active window.  When the NORMAL keyword is used, the dialog is shown
            and becomes the active window. The INACTIVE keyword makes the dialog visible without changing the focuse from the
            current active window.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>RESTORE</term>
          <listitem>
          <para>
            Makes the dialog visible and restores it to its original size and position if it was minimized or maximized. An
            application should specify this flag when restoring a minimized window.
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      </listitem></varlistentry>
      <varlistentry><term>icon [optional]</term>
      <listitem>
      <para>
        The resource ID of the <link linkend="defDialogIcon">dialog's icon</link>. May be numeric or <link
        linkend="defSymbolicID">symbolic</link>.  If an icon ID is not supplied, the default ooDialog icon will be used.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return values are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        The dialog was created and shown without problems. The dialog is currently executing.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
      <para>
        An error occurred, the dialog was not created and is not executing. Do not invoke <link
        linkend="mthEndAsyncExecution">endAsyncExecution</link> in this case.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Although any of the show keywords can be used, for the <emphasis role="italic">executeAsync</emphasis> method the
    SHOWTOP, HIDE, and MAX keywords make the most sense. SHOWTOP is the usual keyword. Rather than use the HIDE keyword,
    it is more practical to simply create the dialog <emphasis role="bold">without</emphasis> the VISIBLE style.
  </para>
  <para>
    If another ooDialog dialog has been started by the Rexx program, it is disabled when <emphasis
    role="italic">executeAsync</emphasis> is invoked. This in effect makes the dialog a <link
    linkend="defModalModeless">modal</link> dialog. To start a <emphasis role="italic">modeless</emphasis> dialog use
    the <link linkend="mthPopup">popup</link> or <link linkend="mthPopupAsChild">popupAsChild</link> methods.
  </para>
  </listitem></varlistentry>
  <varlistentry id="exampleExecuteAsync"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example shows an application that creates a <emphasis role="italic">tool pallette</emphasis> dialog. The tool
    pallette dialog can not be executed until its underlying owner dialog has been created. So the main dialog is
    started using <emphasis role="italic">executeAsync</emphasis>, then the pallette dialog is executed, and finally
    <link linkend="mthEndAsyncExecution">endAsyncExecution</link> is used to wait for the main dialog to close:
<programlisting>
<![CDATA[

  .application~useGlobalConstDir("O", "useTools.h")

  dlg = .MainDialog~new

  dlgTool = .ToolPaletteDlg~new
  dlgTool~ownerDialog = dlg

  dlg~executeAsync("SHOWTOP", IDI_DLG_OOREXX)

  dlgTool~popup("SHOWTOP")

  dlg~endAsyncExecution

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::executeAsync() -->


<section id="mthFreeControlDC"><title>freeControlDC</title>
<indexterm><primary>freeControlDC</primary></indexterm>
<programlisting>
<![CDATA[
>>--freeButtonDC(--id--,--dc--)------------------><


]]>
</programlisting>

<para>The freeControlDC method releases the device context
of a control. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The resource ID of the control.
</para></listitem></varlistentry>
<varlistentry><term>dc</term>
<listitem><para>The device context previously received by the <link linkend="mthGetControlDC">getControlDC</link> method
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthFreeWindowDC"><title>freeWindowDC</title>
<indexterm><primary>freeWindowDC</primary></indexterm>
<programlisting>
<![CDATA[
>>--freeWindowDC(--hwnd--,--dc--)----------------><


]]>
</programlisting>

<para>The freeWindowDC method frees the device context
of a window. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The window handle
</para></listitem></varlistentry>
<varlistentry><term>dc</term>
<listitem><para>The device context previously received by the <link linkend="h001062">GetWindowDC</link> method
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthGetBitmapPosition"><title>getBitmapPosition</title>
<indexterm><primary>getBitmapPosition</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>getBitmapPosition</secondary></indexterm>
<indexterm><primary>DialogExtensions class</primary><secondary>getBitmapPosition</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getBitmapPosition(--id--,--pos--)------------><

]]>
</programlisting>

<para>
  Retrieves the postion in client <link linkend="defScreenCoordinates">coordinates</link>  of the upper left corner of a
  bitmap within a bitmap button.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the bitmap button. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pos</term>
    <listitem>
    <para>
      A <link linkend="clsPoint">point</link> object. On a successful return the point object is updated with the
      position of the bitmap. On an error return, the point object is left unchanged.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns <computeroutput>.true</computeroutput> on success and <computeroutput>.false</computeroutput> on error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Recall that client area coordinates are relative to the (0, 0) point of the client area of a window. Both or either
    of the coordinates can be negative. A negative x will place the bitmap to the left of the edge of the button. A
    negative y will place the bitmap above the top of the bitmap.
  </para>
  <para>
    This method is only for bitmaps that have been assigned to a bitmap button through the <link
    linkend="mthInstallBitmapButton">installBitmapButton</link> method. If there is no bitmap assigned to the button
    then <computeroutput>.false</computeroutput> is returned.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::getBitmapPosition() -->


<section id="mthGetBitmapSize"><title>getBitmapSize</title>
<indexterm><primary>getBitmapSize</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>getBitmapSize</secondary></indexterm>
<indexterm><primary>DialogExtensions class</primary><secondary>getBitmapSize</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getBitmapSize(--id--)------------------------><

]]>
</programlisting>

<para>
  Retrieves the size of the bitmap for a bitmap button as a <link linkend="clsSize">size</link> object.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single arguments is:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the bitmap button. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    On success, returns the bitmap size. On failure returns -1.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    If <emphasis role="italic">id</emphasis> is not the resource ID of a bitmap button, or if the bitmap for the button
    can not be located, the negative one is returned.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example retrieves the size of the bitmap for the bitmap button with symbolic resource ID of IDC_PB_TICKET:
<programlisting>
<![CDATA[

  size = self~getBitmapSize(IDC_PB_TICKET)
  say 'Size for the ticket push button bitmap:' size~width 'by' size~height

  /* Output might be:

     Size for the ticket push button bitmap: 152 by 178

  */
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::getBitmapSize() -->


<section id="mthGetBitMapSizeX"><title>getBitmapSizeX</title>
<indexterm><primary>getBitmapSizeX</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>getBitmapSizeX</secondary></indexterm>
<indexterm><primary>DialogExtensions</primary><secondary>getBitmapSizeX</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getBitmapSizeX(--id--)-----------------------><

]]>
</programlisting>

<para>
  Gets the width of the bitmap assigned to this bitmap button in pixels.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the bitmap button. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    On success, the width of the bitmap for the bitmap button in pixels, on error -1.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method is only for bitmaps that have been assigned to a bitmap button through the <link
    linkend="mthInstallBitmapButton">installBitmapButton</link> method. If there is no bitmap assigned to this button
    then -1 is returned.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::getBitMapSizeX() -->


<section id="mthGetBitMapSizeY"><title>getBitmapSizeY</title>
<indexterm><primary>getBitmapSizeY</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>getBitmapSizeY</secondary></indexterm>
<indexterm><primary>DialogExtensions</primary><secondary>getBitmapSizeY</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getBitmapSizeY(--id--)-----------------------><

]]>
</programlisting>

<para>
  Gets the height of the bitmap assigned to this bitmap button in pixels.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the bitmap button. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    On success, the height of the bitmap for the bitmap button in pixels, on error -1.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method is only for bitmaps that have been assigned to a bitmap button through the <link
    linkend="mthInstallBitmapButton">installBitmapButton</link> method. If there is no bitmap assigned to this button
    then -1 is returned.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::getBitMapSizeX() -->


<section id="mthGetBmpDisplacement"><title>getBmpDisplacement</title>
<indexterm><primary>getBmpDisplacement</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>getBmpDisplacement</secondary></indexterm>
<indexterm><primary>DialogExtensions class</primary><secondary>getBmpDisplacement</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getBmpDisplacement(--id--)-------------------><

]]>
</programlisting>

<para>
  Returns a string containing the <link linkend="defClientArea">client</link> coordinates of the bitmap in a bitmap
  button.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the bitmap button. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    A string with the X position and then the Y position of the bitmap, in pixles. The X and Y coordinates are separated
    by a blank. On error, -1 is returned.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Recall that client area coordinates are relative to the (0, 0) point of the client area of a window. Both or either
    of the coordinates can be negative.
  </para>
  <para>
    This method is only for bitmaps that have been assigned to a bitmap button through the <link
    linkend="mthInstallBitmapButton">installBitmapButton</link> method. If there is no bitmap assigned to the button
    then -1 is returned.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This following example shows how to use the <emphasis role="italic">getBmpDisplacement</emphasis> method:

<programlisting>
<![CDATA[
  bmpPos = self~getBmpDisplacement(IDC_PB_TICKET)
  parse var bmpPos x y
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::getBmpDisplacement() -->


<section id="mthGetControlDC"><title>getControlDC</title>
<indexterm><primary>getControlDC</primary></indexterm>
<programlisting>
<![CDATA[
>>--getControlDC(--id--)--------------------------><


]]>
</programlisting>

<para>The getControlDC method returns the device context
of a dialog control Do not forget to free the device context after you have completed
the operations (see <link linkend="mthFreeControlDC">freeControlDC</link>). </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The resource ID of the dialog control. May be numeric or symbolic.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="getControlRect"><title>getControlRect</title>
<indexterm><primary>getControlRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~getControlRect(--id--)--------------------------><


]]>
</programlisting>

<para>The getControlRect method returns the size and position
of the given button. The four values (left, top, right, bottom) are returned
in one string separated by blanks. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthGetListItemHeight"><title>getListItemHeight</title>
<indexterm><primary>getListItemHeight</primary></indexterm>
<programlisting>
<![CDATA[
>>-getListItemHeight(--id--)---------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">getListItemHeight</emphasis> method returns the height of the items in a list box, in
  dialog units.
</para>
<para>
  The value is usually <link linkend="ovvInaccurate">incorrect</link> because it is calculated using <link
  linkend="atrFactorX">factorX</link>. The programmer is advised to use the <link
  linkend="mthGetListItemHeightPx">getListItemHeightPx</link> method instead, which will return the corrct height of
  a list item.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box of which you want to know the item height.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The height of the list box items, in dialog units.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthGetListItemHeightPx"><title>getListItemHeightPx</title>
<indexterm><primary>getListItemHeightPx</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>getListItemHeightPx</secondary></indexterm>
<indexterm><primary>DialogExtensions class</primary><secondary>getListItemHeightPx</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getListItemHeightPx(--id--)------------------><

]]>
</programlisting>

<para>
  Gets the height, in pixels, of an indvidual item in a <link linkend="clsListBox">ListBox</link> control.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single arguments is:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the list box. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns the height of each item in the list box, in pixels.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::getListItemHeightPx() -->


<section id="mthGetListWidth"><title>getListWidth</title>
<indexterm><primary>getListWidth</primary></indexterm>
<programlisting>
<![CDATA[
>>--getListWidth(--id--)-------------------------><

]]>
</programlisting>

<para>
  The getListWidth method returns the scrollable width of a list box, in dialog units.
</para>
<para>
  The value is usually <link linkend="ovvInaccurate">incorrect</link> because it is calculated using <link
  linkend="atrFactorX">factorX</link>. The programmer is advised to use the <link
  linkend="mthGetListWidthPx">getListWidthPx</link> method instead, which will return the corrct width in pixels.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box of which you want to know the scrollable width.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The width of the scrollable area of the list box, in dialog units.
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthGetListWidthPx"><title>getListWidthPx</title>
<indexterm><primary>getListWidthPx</primary></indexterm>
<indexterm><primary>DialogExtensions class</primary><secondary>getListWidthPx</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getListWidthPx(--id--)-----------------------><

]]>
</programlisting>

<para>
  Retrieves the width, in pixels, that a list box can be scrolled horizontally, if the list box has a horizontal scroll
  bar.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single arguments is:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the list box. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The scrollable width of the list box, in pixels
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::getListWidthPx() -->


<section id="mthGetMouseCapture"><title>getMouseCapture</title>
<indexterm><primary>getMouseCapture</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>getMouseCapture</secondary></indexterm>
<indexterm><primary>DialogExtensions</primary><secondary>getMouseCapture</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getMouseCapture------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">getMouseCapture</emphasis> method retrieves the window handle, if any, that currently has
  captured the mouse. The window that has captured the mouse recieves all mouse input regardless of whether the mouse
  cursor is within the borders of the window or not.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    This method takes no arguments.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The window handle to the dialog or dialog control that has captured the mouse, or 0 if the mouse is not captured.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The mouse capture functions work with windows of the same thread. For ooDialog, this means the dialog window and the
    dialog control windows that belong to this dialog. Getting the mouse capture, only gets the window handle of this
    dialog, or one of its controls. If 0 is returned, it means that no window in this dialog's thread has the mouse
    capture. However, some window in another thread could have the the mouse capture.
  </para>
  <para>
    ooDialog has always had the functionality to set the mouse capture to a dialog control window. However, it is
    difficult to imagine any scenario, in ooDialog, where this could be of any use.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthInstallAnimatedButton"><title>installAnimatedButton</title>
<indexterm><primary>installAnimatedButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-installAnimatedButton(--id,--+-------+-+--------+-,-bmpF-+--------+-,-mX-,-mY-->
                                +-,-mth-+ +-,-cls--+        +-,-bmpT-+

>--+---------+--+---------+--,--delay---+--------+--+--------+--)-----------------><
   +-,-sizeX-+  +-,-sizeY-+             -,+-xNow-+  +-,-yNow-+


]]>
</programlisting>

<para>The installAnimatedButton method installs an animated
button and runs it concurrently with the main activity. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
<varlistentry><term>mth</term>
<listitem><para>The name of a method within the same class. This method is called each
time the button is clicked.
</para></listitem></varlistentry>
<varlistentry><term>cls</term>
<listitem><para>The class that controls the animation (default is <link linkend="anibut">AnimatedButton Class</link>)
</para></listitem></varlistentry>
<varlistentry><term>bmpF</term>
<listitem><para>The ID of the first bitmap in the animation sequence within a binary
resource. It can also be the name of an array stored in the .local directory
containing handles of bitmaps to be animated and bmpTo is omitted. See <link linkend="mthLoadBitmap">loadBitmap</link> for how to get bitmap
handles. The array starts at index 1.
</para></listitem></varlistentry>
<varlistentry><term>bmpT</term>
<listitem><para>The ID of the last bitmap in the animation sequence within a binary
resource. If omitted, bmpFrom is expected to be the
name of an array stored in .local that holds the bitmap handles of the bitmaps
that are to be animated.
</para></listitem></varlistentry>
<varlistentry><term>mX, mY</term>
<listitem><para>Size of one move (in pixels)
</para></listitem></varlistentry>
<varlistentry><term>sizeX, sizeY</term>
<listitem><para>Size of the bitmaps (if omitted, the size of the bitmaps is retrieved)
</para></listitem></varlistentry>
<varlistentry><term>delay</term>
<listitem><para>The time in milliseconds the method waits after each move
</para></listitem></varlistentry>
<varlistentry><term>xNow, yNow</term>
<listitem><para>The starting position of the bitmap
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example defines and runs an animated button. The example
loads ten bitmaps (&quot;anibmp1.bmp&quot; to &quot;anibmp10.bmp&quot;) into memory
and stores them into the array "My.Bitmaps" that is stored in the .local directory.
The name "My.Bitmaps" is specified as the <computeroutput>bmpfrom</computeroutput> and <computeroutput>bmpto</computeroutput> is omitted. After the dialog execution the bitmaps are removed from
memory again. The sample also uses a different animation class (".MyAnimation")
which subclasses from .AnimatedButton and overrides method HitRight which
plays a tune each time the animated bitmap hits the right border.
</para></listitem></varlistentry>
</variablelist>

<programlisting>
<![CDATA[
/* store array in .local */
.Local["My.Bitmaps"] = .array~new(10)
/* load 10 bitmaps into .local array */
do i= 1 to 10
  .Local["My.Bitmaps"][i] = Dialog~loadBitmap("anibmp"i".bmp")
  /* you could also use .My.Bitmaps[i] =  ... */
end

/* connect bitmap sequence and .MyAnimated class with button IDANI */
Dialog~installAnimatedButton("IDANI", ,.MyAnimation,"My.Bitmaps", ,1,1, , ,100)

...
Dialog~execute
...

/* Free the bitmap previously loaded */
do bmp over .Local["My.Bitmaps"] /* You could also use do bmp over .My.Bitmaps */
   Dialog~removeBitmap(bmp)
end


::class MyAnimation subclass AnimatedButton

/* play sound.wav whenever the bitmap hits the right border */

::method HitRight
   ret = Play("sound.wav", yes)
   return self~super:hitright
]]>
</programlisting>
</section>

<section id="mthInstallBitmapButton"><title>installBitmapButton</title>
<indexterm><primary>installBitmapButton</primary></indexterm>
<programlisting>
<![CDATA[
>>--installBitmapButton(-id-+-------+-,-bN--+------+-+------+-+-------+-+--------+-)-><
                            +-,-mth-+       +-,-bF-+ +-,-bS-+ +-,-bD--+ +-,-opts-+

]]>
</programlisting>

<para>The installBitmapButton method connects a bitmap
and a method with a push button. The given bitmaps are displayed instead of
a Windows push button.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button.
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent to this object when the button is clicked.
</para></listitem></varlistentry>
<varlistentry><term>bN</term>
<listitem><para>The name (alphanumeric), resource ID (numeric), or handle (<emphasis role="italic">INMEMORY</emphasis> option) of a bitmap file. This bitmap is displayed when the button is
not selected, not focused, and not disabled. It is used for the other button
states in case the other arguments are omitted.
</para></listitem></varlistentry>
<varlistentry><term>bF</term>
<listitem><para>This bitmap is displayed when the button is focused. The focused button
is activated when the Enter key is pressed.
</para></listitem></varlistentry>
<varlistentry><term>bS</term>
<listitem><para>This bitmap is displayed while the button is clicked and held.
</para></listitem></varlistentry>
<varlistentry><term>bD</term>
<listitem><para>This bitmap is displayed when the button is disabled.
</para></listitem></varlistentry>
<varlistentry><term>opts</term>
<listitem><para>One of the following keywords:
<variablelist>
<varlistentry><term>FRAME</term>
<listitem><para>Draws a frame around the button.  When using this option, the bitmap
button behaves like a normal Windows button, except that a bitmap is
shown instead of a text.
</para></listitem></varlistentry>
<varlistentry><term>USEPAL</term>
<listitem><para>Stores the colors of the bitmap file as the system color palette.  This
option is needed when the bitmap was created with a palette other than the
default Windows color palette. Use it for one button only,
because only one color palette can be active at any time. <emphasis role="italic">USEPAL</emphasis> is
invalid for a bitmap loaded from a DLL.
</para></listitem></varlistentry>
<varlistentry><term>INMEMORY</term>
<listitem><para>This option must be used if the named bitmaps are already loaded into
memory by using the <link linkend="mthLoadBitmap">loadBitmap</link> method. In this case, bmpNormal, bmpFocused, bmpSelected, and bmpDisabled specify a bitmap handle instead of a file.
</para></listitem></varlistentry>
<varlistentry><term>STRETCH</term>
<listitem><para>If this option is specified and the extent of the bitmap is smaller
than the extent of the button rectangle, the bitmap is adapted to match the
extent of the button. STRETCH has no effect for bitmaps
loaded through a DLL.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example connects a button with four bitmaps and a method:

<programlisting>
<![CDATA[
      .
      .
      .
::method initDialog
  self~installBitmapButton(204, "BmpButtonClicked", ,
                           "AddBut_n.bmp", "AddBut_f.bmp", ,
                           "AddBut_s.bmp", "AddBut_d.bmp", "FRAME")
::method BmpButtonClicked
      .
      .
      .
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
<para>See also method <link linkend="mthChangeBitmapButton">changeBitmapButton</link>.</para>
</section>


<section id="ismousebuttondown"><title>IsMouseButtonDown</title>
<indexterm><primary>IsMouseButtonDown</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~IsMouseButtonDown(--"--+-LEFT---+--"--)------><
                                         +-MIDDLE-+
                                         +-RIGHT--+


]]>
</programlisting>

<para>The IsMouseButtonDown method retrieves information
on whether a mouse button is pressed.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>button</term>
<listitem><para>The location of the mouse button you are interested in.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The button is not being pressed.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The button is being pressed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthReleaseMouseCapture"><title>releaseMouseCapture</title>
<indexterm><primary>releaseMouseCapture</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>releaseMouseCapture</secondary></indexterm>
<indexterm><primary>DialogExtensions</primary><secondary>releaseMouseCapture</secondary></indexterm>
<programlisting>
<![CDATA[
>>--releaseMouseCapture--------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">releaseMouseCapture</emphasis> method releases the mouse capture from this dialog, or the
  dialog control belonging to the dialog, which had previously had <link linkend="mthCaptureMouse">captured</link> the
  mouse. Normal mouse input processing is then resotred.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    This method takes no arguments.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem><para>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      The mouse capture was released.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      Releasing the mouse capture failed, the <computeroutput>.SystemErrorCode</computeroutput> will be set.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The mouse capture functions work with windows of the same thread. For ooDialog, this is the dialog window and the
    dialog control windows that belong to this dialog. Releasing the mouse capture, releases the capture from any dialog
    control window within the dialog, or the dialog window itself.
  </para>
  <para>
    ooDialog has always had the functionality to set the mouse capture to a dialog control window. However, it is
    difficult to imagine any scenario, in ooDialog, where this could be of any use.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::releaseMouseCapture() -->


<section id="mthScrollBitmapFromTo"><title>scrollBitmapFromTo</title>
<indexterm><primary>scrollBitmapFromTo</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>scrollBitmapFromTo</secondary></indexterm>
<indexterm><primary>DialogExtensions class</primary><secondary>scrollBitmapFromTo</secondary></indexterm>
<programlisting>
<![CDATA[

>>--scrollBitmapFromTo(--id--,--fromX--,--fromY--,--toX--,--toY---------------->


>--+---------+--+---------+--+---------+--+------------+--)--------------------><
   +-,-stepX-+  +-,-stepY-+  +-,-delay-+  +-,-displace-+
]]>
</programlisting>

<para>
  Scrolls, (moves,) a bitmap from one position to another within a bitmap button.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the bitmap button. May be numeric or <link linkend="defSymbolicID">symbolic</link>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>fromX, fromY [required]</term>
      <listitem>
      <para>
        The starting position, in client <link linkend="defScreenCoordinates">coordinates</link>, where the upper
        left corner of the bitmap is first drawn. This is specified in pixels.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>toX, toY [required]</term>
      <listitem>
      <para>
        The ending position, in client <link linkend="defScreenCoordinates">coordinates</link>, where the upper
        left corner of the bitmap is drawn last. This is specified in pixels.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>stepX, stepY [optional]</term>
      <listitem>
      <para>
        The amount, in pixels, that the bitmap is moved for each step. For each move, <emphasis
        role="italic">stepX</emphasis> is the amount the bitmap is moved horizontally and <emphasis
        role="italic">stepY</emphasis> is the amount the bitmap is vertically. Either or both can be negative. The
        default for both is 0. However, they can not both be 0, or both omitted.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>delay [optional]</term>
      <listitem>
      <para>
        The time in milliseconds this method waits after each move before doing the next move. This determines the speed
        at which the bitmap moves. The default is 0, which means there is no delay between each move of the bitmap.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>displace [optional]</term>
      <listitem>
      <para>
        If <computeroutput>.true</computeroutput> the internal position of the bitmap is updated after each incremental
        move. <link linkend="mthSetBitmapPosition">setBitmapPosition</link> is called after each step
        to adjust the bitmap position. If the dialog is redrawn, the bitmap is shown at the correct position. The
        default is <computeroutput>.true</computeroutput>.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns 0 on success and 1 on error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method is only for bitmaps that have been assigned to a bitmap button through the <link
    linkend="mthInstallBitmapButton">installBitmapButton</link> method. If there is no bitmap assigned to the button
    then 1 is returned.
  </para>
  <para>
    Scrolling is done by positioning the bitmap and then drawing it. After the bitmap is drawn, it is repositioned
    using the <emphasis role="italic">stepX</emphasis> and <emphasis role="italic">stepY</emphasis> arguments and drawn
    again. This is repeated until the bitmap reaches the (<emphasis role="italic">toX</emphasis>, <emphasis
    role="italic">toY</emphasis>) ending position.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::scrollBitmapFromTo() -->


<section id="mthScrollButton"><title>scrollButton</title>
<indexterm><primary>scrollButton</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>scrollButton</secondary></indexterm>
<indexterm><primary>DialogExtensions class</primary><secondary>scrollButton</secondary></indexterm>
<programlisting>
<![CDATA[
>>--scrollButton(--id--,--xPos--,--yPos--,--lft--,--top--,--rght--,--bttm--)---><

]]>
</programlisting>

<para>
  Moves the specified rectangle within the button and redraws the uncovered area with the button background color. This
  method is used to move bitmaps within bitmap buttons.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the button. May be numeric or symbolic.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>xPos, yPos [required]</term>
      <listitem>
      <para>
        The client area <link linkend="defScreenCoordinates">coordinates</link> of the new position for the upper left
        corner of the specified rectangle. The coordinates are specified in pixels.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>lft, top, rght, bttm [required]</term>
      <listitem>
      <para>
        The client area <link linkend="defScreenCoordinates">coordinates</link> of the upper left and bottom right
        corners of the rectangular area to be moved. The coordinates are specified in pixels.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns 0 on success and 1 on error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method is only intended to be used with button controls. It will fail if the resource ID argument specifies a
    dialog control that is not a button.
  </para>
  <para>
    The <link linkend="ovvUnderlying">underlying</link> Windows dialog must exist to use this method.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect usage is detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::scroll() -->


<section id="mthScrollInControl"><title>scrollInControl</title>
<indexterm><primary>scrollInControl</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>scrollInControl</secondary></indexterm>
<indexterm><primary>DialogExtensions class</primary><secondary>scrollInControl</secondary></indexterm>
<programlisting>
<![CDATA[
>>--scrollInControl(--id-,-text--+--------+--+--------+--+--------+--+-----+---->
                                 +-,-font-+  +-,-size-+  +-,-opts-+  +-,-y-+

>--+--------+--+---------+--+---------+----------------------------------------><
   +-,-step-+  +-,-sleep-+  +-,-color-+

]]>
</programlisting>

<para>
  Scrolls text in a dialog control using the specified font.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource id of the dialog control where the text will be scrolled. May be numeric or <link
        linkend="defSymbolicID">symbolic</link>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>text [required]</term>
      <listitem>
      <para>
        A text string that is displayed and scrolled.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>font [optional]</term>
      <listitem>
      <para>
        The name of the font used to write the text. If omitted, the System font is used.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>size [optional]</term>
      <listitem>
      <para>
        The size of the font used to write the text. If omitted, the default is 10.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>opts [optional]</term>
      <listitem>
      <para>
        A list of 0 or more of the following keywords separated by spaces, case is not significant. These options control
        aspects of the font and how the font is written. If this argument is omitted a normal font is used, i.e., not
        bolded, underlined, italicized, or striked out.
      </para>
      <para>
        <simplelist type='vert' columns='3'>
          <member>THIN       </member>
          <member>EXTRALIGHT </member>
          <member>LIGHT      </member>
          <member>MEDIUM     </member>
          <member>SEMIBOLD   </member>
          <member>EXTRABOLD  </member>
          <member>HEAVY      </member>
          <member>BOLD       </member>
          <member>UNDERLINE  </member>
          <member>ITALIC     </member>
          <member>STRIKEOUT  </member>
        </simplelist>
        <variablelist>
          <varlistentry><term>THIN</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 100.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>EXTRALIGHT</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 200.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>LIGHT</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 300.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>MEDIUM</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 500.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>SEMIBOLD</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 600.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>BOLD</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 700.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>EXTRABOLD</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 800.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>HEAVY</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 900.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>UNDERLINE</term>
          <listitem>
          <para>
            An underline font is used.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>ITALIC</term>
          <listitem>
          <para>
            An italic font is used.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>STRIKEOUT</term>
          <listitem>
          <para>
            A strike out font is used.
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      </listitem></varlistentry>
      <varlistentry><term>displaceY</term>
      <listitem>
      <para>
        The Y client area <link linkend="defScreenCoordinates">coordinate</link> of the text. The default is 0. This
        argument is used to shift the text down from the top edge of the control, if needed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>step</term>
      <listitem>
      <para>
        The amount of screen pixels that the text is moved in each iteration. The default is 4.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>sleep</term>
      <listitem>
      <para>
        The time, in milliseconds, that the program waits after each iteration. This determines the scrolling speed. The
        default is 10 milliseconds.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>color</term>
      <listitem>
      <para>
        The color index used for the text. The default is 0, which is black.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns 0 on success and 1 on error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The text is scrolled from right to left. Scrolling is done by repeatedly rewriting the text at <emphasis
    role="italic">step</emphasis> pixels to the left in the client area of the dialog control, starting at the right
    edge of the control. When the writing postion reaches the left edge of the control, the rewriting ends.
  </para>
  <para>
    The <emphasis role="italic">font</emphasis>, <emphasis role="italic">size</emphasis>, <emphasis
    role="italic">style</emphasis>, and <emphasis role="italic">color</emphasis> arguments specify a font for the text
    being scrolled. The ooDialog framework requests a font to match this description from the font manager.
  </para>
  <para>
    If the method is started concurrently, call it a second time with no arguments to stop the scrolling.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example scrolls the string "Hello world!" from left to right within the dialog control window with the
    symbolic resource id of IDC_PB_SCROLLER. The text is located 2 pixels below the top of the client area, one move is
    3 screen pixels, and the delay time after each movement is 15 ms.

<programlisting>
<![CDATA[

self~start(scrollInControl, IDC_PB_SCROLLER, "Hello world!", "Arial", 36,   -
                            "BOLD ITALIC", 2, 3, 15, 4)

]]>
</programlisting>

  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions:scrollInControl() -->



<section id="mthScrollText"><title>scrollText</title>
<indexterm><primary>scrollText</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>scrollText</secondary></indexterm>
<indexterm><primary>DialogExtensions class</primary><secondary>scrollText</secondary></indexterm>
<programlisting>
<![CDATA[
>>--scrollText(--hwnd-,-text--+--------+--+--------+--+--------+--+-----+------>
                              +-,-font-+  +-,-size-+  +-,-opts-+  +-,-y-+

>--+--------+--+---------+--+---------+----------------------------------------><
   +-,-step-+  +-,-sleep-+  +-,-color-+

]]>
</programlisting>

<para>
  Scrolls text in the window using the specified font.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>hwnd [required]</term>
      <listitem>
      <para>
        The window <link linkend="defHandle">handle</link> where the text will be scrolled.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>text [required]</term>
      <listitem>
      <para>
        A text string that is displayed and scrolled.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>font [optional]</term>
      <listitem>
      <para>
        The name of the font used to write the text. If omitted, the System font is used.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>size [optional]</term>
      <listitem>
      <para>
        The size of the font used to write the text. If omitted, the default is 10.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>opts [optional]</term>
      <listitem>
      <para>
        A list of 0 or more of the following keywords separated by spaces, case is not significant. These options control
        aspects of the font and how the font is written. If this argument is omitted a normal font is used, i.e., not
        bolded, underlined, italicized, or striked out.
      </para>
      <para>
        <simplelist type='vert' columns='3'>
          <member>THIN       </member>
          <member>EXTRALIGHT </member>
          <member>LIGHT      </member>
          <member>MEDIUM     </member>
          <member>SEMIBOLD   </member>
          <member>EXTRABOLD  </member>
          <member>HEAVY      </member>
          <member>BOLD       </member>
          <member>UNDERLINE  </member>
          <member>ITALIC     </member>
          <member>STRIKEOUT  </member>
        </simplelist>
        <variablelist>
          <varlistentry><term>THIN</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 100.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>EXTRALIGHT</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 200.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>LIGHT</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 300.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>MEDIUM</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 500.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>SEMIBOLD</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 600.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>BOLD</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 700.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>EXTRABOLD</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 800.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>HEAVY</term>
          <listitem>
          <para>
            The weight of the font in a range of 0 through 1000 will be 900.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>UNDERLINE</term>
          <listitem>
          <para>
            An underline font is used.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>ITALIC</term>
          <listitem>
          <para>
            An italic font is used.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>STRIKEOUT</term>
          <listitem>
          <para>
            A strike out font is used.
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      </listitem></varlistentry>
      <varlistentry><term>displaceY</term>
      <listitem>
      <para>
        The Y client area <link linkend="defScreenCoordinates">coordinate</link> of the text. The default is 0. This
        argument is used to shift the text down from the top edge of the window, if needed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>step</term>
      <listitem>
      <para>
        The amount of screen pixels that the text is moved in each iteration. The default is 4.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>sleep</term>
      <listitem>
      <para>
        The time, in milliseconds, that the program waits after each iteration. This determines the scrolling speed. The
        default is 10 milliseconds.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>color</term>
      <listitem>
      <para>
        The color index used for the text. The default is 0, which is black.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns 0 on success and 1 on error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The text is scrolled from right to left. Scrolling is done by repeatedly rewriting the text at <emphasis
    role="italic">step</emphasis> pixels to the left in the client area of the window, starting at the right edge of
    the window. When the writing postion reaches the left edge of the window, the rewriting ends.
  </para>
  <para>
    The <emphasis role="italic">font</emphasis>, <emphasis role="italic">size</emphasis>, <emphasis
    role="italic">style</emphasis>, and <emphasis role="italic">color</emphasis> arguments specify a font for the text
    being scrolled. The ooDialog framework requests a font to match this description from the font manager.
  </para>
  <para>
    If the method is started concurrently, call it a second time with no arguments to stop the scrolling.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example scrolls the string "Hello world!" from left to right within the control window with the
    symbolic resource id of IDC_PB_SCROLLER. The text is located 2 pixels below the top of the client area, one move is
    3 screen pixels, and the delay time after each movement is 15 ms.

<programlisting>
<![CDATA[

hwnd = self~newPushButton(IDC_PB_SCROLLER)~hwnd

self~start(scrollText, hwnd, "Hello world!", "Arial", 36,   -
                       "BOLD ITALIC", 2, 3, 15, 4)

]]>
</programlisting>

  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions:scrollText() -->


<section id="mthSetBitmapPosition"><title>setBitmapPosition</title>
<indexterm><primary>setBitmapPosition</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>setBitmapPosition</secondary></indexterm>
<indexterm><primary>DialogExtensions class</primary><secondary>setBitmapPosition</secondary></indexterm>
<programlisting>
<![CDATA[

Form 1:

>>--setBitmapPosition(--id--,--point--)----------><

Form 2:

>>--setBitmapPosition(--id--,--x--,--y--)---------------><

Generic form:

>>--setBitmapPosition(--id--,--newPosition--)-----------><

]]>
</programlisting>

<para>
  Sets the position of the upper left corner of the bitmap within the <link linkend="defClientArea">client</link> area
  of a bitmap button.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the button. May be numeric or symbolic.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>newPosition [required]</term>
      <listitem>
      <para>
        The <emphasis role="italic">newPosition</emphasis> argument(s) specify the (x, y) coordinates of the bitmap.
        These coordinates can be specifed either as a <link linkend="clsPoint">object</link> or as 2 separate whole
        number arguments, as in Form 2.
      </para>
      <para>
        Whether specified as a <computeroutput>point</computeroutput> object, or using the <emphasis role="italic">x,
        y</emphasis> format, both the x and y coordinates are required.  If only one argument is used, it must be a
        <computeroutput>point</computeroutput> object. The coordinates are specified as client area coordinates, in
        pixels.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    This method returns 0 for success and 1 on error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Recall that client area coordinates are relative to the (0, 0) point of the client area of a window. Both or either
    of the coordinates can be negative. A negative x will place the bitmap to the left of the edge of the button. A
    negative y will place the bitmap above the top of the bitmap.
  </para>
  <para>
    This method is only for bitmaps that have been assigned to a bitmap button through the <link
    linkend="mthInstallBitmapButton">installBitmapButton</link> method. If there is no bitmap assigned to the button
    then 1 is returned.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
  <varlistentry id="exampleSetBitmapPosition"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>

<programlisting>
<![CDATA[
    p = .Point~new
    if button~getBitmapPosition(IDC_PB_HORSEBITMAP, p) then
        p~x += 4
        p~y += 3
        button~setBitmapPosition(IDC_PB_HORSEBITMAP, p)
    end
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DialogExtensions::setBitmapPosition() -->


<section id="mthWriteToWindow"><title>writeToWindow</title>
<indexterm><primary>writeToWindow</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>writeToWindow</secondary></indexterm>
<indexterm><primary>DialogExtensions</primary><secondary>writeToWindow</secondary></indexterm>
<programlisting>
<![CDATA[
>>--writeToWindow(-h-,-x-,-y-,-txt-+-------+-+------+-+--------+-+------+-+------+-)--><
                                   +-,-fnt-+ +-,-fs-+ +-,-opts-+ +-,-fg-+ +-,-bk-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">writeToWindow</emphasis> method writes text to the specified dialog or dialog control
  in the given font, style, and color, at the specified position.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>h [required]</term>
    <listitem>
    <para>
      The window <link linkend="defHandle">handle</link> of the dialog or dialog control to write the text to.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>x, y [required]</term>
    <listitem>
    <para>
      The starting position of the text, in pixels. The position coordinates are relative to the window, by default, or
      the client area of the window, not relative to the screen. Use the CLIENT keyword in the <emphasis
      role="italic">opts</emphasis> argument to indicate the starting position is relative to the client area of the
      window.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>txt [required]</term>
    <listitem>
    <para>
      The text string to be written.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>fnt [optional]</term>
    <listitem>
    <para>
      The font name. The default if omitted is SYSTEM.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>fs [optional]</term>
    <listitem>
    <para>
      The point size of the font. If omitted, the standard size (10) is used.
    </para>
    </listitem></varlistentry>

    <varlistentry><term>opts [optional]</term>
    <listitem>
    <para>
      A list of 0 or more of the following keywords separated by spaces, case is not significant. These options control
      aspects of the font and how the font is written.
    </para>
    <para>
    <simplelist type='vert' columns='3'>
      <member>OPAQUE     </member>
      <member>TRANSPARENT</member>
      <member>CLIENT     </member>
      <member>THIN       </member>
      <member>EXTRALIGHT </member>
      <member>LIGHT      </member>
      <member>MEDIUM     </member>
      <member>SEMIBOLD   </member>
      <member>EXTRABOLD  </member>
      <member>HEAVY      </member>
      <member>BOLD       </member>
      <member>UNDERLINE  </member>
      <member>ITALIC     </member>
      <member>STRIKEOUT  </member>
    </simplelist>
    <variablelist>
      <varlistentry><term>OPAQUE</term>
      <listitem>
      <para>
        The background of the area the text will occupy is painted with the specified background color, or with white if
        the background color is omitted, before writing the text.  This has the effect of &quot;erasing&quot; whatever
        is currently drawn in that area. Contrast this with the TRANSPARENT option. OPAQUE is the default.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>TRANSPARENT</term>
      <listitem>
      <para>
        The background area of the text is left unchanged. (The background color option is ignored if it is used.) This
        has the effect of writing the text over the top of whatever is currently drawn in the area the text will occupy.
        Contrast this with the OPAQUE option.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>CLIENT</term>
      <listitem>
      <para>
        The position for the text will be relative to the <link linkend="defClientArea">client</link> area of the
        specified window, rather than relative to the window itself.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>THIN</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 100.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>EXTRALIGHT</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 200.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>LIGHT</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 300.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>MEDIUM</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 500.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>SEMIBOLD</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 600.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>BOLD</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 700.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>EXTRABOLD</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 800.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>HEAVY</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 900.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>UNDERLINE</term>
      <listitem>
      <para>
        An underline font is used.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>ITALIC</term>
      <listitem>
      <para>
        An italic font is used.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>STRIKEOUT</term>
      <listitem>
      <para>
        A strike out font is used.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>fg [optional]</term>
    <listitem>
    <para>
      The color index for the text foreground color. If omitted, the text color is left unchanged.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>bk [optional]</term>
    <listitem>
    <para>
      The color index of the background color. If omitted, the background color is left unchanged. The background color
      is not used in transparent mode.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns 0 on success and 1 on error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method sets <computeroutput>.SystemErrorCode</computeroutput> to the error code set by the operating system
    when a failure in one of the Win32 APIs is detected. However, there is one Win32 API,
    <computeroutput>SelectObject()</computeroutput>, that does not set the system error code on failure. It is unlikely
    that it will fail, but if it does, the ooDialog framework sets <computeroutput>.SystemErrorCode</computeroutput> to
    <computeroutput>156</computeroutput>, ERROR_SIGNAL_REFUSED.
  </para>
  <para>
    The text message for error code <computeroutput>156</computeroutput> is: <emphasis role="italic">The recipient
    process has refused the signal.</emphasis> In this case, the text message is not really related to the failure, it
    is just used to indicate that the <computeroutput>SelectObject()</computeroutput> API failed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.  See the remarks above.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example writes the string <emphasis role="italic">Hello world!</emphasis> on the surface of a button
    using a blue 24pt Arial font in bold, italic style. The starting position of the text is at the point (3, 3)
    relative to the client area of the button:

<programlisting>
<![CDATA[

hwnd = self~NewPushButton(IDC_PB_CANVAS)
self~writeToWindow(hwnd, 3, 3, "Hello world!", "Arial", 24, "BOLD ITALIC CLIENT", 4)

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


<section id="mthWriteToControl"><title>writeToControl</title>
<indexterm><primary>writeToControl</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>writeToControl</secondary></indexterm>
<indexterm><primary>DialogExtensions</primary><secondary>writeToControl</secondary></indexterm>
<programlisting>
<![CDATA[
>>--writeToControl(-id-,-x-,-y-,-txt-+-------+-+------+-+--------+-+------+-+------+-)-><
                                     +-,-fnt-+ +-,-fs-+ +-,-opts-+ +-,-fg-+ +-,-bk-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">writeToControl</emphasis> method writes text to the specified dialog control in the given
  font, style, and color, at the specified position.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the dialog control to write the text to. May be numeric or <link
      linkend="defSymbolicID">symbolic</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>x, y [required]</term>
    <listitem>
    <para>
      The starting position of the text, in pixels. The position coordinates are relative to the window, by default, or
      the client area of the window, not relative to the screen. Use the CLIENT keyword in the <emphasis
      role="italic">opts</emphasis> argument to indicate the starting position is relative to the client area of the
      window.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>text [required]</term>
    <listitem>
    <para>
      The string to be written.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>fName [optional]</term>
    <listitem>
    <para>
      The font name. The default if omitted is SYSTEM.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>fSize [optional]</term>
    <listitem>
    <para>
      The point size of the font. If omitted, the standard size (10) is used.
    </para>
    </listitem></varlistentry>

    <varlistentry><term>opts [optional]</term>
    <listitem>
    <para>
      A list of 0 or more of the following keywords separated by spaces, case is not significant. These options control
      aspects of the font and how the font is written.
    </para>
    <para>
    <simplelist type='vert' columns='3'>
      <member>OPAQUE     </member>
      <member>TRANSPARENT</member>
      <member>CLIENT     </member>
      <member>THIN       </member>
      <member>EXTRALIGHT </member>
      <member>LIGHT      </member>
      <member>MEDIUM     </member>
      <member>SEMIBOLD   </member>
      <member>EXTRABOLD  </member>
      <member>HEAVY      </member>
      <member>BOLD       </member>
      <member>UNDERLINE  </member>
      <member>ITALIC     </member>
      <member>STRIKEOUT  </member>
    </simplelist>
    <variablelist>
      <varlistentry><term>OPAQUE</term>
      <listitem>
      <para>
        The background of the area the text will occupy is painted with the specified background color, or with white if
        the background color is omitted, before writing the text.  This has the effect of &quot;erasing&quot; whatever
        is currently drawn in that area. Contrast this with the TRANSPARENT option. OPAQUE is the default.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>TRANSPARENT</term>
      <listitem>
      <para>
        The background area of the text is left unchanged. (The background color option is ignored if it is used.) This
        has the effect of writing the text over the top of whatever is currently drawn in the area the text will occupy.
        Contrast this with the OPAQUE option.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>CLIENT</term>
      <listitem>
      <para>
        The position for the text will be relative to the <link linkend="defClientArea">client</link> area of the
        specified window, rather than relative to the window itself.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>THIN</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 100.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>EXTRALIGHT</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 200.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>LIGHT</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 300.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>MEDIUM</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 500.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>SEMIBOLD</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 600.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>BOLD</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 700.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>EXTRABOLD</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 800.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>HEAVY</term>
      <listitem>
      <para>
        The weight of the font in a range of 0 through 1000 will be 900.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>UNDERLINE</term>
      <listitem>
      <para>
        An underline font is used.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>ITALIC</term>
      <listitem>
      <para>
        An italic font is used.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>STRIKEOUT</term>
      <listitem>
      <para>
        A strike out font is used.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>fg [optional]</term>
    <listitem>
    <para>
      The color index for the text foreground color. If omitted, the text color is left unchanged.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>bk [optional]</term>
    <listitem>
    <para>
      The color index of the background color. If omitted, the background color is left unchanged. The background color
      is not used in transparent mode.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns 0 on success and 1 on error.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method sets <computeroutput>.SystemErrorCode</computeroutput> to the error code set by the operating system
    when a failure in one of the Win32 APIs is detected. However, there is one Win32 API,
    <computeroutput>SelectObject()</computeroutput>, that does not set the system error code on failure. It is unlikely
    that it will fail, but if it does, the ooDialog framework sets <computeroutput>.SystemErrorCode</computeroutput> to
    <computeroutput>156</computeroutput>, ERROR_SIGNAL_REFUSED.
  </para>
  <para>
    The text message for error code <computeroutput>156</computeroutput> is: <emphasis role="italic">The recipient
    process has refused the signal.</emphasis> In this case, the text message is not really related to the failure, it
    is just used to indicate that the <computeroutput>SelectObject()</computeroutput> API failed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.  See the remarks above.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example writes the string <emphasis role="italic">I am done!</emphasis> to the client area of a static
    control. The font of the thxt will be a blue 18pt Arial font in bold, italic style. The starting position of the
    text is at the point (5, 5) relative to the client area of the static control.

<programlisting>
<![CDATA[

self~writeToControl(IDC_ST_BLANK, 5, 5, "Hello world!", "Arial", 18, "BOLD ITALIC CLIENT", 4)

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

</section>
