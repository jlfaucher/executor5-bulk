<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog Reference SGML file.
    #
    # Copyright (c) 2005-2011, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<chapter id="chapOverview"><title>Brief Overview</title>
<indexterm><primary>overview</primary></indexterm>
<para>
  ooDialog is a <emphasis role="italic">framework</emphasis> that aids ooRexx programmers in adding graphical elements
  to their Rexx progamms. The framework provides the base infrastructure, through a number of classes, that the
  programmer builds on to quickly produce Windows dialogs. This book is a reference to the ooDialog classes, methods,
  and utilities that make up the base infrastructure.
</para>
<para>
  In general, the ooDialog framework simply provides the Rexx programmer with an interface to the Windows API, and
  primarily to the part of the API that deals with dialogs and dialog controls. In almost all cases, the behavior of the
  dialog and its controls is dictated by the Windows API. ooDialog has very little control of this. While this document
  strives to be complete enough that a Rexx programmer, knowing very little of the Windows API, can effectively write
  graphical programs in Rexx, it can never be as comprehensive as the actual Microsoft documentation. Therefore, the
  Rexx programmer that needs, or desires, to go beyond the basic dialog and dialog behavior, will benefit greatly by
  consulting the <link linkend="defWindowsDoc">MSDN Library</link>.
</para>

<section id="sctGettingStarted"><title>Getting Started</title>
<para>
  The ooDialog documentation should be divided into two parts - a tutorial and a reference. In the original
  documentation accompanying IBM's Object Rexx, the documentation <emphasis role="bold">was</emphasis> in two parts.
  Unfortunately, the tutorial portion mostly described how to use the <link linkend="ovvResourceWorkshop">IBM Resource
  Workshop</link>. Because the tutorial section was primarily directed towards using the Resource Workshop, it does not
  make much sense in the current context.
</para>
<para>
  This book is primarily a reference that describes the classes and methods in detail. There is no tutorial contained
  within the book. In ooDialog 4.2.0, a new document, the ooDialog User Guide has been started. However, it is currently
  a work in progress, but does contain a tutorial section. There is little other documentation for the newcomer on how
  to get started using ooDialog. Until the ooDialog User Guide gets fleshed, the sample ooDialog programs that accompany
  the ooRexx distribution are probably the best source of help in getting started.  However, there are also numerous
  snippets of example code in this book.  In addition the <link linkend="helpGettingHelp">getting help </link> section
  of this reference lists a number of resources for the programmer with questions about ooDialog.
</para>
</section>

<section id="sctTermDefs"><title>Definition of Terms</title>
<para>
  A collection of definitions and explanations for terms used in the ooDialog documentation. These terms may not be
  familiar to the average Rexx programmer.
</para>

<section id="defResourceScript"><title>Resource Script</title>
<para>
  Resource script files are plain text files usually produced by a resource editor.  The files generally have a file
  extension of &quot;.rc&quot;, but an extension of &quot;.dlg&quot; is used by some resource editors. The text of a
  resource script defines a dialog <link linkend="ovvDialogTemplate">template</link>. The format of the text is defined
  by Microsoft and public knowledge. The format is easily parsable by computer software and is used by resource
  compilers to produce a compiled (binary) file containing the dialog template(s) defined in the script file. The
  ooDialog framework can parse a resource script file and dynamically produce a dialog template in memory. This is the
  basis of how a <link linkend="clsRcDialog">RcDialog</link> works.
</para>
</section>

<section id="defResourceId"><title>Resource ID</title>
<para>
  A resouce ID is the identification number of a dialog resource. There are several different types of dialog
  resources, menus, dialog controls, and bitmaps, to name a few. You assign IDs when you create the resource definition
  for your dialog.  An ID can be either numerical (for example, 1) or symbolic (for example, "IDOK").
</para>
<para>
  IDs must be unique for each resource of the same type.  Although two resources of different types may have the same
  ID, when <link linkend="ovvSymbolicIDMechanism">using</link> symbolic IDs within the ooDialog framework it is
  advisable to give all resources unique numerical IDs.
</para>
</section>

<section id="defSymbolicId"><title>Symbolic ID</title>
<para>
  A symbolic name is a constant symbol that uniquely identifies a specific entity in a program. Defining a symbolic name
  for each numeric resource ID is often done in programs that work with resource IDs.  The symbolic name is then used
  where ever a numeric resource ID is needed.  Symbolic names are easier to remember than numeric IDs and can make the
  code easier to understand.
</para>
<para>
  Symbolic names are most often used in compiled programs, where a preprocessor replaces each ocurrence of the symbolic
  name in the code with its numeric value before the code is compiled. Symbolic names are less often used in interpreted
  languages because there is no preprocessor step where substituitons can be made. However, ooDialog provides a robust
  and useful <link linkend="ovvSymbolicIDMechanism">mechanism</link> for using symbolic IDs in ooDialog programs.
  Programmers wishing to use symbolic resource IDs in their programs should be familar with this <link
  linkend="ovvSymbolicIDMechanism">mechanism</link>.
</para>
</section>

<section id="defResourceEditor"><title>Resource Editor</title>
<para>
  Resource editors are visual tools used to create a dialog <link linkend="ovvDialogTemplate">template</link> in a text
  file. Visual resource editors provide a WYSIWYG (what you see is what you get) environment to design dialogs. The
  editor manages the size and positioning of a dialog and its controls. The user can drag and drop controls where they
  are wanted and use the mouse to size the dialog and controls. Resource editors simplify the process of designing the
  look of a dialog and reduce the amount of trial and error design inherent in using the <link
  linkend="clsUserDialog">UserDialog</link> class.
</para>
</section>

<section id="defPoundDefine"><title>#define Statement</title>
<para>
  Define statements are often used in the C and C++ languages to define symbolic names for numerical values.  Because of
  this, it is common in Windows programs with dialogs to define symbolic names for resource IDs.  Most Windows resource
  editors use symbolic IDs, (some to a limited degree, others exclusively.)  Often the define statements are put in a
  header file so they are available both to the resource compiler and to the program code.  The defines take the form
  of: <computeroutput>#define symbolicName numericValue </computeroutput> as in this example:
</para>
<programlisting>
<![CDATA[

#define   ID_PUSHBUTTON1  413
#define   ID_EDIT1        511
#define   ID_LISTBOX1     602

]]>
</programlisting>
</section>

<section id="defHeaderFile"><title>Header File</title>
<para>
  A common practice when programming applications in Windows that use dialogs and dialog resources is to place symbolic
  defines in a separate file.  These files often have a .h extension and are usually called header files.  Windows
  resource editors often manage a header file for the symbolic IDs automatically. (For instance Microsoft's dialog
  editor creates, writes, and reads the resource ID header file completely on its own. The user does not need to take
  any action other than including the file in her program.)
</para>
</section>

<section id="defDialogUnit"><title>Dialog Unit</title>
<para>
  Dialog box templates contain measurements that define the size and position of the dialog box and its controls. These
  measurements are device independent. This allows a single template to be used to create the same dialog box for all
  types of display devices. Using device independent measurements allows a dialog box to have the same proportions and
  appearance on all screens despite differing resolutions and aspect ratios between screens.
</para>
<para>
  These measurements are called dialog template units, often shortened to just dialog units in this documentation.
</para>
<para>
  The following paragraph in italics, which has been the sole documentation of dialog units in the ooDialog
  documentation prior to version 4.0.0, is unfortunately incorrect.  The value of a dialog unit is dependent on the font
  actually used in the dialog, not on the system font. The statements below were probably true in very early versions of
  Windows when every dialog used system 8 pt font. Today it is highly unusual for a dialog to use system 8 pt font. The
  factorX and factorY values are calculated incorrectly. These values are only correct if the dialog is using system 8
  pt font and are incorrect for a dialog using any other font.
</para>
<para>
  <emphasis role="italic">There is a horizontal and a vertical dialog base unit to convert width and height of dialog
  boxes and controls from dialog units to pixels and vice versa. The value of these base units depend on the screen
  resolution and the active system font; they are stored in attributes of the UserDialog class.</emphasis>
<programlisting>
<![CDATA[
xPixels = xDialogUnits * self~FactorX
]]>
</programlisting>
  <emphasis role="bold">Note</emphasis> that in the above line of code <computeroutput>xPixels</computeroutput> will not
  be <link linkend="ovvInaccurate">accurate</link>.
</para>
</section>

<section id="defDialogIcon"><title>Dialog Icon</title>
<para>
  The term <emphasis role="italic">dialog icon</emphasis> is used in this documentation to refer to the icon that is
  displayed in the left hand corner of the title bar of a dialog. In Windows this is often called the <emphasis
  role="italic">application</emphasis> icon.  The dialog icon is also used for the Task Bar display and in the AltTab
  task switcher application.
</para>
<para>
  The dialog icon for a specific dialog can be set when the dialog is run using one of the execute methods.  See the
  <link linkend="mthExecute">execute</link> or <link linkend="mthPopup">popup</link> methods for example.  ooDialog provides
  four icon images for use in dialogs.  Other, custom, icons can be used by including the icon in a binary (compiled)
  resource, a resource script, or by using the <link linkend="mthAddIconResource">addIconResource</link> method of the
  UserDialog.  The following table shows the pre-defined symbolic IDs of the icon images provided by ooDialog. The
  symbolic ID should always be used in case the numeric value is changed in the future. In addition, the programmer
  should avoid using any of the pre-defifned symbolic IDs <link linkend="ovvPreDefinedSymbolicIDs">reserved</link> by ooDialog. The
  IDI_DLG_DEFAULT is a fifth symbolic ID that represents the default dialog icon. This ID can always be used where a
  dialog icon ID is needed.
</para>
<table frame="all">
<title>ooDialog Supplied Icons</title>
<tgroup cols="2">
<thead>
<row>
<entry>Description</entry>
<entry>Symbolic ID</entry>
</row>
</thead>
<tbody>
<row>
<entry>The default, the letters OOD</entry>
<entry>IDI_DLG_OODIALOG</entry>
</row>
<row>
<entry>Dialog box image</entry>
<entry>IDI_DLG_APPICON</entry>
</row>
<row>
<entry>Fancier dialog box image</entry>
<entry>IDI_DLG_APPICON2</entry>
</row>
<row>
<entry>The ooRexx image</entry>
<entry>IDI_DLG_OOREXX</entry>
</row>
<row>
<entry>IDI_DLG_DEFAULT</entry>
<entry>IDI_DLG_DEFAULT</entry>
</row>
</tbody>
</tgroup>
</table>
</section>

<section id="defClientArea"><title>Client / Nonclient Area</title>
<para>
  The <emphasis role="italic">client area</emphasis> of a window is the part of a window where, normally, the window
  does its active drawing. For a top-level window this is usually where an application displays its output. The title
  bar, menu bar, window menu, minimize and maximize buttons, sizing border, and scroll bars are referred to
  collectively as the window's <emphasis role="italic">nonclient</emphasis> area. The operating system manages most
  aspects of the nonclient area. The application manages the appearance and behavior of its client area.
</para>
<para>
  Dialogs are top-level windows, and the client area is the area where the dialog draws its controls. The nonclient
  area is the border, title bar, etc.. For dialog controls, the client area is where the control draws itself. The
  nonclient area would be the border of the control, if it has one.
</para>
</section>

<section id="defScreenCoordinates"><title>Screen / Client Coordinates</title>
<para>
  Points on the screen are described as x and y coordinate pairs (x,y). The x coordinates increase to the right, y
  coordinates increase towards the bottom. <emphasis role="italic">Screen</emphasis> and <emphasis
  role="italic">client</emphasis> coordinates are used to distinguish the origin (0,0) of the coordinate. For a screen
  coordinate, the origin is the upper left corner of the primary display device, typically a monitor, and usually called
  the screen. Client coordinates on the other hand have an origin of the upper left corner of the <link
  linkend="defClientArea">client</link> area of the window.  Both screen and client coordinates are always given in the
  device unit of the display, which for all practical purposes is a <link linkend="defPixel">pixel</link>.
</para>
</section>

<section id="defModalModeless"><title>Modal and Modeless Dialogs</title>
<para>
  <indexterm><primary>Modal dialog</primary></indexterm>
  <indexterm><primary>Modeless dialog</primary></indexterm>
  Dialogs are executed in two basic ways. A <emphasis role="italic">modal</emphasis> dialog blocks keyboard and mouse
  input to all other windows started by the program. The user can not switch to another window in the program without
  closing the modal dialog. In ooDialog this is often all other dialogs started by the program. A <emphasis
  role="italic">modeless</emphasis> dialog operates independently of the other dialogs in the program. The user can
  switch away from a modeless dialog and work with any of the other dialogs in the program.
</para>
<para>
  Be aware that the original developers of ooDialog choose to not implement true modal dialogs. Rather, they implemented
  a strategy where all dialogs are created as modeless dialog and the ooDialog framework keeps track of the last dialog
  executed. This <emphasis role="italic">last executed</emphasis> dialog is then manually disabled to mimic the
  behaviour of true modal dialogs. While this strategy is usually sufficient, it will sometimes cause the wrong dialog
  to be disabled.
</para>
<para>
  In the ooDialog framework use the <link linkend="mthExecute">execute</link> method to create modal dialogs and the
  <link linkend="mthPopup">popup</link> or <link linkend="mthPopupAsChild">popupAsChild</link> methods to create
  modeless dialogs.
</para>
</section>

<section id="defHandle"><title>handle</title>
<para>
  A unique reference to a Windows object assigned by the system. It can be a reference to a dialog, a particular dialog
  control, a window, or a graphic object (pen, brush, font). Handles are required for certain methods. A handle is an
  opaque type, the Rexx programmer need not be aware of the specific format of a handle. The ooDialog framework provides
  methods that return handles and methods for retrieving handles from the operating system. When a method requires a
  handle as an argument, the Rexx programmer needs to obtain the handle from one of those provided methods.
</para>
</section>

<section id="defDeviceContext"><title>Device Context</title>
<para>
  Stores information about the graphic objects that are displayed, such as bitmaps, lines, and pixels, and the tools
  used to display them, such as pens, brushes, and fonts. A device context can be acquired for a dialog or a dialog
  control. It must be explicitly freed when the text or graphic operations are completed.
</para>
</section>

<section id="defPixel"><title>Pixel</title>
<para>
  Individual addressable point on the monitor (screen or display.) Pixels are whole numbers. Ancient VGA screens
  supported 640 by 480 pixels, SVGA screens supported higher resolutions, such as 800 by 600, 1024 by 768, and up.
  Modern displays support much higher resolutions. 1600 by 1200 is common and displays with 2560x1600 are available.
  Pixel values start at the top left corner of the main display, with that corner being (0,0). Prior to dual monitor
  capabilities, pixel values were always non-negative. On a dual monitor system that is no longer true, depending on the
  virtual position of the secondary monitor. If it is to the left or above the primary monitor negative pixel values are
  possible.
</para>
</section>

<section id="defColor"><title>Color</title>
<para>
  Each color supported by the Windows operating system is assigned a number. Sample color indexes are 0 (black), 1 (dark
  red), 2 (dark green), 3 (dark yellow), 4 (dark blue), 5 (purple), 6 (blue grey), 7 (light grey), 8 (pale green), 9
  (light blue), 10 (white), 11 (grey), 12 (dark grey), 13 (red), 14 (light green), 15 (yellow), 16 (blue), 17 (pink), 18
  (turquoise).
</para>
</section>

<section id="defColorPalette"><title>Color Palette</title>
<para>
  An array that contains color values identifying the colors that can currently be displayed or drawn on the output
  device.
</para>
<para>
  Color palettes are used by devices that can generate many colors but can only display or draw a subset of them at a
  time. For such devices, Windows maintains a system palette to track and manage the current colors of the device.
</para>
<para>
  Applications do not have direct access to this system palette. Instead, Windows associates a default palette with each
  device context. Applications can use the colors in the default palette.
</para>
<para>
  The default palette is an array of color values identifying the colors that can be used with a device context by
  default. Windows associates the default palette with a context whenever an application creates a context for a device
  that supports color palettes. The default palette ensures that colors are available for use by an application without
  any further action. The default palette typically has 20 entries (colors), but the exact number of entries can vary
  from device to device.  The colors in the default palette depend on the device. Display devices, for example, often
  use the 16 standard colors of the VGA display and 4 other colors defined by Windows.
</para>
</section>

<section id="defConventionalHex"><title>Conventional Hexadecimal Format</title>
<para>
  There are a number of methods in the ooDialog framework that have an argument that can be in numeric format, a whole
  number, or in a <emphasis role="italic">conventional hexadecimal</emphasis> format. For the purposes of this
  documentation this hexadecimal format is defined to be a Rexx string that begins with &quot;0x&quot; followed by a
  maximum of 16 characters, which are only characters that represent hexadecimal numbers. I.e., &quot;0&quot; through
  &quot;F&quot;. The following is meant to clarify this:
</para>
<programlisting>
<![CDATA[

-- Acceptable:
"0xffff"
"0XFFFF"
"0x000012aB"
"0xFFFF0000aaaa9999"
"0x0"

-- Incorrect:
" 0xffff"              -- leading space
"0XFZFF"               -- Z is not a hexidecimal symbol
"000012ab"             -- second character must be x
"0x0123456789ABCDEF1"  -- 17 characters
"00x0"                 -- second character must be x, not 0

]]>
</programlisting>
</section>

<section id="defSystemErrorCode"><title>System Error Code</title>
<para>
  The term <emphasis role="italic">system error code</emphasis> refers to an error code set by the Windows operating
  system when an API fails. ooDialog provides an interface to the Windows APIs and when an error is detected many of
  the ooDialog methods have some means of conveying the system error code to the programmer. The ooDialog programmer can
  look up the meaning of a system error code in the <link linkend="defWindowsDoc">MSDN library</link> to understand
  better the cause of a failure.
</para>
<para>
  ooDialog provides the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> environment entry as a means for the
  Rexx programmer to determine the value of the system error code after a method has executed. Note that not all of the
  Windows APIs set the system error code. And, likewise, not all of the ooDialog methods set the
  <computeroutput>.SystemErrorCode</computeroutput>.
</para>
</section>

<section id="defWindowsDoc"><title>Windows Documentation</title>
<para>
  The term <emphasis role="italic">Windows documentation</emphasis> is used throughout the ooDialog reference to refer
  to the Windows Operating System documentation provided by Microsoft.  The documentation is called the <emphasis
  role="bold">MSDN Library</emphasis>.  The library is provided online for anyone to access. In addition, since May
  2006, Microsoft has also provided free of charge the ISO images of the library installation program.  Anyone can
  download the ISOs, burn them to a CD and install the library locally on their system.
</para>
<para>
  It is not necessary for the ooDialog programmer to know or understand the underlying Windows API that ooDialog is
  built on.  However, as programmers write more sophisticated ooDialog applications, it may prove helpful to look up
  certain details in the MSDN Library. The information below is provided to help the ooDialog programmer locate the
  MSDN Library, if they would like to. All things on the Internet change. The URLs listed here are accurate at the time
  of this writing.
</para>
<para>
  The online MSDN Library is currently located at:
</para>
<para>
  http://msdn2.microsoft.com/en-us/library/default.aspx.
</para>
<para>
  Directions to the downloadable ISO images of the MSDN Library have been posted on this blog entry:
</para>
<para>
  http://blogs.msdn.com/robcaron/archive/2006/07/26/678897.aspx
</para>
<para>
  A Google search using: <computeroutput>"Rob Caron" General Downloads MSDN Library</computeroutput> should also turn up
  the blog entry.
</para>
</section>

<section id="defPlatformSDK"><title>Windows Platform SDK</title>
<para>
  The <emphasis role="italic">Windows Platform SDK</emphasis> is provided free of charge by Microsoft.  The SDK is not
  needed to write ooDialog programs.  However, combining the use of the documentation in the MSDN Library with the SDK
  allows very sophisticated ooDialog programs to be written.  In general, the ooDialog framework takes care of the
  low-level details needed to work with the Windows API.  However, there are a few generic ooDialog methods
  that provide direct access to the Windows API.
</para>
<para>
  As an example, the <link linkend="mthAddUserMsg">addUsermessage</link> method allows the programmer to connect any
  Windows message sent to a dialog to a method in his ooDialog class.  To use this method, the programmer would go to
  the MSDN library to look up details on the message and message parameters he is interested in.  He would then use the
  Platform SDK to determine the numeric value of the Windows message and possibly the numeric values of its parameters.
</para>
<para>
  This link provides some good information on the Platform SDK in general and also points the reader to where to get a
  SDK.
</para>
<para>
  http://en.wikipedia.org/wiki/Platform_SDK
</para>
<para>
  Again, note that it is not at all necessary to obtain, or understand details concerning, the Platform SDK.  This
  information is provided for those programmers that have reached the point where they think a method like
  <computeroutput>addUserMessage</computeroutput> might help them and need some direction as to how to go about using
  it.
</para>
</section>

</section> <!-- End: Definition of Terms -->

<section id="sctGeneralOODialog"><title>Common Concepts</title>
<para>
  Many concepts and behaviors in ooDialog, and statements about ooDialog are general in nature. This section gathers up
  this information in one place.  Rather than repeating this information in every method or class description to which
  it applies, the author will assume that the reader understands that the information is always applicable unless
  specifically stated otherwise.
</para>

<section id="ovvNumbers"><title>Numbers in ooDialog:</title>
<para>
  Numbers in ooDialog are <emphasis role="bold">always</emphasis> whole numbers, unless specifically stated otherwise.
  Except in very rare cases, the Windows API that ooDialog provides access to, only deals with whole numbers. Pixels,
  positions, sizes of fonts, coordinates on the screen, etc., are all expressed as whole numbers only. Numerical
  arguments to methods in ooDialog must always be whole numbers, unless the documentation specifically notes that the
  method accepts fractional numbers for the argument.
</para>
</section>

<section id="ovvUnderlying"><title>Underlying Dialog Creation</title>
<para>
  The dialog and dialog control objects in ooDialog represent the dialogs and controls users see on their screens.
  This documentation often refers to the underlying dialog or the underlying control.  These statements refer to the
  dialog or control created by the operating system, the objects the user sees on the screen. The operating system
  controls what these underlying objects can, and can not, do. One thing that it is sometimes difficult for the Rexx
  programmer to grasp is that ooDialog can not alter the behavior or appearance of these objects in ways not allowed
  by the operating system. The Windows API provides a broad number of ways to customize the appearance and behavior
  of dialogs and controls.  But, ooDialog and the Rexx programmer are restricted to those customizations provided
  by the operating system.
</para>
<para>
  Another concept that is often hard to grasp is that many of the methods of the ooDialog dialog and control
  objects can only be used after the underlying Windows dialog has been created.  In general this means in the <link
  linkend="mthInitDialog">initDialog</link>() method or later in the life cycle of the dialog. In particular, the
  <link linkend="mthDefineDialog">defineDialog</link>() method of the <link
  linkend="clsUserDialog">UserDialog</link> class executes before the underlying dialog is created. Therefore, any
  method that requires the underlying dialog to have been created can not work in the <emphasis
  role="italic">defineDialog</emphasis> method. In earlier versions of ooDialog, in general, if the programmer
  invoked a method requiring that the underlying dialog was created, the error was simply ignored. But, the method
  had no effect.
</para>
<para>
  From the 4.0.0 release of ooRexx and on, the goal in ooDialog is to raise a syntax condition when a method
  requiring the underlying dialog is invoked and the underlying dialog does not exist. This goal is being
  implemented over time and may not yet be completed.
</para>
</section>

<section id="ovvWindowMessages"><title>Window Messages</title>
<para>
  In the Windows operating system, not surprisingly, most everything is a window. In a nutshell, the Windows operating
  system works by routing and sending <emphasis role="italic">messages</emphasis> to these windows. Each window has a
  <emphasis role="italic">message processing loop</emphasis> where the window waits for a message to arrive, processes
  it, and then waits for the next message. Each window message has an unique whole number ID that gives meaning to the
  message. When a message is sent to a window, it is sent with two arguments. The first argument is of a type called
  WPARM and the second is a type called LPARAM. These types are opaque and the value of each is dependent on the
  specific message. Either or both of the arguments may have no meaning for the specific message. The window always
  returns a value, another opaque type called LRESULT, which again may have no meaning for the particular message.
</para>
<para>
  In general, most of what ooDialog does is done by sending window messages to the operating system windows. This is
  designed to allow the Rexx programmer to use dialogs without understanding any of the details of window messages.
  However, the ooDialog framework provides a few generic methods that send window messages to the underlying operating
  system windows. These methods, in contrast to most methods, can not be used by the Rexx programmer without some
  knowledge of the window message being sent. The methods are clearly marked. The programmer would need to consult the
  <link linkend="defWindowsDoc">Windows Documentation</link> to understand what both the WPARAM and LPARAM arguments
  must be, and to understand what the LRESULT return, if any, means. In addition, the programmer would need to determine
  the numeric value of the window message ID. This could be done using a <link linkend="defPlatformSDK">Windows
  platform SDK</link>, or perhaps through a Google search.
</para>
<para>
  These generic send messages methods allow Rexx programmers to send any message to any of the underlying windows in
  their programs. The caveat is that the programmers will have to research the meaning of the messages, their arguments,
  and their return values themselves.
</para>

</section>

<section id="ovvEvents"><title>Events</title>
<para>
  The ooDialog framework facilitates the use of a type of programming often called <emphasis role="italic">event
  driven programming</emphasis>. In event driven programming, the program usually does some initial set up and then
  sits in some type of loop waiting to be signaled that an event just happened.  The Windows graphical windowing
  system is designed to be programmed this way. The Windows operating system uses <emphasis
  role="italic">messages</emphasis> to notify each window in the system of events specific to that window. Typically
  events are generated by the user. For instance, clicking a button, typing a key, moving the mouse, all generate
  events. The operating system notifies the window with the input focus of those events by sending <link
  linkend="ovvWindowMessages">messages</link> to the window. Note that some events are generated by the
  operating system itself. For instance, when the user moves a window that uncovers a portion of a window beneath it,
  the operating system will send a message to the underlying window notifying it that it needs to redraw the uncovered
  portion.
</para>
<para>
  Once the basic set up for an ooDialog program is done, the dialog object basically sits there waiting for an
  <emphasis role="italic">event</emphasis> of interest to happen. When the event happens, the program responds by
  taking some action. The programmer decides what events are of interest and uses methods provided by the ooDialog
  framework to <emphasis role="italic">connect</emphasis> a method in the dialog object to the event notification. The
  majority of the event connection methods are part of the <link linkend="clsEventNotification">EventNotification</link>
  class. The connected methods are often called <emphasis role="italic">event handlers</emphasis> because the code in
  the method handles the event.
</para>
<para id="ovvEventsDirectReply">
  Event notification messages in Windows fall into two groups, messages where the reply is ignored and messages where
  the reply is significant. Prior to the introduction of the <link linkend="sctHistory">C++</link> native APIs, there
  was <emphasis role="bold">no way</emphasis> in ooDialog to <emphasis role="italic">directly</emphasis> reply to the
  nofication message. This placed a severe restriction on ooDialog programs. Many of the features of the operating
  system could not be used with this restriction. For instance, when a user selects a new tab in a <link
  linkend="clsTab">tab</link> control, the operating system sends a SELCHANGING event notification before the selected
  tab is changed. The programmer can allow or prevent the change by replying true or false to the notification message.
</para>
<para>
  Without the ability to reply directly to the notification, the ooDialog programmer could not take advantage of the
  SELCHANGING notification. The introduction of the C++ native APIs in ooRexx 4.0.0 removed this restriction. Beginning
  in ooDialog 4.2.0, the event handling methods in the Rexx dialog object are directly invoked from the Windows message
  processing loop. This allows the Rexx dialog object to reply directly to the notification message.
</para>
<para>
  The ability to directly reply to event notifications greatly extends the power of the ooDialog framework. However, it
  also changes how the ooDialog programmer must write his event handlers. In particular, the event handler must return
  in a timely manner. This is discussed more <link linkend="sctCodingEventHandlers">fully</link> in the
  <computeroutput>EventNotification</computeroutput> class documentation.
</para>
</section>

<section id="ovvComctl32"><title>Required Common Control Library (Comctl32) Version</title>
<para>
  The dialog control windows used in dialogs, List-Views, Edit, Tree-Views, etc., are supplied by Microsoft in the
  common controls library. This is a DLL with the name comctl32.dll.  Every version of Windows is supplied with a common
  controls library.  However, Microsoft has updated the library a number of times to provide enhanced functionality and
  improved features
</para>
<para>
  Each new version of the library is backwards compatible with previous versions, but, it will contain features not
  available in older versions.  For instance, some of the List-View <link linkend="listControlExtendedStyles">
  extended styles</link> are only available with a 6.0, or later, version of the common controls library.  ooDialog can
  only provide the features available in the version of the common controls library on the system ooDialog is running
  on.
</para>
<para>
  Therefore, an ooDialog program running on a Windows 2000 machine will not have available some of the features that are
  available when ooDialog is running on a XP service pack two system.  The DlgUtil class provides a method, <link
  linkend="mthComCtl32Version">comCtl32Version</link> that allows the programmer to determine the exact version of the
  common controls library that ooDialog is using.  In the documentation for the ooDialog dialog control classes,
  features that are not available in all versions of the common control library are noted.  The minimum version of the
  library that is needed is listed.  In general, at this time, all features of ooDialog are available on Windows XP
  or later.  This may change in the future as Vista has common control features not available on XP.
</para>
</section>

<section id="ovvRequiredWindows"><title>Required Windows Version</title>
<para>
  The required Windows version is similar to the <link linkend="ovvComctl32">required ComCtl32</link> library version.
  Later versions of the Windows operating system have dialog and dialog control features not available in earlier
  versions of the operating system.
</para>
<para>
  For instance, the <link linkend="clsMonthCalendar">MonthCalendar</link> class has a number of methods that are only
  available on Vista or later. ooDialog can only use the features available on the system on which it is executing. If
  a method is invoked that is not available on the current operating system, a syntax conditions is raised. Any
  method not available on all the Windows versions which ooRexx supports, have the minimum required Windows version
  noted in their documentation.
</para>
<para>
   The <link linkend="clsOS">OS</link> class supplies methods that allow the programmer to determine exactly which
   operating system version the program is currently executing on. For programs that need to run on all versions of
   Windows, the programmer must either avoid using methods not available on all versions, or test for the current
   version and provide an alternative code path dependent on that version.  The <link
   linkend="mthIsAtLeastVista">isAtLeastVista</link>() method of the <emphasis role="italic">OS</emphasis> class
   provides an example of this.
</para>
</section>

<section id="ovvUndocumented"><title>Undocumented Items</title>
<para>
  ooRexx is open source and anyone can peruse the source to see all functions, classes, and methods of the ooDialog
  framework. Any of these items that are undocumented should not be used by the Rexx programmer. If the programmer does
  use any undocumented features in the framework, he does so at his own risk. The framework strives to be backwards
  compatible, but only for documented features. Undocumented features in the framework are intended for internal use
  only and are subject to change, or even removal from the framework.
</para>
<para>
  In addition, previous versions of the ooDialog documentation, documented some features, but added some form of the
  caveat: <emphasis role="italic">for internal use</emphasis>. The prudent programmer would not use any feature
  documented for internal use. These features are also subject to change.
</para>
</section>

<section id="ovvInaccurate"><title>factorX / factorY</title>
<para>
  The <emphasis role="italic">factorX</emphasis> and <emphasis role="italic">factorY</emphasis> attributes of the
  <link linkend="chpDialogObject">dialog object</link> were intended to provide a way to convert between <link
  linkend="defPixel">pixels</link> and <link linkend="defDialogUnit">dialog units</link>, and vice versa. Although their
  values may have been correct when ooDialog was <link linkend="sctHistory">originally designed</link>, in almost all
  cases the values are now incorrect. The method used to calculate the ratio between dialog units and pixels is no
  longer correct.
</para>
<para>
  Unfortunately, many of the methods in the ooDialog framework use <emphasis role="italic">factorX</emphasis> and
  <emphasis role="italic">factorY</emphasis> to convert between pixels and dialog units. This in turn makes all of
  those methods inaccurate. These methods are all marked as being inaccurate. There is almost always no reason to
  convert back to dialog units from pixels. Once the underlying dialog has been created, pixels should be used. Each
  inaccurate method in the framework has a corresponding method that uses pixels instead of dialog units.
</para>
</section>

<section id="ovvDialogTemplate"><title>Dialog Template</title>
<para>
  <indexterm><primary>Template, Dialog</primary></indexterm>
  The <link linkend="ovvUnderlying">underlying</link> dialog seen by the user is created by the operating system from a
  dialog template in memory. The template describes the size and position of the dialog and all of its controls. The
  template also contains modifiers that control the style, behavior, and attributes of the dialog and its controls. To
  make designing dialogs easier, Windows supports the concept of a textual representation of the dialog template. The
  textual representation can then be translated by software tools to the binary form of the template needed by the
  operating system.
</para>
<para>
  ooDialog uses three basic constructs that allow the Rexx programmer to supply the dialog template. The programmer can
  use a binary resource, a resource script, or create the template dynamically in the program code. A binary (compiled)
  dialog template is stored in a DLL, (usually a .dll file.) The programmer subclasses a <link
  linkend="clsResDialog">ResDialog</link> to use a binary resource. Resource scripts, (usually a .rc file) supply the
  dialog template in a text file. The programmer subclasses a <link linkend="clsRcDialog">RcDialog</link> to create a
  dialog from a resource script. To create a dialog template dynamically in the program code, the programmer subclasses
  a <link linkend="clsUserDialog">UserDialog</link> and then uses the <link linkend="sctCreateMethods">create</link>
  methods of that class to create the dialog template. The <computeroutput>UserDialog</computeroutput> object translates
  the program statements into the in-memory dialog template required by the operating system. The
  <computeroutput>RcDialog</computeroutput> object parses the resource script and converts the resource script
  statements into an in-memory dialog template by invoking the proper methods of its superclass, the
<computeroutput>UserDialog</computeroutput>.
</para>
</section>

<section id="ovvSymbolicIDMechanism"><title>Using Symbolic IDs in ooDialog:</title>
<para>
  ooDialog allows programmers to use <link linkend="defSymbolicId">symbolic</link> resource IDs in their programs. The
  symbolic ID can be used for any argument in any method that requires a resource ID. Although this is mostly
  transparent to the programmer, if the programmer is going to use symbolic IDs, he should understand the basics of the
  mechanism allowing the use of symbolic IDs.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Resolving Symbolic IDs:</emphasis></term>
  <listitem>
  <para>
    ooDialog uses a <computeroutput>.Directory</computeroutput> object that consists of indexes that are symbolic names.
    The value for the item at each index is the numeric value of the symbolic name. This gave rise to the object name of
    <computeroutput>constDir</computeroutput>, which probably refers to a directory of constants (symbols.) When an
    argument in a method is a resource ID, ooDialog first checks to see if the argument is a whole number. If so, it
    simply uses the number. When the argument is not a number, ooDialog uses the argument to do a look up in the
    constant directory object. If the argument matches an index in the object, the value of the index is used as the
    numeric value of the resource ID. When the argument does not match an index in the constDir, the method fails.
  </para> </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">constDir Attribute:</emphasis></term>
  <listitem>
  <para>
    Originally the constDir was implemented as an <link linkend="atrConstDir">attribute</link> of the dialog object. Each
    dialog object then has its own constDir, which was used to resolve symbolic IDs where needed in the methods of the
    dialog. Each dialog control has a reference to its owner dialog, allowing the dialog object's constDir to be used to
    resolve symbolic IDs for the methods of the control. This mechanism exists unchanged in the current ooDialog
    framework.
  </para>
  <para>
    However, as enhancements to ooDialog started to be made in version 4.0.0 and later, it became apparent that the
    constDir attribute was not adequate. Classes such as the <link linkend="clsMenu">Menu</link> classes and <link
    linkend="clsResourceImage">ResourceImage</link> class also used resource IDs, but objects of these classes are
    independent of any dialog object. Without access to a dialog object, there was no way in those classes to use symbolic
    IDs. To fix this problem, ooDialog 4.2.0 added the global <computeroutput>.constDir</computeroutput> to the
    mechanism for using symbolic IDs.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Global .constDir object:</emphasis></term>
  <listitem>
  <para>
    The global <link linkend="dotConstDir">.constDir</link> works in the same way as the dialog object's constDir attribute.
    When a symbolic ID needs to be resolved, it can be looked up in the global <computeroutput>.constDir</computeroutput>.
    The integration of the global <computeroutput>.constDir</computeroutput> into the mechanism for resolving symbolic
    IDs is done by allowing the programmer to specify how, or even if, the <computeroutput>.constDir</computeroutput>
    should be used. The four choices are <emphasis role="italic">only</emphasis>, <emphasis
    role="italic">first</emphasis>, <emphasis role="italic">last</emphasis>, or <emphasis
    role="italic">never</emphasis>. The programmer specifies which of these strategies is to be used through one of the
    methods of the <link linkend="dotApplication">.application</link> object. (The
    <computeroutput>.application</computeroutput> object is an instance of the <link
    linkend="clsApplicationManager">ApplicationManager</link> class.)
  </para>
  </listitem></varlistentry>
  <varlistentry id="entConstDirStrategy"><term><emphasis role="bold">Global .constDir Usage
  Strategies:</emphasis></term>
  <listitem>
  <para>
    The four strategies work this way.
    <variablelist>
      <varlistentry><term><emphasis role="bold">Only:</emphasis></term>
      <listitem>
      <para>
        With this strategy, symbolic IDs are only placed in the <computeroutput>.constDir</computeroutput> and only
        looked up through that object. When a new dialog object is instantiated, rather than assign a newly instantiated
        <computeroutput>.Directory</computeroutput> object to its constDir attribute, the global
        <computeroutput>.constDir</computeroutput> is assigned to the attribute. This is by far the most efficient way to
        use symbolic IDs in an ooDialog program.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><emphasis role="bold">First:</emphasis></term>
      <listitem>
      <para>
        When the ooDialog framework needs to resolve a symbolic ID, it will first try to resolve it using the
        <computeroutput>.constDir</computeroutput>. If that fails, it will then try to resolve it using the constDir
        attribute. If that then fails, the method will fail.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><emphasis role="bold">Last:</emphasis></term>
      <listitem>
      <para>
        This is the reverse of the use <emphasis role="italic">first</emphasis> strategy. The ooDialog framework first
        tries to resolve a symbolic ID in the constDir attribute. If that fails, the
        <computeroutput>.constDir</computeroutput> is tried.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><emphasis role="bold">Never:</emphasis></term>
      <listitem>
      <para>
        The <computeroutput>.constDir</computeroutput> is never used in the program. To preserve backwards compatibility,
        this is the default.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Adding Symbols:</emphasis></term>
  <listitem>
  <para>
    A few symbolic IDs are <link linkend="ovvPreDefinedSymbolicIDs">pre-defined</link> by ooDialog and are always
    present in the constant directory. These symbolic IDs can be used in any ooDialog program. Other than the
    pre-defined IDs, the programmer must add symbolic IDs in order to use them in a program.
  </para>
  <para>
    The easiest way to add symbols is to have the ooDialog framework add the symbols itself from a file. Whenever
    ooDialog parses a <link linkend="defResourceScript">resource</link> script or a <link
    linkend="defHeaderFile">header file</link>, it automatically adds any symbol <link
    linkend="defPoundDefine">definitions</link> it finds to a constant directory. Which constant directory is dependent
    on the global <computeroutput>.constDir</computeroutput> usage strategy in effect.
  </para>
  <para>
    Resource scripts are parsed whenever a <link linkend="clsRcDialog">RcDialog</link>, or subclass, is instantiated.
    In addition, all the ooDialog dialog classes accept a header file as an optional parameter when a new instance of a
    dialog object is created. (See for example the <computeroutput>new</computeroutput> method in the <link
    linkend="mthNewDialogObject">dialog</link> object or the <link linkend="mthNewClsUserDialog">UserDialog</link>
    class.) If the programmer supplies the optional header file argument, the ooDialog framework automatically parses
    the file and adds all defined symbols it finds in the file to a constant directory. Again, to be clear, which
    constant directory the symbol is placed in is depenedent on which <computeroutput>.constDir</computeroutput> <link
    linkend="entConstDirStrategy">strategy</link> the programmer has elected to use.
  </para>
  <para>
    In practice, most resource scripts are written by resource <link linkend="defResourceEditor">editors</link> and
    place the symbol definitions in a separate header file. Therefore having the ooDialog framework read and parse a
    header file is the most practical way to add symbols to a constant directory. In addition to using the optional
    header file argument in the <link linkend="mthNewDialogObject">new</link> method of a dialog, the ooDialog framework
    provides some addtional methods for reading a file and adding the symbol definitions to a constant directory. The
    dialog object has the <link linkend="mthParseIncludeFile">parseIncludeFile</link> method. The <link
    linkend="clsApplicationManager">ApplicationManger</link> class has serveral methods, which are accessed through the
    <link linkend="dotApplication">.application</link> object. These are: the <link
    linkend="mthUseGlobalConstDir">useGlobalConstDir</link>, <link linkend="mthAddToConstDir">addToConstDir</link>,
    <link linkend="mthSetDefaults">setDefaults</link>, and <link linkend="mthParseIncludeFile">parseIncludeFile</link>
    methods.
  </para>
  <para>
    Of course, symbolic IDs can also be added directly in the program as the following code snippet shows:
  </para>

<programlisting>
<![CDATA[

::method init
  forward class (super) continue

  self~constDir[IDC_GB] = 101
  self~constDir[IDC_CB_REGINA] = 107
  self~constDir[IDC_CB_REGINALD] = 111
  self~constDir[IDC_CB_OOREXX] = 115

...

::method defineDialog

  self~createGroupBox(IDC_GB, 10, 20, 150, 90, "BORDER", "Pick an interpreter")
  self~createCheckBox(IDC_CB_REGINA, 30, 40, , , "GROUP", "Regina")
  self~createCheckBox(IDC_CB_REGINALD, 30, 60, , , , "Reginald")
  self~createCheckBox(IDC_CB_OOREXX, 30, 80, , , , "ooRexx")

...

::method ok

  oorexxCB = self~newCheckBox(ID_CB_OOREXX)
  if oorexxCB~checked then
    say "You picked the right interpreter."

]]>
</programlisting>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Classes Requiring the Global .constDir for Symbolic IDs:</emphasis></term>
  <listitem>
  <para>
    As explained previously, the dialog ojbect's <link linkend="atrConstDir">constDir</link> attribute allows
    programmers to use symbolic IDs for arguments requiring resource IDs in the methods of the <link
    linkend="chpDialogObject">dialog</link> object and the <link linkend="chpDialogControlObject">dialog</link> contol
    object. However, the ooDialog framework contains other classes with methods requiring resource IDs. The <link
    linkend="clsMenu">Menu</link> classes and the <link linkend="clsResourceImage">ResourceImage</link> class are
    examples of these classes. If the programmer wishes to use symbolic IDs in classes other than the dialog and
    dialog control classes, then the global <computeroutput>.constDir</computeroutput> <emphasis
    role="bold">must</emphasis> be used.
  </para>
  <para>
    Programmers that do not want to use the <computeroutput>.constDir</computeroutput>, <emphasis
    role="bold">must</emphasis> use numeric resource IDs for any argument requiring a resource ID in any of the classes
    other than the dialog and dialog control classes.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Global .constDir Pros:</emphasis></term>
  <listitem>
  <para>
    Using the global <computeroutput>.constDir</computeroutput> is by far the most efficient way to use symbolic IDs in
    ooDialog programs.
  </para>
  <para>
    Using the global <computeroutput>.constDir</computeroutput> allows large applications with many dialogs to read the
    symbol file one time only.  When using the dialog object's <computeroutput>constDir</computeroutput> attribute, the
    symbol file would need to be constantly re-read, once for each dialog.
  </para>
  <para>
    Using the global <computeroutput>.constDir</computeroutput> allows the programmer to use symbolic IDs for any method
    in any object that requires a resource ID.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Global .constDir Cons:</emphasis></term>
  <listitem>
  <para>
    The <computeroutput>.constDir</computeroutput> does have some restrictions. These restrictions may be a reason for
    some programmers to prefer to not use the <computeroutput>.constDir</computeroutput>. Depending on one's point of
    view, many of the cons could be viewed as pluses.
  </para>
  <para>
    The indexes in the <computeroutput>.constDir</computeroutput> are case sensitive. However, this allows symbol
    resolution to be more efficient and faster. Case sesitivity is not a problem if a distinctive naming scheme is used
    for symbolic IDs where the symbol names would never be used for variable names, and the symbol names are never
    quoted.
  </para>
  <para>
    If a symbolic name can not be resolved, a syntax condition is raised. However, the only reason a symbol would not be
    resolved is if the programmer used an incorrect symbol. The raised syntax condition would alert the programmer to an
    error in the program early in the development cycle.
  </para>
  <para>
    Since all symbolic IDs are in one constant directory, duplicate symbol names can not be used in different dialogs,
    unless the duplicate symbol names are assigned a single numeric value. (In which case they are not actually
    duplicates.) For example, take a program that has two different dialogs in it, each with an edit control in the
    dialog. If the programmer's habit is to use a symbol of IDC_EDIT for edit controls, there could be a conflict if the
    edit control in the first dialog, had a define like this: <computeroutput>#define IDC_EDIT  100</computeroutput> and
    the edit control in the second dialog had a define like this: <computeroutput>#define IDC_EDIT
    200</computeroutput>. The solution to this is too either use two different symbols for the two edit controls, or use
    the same resource ID number for both edit contols.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="ovvPreDefinedSymbolicIDs"><title>Predefined Symbolic IDs</title>
<para>
  The symbolic IDs in the following table are pre-defined by ooDialog and always available to the programmer. They are
  placed in the either the <link linkend="atrConstDir">constDir</link> attribute when an instance of a dialog class is
  created, or in the global <link linkend="dotConstDir">.constDir</link>. Where they are placed is dependent on the
  <link linkend="mthUseGlobalConstDir">usage</link> of the <computeroutput>.constDir</computeroutput>. All symbolic
  names after IDC_STATIC in the table refer to resources bound to oodialog.dll for general use by the ooDialog
  programmer.
</para>
<para>
  To allow for future expansion, the ooDialog programmer should consider the resource IDs of 1 through 50 as reserved
  for ooDialog. Programmers can avoid conflicts by using IDs greater than 50 for resource IDs they assign in their
  programs.
</para>
<table id="oodsymbolicids" frame="all">
<title>Symbolic IDs Predefined by ooDialog</title>
<tgroup cols="3">
<thead>
<row>
<entry>Symbolic ID</entry>
<entry>Numeric ID or Symbol</entry>
<entry>ResourceType</entry>
</row>
</thead>
<tbody>
<row>
<entry>IDOK</entry>
<entry>1</entry>
<entry>ID for button controls</entry>
</row>
<row>
<entry>IDCANCEL</entry>
<entry>2</entry>
<entry>ID for button controls</entry>
</row>
<row>
<entry>IDABORT</entry>
<entry>3</entry>
<entry>ID for button controls</entry>
</row>
<row>
<entry>IDRETRY</entry>
<entry>4</entry>
<entry>ID for button controls</entry>
</row>
<row>
<entry>IDIGNORE</entry>
<entry>5</entry>
<entry>ID for button controls</entry>
</row>
<row>
<entry>IDYES</entry>
<entry>6</entry>
<entry>ID for button controls</entry>
</row>
<row>
<entry>IDNO</entry>
<entry>7</entry>
<entry>ID for button controls</entry>
</row>
<row>
<entry>IDCLOSE</entry>
<entry>8</entry>
<entry>ID for button controls</entry>
</row>
<row>
<entry>IDHELP</entry>
<entry>9</entry>
<entry>ID for button controls</entry>
</row>
<row>
<entry>IDTRYAGAIN</entry>
<entry>10</entry>
<entry>ID for button controls</entry>
</row>
<row>
<entry>IDCONTINUE</entry>
<entry>11</entry>
<entry>ID for button controls</entry>
</row>
<row>
<entry>IDC_STATIC</entry>
<entry>-1</entry>
<entry>ID for static controls</entry>
</row>
<row>
<entry>IDI_DLG_OODIALOG</entry>
<entry>IDI_DLG_OODIALOG</entry>
<entry>Icon image</entry>
</row>
<row>
<entry>IDI_DLG_APPICON</entry>
<entry>IDI_DLG_APPICON</entry>
<entry>Icon image</entry>
</row>
<row>
<entry>IDI_DLG_APPICON2</entry>
<entry>IDI_DLG_APPICON2</entry>
<entry>Icon image</entry>
</row>
<row>
<entry>IDI_DLG_OOREXX</entry>
<entry>IDI_DLG_OOREXX</entry>
<entry>Icon image</entry>
</row>
<row>
<entry>IDI_DLG_DEFAULT</entry>
<entry>IDI_DLG_DEFAULT</entry>
<entry>Icon image</entry>
</row>
</tbody>
</tgroup>
</table>
<para id="paraGenericResources">
  The symbolic IDs in the table following IDC_STATIC are the IDs of some generic <link
  linkend="chapResources">resources</link> that are bound to the oodialog.dll file.  They can be used in any ooDialog
  program and are accessed using the <link linkend="clsResourceImage">.ResourceImage</link> class. Programmers should
  always use their symbolic ID rather than their numeric ID in case the numeric value changes in future versions of
  ooDialog.
</para>
</section>

<section id="ovvResourceWorkshop"><title>IBM Resource Workshop</title>
<para>
  The IBM Resource Workshop was a visual resource <link linkend="defResourceEditor">editor</link> included with IBM Object
  Rexx. The Resource Workshop could not be contributed to the open source community and is therefore not a part of the
  Open Object Rexx project.
</para>
<para><emphasis role="bold">Note</emphasis>, there is <emphasis role="bold">no loss</emphasis> of functionality in
  ooDialog because of the absence of the Resource Workshop.  The Windows resource format is well understood and there
  are any number of free or inexpensive resource editors that do a better job of designing dialogs than the Resource
  Workshop did. (The Resource Workshop was a 16-bit application with limited capacity for the newer features in the
  Windows user interface.) ooDialog works fine with dialogs designed by any modern resource editor.
</para>
</section>

<section id="ovvDeprecated"><title>Deprecated</title>
<para>
  PROVIDE TEXT
</para>
</section>

</section> <!-- End: Common Concepts -->


<section id="sctHistory"><title>History</title>
<para>
  ooDialog is a Windows only extension to Open Object Rexx and appeared in the first version of IBM's Object Rexx for
  Windows. Object REXX for Windows NT &amp; 95 Interpreter Edition V1.0 was announced very early in 1997. It included
  ooDialog and could run on Windows 95 and Windows NT 3.5. However, comments within the code and sections of code itself
  in ooDialog, indicate that at one point ooDialog could run on Windows 3.0 and 3.1.
</para>
<para>
  IBM announced and released several successive versions of Object Rexx for Windows over the following years. For
  instance, Object REXX for Windows V2R1 was announced March 2001.  In May 2004, IBM announced its intention to
  contribute the source code for Object Rexx to RexxLA, and the ooRexx project was born. It took the best part of a year
  to work out the details and for the ooRexx developers to get the first version of ooRexx built and released. ooRexx
  3.0, the first ooRexx release, took place on March 25th 2005.
</para>
<para>
  From that point, the ooRexx team began regularly releasing new versions of ooRexx, up through the release of ooRexx
  3.2.0 on November 5, 2007. After the release of 3.2.0, the ooRexx team concentrated on refactoring the interpreter and
  on adding a new set of native APIs used to write extensions to the ooRexx interpreter.  The new APIs allowed the
  passing ooRexx objects to the routines and methods used in extensions.  Previously, only strings could be passed to
  external libraries. The refactored ooRexx interpreter and the new native APIs were introduced in ooRexx 4.0.0,
  released in August 2009.
</para>
<para>
  Up until that release in the middle of 2009, ooDialog remained virtually unchanged. The evolution of the Windows
  operating system had passed it by. ooDialog was designed for Windows 3.1, or at the latest Windows 95. It still
  referred to dialog controls such as the list-view as "new" controls. Despite the fact that the list-view control had
  been in use for over a decade. Some controls were considered "advanced" in ooDialog, while in Windows itself they were
  considered old news.
</para>
<para>
  Much of the design of ooDialog was based on constraints that existed in Windows 3.1 and Windows 95 that no longer
  existed in modern operating systems. For instance, the reason for having three separate ooDialog class files,
  <computeroutput>OODPLAIN.CLS, OODIALOG.CLS, and OODWIN32.CLS</computeroutput>, and for providing the simpler
  <computeroutput>PlainUserDialog</computeroutput> class was to have a smaller package that required less system
  resources for ordinary user interfaces like the standard dialogs.  That reason is not as valid in modern times as it
  was when ooDialog was being developed to run on Windows 3.1. Many of the programming techniques in the ooDialog
  implementation were also outdated. The conversion of dialog units to pixels and vice versa in ooDialog is a good
  example. While the technique must have worked in very early versions of Windows, it is completely wrong in Windows XP
  and later.
</para>
<para>
  The release of the new C++ native APIs in ooRexx 4.0.0 allowed much richer extensions to the Rexx interpreter to be
  written. Extensions could be implemented that had access to the actual objects instantiated within the
  interpreter. During the release of ooRexx 4.0.0, the internal work was started to convert ooDialog to use the C++
  APIs. This work lead to the complete refactoring of the ooDialog code, and the effort to bring ooDialog up to the
  level of Windows Vista and Windows 7 got started. New dialog controls were added along with new dialog objects and
  methods. However, this work was done in the internal development source tree and was not ready for the 4.0.0, 4.0.1,
  and 4.1.0 releases of ooRexx. Although ooDialog in those releases had some improvements and enhancements, they were
  minor.
</para>
<para>
  ooRexx 4.1.0 was released in December 2010. At that time, the internal work to convert ooDialog to the C++ APIs and
  the refactoring of the ooDialog source code was complete, but the refactored ooDialog was not ready for release,
  primarily because the documentation was not complete. The ooDialog distributed with ooRexx 4.1.0 was essentially the
  same as the ooDialog distributed with ooRexx 4.0.0, with bug fixes and some small enhancements.
</para>
<para>
  When the work of getting ooRexx 4.1.0 out the door was finished, some observations about ooDialog were made. One was
  that previously no real versioning of ooDialog was done. The second was that each of the ooDialogs shipped with ooRexx
  4.0.0, 4.0.1, and 4.1.0 only required an ooRexx 4.0.0 interpreter to work, while the refactored ooDialog in the
  internal development source tree required an ooRexx 4.1.0 interpreter. The third observation was that, since ooDialog
  is an extension to the Rexx interpreter, there is no reason why it could not be distributed independently of the
  ooRexx interpreter. Finally, it had been observed from some comments made in bugs opened up against ooDialog, that
  there were a few people who seemed to prefer to remain with an ooDialog that was designed for Windows 95, in essence
  an ooDialog unchanged from the ooDialog shipped with ooRexx 3.2.0.
</para>
<para>
  This lead to the decision to define a more formal versioning scheme for ooDialog and also to implement a means to
  distribute ooDialog independently of the ooRexx distribution. The version string of ooDialog had already been defined
  to be the version string of the ooRexx interpreter ooDialog was built under. A second part of the ooDialog version was
  to be the ooDialog level. This is similar to the language level of the Rexx interpreter. The initial ooDialog levels
  are listed in this table:
</para>
<table id="tblOODialogLevels" frame="all" pgwide='1'>
<title>ooDialog Levels</title>
<tgroup cols="3">
<colspec align='left' colwidth='1*'>
<colspec align='left' colwidth='1*'>
<colspec align='left' colwidth='6*'>
<thead>
<row>
<entry>Level</entry>
<entry>Required Interpreter</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>3.2.0</entry>
<entry>4.0.0</entry>
<entry>ooDialog implementation useing Rexx classic external routines.</entry>
</row>
<row>
<entry>4.1.0</entry>
<entry>4.0.0</entry>
<entry>ooDialog as shipped with ooRexx 4.0.0 with all bug fixes through ooRexx 4.1.0.</entry>
</row>
<row>
<entry>4.2.0</entry>
<entry>4.1.0</entry>
<entry>Refactored ooDialog completely implemented with the C++ native API.</entry>
</row>
</tbody>
</tgroup>
</table>

<variablelist>
  <varlistentry><term><emphasis role="bold">Level 3.2.0</emphasis></term>
  <listitem>
  <para>
    The ooDialog code at level 3.2.0 is frozen. Since the implementing code uses the classic external routines and the
    code itself is unchanged from the ooDialog shipped with ooRexx 3.2.0, ooDialog programs should behave
    exactly as they did under the ooDialog shipped with ooRexx 3.2.0. No fixes, enhancements, or changes will be made to
    the code.
  </para>
  <para>
    It is available as a separate download from SourceForge using the <emphasis role="italic">Switch ooDialog</emphasis>
    technology for users who would like to replace their installed ooDialog with a 3.2.0 level ooDialog. It requires
    that the installed ooRexx is 4.0.0 or later. Although the code is frozen, if a user can demonstrate an ooDialog
    program behaves differently using a 3.2.0 level ooDialog than it did under an actual ooRexx 3.2.0 installation, a
    fix will be considered.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Level 4.1.0</emphasis></term>
  <listitem>
  <para>
    ooDialog at level 4.1.0 is the ooDialog shipped with ooRexx 4.1.0. This ooDialog contains all the bug fixes and
    enhancements that were included in that distribution. It is also provided as a separate download on SourceForge and
    also requires the installed ooRexx be 4.0.0 or later. This code is frozen, no changes will be made to the code. Bugs
    found in this code will be fixed in upcoming releases of ooDialog.
  </para>
  <para>
    It allows users that have not upgraded their ooRexx from 4.0.0 or 4.0.1 to pick up the bug fixes in ooDialog
    included in the ooRexx 4.1.0 distribution. However, its primary purpose is for users who may be unhappy with the
    future direction of ooDialog. It will provide a way for users to upgrade to future versions of ooRexx and yet
    retain an unchanged ooDialog.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Level 4.2.0</emphasis></term>
  <listitem>
  <para>
    This is the actively maintained ooDialog level. The level will be incremented in the future as circumstances
    dictate. It requires an installed ooRexx of 4.1.0 or later. New versions of ooDialog at the 4.2.0 level will be
    released as they become ready. It is available as a separate download from SourceForge and will also be the
    ooDialog level shipped with future versions of ooRexx, (versions past ooRexx 4.1.0.)
  </para>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="sctCurrentRelease"><title>Current Release</title>
<para>
  The current release of ooDialog is the 4.2.0 level ooDialog. It is the first major enhancement of ooDialog in over a
  decade. This ooDialog has a lot of new and different things in it. In addition to the new dialog classes, new dialog
  control classes, new methods on existing classes, it includes design changes intended to simplify areas of ooDialog
  that seem to have been confusing in the past. Enhancements have been made that fix areas of ooDialog that have always
  been broken. All ooDialog users should take a close look at these changes.
</para>

<variablelist>
  <varlistentry id="termMethodNameUnification"><term><emphasis role="bold">Unification of Method Names</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Simplification of Requires Statement</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Simplification of Inherited Classes</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">True Call Backs from the Windows Message Loop</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Correct Conversion of Dialog Units to Pixels</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">New Dialog Classes</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">New Dialog Control Classes</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">New Methods on Existing Classes</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">New Classes</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Use of Objects as Arguments and Return Values</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Raising of Syntax Conditions</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Completely New Example Programs</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Updating of Existing Example Programs</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Revision of the Documentation</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Deprecated Classes and Methods</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Backwards Compatibility</emphasis></term>
  <listitem>
  <para>
    xxx and xxx sss.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="sctOODialogFuture"><title>Future</title>
<indexterm><primary>future directions</primary></indexterm>
<para>
  xxx and xxx sss.
</para>
<para>
  xxx and xxx sss.
</para>
<para>
  xxx and xxx sss.
</para>
</section>


<section id="reference"><title>ooDialog Class Reference</title>
<para>
  The classes provided by ooDialog form a hierarchy as shown in <link linkend="fig52">The Hierarchy of ooDialog
  Classes</link>.
</para>

<figure id="fig52"><title>The Hierarchy of ooDialog Classes</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxou0s12.jpg" scale="40">
</imageobject>
</mediaobject>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxou0s24.jpg" scale="40">
</imageobject>
</mediaobject>
</figure>

<para>The classes are: </para>
<variablelist>
<varlistentry><term>PlainBaseDialog, BaseDialog</term>
<listitem><para>Base methods regardless of whether the dialog is implemented as a binary
resource, a script, or dynamically. PlainBaseDialog provides limited functionality.
</para></listitem></varlistentry>
<varlistentry><term>PlainUserDialog</term>
<listitem><para>Subclass of PlainBaseDialog used to create a dialog with all its control
elements or to execute a dialog stored in a resource script (.RC). This class
has limited functionality.
</para></listitem></varlistentry>
<varlistentry><term>DynamicDialog, DialogExtensions, WindowBase, WindowExtensions</term>
<listitem><para>Internal mixin classes used to extend PlainBaseDialog, PlainUserDialog,
BaseDialog, UserDialog, and DialogControl. The methods provided by these classes
are not listed separately but are listed in BaseDialog or UserDialog.
</para></listitem></varlistentry>
<varlistentry><term>UserDialog</term>
<listitem><para>Subclass of BaseDialog used to create a dialog with all its control
elements, such as push buttons, check boxes, radio buttons, entry lines, and
list boxes.
</para></listitem></varlistentry>
<varlistentry><term>ResDialog</term>
<listitem><para>Subclass of BaseDialog for dialogs within a binary (compiled) resource
file (.DLL).
</para></listitem></varlistentry>
<varlistentry><term>TimedMessage</term>
<listitem><para>Class to show a message window for a defined duration.
</para></listitem></varlistentry>
<varlistentry><term>InputBox</term>
<listitem><para>Class to dynamically define a dialog with a message, one entry line,
and two push buttons (OK, Cancel).
</para></listitem></varlistentry>
<varlistentry><term>PasswordBox</term>
<listitem><para>Similar to InputBox, but keystrokes in the entry line are shown as asterisks
(*).
</para></listitem></varlistentry>
<varlistentry><term>IntegerBox</term>
<listitem><para>Similar to InputBox, but only numeric data can be entered in the entry
line.
</para></listitem></varlistentry>
<varlistentry><term>MultiInputBox</term>
<listitem><para>Similar to InputBox, but with multiple entry lines.
</para></listitem></varlistentry>
<varlistentry><term>ListChoice</term>
<listitem><para>Class to dynamically define a dialog with a list box, where one line
can be selected and returned to the caller.
</para></listitem></varlistentry>
<varlistentry><term>MultiListChoice</term>
<listitem><para>Similar to ListChoice, but more than one line can be selected and returned
to the caller.
</para></listitem></varlistentry>
<varlistentry><term>CheckList</term>
<listitem><para>Class to dynamically define a dialog with a group of check boxes, which
can be selected and returned to the caller.
</para></listitem></varlistentry>
<varlistentry><term>SingleSelection</term>
<listitem><para>Class to dynamically define a dialog with a group of radio buttons,
where one can be selected and returned.
</para></listitem></varlistentry>
<varlistentry><term>Dialog</term>
<listitem><para>Subclass of UserDialog for simple dialogs. You can change the default
dialog style from UserDialog to ResDialog.
</para></listitem></varlistentry>
<varlistentry><term>AnimatedButton</term>
<listitem><para>Class to implement an animated button within a dialog.
</para></listitem></varlistentry>
<varlistentry><term>DialogControl</term>
<listitem><para>Class to implement methods that are common to all dialogs and dialog
controls.
</para></listitem></varlistentry>
<varlistentry><term>TreeView</term>
<listitem><para>Class to implement a tree to display the list of items in a dialog in
a hierarchy.
</para></listitem></varlistentry>
<varlistentry><term>ListView</term>
<listitem><para>Class to implement a list-view to display the items in a dialog as a
collection.
</para></listitem></varlistentry>
<varlistentry><term>ProgressBar</term>
<listitem><para>Class to implement a progress indicator within a dialog.
</para></listitem></varlistentry>
<varlistentry><term>Trackbar</term>
<listitem><para>Class to implement a slider or trackbar within a dialog.
</para></listitem></varlistentry>
<varlistentry><term>Tab</term>
<listitem><para>Class to implement tabs, which can be compared to dividers in a notebook
or labels in a file cabinet.
</para></listitem></varlistentry>
<varlistentry><term>Static</term>
<listitem><para>Class to query and modify static controls, such as static text, group
boxes, and frames.
</para></listitem></varlistentry>
<varlistentry><term>Edit</term>
<listitem><para>Class to query and modify edit controls, which are also called entry
lines.
</para></listitem></varlistentry>
<varlistentry><term>Button</term>
<listitem><para>Class to implement push buttons within a dialog.
</para></listitem></varlistentry>
<varlistentry><term>RadioButton</term>
<listitem><para>Class to implement radio buttons within a dialog.
</para></listitem></varlistentry>
<varlistentry><term>CheckBox</term>
<listitem><para>Class to implement check boxes within a dialog.
</para></listitem></varlistentry>
<varlistentry><term>ListBox</term>
<listitem><para>Class to implement list boxes within a dialog.
</para></listitem></varlistentry>
<varlistentry><term>ComboBox</term>
<listitem><para>Class to implement a combo box, which combines a list box with an edit
control.
</para></listitem></varlistentry>
<varlistentry><term>ScrollBar</term>
<listitem><para>Class to implement a scroll bar within a dialog.
</para></listitem></varlistentry>
</variablelist>
</section>

</chapter>
