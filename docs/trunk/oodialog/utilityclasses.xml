<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog Reference SGML file.
    #
    # Copyright (c) 2005-2011, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<chapter id="utilityclasses"><title>Utility Classes and Objects</title>
<indexterm><primary>Utility Classes</primary></indexterm>
<para>
  The ooDialog framework provides a number of utility classes that are useful when writing more complex
  programs.  These classes do not easily fit into the category of a type of dialog or a type of dialog
  control and are therefore documented separately.  In addition, ooDialog places some globally available
  objects in the <computeroutput>.local</computeroutput> environment.
</para>
<para>
  The classes and objects in the following table are described in this chapter:
<table id="tUtilityClasses" frame="all">
<title>ooDialog Utility Classes and Objects</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Utility Class or Object</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry><link linkend="dotApplication">.application object</link></entry>
<entry>.</entry>
</row>
<row>
<entry><link linkend="dotConstDir">.constDir object</link></entry>
<entry>.</entry>
</row>
<row>
<entry><link linkend="dotSystemErrorCode">.systemErrorCode object</link></entry>
<entry>Reflects the <link linkend="defSystemErrorCode">system error code</link>, if set.</entry>
</row>
<row>
<entry><link linkend="clsApplicationManager">ApplicationManager Class</link></entry>
<entry>Manages application (global) settings for a single ooDialog program.</entry>
</row>
<row>
<entry><link linkend="clsDayState">DayState Class</link></entry>
<entry>Represents the state of each day within a single month. A helper class for the <link linkend="clsMonthCalendar">MonthCalendar</link>.</entry>
</row>
<row>
<entry><link linkend="clsDayStates">DayStates Class</link></entry>
<entry>A sequential collection of day state objects.</entry>
</row>
<row>
<entry><link linkend="clsDlgArea">DlgArea Class</link></entry>
<entry>Assists in laying out the dialog controls in a dynamically defined dialog.</entry>
</row>
<row>
<entry><link linkend="clsDlgAreaU">DlgAreaU Class</link></entry>
<entry>Assists in the creation of dynamically resizable dialogs.</entry>
</row>
<row>
<entry><link linkend="clsDlgUtil">DlgUtil Class</link></entry>
<entry>Provides some common, useful, utilities for working with dialogs.</entry>
</row>
<row>
<entry><link linkend="clsPoint">OS Class</link></entry>
<entry>Provides methods for accessing information about the operating system.</entry>
</row>
<row>
<entry><link linkend="clsPoint">Point Class</link></entry>
<entry>An object that represents a point in a 2-D coordinate system.</entry>
</row>
<row>
<entry><link linkend="clsRect">Rect Class</link></entry>
<entry>An object used to represent a rectangle in a 2-D coordinate system.</entry>
</row>
<row>
<entry><link linkend="clsSize">Size Class</link></entry>
<entry>An object encapsulating a width and height dimension in a 2-D coordinate system.</entry>
</row>
<row>
<entry><link linkend="clsVK">VK Class</link></entry>
<entry>Translates back and forth between virtual key code numbers and symbolic names.</entry>
</row>
<row>
<entry><link linkend="clsWindow">Window Class</link></entry>
<entry>A utility object with methods common to all windows.</entry>
</row>
</tbody></tgroup>
</table>
</para>


<section id="dotApplication"><title>.application object</title>
<indexterm><primary>.application</primary></indexterm>
<para>
  The <computeroutput>.application</computeroutput> object is an instance of the <link
  linkend="clsApplicationManager">ApplicationManager</link> class that is present in all ooDialog programs. The object is
  initialized and placed in the <computeroutput>.local</computeroutput> environment when the ooDialog package is loaded.
</para>
<para>
  The <computeroutput>.application</computeroutput> object is used by the programmer to manage application wide settings
  and constants. Its use is primarily to change global default values of ooDialog. For instance, by default, <link
  linkend="paraAutomaticDataDetection">automatic</link> data detection is on. (Automatic data detection is part of the
  <link linkend="sctUnderstandingDataAttributes">data </link> attributes concept.) The
  <computeroutput>.application</computeroutput> object can be used to change the default for all dialogs in a
  application to off.
</para>
<para>
  It would be most common to use the <computeroutput>.application</computeroutput> object at the start of a program.
  This example shows a typical way of changing the default for automatic data detection off for the entire application:
</para>
<programlisting>
<![CDATA[

  .application~autoDetection(.false)

  dlg = .SimpleDialog~new("UserMenuBar.rc", IDD_MAIN_DIALOG)
  if dlg~initCode <> 0 then do
    return 99
  end

  dlg~execute("SHOWTOP")
  ...

]]>
</programlisting>
</section>


<section id="dotConstDir"><title>.constDir object</title>
<indexterm><primary>.constDir</primary></indexterm>
<para>
  The <computeroutput>.constDir</computeroutput> is a Rexx <computeroutput>.directory</computeroutput> object that is
  present in all ooDialog programs. It is initialized and placed in the <computeroutput>.local</computeroutput>
  environment automatically by the <link linkend="dotApplication">application</link> object. The global
  <computeroutput>.constDir</computeroutput> is part of the <link linkend="ovvSymbolicIDMechanism">mechanism</link>
  allowing the use of <link linkend="defSymbolicID">symbolic</link> IDs in ooDialog programs.
</para>
<para>
  The <computeroutput>.constDir</computeroutput> is the most efficient way to use sybmolic IDs. However, to maintain
  backwards compatiblity with older ooDialog programs its use is turned off by default. The <link
  linkend="dotApplication">.application</link> object, through its <link
  linkend="mthUseGlobalConstDir">useGlobalConstDir</link> method or <link linkend="mthSetDefaults">setDefaults</link>
  method is used to specify how the <computeroutput>.constDir</computeroutput> is used.
</para>
<para>
  Other than specifying <emphasis role="italic">how</emphasis> the <computeroutput>.constDir</computeroutput> is to be
  used, the <computeroutput>.constDir</computeroutput> is mostly transparent to the programmer. To take best advantage
  of the <computeroutput>.constDir</computeroutput> the programmer should read the section in the Brief Overview chapter
  that discusses the symbolic ID <link linkend="ovvSymbolicIDMechanism">mechanism</link> in ooDialog.
</para>
<para>
  This example shows a typical use of the <computeroutput>.constDir</computeroutput> in a program. The example sets the
  program to use <emphasis role="bold">only</emphasis> the <computeroutput>.constDir</computeroutput> and populates the
  <computeroutput>.constDir</computeroutput> with the symbolic IDs contained in the file:
  <computeroutput>accountingApp.h</computeroutput>. Notice that the <computeroutput>.constDir</computeroutput> is not
  even directly referenced. Typically, the programmer never needs to directly access the
  <computeroutput>.constDir</computeroutput>. Again, the details are explained in the discussion on the symbolic ID
  <link linkend="ovvSymbolicIDMechanism">mechanism</link>.
</para>
<programlisting>
<![CDATA[

  .application~useGlobalConstDir('O', 'accountingApp.h')

  dlg = .MainMenuDlg~new("QuickBooks.dll", IDD_MAIN_MENU_DIALOG)
  if dlg~initCode == 0 then do
      dlg~execute("SHOWTOP", IDI_BOOKS)
  end
  ...

]]>
</programlisting>
</section>


<section id="dotSystemErrorCode"><title>.SystemErrorCode object</title>
<indexterm><primary>.SystemErrorCode</primary></indexterm>
<para>
  The .SystemErrorCode can be used, at times, to obtain additional information when the invocation of a
  method generates an operating system error.
</para>
<para>
  ooDialog provides an interface to the Windows operating system APIs.  To be specific, the Win32 APIs,
  and mostly those dealing with dialogs and other graphical aspects of the user interface.  Some of the
  Win32 APIs will set a system error code when something goes wrong.  (On the other hand, many of the
  Win32 APIs do not set a system error code.)
</para>
<para>
  When the ooDialog framework first initialize, it sets the value of .SystemErrorCode to 0.  <emphasis
  role="italic">Some</emphasis>, of the methods of the ooDialog classes will set the .SystemErrorCode to
  the value of the system error code when the method detects that a Win32 API has failed and has set the
  error code.  Most methods do <emphasis role="bold">not</emphasis> change the value of .SystemErrorCode.
  Only those methods that explicitly document they use .SystemErrorCode will ever change its value.
</para>
<para>
  One consequence of the fact that most methods do not change .SystemErrorCode is that its value is only
  meaningful immediately after the invocation of a method that is documented as using .SystemErrorCode.
  Those methods will set the code to 0 and, if they detect a Win32 API has set the system error code to
  non-zero, they will then set .SystemErrorCode to the value of the system error.  Checking
  .SystemErrorCode after the invocation of a method that does not set .SystemErrorCode will tell the
  programmer nothing. Neither that a system error happened, or that it did not happen.
</para>
<para>
  The <link linkend="mthGetImageClsImage">getImage()</link> method of the <link
  linkend="clsImage">.Image</link> class is one method that does change .SystemErrorCode.  This is an
  example of a possible usage:
</para>
<programlisting>
<![CDATA[
image = .Image~getImage("resources\bogus.bmp")
if image~isNull then do
  say "Error getting the bogus.bmp image."
  if .SystemErrorCode <> 0 then do
    say 'System error code:' .SystemErrorCode
    say '  system message:' SysGetErrorText(.SystemErrorCode)
  end
end

/*
  Output on the screen might be:

Error getting the bogus.bmp image.
System error code: 2
  system message: The system cannot find the file specified.
*/
]]>
</programlisting>
</section>


<section id="clsDlgUtil"><title>DlgUtil Class</title>
<indexterm><primary>DlgUtil class</primary></indexterm>
<para>
  All the methods of the DlgUtil class are class methods. There are no instance methods, other than inherited methods,
  for this class.  The class methods are a collection of common utilities, mostly for converting different Windows
  values, getting version information, and the like.
</para>

<section id="sctMethodsDlgUtil"><title>Method Table</title>
<para>
  The <computeroutput>DlgUtil</computeroutput> class implements the methods listed in the following table.

<table id="tDlgUtilMethods" frame="all">
<title>Methods of the DlgUtil class</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthAndClsDlgUtil">and</link></entry>
<entry><emphasis role="italic">and's</emphasis> two numbers and returns the result.</entry>
</row>
<row>
<entry><link linkend="mthComCtl32Version">comCtl32Version</link></entry>
<entry>Determines the Common Controls Library version in use by ooDialog.</entry>
</row>
<row>
<entry><link linkend="mthGetSystemMetricsClsDlgUtil">getSystemMetrics</link></entry>
<entry>Obtains the system metric value for a given index.</entry>
</row>
<row>
<entry><link linkend="mthHiWord">hiWord</link></entry>
<entry>Returns the high-order word portion of a number as a number in the range of 0 through 65535.</entry>
</row>
<row>
<entry><link linkend="mthLoWord">loWord</link></entry>
<entry>Returns the low-order word portion of a number as a number in the range of 0 through 65535.</entry>
</row>
<row>
<entry><link linkend="mthMakeLParam">makeLParam</link></entry>
<entry>Packs two numbers into a LPARAM argument and returns the result.</entry>
</row>
<row>
<entry><link linkend="mthMakeWParam">makeWParam</link></entry>
<entry>Packs two numbers into a WPARAM argument and returns the result</entry>
</row>
<row>
<entry><link linkend="mthOrClsDlgUtil">or</link></entry>
<entry><emphasis role="italic">or's</emphasis> two or more numbers and returns the result.</entry>
</row>
<row>
<entry><link linkend="mthScreenArea">screenArea</link></entry>
<entry>Retrieves the usable screen area (work area.) on the primary display monitor.</entry>
</row>
<row>
<entry><link linkend="mthScreenSize">screenSize</link></entry>
<entry>Retrieves the screen size in either pixels, dialog units, or both.</entry>
</row>
<row>
<entry><link linkend="mthSHiWord">sHiWord</link></entry>
<entry>Returns the high-order word portion of a number as a number in the range of -32768 through 32767.</entry>
</row>
<row>
<entry><link linkend="mthSLoWord">sLoWord</link></entry>
<entry>Returns the low-order word portion of a number as a number in the range of -32768 through 32767.</entry>
</row>
<row>
<entry><link linkend="mthThreadID">threadID</link></entry>
<entry>Returns the thread identifier of the thread the method is executing in.</entry>
</row>
<row>
<entry><link linkend="mthVersion">version</link></entry>
<entry>Returns the ooDialog version string.</entry>
</row>
</tbody></tgroup>
</table>
</para>
</section>

<section id="mthVersion"><title>version (Class Method)</title>
<indexterm><primary>version</primary></indexterm>
<indexterm><primary>DlgUtil class</primary><secondary>version</secondary></indexterm>
<programlisting>
<![CDATA[

>>-version(--+---------+-)-----------------------><
             +-format--+
]]>
</programlisting>

<para>
  Returns the ooDialog version string.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
    <varlistentry><term>format [optional]</term>
    <listitem>
    <para>
      A keyword indicating the format of the returned version string.  Only the first letter is needed and case is not
      significant.  Any unrecognized keyword is ignored and the default format is used.  The format for each keyword is
      as follows:
    </para>
    <variablelist>
      <varlistentry><term>Full</term>
      <listitem>
      <para>
        A string specifying the version of the ooRexx interpreter that ooDialog was built with.  This is the default.
        The string has the format: <computeroutput>ooDialog Version x.x.x.SS (an ooRexx Windows Extension)
        </computeroutput> where x.x.x is the ooRexx interpreter version and SS is the Subversion revision number of the
        build. The actual version string might look like: <computeroutput>ooDialog Version 4.0.0.3734 (an ooRexx Windows
        Extension)</computeroutput>
      </para>
      </listitem></varlistentry>
      <varlistentry><term>Short</term>
      <listitem>
      <para>
        Only the x.x.x.SS part of the full version string is returned. Using the above example, the string would look
        like <computeroutput>4.0.0.3734</computeroutput> .
      </para>
      </listitem></varlistentry>
      <varlistentry><term>Level</term>
      <listitem>
      <para>
        The ooDialog <link linkend="tblOODialogLevels">level</link>. Continuing with the same example the level would be
        <computeroutput>4.1.0</computeroutput>
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    A string in one of the formats specified above.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
<programlisting>
<![CDATA[
v = .DlgUtil~version
say v
say

if .DlgUtil~version("SHORT") < 4.1.0.0000 then do
  say 'Too bad, you are still running ooRexx 4.0.0'
end
else do
  if .DlgUtil~version("LEVEL") < 4.2.0 then
    say 'You should really get a 4.2.0 ooDialog, it is much improved.'
end

::requires 'ooDialog.cls'

/* On the screen you might see:

ooDialog Version 4.0.0.3768 (an ooRexx Windows Extension)

Too bad, you are still running ooRexx 4.0.0

*/
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthComCtl32Version"><title>comCtl32Version (Class Method)</title>
<indexterm><primary>comCtl32Version</primary></indexterm>
<indexterm><primary>DlgUtil class</primary><secondary>comCtl32Version</secondary></indexterm>
<programlisting>
<![CDATA[

>>--comCtl32Version(--+----------+-)-------------><
                      +--format--+

]]>
</programlisting>

<para>
  Use this method to determine the version of the<link linkend="ovvComctl32"> Common Controls Library</link> used by
  ooDialog on the current system.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
    <varlistentry><term>format [optional]</term>
    <listitem>
    <para>
      A keyword indicating the format of the returned version string.  Only the first letter is needed and case is not
      significant.  Any unrecognized keyword is ignored and the default format is used.  The format for each keyword is
      as follows:
    </para>
    <variablelist>
      <varlistentry><term>Short</term>
      <listitem>
      <para>
        The version number, for instance <computeroutput>4.72</computeroutput> or <computeroutput>6.0</computeroutput>.
        This is the default.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>Number</term>
      <listitem>
      <para>
        This is an alias for short.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>OS</term>
      <listitem>
      <para>
        The minimum operating system that can be expected to be compatible with the library. Earlier versions of the
        common control library were also distributed with Internet Explorer and so an OS part of say,
        <computeroutput>W98 / IE 4.01</computeroutput> would indicate that the current common control library supports
        all the features available on Windows 98 or with Internet Explorer 4.01.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>Full</term>
      <listitem>
      <para>
        The full format string in the format <computeroutput>comctl32.dll version 6.0 (XP)</computeroutput>. Where the
        6.0 is the number part and XP is the OS part.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    This method returns a string in one of the formats described above.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    In the following example, the programmer repositions the dialog controls under certain conditions.  In Windows XP
    and later, this task is more accurate if the <computeroutput>getIdealSize()</computeroutput> method of the Button
    class is used. However, the programmer needs the application to also run on Windows 2000.  He uses the
    <computeroutput>comCtl32Version()</computeroutput> method to determine if the <link
    linkend="mthGetIdealSize">getIdealSize</link> method is available.  If it is not available he uses an alternative,
    but less accurate method to reposition the controls.

<programlisting>
<![CDATA[
::method repositionControls

  if .DlgUtil~comCtl32Version < 6.0 then return self~doW2KReposition

  size = self~newPushButton(IDC_CHECK_TWO)~getIdealSize
  if size == .nil then return .false

  -- do the repositioning

return .true
]]>
</programlisting>
    An alternative way to achieve the same thing might be:
<programlisting>
<![CDATA[
::method repositionControls

  if .DlgUtil~comCtl32Version('O') == "XP" then return self~doXPReposition

  -- Do the less accurate repositioning
  ...

return .true
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthLoWord"><title>loWord (Class Method)</title>
<indexterm><primary>loWord</primary></indexterm>
<indexterm><primary>DlgUtil class</primary><secondary>loWord</secondary></indexterm>
<programlisting>
<![CDATA[
>>--loWord(--param--)----------------------------><

]]>
</programlisting>

<para>
  The Windows API often packs two values into a single number.  One value in the low-order word and the other value in
  the high-order word.  In ooDialog this is most often seen in the arguments passed to event notification methods.  This
  utility method is used to extract the low-order word from a number.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>param [required]</term>
      <listitem>
      <para>
        The number whose low-order word is needed.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return is the low-order word portion of the number. This whole number value will be in the range of 0 through
    65535.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Unfortunately, the practice of packing two values into a single number can lead to ambiguities, especially when the
    values can be either negative or positive, and start getting larger. The number returned from the <emphasis
    role="italic">loWord</emphasis> method will always be non-negative. For situations where the expected returned
    number may be negative, the <link linkend="mthSLoWord">sLoWord</link> method is provided.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    A common place in the Windows API where two values are packed into a single number is where the API deals with
    position.  This example shows how to extract the x and y position coordinates of a dialog after it has been moved.
    The example is complete, it can be cut and pasted into a file and will execute as is.
<programlisting id="exampleLoWordClsDlgUtil">
<![CDATA[

  dlg = .MovingDialog~new
  dlg~createCenter(100, 60, "Move Me")
  dlg~execute("SHOWTOP")

::requires 'ooDialog.cls'

::class 'MovingDialog' subclass UserDialog

::method init
  forward class (super) continue

  self~connectMove(onMove)

::method onMove
  use arg unUsed, posInfo

  x = .DlgUtil~loWord(posInfo)
  y = .DlgUtil~hiWord(posInfo)
  say 'At coordinate (' x',' y' ) on the screen. (In pixels.)'

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthHiWord"><title>hiWord (Class Method)</title>
<indexterm><primary>hiWord</primary></indexterm>
<indexterm><primary>DlgUtil class</primary><secondary>hiWord</secondary></indexterm>
<programlisting>
<![CDATA[
>>--hiWord(--param--)----------------------------><

]]>
</programlisting>

<para>
  The Windows API often packs two values into a single number.  One value in the low-order word and the other value in
  the high-order word.  In ooDialog this is most often seen in the arguments passed to event notification methods.  This
  utility method is used to extract the high-order word from a number.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>param [required]</term>
      <listitem>
      <para>
        The number whose high-order word is needed.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return is the high-order word portion of the number. This whole number value will be in the range of 0 through
    65535.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Unfortunately, the practice of packing two values into a single number can lead to ambiguities, especially when the
    values can be either negative or positive, and start getting larger. The number returned from the <emphasis
    role="italic">hiWord</emphasis> method will always be non-negative. For situations where the expected returned
    number may be negative, the <link linkend="mthSHiWord">sHiWord</link> method is provided.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    See the <link linkend="exampleLoWordClsDlgUtil">loWord() example</link>.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


<section id="mthSLoWord"><title>sLoWord (Class Method)</title>
<indexterm><primary>sLoWord</primary></indexterm>
<indexterm><primary>DlgUtil class</primary><secondary>sLoWord</secondary></indexterm>
<programlisting>
<![CDATA[
>>--sLoWord(--param--)----------------------------><

]]>
</programlisting>

<para>
  The Windows API often packs two values into a single number.  One value in the low-order word and the other value in
  the high-order word. The <emphasis role="italic">sLoWord</emphasis> method is the signed version of the <link
  linkend="mthLoWord">loWord</link> method. It is used to extract the low-order word from a number, where the value of
  the low-order word may be positive or negative.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>param [required]</term>
      <listitem>
      <para>
        The number whose low-order word is needed.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return is the low-order word portion of the number. The returned whole number will be in the range of -32768 to
    32767
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Unfortunately, the practice of packing two values into a single number can lead to ambiguities, especially when the
    values can be either negative or positive, and start getting larger. The number returned from the <emphasis
    role="italic">sLoWord</emphasis> method can be either negative or positive, but the largest maximum number will only
    be 32767. For situations where the expected returned number is always positive and may be larger than 32767, the
    <link linkend="mthLoWord">loWord</link> method is provided.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    One place where two values are packed into one number by the operating system is the return from scrolling an edit
    control. The operating system returns true or false in the high word, for success or failure. The lines scrolled are
    in the low word. When the edit control is scrolled from the bottom towards the top, the number of lines is negative.
    This example shows the result of using the <link linkend="mthScrollCommand">scrollCommand</link> repeatedly until
    the top of the edti control is reached:

<programlisting id="exampleSLoWordClsDlgUtil">
<![CDATA[

  success = .true
  do while success
    ret = editControl~scrollCommand("PAGEUP")

    success = .DlgUtil~sHiWord(ret)
    linesMoved = .DlgUtil~sLoWord(ret)

    say "Scrolled the edit control:"
    say "  Success?" success
    say "  Lines:  " linesMoved
  end

/* Output might be:

Scrolled the edit control:
  Success? 1
  Lines:   -16
Scrolled the edit control:
  Success? 1
  Lines:   -16
...
Scrolled the edit control:
  Success? 1
  Lines:   -16
Scrolled the edit control:
  Success? 1
  Lines:   -5
Scrolled the edit control:
  Success? 0
  Lines:   0

*/

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthSHiWord"><title>sHiWord (Class Method)</title>
<indexterm><primary>sHiWord</primary></indexterm>
<indexterm><primary>DlgUtil class</primary><secondary>sHiWord</secondary></indexterm>
<programlisting>
<![CDATA[
>>--sHiWord(--param--)---------------------------><

]]>
</programlisting>

<para>
  The Windows API often packs two values into a single number.  One value in the low-order word and the other value in
  the high-order word. The <emphasis role="italic">sHiWord</emphasis> method is the signed version of the <link
  linkend="mthHiWord">HiWord</link> method. It is used to extract the high-order word from a number, where the value of
  the high-order word may be positive or negative.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>param [required]</term>
      <listitem>
      <para>
        The number whose high-order word is needed.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return is the high-order word portion of the number. The returned whole number will be in the range of -32768 to
    32767.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Unfortunately, the practice of packing two values into a single number can lead to ambiguities, especially when the
    values can be either negative or positive, and start getting larger. The number returned from the <emphasis
    role="italic">sHiWord</emphasis> method can be either negative or positive, but the largest maximum number will only
    be 32767. For situations where the expected returned number is always positive and may be larger than 32767, the
    <link linkend="mthHiWord">hiWord</link> method is provided.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    See the <link linkend="exampleSLoWordClsDlgUtil">sLoWord() example</link>.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


<section id="mthMakeLParam"><title>makeLParam (Class Method)</title>
<indexterm><primary>makeLParam</primary></indexterm>
<indexterm><primary>DlgUtil class</primary><secondary>makeLParam</secondary></indexterm>
<programlisting>
<![CDATA[
>>--makeLParam(--numLow--,--numHigh--)-----------><

]]>
</programlisting>

<para>
  When a <link linkend="ovvWindowMessages">message</link> is <link linkend="mthSendMessage">sent</link> to an <link
  linkend="ovvUnderlying">underlying</link> window two of the arguments are the WPARAM and the LPARAM parameters. Quite
  often the Windows API requires that two numbers be packed into the LPARAM argument. The <emphasis
  role="italic">makeLParam</emphasis> method is a convenience method used to perform the packing.  It is similar to the
  <link linkend="mthLoWord">loWord</link> and <link linkend="mthHiWord">hiWord</link> methods, but works in the
  opposite direction.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>numLow [required]</term>
    <listitem>
    <para>
      A whole number to be packed into the low word position of the LPARAM number.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>numHigh [required]</term>
    <listitem>
    <para>
      A whole number to be packed into the high word position of the LPARAM number.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return is a number suitable for the LPARAM argument in a message sent to an underlying window, when the message
    requires two values in LPARAM.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry id="exampleMakeLParam"><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    This example shows the implementation of a method used to set the margins in an edit control
<programlisting>
<![CDATA[
::method setEditMargins
    use arg left, right

    EC_LEFTMARGIN  = "0x0001"
    EC_RIGHTMARGIN = "0x0002"
    EC_USEFONTINFO = "0xFFFF"
    EM_SETMARGINS  = "0x00D3"

    if arg(1, 'O'), arg(2, 'O') then do
       self~sendMessage(EM_SETMARGINS, 0, EC_USEFONTINFO)
    end
    else do
       flag = 0
       if arg(1, 'E') then flag = EC_LEFTMARGIN
       if arg(2, 'E') then flag = .DlgUtil~or(flag, EC_RIGHTMARGIN)
       lParam = .DlgUtil~makeLParam(left, right)
       self~sendMessage(EM_SETMARGINS, flag, lParam)
    end
    return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DlgUtil::makeLParam() -->


<section id="mthMakeWParam"><title>makeWParam (Class Method)</title>
<indexterm><primary>makeWParam</primary></indexterm>
<indexterm><primary>DlgUtil class</primary><secondary>makeWParam</secondary></indexterm>
<programlisting>
<![CDATA[
>>--makeWParam(--numLow--,--numHigh--)-----------><

]]>
</programlisting>

<para>
  When a <link linkend="ovvWindowMessages">message</link> is <link linkend="mthSendMessage">sent</link> to an <link
  linkend="ovvUnderlying">underlying</link> window two of the arguments are the WPARAM and the LPARAM parameters. Quite
  often the Windows API requires that two numbers be packed into the WPARAM argument. The <emphasis
  role="italic">makeWParam</emphasis> method is a convenience method used to perform the packing.  It is similar to the
  <link linkend="mthLoWord">loWord</link> and <link linkend="mthHiWord">hiWord</link> methods, but works in the
  opposite direction.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>numLow [required]</term>
    <listitem>
    <para>
      A whole number to be packed into the low word position of the WPARAM number.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>numHigh [required]</term>
    <listitem>
    <para>
      A whole number to be packed into the high word position of the WPARAM number.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return is a number suitable for the WPARAM argument in a message sent to an underlying window, when the message
    requires two values in WPARAM.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    Although the <link linkend="exampleMakeLParam">example</link> for <emphasis role="italic">makeLParam</emphasis> does
    not show the use of <emphasis role="italic">makeWParam</emphasis>, the basic idea in using either method is
    essentially the same.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DlgUtil::makeWParam() -->

<section id="mthOrClsDlgUtil"><title>or (Class Method)</title>
<indexterm><primary>or</primary></indexterm>
<indexterm><primary>DlgUtil class</primary><secondary>or</secondary></indexterm>
<programlisting>
<![CDATA[
         +-,-------+
         V         |
>>--or(----number--+--)--------------------------><

]]>
</programlisting>

<para>
  Combines any number of numerical values into a single number by <emphasis role="italic">oring</emphasis> the
  individual numbers together.  This is the typical or operation used by assembly and C programmer's.  The ooDialog
  programmer does not need to understand the concept to use this method.  Some arguments to some methods in the ooDialog
  framework can take a value that is a combination of some individual <emphasis role="italic">flags</emphasis>.  The or
  method is provided to construct this combination.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    There is no restriction on the number of arguments to this method, other than each argument must represent a whole
    number.
  </para>
  <para>
    As a convenience, the whole numbers can also be specified as a string with the following format:
    <computeroutput>0x</computeroutput> followed by a series of hexadecimal digits with no spaces. Such as
    <computeroutput>"0xff12abc9"</computeroutput> or <computeroutput>"0x1"</computeroutput> or
    <computeroutput>"0x00000080"</computeroutput>. This makes it easy to look up and use the value of a flag directly.
    For instance looking up the value of <computeroutput>ILC_COLOR24</computeroutput>, one would see it is
    <computeroutput>0x00000018</computeroutput>. This value could be used directly in the
    <computeroutput>or()</computeroutput> method. Case is not significant in the string.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return value is a number that is the result of combining all the individual arguments together.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    One method that has an argument that can be the result of combining a number of flags is the <link
    linkend="mthCreateClsImageList">create()</link> method of the <link
    linkend="clsImage">.ImageList</link> class.  This is how the or method might be used
<programlisting>
<![CDATA[
  flags = .DlgUtil~or(.Image~toID(ILC_COLOR24), .Image~toID(ILC_MASK))

  -- Create an empty .ImageList object:
  imageList = .ImageList~create(.Size~new(61, 46), flags, 10, 10);
]]>
</programlisting>
    </para>
    <para>
      The following is equivalent to the above example:
<programlisting>
<![CDATA[
  flags = .DlgUtil~or(0x00000018, 0x00000001)

  -- Create an empty .ImageList object:
  imageList = .ImageList~create(.Size~new(61, 46), flags, 10, 10);
]]>
</programlisting>
  </para>
  <para>
    To round out the examples a little:
<programlisting>
<![CDATA[
  flags = .DlgUtil~or(.Image~toID(ILC_COLOR24), .Image~toID(ILC_MASK))
  say "Flags value:" flags

  flags = .DlgUtil~or(0x00000018, 0x00000001)
  say "Flags value:" flags

::requires 'oodDialog.cls'

/* Output would be:

     Flags value: 25
     Flags value: 25
*/
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DlgUtil::or() [class method] -->

<section id="mthAndClsDlgUtil"><title>and (Class Method)</title>
<indexterm><primary>and</primary></indexterm>
<indexterm><primary>DlgUtil class</primary><secondary>and</secondary></indexterm>
<programlisting>
<![CDATA[
>>--and(--number1-,-number2--)-------------------><

]]>
</programlisting>

<para>
  Combines two numbers into a single number by <emphasis role="italic">anding</emphasis> the individual numbers
  together.  This is the typical <emphasis role="italic">and</emphasis> operation used by assembly and C programmer's.
  The typical ooDialog programmer would have no need of the method. It is provided as a convenience for use in
  sophisticated ooDialog programs.
</para>
<para>
  The normal use of an <emphasis role="italic">and</emphasis> operation in ooDialog programs is to extract the low or
  high words from an argument returned from the operating system. The addition of the <link
  linkend="mthLoWord">loWord</link>() and <link linkend="mthHiWord">hiWord</link>() methods to the ooDialog framework
  have eliminated most of the reason for this usage.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The required two arguments are the whole numbers to be <emphasis role="italic">anded</emphasis> together.
  </para>
  <para>
    As a convenience, the whole numbers can also be specified as a string with the following format:
    <computeroutput>0x</computeroutput> followed by a series of hexadecimal digits with no spaces. Such as
    <computeroutput>"0xff12abc9"</computeroutput> or <computeroutput>"0x1"</computeroutput> or
    <computeroutput>"0x00000080"</computeroutput>.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return value is the number that is the result of <emphasis role="italic">anding</emphasis> the two arguments
    together.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example is part of a generic method in an application that returns the text of an edit control. The
    application is a complex one and has many edit controls that are read only. The text for read only controls is
    ignored. The method returns .nil for read only controls to differentiate the difference between a read only
    control and a control that has the empty string.
  </para>
  <para>
    The value of the ES_READONLY style is 0x0800.
<programlisting>
<![CDATA[

::method getEditText private
  use strict arg control

  -- If the control is read only, we just return .nil
  if .DlgUtil~and(control~getStyleRaw, 0x0800) <> 0 then return .nil

  ...
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DlgUtil::and() [class method] -->

<section id="mthGetSystemMetricsClsDlgUtil"><title>getSystemMetrics (Class Method)</title>
<indexterm><primary>getSystemMetrics</primary></indexterm>
<indexterm><primary>DlgUtil class</primary><secondary>getSystemMetrics</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getSystemMetrics(--index--)------------------><

]]>
</programlisting>

<para>
  Obtains the system metric value for the given index.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>The only argument is:
  <variablelist>
    <varlistentry><term>index</term>
    <listitem>
    <para>
      The numeric index of the system metric.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return value is dependent on the index queried. See the <emphasis role="italic">remarks</emphasis> section.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Good documentation on the system metrics is found in the <link linkend="defWindowsDoc">MSDN
    Library</link> under the GetSystemMetrics function.  This documentation contains both the
    numeric value of the different indexes and information on what is returned for each index. The
    documentation is easy to found using a Google search of &quot;GetSystemMetrics MSDN
    library&quot;
  </para>
  <para>
    The OS will return 0 if an invalid index is used.  However, the return value for some indexes is also 0.  The
    programmer will need to determine from the context if 0 is an error return or not.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following code snippet is from an application where the user can have 5, 6, or more, independent dialogs open at
    one time. One of the menu options is &quot;Tile Dialogs.&quot; When the user selects this option all the open
    dialogs are &quot;tiled.&quot;
  </para>
  <para>
    All the open dialog objects are stored in a queue.  In the <computeroutput>onTile</computeroutput> method, which is
    invoked when the user selects the menu item, each dialog is fetched in turn from the queue.  Then the  dialog is
    repositioned at an offset from the preceding dialog. It is shifted to the right the width of 2 scroll bars and
    shifted down the the width of the title bar.  (This width is the title bar width plus the thin border around the
    title bar.)  The height of the thin border, the height of the title bar, and the width of a scroll bar are all
    determined by querying the system metrics.
<programlisting>
<![CDATA[

::method onTile
  expose offSetX offSetY dialogQueue

  -- SM_CXVSCROLL = 20
  -- SM_CYCAPTION = 4
  -- SM_CYBORDER  = 6

  if \ offSetX~datatype('W') then do
    scrollBarX = .DlgUtil~getSystemMetrics(20)
    titleBarY = .DlgUtil~getSystemMetrics(4)
    windowBorderY = .DlgUtil~getSystemMetrics(6)

    offSetX = 2 * scrollBarX
    offSetY = (2 * windowBorderY) + titleBarY
  end

  parse value self~getWindowRect(self~dlgHandle) with x y .

  do dlg over dialogQueue
    x += offSetX
    y += offSetY

    self~setWindowRect(dlg~dlgHandle, x, y, 0, 0, "NOSIZE")
  end
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DlgUtil::getSystemMetrics() [class method] -->

<section id="mthScreenArea"><title>screenArea (Class Method)</title>
<indexterm><primary>screenArea</primary></indexterm>
<indexterm><primary>DlgUtil class</primary><secondary>screenArea</secondary></indexterm>
<programlisting>
<![CDATA[
>>--screenArea-----------------------------------><

]]>
</programlisting>

<para>
  Gets the usable screen area (work area.) on the primary display monitor. The work area is the portion of the screen
  not obscured by the system taskbar or by application desktop toolbars.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    This method takes no arguments.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    A <link linkend="clsRect">.Rect</link> object that contains the coordinates of the work area. The coordinates are
    expressed in <link linkend="defScreenCoordinates">screen</link> coordinates.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DlgUtil::screenArea() -->

<section id="mthScreenSize"><title>screenSize (Class Method)</title>
<indexterm><primary>screenSize</primary></indexterm>
<indexterm><primary>DlgUtil class</primary><secondary>screenSize</secondary></indexterm>
<programlisting>
<![CDATA[
>>--screenSize(--+--------+--+-----------+--)----><
                 +--flag--+  +-,-dlgObj--+
]]>
</programlisting>

<para>
  Retrieves the screen size in either pixels, dialog units, or both.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>flag [optional]</term>
      <listitem>
      <para>
        A keyword signaling whether to return the size in pixels, dialog units, or both. The default is both. The keywords
        are PIXELS, DIALOGUNITS, and BOTH.  Only the first letter is needed and case is insignificant.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>dlgObj [optional]</term>
      <listitem>
      <para>
        A Rexx dialog object. When this argument is used, dialog units are calculated correctly for the dialog. If it is
        omitted, the dialog units will most likely be incorrect. See the remarks section
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return is dependent on the flag in use:
    <variablelist>
      <varlistentry><term>Pixels:</term>
      <listitem>
      <para>
        A <link linkend="clsSize">Size</link> object with the screen size in pixels.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>DialogUnits</term>
      <listitem>
      <para>
        A <link linkend="clsSize">Size</link> object with the screen size in dialog units.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>Both</term>
      <listitem>
      <para>
        An <computeroutput>Array</computeroutput>> with the screen size in dialog units at indexes 1 and 2 and the size
        in pixels at indexes 3 and 4. Indexes 1 and 3 contain the width, indexes 2 and 4 contain the height..
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    If a Rexx dialog object is not supplied, it is unlikely that the <link linkend="defDialogUnit">dialog units</link>
    will be correct. Without a reference to a dialog, the method calculates the dialog units using 8 point System font.
    Since dialog units are dependent on the font in use for a specific dialog, It is highly unlikely that this is
    correct for any specific dialog.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example calculates the mid-point of the upper left quadrant of the screen and positions the dialog at that
    point:
<programlisting>
<![CDATA[

::method initDialog

  -- Get the screen size and then position ourself in the upper left quadrant.
  s = .DlgUtil~screenSize('P')
  p = .Point~new(s~width % 4, s~height % 4)
  self~moveTo(p, "SHOWWINDOW")
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DlgUtil::screenSize() -->

<section id="mthThreadID"><title>threadID (Class Method)</title>
<indexterm><primary>threadID</primary></indexterm>
<indexterm><primary>DlgUtil class</primary><secondary>threadID</secondary></indexterm>
<programlisting>
<![CDATA[
>>--threadID-------------------------------------><

]]>
</programlisting>

<para>
  Returns the thread identifier of the thread the method is executing in.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    There are no arguments for this method.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return is a non-zero positive number, the number the operating system uses to identify the current thread.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Until the thread terminates, the thread identifier uniquely identifies the thread throughout the operating system.
  </para>
  <para>
    This is a convenience method for the use of the developers more than anything. However, for any user of ooRexx it
    does provide some insight into the concurrency functionality of ooRexx.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example displays the thread ID from several different threads, (activities,) during the life cycle of a dialog.
<programlisting>
<![CDATA[

  dlg = .SimpleDialog~new
  say "In the start up of the program thread ID:  " .DlgUtil~threadID
  dlg~execute("SHOWTOP", IDI_DLG_OOREXX)

::requires "ooDialog.cls"

::class 'SimpleDialog' subclass UserDialog

::method init
  forward class (super) continue

  self~create(30, 30, 257, 123, "Simple Dialog", "CENTER")

::method defineDialog

  self~createPushButton(IDOK, 142, 99, 50, 14, "DEFAULT", "Ok")
  self~createPushButton(IDCANCEL, 197, 99, 50, 14, , "Cancel")

::method initDialog

  say "In initDialog() thread ID:                 " .DlgUtil~threadID
  self~start("secondActivity")

::method secondActivity unguarded

  reply 0
  j = SysSleep(1)
  say "Executing in the second activity thread ID:" .DlgUtil~threadID

::method ok unguarded

  say "In the ok method thread ID:                " .DlgUtil~threadID
  return self~ok:super

/* The output on the console might ge:

In the start up of the program thread ID:   128
In initDialog() thread ID:                  128
Executing in the second activity thread ID: 2672
In the ok method thread ID:                 2344

*/
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DlgUtil::threadID() -->

</section> <!-- End DlgUtil Class -->


<section id="clsApplicationManager"><title>ApplicationManager Class</title>
<indexterm><primary>ApplicationManager class</primary></indexterm>
<para>
  x
</para>
<para>
  x
</para>

<section id="sctMethodsApplicationMgr"><title>Method Table</title>
<para>
  The following table lists the class and instance methods of the <computeroutput>ApplicationManager</computeroutput> class:

<table id="tblMethodsApplicationMgr" frame="all"> <title>ApplicationManager Class Method Reference</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center"><emphasis role="bold">Objects</emphasis></entry>
<entry align="center"><emphasis role="bold"></emphasis></entry>
</row>
<row>
<entry><link linkend="dotConstDir"></link></entry>
<entry>A global (application wide) <computeroutput>.directory</computeroutput> object used to resolve symbolic IDs.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
<entry align="center"><emphasis role="bold"></emphasis></entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
<entry align="center"><emphasis role="bold"></emphasis></entry>
</row>
<row>
<entry><link linkend="mthUseGlobalConstDir">useGlobalConstDir</link></entry>
<entry>Defines how the global <link linkend="dotConstDir">.constDir</link> is used in the application.</entry>
</row>
<row>
<entry><link linkend="mthAddToConstDir">addToConstDir</link></entry>
<entry>Adds symbols, symbolic IDs, to the <computeroutput>.constDir</computeroutput>.</entry>
</row>
<row>
<entry><link linkend="mthAutoDetectionClsApplicationManger">autoDetection</link></entry>
<entry>Sets the application global default for <link linkend="paraAutomaticDataDetection">autoDetction</link> to off, or on.</entry>
</row>
<row>
<entry><link linkend="mthDefaultFont">defaultFont</link></entry>
<entry>Changes the <link linkend="mthClsSetDefaultFont">default</link> font for the application.</entry>
</row>
<row>
<entry><link linkend="mthSetDefaults"></link>setDefaults</entry>
<entry>Sets one or more of the global defualts for the application.</entry>
</row>
</tbody></tgroup>
</table>
</para>
</section>

<section id="mthUseGlobalConstDir"><title>useGlobalConstDir</title>
<indexterm><primary>useGlobalConstDir</primary></indexterm>
<indexterm><primary>ApplicationManager class</primary><secondary>useGlobalConstDir</secondary></indexterm>
<programlisting>
<![CDATA[
>>--useGlobalConstDir(--mode--+--------------+--)---------------><
                              +--symbolFile--+
]]>
</programlisting>

<para>
  xx
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>mode [required]</term>
      <listitem>
      <para>
        xx
      </para>
      </listitem></varlistentry>
      <varlistentry><term>symbolFile [optional]</term>
      <listitem>
      <para>
        xx
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    xx
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Additional comments.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example ...
<programlisting>
<![CDATA[

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End ApplicationMgr::useGlobalConstDir() -->

<section id="mthAddToConstDir"><title>addToConstDir</title>
<indexterm><primary>addToConstDir</primary></indexterm>
<indexterm><primary>ApplicationManager class</primary><secondary>addToConstDir</secondary></indexterm>
<programlisting>
<![CDATA[
>>--addToConstDir(--+--------+--)---------------------------------------------><
                  +--type--+
]]>
</programlisting>

<para>
  xx
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>TERM</term>
      <listitem>
      <para>
        xx
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    xx
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Additional comments.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example ...
<programlisting>
<![CDATA[

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End ApplicationManager::addToConstDir() -->

<section id="mthAutoDetectionClsApplicationManger"><title>auotDetection</title>
<indexterm><primary>auotDetection</primary></indexterm>
<indexterm><primary>ApplicationManager class</primary><secondary>auotDetection</secondary></indexterm>
<programlisting>
<![CDATA[
>>--auotDetection(--+--------+--)---------------------------------------------><
                  +--type--+
]]>
</programlisting>

<para>
  xx
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>TERM</term>
      <listitem>
      <para>
        xx
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    xx
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Additional comments.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example ...
<programlisting>
<![CDATA[

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End ApplicationManager::auotDetection() -->

<section id="mthDefaultFont"><title>defaultFont</title>
<indexterm><primary>defaultFont</primary></indexterm>
<indexterm><primary>ApplicationManager class</primary><secondary>defaultFont</secondary></indexterm>
<programlisting>
<![CDATA[
>>--defaultFont(--+--------+--)---------------------------------------------><
                  +--type--+
]]>
</programlisting>

<para>
  xx
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>TERM</term>
      <listitem>
      <para>
        xx
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    xx
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Additional comments.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example ...
<programlisting>
<![CDATA[

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End ApplicationManager::defaultFont() -->

<section id="mthSetDefaults"><title>setDefaults</title>
<indexterm><primary>setDefaults</primary></indexterm>
<indexterm><primary>ApplicationManager class</primary><secondary>setDefaults</secondary></indexterm>
<programlisting>
<![CDATA[
>>--setDefaults(--+--------+--)---------------------------------------------><
                  +--type--+
]]>
</programlisting>

<para>
  xx
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>TERM</term>
      <listitem>
      <para>
        xx
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    xx
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Additional comments.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  <para>
    Sets the <link linkend="dotSystemErrorCode">.SystemErrorCode</link> variable.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example ...
<programlisting>
<![CDATA[

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End ApplicationManager::setDefaults() -->

</section> <!-- End ApplicationManager Class -->


<section id="clsWindow"><title>Window Class</title>
<indexterm><primary>Window class</primary></indexterm>
<para>
  A <emphasis role="italic">Window</emphasis> object allows the invocation of methods common to every window.  It does
  this by inheriting the <emphasis role="italic">WindowBase</emphasis> class. Other than the <link
  linkend="mthNewClsWindow">new</link>() method, the <emphasis role="italic">Window</emphasis> class provides no other
  methods of its own.
</para>

<section id="sctMethodsWindow"><title>Method Table</title>
<para>
  The following table lists the class and instance methods of the <computeroutput>Window</computeroutput> class:
<table id="tblMethodsWindow" frame="all"> <title>Window Class Method Reference</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Window Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthNewClsWindow">new</link></entry>
<entry>Instantiates a new window object.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Attributes</emphasis></entry>
<entry align="center"><emphasis role="bold">Attributes</emphasis></entry>
</row>
<row>
<entry><link linkend="wbwFactorX">factorX</link></entry>
<entry>The horizontal size of one dialog unit in pixels. (Inaccurate.)</entry>
</row>
<row>
<entry><link linkend="wbwFactorY">factorY</link></entry>
<entry>The vertical size of one dialog unit in pixels. (Inaccurate.)</entry>
</row>
<row>
<entry><link linkend="wbwHwnd">hwnd</link></entry>
<entry>The window handle of the window.</entry>
</row>
<row>
<entry><link linkend="wbwInitCode">initCode</link></entry>
<entry>Has no meaning, always 0.</entry>
</row>
<row>
<entry><link linkend="wbwPixelCX">pixelCX</link></entry>
<entry>The width of the window in pixels.</entry>
</row>
<row>
<entry><link linkend="wbwPixelCY">pixelCY</link></entry>
<entry>The height of the window in pixels.</entry>
</row>
<row>
<entry><link linkend="wbwSizeX">sizeX</link></entry>
<entry>The width of the window in dialog units. (Inaccurate.)</entry>
</row>
<row>
<entry><link linkend="wbwSizeY">sizeY</link></entry>
<entry>The height of the window in dialog units. (Inaccurate.)</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
<entry align="center"><emphasis role="bold"></emphasis></entry>
</row>
<row>
<entry><link linkend="wbwClear">clear</link></entry>
<entry>Clears the client area of the window by painting it with the background brush.</entry>
</row>
<row>
<entry><link linkend="wbwClient2screen">client2screen</link></entry>
<entry>Converts a point or points in client-area coordinates of the window to its screen coordinates.</entry>
</row>
<row>
<entry><link linkend="wbwClientRect">clientRect</link></entry>
<entry>Returns a <computeroutput>Rect</computeroutput> object containing the dimensions of the window's client area in pixels.</entry>
</row>
<row>
<entry><link linkend="wbwClientToScreen">clientToScreen</link></entry>
<entry>Converts client-area coordinates of the window to its screen coordinates.</entry>
</row>
<row>
<entry><link linkend="wbwEnable">enable</link></entry>
<entry>Enables the window.</entry>
</row>
<row>
<entry><link linkend="wbwDisable">disable</link></entry>
<entry>Disables the window.</entry>
</row>
<row>
<entry><link linkend="wbwDisplay">display</link></entry>
<entry>Shows or hides the window.</entry>
</row>
<row>
<entry><link linkend="wbwDraw">draw</link></entry>
<entry>Redraws the entire client area of the window immediately.</entry>
</row>
<row>
<entry><link linkend="wbwForegroundWindow">foregroundWindow</link></entry>
<entry>Returns the handle of the window in the foreground.</entry>
</row>
<row>
<entry><link linkend="wbwGetClientRect">getClientRect</link></entry>
<entry>Returns the dimensions of the window's client area.</entry>
</row>
<row>
<entry><link linkend="wbwGetExStyleRaw">getExStyleRaw</link></entry>
<entry>Retrieves the numeric value of the window's extended style flags.</entry>
</row>
<row>
<entry><link linkend="wbwGetID">getID</link></entry>
<entry>Retrieves the identification number of the window.</entry>
</row>
<row>
<entry><link linkend="wbwGetPos">getPos</link></entry>
<entry>Returns the position of the window in dialog units <emphasis role="bold">(not accurate.)</emphasis></entry>
</row>
<row>
<entry><link linkend="wbwGetRealPos">getRealPos</link></entry>
<entry>Returns the position of the window in pixels as a <computeroutput>Point</computeroutput> object.</entry>
</row>
<row>
<entry><link linkend="wbwGetRealSize">getRealSize</link></entry>
<entry>Returns the size of the window in pixels as a <computeroutput>Size</computeroutput> object.</entry>
</row>
<row>
<entry><link linkend="wbwGetRect">getRect</link></entry>
<entry>Returns the dimensions of the window.</entry>
</row>
<row>
<entry><link linkend="wbwGetSize">getSize</link></entry>
<entry>Returns the size of the window in dialog units <emphasis role="bold">(not accurate.)</emphasis></entry>
</row>
<row>
<entry><link linkend="wbwGetStyleRaw">getStyleRaw</link></entry>
<entry>Retrieves the numeric value of the window's style flags.</entry>
</row>
<row>
<entry><link linkend="wbwGetText">getText</link></entry>
<entry>Gets the text of the window.</entry>
</row>
<row>
<entry><link linkend="wbwGetTextSizePx">getTextSizePx</link></entry>
<entry>Calculates the size needed for a string in pixels <emphasis role="bold">(preferred method.)</emphasis></entry>
</row>
<row>
<entry><link linkend="wbwGetTextSizeScreen">getTextSizeScreen</link></entry>
<entry>Calculates the size needed for a string in pixels.</entry>
</row>
<row>
<entry><link linkend="wbwHide">hide</link></entry>
<entry>Makes the window invisible and repaints it.</entry>
</row>
<row>
<entry><link linkend="wbwHideFast">hideFast</link></entry>
<entry>Marks the window as invisible</entry>
</row>
<row>
<entry><link linkend="wbwIsEnabled">isEnabled</link></entry>
<entry>Tests if the window is enabled.</entry>
</row>
<row>
<entry><link linkend="wbwIsVisible">isVisible</link></entry>
<entry>Tests if the window is visible.</entry>
</row>
<row>
<entry><link linkend="wbwMove">move</link></entry>
<entry>Moves the window to the position specified in dialog units <emphasis role="bold">(not accurate.)</emphasis></entry>
</row>
<row>
<entry><link linkend="wbwMoveTo">moveTo</link></entry>
<entry>Moves the window to the position specified in pixels.</entry>
</row>
<row>
<entry><link linkend="wbwRedraw">redraw</link></entry>
<entry>Redraws the entire window and all its child windows immediately.</entry>
</row>
<row>
<entry><link linkend="wbwRedrawClient">redrawClient</link></entry>
<entry>Redraws the entire client area of the window immediately.</entry>
</row>
<row>
<entry><link linkend="wbwResize">resize</link></entry>
<entry>Resizes the window to the size specified in dialog units <emphasis role="bold">(not accurate.)</emphasis></entry>
</row>
<row>
<entry><link linkend="wbwResizeTo">resizeTo</link></entry>
<entry>Resizes the window to the size specified in pixels.</entry>
</row>
<row>
<entry><link linkend="wbwScreen2client">screen2client</link></entry>
<entry>Converts a point or points in screen coordinates to the client-area coordinates of the window.</entry>
</row>
<row>
<entry><link linkend="wbwScreenToClient">screenToClient</link></entry>
<entry>Converts screen coordinates to the client-area coordinates of the window.</entry>
</row>
<row>
<entry><link linkend="wbwSendMessage">sendMessage</link></entry>
<entry>Sends a Windows message to the underlying window and returns its response as a whole number.</entry>
</row>
<row>
<entry><link linkend="wbwSendMessageHandle">sendMessageHandle</link></entry>
<entry>Sends a Windows message to the underlying window and returns its response as a handle.</entry>
</row>
<row>
<entry><link linkend="wbwSetRect">setRect</link></entry>
<entry>Moves and / or resizes the window.</entry>
</row>
<row>
<entry><link linkend="wbwSetText">setText</link></entry>
<entry>Sets the text of the window.</entry>
</row>
<row>
<entry><link linkend="wbwSetTitle">setTitle</link></entry>
<entry>Sets the text of the window.</entry>
</row>
<row>
<entry><link linkend="wbwShowfast">showFast</link></entry>
<entry>Marks the window as visible.</entry>
</row>
<row>
<entry><link linkend="wbwTitle">title</link></entry>
<entry>Gets the text of the window.</entry>
</row>
<row>
<entry><link linkend="wbwTitleEquals">title=</link></entry>
<entry>Sets the text of the window.</entry>
</row>
<row>
<entry><link linkend="wbwUpdate">update</link></entry>
<entry>Invalidates the entire client area of the window.</entry>
</row>
<row>
<entry><link linkend="wbwWindowRect">windowRect</link></entry>
<entry>Returns a <computeroutput>Rect</computeroutput> object containing the dimensions of the window in pixels.</entry>
</row>
</tbody></tgroup>
</table>
</para>
</section>

<section id="mthNewClsWindow"><title>new (Class Method)</title>
<indexterm><primary>new</primary>
<secondary>Window class</secondary></indexterm>
<programlisting>
<![CDATA[

>>--new(--hwnd--)--------------------------------><

]]>
</programlisting>

<para>
  Given a window <link linkend="defHandle">handle</link>, instantiates a new <computeroutput>Window</computeroutput>
  object.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window
    </para>
    </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    This method returns a new <computeroutput>Window</computeroutput> object.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    Given an array of dialog control resource IDs this method enables all the controls without having to know what the
    type of the individual control is:
<programlisting>
<![CDATA[
::method enableControls
  use strict arg IDs
  hDlg = self~hwnd
  do id over IDs
    hwnd = self~getControlHandle(id, hDlg)
    if hwnd = 0 then return .false
    .Window~new(hwnd)~enable
  end
  return .true

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="wbwInitCode"><title>initCode (Attribute)</title>
<programlisting>
WindowBase::<link linkend="atrInitCode">initCode</link>

<![CDATA[
>>--initCode-------------------------------------><

>>--initCode-=-code------------------------------><

]]>
</programlisting>
</section>

<section id="wbwHwnd"><title>hwnd (Attribute)</title>
<programlisting>
WindowBase::<link linkend="atrHwnd">hwnd</link>

<![CDATA[
>>--hwnd-----------------------------------------><

]]>
</programlisting>
</section>

<section id="wbwSizeX"><title>sizeX (Attribute)</title>
<programlisting>
WindowBase::<link linkend="atrSizeX">sizeX</link>

<![CDATA[
>>--sizeX----------------------------------------><

>>--sizeX-=-dialogUnits--------------------------><
]]>
</programlisting>
</section>

<section id="wbwSizeY"><title>sizeY (Attribute)</title>
<programlisting>
WindowBase::<link linkend="atrSizeY">sizeY</link>

<![CDATA[
>>--sizeY----------------------------------------><

>>--sizeY-=-dialogUnits--------------------------><
]]>
</programlisting>
</section>

<section id="wbwFactorX"><title>factorX (Attribute)</title>
<programlisting>
WindowBase::<link linkend="atrFactorX">factorX</link>

<![CDATA[
>>--factorX--------------------------------------><

>>--factorX-=-ratio------------------------------><
]]>

</programlisting>
</section>

<section id="wbwFactorY"><title>factorY (Attribute)</title>
<programlisting>
WindowBase::<link linkend="atrFactorY">factorY</link>

<![CDATA[
>>--factorY--------------------------------------><

>>--factorY-=-ratio------------------------------><
]]>

</programlisting>
</section>

<section id="wbwPixelCX"><title>pixelCX (Attribute)</title>
<programlisting>
WindowBase::<link linkend="atrPixelCX">pixelCX</link>

<![CDATA[
>>--pixelCX--------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwPixelCY"><title>pixelCY (Attribute)</title>
<programlisting>
WindowBase::<link linkend="atrPixelCY">pixelCY</link>

<![CDATA[
>>--pixelCY--------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwSendMessage"><title>sendMessage</title>
<programlisting>
WindowBase::<link linkend="mthSendMessage">sendMessage</link>

<![CDATA[
>>--sendMessage(--id--,--msg--,--wParam--,--lParam--)--------------------------><
]]>
</programlisting>
</section>

<section id="wbwSendMessageHandle"><title>sendMessageHandle</title>
<programlisting>
<link linkend="mthSendMessageHandle">sendMessageHandle</link>

<![CDATA[
>>--sendMessageHandle(--id--,--msg--,--wParam--,--lParam--)--------------------><
]]>
</programlisting>
</section>

<section id="wbwEnable"><title>enable</title>
<programlisting>
WindowBase::<link linkend="mthEnable">enable</link>

<![CDATA[
>>--enable---------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwDisable"><title>disable</title>
<programlisting>
WindowBase::<link linkend="mthDisable">disable</link>

<![CDATA[
>>--disable--------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwIsVisible"><title>isVisible</title>
<programlisting>
WindowBase::<link linkend="mthIsVisible">isVisible</link>

<![CDATA[
>>--isVisible------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwIsEnabled"><title>isEnabled</title>
<programlisting>
WindowBase::<link linkend="mthIsEnabled">isEnabled</link>

<![CDATA[
>>--isEnabled------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwHide"><title>hide</title>
<programlisting>
WindowBase::<link linkend="mthHide">hide</link>

<![CDATA[
>>--hide-----------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwShowFast"><title>showFast</title>
<programlisting>
WindowBase::<link linkend="mthShowFast">showFast</link>

<![CDATA[
>>--showFast-------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwHideFast"><title>hideFast</title>
<programlisting>
WindowBase::<link linkend="mthHideFast">hideFast</link>

<![CDATA[
>>--hideFast-------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwDisplay"><title>display</title>
<programlisting>
WindowBase::<link linkend="mthDisplay">display</link>

<![CDATA[
]]>
</programlisting>
</section>

<section id="wbwUpdate"><title>update</title>
<programlisting>
WindowBase::<link linkend="mthUpdate">update</link>

<![CDATA[
]]>
</programlisting>
</section>

<section id="wbwDraw"><title>draw</title>
<programlisting>
WindowBase::<link linkend="mthDraw">draw</link>

<![CDATA[
>>--draw-----------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwRedrawClient"><title>redrawClient</title>
<programlisting>
WindowBase::<link linkend="mthRedrawClient">redrawClient</link>

<![CDATA[
>>--redrawClient(--+------------+--)-------------><
                   +--eraseBkg--+
]]>
</programlisting>
</section>

<section id="wbwRedraw"><title>redraw</title>
<programlisting>
WindowBase::<link linkend="mthRedraw">redraw</link>

<![CDATA[
>>--redraw---------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwGetID"><title>getID</title>
<programlisting>
WindowBase::<link linkend="mthGetID">getID</link>

<![CDATA[
>>--getID----------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwGetStyleRaw"><title>getStyleRaw</title>
<programlisting>
WindowBase::<link linkend="mthGetStyleRaw">getStyleRaw</link>

<![CDATA[
>>--getStyleRaw----------------------------------><
]]>
</programlisting>
</section>

<section id="wbwGetExStyleRaw"><title>getExStyleRaw</title>
<programlisting>
WindowBase::<link linkend="mthGetExStyleRaw">getExStyleRaw</link>

<![CDATA[
>>--getExStyleRaw--------------------------------><
]]>
</programlisting>
</section>

<section id="wbwSetText"><title>setText</title>
<programlisting>
WindowBase::<link linkend="mthSetText">setText</link>

<![CDATA[
>>--setText(--newText--)-------------------------><
]]>
</programlisting>
</section>

<section id="wbwGetText"><title>getText</title>
<programlisting>
WindowBase::<link linkend="mthGetText">getText</link>

<![CDATA[
>>--getText--------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwTitleEquals"><title>title=</title>
<programlisting>
WindowBase::<link linkend="mthTitleEquals">title=</link>

<![CDATA[
>>--title-=--newText-----------------------------><
]]>
</programlisting>
</section>

<section id="wbwSetTitle"><title>setTitle</title>
<programlisting>
WindowBase::<link linkend="mthSetTitle">setTitle</link>

<![CDATA[
>>--setTitle(--newText--)------------------------><
]]>
</programlisting>
</section>

<section id="wbwTitle"><title>title</title>
<programlisting>
WindowBase::<link linkend="mthTitle">title</link>

<![CDATA[
>>--title----------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwGetTextSizePx"><title>getTextSizePx</title>
<programlisting>
WindowBase::<link linkend="mthGetTextSizePx">getTextSizePx</link>

<![CDATA[
>>--getTextSizePx(-text--)-----------------------><
]]>
</programlisting>
</section>

<section id="wbwGetTextSizeScreen"><title>getTextSizeScreen</title>
<programlisting>
WindowBase::<link linkend="mthGetTextSizeScreen">getTextSizeScreen</link>

<![CDATA[
>>--getTextSizeScreen(-text--+---------+--+------------+--+-------------+-)---><
                             +-,-type--+  +-,-fontSrc--+  +-,-fontSize--+
]]>
</programlisting>
</section>

<section id="wbwSetRect"><title>setRect</title>
<programlisting>
WindowBase::<link linkend="mthSetRect">setRect</link>

<![CDATA[
Form 1:

>>--setRect(--rectangle--+------------+--)-------><
                         +-,-showOpts-+

Form 2:

>>--setRect(--point--,--size--+------------+--)--------------------------------><
                              +-,-showOpts-+

Form 3:

>>--setRect(--x-,--y-,--cx-,--cy--+------------+--)----------------------------><
                                  +-,-showOpts-+

Generic form:

>>--setRect(--ptSizeRectangle--+------------+--)-------------------------------><
                               +-,-showOpts-+
]]>
</programlisting>
</section>

<section id="wbwResizeTo"><title>resizeTo</title>
<programlisting>
WindowBase::<link linkend="mthResizeTo">resizeTo</link>

<![CDATA[
Form 1:

>>--resizeTo(--size--)---------------------------><

Form 2:

>>--resizeTo(--cx,--cy--)------------------------><

Generic form:

>>--resizeTo(--newSize--)------------------------><
]]>
</programlisting>
</section>

<section id="wbwMoveTo"><title>moveTo</title>
<programlisting>
WindowBase::<link linkend="mthMoveTo">moveTo</link>

<![CDATA[
Form 1:

>>--moveTo(--point--+--------------+--)----------><
                    +--,-showOpts--+
Form 2:

>>--moveTo(--x,--y--+--------------+--)----------><
                    +--,-showOpts--+
Generic form:

>>--moveTo(--newPos--+--------------+--)---------><
                     +--,-showOpts--+
]]>
</programlisting>
</section>

<section id="wbwGetRealSize"><title>getRealSize</title>
<programlisting>
WindowBase::<link linkend="mthGetRealSize">getRealSize</link>

<![CDATA[
>>--getRealSize----------------------------------><
]]>
</programlisting>
</section>

<section id="wbwGetRealPos"><title>getRealPos</title>
<programlisting>
WindowBase::<link linkend="mthGetSize">getRealPos</link>

<![CDATA[
>>--getRealPos-----------------------------------><
]]>
</programlisting>
</section>

<section id="wbwWindowRect"><title>windowRect</title>
<programlisting>
WindowBase::<link linkend="mthWindowRect">windowRect</link>

<![CDATA[
>>--windowRect(--+--------+--)-------------------><
                 +--hwnd--+
]]>
</programlisting>
</section>

<section id="wbwClientRect"><title>clientRect</title>
<programlisting>
WindowBase::<link linkend="mthClientRect">clientRect</link>

<![CDATA[
>>--clientRect(--+--------+--)-------------------><
                 +--hwnd--+
]]>
</programlisting>
</section>

<section id="wbwClear"><title>clear</title>
<programlisting>
WindowBase::<link linkend="mthClear">clear</link>

<![CDATA[
>>--clear----------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwResize"><title>resize</title>
<programlisting>
WindowBase::<link linkend="mthResize">resize</link>

<![CDATA[
>>--resize(--width--,--height--+-------------+--)------------------------------><
                               +-,-showOpts--+
]]>
</programlisting>
</section>

<section id="wbwMove"><title>move</title>
<programlisting>
WindowBase::<link linkend="mthMove">move</link>

<![CDATA[
>>--move(--xPos--,--yPos--+-------------+--)-----><
                          +-,-showOpts--+
]]>
</programlisting>
</section>

<section id="wbwGetSize"><title>getSize</title>
<programlisting>
WindowBase::<link linkend="mthGetSize">getSize</link>

<![CDATA[
>>--getSize--------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwGetPos"><title>getPos</title>
<programlisting>
WindowBase::<link linkend="mthGetPos">getPos</link>

<![CDATA[
>>--getPos---------------------------------------><

]]>
</programlisting>
</section>

<section id="wbwGetRect"><title>getRect</title>
<programlisting>
WindowBase::<link linkend="mthGetRect">getRect</link>

<![CDATA[
>>--getRect--------------------------------------><
]]>
</programlisting>
</section>

<section id="wbwGetClientRect"><title>getClientRect</title>
<programlisting>
WindowBase::<link linkend="mthGetClientRect">getClientRect</link>

<![CDATA[
>>--getClientRect(--+------+--)------------------><
                    +-hwnd-+
]]>
</programlisting>
</section>


<section id="wbwForegroundWindow"><title>foregroundWindow</title>
<programlisting>
WindowBase::<link linkend="mthForegroundWindow">foregroundWindow</link>

<![CDATA[
>>--foregroundWindow-----------------------------><
]]>
</programlisting>
</section>


<section id="wbwScreen2client"><title>screen2client</title>
<programlisting>
WindowBase::<link linkend="mthScreen2client">screen2client</link>

<![CDATA[
>>--screen2client(--pointOrRect--)---------------><
]]>
</programlisting>
</section>


<section id="wbwClient2screen"><title>client2screen</title>
<programlisting>
WindowBase::<link linkend="mthClient2screen">client2screen</link>

<![CDATA[
>>--client2screen(--pointOrRect--)---------------><
]]>
</programlisting>
</section>


<section id="wbwScreenToClient"><title>screenToClient</title>
<programlisting>
WindowBase::<link linkend="mthScreenToClient">screenToClient</link>

<![CDATA[
>>--screenToClient(--x--,--y--)------------------><
]]>
</programlisting>
</section>


<section id="wbwClientToScreen"><title>clientToScreen</title>
<programlisting>
WindowBase::<link linkend="mthClientToScreen">clientToScreen</link>

<![CDATA[
>>--clientToScreen(--x--,--y--)------------------><
]]>
</programlisting>
</section>

</section> <!-- End Window Class -->


<section id="clsOs"><title>OS Class</title>
<indexterm><primary>OS class</primary></indexterm>
<para>
  The <computeroutput>OS</computeroutput> class provides methods for extracting information about the operating system a
  program is currently executing on. All the methods of the OS class are class methods.  In general these methods are
  easy to use, returning true or false about a specific piece of information. See the <link
  linkend="mthIsAtLeastVista">isAtLeastVista</link>() method for an example of usage.
</para>


<section id="sctMethodsOS"><title>Method Table</title>
<para>
  The following table lists the class methods of the <computeroutput>OS</computeroutput> class:
<table id="tblMethodsOS" frame="all"> <title>OS Class Method Reference</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthIs32on64bit">is32on64bit</link></entry>
<entry>Tests if running under ooRexx 32-bit on a 64 bit system</entry>
</row>
<row>
<entry><link linkend="mthIs64bit">is64bit</link></entry>
<entry>Tests if running under ooRexx 64-bit</entry>
</row>
<row>
<entry><link linkend="mthIsAtLeastVista">isAtLeastVista</link></entry>
<entry>Tests if operating system is Windows Vista or later</entry>
</row>
<row>
<entry><link linkend="mthIsAtLeastW2K">isAtLeastW2K</link></entry>
<entry>Tests if operating system is Windows 2000 or later</entry>
</row>
<row>
<entry><link linkend="mthIsAtLeastW2K3">isAtLeastW2K3</link></entry>
<entry>Tests if operating system is Windows 2003 or later</entry>
</row>
<row>
<entry><link linkend="mthIsAtLeastWindows7">isAtLeastWindows7</link></entry>
<entry>Tests if operating system is Windows 7 or later</entry>
</row>
<row>
<entry><link linkend="mthIsAtLeastXP">isAtLeastXP</link></entry>
<entry>Tests if operating system is Windows XP or later</entry>
</row>
<row>
<entry><link linkend="mthIsServer2008">isServer2008</link></entry>
<entry>Tests if operating system is Windows Server 2008</entry>
</row>
<row>
<entry><link linkend="mthIsServer2008R2">isServer2008R2</link></entry>
<entry>Tests if operating system is Windows Server 2008 Release 2</entry>
</row>
<row>
<entry><link linkend="mthIsVista">isVista</link></entry>
<entry>Tests if operating system is Windows Vista</entry>
</row>
<row>
<entry><link linkend="mthIsW2K">isW2K</link></entry>
<entry>Tests if operating system is Windows 2000</entry>
</row>
<row>
<entry><link linkend="mthIsW2K3">isW2K3</link></entry>
<entry>Tests if operating system is Windows 2003</entry>
</row>
<row>
<entry><link linkend="mthIsWindows7">isWindows7</link></entry>
<entry>Tests if operating system is Windows 7</entry>
</row>
<row>
<entry><link linkend="mthIsWow64">isWow64</link></entry>
<entry>Alias for the <emphasis role="italic">is32on64bit</emphasis>() method</entry>
</row>
<row>
<entry><link linkend="mthIsXP">isXP</link></entry>
<entry>Tests if operating system is Windows XP</entry>
</row>
<row>
<entry><link linkend="mthIsXP32">isXP32</link></entry>
<entry>Tests if operating system is 32-bit Windows XP</entry>
</row>
<row>
<entry><link linkend="mthIsXP64">isXP64</link></entry>
<entry>Tests if operating system is 64-bit Windows XP</entry>
</row>
</tbody></tgroup>
</table>
</para>
</section>


<section id="mthIs64bit"><title>is64bit (Class Method)</title>
<indexterm><primary>is64bit</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>is64bit</secondary></indexterm>
<programlisting>
<![CDATA[

>>--is64bit--------------------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running under the 64-bit ooRexx interpreter on a 64-bit version of
  Windows, otherwise false.
</para>
</section>  <!-- End OS::is64bit() [class method] -->

<section id="mthIs32on64bit"><title>is32on64bit (Class Method)</title>
<indexterm><primary>is32on64bit</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>is32on64bit</secondary></indexterm>
<programlisting> <![CDATA[

>>--is32on64bit----------------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running under the 32-bit ooRexx interpreter on a 64-bit version of
  Windows, otherwise false.
</para>
</section>  <!-- End OS::is32on64bit() [class method] -->

<section id="mthIsWow64"><title>isWow64 (Class Method)</title>
<indexterm><primary>isWow64</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>isWow64</secondary></indexterm>
<programlisting>
<![CDATA[

>>--isWow64--------------------------------------><

]]>
</programlisting>

<para>
  This is an alias for the <emphasis role="italic">is32on64bit</emphasis>() method.  WoW is Microsoft's term for running
  Windows on Windows.  In this case running 32-bit Windows on a 64-bit version of Windows.  The method returns true if
  the currently executing program is running under the 32-bit ooRexx interpreter on a 64-bit version of Windows,
  otherwise false.
</para>
</section>  <!-- End OS::isWow64() [class method] -->

<section id="mthIsW2K"><title>isW2K (Class Method)</title>
<indexterm><primary>isW2K</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>isW2K</secondary></indexterm>
<programlisting>
<![CDATA[

>>--isW2K----------------------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running on Windows 2000, otherwise false.
</para>
</section>  <!-- End OS::isW2K() [class method] -->

<section id="mthIsXP"><title>isXP (Class Method)</title>
<indexterm><primary>isXP</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>isXP</secondary></indexterm>
<programlisting>
<![CDATA[

>>--isXP-----------------------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running on Windows XP, otherwise false.
</para>
</section>  <!-- End OS::isXP() [class method] -->

<section id="mthIsXP32"><title>isXP32 (Class Method)</title>
<indexterm><primary>isXP32</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>isXP32</secondary></indexterm>
<programlisting>
<![CDATA[

>>--isXP-----------------------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running on 32-bit Windows XP, otherwise false.
</para>
</section>  <!-- End OS::isXP32() [class method] -->

<section id="mthIsXP64"><title>isXP64 (Class Method)</title>
<indexterm><primary>isXP64</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>isXP64</secondary></indexterm>
<programlisting>
<![CDATA[

>>--isXP64---------------------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running on 64-bit Windows XP, otherwise false.
</para>
</section>  <!-- End OS::isXP64() [class method] -->

<section id="mthIsW2K3"><title>isW2K3 (Class Method)</title>
<indexterm><primary>isW2K3</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>isW2K3</secondary></indexterm>
<programlisting>
<![CDATA[

>>--isW2K3---------------------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running on Windows 2003, otherwise false.
</para>
</section>  <!-- End OS::isW2K3() [class method] -->

<section id="mthIsVista"><title>isVista (Class Method)</title>
<indexterm><primary>isVista</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>isVista</secondary></indexterm>
<programlisting>
<![CDATA[

>>--isVista--------------------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running on Windows Vista, otherwise false.
</para>
</section>  <!-- End OS::isVista() [class method] -->

<section id="mthIsServer2008"><title>isServer2008 (Class Method)</title>
<indexterm><primary>isServer2008</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>isServer2008</secondary></indexterm>
<programlisting>
<![CDATA[

>>--isServer2008---------------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running on Windows Server 2008, otherwise false.
</para>
</section>  <!-- End OS::isServer2008() [class method] -->

<section id="mthIsWindows7"><title>isWindows7 (Class Method)</title>
<indexterm><primary>isWindows7</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>isWindows7</secondary></indexterm>
<programlisting>
<![CDATA[

>>--isWindows7-----------------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running on Windows 7, otherwise false.
</para>
</section>  <!-- End OS::isWindows7() [class method] -->

<section id="mthIsServer2008R2"><title>isServer2008R2 (Class Method)</title>
<indexterm><primary>isServer2008R2</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>isServer2008R2</secondary></indexterm>
<programlisting>
<![CDATA[

>>--isServer2008R2-------------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running on Windows Server 2008 Release 2, otherwise false.
</para>
</section>  <!-- End OS::isServer2008R2() [class method] -->

<section id="mthIsAtLeastW2K"><title>isAtLeastW2K (Class Method)</title>
<indexterm><primary>isAtLeastW2K</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>isAtLeastW2K</secondary></indexterm>
<programlisting>
<![CDATA[

>>--isAtLeastW2K---------------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running on Windows 2000, or later. Otherwise it returns false.
</para>
</section>  <!-- End OS::isAtLeastW2K() [class method] -->

<section id="mthIsAtLeastXP"><title>isAtLeastXP (Class Method)</title>
<indexterm><primary>isAtLeastXP</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>isAtLeastXP</secondary></indexterm>
<programlisting>
<![CDATA[

>>--isAtLeastXP----------------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running on Windows XP, or later. Otherwise it returns false.
</para>
</section>  <!-- End OS::isAtLeastXP() [class method] -->

<section id="mthIsAtLeastW2K3"><title>isAtLeastW2K3 (Class Method)</title>
<indexterm><primary>isAtLeastW2K3</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>isAtLeastW2K3</secondary></indexterm>
<programlisting>
<![CDATA[

>>--isAtLeastW2K3--------------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running on Windows 2003, or later. Otherwise it returns false.
</para>
</section>  <!-- End OS::isAtLeastW2K3() [class method] -->

<section id="mthIsAtLeastVista"><title>isAtLeastVista (Class Method)</title>
<indexterm><primary>isAtLeastVista</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>isAtLeastVista</secondary></indexterm>
<programlisting>
<![CDATA[

>>--isAtLeastVista-------------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running on Windows Vista, or later. Otherwise it returns false.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The <link linkend="clsMonthCalendar">MonthCalendar</link> class has a number of methods that are only available on
    Windows Vista or Windows 7. This example is from a program that demonstrates those methods. It first checks if the
    program is running on Vista, and if not it quits.
<programlisting>
<![CDATA[

/* Simple MonthCalendar example */

  -- We demonstrate some of the MonthCalendar features here that are
  -- only available on Vista.  So, be sure we are running on Vista and
  -- abort if not.
  if \ .OS~isAtLeastVista then do
    info = "This program requires Windows Vista or later."
    return messageDialog(info, , "Error", "OK", "HAND")
  end

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End OS::isAtLeastVista() [class method] -->

<section id="mthIsAtLeastWindows7"><title>isAtLeastWindows7 (Class Method)</title>
<indexterm><primary>isAtLeastWindows7</primary></indexterm>
<indexterm><primary>OS class</primary><secondary>isAtLeastWindows7</secondary></indexterm>
<programlisting>
<![CDATA[

>>--isAtLeastWindows7----------------------------><

]]>
</programlisting>

<para>
  Returns true if the currently executing program is running on Windows 7, or later. Otherwise it returns false.
</para>
</section>  <!-- End OS::isAtLeastWindows7() [class method] -->

</section> <!-- End OS Class -->


<section id="clsSPI"><title>SPI Class</title>
<indexterm><primary>SPI class</primary></indexterm>
<para>
  The <computeroutput>SPI</computeroutput> class (System Parameters Information) reflects the system-wide parameters
  of the computer the Rexx program is running on. The class consists entirely of class attributes. For each attribute,
  the value of the attribute is the value of a system parameter. Changing the value of the attribute changes the value
  of the system parameter.
</para>
<para>
  xx
</para>

<section id="sctMethodsSPI"><title>Method Table</title>
<para>
  The following table lists the class attributes of the <computeroutput>SPI</computeroutput> class:

<table id="tblMethodsSPI" frame="all"> <title>SPI Class Attribute Reference</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Attribute</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry><link linkend="atrWheelScrollLines">wheelScrollLines</link></entry>
<entry>Reflects the number of lines to scroll when the vertical mouse wheel is moved.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
</row>
</tbody></tgroup>
</table>
</para>
</section>

<section id="atrWheelScrollLines"><title>wheelScrollLines (Attribute)</title>
<indexterm><primary>wheelScrollLines</primary></indexterm>
<indexterm><primary>SPI class</primary><secondary>wheelScrollLines</secondary></indexterm>
<programlisting>
<![CDATA[
>>--wheelScrollLines-----------------------------------------------------><

>>--wheelScrollLines-=-count---------------------------------------------><

]]>
</programlisting>

<para>
  Reflects the number of lines to scroll when the vertical mouse wheel is moved. The number is a non-negative whole
  number. The system default is 3.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">wheelScrollLines get:</emphasis></term>
  <listitem>
  <para>
    Retrieves the number of lines to scroll when the vertical mouse wheel is moved.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">wheelScrollLines set:</emphasis></term>
  <listitem>
  <para>
    Sets the number of lines to scroll when the vertical mouse wheel is moved.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The wheel scroll lines is the suggested number of lines to scroll when the mouse wheel is rolled without using
    modifier keys. If the number is 0, then no scrolling should occur. If the number of lines to scroll is larger than
    the number of viewable lines, and especially if it is the <computeroutput>SPI</computeroutput> constant
    WHEEL_PAGESCROLL (<computeroutput>.SPI~WHEEL_PAGESCROLL</computeroutput>), the scroll operation should be
    interpreted as clicking once in the page down or page up regions of the scroll bar.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example retrieves the current setting for the wheel scroll lines and then scrolls the text in an edit control
    the appropriate amount:
<programlisting>
<![CDATA[


]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End SPI::wheelScrollLines() [attribute]  -->


</section> <!-- End SPI Class -->

<section id="clsRect"><title>Rect Class</title>
<indexterm><primary>Rect class</primary></indexterm>
<para>
  The <computeroutput>Rect</computeroutput> object is most often used to represent a rectangle on a coordinate system,
  specifically the coordinate system used by Windows where the upper left corner is considered (0,0).  However, it is
  convenient to use the Rect object for other things, for instance the margin around a rectangle.
</para>

<section id="sctMethodsRect"><title>Method Table</title>
<para>
  The following table lists the class and instance methods of the <computeroutput>Rect</computeroutput> class:
<table id="tblMethodsRect" frame="all"> <title>Rect Class Method Reference</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthNewClsRect">new</link></entry>
<entry>Instantiates a new <computeroutput>Rect</computeroutput> object.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Attributes</emphasis></entry>
<entry align="center"><emphasis role="bold">Attributes</emphasis></entry>
</row>
<row>
<entry><link linkend="atrBottomClsRect">bottom</link></entry>
<entry>xx</entry>
</row>
<row>
<entry><link linkend="atrLeftClsRect">left</link></entry>
<entry>xx</entry>
</row>
<row>
<entry><link linkend="atrRightClsRect">right</link></entry>
<entry>xx</entry>
</row>
<row>
<entry><link linkend="atrTopClsRect">top</link></entry>
<entry>xx</entry>
</row>
</tbody></tgroup>
</table>
</para>
</section>

<section id="mthNewClsRect"><title>new (Class Method)</title>
<indexterm><primary>new</primary><secondary>Rect class</secondary></indexterm>
<programlisting>
<![CDATA[

>>--new(--+------+--+--------+--+---------+--+----------+--)-------------------><
          +-left-+  +-,-top--+  +-,-right-+  +-,-bottom-+

]]>
</programlisting>

<para>
  Instantiates a new <computeroutput>Rect</computeroutput> object.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem><para>The arguments are:
  <variablelist>
    <varlistentry><term>left [optional]</term>
    <listitem>
    <para>
      The left coordinate of the rectangle. The default is 0.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>top [optional]</term>
    <listitem>
    <para>
      The top coordinate of the rectangle. The default is the value of <emphasis role="italic">left</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>right [optional]</term>
    <listitem>
    <para>
      The right coordinate of the rectangle. The default is the value of <emphasis role="italic">left</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>bottom [optional]</term>
    <listitem>
    <para>
      The bottom coordinate of the rectangle. The default is the value of <emphasis role="italic">left</emphasis>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The new <computeroutput>Rect</computeroutput> object is returned.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    All the coordinates of the rectangle are whole numbers in the range of -2147483648 to 2147483647, inclusive. Note
    that the <emphasis role="italic">left</emphasis> argument is checked first, if it is omitted, its value is set to 0.
    All other arguments, if omitted, are set to the value of <emphasis role="italic">left</emphasis>.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry id="exampleNewClsRect"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
<programlisting>
<![CDATA[
r = .Rect~new(3, 4, 13, 9)
say 'Upper corner ('r~left','r~top') lower corner 'r~right','r~bottom')'
say
margin = .Rect~new(5)
say 'Margins:'
say '  Left: ' margin~left
say '  Top   ' margin~top
say '  Right ' margin~right
say '  Bottom' margin~bottom
say

r~left = 55
r~top = 75
r~right = 110
r~bottom = 125
say 'New upper corner ('r~left','r~top') new lower corner 'r~right','r~bottom')'
say

/* Output would be:
Upper corner (3,4) lower corner 13,9)

Margins:
  Left:  5
  Top    5
  Right  5
  Bottom 5

New upper corner (55,75) new lower corner 110,125)

/*

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="atrLeftClsRect"><title>left (Attribute)</title>
<indexterm><primary>left</primary><secondary>Rect class</secondary></indexterm>
<indexterm><primary>Rect class</primary><secondary>left</secondary></indexterm>
<programlisting>
<![CDATA[
>>--left-----------------------------------------><

>>--left-=-number--------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">left</emphasis> attribute reflects the x coordinate of the upper left corner of the
  rectangle.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">left get:</emphasis></term>
  <listitem>
  <para>
    Returns the value of <emphasis role="italic">left</emphasis> coordinate of the rectangle.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">left set:</emphasis></term>
  <listitem>
  <para>
    Sets the value of the <emphasis role="italic">left</emphasis> coordinate of the rectangle. The value must be a
    whole number in the range of -2147483648 to 2147483647, inclusive.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    See <link linkend="exampleNewClsRect">.Rect~new</link> example.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End Rect::left() [attribute]  -->

<section id="atrTopClsRect"><title>top (Attribute)</title>
<indexterm><primary>top</primary><secondary>Rect class</secondary></indexterm>
<indexterm><primary>Rect class</primary><secondary>top</secondary></indexterm>
<programlisting>
<![CDATA[
>>--top------------------------------------------><

>>--top-=-number---------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">top</emphasis> attribute reflects the y coordinate of the upper left corner of the
  rectangle.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">top get:</emphasis></term>
  <listitem>
  <para>
    Returns the value of <emphasis role="italic">top</emphasis> coordinate of the rectangle.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">top set:</emphasis></term>
  <listitem>
  <para>
    Sets the value of the <emphasis role="italic">top</emphasis> coordinate of the rectangle. The value must be a
    whole number in the range of -2147483648 to 2147483647, inclusive.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    See <link linkend="exampleNewClsRect">.Rect~new</link> example.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End Rect::top() [attribute]  -->

<section id="atrRightClsRect"><title>right (Attribute)</title>
<indexterm><primary>right</primary><secondary>Rect class</secondary></indexterm>
<indexterm><primary>Rect class</primary><secondary>right</secondary></indexterm>
<programlisting>
<![CDATA[
>>--right----------------------------------------><

>>--right-=-number-------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">right</emphasis> attribute reflects the x coordinate of the bottom right corner of the
  rectangle.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">right get:</emphasis></term>
  <listitem>
  <para>
    Returns the value of <emphasis role="italic">right</emphasis> coordinate of the rectangle.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">right set:</emphasis></term>
  <listitem>
  <para>
    Sets the value of the <emphasis role="italic">right</emphasis> coordinate of the rectangle. The value must be a
    whole number in the range of -2147483648 to 2147483647, inclusive.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    See <link linkend="exampleNewClsRect">.Rect~new</link> example.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End Rect::right() [attribute]  -->

<section id="atrBottomClsRect"><title>bottom (Attribute)</title>
<indexterm><primary>bottom</primary><secondary>Rect class</secondary></indexterm>
<indexterm><primary>Rect class</primary><secondary>bottom</secondary></indexterm>
<programlisting>
<![CDATA[
>>--bottom---------------------------------------><

>>--bottom-=-number------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">bottom</emphasis> attribute reflects the y coordinate of the bottom right corner of the
  rectangle.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">bottom get:</emphasis></term>
  <listitem>
  <para>
    Returns the value of the <emphasis role="italic">bottom</emphasis> coordinate of the rectangle.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">bottom set:</emphasis></term>
  <listitem>
  <para>
    Sets the value of the <emphasis role="italic">bottom</emphasis> coordinate of the rectangle. The value must be a
    whole number in the range of -2147483648 to 2147483647, inclusive.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    See <link linkend="exampleNewClsRect">.Rect~new</link> example.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End Rect::bottom() [attribute]  -->

</section> <!-- End Rect Class -->


<section id="clsPoint"><title>Point Class</title>
<indexterm><primary>Point class</primary></indexterm>
<para>
  The <computeroutput>Point</computeroutput> class represents a point in a 2-D coordinate system.
</para>


<section id="sctMethodsPoint"><title>Method Table</title>
<para>
  The following table lists the class and instance methods of the <computeroutput>Point</computeroutput> class:

<table id="tblMethodsPoint" frame="all"> <title>Point Class Method Reference</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthNewClsPoint">new</link></entry>
<entry>Instantiates a new <computeroutput>Point</computeroutput> object.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Attributes</emphasis></entry>
<entry align="center"><emphasis role="bold">Attributes</emphasis></entry>
</row>
<row>
<entry><link linkend="atrXClsPoint">x</link></entry>
<entry>Reflects the X coordinate of the point.</entry>
</row>
<row>
<entry><link linkend="atrYClsPoint">y</link></entry>
<entry>Reflects the Y coordinate of the point.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthPlus">+</link></entry>
<entry>Adds two <computeroutput>Point</computeroutput>objects</entry>
</row>
<row>
<entry><link linkend="mthMinus">-</link></entry>
<entry>Subtracts two <computeroutput>Point</computeroutput>objects</entry>
</row>
<row>
<entry><link linkend="mthDecr">decr</link></entry>
<entry>Decrements the x and y attributes by the amount specified</entry>
</row>
<row>
<entry><link linkend="mthIncr">incr</link></entry>
<entry>Increments the x and y attributes by the amount specified</entry>
</row>
</tbody></tgroup>
</table>
</para>
</section>

<section id="mthNewClsPoint"><title>new (Class Method)</title>
<indexterm><primary>new</primary><secondary>Point class</secondary></indexterm>
<programlisting>
<![CDATA[

>>--new(--+---+--,--+---+--)---------------------><
          +-x-+     +-y-+
]]>
</programlisting>

<para>
  Instantiates a new <computeroutput>Point</computeroutput> object.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>x [optional]</term>
      <listitem>
      <para>
        The x coordinate of the point. The default is 0.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>y</term>
      <listitem>
      <para>
        The y coordinate of the point. The default is the value of the x coordinate.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    This method returns a new <computeroutput>Point</computeroutput> object.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Both the x and y coordinates of a point are whole numbers in the range of -2147483648 to 2147483647, inclusive.
    Note that the <emphasis role="italic">x</emphasis> argument is checked first, if it is omitted, its value is set
    to 0. The <emphasis role="italic">y</emphasis>, if omitted, is then set to the value of <emphasis
    role="italic">x</emphasis>.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example simply creates a few <computeroutput>Point</computeroutput> objects:
<programlisting id="exampleNewClsPoint">
<![CDATA[
p = .Point~new(45, 90)
say 'Point p is at ('p~x','p~y')'
say
q = .Point~new(55)
say 'A new point q is at ('q~x','q~y')'
say

q~x = 150
q~y = 300
say 'Changed point q to be at ('q~x','q~y')'
say

::requires 'ooDialog.cls'

/* Output would be:

Point p is at (45,90)

A new point q is at (55,55)

Changed point q to be at (150,300)

*/
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="atrXClsPoint"><title>x (Attribute)</title>
<indexterm><primary>x</primary><secondary>Point class</secondary></indexterm>
<indexterm><primary>Point class</primary><secondary>x</secondary></indexterm>
<programlisting>
<![CDATA[
>>--x--------------------------------------------><

>>--x-=-number-----------------------------------><

]]>
</programlisting>

<para>
  Reflects the x coordinate of the <computeroutput>Point</computeroutput>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">x get:</emphasis></term>
  <listitem>
  <para>
    Returns the value of <emphasis role="italic">x</emphasis> coordinate of the point
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">x set:</emphasis></term>
  <listitem>
  <para>
    Sets the value of the <emphasis role="italic">x</emphasis> coordinate of the point. The value must be a
    whole number in the range of -2147483648 to 2147483647, inclusive.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    See <link linkend="exampleNewClsPoint">.Point~new</link> example.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End Point::x() [attribute]  -->

<section id="atrYClsPoint"><title>y (Attribute)</title>
<indexterm><primary>y</primary><secondary>Point class</secondary></indexterm>
<indexterm><primary>Point class</primary><secondary>y</secondary></indexterm>
<programlisting>
<![CDATA[
>>--y--------------------------------------------><

>>--y-=-number-----------------------------------><

]]>
</programlisting>

<para>
  Reflects the y coordinate of the <computeroutput>Point</computeroutput>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">y get:</emphasis></term>
  <listitem>
  <para>
    Returns the value of <emphasis role="italic">y</emphasis> coordinate of the point
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">y set:</emphasis></term>
  <listitem>
  <para>
    Sets the value of the <emphasis role="italic">y</emphasis> coordinate of the point. The value must be a whole number
    in the range of -2147483648 to 2147483647, inclusive.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    See <link linkend="exampleNewClsPoint">.Point~new</link> example.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End Point::y() [attribute]  -->

<section id="mthPlus"><title>+</title>
<indexterm><primary>+</primary></indexterm>
<indexterm><primary>Point class</primary><secondary>+</secondary></indexterm>
<programlisting>
<![CDATA[
>>--"+"--point2----------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">+</emphasis> method adds the X and Y attributes of this point to another
  <computeroutput>Point</computeroutput>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
  <variablelist>
    <varlistentry><term>point2 [required]</term>
    <listitem>
    <para>
      The <computeroutput>Point</computeroutput> object being added.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return value is a <computeroutput>Point</computeroutput> object whose X and Y attributes are the sum of the X
    and Y attributes of this point and the other point.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example shows a generic method used to move a number of controls the same relative distance in a dialog:
<programlisting>
<![CDATA[

::method moveControls private
  use strict arg controlArray, x = 0, y = 0

  offSet = .Point~new(x, y)
  do obj over controlArray
    pos = obj~getRealPos
    newPos = pos + offSet
    obj~moveTo(newPos, "NOREDRAW")
  end

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End Point::+() -->

<section id="mthMinus"><title>-</title>
<indexterm><primary>-</primary></indexterm>
<indexterm><primary>Point class</primary><secondary>-</secondary></indexterm>
<programlisting>
<![CDATA[
>>--"-"--point2----------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic"></emphasis> method subtracts the X and Y attributes of this point from another
  <computeroutput>Point</computeroutput>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
  <variablelist>
    <varlistentry><term>point2 [required]</term>
    <listitem>
    <para>
      The <computeroutput>Point</computeroutput> object being subtracted.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return value is a <computeroutput>Point</computeroutput> object whose X and Y attributes are the result of
    subtracting the other point's X and Y attributes from the X and Y attributes of this point.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    A simple example:
<programlisting>
<![CDATA[


  p1 = .Point~new(250, 200)
  p2 = .Point~new(25, 20)
  p3 = p1 - p2
  say "Point 3, x:" p3~x "y:" p3~y

  /* Output would be:

     Point 3, x: 225 y: 180

  */
::requires "ooDialog.cls"
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End Point::-() -->

<section id="mthIncr"><title>incr</title>
<indexterm><primary>incr</primary></indexterm>
<indexterm><primary>Point class</primary><secondary>incr</secondary></indexterm>
<programlisting>
<![CDATA[
>>--incr(--+--------+--+---------+--)------------><
           +--incrX-+  +-,-incrY-+
]]>
</programlisting>

<para>
  Increments this point's x and y attributes by the specified amount.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>incrX [optional]</term>
    <listitem>
    <para>
      The amount to increment, (to add to,) this point's x attribute. The amount must be a whole number in the range of
      -2147483648 to 2147483647, inclusive.
    </para>
    <para>
      If <emphasis role="italic">incrY</emphasis> is specified and this arg is omitted then the x attribute is not
      changed. If both <emphasis role="italic">incrX</emphasis> and <emphasis role="italic">incrY</emphasis> are
      ommitted, then the x and y attributes are incremented by 1.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>incrY [optional]</term>
    <listitem>
    <para>
      The amount to increment, (to add to,) this point's y attribute. The amount must be a whole number in the range of
      -2147483648 to 2147483647, inclusive.
    </para>
    <para>
      If <emphasis role="italic">incrX</emphasis> is specified and this arg is omitted then the y attribute is not
      changed. If both <emphasis role="italic">incrX</emphasis> and <emphasis role="italic">incrY</emphasis> are
      ommitted, then the x and y attributes are incremented by 1.
    </para>
    </listitem></varlistentry>
  </variablelist> </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    There is no return.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example changes the pointer to the hourglass shape then moves the cursor one pixel down and one pixel to the
    right. Moving the cursor it to be redrawn
<programlisting>
<![CDATA[

  oldCursorPosition = self~getCursorPos
  oldCursorShape = self~cursor_wait
  self~setCursorPos(oldCursorPosition~incr)

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End Point::incr() -->

<section id="mthDecr"><title>Decr</title>
<indexterm><primary>decr</primary></indexterm>
<indexterm><primary>Point class</primary><secondary>decr</secondary></indexterm>
<programlisting>
<![CDATA[
>>--decr(--+--------+--+---------+--)------------><
           +--decrX-+  +-,-decrY-+
]]>
</programlisting>

<para>
  Decrements this point's x and y attributes by the specified amount.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>decrX [optional]</term>
    <listitem>
    <para>
      The amount to decrement, (to subtract from,) this point's x attribute. The amount must be a whole number in the
      range of -2147483648 to 2147483647, inclusive.
    </para>
    <para>
      If <emphasis role="italic">decrY</emphasis> is specified and this arg is omitted then the x attribute is not
      changed. If both <emphasis role="italic">decrX</emphasis> and <emphasis role="italic">decrY</emphasis> are
      ommitted, then the x and y attributes are decremented by 1.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>decrY [optional]</term>
    <listitem>
    <para>
      The amount to decrement, (to subtract from,) this point's y attribute. The amount must be a whole number in the
      range of -2147483648 to 2147483647, inclusive.
    </para>
    <para>
      If <emphasis role="italic">decrX</emphasis> is specified and this arg is omitted then the y attribute is not
      changed. If both <emphasis role="italic">decrX</emphasis> and <emphasis role="italic">decrY</emphasis> are
      ommitted, then the x and y attributes are decremented by 1.
    </para>
    </listitem></varlistentry>
  </variablelist> </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    There is no return.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example changes the pointer to the hourglass shape then moves the cursor one pixel up and one pixel to the
    left. Moving the cursor forces the cursor to be redrawn
<programlisting>
<![CDATA[

  oldCursorPosition = self~getCursorPos
  oldCursorShape = self~cursor_wait
  self~setCursorPos(oldCursorPosition~decr)

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End Point::decr() -->

</section> <!-- End Point Class -->


<section id="clsSize"><title>Size Class</title>
<indexterm><primary>Size class</primary></indexterm>
<para>
  A <computeroutput>Size</computeroutput> object encapsulates a width and height dimension in a 2-D coordinate system.
</para>


<section id="sctMethodsSize"><title>Method Table</title>
<para>
  The following table lists the class and instance methods of the <computeroutput>Size</computeroutput> class:

<table id="tblMethodsSize" frame="all"> <title>Size Class Method Reference</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthNewClsSize">new</link></entry>
<entry>Instantiates a new <computeroutput>Size</computeroutput> object.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Attributes</emphasis></entry>
<entry align="center"><emphasis role="bold">Attributes </emphasis></entry>
</row>
<row>
<entry><link linkend="atrHeightClsPoint">height</link></entry>
<entry>Reflects the height of the <computeroutput>Size</computeroutput> object.</entry>
</row>
<row>
<entry><link linkend="atrWidthClsPoint">width</link></entry>
<entry>Reflects the width of the <computeroutput>Size</computeroutput> object.</entry>
</row>
</tbody></tgroup>
</table>
</para>
</section>

<section id="mthNewClsSize"><title>new (Class Method)</title>
<indexterm><primary>new</primary><secondary>Size class</secondary></indexterm>
<programlisting>
<![CDATA[

>>-.Size~new(--+-------+--,--+---------+--)------><
               +-width-+     +-height--+
]]>
</programlisting>
<para>
  Instantiates a new <computeroutput>Size</computeroutput> object with the dimensions specified.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>width</term>
      <listitem>
      <para>
        The width for the new object.  The default is 0.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>height</term>
      <listitem>
      <para>
        The height for the new object.  The default is the <emphasis role="italic">width</emphasis> value.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    This method returns the new <computeroutput>Size</computeroutput> object.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Both the <emphasis role="italic">width</emphasis> and the <emphasis role="italic">height</emphasis>  of a
    <computeroutput>Size</computeroutput> object are whole numbers in the range of -2147483648 to 2147483647, inclusive.
    Note that the <emphasis role="italic">width</emphasis> argument is checked first, if it is omitted, its value is set
    to 0. The <emphasis role="italic">height</emphasis>, if omitted, is then set to the value of <emphasis
    role="italic">width</emphasis>.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry id="exampleNewClsSize"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
<programlisting>
<![CDATA[

size = .Size~new(4, 8)
say 'Width:' size~width 'Height:' size~height
say
size2 = .Size~new(16)
say 'A new size object:'
say '  Width: ' size2~width
say '  Height:' size2~height
say

size2~width = 100
size2~height = 300
say 'New width:' size2~width 'new height:' size2~height
say

::requires 'ooDialog.cls'

/* Output would be:

Width: 4 Height: 8

A new size object:
  Width:  16
  Height: 16

New width: 100 new height: 300

*/
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="atrWidthClsPoint"><title>width (Attribute)</title>
<indexterm><primary>width</primary><secondary>Size class</secondary></indexterm>
<indexterm><primary>Size class</primary><secondary>width</secondary></indexterm>
<programlisting>
<![CDATA[
>>--width----------------------------------------><

>>--width-=-number-------------------------------><

]]>
</programlisting>

<para>
  Reflects the width of the <computeroutput>Size</computeroutput> object.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">width get:</emphasis></term>
  <listitem>
  <para>
    Returns the value of <emphasis role="italic">width</emphasis> of the <computeroutput>Size</computeroutput> object.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">width set:</emphasis></term>
  <listitem>
  <para>
    Sets the value of the <emphasis role="italic">width</emphasis> of the <computeroutput>Size</computeroutput> object.
    The value must be a whole number in the range of -2147483648 to 2147483647, inclusive.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    See <link linkend="exampleNewClsSize">.Size~new</link> example.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End Size::width() [attribute]  -->

<section id="atrHeightClsPoint"><title>height (Attribute)</title>
<indexterm><primary>height</primary><secondary>Size class</secondary></indexterm>
<indexterm><primary>Size class</primary><secondary>height</secondary></indexterm>
<programlisting>
<![CDATA[
>>--height---------------------------------------><

>>--height-=-number------------------------------><

]]>
</programlisting>

<para>
  Reflects the height of the <computeroutput>Size</computeroutput> object.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">height get:</emphasis></term>
  <listitem>
  <para>
    Returns the value of <emphasis role="italic">height</emphasis> of the <computeroutput>Size</computeroutput> object.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">height set:</emphasis></term>
  <listitem>
  <para>
    Sets the value of the <emphasis role="italic">height</emphasis> of the <computeroutput>Size</computeroutput> object.
    The value must be a whole number in the range of -2147483648 to 2147483647, inclusive.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Additional comments.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    See <link linkend="exampleNewClsSize">.Size~new</link> example.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End Size::height() [attribute]  -->

</section> <!-- End Size Class -->


<section id="clsDayState"><title>DayState Class</title>
<indexterm><primary>DayState class</primary></indexterm>
<para>
  A <computeroutput>DayState</computeroutput> object represents the state of each day in a month. It is a specialty
  class used by the <link linkend="clsMonthCalendar">MonthCalendar</link> class when the month calendar needs to reply
  to the <link linkend="evtMonthCalendarGETDAYSTATE">GETDAYSTATE</link> event.
</para>
<para>
  Each <computeroutput>DayState</computeroutput> object contains a single value. The value encodes the state of each day
  in a format understood by the <link linkend="ovvUnderlying">underlying</link> Windows month calendar control. The
  state of a single day is a binary value. I.e., on or off, true or false, special or not special, however it is
  convenient for the programmer to think of. When the state of a day is on, the month calendar displays that day in
  bold.
</para>

<section id="sctMethodsDayState"><title>Method Table</title>
<para>
  The following table lists the class and instance methods of the <computeroutput>DayState</computeroutput> class:

<table id="tblMethodsDayState" frame="all"> <title>DayState Class Method Reference</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthNewClsDayState">new</link></entry>
<entry>Instantiates a new <computeroutput>DayState</computeroutput> object and sets the state of each day.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthValue">value</link></entry>
<entry>Returns the <emphasis role="italic">value</emphasis> of the <computeroutput>DayState</computeroutput> object.</entry>
</row>
</tbody></tgroup>
</table>
</para>
</section>

<section id="mthNewClsDayState"><title>new (Class Method)</title>
<indexterm><primary>new</primary><secondary>DayState class</secondary></indexterm>
<indexterm><primary>DayState class</primary><secondary>new</secondary></indexterm>
<programlisting>
<![CDATA[

          +--,-----+
          V        |
>>--new(---dayNum--+--)--------------------------><

]]>
</programlisting>

<para>
  Instantiates a new <computeroutput>DayState</computeroutput> object and sets the state of each day.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>dayNum [optional]</term>
    <listitem>
    <para>
      A single <emphasis role="italic">dayNum</emphasis> argument is the number of a day within a month whose state
      should be turned <emphasis role="italic">on</emphasis>. If there are no arguments, none of the days in the month
      are turned on. The arguments can repeat any number of times, but each argument must be a whole number within the
      range of 1 to 32, inclusive.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    A new <computeroutput>DayState</computeroutput> object.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example constructs a day state for an application that displays the author's birth date in a <link
    linkend="clsMonthCalendar">month</link> calendar control in bold. All other days of the year are displayed without
    emphasis.
<programlisting>
<![CDATA[

::method getProperDayState private
  use strict arg date

  if date~orderedDate~substr(3, 2) == 07, date~orderedDate~right(2) == 14 then
    return .DayState~new(14)
  else
    return .DayState~new

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DayState::new() -->

<section id="mthValue"><title>value</title>
<indexterm><primary>value</primary></indexterm>
<indexterm><primary>DayState class</primary><secondary>value</secondary></indexterm>
<programlisting>
<![CDATA[
>>--value----------------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">value</emphasis> method returns the encoded value of the
  <computeroutput>DayState</computeroutput> object.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    There are no arguments.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return is a number that encodes the state of every day within a month.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    There is probably no practical use of this method for the programmer, other than perhaps curiosity. The method is
    used by the interpreter to get the encoded numerical value of a <computeroutput>DayState</computeroutput> object and
    send that number to the underlying month calendar control.
  </para>
  <para>
    For those curious, the encoding is essentially a bit field. Each bit, 1 through 31 represents the state of the
    corresponding day in a month. If the bit is on, the month calendar displays that day in bold. If the bit is not on,
    the day is displayed normally.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example is for the curious and displays the bit encoding of a day state value:
<programlisting>
<![CDATA[

  dayState = .DayState~new(1, 4, 17)
  say 'dayState value:' dayState~value 'binary form:' dayState~value~d2x~x2b

  /* Output would be:

     dayState value: 65545 binary form: 00010000000000001001

  */
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DayState::value() -->

</section> <!-- End DayState Class -->


<section id="clsDayStates"><title>DayStates Class</title>
<indexterm><primary>DayStates class</primary></indexterm>
<para>
  A <computeroutput>DayStates</computeroutput> object is a sequential collection of <link linkend="clsDayState">day
  state</link> objects. It is a speciality class used to construct the proper reply value for the <link
  linkend="evtMonthCalendarGETDAYSTATE">GETDAYSTATE</link> event of the <link linkend="clsMonthCalendar">month</link>
  calendar control.
</para>
<para>
  The primary purpose of the <computeroutput>DayStates</computeroutput> class is to supply the buffer of day states that
  is used to reply to the get day state event. But, the class also has methods that allow the programmer to build a
  cache of day state objects. Then during the get day state event, the programmer can request a buffer of some number of
  the cached day states.
</para>

<section id="sctMethodsDayStates"><title>Method Table</title>
<para>
  The following table lists the class and instance methods of the <computeroutput>DayStates</computeroutput> class:

<table id="tblMethodsDayStates" frame="all"> <title>DayStates Class Method Reference</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthNewClsDayStates">new</link></entry>
<entry>Instantiates a new <computeroutput>DayStates</computeroutput> object with a cache of <computeroutput>DayState</computeroutput> objects.</entry>
</row>
<row>
<entry><link linkend="mthMakeDayStateBuffer">makeDayStateBuffer</link></entry>
<entry>Returns a buffer of the specified <computeroutput>DayState</computeroutput> objects</entry>
</row>
<row>
<entry><link linkend="mthQuickDayStateBuffer">quickDayStateBuffer</link></entry>
<entry>Returns a buffer constructed from the 3 <computeroutput>DayState</computeroutput> objects specified.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Attributes</emphasis></entry>
<entry align="center"><emphasis role="bold">Attributes</emphasis></entry>
</row>
<row>
<entry><link linkend="atrEndMonth">endMonth</link></entry>
<entry>Reflects the last month in the cache of <computeroutput>DayState</computeroutput> objects.</entry>
</row>
<row>
<entry><link linkend="atrStartMonth">startMonth</link></entry>
<entry>Reflects the first month in the cache of <computeroutput>DayState</computeroutput> objects.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthPutMonth">putMonth</link></entry>
<entry>Puts a single <computeroutput>DayState</computeroutput> object in the cache.</entry>
</row>
<row>
<entry><link linkend="mthPutYear">putYear</link></entry>
<entry>Puts an entire year of <computeroutput>DayState</computeroutput> objects in the cache.</entry>
</row>
<row>
<entry><link linkend="mthGetDayState">getDayState</link></entry>
<entry>Returns the specified <computeroutput>DayState</computeroutput> object from the cache.</entry>
</row>
<row>
<entry><link linkend="mthGetDayStateBuffer">getDayStateBuffer</link></entry>
<entry>Returns a day state buffer constructed from the specified months in the cache</entry>
</row>
</tbody></tgroup>
</table>
</para>
</section>

<section id="mthNewClsDayStates"><title>new (Class Method)</title>
<indexterm><primary>new</primary><secondary>DayStates class</secondary></indexterm>
<indexterm><primary>DayStates class</primary><secondary>new</secondary></indexterm>
<programlisting>
<![CDATA[
>>--new(--+-------------+--+---------+--)--------><
          +--startYear--+  +-,-count-+
]]>
</programlisting>

<para>
  Instantiates a new <computeroutput>DayStates</computeroutput> object and initalizes the cache of <link
  linkend="clsDayState">DayState</link> objects. Each day state in the is initialized with the state of every day turned
  off.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>startYear [optional]</term>
      <listitem>
      <para>
        Specifies the starting year for the cache. The default if this argument is omitted is two years prior to the
        current year. The <emphasis role="italic">startYear</emphasis> is specified as the whole number year value,
        e.g., 2011, 1988, 1492, etc..
      </para>
      </listitem></varlistentry>
      <varlistentry><term>count [optional]</term>
      <listitem>
      <para>
        The number of years to initialize the cache with. The default is 3 years.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return is a new <computeroutput>DayStates</computeroutput> object.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The cache of day state values in a day states object is always a whole number of years in size, and is always
    sequential. I.e., 12 day state values for each year. As indicated, initially the state of every day is turned off.
    The <link linkend="mthPutMonth">putMonth</link> and <link linkend="mthPutYear">putYear</link> methods are used set
    the day state values in the cache to values with the state of days turned on.
  </para>
  <para>
    The <link linkend="mthMakeDayStateBuffer">makeDayStateBuffer</link> and <link
    linkend="mthQuickDayStateBuffer">quickDayStateBuffer</link> class methods can be used to obtain a day states buffer
    without initializing or using a cache.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example instantiates a new <computeroutput>DayStates</computeroutput> object and initializes the cache to 10
    years, with the start year one year prior to the current date. It then sets the state of July 4th of every year to
    on:

<programlisting>
<![CDATA[

  yr = (.DateTime~today~year - 1)

  dayStates = .DayStates~new(yr, 10)

  dayState = .DayState~new(4)
  do 10
    dayStates~putMonth(yr, 7, dayState)
    yr += 1
  end

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DayStates::new() -->

<section id="mthMakeDayStateBuffer"><title>makeDayStateBuffer (Class method)</title>
<indexterm><primary>makeDayStateBuffer</primary></indexterm>
<indexterm><primary>DayStates class</primary><secondary>makeDayStateBuffer</secondary></indexterm>
<programlisting>
<![CDATA[
>>--makeDayStateBuffer(--dayStates--)------------><

]]>
</programlisting>

<para>
  Returns a buffer of the specified day states. This buffer can be used for the return from the event handler for a
  <link linkend="evtMonthCalendarGETDAYSTATE">GETDAYSTATE</link> event.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
  <variablelist>
    <varlistentry><term>dayStates [required]</term>
    <listitem>
    <para>
      An array of <link linkend="clsDayState">DayState</link> objects.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return is a day states buffer. The buffer is only useful as the reply to the GETDAYSTATE event of the month
    calendar control.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The <emphasis role="italic">dayStates</emphasis> array can not be sparse. The day state objects are assumed to be
    sequential by the underlying month calendar control.
  </para> </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example shows part of the implementation for a GETDAYSTATE event handler. Start with the month of the start
    date requested, and then, for the number of months requested, a day state object is created and put into an array.
    The <emphasis role="italic">makeDayStateBuffer</emphasis> method is invoked to get the proper buffer, which is
    returned from the event handler.
<programlisting>
<![CDATA[

::method onGetDayState unguarded
  use arg startDate, count, id, hwnd

  -- Create the array to hold the .DayState objects.
  dayStates = .array~new(count)

  -- The calendar is restricted to a single year.  We
  -- know for our application, the month calendar always
  -- requests 3 months, the partial month prior to the
  -- current month showing, the current month, and the
  -- partial month following the current month.
  --
  -- So, if the starting month is December, it can only
  -- be the December prior to January of the current
  -- year.  It can not be the December of this year because
  -- the calendar will not display January of next year.
  -- Setting the month to 0 will produce a day state with
  -- no days turned on, exactly what we want.

  month = startDate~month
  if month == 12 then month = 0

  do i = 1 to count
    dayStates[i] = self~getDayState(month + i - 1)
  end

  buffer = .DayStates~makeDayStateBuffer(dayStates)
  return buffer


::method getDayState private
  use strict arg month

  select
    when month ==  1 then ds = .DayState~new(17)
    when month ==  2 then ds = .DayState~new(21)
    when month ==  3 then ds = .DayState~new
    ...
    otherwise ds = .DayState~new
  end
  -- End select

  return ds

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DayStates::makeDayStateBuffer() -->

<section id="mthQuickDayStateBuffer"><title>quickDayStateBuffer (Class method)</title>
<indexterm><primary>quickDayStateBuffer</primary></indexterm>
<indexterm><primary>DayStates class</primary><secondary>quickDayStateBuffer</secondary></indexterm>
<programlisting>
<![CDATA[
>>--quickDayStateBuffer(--dayState1--,--dayState2--,--dayState3--)-------------><

]]>
</programlisting>

<para>
  Returns a buffer for the 3 specified day states. This buffer can be used for the return from the event handler for a
  <link linkend="evtMonthCalendarGETDAYSTATE">GETDAYSTATE</link> event.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are the 3 <computeroutput>DayState</computeroutput> objects used to construct the buffer.
  <variablelist>
    <varlistentry><term>dayState1 [required]</term>
    <listitem>
    <para>
      The first day state in the sequence of day states.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dayState2 [required]</term>
    <listitem>
    <para>
      The second day state in the sequence of day states.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dayState3 [required]</term>
    <listitem>
    <para>
      The third day state in the sequence of day states.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return is a day states buffer. The buffer is only useful as the reply to the GETDAYSTATE event of the month
    calendar control.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Normally the month calendar control is sized to only display 1 month. With this display, a week prior to the month
    and a week after the month are also shown. For this situation, when the underlying month calendar requests
    information on how to display individual days through the <link
    linkend="evtMonthCalendarGETDAYSTATE">GETDAYSTATE</link> notification, it will always request 3 months. The
    <emphasis role="italic">quickDayStateBuffer</emphasis> is a convenience method for this situation, which is the most
    common request.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect arguments are detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example shows the event handler for the GETDAYSTATE notification in an application that shows the 1st and the
    15th of each month in bold. The application always sizes the month calendar with 1 full month displayed. Because of
    this, we know the count will be 3.
<programlisting>
<![CDATA[

::method onGetDayState unguarded
  use arg startDate, count, id, hwnd

  -- All months are the same, so we can ignore the start date.
  ds = .DayState~new(1, 15)
  return .DayStates~quickDayStateBuffer(ds, ds, ds)

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DayStates::quickDayStateBuffer() -->

<section id="atrEndMonth"><title>endMonth (Attribute)</title>
<indexterm><primary>endMonth</primary></indexterm>
<indexterm><primary>DayStates class</primary><secondary>endMonth</secondary></indexterm>
<programlisting>
<![CDATA[
>>--endMonth-------------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">endMonth</emphasis> attribute reflects the last month in the cache of <link
  linkend="clsDayState">DayState</link> objects. Its value is a <computeroutput>DateTime</computeroutput> object whose
  date is the first of the last month and last year in the cache.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">endMonth get:</emphasis></term>
  <listitem>
  <para>
    Returns a <computeroutput>DateTime</computeroutput> object whose date is the last month in the cache.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">endMonth set:</emphasis></term>
  <listitem>
  <para>
    The <emphasis role="italic">endMonth</emphasis> attribute can not be set by the programmer. It is set internally by
    the class.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Since the cache always contains whole years, the date of the <emphasis role="italic">endMonth</emphasis> attribute
    is always going to be 12/01. The real information will be the year of the <emphasis
    role="italic">endMonth</emphasis> date. I.e., if the <link linkend="atrStartMonth">startMonth</link> attribute is
    1/1/1990 and the <emphasis role="italic">endMonth</emphasis> attribute is 12/01/2010 then the cache contains 21
    complete years of <computeroutput>DayState</computeroutput> objects.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DayStates::endMonth() [attribute]  -->

<section id="atrStartMonth"><title>startMonth (Attribute)</title>
<indexterm><primary>startMonth</primary></indexterm>
<indexterm><primary>DayStates class</primary><secondary>startMonth</secondary></indexterm>
<programlisting>
<![CDATA[
>>--startMonth-----------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">startMonth</emphasis> attribute reflects the first month in the cache of <link
  linkend="clsDayState">DayState</link> objects. Its value is a <computeroutput>DateTime</computeroutput> object whose
  date is the first of January of the first year in the cache.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">startMonth get:</emphasis></term>
  <listitem>
  <para>
    Returns a <computeroutput>DateTime</computeroutput> object whose date is the first month in the cache.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">startMonth set:</emphasis></term>
  <listitem>
  <para>
    The programmer can not set the <emphasis role="italic">startMonth</emphasis> attribute. It is set internally by the
    class.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Since the cache always contains whole years, the date of the <emphasis role="italic">startMonth</emphasis> attribute
    is always going to be 1/1. The real information will be the year of the <emphasis
    role="italic">startMonth</emphasis> date. I.e., if the <emphasis role="italic">startMonth</emphasis> attribute is
    1/1/2010 and the <link linkend="atrEndMonth">endMonth</link> attribute is 12/01/2011 then the cache contains 2
    complete years of <computeroutput>DayState</computeroutput> objects.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DayStates::startMonth() [attribute]  -->

<section id="mthPutMonth"><title>putMonth</title>
<indexterm><primary>putMonth</primary></indexterm>
<indexterm><primary>DayStates class</primary><secondary>putMonth</secondary></indexterm>
<programlisting>
<![CDATA[
>>--putMonth(--dateTime--,--dayState--)----------><

]]>
</programlisting>

<para>
  Puts a single <link linkend="clsDayState">DayState</link> object into the cache.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>dateTime [required]</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object whose date specifies the month in the cache to put the
      <emphasis role="italic">dayState</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dayState [required]</term>
    <listitem>
    <para>
      The <computeroutput>DayState</computeroutput> object to put in the cache.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    There is no return value from this method.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    If a day state object already exists for the month specified, it is replaced by <emphasis
    role="italic">dayState</emphasis>.
  </para>
  <para>
    If the month specified by the <emphasis role="italic">dateTime</emphasis> argument does not yet exist in the cache,
    then the cache is extended to include the year specified by <emphasis role="italic">dateTime</emphasis>. The month
    specified is assigned the <emphasis role="italic">dayState</emphasis> argument and all other months in the extension
    are assigned a <computeroutput>DayState</computeroutput> object with a value of 0, (all days are turned off.)
  </para> </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example shows how <emphasis role="italic">putMonth</emphasis> works. A
    <computeroutput>DateTime</computeroutput> object with the date of 7/1/2012 is used for the month and a
    <computeroutput>DayState</computeroutput> object is created with the 4th turned on. That will display July 4th 2012
    bolded.
  </para>
  <para>
    The output shows that before <emphasis role="italic">putMonth</emphasis> is invoked, the end month of the
    day states object was December 2011. After <emphasis role="italic">putMonth</emphasis> is invoked, the end month is
    December 2012. Adding July 2012 to the cache extended the entire year of 2012. All months other than July will have
    all days in the month turned off.
<programlisting>
<![CDATA[

  dayStates = .DayStates~new(2010, 2)
  say "Day states end month:" dayStates~endMonth~standardDate

  month = .DateTime~fromStandardDate(20120701)
  dayState = .DayState~new(4)

  dayStates~putMonth(month, dayState)

  say "Day states end month:" dayStates~endMonth~standardDate

::requires "ooDialog.cls"

/* Output would be:

  Day states end month: 20111201
  Day states end month: 20121201

*/

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DayStates::addMonth() -->

<section id="mthPutYear"><title>putYear</title>
<indexterm><primary>putYear</primary></indexterm>
<indexterm><primary>DayStates class</primary><secondary>putYear</secondary></indexterm>
<programlisting>
<![CDATA[
>>--putYear(--dateTime--,--dayStates--)----------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">putYear</emphasis> method add a year of <link linkend="clsDayState">DayState</link>
  objects to the cache.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>dateTime [required]</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that specifies the year being added. Only the year portion of
      the date is relevant. The day and month of the date are ignored.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dayStates [required]</term>
    <listitem>
    <para>
      An <computeroutput>array</computeroutput> of <computeroutput>DayState</computeroutput> objects that are the day
      states for the months of the year being added. Only the indexes 1 through 12 are looked at. If the index contains
      a day state object, that day state object is assigned to the corresponding month. If an index does not have a
      value, then a day state object with a value of 0, (no days are turned on,) is assigned to the corresponding month.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    There is no return from this method.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    If the year specified already exists in the cache then that year is replaced by the day state objects specified int
    the <emphasis role="italic">dayStates</emphasis> array.
  </para>
  <para>
    If the year does not exist yet in the cache it is added. If adding the new year creates a gap in the sequential
    order of years in the cache, then the gap is filled in using years with the state of all days turned off. In other
    words, if the cache currently consists of the years 2008 through 2012 and the <emphasis
    role="italic">putYear</emphasis> method is used to put the year 2016 in the cache, then the cache is also filled
    with the years 2013 through 2015. Each year 2013 through 2015 have day state objects with the state of all days
    turned off.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example creates a <computeroutput>DayStates</computeroutput> object with 3 years cached. In the application
    that uses this, all months have the 7th, 14th, 21st, and 28th days displayed in bold. After instantiating the new
    <computeroutput>DayStates</computeroutput> object, each year in the cache is updated with a
    <computeroutput>DayState</computeroutput> object that turns the state of the 7th, 14th, 21st, and 28th on.

<programlisting>
<![CDATA[

  dayStates = .DayStates~new(2010, 3)
  dayState = .DayState~new(7, 14, 21, 28)

  do i = 2010 to 2012
    year = .DateTime~fromStandardDate(i || 0101)

    a = .array~new(12)
    do j = 1 to 12
      a[j] = dayState
    end

    dayStates~putYear(year, a)
  end

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DayStates::addYear() -->

<section id="mthGetDayStatebuffer"><title>getDayStateBuffer</title>
<indexterm><primary>getDayStateBuffer</primary></indexterm>
<indexterm><primary>DayStates class</primary><secondary>getDayStateBuffer</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getDayStateBuffer(--dateTime--,--count--)----><

]]>
</programlisting>

<para>
  Creates a buffer from the cached <link linkend="clsDayState">DayState</link> objects using the specified date and
  <emphasis role="italic">count</emphasis>. This buffer can be used for the return from the event handler for a <link
  linkend="evtMonthCalendarGETDAYSTATE">GETDAYSTATE</link> event.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>dateTime [required]</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object whose date is used as the starting point in the cache to fetch
      the <computeroutput>DayState</computeroutput> objects.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>count [required]</term>
    <listitem>
    <para>
      The number of <computeroutput>DayState</computeroutput> objects to use in the returned buffer.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return is a day states buffer. The buffer is only useful as the reply to the GETDAYSTATE event of the month
    calendar control.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    If some, or all, of the day state objects requested for the buffer are not in the cache, then a new
    <computeroutput>DayState</computeroutput> object is create with the start of all days turned off and used. The cache
    is not updated, it remains the same after the method returns.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example sets up a cache of <computeroutput>DayState</computeroutput> objects before the application dialog is
    displayed.  It then gets buffers from this cache during the <link
    linkend="evtMonthCalendarGETDAYSTATE">GETDAYSTATE</link> event to return from the event handler.
<programlisting>
<![CDATA[

::class 'PaidHolidaysDlg' subclass ResDialog

::method init
  expose dayStates

  forward class (super) continue

  dayStates = self~createDayStateCache
  self~connectMonthCalendarEvent(IDC_MC_HOLIDAYS, "GETDAYSTATE", onGetDayState)
  ...

::method onGetDayState unguarded
  expose dayStates
  use arg startDate, count, id, hwnd

  return dayStates~getDayStateBuffer(startDate, count)

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DayStates::getDayStateBuffer() -->

<section id="mthGetDayState"><title>getDayState</title>
<indexterm><primary>getDayState</primary></indexterm>
<indexterm><primary>DayStates class</primary><secondary>getDayState</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getDayState(--dateTime--)--------------------><

]]>
</programlisting>

<para>
  Retrieves the cached <link linkend="clsDayState">DayState</link> object for the date specified.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
  <variablelist>
    <varlistentry><term>dateTime</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that specifies which <computeroutput>DayState</computeroutput>
      object to retrieve. Only the month and the year of <emphasis role="italic">dateTime</emphasis> are relevant, the
      day is ignored.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The value returned is the <computeroutput>DayState</computeroutput> object in the cache for the date specified, or
    <computeroutput>.nil</computeroutput> if there is no day state in the cache for the date.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Normally there is no need to get specific day state objects from the cache, the programmer usually wants a <emphasis
    role="italic">buffer</emphasis> of day state objects. However this method can be of use in debugging by checking
    what values are actually in the cache.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example expands on the example for the <link linkend="mthPutYear">putYear</link> method by checking the values
    of the <link linkend="atrStartMonth">startMonth</link> and <link linkend="atrEndMonth">endMonth</link> day state
    objects.
<programlisting>
<![CDATA[

  dayStates = .DayStates~new(2010, 3)
  dayState = .DayState~new(7, 14, 21, 28)

  do i = 2010 to 2012
    year = .DateTime~fromStandardDate(i || 0101)

    a = .array~new(12)
    do j = 1 to 12
      a[j] = dayState
    end

    dayStates~putYear(year, a)
  end

  s = dayStates~startMonth
  e = dayStates~endMonth

  say 'Start month day state value:' dayStates~getDayState(s)~value~d2x~x2b
  say 'End month day state value:  ' dayStates~getDayState(e)~value~d2x~x2b

::requires 'ooDialog.cls'

/* Output to the console would be:

Start month day state value: 1000000100000010000001000000
End month day state value:   1000000100000010000001000000

 */
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DayStates::getDayState() -->

</section> <!-- End DayStates Class -->


<section id="clsVK"><title>VK Class</title>
<indexterm><primary>VK class</primary></indexterm>
<indexterm><primary>virtual key codes</primary></indexterm>
<para>
  The <computeroutput>VK</computeroutput> class allows the programmer to use symbolic names in a program instead of the
  numeric value of the virtual key codes.
</para>
<para>
  The Windows operating system assigns a value to each key on the keyboard called a scan code. Scan codes are device
  <emphasis role="italic">dependent</emphasis>. To notify an application that the user has pressed a key, the operating system translates the scan
  code into a <emphasis role="italic">virtual key code</emphasis>. Virtual key codes are device <emphasis
  role="italic">independent</emphasis>. This allows the programmer to write a program without worrying about what
  keyboard the user may have.
</para>
<para>
  Virtual key codes are in the range of 0 through 255. However a number of the possible codes are unassigned, perhaps 30
  or 40. The <computeroutput>VK</computeroutput> class provides constants for every assigned key code. The constants
  serve as symbolic names for the key codes. In addition, the <link linkend="mthKey2Name">key2name</link> method is
  provided that translates a numeric number into its human-readable string name.
</para>
<para>
  There are two ways to use the <computeroutput>VK</computeroutput> class. The class is a <emphasis
  role="italic">mixinclass</emphasis>. It can be inherited by a class to provide that class with all the constants and
  methods of the <computeroutput>VK</computeroutput> class. Recall that the <emphasis
  role="italic">::constant</emphasis> directive defines both a class and an instance method that returns a constant
  value. Therefore, the constant values can be accessed directly through the class methods of the
  <computeroutput>VK</computeroutput> class.  There is also a <emphasis role="italic">key2name</emphasis> class method
  along with the instance method. The following two examples should clarify that:
</para>

<programlisting>
<![CDATA[

::class 'SimpleDlg' subclass RcDialog inherit VK

::method onKeyDown
  use arg controlID, key

  say "The key pressed was the" self~name2key(key) "virtual key"

  if key == self~DELETE then do
    return self~deleteAllItems
  end

]]>
</programlisting>
<para>
  The above example inherits the <computeroutput>VK</computeroutput> class and thus the DELETE constant and the
  <emphasis role="italic">key2name</emphasis> method become part of the  <computeroutput>SimpleDlg</computeroutput>
  class. The same thing can be accomplished using the class methods of the <computeroutput>VK</computeroutput> class:
</para>

<programlisting>
<![CDATA[

::class 'SimpleDlg' subclass RcDialog

::method onKeyDown
  use arg controlID, key

  say "The key pressed was the" .VK~name2key(key) "virtual key"

  if key == .VK~DELETE then do
    return self~deleteAllItems
  end

]]>
</programlisting>
<para>
  Using the class methods of the <computeroutput>VK</computeroutput> class has the advantage of not conflicting with any
  existing method the <computeroutput>SimpleDlg</computeroutput> may have.
</para>

<section id="sctMethodsVK"><title>Method Table</title>
<para>
  The <computeroutput>VK</computeroutput> class primarily consists of constants. The implemented constants and methods
  are listed in the following table.

<table id="tblVKMethods" frame="all">
<title>Methods of the DlgUtil class</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthKey2Name">key2name</link></entry>
<entry>Returns the symbolic name for a numeric key code as a string</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthKey2Name">key2name</link></entry>
<entry>Returns the symbolic name for a numeric key code as a string</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Constants</emphasis></entry>
<entry align="center"><emphasis role="bold">Constants</emphasis></entry>
</row>
<row>
<entry>LBUTTON</entry>
<entry>The Left mouse button</entry>
</row>
<row>
<entry>RBUTTON</entry>
<entry>The Right mouse button</entry>
</row>
<row>
<entry>CANCEL</entry>
<entry>The Control-break processing</entry>
</row>
<row>
<entry>MBUTTON</entry>
<entry>The Middle mouse button (three-button mouse)</entry>
</row>
<row>
<entry>XBUTTON</entry>
<entry>The X1 mouse button</entry>
</row>
<row>
<entry>XBUTTON</entry>
<entry>The X2 mouse button</entry>
</row>
<row>
<entry>BACK</entry>
<entry>The BACKSPACE key</entry>
</row>
<row>
<entry>TAB</entry>
<entry>The TAB key</entry>
</row>
<row>
<entry>CLEAR</entry>
<entry>The CLEAR key</entry>
</row>
<row>
<entry>RETURN</entry>
<entry>The ENTER key</entry>
</row>
<row>
<entry>SHIFT</entry>
<entry>The SHIFT key</entry>
</row>
<row>
<entry>CONTROL</entry>
<entry>The CTRL key</entry>
</row>
<row>
<entry>MENU</entry>
<entry>The ALT key</entry>
</row>
<row>
<entry>PAUSE</entry>
<entry>The PAUSE key</entry>
</row>
<row>
<entry>CAPITAL</entry>
<entry>The CAPS LOCK key</entry>
</row>
<row>
<entry>KANA</entry>
<entry>The IME Kana mode</entry>
</row>
<row>
<entry>HANGUL</entry>
<entry>The IME Hangul mode</entry>
</row>
<row>
<entry>JUNJA</entry>
<entry>The IME Junja mode</entry>
</row>
<row>
<entry>FINAL</entry>
<entry>The IME final mode</entry>
</row>
<row>
<entry>HANJA</entry>
<entry>The IME Hanja mode</entry>
</row>
<row>
<entry>KANJI</entry>
<entry>The IME Kanji mode</entry>
</row>
<row>
<entry>ESCAPE</entry>
<entry>The ESC key</entry>
</row>
<row>
<entry>CONVERT</entry>
<entry>The IME convert</entry>
</row>
<row>
<entry>NONCONVERT</entry>
<entry>The IME nonconvert</entry>
</row>
<row>
<entry>ACCEPT</entry>
<entry>The IME accept</entry>
</row>
<row>
<entry>MODECHANGE</entry>
<entry>The IME mode change request</entry>
</row>
<row>
<entry>SPACE</entry>
<entry>The SPACEBAR</entry>
</row>
<row>
<entry>PRIOR</entry>
<entry>The PAGE UP key</entry>
</row>
<row>
<entry>NEXT</entry>
<entry>The PAGE DOWN key</entry>
</row>
<row>
<entry>END</entry>
<entry>The END key</entry>
</row>
<row>
<entry>HOME</entry>
<entry>The HOME key</entry>
</row>
<row>
<entry>LEFT</entry>
<entry>The LEFT ARROW key</entry>
</row>
<row>
<entry>UP</entry>
<entry>The UP ARROW key</entry>
</row>
<row>
<entry>RIGHT</entry>
<entry>The RIGHT ARROW key</entry>
</row>
<row>
<entry>DOWN</entry>
<entry>The DOWN ARROW key</entry>
</row>
<row>
<entry>SELECT</entry>
<entry>The SELECT key</entry>
</row>
<row>
<entry>PRINT</entry>
<entry>The PRINT key</entry>
</row>
<row>
<entry>EXECUTE</entry>
<entry>The EXECUTE key</entry>
</row>
<row>
<entry>SNAPSHOT</entry>
<entry>The PRINT SCREEN key</entry>
</row>
<row>
<entry>INSERT</entry>
<entry>The INS key</entry>
</row>
<row>
<entry>DELETE</entry>
<entry>The DEL key</entry>
</row>
<row>
<entry>HELP</entry>
<entry>The HELP key</entry>
</row>
<row>
<entry><emphasis role="bold">0</emphasis></entry>
<entry>The <emphasis role="bold">0</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">1</emphasis></entry>
<entry>The <emphasis role="bold">1</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">2</emphasis></entry>
<entry>The <emphasis role="bold">2</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">3</emphasis></entry>
<entry>The <emphasis role="bold">3</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">4</emphasis></entry>
<entry>The <emphasis role="bold">4</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">5</emphasis></entry>
<entry>The <emphasis role="bold">5</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">6</emphasis></entry>
<entry>The <emphasis role="bold">6</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">7</emphasis></entry>
<entry>The <emphasis role="bold">7</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">8</emphasis></entry>
<entry>The <emphasis role="bold">8</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">9</emphasis></entry>
<entry>The <emphasis role="bold">9</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">A</emphasis></entry>
<entry>The <emphasis role="bold">A</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">B</emphasis></entry>
<entry>The <emphasis role="bold">B</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">C</emphasis></entry>
<entry>The <emphasis role="bold">C</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">D</emphasis></entry>
<entry>The <emphasis role="bold">D</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">E</emphasis></entry>
<entry>The <emphasis role="bold">E</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">F</emphasis></entry>
<entry>The <emphasis role="bold">F</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">G</emphasis></entry>
<entry>The <emphasis role="bold">G</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">H</emphasis></entry>
<entry>The <emphasis role="bold">H</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">I</emphasis></entry>
<entry>The <emphasis role="bold">I</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">J</emphasis></entry>
<entry>The <emphasis role="bold">J</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">K</emphasis></entry>
<entry>The <emphasis role="bold">K</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">L</emphasis></entry>
<entry>The <emphasis role="bold">L</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">M</emphasis></entry>
<entry>The <emphasis role="bold">M</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">N</emphasis></entry>
<entry>The <emphasis role="bold">N</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">O</emphasis></entry>
<entry>The <emphasis role="bold">O</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">P</emphasis></entry>
<entry>The <emphasis role="bold">P</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">Q</emphasis></entry>
<entry>The <emphasis role="bold">Q</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">R</emphasis></entry>
<entry>The <emphasis role="bold">R</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">S</emphasis></entry>
<entry>The <emphasis role="bold">S</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">T</emphasis></entry>
<entry>The <emphasis role="bold">T</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">U</emphasis></entry>
<entry>The <emphasis role="bold">U</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">V</emphasis></entry>
<entry>The <emphasis role="bold">V</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">W</emphasis></entry>
<entry>The <emphasis role="bold">W</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">X</emphasis></entry>
<entry>The <emphasis role="bold">X</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">Y</emphasis></entry>
<entry>The <emphasis role="bold">Y</emphasis> key</entry>
</row>
<row>
<entry><emphasis role="bold">Z</emphasis></entry>
<entry>The <emphasis role="bold">Z</emphasis> key</entry>
</row>
<row>
<entry>LWIN</entry>
<entry>The Left Windows key (Natural keyboard)</entry>
</row>
<row>
<entry>RWIN</entry>
<entry>The Right Windows key (Natural keyboard)</entry>
</row>
<row>
<entry>APPS</entry>
<entry>The Applications key (Natural keyboard)</entry>
</row>
<row>
<entry>SLEEP</entry>
<entry>The Computer Sleep key</entry>
</row>
<row>
<entry>NUMPAD0</entry>
<entry>The Numeric keypad 0 key</entry>
</row>
<row>
<entry>NUMPAD1</entry>
<entry>The Numeric keypad 1 key</entry>
</row>
<row>
<entry>NUMPAD2</entry>
<entry>The Numeric keypad 2 key</entry>
</row>
<row>
<entry>NUMPAD3</entry>
<entry>The Numeric keypad 3 key</entry>
</row>
<row>
<entry>NUMPAD4</entry>
<entry>The Numeric keypad 4 key</entry>
</row>
<row>
<entry>NUMPAD5</entry>
<entry>Numeric keypad 5 key</entry>
</row>
<row>
<entry>NUMPAD6</entry>
<entry>The Numeric keypad 6 key</entry>
</row>
<row>
<entry>NUMPAD7</entry>
<entry>The Numeric keypad 7 key</entry>
</row>
<row>
<entry>NUMPAD8</entry>
<entry>The Numeric keypad 8 key</entry>
</row>
<row>
<entry>NUMPAD9</entry>
<entry>The Numeric keypad 9 key</entry>
</row>
<row>
<entry>MULTIPLY</entry>
<entry>The Multiply key</entry>
</row>
<row>
<entry>ADD</entry>
<entry>The Add key</entry>
</row>
<row>
<entry>SEPARATOR</entry>
<entry>The Separator key</entry>
</row>
<row>
<entry>SUBTRACT</entry>
<entry>The Subtract key</entry>
</row>
<row>
<entry>DECIMAL</entry>
<entry>The Decimal key</entry>
</row>
<row>
<entry>DIVIDE</entry>
<entry>The Divide key</entry>
</row>
<row>
<entry>F1</entry>
<entry>The F1 key</entry>
</row>
<row>
<entry>F2</entry>
<entry>The F2 key</entry>
</row>
<row>
<entry>F3</entry>
<entry>The F3 key</entry>
</row>
<row>
<entry>F4</entry>
<entry>The F4 key</entry>
</row>
<row>
<entry>F5</entry>
<entry>The F5 key</entry>
</row>
<row>
<entry>F6</entry>
<entry>The F6 key</entry>
</row>
<row>
<entry>F7</entry>
<entry>The F7 key</entry>
</row>
<row>
<entry>F8</entry>
<entry>The F8 key</entry>
</row>
<row>
<entry>F9</entry>
<entry>The F9 key</entry>
</row>
<row>
<entry>F10</entry>
<entry>The F10 key</entry>
</row>
<row>
<entry>F11</entry>
<entry>The F11 key</entry>
</row>
<row>
<entry>F12</entry>
<entry>The F12 key</entry>
</row>
<row>
<entry>F13</entry>
<entry>The F13 key</entry>
</row>
<row>
<entry>F14</entry>
<entry>The F14 key</entry>
</row>
<row>
<entry>F15</entry>
<entry>The F15 key</entry>
</row>
<row>
<entry>F16</entry>
<entry>The F16 key</entry>
</row>
<row>
<entry>F17</entry>
<entry>The F17 key</entry>
</row>
<row>
<entry>F18</entry>
<entry>The F18 key</entry>
</row>
<row>
<entry>F19</entry>
<entry>The F19 key</entry>
</row>
<row>
<entry>F20</entry>
<entry>The F20 key</entry>
</row>
<row>
<entry>F21</entry>
<entry>The F21 key</entry>
</row>
<row>
<entry>F22</entry>
<entry>The F22 key</entry>
</row>
<row>
<entry>F23</entry>
<entry>The F23 key</entry>
</row>
<row>
<entry>F24</entry>
<entry>The F24 key</entry>
</row>
<row>
<entry>NUMLOCK</entry>
<entry>The NUM LOCK key</entry>
</row>
<row>
<entry>SCROLL</entry>
<entry>The SCROLL LOCK key</entry>
</row>
<row>
<entry>LSHIFT</entry>
<entry>The Left SHIFT key</entry>
</row>
<row>
<entry>RSHIFT</entry>
<entry>The Right SHIFT key</entry>
</row>
<row>
<entry>LCONTROL</entry>
<entry>The Left CONTROL key</entry>
</row>
<row>
<entry>RCONTROL</entry>
<entry>The Right CONTROL key</entry>
</row>
<row>
<entry>LMENU</entry>
<entry>The Left MENU key</entry>
</row>
<row>
<entry>RMENU</entry>
<entry>The Right MENU key</entry>
</row>
<row>
<entry>BROWSER_BACK</entry>
<entry>The Browser Back key</entry>
</row>
<row>
<entry>BROWSER_FORWARD</entry>
<entry>The Browser Forward key</entry>
</row>
<row>
<entry>BROWSER_REFRESH</entry>
<entry>The Browser Refresh key</entry>
</row>
<row>
<entry>BROWSER_STOP</entry>
<entry>The Browser Stop key</entry>
</row>
<row>
<entry>BROWSER_SEARCH</entry>
<entry>The Browser Search key</entry>
</row>
<row>
<entry>BROWSER_FAVORITES</entry>
<entry>The Browser Favorites key</entry>
</row>
<row>
<entry>BROWSER_HOME</entry>
<entry>The Browser Start and Home key</entry>
</row>
<row>
<entry>VOLUME_MUTE</entry>
<entry>The Volume Mute key</entry>
</row>
<row>
<entry>VOLUME_DOWN</entry>
<entry>The Volume Down key</entry>
</row>
<row>
<entry>VOLUME_UP</entry>
<entry>The Volume Up key</entry>
</row>
<row>
<entry>MEDIA_NEXT_TRACK</entry>
<entry>The Next Track key</entry>
</row>
<row>
<entry>MEDIA_PREV_TRACK</entry>
<entry>The Previous Track key</entry>
</row>
<row>
<entry>MEDIA_STOP</entry>
<entry>The Stop Media key</entry>
</row>
<row>
<entry>MEDIA_PLAY_PAUSE</entry>
<entry>The Play/Pause Media key</entry>
</row>
<row>
<entry>LAUNCH_MAIL</entry>
<entry>The Start Mail key</entry>
</row>
<row>
<entry>LAUNCH_MEDIA_SELECT</entry>
<entry>The Select Media key</entry>
</row>
<row>
<entry>LAUNCH_APP1</entry>
<entry>The Start Application 1 key</entry>
</row>
<row>
<entry>LAUNCH_APP2</entry>
<entry>The Start Application 2 key</entry>
</row>
<row>
<entry>OEM_1</entry>
<entry>Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the ';:' key</entry>
</row>
<row>
<entry>OEM_PLUS</entry>
<entry>For any country/region, the '+' key</entry>
</row>
<row>
<entry>OEM_COMMA</entry>
<entry>For any country/region, the ',' key</entry>
</row>
<row>
<entry>OEM_MINUS</entry>
<entry>For any country/region, the '-' key</entry>
</row>
<row>
<entry>OEM_PERIOD</entry>
<entry>For any country/region, the '.' key</entry>
</row>
<row>
<entry>OEM_2</entry>
<entry>Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '/?' key</entry>
</row>
<row>
<entry>OEM_3</entry>
<entry>Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '`~' key</entry>
</row>
<row>
<entry>OEM_4</entry>
<entry>Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '[{' key</entry>
</row>
<row>
<entry>OEM_5</entry>
<entry>Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '\|' key</entry>
</row>
<row>
<entry>OEM_6</entry>
<entry>Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the ']}' key</entry>
</row>
<row>
<entry>OEM_7</entry>
<entry>Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the 'single-quote/double-quote' key</entry>
</row>
<row>
<entry>OEM_8</entry>
<entry>Used for miscellaneous characters; it can vary by keyboard.</entry>
</row>
<row>
<entry>OEM_AX</entry>
<entry>The <emphasis role="italic">AX</emphasis> key on Japanese AX kbd</entry>
</row>
<row>
<entry>OEM_102</entry>
<entry>Either the angle bracket key or the backslash key on the RT 102-key keyboard</entry>
</row>
<row>
<entry>ICO_HELP</entry>
<entry>The Help key on ICO</entry>
</row>
<row>
<entry>ICO_00</entry>
<entry>The 00 key on ICO</entry>
</row>
<row>
<entry>PROCESSKEY</entry>
<entry>The IME PROCESS key</entry>
</row>
<row>
<entry>ICO_CLEAR</entry>
<entry>No explanation</entry>
</row>
<row>
<entry>PACKET</entry>
<entry>
  Used to pass Unicode characters as if they were keystrokes. The PACKET key is the low word of a 32-bit Virtual Key value used
  for non-keyboard input methods.
</entry>
</row>
<row>
<entry>OEM_RESET</entry>
<entry>Nokia/Ericsson definition</entry>
</row>
<row>
<entry>OEM_JUMP</entry>
<entry>Nokia/Ericsson definition</entry>
</row>
<row>
<entry>OEM_PA1</entry>
<entry>Nokia/Ericsson definition</entry>
</row>
<row>
<entry>OEM_PA2</entry>
<entry>Nokia/Ericsson definition</entry>
</row>
<row>
<entry>OEM_PA3</entry>
<entry>Nokia/Ericsson definition</entry>
</row>
<row>
<entry>OEM_WSCTRL</entry>
<entry>Nokia/Ericsson definition</entry>
</row>
<row>
<entry>OEM_CUSEL</entry>
<entry>Nokia/Ericsson definition</entry>
</row>
<row>
<entry>OEM_ATTN</entry>
<entry>Nokia/Ericsson definition</entry>
</row>
<row>
<entry>OEM_FINISH</entry>
<entry>Nokia/Ericsson definition</entry>
</row>
<row>
<entry>OEM_COPY</entry>
<entry>Nokia/Ericsson definition</entry>
</row>
<row>
<entry>OEM_AUTO</entry>
<entry>Nokia/Ericsson definition</entry>
</row>
<row>
<entry>OEM_ENLW</entry>
<entry>Nokia/Ericsson definition</entry>
</row>
<row>
<entry>OEM_BACKTAB</entry>
<entry>Nokia/Ericsson definition</entry>
</row>
<row>
<entry>ATTN</entry>
<entry>The Attn key</entry>
</row>
<row>
<entry>CRSEL</entry>
<entry>The CrSel key</entry>
</row>
<row>
<entry>EXSEL</entry>
<entry>The ExSel key</entry>
</row>
<row>
<entry>EREOF</entry>
<entry>The Erase EOF key</entry>
</row>
<row>
<entry>PLAY</entry>
<entry>The Play key</entry>
</row>
<row>
<entry>ZOOM</entry>
<entry>The Zoom key</entry>
</row>
<row>
<entry>PA1</entry>
<entry>The PA1 key</entry>
</row>
<row>
<entry>OEM_CLEAR</entry>
<entry>The Clear key</entry>
</row>
</tbody></tgroup>
</table>
</para>
</section>


<section id="mthKey2Name"><title>key2name</title>
<indexterm><primary>key2name</primary></indexterm>
<indexterm><primary>VK class</primary><secondary>key2name</secondary></indexterm>
<programlisting>
<![CDATA[
>>--key2name(--numericCode--)--------------------><

]]>
</programlisting>

<para>
  Converts a numeric virtual key code into the string version of its constant name.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The only argument is:
  <variablelist>
    <varlistentry><term>numericCode [required]</term>
    <listitem>
    <para>
      The numeric value of a virtual key code. Virtual key codes are whole numbers in the range 0 through 255.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns the constant method name for the specified virtual key code as a string.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    There is both a class method and an instance method with this method's name. Therefore the method can be use like
    this:
<programlisting>
<![CDATA[
  ::class 'MyClass' subclass ResDialog inherit VK
    ...
    say "The key pressed was:" self~key2Name(key)

]]>
</programlisting>

    or like this:

<programlisting>
<![CDATA[
  ::class 'MyClass' subclass RcDialog
    ...
    say "The key pressed was:" .VK~key2name(key)

]]>
</programlisting>

  </para>
  <para>
    Not all possible key codes are assigned. The empty string is returned for those numbers.
  </para>
  <para>
    This method is a convenience method which allows a program to print the key code name to the screen in a say
    statement. The method is usually not needed. In particular, code like this:

<programlisting>
<![CDATA[
  ::method someMethod
    use arg key
    ...
    if .VK~key2Name(key) == "INSERT" then
      ...

]]>
</programlisting>

    can be replaced by this:

<programlisting>
<![CDATA[
  ::method someMethod
    use arg key
    ...
    if key == .VK~INSERT then
      ...

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    A syntax error is raised if <emphasis role="italic">numericCode</emphasis> is not a whole number the range of 0
    through 255.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End VK::key2name() -->

<section id="exampleVKConstant"><title>Example VK Constant Use</title>
<para>
  This example connects the key down event in a tree control with a method in the dialog. If the user presses the
  delete key while the tree control has the focus, the selected item is deleted. Likewise, if the user presses the
  insert key he is given the opportunity to insert a new item into the tree.
</para>

<programlisting>
<![CDATA[

::class 'TreeDlg' subclass ResDialog
...

::method initDialog

self~connectTreeViewEvent(IDC_TREE, "KEYDOWN", onKeyDown)
...

::method onKeyDown
use arg treeId, key
tree = self~newTreeView(treeId)

-- If the delete key is pressed, delete the selected item, or if the insert
-- key is pressed insert a new item by programmaticaly clicking the New Item
-- button. Otherwise ignore key.
if key == .VK~DELETE then
   tree~delete(tree~selected)
else if key == .VK~INSERT then
   self~newPushButton(IDC_PB_NEW_ITEM)~push

]]>
</programlisting>
</section>

</section> <!-- End VK Class -->


<section id="clsDlgArea"><title>DlgArea Class</title>
<indexterm><primary>DlgArea class</primary></indexterm>
<para>
  The <computeroutput>DlgArea</computeroutput> class provides assistance in laying out the dialog controls in a
  dynamically defined dialog.  The class defines an area within the <link linkend="defClientArea">client</link> area of
  a <link linkend="clsUserDialog">UserDialog</link>. It is a helper class for the <link
  linkend="mthDefineDialog">defineDialog</link> method of a <computeroutput>UserDialog</computeroutput> and has no
  effect on any <link linkend="ovvUnderlying">underlying</link> window.
</para>
<para>
  The methods and attributes of the <computeroutput>DlgArea</computeroutput> provide the coordinates of, and within, the
  defined area. All coordinates are specified as <emphasis role="italic">client area</emphasis> coordinates. That is,
  all coordinates are relative to the origin (0, 0) of the client area of the dialog.
</para>
<para>
  The following figure shows the measurement attributes used to position a <computeroutput>DlgArea</computeroutput> on
  the client area of a <computeroutput>UserDialog</computeroutput>.
</para>
<figure id="dlgareafig"><title>DlgArea Measurements</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="dlgArea" scale="90">
</imageobject>
</mediaobject>
</figure>

<section id="sctMethodsDlgArea"><title>Method Table</title>
<para>
  The following table lists the class methods, attributes, and instance methods of the
  <computeroutput>DlgArea</computeroutput> class:

<table id="tblMethodsDlgArea" frame="all"> <title>DlgArea Class Method Reference</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthNewClsDlgArea">new</link></entry>
<entry>Instantiates a new <computeroutput>DlgArea</computeroutput> object.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Attributes</emphasis></entry>
<entry align="center"><emphasis role="bold">Attributes</emphasis></entry>
</row>
<row>
<entry><link linkend="atrB">b</link></entry>
<entry>Reflects the y coordinate, in dialog units, of the bottom margin of the dialog area.</entry>
</row>
<row>
<entry><link linkend="atrHeight">height</link></entry>
<entry>Reflects the height of the dialog area in dialog units.</entry>
</row>
<row>
<entry><link linkend="atrL">l</link></entry>
<entry>Reflects the x coordinate, in dialog units, of the left margin of the area.</entry>
</row>
<row>
<entry><link linkend="atrLeft">left</link></entry>
<entry>Reflects the x coordinate, in dialog units, of the left edge of the area.</entry>
</row>
<row>
<entry><link linkend="atrMargin">margin</link></entry>
<entry>Reflects the size, in dialog units, of the dialog area margin.</entry>
</row>
<row>
<entry><link linkend="atrR">r</link></entry>
<entry>Reflects the x coordinate, in dialog units, of the right margin of the area.</entry>
</row>
<row>
<entry><link linkend="atrT">t</link></entry>
<entry>Reflects the y coordinate, in dialog units, of the top margin of the area.</entry>
</row>
<row>
<entry><link linkend="atrTop">top</link></entry>
<entry>Reflects the y coordinate, in dialog units, of the top edge of the area.</entry>
</row>
<row>
<entry><link linkend="atrWidth">width</link></entry>
<entry>Reflects the width of the dialog area in dialog units.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthCX">cx</link></entry>
<entry>Returns a width, in dialog units, relative to the width of the dialog area.</entry>
</row>
<row>
<entry><link linkend="mthCY">cy</link></entry>
<entry>Returns a height, in dialog units, relative to the height of the dialog area.</entry>
</row>
<row>
<entry><link linkend="mthH">h</link></entry>
<entry>Returns a height, in dialog units, relative to the height of the dialog area.</entry>
</row>
<row>
<entry><link linkend="mthHR">hr</link></entry>
<entry>Returns the remaining height, in dialog units, between the last y invocation and the bottom margin of the area.</entry>
</row>
<row>
<entry><link linkend="mthRightClsDlgArea">right</link></entry>
<entry>Returns the x coordinate, in dialog units, of the right edge of the area.</entry>
</row>
<row>
<entry><link linkend="mthW">w</link></entry>
<entry>Returns a width, in dialog units, relative to the width of the dialog area.</entry>
</row>
<row>
<entry><link linkend="mthWR">wr</link></entry>
<entry>Returns the remaining width, in dialog units, between the last x invocation and the right margin of the area.</entry>
</row>
<row>
<entry><link linkend="mthXClsDlgArea">x</link></entry>
<entry>Returns a x coordinate relative to the client area of the dialog by specifying an offset relative to the defined dialog area.</entry>
</row>
<row>
<entry><link linkend="mthYClsDlgArea">y</link></entry>
<entry>Returns a y coordinate relative to the client area of the dialog by specifying an offset relative to the defined dialog area.</entry>
</row>
</tbody></tgroup>
</table>
</para>
</section>

<section id="mthNewClsDlgArea"><title>init</title>
<indexterm><primary>new</primary><secondary>DlgArea class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--new(--x--,--y--,--width--,--height--+-------------+--)---------------------><
                                        +--,--margin--+
]]>
</programlisting>

<para>
  Instantiates a new <computeroutput>DlgArea</computeroutput> object.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>x [required]</term>
      <listitem>
      <para>
        The x coordinate for the area to be defined. The coordinate is specified in dialog <link
        linkend="defDialogUnit">units</link> and is relative to the top left corner of the <link
        linkend="defClientArea">client</link> area of the <computeroutput>UserDialog</computeroutput>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>y [required]</term>
      <listitem>
      <para>
        The y coordinate for the area to be defined. The coordinate is specified in dialog units and is relative to the
        top left corner of the client area of the <computeroutput>UserDialog</computeroutput>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>width [required]</term>
      <listitem>
      <para>
        The width, in dialog units, of the area being defined.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>height [required]</term>
      <listitem>
      <para>
        The height, in dialog units, of the area being defined.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>margin [optional]</term>
      <listitem>
      <para>
        An inner margin, in dialog units, within the dialog area to be left blank. The default is 5
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This examples defines two dialog areas in a dialog. The first area, <emphasis role="italic">u</emphasis>, is defined
    for the entire client area of the dialog. The second area, <computeroutput>b</computeroutput> is defined as a
    sub-area of the <computeroutput>u</computeroutput> area.
  </para>

<programlisting>
<![CDATA[
u = .dlgArea~new(0, 0, self~sizeX,self~sizeY)
b = .dlgArea~new(u~x("70%"), u~y , u~w("R"), u~h("R"))
]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="atrT"><title>t (Attribute)</title>
<indexterm><primary>t</primary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>t</secondary></indexterm>
<programlisting>
<![CDATA[
>>--t--------------------------------------------><
]]>
</programlisting>
<para>
  Reflects the y coordinate, in dialog units, of the top margin of the area.
</para>

</section>

<section id="atrL"><title>l (Attribute)</title>
<indexterm><primary>l</primary></indexterm>
<indexterm><primary>DlgArea class</primary<secondary>l</secondary></indexterm>
<programlisting>
<![CDATA[
>>--l--------------------------------------------><
]]>
</programlisting>
<para>
  Reflects the x coordinate, in dialog units, of the left margin of the area.
</para>

</section>

<section id="atrB"><title>b (Attribute)</title>
<indexterm><primary>b</primary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>b</secondary></indexterm>
<programlisting>
<![CDATA[
>>--b--------------------------------------------><
]]>
</programlisting>
<para>
  Reflects the y coordinate, in dialog units, of the bottom margin of the area.
</para>

<para></para>
</section>

<section id="atrR"><title>r (Attribute)</title>
<indexterm><primary>r</primary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>r</secondary></indexterm>
<programlisting>
<![CDATA[
>>--r--------------------------------------------><
]]>
</programlisting>
<para>
  Reflects the x coordinate, in dialog units, of the right margin of the area.
</para>

</section>

<section id="atrTop"><title>top (Attribute)</title>
<indexterm><primary>top</primary><secondary>DlgArea class</secondary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>top</secondary></indexterm>
<programlisting>
<![CDATA[
>>--top------------------------------------------><
]]>
</programlisting>
<para>
  Reflects the y coordinate, in dialog units, of the top edge of the area.
</para>

</section>

<section id="atrLeft"><title>left (Attribute)</title>
<indexterm><primary>left</primary><secondary>DlgArea class</secondary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>left</secondary></indexterm>
<programlisting>
<![CDATA[
>>--left-----------------------------------------><
]]>
</programlisting>
<para>
  Reflects the x coordinate, in dialog units, of the left edge of the area.
</para>

</section>

<section id="atrWidth"><title>width (Attribute)</title>
<indexterm><primary>width</primary><secondary>DlgArea class</secondary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>width</secondary></indexterm>
<programlisting>
<![CDATA[
>>--width----------------------------------------><
]]>
</programlisting>
<para>
  Reflects the width of the dialog area in dialog units.
</para>

</section>

<section id="atrHeight"><title>height (Attribute)</title>
<indexterm><primary>height</primary><secondary>DlgArea class</secondary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>height</secondary></indexterm>
<programlisting>
<![CDATA[
>>--height---------------------------------------><
]]>
</programlisting>
<para>
  Reflects the height of the dialog area in dialog units.
</para>

</section>

<section id="atrMargin"><title>margin (Attribute)</title>
<indexterm><primary>margin</primary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>margin</secondary></indexterm>
<programlisting>
<![CDATA[
>>--margin---------------------------------------><
]]>
</programlisting>

<para>
  Reflects the size, in dialog units, of the dialog area margin.
</para>

</section>

<section id="mthCX"><title>cx</title>
<indexterm><primary>cx</primary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>cx</secondary></indexterm>
<programlisting>
<![CDATA[
>>--cx(--+---------+--)--------------------------><
         +--flag---+

]]>
</programlisting>
<para>
  Returns a width, in dialog units, relative to the width of the dialog area. The <emphasis role="italic">cx</emphasis>
  and <link linkend="mthW">w</link> methods are synonomous.
</para>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
      <varlistentry><term>flag [optional]</term>
      <listitem>
      <para>
        The <emphasis role="italic">flag</emphasis> argument signals what part of the width to return.
      </para>
      <para>
        If the flag is omitted, then the entire width of the dialog area, excluding the margins, is returned. If flag is
        not omitted, it should be one of the following symbols:
      </para>
      <variablelist>
        <varlistentry><term>n%</term>
        <listitem>
        <para>
           Where <computeroutput>n</computeroutput> is a number and the percent sign signals that a percentage of the
           dialog area width should be returned. E.g., <computeroutput>10%</computeroutput> would mean to return 10
           percent of the dialog area width.  <computeroutput>8%</computeroutput> would ask for 8 percent of the width,
           etc..
        </para>
        </listitem></varlistentry>
        <varlistentry><term>R</term>
        <listitem>
        <para>
          A capital <computeroutput>R</computeroutput> indicates the <emphasis role="italic">remainder</emphasis> of the
          dialog area width should be returned. I.e., that portion of the width between the last invocation of the <link
          linkend="mthXClsDlgArea">x</link> method and the right margin.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Returns:</emphasis></term>
  <listitem>
  <para>
    The return is part, or all, of the dialog area width as specified by the <emphasis role="italic">flag</emphasis>
    argument.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Rigours error checking of the argument is not done. If the argument is not recognized it is just ignored and treated
    as if the argument was omitted.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthCY"><title>cy</title>
<indexterm><primary>cy</primary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>cy</secondary></indexterm>
<programlisting>
<![CDATA[
>>--cy(--+---------+--)--------------------------><
         +--flag---+

]]>
</programlisting>

<para>
  Returns a height, in dialog units, relative to the height of the dialog area. The <emphasis
  role="italic">cy</emphasis> and <link linkend="mthH">h</link> methods are synonomous.
</para>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
      <varlistentry><term>flag [optional]</term>
      <listitem>
      <para>
        The <emphasis role="italic">flag</emphasis> argument signals what part of the height to return.
      </para>
      <para>
        If the flag is omitted, then the entire height of the dialog area, excluding the margins, is returned. If flag
        is not omitted, it should be one of the following symbols:
      </para>
      <variablelist>
        <varlistentry><term>n%</term>
        <listitem>
        <para>
           Where <computeroutput>n</computeroutput> is a number and the percent sign signals that a percentage of the
           dialog area height should be returned. E.g., <computeroutput>4%</computeroutput> would mean to return 4
           percent of the dialog area height  <computeroutput>20%</computeroutput> would ask for 20 percent of the
           height, etc..
        </para>
        </listitem></varlistentry>
        <varlistentry><term>R</term>
        <listitem>
        <para>
          A capital <computeroutput>R</computeroutput> indicates the <emphasis role="italic">remainder</emphasis> of the
          dialog area height should be returned. I.e., that portion of the height between the last invocation of the
          <link linkend="mthYClsDlgArea">y</link> method and the bottom margin.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Returns:</emphasis></term>
  <listitem>
  <para>
    The return is part, or all, of the dialog area height as specified by the <emphasis role="italic">flag</emphasis>
    argument.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Rigours error checking of the argument is not done. If the argument is not recognized it is just ignored and treated
    as if the argument was omitted.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthH"><title>h</title>
<indexterm><primary>h</primary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>h</secondary></indexterm>

<para>
  Returns a height, in dialog units, relative to the height of the dialog area. The <emphasis
  role="italic">h</emphasis> and <link linkend="mthCY">cy</link> methods are synonomous.
</para>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
      <varlistentry><term>flag [optional]</term>
      <listitem>
      <para>
        The <emphasis role="italic">flag</emphasis> argument signals what part of the height to return.
      </para>
      <para>
        If the flag is omitted, then the entire height of the dialog area, excluding the margins, is returned. If flag
        is not omitted, it should be one of the following symbols:
      </para>
      <variablelist>
        <varlistentry><term>n%</term>
        <listitem>
        <para>
           Where <computeroutput>n</computeroutput> is a number and the percent sign signals that a percentage of the
           dialog area height should be returned. E.g., <computeroutput>4%</computeroutput> would mean to return 5
           percent of the dialog area height  <computeroutput>20%</computeroutput> would ask for 20 percent of the
           height, etc..
        </para>
        </listitem></varlistentry>
        <varlistentry><term>R</term>
        <listitem>
        <para>
          A capital <computeroutput>R</computeroutput> indicates the <emphasis role="italic">remainder</emphasis> of the
          dialog area height should be returned. I.e., that portion of the height between the last invocation of the
          <link linkend="mthYClsDlgArea">y</link> method and the bottom margin.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Returns:</emphasis></term>
  <listitem>
  <para>
    The return is part, or all, of the dialog area height as specified by the <emphasis role="italic">flag</emphasis>
    argument.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Rigours error checking of the argument is not done. If the argument is not recognized it is just ignored and treated
    as if the argument was omitted.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthHR"><title>hr</title>
<indexterm><primary>hr</primary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>hr</secondary></indexterm>
<programlisting>
<![CDATA[
>>--hr-------------------------------------------><
]]>
</programlisting>

<para>
  Returns the remaining height, in dialog units, between the last <link linkend="mthYClsDlgArea">y</link> invocation and
  the bottom margin of the area. This is equivalent to <link linkend="mthH">h("R")</link>.
</para>

</section>

<section id="mthRightClsDlgArea"><title>right</title>
<indexterm><primary>right</primary><secondary>DlgArea class</secondary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>right</secondary></indexterm>
<programlisting>
<![CDATA[
>>--right----------------------------------------><
]]>
</programlisting>

<para>
  Returns the x coordinate, in dialog units, of the right edge of the area.
</para>

</section>

<section id="mthW"><title>w</title>
<indexterm><primary>w</primary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>w</secondary></indexterm>
<programlisting>
<![CDATA[
>>--w(--+---------+--)---------------------------><
        +--flag---+

]]>
</programlisting>
<para>
  Returns a width, in dialog units, relative to the width of the dialog area. The <link linkend="mthCX">cx</link> and
  <emphasis role="italic">w</emphasis> methods are synonomous.
</para>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
      <varlistentry><term>flag [optional]</term>
      <listitem>
      <para>
        The <emphasis role="italic">flag</emphasis> argument signals what part of the width to return.
      </para>
      <para>
        If the flag is omitted, then the entire width of the dialog area, excluding the margins, is returned. If flag is
        not omitted, it should be one of the following symbols:
      </para>
      <variablelist>
        <varlistentry><term>n%</term>
        <listitem>
        <para>
           Where <computeroutput>n</computeroutput> is a number and the percent sign signals that a percentage of the
           dialog area width should be returned. E.g., <computeroutput>10%</computeroutput> would mean to return 10
           percent of the dialog area width.  <computeroutput>8%</computeroutput> would ask for 8 percent of the width,
           etc..
        </para>
        </listitem></varlistentry>
        <varlistentry><term>R</term>
        <listitem>
        <para>
          A capital <computeroutput>R</computeroutput> indicates the <emphasis role="italic">remainder</emphasis> of the
          dialog area width should be returned. I.e., that portion of the width between the last invocation of the <link
          linkend="mthXClsDlgArea">x</link> method and the right margin.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Returns:</emphasis></term>
  <listitem>
  <para>
    The return is part, or all, of the dialog area width as specified by the <emphasis role="italic">flag</emphasis>
    argument.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Rigours error checking of the argument is not done. If the argument is not recognized it is just ignored and treated
    as if the argument was omitted.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthWR"><title>wr</title>
<indexterm><primary>wr</primary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>wr</secondary></indexterm>
<programlisting>
<![CDATA[
>>--wr-------------------------------------------><
]]>
</programlisting>

<para>
  Returns the remaining width, in dialog units, between the last <link linkend="mthXClsDlgArea">x</link> invocation and the
  right margin of the area. This is equivalent to <link linkend="mthW">w("R")</link>.
</para>

</section>

<section id="mthXClsDlgArea"><title>x</title>
<indexterm><primary>x</primary><secondary>DlgArea class</secondary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>x</secondary></indexterm>
<programlisting>
<![CDATA[
>>--x(--+----------+--)--------------------------><
        +--offSet--+

]]>
</programlisting>

<para>
  Returns a x coordinate relative to the <link linkend="defClientArea">client</link> area of the dialog by specifying
  an offset relative to the defined dialog area.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
      <varlistentry><term>offset [optional]</term>
      <listitem>
      <para>
        If <emphasis role="italic">offset</emphasis> is omitted, then the x coordinate of the left margin is returned.
      </para>
      <para>
        Otherwise, <emphasis role="italic">offset</emphasis> is specified as either a concrete number or as a
        percentage. To specify a percentage add the percent sign to the number, e.g. for twenty percent use
        <computeroutput>20%</computeroutput>.
      </para>
      <para>
        In addition, <emphasis role="italic">offset</emphasis> can be negative or positive. When positive, the offset is
        an amount to the right of the left margin. When negative, the offset is an amount to the left of the right
        margin. Both concrete and percentage offsets can be negative.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Returns:</emphasis></term>
  <listitem>
  <para>
    The appropriate <link linkend="defClientArea">client</link> area x coordinate, in dialog units, as specified by the
    <emphasis role="italic">offset</emphasis> argument.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthYClsDlgArea"><title>y</title>
<indexterm><primary>y</primary><secondary>DlgArea class</secondary></indexterm>
<indexterm><primary>DlgArea class</primary><secondary>y</secondary></indexterm>
<programlisting>
<![CDATA[
>>--y(--+----------+--)--------------------------><
        +--offSet--+

]]>
</programlisting>

<para>
  Returns a y coordinate relative to the <link linkend="defClientArea">client</link> area of the dialog by specifying
  an offset relative to the defined dialog area.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
      <varlistentry><term>offset [optional]</term>
      <listitem>
      <para>
        If <emphasis role="italic">offset</emphasis> is omitted, then the y coordinate of the top margin is returned.
      </para>
      <para>
        Otherwise, <emphasis role="italic">offset</emphasis> is specified as either a concrete number or as a
        percentage. To specify a percentage add the percent sign to the number, e.g. for twenty percent use
        <computeroutput>20%</computeroutput>.
      </para>
      <para>
        In addition, <emphasis role="italic">offset</emphasis> can be negative or positive. When positive, the offset is
        an amount below the top margin. When negative, the offset is an amount above the bottom margin. Both concrete
        and percentage offsets can be negative.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Returns:</emphasis></term>
  <listitem>
  <para>
    The appropriate <link linkend="defClientArea">client</link> area y coordinate, in dialog units, as specified by the
    <emphasis role="italic">offset</emphasis> argument.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="exampleDlgArea"><title>DlgArea Example</title>
<para>
  With a <computeroutput>UserDialog</computeroutput> we want the top left to be an edit control, with an area for
  buttons on the right and a status area below.
</para>
<para>
  We decide to give 70% of the width and 90% of the height to the edit control. We leave the margin as the default.
</para>
<figure id="dlgareaplanfig"><title>DlgArea Plan</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="dlgareaplan">
</imageobject>
</mediaobject>
</figure>
<para>
  Here is what our defineDialog method might look like:
</para>
<programlisting>
<![CDATA[
/* ------------------------------------------------------------------------- */
::method defineDialog
/* ------------------------------------------------------------------------- */
/* define DlgArea named u as whole of user dialog                            */
u=.dlgArea~new(  0       ,         0,self~SizeX,Self~SizeY)   /* whole dlg   */

/* define DlgArea named e within DlgArea u for edit control                  */
e=.dlgArea~new(u~x       ,u~y       ,u~w("70%"),u~h("90%"))

/* define DlgArea named s within DlgArea u for Status Area in remaining height*/
s=.dlgArea~new(u~x       ,u~y("90%"),u~w("70%"),u~hr      )

/* define DlgArea named b within DlgArea u for Button area                   */
b=.dlgArea~new(u~x("70%"),u~y       ,u~wr      ,u~hr      )

/* Edit control coterminous with area e margins                              */
self~createEdit(12, e~x, e~y, e~w, e~h, "multiline", "text")

/* Status Area Coterminous with area s margins                               */
self~createStaticText(11, s~x, s~y, s~w, s~h, , "Status info appears here")

/* Seven buttons evenly spaced at 10% intervals, 9% high                     */
do i = 0 to 6
   self~createPushButton(12+i,b~x,b~y((i * 10)||"%"),b~w,b~h("9%"), ,"Button" i,"Button"||i)
end /* DO */

/* ok button 15 dialog units high at bottom of area b                        */
self~createPushButton(IDOK,b~x,b~y(-15),b~w,15,"Default","OK","OK")
]]>
</programlisting>
<para>
  Here is the resultant dialog.
</para>
<figure id="dlgareasample"><title>Sample DlgArea</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="sample1.png">
</imageobject>
</mediaobject>
</figure>
</section>
</section>

<section id="clsDlgAreaU"><title>DlgAreaU Class</title>
<indexterm><primary>DlgAreaU class</primary></indexterm>
<para>
  The <computeroutput>DlgAreaU</computeroutput> class is a subclass of the <link linkend="clsDlgArea">DlgArea</link>
  class that helps with the creation of dynamically resizable dialogs. This class provides assistance in resizing and /
  or positioning controls when a dialog is resized.  When the <computeroutput>DlgArea</computeroutput> and
  <computeroutput>DlgAreaU</computeroutput> classes are used together, the they provide a convenient way to create
  resizable dialogs.
</para>
<para>
  <emphasis role="bold">Note:</emphasis> The <computeroutput>DlgAreaU</computeroutput> class uses the <emphasis
  role="italic">.Object</emphasis> class's <emphasis role="italic">source</emphasis> class method to parse the source
  code of the dialog's <link linkend="mthDefineDialog">defineDialog</link> method.  This source is not available if the
  <emphasis role="italic">rexxc</emphasis> program is used to tokenize the source code. Therefore, <emphasis
  role="italic">DlgAreaU</emphasis> class will <emphasis role="bold">not</emphasis> work if <emphasis
  role="italic">rexxc</emphasis> is used to tokenize the source code.
</para>
<para>
  The other implication of using the <emphasis role="italic">source</emphasis> method to parse the dialog's <emphasis
  role="italic">defineDialog</emphasis> method is that the <computeroutput>DlgAreaU</computeroutput> class can only be
  used with a <link linkend="clsUserDialog">UserDialog</link>. It will not work with any other dialog class, such as the
  <link linkend="clsResDialog">ResDialog</link> or <link linkend="clsRcDialog">RcDialog</link> classes.
</para>

<section id="sctMethodsDlgAreaU"><title>Method Table</title>
<para>
  Instances of the <computeroutput>DlgAreaU</computeroutput> class implement the methods listed in the following
  table.

<table id="tDlgAreaUClass" frame="all">
<title>DlgAreaU Method Reference</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Class Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthNewClsDlgAreaU">new</link></entry>
<entry>Instantiates a new <computeroutput>DlgAreaU</computeroutput> object.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Attributes</emphasis></entry>
<entry align="center"><emphasis role="bold"></emphasis></entry>
</row>
<row>
<entry><link linkend="atrCorrectionFactor">correctionFactor</link></entry>
<entry>A value used to fix problems in the conversion of pixels to dialog units by adjusting the ratio of original size to change in size.</entry>
</row>
<row>
<entry><link linkend="atrLastError">lastError</link></entry>
<entry>Holds the details if an error was encountered when parsing the dialog's defineDialog method.</entry>
</row>
<row>
<entry><link linkend="atrNoMove">noMove</link></entry>
<entry>Holds a set of the resource IDs of dialog controls not to be moved during a resize event.</entry>
</row>
<row>
<entry><link linkend="atrNoResize">noResize</link></entry>
<entry>Holds a set of the resource IDs of dialog controls not to be resized during a resize event.</entry>
</row>
<row>
<entry><link linkend="atrUpdateOnResize">upDateOnResize</link></entry>
<entry>Controls whether the DlgAreaU object forces the dialog controls to redraw after every resize event.</entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
</row>
<row>
<entry><link linkend="mthNoMovePut">noMovePut</link></entry>
<entry>Adds a dialog control to the set of dialog controls that will not be moved during the resize event.</entry>
</row>
<row>
<entry><link linkend="mthNoResizePut">noResizePut</link></entry>
<entry>Adds a dialog control to the set of dialog controls that will not be resized during the resize event.</entry>
</row>
<row>
<entry><link linkend="mthResizeClsDlgAreaU">resize</link></entry>
<entry>Causes the DlgAreaU object to resize and reposition all the dialog controls in the dialog.</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

</section>

<section id="mthNewClsDlgAreaU"><title>new (Class method)</title>
<indexterm><primary>new</primary><secondary>DlgAreaU class</secondary></indexterm>
<indexterm><primary>DlgAreaU class</primary><secondary>new</secondary></indexterm>
<programlisting>
<![CDATA[
>>--new(-dlg--+----------+--+------------+--+--------+-)-----------------------><
             +-,-margin-+  +-,-noResize-+  +-noMove-+

]]>
</programlisting>

<para>
  The <computeroutput>DlgAreaU</computeroutput> object creates a dialog area coterminous with the calling dialog. It is
  a subclass of the <link linkend="clsDlgArea">DlgArea</link> class and therefore inherits all the methods and
  attributes of that class.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  </para>
    <variablelist>
      <varlistentry><term>dlg</term>
      <listitem>
      <para>
        The resizable dialog you are creating a dialog area for. This dialog must be subclassed from a
       <link linkend="clsUserDialog">UserDialog</link>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>margin</term>
      <listitem>
      <para>
        The <computeroutput>DlgArea</computeroutput> <link linkend="atrMargin">margin</link>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>noResize</term>
      <listitem>
      <para>
        A <computeroutput>.Set</computeroutput> object containing the resource <link linkend="defResourceID">IDs</link>
        of the dialog controls that should <emphasis role="bold">not</emphasis> be resized during the resize event. The
        IDs may be numeric or <link linkend="defSymbolicID">symbolic</link>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>noMove</term>
      <listitem>
      <para>
        A <computeroutput>.Set</computeroutput> object containing the resource <link linkend="defResourceID">IDs</link>
        of the dialog controls that should <emphasis role="bold">not</emphasis> be moved during the resize event. The
        IDs may be numeric or <link linkend="defSymbolicID">symbolic</link>.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="atrCorrectionFactor"><title>correctionFactor (Attribute)</title>
<indexterm><primary>correctionFactor</primary></indexterm>
<indexterm><primary>DlgAreaU class</primary<secondary>correctionFactor</secondary></indexterm>
<programlisting>
<![CDATA[
>>--correctionFactor-----------------------------><

>>--correctionFactor-=-num-----------------------><
]]>
</programlisting>

<para>
  An attribute containing the value used to adjust the ratio of the top &amp; left margins to the bottom &amp; right
  margins. (The default correction factor is set to 1.05.) The <link linkend="sctDlgAreaUProblems">Possible
  Problems</link> section has additional details on using the <emphasis role="italic">correctionFactor</emphasis>
  attribute.
</para>
</section>

<section id="atrLastError"><title>lastError (Attribute)</title>
<indexterm><primary>lastError</primary></indexterm>
<indexterm><primary>DlgAreaU class</primary<secondary>lastError</secondary></indexterm>
<programlisting>
<![CDATA[
>>--lastError------------------------------------><

>>--lastError-=-errMsg---------------------------><
]]>
</programlisting>

<para>
  An attribute holding the details if an error was encountered when parsing the calling dialog's <link
  linkend="mthDefineDialog">defineDialog</link> method.  The value of the attribute is .nil if no error occurred.
</para>
</section>

<section id="atrNoMove"><title>noMove (Attribute)</title>
<indexterm><primary>noMove</primary></indexterm>
<indexterm><primary>DlgAreaU class</primary><secondary>noMove</secondary></indexterm>
<programlisting>
<![CDATA[
>>--noMove---------------------------------------><

>>--noMove-=-ids---------------------------------><
]]>
</programlisting>

<para>
  A <computeroutput>.Set</computeroutput> object holding the resource IDs of the dialog controls that the programmer
  does not wish to be moved during a resize event. The IDs in the set must be numeric.
</para>
<para>
  The programmer can use <link linkend="defSymbolicID">symbolic</link> IDs for the dialog controls by adding to the set
  through the <link linkend="mthNoMovePut">noMovePut</link> method. Or by passing in a
  <computeroutput>.Set</computeroutput> object when instantiating a <link linkend="mthNewClsDlgAreaU">new</link>
  <computeroutput>DlgAreaU</computeroutput> object. If the programmer accesses the set of IDs directly through the
  <emphasis role="italic">noMove</emphasis> attribute to add a resource ID, only numeric IDs should be used.
</para>
</section>

<section id="atrNoResize"><title>noResize (Attribute)</title>
<indexterm><primary>noResize</primary></indexterm>
<indexterm><primary>DlgAreaU class</primary<secondary>noResize</secondary></indexterm>

<programlisting>
<![CDATA[
>>--noResize-------------------------------------><

>>--noResize-=-ids-------------------------------><
]]>
</programlisting>

<para>
  A <computeroutput>.Set</computeroutput> object holding the resource IDs of the dialog controls that the programmer
  does not wish to be resized during a resize event. The IDs in the set must be numeric.
</para>
<para>
  The programmer can use <link linkend="defSymbolicID">symbolic</link> IDs for the dialog controls by adding to the set
  through the <link linkend="mthNoResizePut">noResizePut</link> method. Or by passing in a
  <computeroutput>.Set</computeroutput> object when instantiating a <link linkend="mthNewClsDlgAreaU">new</link>
  <computeroutput>DlgAreaU</computeroutput> object. If the programmer accesses the set of IDs directly through the
  <emphasis role="italic">noResize</emphasis> attribute to add a resource ID, only numeric IDs should be used.
</para>
</section>

<section id="atrUpdateOnResize"><title>updateOnResize (Attribute)</title>
<indexterm><primary>updateOnResize</primary></indexterm>
<indexterm><primary>DlgAreaU class</primary><secondary>updateOnResize</secondary></indexterm>
<programlisting>
<![CDATA[
>>--updateOnResize-------------------------------><
>>--updateOnResize-=-boolean---------------------><
]]>
</programlisting>

<para>
  An attribute that controls whether the <computeroutput>DlgAreaU</computeroutput> object forces the dialog controls to
  redraw during every resize event.  The default value of this attribute is <computeroutput>.true</computeroutput>, the
  dialog controls are forced to redraw on every resize event. Setting this attribute to false will prevent the dialog
  controls from being forced to redraw.
</para>
<para>
  When the <emphasis role="italic">updateOnResize</emphasis> attribute is <computeroutput>.false</computeroutput>, it
  becomes the programmer's responsibility to force the dialog controls to redraw when the user has stopped resizing the
  dialog. This can be down by using the <link linkend="mthConnectSizeMoveEnded"></link> method. Having the dialog
  controls redraw only once eliminates flicker while the user is sizing the dialog. However, the dialog controls do not
  change size or position while the using is sizing the dialog. In the <computeroutput>samples\oodialog</computeroutput>
  directory of the ooRexx installation are two example programs: <computeroutput>dlgAreaUDemo.rex</computeroutput>
  redraws the dialog controls on every resize event. <computeroutput>dlgAreaUDemoTwo.rex</computeroutput> only redraws
  the controls once, when the user has stopped resizing the controls. Contrast the two programs to determine which
  method best suits the needs or your program.
</para>
</section>

<section id="mthNoMovePut"><title>noMovePut</title>
<indexterm><primary>noMovePut</primary></indexterm>
<indexterm><primary>DlgAreaU class</primary><secondary>noMovePut</secondary></indexterm>
<programlisting>
<![CDATA[
>>--noMovePut(--resourceID--)--------------------><

]]>
</programlisting>

<para>
  Adds a dialog control to the <link linkend="atrNoMove">set</link> of dialog controls that will not be moved during the
  resize event.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
  <variablelist>
    <varlistentry><term>resourceID [required]</term>
    <listitem>
    <para>
      The resource ID of the dialog control that is not to be moved during the resize event. May be symbolic or numeric.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    This method does not return a value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Using this method allows the programmer to use <link linkend="defSymbolicID">symbolic</link> ids for the dialog
    control. If the resource ID is put directly into the set through the <emphasis role="italic">noMove</emphasis>
    attribute, symbolic IDs will not be recognized.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    If a symbolic ID is used and it can not be resolved a syntax error is raised.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DlgAreaU::noMovePut() -->

<section id="mthNoResizePut"><title>noResizePut</title>
<indexterm><primary>noResizePut</primary></indexterm>
<indexterm><primary>DlgAreaU class</primary><secondary>noResizePut</secondary></indexterm>
<programlisting>
<![CDATA[
>>--noResizePut(--resourceID--)------------------><

]]>
</programlisting>

<para>
  Adds a dialog control to the <link linkend="atrNoResize">set</link> of dialog controls that will not be resized during
  the resize event.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
  <variablelist>
    <varlistentry><term>resourceID [required]</term>
    <listitem>
    <para>
      The resource ID of the dialog control that is not to be resized during the resize event. May be symbolic or
      numeric.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    This method does not return a value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Using this method allows the programmer to use <link linkend="defSymbolicID">symbolic</link> ids for the dialog
    control. If the resource ID is put directly into the set through the <emphasis role="italic">noResize</emphasis>
    attribute, symbolic IDs will not be recognized.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    If a symbolic ID is used and it can not be resolved a syntax error is raised.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DlgAreaU::noMovePut() -->

<section id="mthResizeClsDlgAreaU"><title>resize</title>
<indexterm><primary>resize</primary><secondary>DlgAreaU class</secondary></indexterm>
<indexterm><primary>DlgAreaU class</primary><secondary>resize</secondary></indexterm>
<programlisting>
<![CDATA[
>>--resize(--dlgObj--,--sizeInfo--)--------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">resize</emphasis> method causes the <computeroutput>DlgAreaU</computeroutput> object to
  resize and reposition all the dialog controls in the <emphasis role="italic">dlgObj</emphasis> dialog in relation to
  the <emphasis role="italic">sizeInfo</emphasis> argument. Normally the dialog is then told to update itself, which
  redraws the controls. However, the updating is dependent on the value of the <link
  linkend="atrUpdateOnResize">upDateOnResize</link> attribute.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>dlgObj [required]</term>
    <listitem>
    <para>
      The dialog which is being resized. The dialog must be the same dialog used to instantiate the <link
      linkend="mthNewClsDlgAreaU">new</link> <computeroutput>DlgAreaU</computeroutput> object.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>sizeInfo [required]</term>
    <listitem>
    <para>
      The new size of the dialog. Normally, <emphasis role="italic">sizeInfo</emphasis> comes from the value passed to
      your resize <link linkend="paraResizeEvent">event</link> handler.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    This method does not return a value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The most common way to use the <computeroutput>DlgAreaU</computeroutput> class is to connect the <link
    linkend="mthConnectResize">RESIZE</link> event to an event handling method in a resizable dialog. Then the <emphasis
    role="italic">sizeInfo</emphasis> arg to the event handler is simply passed on to the <emphasis
    role="italic">resize</emphasis> method.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example shows a typical event handling method in a resizable dialog that makes use of the
    <computeroutput>DlgAreaU</computeroutput> class
<programlisting>
<![CDATA[

::method defineDialog
  expose u

  self~connectResize('onResize')

  u = .dlgAreaU~new(self)
  ...


::method onResize unguarded
  expose u
  use arg sizeEvent, sizeInfo

  u~resize(self, sizeInfo)
  return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End DlgAreaU::resize() -->

<section id="sctCeateResizableDialogs"><title>Creating Resizeable Dialogs</title>
<indexterm><primary>dynamically resizable dialogs</primary><secondary>DlgAreaU class</secondary></indexterm>
<indexterm><primary>DlgAreaU class</primary><secondary>resizable dialogs</secondary></indexterm>
<para>
  You can use the <computeroutput>DlgAreaU</computeroutput> class to facilitate creating dynamically resizable dialogs.
  However the following restrictions apply:
</para>
<para>
  The dialog must be a <link linkend="clsUserDialog">UserDialog</link> with all dialog controls created in the dialog
  template from within the <link linkend="mthDefineDialog">defineDialog</link> method. In the <link
  linkend="mthCreate">create</link> or <link linkend="mthCreateCenter">createCenter</link> method, the dialog template
  must be created with the THICKFRAME option.
</para>
<para id="paraResizeEvent">
  You must connect the <link linkend="mthConnectResize">RESIZE</link> event to a method in your dialog. Add the
  following code somewhere in your dialog code. The <emphasis role="italic">init</emphasis>, <emphasis
  role="italic">defineDialog</emphasis> or <emphasis role="italic">initDialog</emphasis> methods are all a suitable
  place for the line. The <emphasis role="italic">methodName</emphasis> argument is the name of your event handling
  method and can be any appropriate method name.
</para>

<programlisting>
<![CDATA[
self~connectResize(methodName)
]]>
</programlisting>

<para>
  Your <emphasis role="italic">defineDialog</emphasis> method must start with these lines:
</para>
<programlisting>
<![CDATA[
expose u
u = .dlgAreaU~new(self)
]]>
</programlisting>
<para>
  Your <emphasis role="italic">defineDialog</emphasis> method must not reference variables within the <link
  linkend="sctCreateMethods">create</link> control method parameters. Although you can use references to <link
  linkend="clsDlgArea">DlgArea</link> attributes, so
</para>
<programlisting>
<![CDATA[
  self~createPushButton(IDC_PB, 5, 100, 45, 15, , "MyButton", "Pressed")
  self~createPushButton(IDC_PB_1, b~x, b~y("10%"), b~w, b~h("9%"), , "Button" 1, "Button"||1)
]]>
</programlisting>
  <para>
    work fine, whereas
  </para>
<programlisting>
<![CDATA[
/* Seven buttons evenly spaced at 10% intervals, 9% high                     */
do i = 0 to 6
   self~createPushButton(12+i, b~x, b~y((i * 10)||"%"), b~w, b~h("9%"), , "Button" i, "Button"||i)
end /* DO */
]]>
</programlisting>
<para>
  would fail because the <emphasis role="italic">createPushButton</emphasis> method references the variable
  <computeroutput>i</computeroutput> within its parameters.
</para>
<para>
  To debug your <computeroutput>DlgAreaU</computeroutput> object call/insert the following after the instantiation:
</para>
<programlisting>
<![CDATA[
if u~lastError \= .nil then call errorDialog u~lastError
]]>
</programlisting>
<para>
  Your event handler code for the RESIZE event must pass on the second argument of the method to the
  <computeroutput>DlgAreaU</computeroutput> object's <emphasis role="italic">resize</emphasis> method.
</para>
<programlisting>
<![CDATA[
/* ------------------------------------------------------------------------- */
::method OnResize
/* ------------------------------------------------------------------------- */
  expose u
  use arg sizeEvent, sizeInfo

  u~resize(self, sizeInfo)

]]>
</programlisting>
<para>
  The <computeroutput>DlgAreaU</computeroutput> object's <emphasis role="italic">resize</emphasis> method will then
  automatically resize &amp; position the dialog controls in your dialog that were added to the dialog template with the
  following methods. The resizing takes place when the dialog frame is dragged, or the minimize, maximize, or restore
  buttons are pressed:
</para>
<table frame="all">
<title>DlgAreaU Automatic Resize Controls</title>
<tgroup cols="4" align="left" colsep="1" rowsep="1">
<tbody>
<row>
  <entry>createBitmapbutton</entry>
  <entry>createBlackframe</entry>
  <entry>createBlackrect</entry>
  <entry>createCheckbox</entry>
</row>
<row>
  <entry>createCombobox</entry>
  <entry>createEdit</entry>
  <entry>createDatetimePicker</entry>
  <entry>createEdit</entry>
</row>
<row>
  <entry>createEtchedHorizontal</entry>
  <entry>createEtchedVertical</entry>
  <entry>createGrayFrame</entry>
  <entry>createGrayRect</entry>
</row>
<row>
  <entry>createGroupBox</entry>
  <entry>createListBox</entry>
  <entry>createListView</entry>
  <entry>createMonthCalendar</entry>
</row>
<row>
  <entry>createPasswordEdit</entry>
  <entry>createProgressBar</entry>
  <entry>createPushButton</entry>
  <entry>createRadioButton</entry>
</row>
<row>
  <entry>createScrollBar</entry>
  <entry>createStatic</entry>
  <entry>createStaticFrame</entry>
  <entry>createStaticImage</entry>
</row>
<row>
  <entry>createStaticText</entry>
  <entry>createTab</entry>
  <entry>createTrackBar</entry>
  <entry>createTreeView</entry>
</row>
<row>
  <entry>createUpDown</entry>
  <entry>createWhiteFrame</entry>
  <entry>createWhiteRect</entry>
  <entry></entry>
</row>
</tbody>
</tgroup>
</table>
<para>
  The following <link linkend="sctCreateMethods">methods</link> can be used to define dialog controls in a <link
  linkend="clsUserDialog">UserDialog</link>, but cannot be handled by the <computeroutput>DlgAreaU</computeroutput>
  <link linkend="mthResizeClsDlgAreaU">resize</link> method. If you use any of these methods, the dialog controls will
  not be automatically resized and positioned.
</para>
<table frame="all">
<title>DlgAreaU Non-Automatic Resize Controls</title>
<tgroup cols="4" align="left" colsep="1" rowsep="1">
<tbody>
<row>
  <entry>createCheckBoxGroup</entry>
  <entry>createCheckBoxStem</entry>
  <entry>createComboBoxInput</entry>
  <entry>createEditInput</entry>
</row>
<row>
  <entry>createEditInputGroup</entry>
  <entry>createEditInputStem</entry>
  <entry>createOkCancelLeftBottom</entry>
  <entry>createOkCancelLeftTop</entry>
</row>
<row>
  <entry>createOkCancelRightBottom</entry>
  <entry>createOkCancelRightTop</entry>
  <entry>createPushButtonGroup</entry>
  <entry>createRadioButtonGroup</entry>
</row>
<row>
  <entry>createRadioButtonStem</entry>
  <entry></entry>
  <entry></entry>
  <entry></entry>
</row>
</tbody>
</tgroup>
</table>
<para>
  All of these dialog controls can be added to the dialog template by using combinations of the methods recognized in
  the <emphasis role="italic">resize</emphasis> method.
</para>
</section>

<section id="sctDlgAreaUProblems"><title>Possible Problems</title>
<para>
  The <computeroutput>DlgAreaU</computeroutput> <link linkend="mthResizeClsDlgAreaU">resize</link> method can create slightly
  over-size margins on the left &amp; bottom of the Dialog.  To correct for this the DlgAreaU class has a <link
  linkend="atrCorrectionFactor">correctionFactor </link> attribute set by default to 1.05. In tests, this correction
  factor appears to neutralise the effect. If your dialogs have over (or under) sized margins, you may be able to
  correct this in your code by adjusting the <emphasis role="italic">correctionFactor</emphasis> attribute. For example:
</para>
<programlisting>
<![CDATA[
u = .DlgAreaU~new(self)
u~correctionFactor=1.07
]]>
</programlisting>
<para>
  You will have to experiment to find the appropriate setting for this attribute.
</para>
<para>
  This problem occurs because of the use of the <link linkend="ovvInaccurate">inaccurate</link> <emphasis
  role="italic">factorX</emphasis> and <emphasis role="italic">factorY</emphasis> attributes to convert pixels to dialog
  units. Fixing the problem, at this point, would most likely break existing programs.
</para>
</section>

<section id="sctDlgAreaUSample"><title>Sample Code</title>
<programlisting>
<![CDATA[
/* DlgAreaDemo.Rex  --  Demonstrate DlgArea & DlgAreaU Classes  --  Feb 2006 */

dlg = .MyDialog~new
if dlg~initCode == 0 then dlg~execute("ShowTop")

return dlg~initCode

::requires "ooDialog.cls"
/* ========================================================================= */
::class 'MyDialog' subclass UserDialog
/* ========================================================================= */
::method init
/* ------------------------------------------------------------------------- */
  self~init:super
  if \ self~createCenter(250, 250, "MyDialog", "ThickFrame", , "Tahoma", 8) then do
    self~initCode = 1
    return
  end

  self~connectResize("onResize")

/* ------------------------------------------------------------------------- */
::method defineDialog
/* ------------------------------------------------------------------------- */
expose u

u = .dlgAreaU~new(self)                                       /* whole dlg   */
if u~lastError \= .nil then call errorDialog u~lastError
e = .dlgArea~new(u~x       ,u~y       ,u~w("70%"),u~h("90%")) /* edit   area */
s = .dlgArea~new(u~x       ,u~y("90%"),u~w("70%"),u~hr      ) /* status area */
b = .dlgArea~new(u~x("70%"),u~y       ,u~wr      ,u~hr      ) /* button area */

self~createEdit(IDC_EDIT, e~x, e~y, e~w, e~h, "multiline", "text")
self~createStaticText(IDC_ST_STATUS, s~x, s~y, s~w, s~h, , "Status info appears here")

self~createPushButton(IDC_PB_0, b~x, b~y('00%'), b~w, b~h('9%'), ,'Button' 0, 'Button'||0)
self~createPushButton(IDC_PB_1, b~x, b~y('10%'), b~w, b~h('9%'), ,'Button' 1, 'Button'||1)
self~createPushButton(IDC_PB_2, b~x, b~y('20%'), b~w, b~h('9%'), ,'Button' 2, 'Button'||2)
self~createPushButton(IDC_PB_3, b~x, b~y('30%'), b~w, b~h('9%'), ,'Button' 3, 'Button'||3)
self~createPushButton(IDC_PB_4, b~x, b~y('40%'), b~w, b~h('9%'), ,'Button' 4, 'Button'||4)
self~createPushButton(IDC_PB_5, b~x, b~y('50%'), b~w, b~h('9%'), ,'Button' 5, 'Button'||5)
self~createPushButton(IDC_PB_6, b~x, b~y('60%'), b~w, b~h('9%'), ,'Button' 6, 'Button'||6)
self~createPushButton(IDOK,     b~x, b~y('90%'), b~w, b~h('9%'),'DEFAULT', 'Ok')


/* ------------------------------------------------------------------------- */
::method unknown
/* ------------------------------------------------------------------------- */
use arg msgname, args
if msgname~abbrev("BUTTON") then
   self~newStatic(IDC_ST_STATUS)~setText('You Pressed Button' msgname~right(1))

/* ------------------------------------------------------------------------- */
::method onResize
/* ------------------------------------------------------------------------- */
expose u
use arg sizeEvent, sizeinfo
u~resize(self, sizeinfo)

]]>
</programlisting>
<para>
  This achieves the same dialog as the previous <link linkend="exampleDlgArea"> DlgArea example</link>, but now it is
  resizable by dragging the frame.
</para>
</section>
</section>

</chapter>
