<!--#########################################################################
    #
    # Description: Open Object Rexx: OODialog Reference SGML file.
    #
    # Copyright (c) 2005-2009, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<chapter id="clsBaseDialog"><title>BaseDialog Class</title>
<indexterm><primary>BaseDialog class</primary></indexterm>
<para>The BaseDialog class implements base methods for
all dialogs regardless of whether the dialog is implemented as a binary resource,
a resource script, or created dynamically. Binary (compiled) resources are
stored in a DLL. A dialog is created dynamically by using Add... methods.
Dialogs that are implemented using a resource script (.RC) are generated semi-dynamically.</para>
<para>BaseDialog is an abstract class. You cannot use it to execute a Windows dialog
but have to use one of its subclasses.</para>
<para>See the subclasses <link linkend="clsUserDialog">UserDialog Class</link>,
<link linkend="clsResDialog">ResDialog Class</link>, and
<link linkend="clsRcDialog">RcDialog Class</link> for additional information.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Requires:</emphasis></term>
<listitem><para><computeroutput>BaseDlg.cls</computeroutput> is the source file of this class.
<programlisting>
<![CDATA[
::requires oodialog.cls
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry id="tmpAttributesBaseDialog"><term><emphasis role="bold">Attributes:</emphasis></term>
<listitem><para>Instances of the BaseDialog class have the following attributes:
<variablelist>
<varlistentry><term><emphasis role="bold">AutoDetect</emphasis></term>
<listitem><para>Automatic data field detection on (=1, default) or off (=0). For the
UserDialog subclass the default is off and Connect... methods or a resource
script are usually used.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">AutomaticMethods</emphasis></term>
<listitem><para>A queue containing the methods that are started concurrently before
the execution of the dialog.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">BkgBitmap</emphasis></term>
<listitem><para>The handle to a bitmap that is displayed in the dialog's background.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">BkgBrushBmp</emphasis></term>
<listitem><para>The handle to a bitmap that is used to draw the dialog's background.
</para></listitem></varlistentry>
<varlistentry><term id="constdir"><emphasis role="bold">ConstDir</emphasis></term>
<listitem><para>A directory object whose indexes are
<link linkend="symbolicid">symbolic ID</link>s.  The entry for each index is the
numerical value of the symbolic ID.  Once a symbolic ID is added to the <computeroutput>
Constdir</computeroutput> directory, the symbolic ID can be used in place of the numeric
value in any method of the ooDialog classes that requires a resource ID.
</para><para>A few symbolic IDs are pre-defined by ooDialog and are present in
the <computeroutput>ConstDir</computeroutput> directory of all ooDialogs.  See
the table, <link linkend="oodsymbolicids">Symbolic IDs Used by ooDialog</link>,
for a list of these IDs.  The programmer can add symbolic IDs to this directory
by using <link linkend="pounddefine">#define</link> statements in a resource script
or a <link linkend="headerfile">header file</link>.  Of course, symbolic
IDs can also be added directly in the program as the following code snippet
shows:</para>

<programlisting>
<![CDATA[

::method Init
  forward class (super) continue

  self~ConstDir["ID_GB"] = 101
  self~ConstDir["ID_CB_REGINA"] = 107
  self~ConstDir["ID_CB_REGINALD"] = 111
  self~ConstDir["ID_CB_OOREXX"] = 115

...

::method defineDialog

  self~addGroupBox(10, 20, 150, 90, "Pick an interpreter", "BORDER", ID_GB)
  self~addCheckBox(ID_CB_REGINA, "cb1", 30, 40, , , "Regina", "GROUP")
  self~addCheckBox(ID_CB_REGINALD, "cb2", 30, 60, , , "Reginald")
  self~addCheckBox(ID_CB_OOREXX, "cb3", 30, 80, , , "ooRexx")

...

::method ok

  oorexxCB = self~getCheckControl(ID_CB_OOREXX)
  if oorexxCB~checked then
    say "You picked the right interpreter."

]]>
</programlisting></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">DataConnection</emphasis></term>
<listitem><para>A protected attribute to store connections between dialog items and
the attributes of the dialog instance.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">DlgHandle</emphasis></term>
<listitem><para>The handle to the dialog.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Finished</emphasis></term>
<listitem><para>When this is set to 1, Ok or Cancel will terminate the dialog on exit.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">InitCode</emphasis></term>
<listitem>
  <para>
    After the Init method has executed the InitCode attribute will be 0 if the object initialization
    detected no errors.  The attribute will be non-zero if initialization failed or an error was detected.
    The programmer should always check the InitCode attribute after instantiating a dialog object. If the
    attribute is not zero, then the object was not initialized correctly and its behavior is undefined.
  </para>
  <para>
    After the dialog is finished, the attribute will be 1 if terminated with Ok, 2 if terminated with
    Cancel.
  </para>
</listitem></varlistentry>
<varlistentry><term><emphasis role="bold">IsExtended</emphasis></term>
<listitem><para>A protected attribute that is true (=1) if the graphics extension is
installed.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">UseStem</emphasis></term>
<listitem><para>A protected attribute that is true (=1) if a stem variable was passed
to Init.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Routines:</emphasis></term>
<listitem><para>See <link linkend="sctPublicRoutines">Public Routines</link> for a description of the audio Play routine.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Cross Reference:</emphasis></term>
<listitem>
<para>
  The following table cross references the descriptions for the BaseDialog class methods, attributes, and
  instance methods:
<table id="t000013" frame="all">
<title>BaseDialog Reference</title>
<tgroup cols="2">
<thead>
<row>
<entry>Item...</entry>
<entry>...description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center"><emphasis role="bold">Class Method</emphasis></entry>
<entry align="center"><emphasis role="bold">Link</emphasis></entry>
</row>
<row>
<entry>getFontName (Class method)</entry>
<entry><link linkend="mthClsGetFontName">getFontName</link></entry>
</row>
<row>
<entry>getFontSize (Class method)</entry>
<entry><link linkend="mthClsGetFontSize">getFontSize</link></entry>
</row>
<row>
<entry>setDefaultFont (Class method)</entry>
<entry><link linkend="mthClsSetDefaultFont">setDefaultFont</link></entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Attributes</emphasis></entry>
<entry align="center"><emphasis role="bold">Link</emphasis></entry>
</row>
<row>
<entry>fontName (Attribute)</entry>
<entry><link linkend="atrFontName">fontName</link></entry>
</row>
<row>
<entry>fontSize (Attribute)</entry>
<entry><link linkend="atrFontSize">fontSize</link></entry>
</row>
<row>
<entry align="center"><emphasis role="bold">Instance Methods</emphasis></entry>
<entry align="center"><emphasis role="bold">Link</emphasis></entry>
</row>
<row>
<entry>AbsRect2LogRect</entry>
<entry><link linkend="absrect2logrect">AbsRect2LogRect</link></entry>
</row>
<row>
<entry>AddAttribute</entry>
<entry><link linkend="h000274">AddAttribute</link></entry>
</row>
<row>
<entry>AddAutoStartMethod</entry>
<entry><link linkend="h001383">AddAutoStartMethod</link></entry>
</row>
<row>
<entry>AddComboEntry</entry>
<entry><link linkend="h000307">AddComboEntry</link></entry>
</row>
<row>
<entry>AddListEntry</entry>
<entry><link linkend="h000380">AddListEntry</link></entry>
</row>
<row>
<entry>addUserMsg</entry>
<entry><link linkend="mthAddUserMsg">addUserMsg</link></entry>
</row>
<row>
<entry>AssignWindow</entry>
<entry><link linkend="assignwindow">AssignWindow</link></entry>
</row>
<row>
<entry>AsyncMessageHandling</entry>
<entry><link linkend="h000746">AsyncMessageHandling</link></entry>
</row>
<row>
<entry>AutoDetection</entry>
<entry><link linkend="h001439">AutoDetection</link></entry>
</row>
<row>
<entry>BackgroundBitmap</entry>
<entry><link linkend="h001053">BackgroundBitmap</link></entry>
</row>
<row>
<entry>BackgroundColor</entry>
<entry><link linkend="background">BackgroundColor</link></entry>
</row>
<row>
<entry>Cancel</entry>
<entry><link linkend="h001450">Cancel</link></entry>
</row>
<row>
<entry>CaptureMouse</entry>
<entry><link linkend="capturemouse">CaptureMouse</link></entry>
</row>
<row>
<entry>Center</entry>
<entry><link linkend="h001370">Center</link></entry>
</row>
<row>
<entry>ChangeBitmapButton</entry>
<entry><link linkend="h000170">ChangeBitmapButton</link></entry>
</row>
<row>
<entry>ChangeComboEntry</entry>
<entry><link linkend="h000352">ChangeComboEntry</link></entry>
</row>
<row>
<entry>ChangeListEntry</entry>
<entry><link linkend="h000425">ChangeListEntry</link></entry>
</row>
<row>
<entry>CheckMenuItem</entry>
<entry><link linkend="chmim">CheckMenuItem</link></entry>
</row>
<row>
<entry>Clear</entry>
<entry><link linkend="clear">Clear</link></entry>
</row>
<row>
<entry>ClearButtonRect</entry>
<entry><link linkend="h000622">ClearButtonRect</link></entry>
</row>
<row>
<entry>ClearMessages</entry>
<entry><link linkend="h000763">ClearMessages</link></entry>
</row>
<row>
<entry>ClearRect</entry>
<entry><link linkend="h000640">ClearRect</link></entry>
</row>
<row>
<entry>ClearWindowRect</entry>
<entry><link linkend="h000631">ClearWindowRect</link></entry>
</row>
<row>
<entry>ClientToScreen</entry>
<entry><link linkend="clienttoscreen">ClientToScreen</link></entry>
</row>
<row>
<entry>CombineELwithSB</entry>
<entry><link linkend="h000816">CombineELwithSB</link></entry>
</row>
<row>
<entry>ComboAddDirectory</entry>
<entry><link linkend="h000362">ComboAddDirectory</link></entry>
</row>
<row>
<entry>ComboDrop</entry>
<entry><link linkend="h000372">ComboDrop</link></entry>
</row>
<row>
<entry>ConnectAllSBEvents</entry>
<entry><link linkend="allsbe">ConnectAllSBEvents</link></entry>
</row>
<row>
<entry>ConnectAnimatedButton</entry>
<entry><link linkend="h001393">ConnectAnimatedButton</link></entry>
</row>
<row>
<entry>ConnectBitmapButton</entry>
<entry><link linkend="mthConnectBitmapButton">ConnectBitmapButton</link></entry>
</row>
<row>
<entry>ConnectButton</entry>
<entry><link linkend="mthConnectButton">ConnectButton</link></entry>
</row>
<row>
<entry>ConnectCheckBox</entry>
<entry><link linkend="mthConnectCheckBox">ConnectCheckBox</link></entry>
</row>
<row>
<entry>connectComboBox</entry>
<entry><link linkend="mthConnectComboBox">connectComboBox</link></entry>
</row>
<row>
<entry>ConnectControl</entry>
<entry><link linkend="h000123">ConnectControl</link></entry>
</row>
<row>
<entry>ConnectDraw</entry>
<entry><link linkend="h111111">ConnectDraw</link></entry>
</row>
<row>
<entry>ConnectEntryLine</entry>
<entry><link linkend="mthConnectEntryLine">ConnectEntryLine</link></entry>
</row>
<row>
<entry>ConnectFKeyPress</entry>
<entry><link linkend="mthConnectFKeyPressBaseDialog">ConnectFKeyPress</link></entry>
</row>
<row>
<entry>ConnectHelp</entry>
<entry><link linkend="mthConnectHelp">ConnectHelp</link></entry>
</row>
<row>
<entry>ConnectKeyPress</entry>
<entry><link linkend="mthConnectKeyPressBaseDialog">ConnectKeyPress</link></entry>
</row>
<row>
<entry>ConnectList</entry>
<entry><link linkend="h000132">ConnectList</link></entry>
</row>
<row>
<entry>ConnectListBox</entry>
<entry><link linkend="mthConnectListBox">ConnectListBox</link></entry>
</row>
<row>
<entry>ConnectListLeftDoubleClick</entry>
<entry><link linkend="clldcm">ConnectListLeftDoubleClick</link></entry>
</row>
<row>
<entry>ConnectMenuItem</entry>
<entry><link linkend="cmim">ConnectMenuItem</link></entry>
</row>
<row>
<entry>ConnectMouseCapture</entry>
<entry><link linkend="connectmousecapture">ConnectMouseCapture</link></entry>
</row>
<row>
<entry>ConnectMove</entry>
<entry><link linkend="connectmove">ConnectMove</link></entry>
</row>
<row>
<entry>ConnectMultiListBox</entry>
<entry><link linkend="mthConnectMultiListBox">ConnectMultiListBox</link></entry>
</row>
<row>
<entry>ConnectPosChanged</entry>
<entry><link linkend="connectposchanged">ConnectPosChanged</link></entry>
</row>
<row>
<entry>ConnectRadioButton</entry>
<entry><link linkend="mthConnectRadioButton">ConnectRadioButton</link></entry>
</row>
<row>
<entry>ConnectResize</entry>
<entry><link linkend="mthConnectResize">ConnectResize</link></entry>
</row>
<row>
<entry>ConnectScrollBar</entry>
<entry><link linkend="h000802">ConnectScrollBar</link></entry>
</row>
<row>
<entry>CreateBrush</entry>
<entry><link linkend="h001026">CreateBrush</link></entry>
</row>
<row>
<entry>createFontEx</entry>
<entry><link linkend="mthCreateFontEx">createFontEx</link></entry>
</row>
<row>
<entry>CreatePen</entry>
<entry><link linkend="h001035">CreatePen</link></entry>
</row>
<row>
<entry>Cursor_AppStarting</entry>
<entry><link linkend="cursorappstarting">Cursor_AppStarting</link></entry>
</row>
<row>
<entry>Cursor_Arrow</entry>
<entry><link linkend="cursorarrow">Cursor_Arrow</link></entry>
</row>
<row>
<entry>Cursor_Cross</entry>
<entry><link linkend="cursorcross">Cursor_Cross</link></entry>
</row>
<row>
<entry>Cursor_No</entry>
<entry><link linkend="cursorno">Cursor_No</link></entry>
</row>
<row>
<entry>CursorPos</entry>
<entry><link linkend="cursorpos">CursorPos</link></entry>
</row>
<row>
<entry>Cursor_Wait</entry>
<entry><link linkend="cursorwait">Cursor_Wait</link></entry>
</row>
<row>
<entry>DeInstall</entry>
<entry><link linkend="h001468">DeInstall</link></entry>
</row>
<row>
<entry>DeleteComboEntry</entry>
<entry><link linkend="h000326">DeleteComboEntry</link></entry>
</row>
<row>
<entry>DeleteFont</entry>
<entry><link linkend="deletefont">DeleteFont</link></entry>
</row>
<row>
<entry>DeleteListEntry</entry>
<entry><link linkend="h000399">DeleteListEntry</link></entry>
</row>
<row>
<entry>DeleteObject</entry>
<entry><link linkend="h001017">DeleteObject</link></entry>
</row>
<row>
<entry>DetermineSBPosition</entry>
<entry><link linkend="detersb">DetermineSBPosition</link></entry>
</row>
<row>
<entry>Disable</entry>
<entry><link linkend="disable">Disable</link></entry>
</row>
<row>
<entry>DisableItem</entry>
<entry><link linkend="h001229">DisableItem</link></entry>
</row>
<row>
<entry>DisableMenuItem</entry>
<entry><link linkend="dmim">DisableMenuItem</link></entry>
</row>
<row>
<entry>DisconnectKeyPress</entry>
<entry><link linkend="mthDisconnectKeyPressBaseDialog">DisconnectKeyPress</link></entry>
</row>
<row>
<entry>DisplaceBitmap</entry>
<entry><link linkend="h000726">DisplaceBitmap</link></entry>
</row>
<row>
<entry>Display</entry>
<entry><link linkend="display">Display</link></entry>
</row>
<row>
<entry>Draw</entry>
<entry><link linkend="draw">Draw</link></entry>
</row>
<row>
<entry>DrawAngleArc</entry>
<entry><link linkend="h001215">DrawAngleArc</link></entry>
</row>
<row>
<entry>DrawArc</entry>
<entry><link linkend="h001212">DrawArc</link></entry>
</row>
<row>
<entry>DrawBitmap</entry>
<entry><link linkend="h001143">DrawBitmap</link></entry>
</row>
<row>
<entry>DrawButton</entry>
<entry><link linkend="h000606">DrawButton</link></entry>
</row>
<row>
<entry>DrawLine</entry>
<entry><link linkend="h001188">DrawLine</link></entry>
</row>
<row>
<entry>DrawPie</entry>
<entry><link linkend="h001216">DrawPie</link></entry>
</row>
<row>
<entry>DrawPixel</entry>
<entry><link linkend="h001200">DrawPixel</link></entry>
</row>
<row>
<entry>Dump</entry>
<entry><link linkend="dumpdialog">Dump</link></entry>
</row>
<row>
<entry>Enable</entry>
<entry><link linkend="enable">Enable</link></entry>
</row>
<row>
<entry>EnableMenuItem</entry>
<entry><link linkend="emim">EnableMenuItem</link></entry>
</row>
<row>
<entry>EnableItem</entry>
<entry><link linkend="h001221">EnableItem</link></entry>
</row>
<row>
<entry>EndAsyncExecution</entry>
<entry><link linkend="h000068">EndAsyncExecution</link></entry>
</row>
<row>
<entry>EnsureVisible</entry>
<entry><link linkend="mthEnsureVisible">EnsureVisible</link></entry>
</row>
<row>
<entry>Execute</entry>
<entry><link linkend="h000048">Execute</link></entry>
</row>
<row>
<entry>ExecuteAsync</entry>
<entry><link linkend="h000057">ExecuteAsync</link></entry>
</row>
<row>
<entry>FillDrawing</entry>
<entry><link linkend="h001217">FillDrawing</link></entry>
</row>
<row>
<entry>FindComboEntry</entry>
<entry><link linkend="h000335">FindComboEntry</link></entry>
</row>
<row>
<entry>FindListEntry</entry>
<entry><link linkend="h000408">FindListEntry</link></entry>
</row>
<row>
<entry>FocusItem</entry>
<entry><link linkend="focusitem">FocusItem</link></entry>
</row>
<row>
<entry>FontColor</entry>
<entry><link linkend="h000997">FontColor</link></entry>
</row>
<row>
<entry>FontToDC</entry>
<entry><link linkend="h000948">FontToDC</link></entry>
</row>
<row>
<entry>ForegroundWindow</entry>
<entry><link linkend="foregroundwindow">ForegroundWindow</link></entry>
</row>
<row>
<entry>FreeButtonDC</entry>
<entry><link linkend="h001105">FreeButtonDC</link></entry>
</row>
<row>
<entry>FreeDC</entry>
<entry><link linkend="freedc">FreeDC</link></entry>
</row>
<row>
<entry>FreeWindowDC</entry>
<entry><link linkend="h001086">FreeWindowDC</link></entry>
</row>
<row>
<entry>Get</entry>
<entry><link linkend="h000086">Get</link></entry>
</row>
<row>
<entry>GetArcDirection</entry>
<entry><link linkend="h001213">GetArcDirection</link></entry>
</row>
<row>
<entry>GetAttrib</entry>
<entry><link linkend="h000522">GetAttrib</link></entry>
</row>
<row>
<entry>GetBitmapSizeX</entry>
<entry><link linkend="h001127">GetBitmapSizeX</link></entry>
</row>
<row>
<entry>GetBitmapSizeY</entry>
<entry><link linkend="h001135">GetBitmapSizeY</link></entry>
</row>
<row>
<entry>GetBmpDisplacement</entry>
<entry><link linkend="h000737">GetBmpDisplacement</link></entry>
</row>
<row>
<entry>GetButtonDC</entry>
<entry><link linkend="h001077">GetButtonDC</link></entry>
</row>
<row>
<entry>GetButtonRect</entry>
<entry><link linkend="h000703">GetButtonRect</link></entry>
</row>
<row>
<entry>GetClientRect</entry>
<entry><link linkend="mthGetClientRect">GetClientRect</link></entry>
</row>
<row>
<entry>GetCheckBox</entry>
<entry><link linkend="h000490">GetCheckBox</link></entry>
</row>
<row>
<entry>GetComboEntry</entry>
<entry><link linkend="gcem">GetComboEntry</link></entry>
</row>
<row>
<entry>GetComboItems</entry>
<entry><link linkend="h000336">GetComboItems</link></entry>
</row>
<row>
<entry>GetComboLine</entry>
<entry><link linkend="h000482">GetComboLine</link></entry>
</row>
<row>
<entry>GetControlID</entry>
<entry><link linkend="mthGetControlID">GetControlID</link></entry>
</row>
<row>
<entry>GetCurrentComboIndex</entry>
<entry><link linkend="h000344">GetCurrentComboIndex</link></entry>
</row>
<row>
<entry>GetCurrentListIndex</entry>
<entry><link linkend="h000417">GetCurrentListIndex</link></entry>
</row>
<row>
<entry>GetData</entry>
<entry><link linkend="h000269">GetData</link></entry>
</row>
<row>
<entry>GetDataStem</entry>
<entry><link linkend="h000298">GetDataStem</link></entry>
</row>
<row>
<entry>GetDC</entry>
<entry><link linkend="getdc">GetDC</link></entry>
</row>
<row>
<entry>GetEntryLine</entry>
<entry><link linkend="h000466">GetEntryLine</link></entry>
</row>
<row>
<entry>getExStyleRaw</entry>
<entry><link linkend="mthGetExStyleRaw">getExStyleRaw</link></entry>
</row>
<row>
<entry>GetFocus</entry>
<entry><link linkend="getfocus">GetFocus</link></entry>
</row>
<row>
<entry>getFont</entry>
<entry><link linkend="mthGetFont">getFont</link></entry>
</row>
<row>
<entry>GetID</entry>
<entry><link linkend="getid">GetID</link></entry>
</row>
<row>
<entry>GetItem</entry>
<entry><link linkend="mthGetItem">GetItem</link></entry>
</row>
<row>
<entry>GetListEntry</entry>
<entry><link linkend="glem">GetListEntry</link></entry>
</row>
<row>
<entry>GetListItemHeight</entry>
<entry><link linkend="getlistitemheight">GetListItemHeight</link></entry>
</row>
<row>
<entry>GetListItems</entry>
<entry><link linkend="h000409">GetListItems</link></entry>
</row>
<row>
<entry>GetListLine</entry>
<entry><link linkend="h000474">GetListLine</link></entry>
</row>
<row>
<entry>GetListWidth</entry>
<entry><link linkend="getlistwidth">GetListWidth</link></entry>
</row>
<row>
<entry>GetMenuItemState</entry>
<entry><link linkend="gmism">GetMenuItemState</link></entry>
</row>
<row>
<entry>GetMouseCapture</entry>
<entry><link linkend="getmousecapture">GetMouseCapture</link></entry>
</row>
<row>
<entry>GetMultiList</entry>
<entry><link linkend="h000506">GetMultiList</link></entry>
</row>
<row>
<entry>GetPixel</entry>
<entry><link linkend="h001211">GetPixel</link></entry>
</row>
<row>
<entry>GetPos</entry>
<entry><link linkend="mthGetPos">GetPos</link></entry>
</row>
<row>
<entry>GetRadioButton</entry>
<entry><link linkend="h000498">GetRadioButton</link></entry>
</row>
<row>
<entry>GetRect</entry>
<entry><link linkend="getrect">GetRect</link></entry>
</row>
<row>
<entry>GetSBPos</entry>
<entry><link linkend="h000790">GetSBPos</link></entry>
</row>
<row>
<entry>GetSBRange</entry>
<entry><link linkend="h000782">GetSBRange</link></entry>
</row>
<row>
<entry>GetSelf</entry>
<entry><link linkend="mthGetSelf">GetSelf</link></entry>
</row>
<row>
<entry>GetSize</entry>
<entry><link linkend="getsize">GetSize</link></entry>
</row>
<row>
<entry>getStyleRaw</entry>
<entry><link linkend="mthGetStyleRaw">getStyleRaw</link></entry>
</row>
<row>
<entry>getTextSize <emphasis role="bold">(deprecated)</emphasis></entry>
<entry><link linkend="mthGetTextSize">getTextSize</link> <emphasis role="bold">(deprecated)</emphasis></entry>

</row>
<row>
<entry>getTextSizeDlg</entry>
<entry><link linkend="mthGetTextSizeDlgClsPlainBaseDialog">getTextSizeDlg</link></entry>
</row>
<row>
<entry>getTextSizeScreen</entry>
<entry><link linkend="mthGetTextSizeScreen">getTextSizeScreen</link></entry>
</row>
<row>
<entry>GetValue</entry>
<entry><link linkend="h000514">GetValue</link></entry>
</row>
<row>
<entry>GetWindowDC</entry>
<entry><link linkend="h001062">GetWindowDC</link></entry>
</row>
<row>
<entry>GetWindowRect</entry>
<entry><link linkend="h000712">GetWindowRect</link></entry>
</row>
<row>
<entry>GrayMenuItem</entry>
<entry><link linkend="gmim">GrayMenuItem</link></entry>
</row>
<row>
<entry>HandleMessages</entry>
<entry><link linkend="h000756">HandleMessages</link></entry>
</row>
<row>
<entry>HasKeyPressConnection</entry>
<entry><link linkend="mthHasKeyPressConnectionBaseDialog">HasKeyPressConnection</link></entry>
</row>
<row>
<entry>HScrollPos</entry>
<entry><link linkend="hscrollpos">HScrollPos</link></entry>
</row>
<row>
<entry>Help</entry>
<entry><link linkend="h001456">Help</link></entry>
</row>
<row>
<entry>Hide</entry>
<entry><link linkend="hide">Hide</link></entry>
</row>
<row>
<entry>HideFast</entry>
<entry><link linkend="hidefast">HideFast</link></entry>
</row>
<row>
<entry>HideItem</entry>
<entry><link linkend="mthHideItem">HideItem</link></entry>
</row>
<row>
<entry>HideItemFast</entry>
<entry><link linkend="h001285">HideItemFast</link></entry>
</row>
<row>
<entry>HideWindow</entry>
<entry><link linkend="h001253">HideWindow</link></entry>
</row>
<row>
<entry>HideWindowFast</entry>
<entry><link linkend="h001261">HideWindowFast</link></entry>
</row>
<row>
<entry>Init</entry>
<entry><link linkend="h000025">Init</link></entry>
</row>
<row>
<entry>InitAutoDetection</entry>
<entry><link linkend="mthInitAutoDetection">InitAutoDetection</link></entry>
</row>
<row>
<entry>InitDialog</entry>
<entry><link linkend="mthInitDialog">InitDialog</link></entry>
</row>
<row>
<entry>IsMouseButtonDown</entry>
<entry><link linkend="ismousebuttondown">IsMouseButtonDown</link></entry>
</row>
<row>
<entry>Leaving</entry>
<entry><link linkend="leavi">Leaving</link></entry>
</row>
<row>
<entry>InsertComboEntry</entry>
<entry><link linkend="h000316">InsertComboEntry</link></entry>
</row>
<row>
<entry>InsertListEntry</entry>
<entry><link linkend="h000389">InsertListEntry</link></entry>
</row>
<row>
<entry>IsDialogActive</entry>
<entry><link linkend="h000721">IsDialogActive</link></entry>
</row>
<row>
<entry>isEnabled</entry>
<entry><link linkend="mthIsEnabled">isEnabled</link></entry>
</row>
<row>
<entry>IsMaximized</entry>
<entry><link linkend="mthIsMaximized">IsMaximized</link></entry>
</row>
<row>
<entry>IsMinimized</entry>
<entry><link linkend="mthIsMinimized">IsMinimized</link></entry>
</row>
<row>
<entry>isVisible</entry>
<entry><link linkend="mthIsVisible">isVisible</link></entry>
</row>
<row>
<entry>ItemTitle</entry>
<entry><link linkend="h001348">ItemTitle</link></entry>
</row>
<row>
<entry>ListAddDirectory</entry>
<entry><link linkend="h000448">ListAddDirectory</link></entry>
</row>
<row>
<entry>ListDrop</entry>
<entry><link linkend="h000458">ListDrop</link></entry>
</row>
<row>
<entry>LoadBitmap</entry>
<entry><link linkend="h000667">LoadBitmap</link></entry>
</row>
<row>
<entry>LogRect2AbsRect</entry>
<entry><link linkend="logrect2absrect">LogRect2AbsRect</link></entry>
</row>
<row>
<entry>Maximize</entry>
<entry><link linkend="mthMaximize">Maximize</link></entry>
</row>
<row>
<entry>Minimize</entry>
<entry><link linkend="mthMinimize">Minimize</link></entry>
</row>
<row>
<entry>Move</entry>
<entry><link linkend="move">Move</link></entry>
</row>
<row>
<entry>MoveItem</entry>
<entry><link linkend="h001322">MoveItem</link></entry>
</row>
<row>
<entry>NoAutoDetection</entry>
<entry><link linkend="mthNoAutoDetection">NoAutoDetection</link></entry>
</row>
<row>
<entry>ObjectToDC</entry>
<entry><link linkend="h000928">ObjectToDC</link></entry>
</row>
<row>
<entry>OK</entry>
<entry><link linkend="h001444">OK</link></entry>
</row>
<row>
<entry>OpaqueText</entry>
<entry><link linkend="h000842">OpaqueText</link></entry>
</row>
<row>
<entry>PeekDialogMessage</entry>
<entry><link linkend="peekdialogmessage">PeekDialogMessage</link></entry>
</row>
<row>
<entry>Popup</entry>
<entry><link linkend="popup">Popup</link></entry>
</row>
<row>
<entry>PopupAsChild</entry>
<entry><link linkend="mthPopupAsChild">PopupAsChild</link></entry>
</row>
<row>
<entry>Rectangle</entry>
<entry><link linkend="h001115">Rectangle</link></entry>
</row>
<row>
<entry>Redraw</entry>
<entry><link linkend="redraw">Redraw</link></entry>
</row>
<row>
<entry>RedrawClient</entry>
<entry><link linkend="redrawclient">RedrawClient</link></entry>
</row>
<row>
<entry>RedrawButton</entry>
<entry><link linkend="h000684">RedrawButton</link></entry>
</row>
<row>
<entry>RedrawRect</entry>
<entry><link linkend="h000653">RedrawRect</link></entry>
</row>
<row>
<entry>RedrawWindow</entry>
<entry><link linkend="redrawwindow">RedrawWindow</link></entry>
</row>
<row>
<entry>RedrawWindowRect</entry>
<entry><link linkend="h000693">RedrawWindowRect</link></entry>
</row>
<row>
<entry>ReleaseMouseCapture</entry>
<entry><link linkend="releasemousecapture">ReleaseMouseCapture</link></entry>
</row>
<row>
<entry>RemoveBitmap</entry>
<entry><link linkend="h000676">RemoveBitmap</link></entry>
</row>
<row>
<entry>Resize</entry>
<entry><link linkend="resize">Resize</link></entry>
</row>
<row>
<entry>ResizeItem</entry>
<entry><link linkend="h001301">ResizeItem</link></entry>
</row>
<row>
<entry>Restore</entry>
<entry><link linkend="mthRestore">Restore</link></entry>
</row>
<row>
<entry>RestoreCursorShape</entry>
<entry><link linkend="restorecursorshape">RestoreCursorShape</link></entry>
</row>
<row>
<entry>Run</entry>
<entry><link linkend="h000041">Run</link></entry>
</row>
<row>
<entry>ScreenToClient</entry>
<entry><link linkend="screentoclient">ScreenToClient</link></entry>
</row>
<row>
<entry>Scroll</entry>
<entry><link linkend="scroll">Scroll</link></entry>
</row>
<row>
<entry>ScrollBitmapFromTo</entry>
<entry><link linkend="h001172">ScrollBitmapFromTo</link></entry>
</row>
<row>
<entry>ScrollButton</entry>
<entry><link linkend="h000913">ScrollButton</link></entry>
</row>
<row>
<entry>ScrollInButton</entry>
<entry><link linkend="h000896">ScrollInButton</link></entry>
</row>
<row>
<entry>ScrollText</entry>
<entry><link linkend="h000879">ScrollText</link></entry>
</row>
<row>
<entry>SendMessageToItem</entry>
<entry><link linkend="h000614">SendMessageToItem</link></entry>
</row>
<row>
<entry>SetArcDirection</entry>
<entry><link linkend="h001214">SetArcDirection</link></entry>
</row>
<row>
<entry>SetAttrib</entry>
<entry><link linkend="h000593">SetAttrib</link></entry>
</row>
<row>
<entry>SetCheckBox</entry>
<entry><link linkend="h000557">SetCheckBox</link></entry>
</row>
<row>
<entry>SetComboLine</entry>
<entry><link linkend="h000548">SetComboLine</link></entry>
</row>
<row>
<entry>SetCursorPos</entry>
<entry><link linkend="setcursorpos">SetCursorPos</link></entry>
</row>
<row>
<entry>SetCurrentComboIndex</entry>
<entry><link linkend="h000345">SetCurrentComboIndex</link></entry>
</row>
<row>
<entry>SetCurrentListIndex</entry>
<entry><link linkend="h000418">SetCurrentListIndex</link></entry>
</row>
<row>
<entry>SetData</entry>
<entry><link linkend="h000264">SetData</link></entry>
</row>
<row>
<entry>SetDataStem</entry>
<entry><link linkend="h000289">SetDataStem</link></entry>
</row>
<row>
<entry>SetEntryLine</entry>
<entry><link linkend="h000530">SetEntryLine</link></entry>
</row>
<row>
<entry>SetFocus</entry>
<entry><link linkend="setfocus">SetFocus</link></entry>
</row>
<row>
<entry>SetFocusToWindow</entry>
<entry><link linkend="setfocustowindow">SetFocusToWindow</link></entry>
</row>
<row>
<entry>setFont</entry>
<entry><link linkend="mthSetFont">SetFont</link></entry>
</row>
<row>
<entry>SetForegroundWindow</entry>
<entry><link linkend="setforegroundwindow">SetForegroundWindow</link></entry>
</row>
<row>
<entry>SetGroup</entry>
<entry><link linkend="mthSetGroup">SetGroup</link></entry>
</row>
<row>
<entry>SetHScrollPos</entry>
<entry><link linkend="sethscrollpos">SetHScrollPos</link></entry>
</row>
<row>
<entry>SetVScrollPos</entry>
<entry><link linkend="setvscrollpos">SetVScrollPos</link></entry>
</row>
<row>
<entry>SetItemFont</entry>
<entry><link linkend="sifm">SetItemFont</link></entry>
</row>
<row>
<entry>SetListColumnWidth</entry>
<entry><link linkend="setlistcolumnwidth">SetListColumnWidth</link></entry>
</row>
<row>
<entry>SetListItemHeight</entry>
<entry><link linkend="setlistitemheight">SetListItemHeight</link></entry>
</row>
<row>
<entry>SetListLine</entry>
<entry><link linkend="h000539">SetListLine</link></entry>
</row>
<row>
<entry>SetListWidth</entry>
<entry><link linkend="setlistwidth">SetListWidth</link></entry>
</row>
<row>
<entry>SetListTabulators</entry>
<entry><link linkend="h000435">SetListTabulators</link></entry>
</row>
<row>
<entry>SetMenuItemRadio</entry>
<entry><link linkend="smirm">SetMenuItemRadio</link></entry>
</row>
<row>
<entry>SetMultiList</entry>
<entry><link linkend="h000575">SetMultiList</link></entry>
</row>
<row>
<entry>SetRadioButton</entry>
<entry><link linkend="h000566">SetRadioButton</link></entry>
</row>
<row>
<entry>SetRect</entry>
<entry><link linkend="setrect">SetRect</link></entry>
</row>
<row>
<entry>SetSBPos</entry>
<entry><link linkend="h000791">SetSBPos</link></entry>
</row>
<row>
<entry>SetSBRange</entry>
<entry><link linkend="h000770">SetSBRange</link></entry>
</row>
<row>
<entry>SetStaticText</entry>
<entry><link linkend="h000255">SetStaticText</link></entry>
</row>
<row>
<entry>SetTabStop</entry>
<entry><link linkend="mthSetTabStop">SetTabStop</link></entry>
</row>
<row>
<entry>SetTitle</entry>
<entry><link linkend="settitle">SetTitle</link></entry>
</row>
<row>
<entry>SetValue</entry>
<entry><link linkend="h000584">SetValue</link></entry>
</row>
<row>
<entry>SetWindowRect</entry>
<entry><link linkend="mthSetWindowRect">SetWindowRect</link></entry>
</row>
<row>
<entry>SetWindowTitle</entry>
<entry><link linkend="h000246">SetWindowTitle</link></entry>
</row>
<row>
<entry>Show</entry>
<entry><link linkend="show">Show</link></entry>
</row>
<row>
<entry>ShowFast</entry>
<entry><link linkend="showfast">ShowFast</link></entry>
</row>
<row>
<entry>ShowItem</entry>
<entry><link linkend="mthShowItem">ShowItem</link></entry>
</row>
<row>
<entry>ShowItemFast</entry>
<entry><link linkend="h001293">ShowItemFast</link></entry>
</row>
<row>
<entry>ShowWindow</entry>
<entry><link linkend="h001269">ShowWindow</link></entry>
</row>
<row>
<entry>ShowWindowFast</entry>
<entry><link linkend="h001277">ShowWindowFast</link></entry>
</row>
<row>
<entry>StopIt</entry>
<entry><link linkend="h000073">StopIt</link></entry>
</row>
<row>
<entry>TabToNext</entry>
<entry><link linkend="tabtonext">TabToNext</link></entry>
</row>
<row>
<entry>TabToPrevious</entry>
<entry><link linkend="tabtoprevious">TabToPrevious</link></entry>
</row>
<row>
<entry>TiledBackgroundBitmap</entry>
<entry><link linkend="h001045">TiledBackgroundBitmap</link></entry>
</row>
<row>
<entry>Title</entry>
<entry><link linkend="title">Title</link></entry>
</row>
<row>
<entry>Title=</entry>
<entry><link linkend="mthTitleEquals">Title=</link></entry>
</row>
<row>
<entry>TransparentText</entry>
<entry><link linkend="h000841">TransparentText</link></entry>
</row>
<row>
<entry>ToTheTop</entry>
<entry><link linkend="h000109">ToTheTop</link></entry>
</row>
<row>
<entry>UncheckMenuItem</entry>
<entry><link linkend="uchmim">UncheckMenuItem</link></entry>
</row>
<row>
<entry>Update</entry>
<entry><link linkend="update">Update</link></entry>
</row>
<row>
<entry>Validate</entry>
<entry><link linkend="h001462">Validate</link></entry>
</row>
<row>
<entry>VScrollPos</entry>
<entry><link linkend="vscrollpos">VScrollPos</link></entry>
</row>
<row>
<entry>Write</entry>
<entry><link linkend="h000866">Write</link></entry>
</row>
<row>
<entry>WriteDirect</entry>
<entry><link linkend="h000840">WriteDirect</link></entry>
</row>
<row>
<entry>WriteToButton</entry>
<entry><link linkend="h000852">WriteToButton</link></entry>
</row>
<row>
<entry>WriteToWindow</entry>
<entry><link linkend="h000826">WriteToWindow</link></entry>
</row>
</tbody></tgroup>
</table>
</para></listitem></varlistentry>
</variablelist>


<section id="clsMthsBaseDialog"><title>Class Methods</title>
<indexterm><primary>class methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<para>
  The class methods listed here are class methods of the <link
  linkend="paraPlainBaseDialog">PlainBaseDialog</link> class.
</para>

<section id="mthClsSetDefaultFont"><title>setDefaultFont (Class method)</title>
<indexterm><primary>setDefaultFont</primary>
<secondary>PlainBaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--setDefaultFont(--fontName--,--fontSize--)----------------------------------><

]]>
</programlisting>

<para>
  This method changes the default dialog font used for all dialogs. The default dialog font is used
  whenever a dialog template, used in a dynamically defined dialog, does not specify a font.  Since it is
  very unusual for a resource script to not specify a font, this mostly effects the <link
  linkend="clsPlainUserDialog">PlainUserDialog</link> and <link linkend="clsUserDialog">UserDialog</link>
  classes. Binary compiled dialog templates (<link linkend="clsResDialog">ResDialog</link>) can not be
  changed, so the default dialog font has no meaning for a ResDialog.
</para>
<para>
  Currently the default font is <computeroutput>MS Shell Dlg</computeroutput> with a size of
  <computeroutput>8</computeroutput>.  MS Shell Dlg is not a true font name, but rather a pseudo name
  that signals the operating system to use a standard font for the specific version of Windows.  In other
  words, on Windows 2000, MS Shell Dlg will cause the operating system to use the standard font for
  dialogs on Windows 2000.  On XP, the operating system will use the standard XP dialog font.  (The two
  fonts are different.)  By using this font for the default, ooDialog produces dialogs that match what is
  most common on the current operating system.
</para>
<para>
  Of course, when the ooDialog programmer specifies a font in either the <link
  linkend="mthCreate">create</link>() or the <link linkend="mthCreateCenter">createCenter</link>()
  methods then the defualt font is ignored. Once the default font is changed in a process then all
  dynamic dialogs, that don't specify a font, that are created afterwards will use the new default font.
</para>
<para>
  The actual font used by a dialog directly effects the value of a <link linkend="defDialogUnit">dialog
  unit</link>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
    <para>The arguments are:
    <variablelist>
      <varlistentry><term>fontName</term>
      <listitem>
        <para>
          The family name to use for the default font, for example
          <computeroutput>Tahoma</computeroutput>.
        </para>
      </listitem></varlistentry>
      <varlistentry><term>fontSize</term>
      <listitem>
        <para>
          The size of the font, for example, <computeroutput>10</computeroutput>.
        </para>
      </listitem></varlistentry>
    </variablelist>
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
    <para>
      This method does not return a value.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
    <para>
      This example shows a change to the oostddlg.rex sample program.  The default font is changed to
      Tahoma pt 10.  This causes all the <link linkend="sectStandardDialogs">Standard Dialogs</link> to
      be created using this font.
      <programlisting>
      <![CDATA[

      /*--------------------------------------------------------------------------*/
      /*                                                                          */
      /* OODialog\Samples\oostddlg.rex   Standard Dialog demonstration            */
      /*                                                                          */
      /*--------------------------------------------------------------------------*/

      .PlainBaseDialog~setDefaultFont("Tahoma", 10)
      say
      say 'Starting standard dialog demonstration...'

      ...
      ]]>
      </programlisting>
    </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::setDefaultFont() [class method?] -->


<section id="mthClsGetFontName"><title>getFontName (Class method)</title>
<indexterm><primary>getFontName</primary>
<secondary>PlainBaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getFontName----------------------------------------------------><

]]>
</programlisting>
<para>
  Returns the current default dialog font name. The default dialog font is used whenever a dialog
  template, used in a dynamically defined dialog, does not specify a font.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
    <para>
      There are no arguments.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
    <para>
      This method returns the current default font family name. For instance, MS Shell Dlg.
    </para>
  </listitem></varlistentry>
  <varlistentry id="exampleGetFontNameCls"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
    <para>
      The following example temporarily changes the default font to run the accounting program. The
      accounting program uses a large number of dynamically defined dialogs. It does not specify the
      dialog font for any of the dialogs. Before starting the program, the default font is changed to 10
      pt Tahoma. Then, all the dialogs created while the accounting program is executing will be created
      using 10 pt Tahoma.  When the accounting program is done, the old default is restored.
      <programlisting>
      <![CDATA[
      oldName = .PlainBaseDialog~getFontName
      oldSize = .PlainBaseDialog~getFontSize
      .PlainBaseDialog~setDefaultFont("Tahoma", 10)

      ret = excuteAccounting("Daily")

      .PlainBaseDialog~setDefaultFont(oldName, oldSize)
      ]]>
      </programlisting>
    </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::getFontName() [class method] -->

<section id="mthClsGetFontSize"><title>getFontSize (Class method)</title>
<indexterm><primary>getFontSize</primary>
<secondary>PlainBaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getFontSize----------------------------------------------------><

]]>
</programlisting>
<para>
  Returns the current default dialog font size. The default dialog font is used whenever a dialog
  template, used in a dynamically defined dialog, does not specify a font.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
    <para>
      There are no arguments.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
    <para>
      This method returns the current default font size. For instance, 8.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
    <para>
      See the previous <link linkend="exampleGetFontNameCls">getFontName</link>() example.
    </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::getFontName() [class method] -->

</section>

<section id="attributesBaseDialog"><title>Attributes</title>
<indexterm><primary>BaseDialog attributes</primary></indexterm>
<para>
  This section describes the important attributes of instances of the BaseDialog. (This section of
  the documentation is a work in progress.  Please see the <link
  linkend="tmpAttributesBaseDialog">attrbutes</link> list at the beginning of this chapeter for
  attributes not listed here.)
</para>


<section id="atrFontName"><title>fontName (Attribute)</title>
<indexterm><primary>fontName</primary>
<secondary>PlainBaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--fontName----------------------------------------------------><

>>--fontName=---------------------------------------------------><

]]>
</programlisting>

<para>
  Prior to the creation of the underlying Windows dialog, the font name attribute specifies the name of
  the font that will be used to create the dialog. This font is only used when the font is not specified
  in the <link linkend="mthCreate">create</link>() or the <link
  linkend="mthCreateCenter">createCenter</link>() methods. After the creation of the dialog, the
  attribute reflects the font name that was actually used to create the dialog.
</para>
<para>
  This applies to all dialogs, with this cavaet.  With a binary compiled dialog resource (<link
  linkend="clsResDialog">ResDialog</link>) the font has always been specified when the dialog template
  was compiled. Therefore the font name attribute has no effect on a ResDialog prior to the execution of
  the dialog.  However, when the ResDialog object is executed, the font name attribute is updated to
  reflect the font used by the dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
    <para>
      Getting the value of the font name attribute is public:
      <programlisting>
      <![CDATA[
      name = dlgObj~fontName
      ]]>
      </programlisting>
    </para>
    <para>
      Setting the value of the font name attribute is private:
      <programlisting>
      <![CDATA[
      dlgObj~fontName = "MS Sans Serif"
      ]]>
      </programlisting>
      will result in an error.
    </para>
    <para>
      Set the value of the font name within a method context of the dialog object:
      <programlisting>
      <![CDATA[
      ::class 'MessageBox' subclass UserDialog

      ::method init

        forward class (super) continue
        if self~initCode <> 0 then return

        self~fontName = "MS Sans Serif"
      ]]>
      </programlisting>
    </para>
    <note><title>Note</title><para>
      The font name and font size attributes are set in the super class init() method to the value of the
      <link linkend="mthClsSetDefaultFont">default</link> dialog font.  Therefore, to have any effect,
      setting the font name attribute has to be done after the super class init() is finished.
    </para></note>
  </listitem></varlistentry>
  <varlistentry id="exampleFontName"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
    <para>
      This example is a portion of the code used to to create a message box dialog using a variable font.
      The calcSizes() method is not shown, but in that method the size and position of the controls, and
      the overall size of the dialog, are calculated in relation to the size needed for the message.
      <programlisting>
      <![CDATA[
        fontName = "Tahoma"
        fontSize = 20
        message = "Drive z: is a network drive and is not accesible."
        title = "Disk Drive Error"

        dlg = .MessageBox~new( , , message, title, fontName, fontSize)
        if dlg~initCode = 0 then do
          dlg~Execute("SHOWTOP", 14)
        end

        dlg~Deinstall

      return 0
      -- End of entry point.

      ::requires "oodWin32.cls"

      ::class 'MessageBox' subclass UserDialog inherit AdvancedControls MessageExtensions

      ::method init
        expose cx cy message title fontName fontSize

        a = .array~new(2)
        if arg(1, 'E') then a[1] = arg(1)
        if arg(2, 'E') then a[2] = arg(2)

        message = arg(3)
        title = arg(4)
        if arg(5, 'E') then do
          fontName = arg(5)
          fontSize = arg(6)
        end

        forward class (super) arguments (a) continue
        if self~initCode <> 0 then return

        if arg(5, 'E') then do
          self~fontName = fontName
          self~fontSize = fontSize
        end

        self~calcSizes()
        self~createCenter(cx, cy, title)
      ]]>
      </programlisting>
    </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::fontName [attribute] -->

<section id="atrFontSize"><title>fontSize (Attribute)</title>
<indexterm><primary>fontSize</primary>
<secondary>PlainBaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--fontSize----------------------------------------------------><

>>--fontSize=---------------------------------------------------><

]]>
</programlisting>

<para>
  Prior to the creation of the underlying Windows dialog, the font size attribute specifies the size of
  the font that will be used to create the dialog. This font is only used when the font is not specified
  in the <link linkend="mthCreate">create</link>() or the <link
  linkend="mthCreateCenter">createCenter</link>() methods. After the creation of the dialog, the
  attribute reflects the font size that was actually used to create the dialog.
</para>
<para>
  This applies to all dialogs, with this cavaet.  With a binary compiled dialog resource (<link
  linkend="clsResDialog">ResDialog</link>) the font has always been specified when the dialog template
  was compiled. Therefore the font size attribute has no effect on a ResDialog prior to the execution of
  the dialog.  However, when the ResDialog object is executed, the font size attribute is updated to
  reflect the font used by the dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
    <para>
      Getting the value of the font size attribute is public:
      <programlisting>
      <![CDATA[
      size = dlgObj~fontSize
      ]]>
      </programlisting>
    </para>
    <para>
      Setting the value of the font size attribute is private:
      <programlisting>
      <![CDATA[
      dlgObj~fontSize = 8
      ]]>
      </programlisting>
      will result in an error.
    </para>
    <para>
      Set the value of the font name within a method context of the dialog object:
      <programlisting>
      <![CDATA[
      ::class 'MessageBox' subclass UserDialog

      ::method init

        forward class (super) continue
        if self~initCode <> 0 then return

        self~fontSize = 8
      ]]>
      </programlisting>
    </para>
    <note><title>Note</title><para>
      The font name and font size attributes are set in the super class init() method to the value of the
      <link linkend="mthClsSetDefaultFont">default</link> dialog font.  Therefore, to have any effect,
      setting the font size attribute has to be done after the super class init() is finished.
    </para></note>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
    <para>
      See the <link linkend="exampleFontName">fontName</link>() example, which also uses the fontSize
      attribute.
    </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::fontSize [attribute] -->

</section>

<section id="prepdialog"><title>Preparing and Running the Dialog</title>
<indexterm><primary>preparing and running dialogs</primary></indexterm>
<para>This section presents the methods used to prepare and initialize a dialog,
show it, run it, and stop it.</para>

<section id="h000025"><title>Init</title>
<programlisting>
<![CDATA[
>>-aBaseDialog~Init(--+---------+--,--id--+-------------+--+----------+--)--><
                      +-Library-+         +-,--DlgData.-+  +-,--hFile-+


]]>
</programlisting>

<para>The constructor of the class installs the necessary C functions for the Object Rexx API
manager and prepares the dialog management for a new dialog. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected. You cannot create an instance of BaseDialog.
You can only create instances of its subclasses.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>Library</term>
<listitem><para>The file name of a .DLL file. Pass an empty string if you do not use
binary resources.
</para></listitem></varlistentry>
<varlistentry><term>id</term>
<listitem><para>The resource ID, (numeric or <link linkend="symbolicid">symbolic</link>,) of
the dialog within the resource file.
</para></listitem></varlistentry>
<varlistentry><term>DlgData.</term>
<listitem><para>A stem variable (remember the period!) that contains initialization
data for the dialog. For example, if you assign the string &quot;Hello world&quot;
to <computeroutput>DlgData.103</computeroutput>, where <computeroutput>103</computeroutput>
is the ID of an entry field, it is initialized with this string. If the dialog is terminated with
OK, the data of the dialog is copied into this stem variable.
</para></listitem></varlistentry>
<varlistentry><term>hFile</term>
<listitem><para>A file, (often called a <link linkend="headerfile">header</link> file,)
defining symbolic IDs for resources.  The symbolic IDs defined within the file will be
added to the <link linkend="constdir">ConstDir</link> directory.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry id="basedialoginitexample"><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example shows how a header file, symbolic IDs, and the
data stem can be used in instantiating a new object that is a subclass of the ResDialog.
Assume <computeroutput>resources.h</computeroutput> is a file in the same directory
as the program file and contains the following:
<programlisting>
<![CDATA[
/* resources.h */
  #define IDD_BUILD_DLG           100
  #define IDC_EDITFIELD_INCLUDE   110
  #define IDC_COMBOBOX_PROJECT    120
  #define IDC_RADIO_DEBUG         130
  #define IDC_RADIO_RELEASE       131
  #define IDC_CHECKBOX_CLEAN      140
  #define IDI_DLG_ICON            514

]]>
</programlisting></para>
<para>The dialog (a fictitious build dialog) will have an entry line, a combo box,
two radio buttons, and a check box.  The <computeroutput>DlgData.</computeroutput>
stem will be used to initialize the values of the controls using the symbolic
IDs defined in the header file.
<programlisting>
<![CDATA[
/* BuildDlg.rex */
  DlgData.IDC_EDITFIELD_INCLUDE = "C:\sdk\include"
  DlgData.IDC_COMBOBOX_PROJECT = "Calculator"
  DlgData.RADIO_DEBUG = 0
  DlgData.RADIO_RELEASE = 1
  DlgData.CHECKBOX_CLEAN = 0

  dlg = .BuildDialog~new( "dlg.dll", IDD_BUILD_DLG, DlgData, "resources.h" )
  if dlg~initCode <> 0 then do
    say "Error starting dialog.  initCode:" dlg~initCode
    return dlg~initCode
  end

  dlg~execute( "NORMAL", IDI_DLG_ICON )
  ...

]]>
</programlisting></para>
<para>At this point the dialog is shown, the entry line will contain
"C:\sdk\include", the combo box will have the Calculator project selected, the
release radio button will be checked, (the debug radio button will not be
checked,) and the clean check box will not be checked.</para>
<para>The user interacts with the dialog and selects ok to close it.  Now the state of
the dialog when it was closed can be determined by checking the DlgData. stem
values.
<programlisting>
<![CDATA[
  ...
  dlg~deinstall

  if DlgData.CHECKBOX_CLEAN == 1 then doClean()

  includePath = DlgData.IDC_EDITFIELD_INCLUDE
  if DlgData.RADIO_RELEASE == 1 then
    success = doReleaseBuild(includePath)
  else
    success = doDebugBuild(includePath)

  return success

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthInitAutoDetection"><title>InitAutoDetection</title>
<indexterm><primary>InitAutoDetection</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~InitAutoDetection-------------------------------><


]]>
</programlisting>

<para>The InitAutoDetection method is called by the Init
method to change the default setting for the automatic data field detection.</para>
<para>Automatic data field detection means that for every
dialog data item a corresponding Object Rexx attribute is created automatically.
If you disable automatic detection, you have to use the Connect... methods to assign a dialog item to an Object Rexx attribute. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected. You can override this method within your subclass
to change the standard behavior.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example overrides the method to switch off auto detection:

<programlisting>
<![CDATA[
::class MyDialog subclass UserDialog
::method InitAutoDetection
   self~NoAutoDetection
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthNoAutoDetection"><title>NoAutoDetection</title>
<indexterm><primary>NoAutoDetection</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~NoAutoDetection---------------------------------><


]]>
</programlisting>

<para>The NoAutoDetection method switches off auto detection.</para>
</section>

<section id="h001439"><title>AutoDetection</title>
<indexterm><primary>AutoDetection</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~AutoDetection----------------------------------->>


]]>
</programlisting>

<para>The AutoDetection method switches on auto detection.</para>
</section>

<section id="mthInitDialog"><title>InitDialog</title>
<indexterm><primary>InitDialog</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~InitDialog--------------------------------------><


]]>
</programlisting>

<para>The InitDialog method is called after the Windows dialog
has been created. It is useful for setting data fields and initializing combo
and list boxes. Do not use Set... methods because
the <link linkend="h000264">SetData</link> method is executed automatically afterwards
and sets the values of all dialog items from the attributes. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>The method is designed to be overwritten in subclasses; it cannot be
called from outside the class.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example shows how to use InitDialog to initialize dialog
items; in this case a list box:

<programlisting>
<![CDATA[
::class MyDialog subclass Userdialog
::method InitDialog
  self~InitDialog:super
  AddListEntry(501, "this is the first line")
  AddListEntry(501, "and this one the second")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000041"><title>Run</title>
<indexterm><primary>Run</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Run---------------------------------------------><


]]>
</programlisting>

<para>The Run method dispatches messages from the Windows dialog until the user terminates the dialog by one of the following
actions: </para>
<itemizedlist>
<listitem><para>Press the OK button (the push button with ID 1)</para></listitem>
<listitem><para>Press the Cancel button (the push button with ID 2)</para></listitem>
<listitem><para>Press the Enter key (if OK or Cancel is the default button)</para></listitem>
<listitem><para>Press the Esc key</para></listitem></itemizedlist>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>Run is a protected method. You cannot call this method directly; it
is called by <link linkend="h000048">Execute</link>.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000048"><title>Execute</title>
<indexterm><primary>Execute</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
                            +-DEFAULT--+
>>-aBaseDialog~Execute(--"--+----------+--"--+---------+--)----><
                            +-NORMAL---+     +-,--icon-+
                            +-SHOWTOP--+
                            +-HIDE-----+
                            +-MIN------+
                            +-MAX------+
                            +-INACTIVE-+


]]>
</programlisting>

<para>The Execute method creates the dialog, shows it
(see <link linkend="show">Show</link>), starts automatic methods, and destroys the dialog.
The data is passed to the Windows dialog before execution and received
from it after the dialog is terminated.</para>

<note><title>Note</title><para>
If another dialog has already been started in
the same process, it is disabled by Execute.
</para></note>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>show</term>
<listitem><para>See <link linkend="show">Show</link>.
</para></listitem></varlistentry>
<varlistentry><term>icon</term>
<listitem><para>The resource ID of the <link linkend="dialogicon">dialog's
icon</link>.  If an icon ID is not supplied, the default ooDialog icon will be
used.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The dialog was not executed.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>You terminated the method using the OK button.
</para></listitem></varlistentry>
<varlistentry><term>2</term>
<listitem><para>You terminated the method using the Cancel button.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example instantiates a new dialog object (remember that
it is not possible to instantiate an object of the BaseDialog class), creates
a dialog template, and runs the dialog as the topmost window.  The
<link linkend="dialogicon">dialog icon</link> is one of the pre-defined icons
supplied by ooDialog:

<programlisting>
<![CDATA[
MyDialog = .UserDialog~new(...)
MyDialog~Create(...)
MyDialog~Execute("SHOWTOP", IDI_DLG_OOREXX)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000057"><title>ExecuteAsync</title>
<indexterm><primary>ExecuteAsync</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ExecuteAsync--+--------------+------------------->
                             +-(--sleeptime-+

>--+-----------------------------------------------+-----------><
   +-+----------------------------------------+--)-+
     +-,--+--------------------+--+---------+-+
          |    +-DEFAULT--+    |  +-,--icon-+
          +-"--+-NORMAL---+--"-+
               +-SHOWTOP--+
               +-HIDE-----+
               +-MIN------+
               +-MAX------+
               +-INACTIVE-+


]]>
</programlisting>

<para>The ExecuteAsync method does the same as Execute,
except that it dispatches messages asynchronously. Therefore the ExecuteAsync
method returns immediately after the dialog has been started. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>sleeptime</term>
<listitem><para>The time slice, in milliseconds, until the next message is processed.
</para></listitem></varlistentry>
<varlistentry><term>show</term>
<listitem><para>See <link linkend="show">Show</link>.
</para></listitem></varlistentry>
<varlistentry><term>icon</term>
<listitem><para>The resource ID of the <link linkend="dialogicon">dialog's
icon</link>.  If an icon ID is not supplied, the default ooDialog icon will be
used.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The dialog was started.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>An error occurred. Do not call the EndAsyncExecution method in this
case.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example starts a dialog and runs the statements between
ExecuteAsync and EndAsyncExecution asynchronously to the dialog:

<programlisting>
<![CDATA[
ret = MyDialog~ExecuteAsync(1000, "SHOWTOP")
if ret = 0 then do
   ...
   /* Object Rexx statements to run while the dialog is executing */
   ...
   MyDialog~EndAsyncExecution
   end
else call ErrorMessage("Could not start dialog")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000068"><title>EndAsyncExecution</title>
<indexterm><primary>EndAsyncExecution</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~EndAsyncExecution-------------------------------><


]]>
</programlisting>

<para>The EndAsyncExecution method is used to complete
the asynchronous execution of a dialog. It does not terminate the dialog but
waits until the user terminates it. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The dialog was not executed.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The dialog was terminated using the OK button.
</para></listitem></varlistentry>
<varlistentry><term>2</term>
<listitem><para>The dialog was terminated using the Cancel button.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>See the example in <link linkend="h000057">ExecuteAsync</link>.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="popup"><title>Popup</title>
<indexterm><primary>Popup</primary></indexterm>
<programlisting>
<![CDATA[
                          +-DEFAULT--+
>>-aBaseDialog~Popup(--"--+----------+--"--+-------------------------------+--)-><
                          +-NORMAL---+     +-,--+-----------+--+---------+-+
                          +-SHOWTOP--+          +-sleeptime-+  +-,--icon-+
                          +-HIDE-----+
                          +-MIN------+
                          +-MAX------+
                          +-INACTIVE-+


]]>
</programlisting>

<para>The Popup method starts a dialog, dispatches messages
asynchronously, and returns immediately after the dialog is started.</para>
<para>A dialog started with Popup is independent of any other dialog. This means
that a dialog already started in the same process is not disabled by Popup.
You can therefore use Popup to produce nonmodal dialogs.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>show</term>
<listitem><para>See <link linkend="show">Show</link>.
</para></listitem></varlistentry>
<varlistentry><term>sleeptime</term>
<listitem><para>The time, in milliseconds, until the next message is processed.
</para></listitem></varlistentry>
<varlistentry><term>icon</term>
<listitem><para>The resource ID of the <link linkend="dialogicon">dialog's
icon</link>.  If an icon ID is not supplied, the default ooDialog icon will be
used.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example starts a dialog and runs the statements after
Popup asynchronously to the dialog. This means that the dialog reacts to an
event like pressing a button and calls the connected method while the DO loop
is being processed:</para>

<programlisting>
<![CDATA[
MyDialog~Popup("SHOWTOP", 250)
do i = 1 to 1000
   say "Iteration" i
   call SleepMs 100
end
]]>
</programlisting>
<para>This example could also be part of a method handling an event
of a dialog, for example dialog A. The newly started dialog MyDialog is independent
of dialog A. If dialog A is closed, MyDialog remains unaffected and active.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthPopupAsChild"><title>PopupAsChild</title>
<indexterm><primary>PopupAsChild</primary></indexterm>
<programlisting>
<![CDATA[
                                            +-DEFAULT--+
>>-aBaseDialog~PopupAsChild(--parent--,--"--+----------+--"----->
                                            +-NORMAL---+
                                            +-SHOWTOP--+
                                            +-HIDE-----+
                                            +-MIN------+
                                            +-MAX------+
                                            +-INACTIVE-+

>--+-------------------------------+--)------------------------><
   +-,--+-----------+--+---------+-+
        +-sleeptime-+  +-,--icon-+


]]>
</programlisting>

<para>The PopupAsChild method starts a dialog as a child
dialog of another dialog, dispatches messages asynchronously, and returns
immediately after the dialog is started.</para>
<para>A dialog started with PopupAsChild and its parent dialog can be active
at the same time. This means that the parent dialog is not disabled by the
child dialog. You can therefore use PopupAsChild to produce nonmodal dialogs.
However, the child dialog is automatically terminated when the parent dialog
is closed.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>parent</term>
<listitem><para>An object of the PlainBaseDialog class or one of its descendants that
is the parent of the newly started dialog.
</para></listitem></varlistentry>
<varlistentry><term>show</term>
<listitem><para>See <link linkend="show">Show</link>.
</para></listitem></varlistentry>
<varlistentry><term>sleeptime</term>
<listitem><para>The time, in milliseconds, until the next message is processed.
</para></listitem></varlistentry>
<varlistentry><term>icon</term>
<listitem><para>The resource ID of the <link linkend="dialogicon">dialog's
icon</link>.  If an icon ID is not supplied, the default ooDialog icon will be
used.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example starts a dialog and runs the statements after
PopupAsChild asynchronously to the dialog. This means that the dialog reacts
to an event like pressing a button and calls the connected method while the
DO loop is being processed. The new dialog is started as a child of MyParent
and is therefore closed when the MyParent dialog is closed:</para>

<programlisting>
<![CDATA[
MyParent = .UserDialog~new
...
MyParent~Popup("SHOWTOP")
...
MyDialog~PopupAsChild(MyParent, "SHOWTOP", 250)
do i = 1 to 1000
   say "Iteration" i
   call SleepMs 100
   if i = 800 then MyParent~Finished = 1  /* close both dialogs when i = 800 */
end
]]>
</programlisting>
<para>This example could also be part of a method handling an event
of a dialog, for example dialog A. The newly started dialog MyDialog is independent
of dialog A. If dialog A is closed, MyDialog remains unaffected and active.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000721"><title>IsDialogActive</title>
<indexterm><primary>IsDialogActive</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~IsDialogActive----------------------------------><


]]>
</programlisting>

<para>The IsDialogActive method returns 1 if the Windows dialog still exists. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example tests whether the dialog is active:

<programlisting>
<![CDATA[
if MyDialog~IsDialogActive then ...
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000073"><title>StopIt</title>
<indexterm><primary>StopIt</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~StopIt------------------------------------------><


]]>
</programlisting>

<para>The StopIt method removes the Windows dialog
from the memory. It is called by <link linkend="h000048">Execute</link>, after
the user terminates the dialog. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected and for internal use only.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000756"><title>HandleMessages</title>
<indexterm><primary>HandleMessages</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~HandleMessages----------------------------------><


]]>
</programlisting>

<para>The HandleMessages method handles dialog messages
synchronously. It is called by <link linkend="h000048">Execute</link>. HandleMessages
is a dispatcher that receives Windows events and posts the message that
is set to handle the event.</para>
</section>

<section id="h000746"><title>AsyncMessageHandling</title>
<indexterm><primary>AsyncMessageHandling</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~AsyncMessageHandling(--sleeptime--)-------------><


]]>
</programlisting>

<para>The AsyncMessageHandling method starts the asynchronous
handling of dialog messages. It is invoked automatically by <link linkend="h000057">ExecuteAsync</link> with the Start method of the Object class. A message in this
context is the name of an object method that is processed whenever the corresponding
event occurs.  You can set the messages that should be sent by using Connect... methods (see page <link linkend="man0001">Connect Methods</link>). </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected and for internal use only.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>sleeptime</term>
<listitem><para>The time slice, in milliseconds, until the next message is processed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="peekdialogmessage"><title>PeekDialogMessage</title>
<indexterm><primary>PeekDialogMessage</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~PeekDialogMessage-------------------------------><


]]>
</programlisting>

<para>The PeekDialogMessage method returns the first
pending message of the dialog's message queue without removing it from
the message queue.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The first pending message or an empty string.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000763"><title>ClearMessages</title>
<indexterm><primary>ClearMessages</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ClearMessages-----------------------------------><


]]>
</programlisting>

<para>The ClearMessages method clears all pending dialog
messages.</para>
</section>

<section id="h000614"><title>SendMessageToItem</title>
<indexterm><primary>SendMessageToItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SendMessageToItem(--id--,--msg--,--wp--,--lp--)-><


]]>
</programlisting>

<para>The SendMessageToItem method sends a Windows message
to a dialog item. It is used to influence the behavior of dialog items. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog item.
</para></listitem></varlistentry>
<varlistentry><term>msg</term>
<listitem><para>The Windows message (you need a Windows SDK
to look up these numbers).
</para></listitem></varlistentry>
<varlistentry><term>wp</term>
<listitem><para>The first message parameter (wParam).
</para></listitem></varlistentry>
<varlistentry><term>lp</term>
<listitem><para>The second message parameter (lParam).
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example sets the marker to radio button 9001:

<programlisting>
<![CDATA[
MyDialog~SendMessageToItem(9001, "0x000000F1", 1, 0)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="man0001"><title>Connect Event Methods</title>
<indexterm><primary>connect event methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<para>The following methods create a connection between an event of the Windows
dialog, or a dialog control, and a method of the Rexx dialog object. In the
Windows user interface, as the user interacts with the system, events are
generated that specify what the action of the user was. Mouse clicks, keyboard
presses, moving or sizing windows, all generate events. In the ooDialog
framework, when a specific event is connected to a method, that method will be
invoked each time the event occurs.
</para>
<itemizedlist>
<listitem><para>For push buttons you connect a method to the button. The connected method
is called each time the button is pressed (clicked.)</para></listitem>
<listitem><para>List boxes, multiple list boxes, and combo boxes can also be connected
to a method that is called each time a line in the box is selected.</para></listitem>
<listitem><para>For a scroll bar you can specify different methods that are called depending
on the user action. The user can click on the arrow buttons, drag the thumb,
or use direction keys.</para></listitem></itemizedlist>
<para>In a <computeroutput>UserDialog</computeroutput> the Connect... event
methods for buttons are called automatically from the Add... methods.  However,
for most events like the resize or move events, the connection needs to be made
explicitly.  In general, events should be connected before the dialog is shown on
the screen. So, the Connect... event methods can be used in the <link
linkend="mthInitDialog">InitDialog</link> method.  In a UserDialog, the <link
linkend="h001506">DefineDialog</link> method is a good place for the Connect...
event methods.  If the programmer is overriding the <link
linkend="h000025">Init</link> method, the Connect... event methods can be placed
there.  But, be sure the methods are not used until after the superclass has
been initialized.
</para>

<note><title>Note</title><para>
The method name that is to be invoked when the specified event occurs must be
less than 256 characters.
</para></note>

<section id="mthConnectResize"><title>ConnectResize</title>
<indexterm><primary>ConnectResize</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectResize(--msgToRaise--)-------------------><


]]>
</programlisting>

<para>The ConnectResize method connects a dialog resize
event with a method. It is called each time the size of the dialog is changed.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent each time the dialog is resized. Provide
a method with a matching name.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example 1:</emphasis></term>
<listitem><para>

<programlisting>
<![CDATA[
  dlg = .ResizingDialog~new
  dlg~createCenter(100, 60, "Resize Me", "THICKFRAME")
  dlg~execute("SHOWTOP")

::requires 'ooDialog.cls'

::class 'ResizingDialog' subclass UserDialog

::method init
  forward class (super) continue

  self~connectResize("onSize")

::method onSize
  use arg sizeEvent, sizeInfo

  -- Wait until the last size event message, in a series of messages, arrives.
  msg = self~peekDialogMessage
  if msg~left(6) = "ONSIZE" then return

  -- sizeInfo contains information about the new width and height in pixels.
  w = .DlgUtil~loWord(sizeinfo) / self~factorX
  h = .DlgUtil~hiWord(sizeinfo) / self~factorY
  say "New width=" w ", new height=" h

]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example 2:</emphasis></term>
<listitem><para>This example is pulled from the <link
linkend="exampleFileViewer">File Viewer</link> example at the end of the
&quot;Appearance and Behavior Methods&quot; section. A complete working example
is presented there that uses a number of the base dialog methods.

<programlisting>
<![CDATA[

::method defineDialog
  expose wasMinimized

  wasMinimized = .false
  style = "VSCROLL HSCROLL MULTILINE READONLY"
  self~addEntryLine(IDC_MULTILINE, "cEntry", 0, 0, 170, 180, style)
  self~connectResize("onSize")
  ...

/* The first arg, sizeEvent, is a flag that the OS sends specifying the type of
 * size event.  We are only interested in these 3 flags:
 *
 * SIZE_RESTORED   = 0
 * SIZE_MINIMIZED  = 1
 * SIZE_MAXIMIZED  = 2
 */
::method onSize
  expose wasMinimized
  use arg sizeEvent sizeInfo

  if sizeEvent = 1 then wasMinimized = .true

  if sizeEvent = 0 |  sizeEvent = 2 then do
    if \ wasMinimized then self~resizeEditControl
    wasMinimized = .false
  end

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

<note><title>Note</title><para>
Connections are usually placed in the <link linkend="h000025">Init</link> or <link linkend="mthInitDialog">InitDialog</link> method. If both methods
are defined, use Init as the place for this connection - but not before init:super has been called.
</para></note>
</section>

<section id="connectmove"><title>ConnectMove</title>
<indexterm><primary>ConnectMove</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectMove(--msgToRaise--)---------------------><


]]>
</programlisting>

<para>The ConnectMove method connects a dialog move event
with a method. It is called each time the position of the dialog is changed.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent each time the dialog is moved. Provide
a method with a matching name.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>

<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  forward class (super) continue

  self~connectMove(onMove)

::method onMove
  use arg unUsed, posInfo

  -- Look at our message queue to see if the next message in the queue is also
  -- onMove.  If so, just return.
  msg = self~peekDialogMessage
  if msg~left(6) = "ONMOVE" then return

  -- Now, we should be done moving, print out where we are.
  x = .DlgUtil~loWord(posInfo)
  y = .DlgUtil~hiWord(posInfo)
  say 'At coordinate (' x',' y' ) on the screen. (In pixels.)'

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

<note><title>Note</title><para>
Connections are usually placed in the <link linkend="h000025">Init</link> or <link linkend="mthInitDialog">InitDialog</link> method. If both methods
are defined, use Init as the place for this connection - but not before init:super has been called.
</para></note>
</section>

<section id="connectposchanged"><title>ConnectPosChanged</title>
<indexterm><primary>ConnectPosChanged</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectPosChanged(--msgToRaise--)---------------><


]]>
</programlisting>

<para>The ConnectPosChanged method connects a change
regarding the dialog coordinates with a method. It is called each time the
size, position, or place in the Z order of the dialog is changed.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent each time the coordinates of the dialog
are changed. Provide a method with a matching name.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>

<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method Init
  self~init:super(...)
  self~ConnectPosChanged("OnNewPos")

::method OnNewPos
  say "The new rectangle is" self~GetWindowRect(self~DlgHandle)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

<note><title>Note</title><para>
Connections are usually placed in the <link linkend="h000025">Init</link> or <link linkend="mthInitDialog">InitDialog</link> method. If both methods
are defined, use Init as the place for this connection - but not before init:super has been called.
</para></note>
</section>

<section id="connectmousecapture"><title>ConnectMouseCapture</title>
<indexterm><primary>ConnectMouseCapture</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectMouseCapture(--msgToRaise--)------------->>


]]>
</programlisting>

<para>The ConnectMouseCapture method connects a method
with the lose-mouse-capture event. It is called each time the dialog loses
the mouse capture. This can happen, for example, when you move a dialog with
the mouse and release the left mouse button.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent each time the mouse capture is lost in
the dialog. Provide a method with a matching name.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectHelp"><title>ConnectHelp</title>
<indexterm><primary>ConnectHelp</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectHelp(--msgToRaise--)-----------------------><


]]>
</programlisting>

<para>The <computeroutput>ConnectHelp</computeroutput> method connects the
Windows Help event with a method in the dialog class. The Windows Help event
occurs when the user presses the F1 key.  (Only the Help events generated when
the dialog is the active window are connected.)
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>msgToRaise</term>
<listitem><para>The name of the method that is to be invoked.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>An (internal) error prevented the message from being connected
to a method.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Event Method Arguments
</emphasis></term>
<listitem><para>The ooDialog method connected to the Help event will receive the
following four arguments in the order listed:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The resource ID of the dialog, dialog control, or menu item that
had the focus when the F1 key was pressed.
</para></listitem></varlistentry>
<varlistentry><term>type</term>
<listitem><para>Specifies if the ID in argument 1 was from a window (a dialog or
dialog control) or from a menu item.  This argument will either be
<computeroutput>WINDOW</computeroutput> or <computeroutput>MENU
</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>mouseX</term>
<listitem><para>The x coordinate of the mouse at the time the F1 key was
pressed.  This value is an absolute screen coordinate (pixel) and note that the
mouse will not necessarily be over the dialog.
</para></listitem></varlistentry>
<varlistentry><term>mouseY</term>
<listitem><para>The y coordinate of the mouse at the time the F1 key was
pressed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>

<programlisting>
<![CDATA[

::method Init
    self~init:super
    ...
    self~connectResize(onResize)
    self~connectHelp(onHelp)
    ...

::method onHelp
    use arg id, type, mouseX, mouseY
    if type == "MENU" then w = 'Menu id' id; else w = 'Dialog id' id
    say "Help request:"
    say " " w
    say "  Mouse position x:" mouseX "y:" mouseY

/* As the user presses the F1 key at various times when the dialog has the focus
 * the output might be as follows:
 */

Help request:
  Dialog id 12
  Mouse position x: 420 y: 106
Help request:
  Menu id 60
  Mouse position x: 204 y: 93
Help request:
  Menu id 65
  Mouse position x: 203 y: 166
Help request:
  Dialog id 14
  Mouse position x: 218 y: 410
Help request:
  Dialog id 80
  Mouse position x: 387 y: 462
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectKeyPressBaseDialog"><title>ConnectKeyPress</title>
<indexterm><primary>ConnectKeyPress</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectKeyPress(--msgToRaise--,--keys-+------------+--)----><
                                                    +-,--filter--+

]]>
</programlisting>

<para>The <computeroutput>ConnectKeyPress</computeroutput> method connects a key
press event with a method in the dialog class. A single key or multiple keys can
be connected to the same method.  Multiple methods can be connected for key
press events, but only 1 method can be connected to any single key.
</para>
<para>The underlying Windows dialog must exist before this method can be used.
That means it can be used in <link linkend="mthInitDialog">InitDialog</link> or any
time thereafter.  There is a maximum limit of 63 methods, per dialog, that can
be connected to key press events.  Connections can be removed (see the <link
linkend="mthDisconnectKeyPressBaseDialog">DisconnectKeyPress</link> method) if
there is no longer a need for a notification of a key press.
</para>
<para>A similar <link linkend="mthConnectKeyPressDialogcontrol">method</link>
is a member of the <computeroutput>DialogControl</computeroutput> class.  It is
important to note this distinction between the two methods.  The method of the
<computeroutput>BaseDialog</computeroutput> (this method) will capture any key
press event when the dialog is the active window.  The method of the
<computeroutput>DialogControl</computeroutput> class will only capture a key
press when the control has the keyboard focus.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>msgToRaise</term>
<listitem><para>The name of the method that is to be invoked when the key press
event happens.
</para></listitem></varlistentry>
<varlistentry><term>keys</term>
<listitem><para>The key (or keys) for which the key press event is to be
connected. A single key or multiple keys can be specified. A range of keys can
be used.  Each single key or range of keys is separated by a comma.  A range of
keyes is denoted by using the dash character &quot;-&quot;.  White space within
the <computeroutput>keys</computeroutput> argument is ignored.
</para>
<para>The keys are specified by the numeric value defined by Microsoft for its
virtual key set.  These numeric values are 0 through 255, although both 0 and
255 are not used.  The <link linkend="clsVirtualKeyCodes">VirtualKeyCodes</link>
class can be used to make a program more readable.
</para>
<note><title>Note</title>
<para>The programmer can use the <link linkend="windowsdoc">Windows
documentation</link> and <link linkend="platformsdk">Platform SDK</link> to
obtain the full list of the virtual key numbers.
</para></note>
<para>In addition there are a few keywords that can be used to specify some
common key ranges. These keywords are:
<variablelist>
<varlistentry><term>ALL</term>
<listitem><para>All keys.
</para></listitem></varlistentry>
<varlistentry><term>FKEYS</term>
<listitem><para>All Function keys, other than F1.  (In Windows the F1 key is the
help key and the <link linkend="mthConnectHelp">ConnectHelp</link> method should
be used for F1.)
</para></listitem></varlistentry>
<varlistentry><term>ALPHA</term>
<listitem><para>The keys A though Z.
</para></listitem></varlistentry>
<varlistentry><term>NUMERIC</term>
<listitem><para>The keys 0 through 9.  Note that these are the normal number
keys, not the keypad numbers on an enhanced keyboard.
</para></listitem></varlistentry>
<varlistentry><term>ALPHANUMERIC</term>
<listitem><para>The keys A through Z and 0 through 9.
</para></listitem></varlistentry>
</variablelist></para>
<note><title>Note</title><para>Case is insignificant for these keywords as is the
order of the keywords. A keyword not in the list will result in a return of -1.
However, if the argument contains other valid key tokens, those keys will be
connected to the method.  If there are no other valid key tokens, then no
connection is made.
</para></note></listitem></varlistentry>
<varlistentry><term>filter</term>
<listitem><para>A (simplistic) filter that is applied to the key press event for
the key(s) specified.  The filter is a string of keywords separated by blanks.
(Case is not significant, neither is the order of the words.  Any words other
than the specified keywords are ignored.) The possible keywords are:
<computeroutput>SHIFT, CONTROL, ALT, AND, NONE.</computeroutput>
</para>
<para>Shift, control, and alt specify that the corresponding key must be down at
the time of the key press event. These keywords are combined in a boolean
expression.  The default is an OR expression. If the AND keyword is present then
the boolean expression is an AND expression. If the NONE keyword is used, it
means that none of the shift, control, or alt keys can be down at the time of
the key press event.  (When NONE is used, all other words in the string are
ignored.)
</para>
<para> Some examples may make this more clear:
<programlisting>
<![CDATA[

::method initDialog

  -- Using the below, the onAltCD method would be invoked when the user types
  -- Alt-Shift-C or Alt-Shift-D.  But the method would not be invoked for Alt-C
  -- or Shift-D (or any other key press event.)

  keys = self~vCode('C') "," self~vCode('D')
  self~connectKeyPress(onAltCD, keys, "ALT AND SHIFT")

  -- The below would invoke the onAltCD method any time a C or a D was typed
  -- with either the Alt or the Control key down.  This would include Alt-C,
  -- Alt-Shift-C, Ctrl-Alt-Shift-C, etc..

  self~connectKeyPress(onAltCD, keys, "ALT CONTROL")

  -- The below would invoke the onAltCD method only when Alt-C or Alt-D was
  -- typed.

  self~connectKeyPress(onAltCD, keys, "ALT AND")

  -- The below would invoke the onF4 method only when the F4 key was pressed by
  -- itself. Alt-F4, Ctrl-F4, etc., would not invoke the method.

  self~connectKeyPress(onF4, self~vCode('F4'), "NONE")
]]>
</programlisting>

</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para> The return values are:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Success.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>A problem with one of the arguments, such as skipping a required
argument, using an incorrect format for the <computeroutput>keys
</computeroutput> or the <computeroutput>filter</computeroutput> arguments,
etc..  Note that it is possible to get a return of -1 but still have some keys
connected.  For instance in the following example the C and D keys would be
connected and the filter applied.  The &quot;"dog&quot;" token would result in
-1 being returned:
<programlisting>
<![CDATA[

  keys = self~vCode('C') ", dog," self~vCode('D')
  ret = self~connectKeyPress('onAltCD', keys, "ALT AND SHIFT")
  say 'Got a return of:' ret
  say "Have connection to onAltCD?" self~hasKeyPressConnection('onAltCD')

  -- The output would be:
  Got a return of: -1
  Have connection to onAltCD? 1

]]>
</programlisting>

</para></listitem></varlistentry>
<varlistentry><term>-2</term>
<listitem><para>The underlying mechanism in the Windows API that is used to
capture key events failed.
</para></listitem></varlistentry>
<varlistentry><term>-4</term>
<listitem><para>An (internal) problem with the dialog window.
</para></listitem></varlistentry>
<varlistentry><term>-5</term>
<listitem><para>Memory allocation error in the underlying Windows API.
</para></listitem></varlistentry>
<varlistentry><term>-6</term>
<listitem><para>The maximum number of connections has been reached.
</para></listitem></varlistentry>
<varlistentry><term>-7</term>
<listitem><para>The <computeroutput>msgToRaise</computeroutput> method is
already connected to a key down event for this dialog.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Event Method Arguments
</emphasis></term>
<listitem><para>The ooDialog method connected to the key press event will
receive the following five arguments in the order listed:
<variablelist>
<varlistentry><term>keyCode</term>
<listitem><para>The numeric code of the key pressed.
</para></listitem></varlistentry>
<varlistentry><term>shift</term>
<listitem><para>A boolean (true or false) that denotes whether a shift key
was down or up at the time of the key press.  It will be true if a shift key
was down and false if the shift key was not down.
</para></listitem></varlistentry>
<varlistentry><term>control</term>
<listitem><para>True if a control key was down at the time of the key press,
false if it was not.
</para></listitem></varlistentry>
<varlistentry><term>alt</term>
<listitem><para>True if an alt key was down at the time of the key press, false
if it was not.
</para></listitem></varlistentry>
<varlistentry><term>extraInfo</term>
<listitem><para>This argument is a string containing keywords.  It supplies
extra information about the keyboard state at the time of a key press event.
The string will contain some combination of these keywords
<variablelist>
<varlistentry><term>numOn</term>
<listitem><para>Num Lock was on at the time of the key press event.
</para></listitem></varlistentry>
<varlistentry><term>numOff</term>
<listitem><para>Num Lock was off.
</para></listitem></varlistentry>
<varlistentry><term>capsOn</term>
<listitem><para>Caps Lock was on at the time of the key press event.
</para></listitem></varlistentry>
<varlistentry><term>capsOff</term>
<listitem><para>Caps Lock was off.
</para></listitem></varlistentry>
<varlistentry><term>scrollOn</term>
<listitem><para>Scroll Lock was on at the time of the key press event.
</para></listitem></varlistentry>
<varlistentry><term>scrollOff</term>
<listitem><para>Scroll Lock was off.
</para></listitem></varlistentry>
<varlistentry><term>lShift</term>
<listitem><para>The left shift key was down at the time of the key press event.
</para></listitem></varlistentry>
<varlistentry><term>rShift</term>
<listitem><para>The right shift key was down.
</para></listitem></varlistentry>
<varlistentry><term>lControl</term>
<listitem><para>The left control key was down at the time of the key press
event.
</para></listitem></varlistentry>
<varlistentry><term>rControl</term>
<listitem><para>The right control key was down.
</para></listitem></varlistentry>
<varlistentry><term>lAlt</term>
<listitem><para>The left alt key was down at the time of the key press event.
</para></listitem></varlistentry>
<varlistentry><term>rAlt</term>
<listitem><para>The right alt key was down.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry id="connectKeyPressExample"><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example is from a fictitious customer order
system.  As the user is filling out a customer order using the customer order
dialog, he has the F2 through F5 short cut keys available.  F2 brings up a
customer look up dialog.  F3 looks up info on the product number entered in an
edit control.  F4 resets the form by clearing all the fields.  F5 is used to
print out the finished invoice.
<programlisting>
<![CDATA[
::method initDialog

  ...

  -- Capture F2 key presses, but not Ctrl-F2 or Alt-F2, etc..
  self~connectKeyPress(onF2, self~vCode('F2'), "NONE")

  -- Same idea for F3, F4, and F5.  This uses the actual numeric value for the
  -- keys without bothering to use the VirtualKeyCodes class to translate.
  self~connectKeyPress(onF3, 114, "NONE")
  self~connectKeyPress(onF4, 115, "NONE")
  self~connectKeyPress(onF5, 116, "NONE")

  ...

::method onF2
  self~showCustomerLookupDialog

::method onF3

  prodNum = self~getEditControl(IDC_EDIT_PRODUCT)~getText
  if prodNum \== "" then self~showProductInfo(prodNum)

::method onF4
  self~resetAllFields

::method onF5
  self~printInvoice

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectFKeyPressBaseDialog"><title>ConnectFKeyPress</title>
<indexterm><primary>ConnectFKeyPress</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~ConnectFKeyPress(--msgToRaise--)-------------><


]]>
</programlisting>

<para>The <computeroutput>ConnectFKeyPress</computeroutput> method connects a
function key press to a method in the dialog instance.  This works for function
keys F2 through F24, without the shift, control, or alt keys also being pressed.
The underlying Windows dialog must exist before this method can be invoked.
This is a convenience method and is exactly equivalent to:
<programlisting>
<![CDATA[
::method initDialog
  ...
  keys = self~vCode('F2') "-" self~vCode('F24')
  self~connectKeyPress(msgToRaise, keys, "NONE")
]]>
</programlisting>
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The required argument is:
<variablelist>
<varlistentry><term>msgToRaise</term>
<listitem><para>The method to be invoked for the F key press event.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para> The return values are:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Success.
</para></listitem></varlistentry>
<varlistentry><term>-2</term>
<listitem><para>The underlying mechanism in the Windows API that is used to
capture key events failed.
</para></listitem></varlistentry>
<varlistentry><term>-4</term>
<listitem><para>An (internal) problem with the dialog window.
</para></listitem></varlistentry>
<varlistentry><term>-5</term>
<listitem><para>Memory allocation error in the underlying Windows API.
</para></listitem></varlistentry>
<varlistentry><term>-6</term>
<listitem><para>The maximum number of connections has been reached.
</para></listitem></varlistentry>
<varlistentry><term>-7</term>
<listitem><para>The <computeroutput>msgToRaise</computeroutput> method is
already connected to a key down event for this dialog.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example is a variation on the <link
linkend="connectKeyPressExample">example</link> shown for the <link
linkend="mthConnectKeyPressBaseDialog">ConnectKeyPress</link> method. It
connects all the function keys to the same method and then determines what
action to take by examining which key was pressed.
<programlisting>
<![CDATA[
::method initDialog

  ...

  -- Capture all function key presses.
  self~connectFKeyPress(onFKey)

  ...

::method onFKey
  use arg keyPressed

  select
    when self~keyName(keyPressed) == 'F2' then self~showCustomerLookupDialog

    when keyPressed = 114 then do
      prodNum = self~getEditControl(IDC_EDIT_PRODUCT)~getText
      if prodNum \== "" then self~showProductInfo(prodNum)
    end

    when keyPressed = 115 then self~resetAllFields
    when keyPressed = 116 then self~printInvoice

    otherwise do
      -- Not interested in any other function keys
      nop
    end
  end

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthDisconnectKeyPressBaseDialog"><title>DisconnectKeyPress</title>
<indexterm><primary>DisconnectKeyPress</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DisconnectKeyPress(--+--------------+--)--------><
                                    +--methodName--+

]]>
</programlisting>

<para>The <computeroutput>DisconnectKeyPress</computeroutput> method disconnects
a key press event from a method that was previously connected using <link
linkend="mthConnectKeyPressBaseDialog">ConnectKeyPress</link>.  If no
method name is specified than all key press event connections are removed.
Otherwise, only the key press events connected to the specific method are
removed.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The single optional argument is:
<variablelist>
<varlistentry><term>methodName</term>
<listitem><para>If <computeroutput>methodName</computeroutput> is specified,
only the key press events connected to that method are disconnected.  If the
argument is omitted, then all key press events for the dialog will be
disconnected.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The return values are:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Success.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>The specified <computeroutput>methodName</computeroutput> is not
connected to any key press events for this dialog.
</para></listitem></varlistentry>
<varlistentry><term>-2</term>
<listitem><para>This return code can only occur when removing the connection for
a single <computeroutput>methodName</computeroutput>.  It indicates that after
removing the connection, the underlying mechanism in the Windows API that
captures the key press events could not be re-initialized.  (It is doubtful this
error would ever occur.)
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example is a variation on the <link
linkend="connectKeyPressExample">example</link> shown for the <link
linkend="mthConnectKeyPressBaseDialog">ConnectKeyPress</link> method. It builds
on the fictitious customer order system.  The F7 key saves the completed invoice
into the system and enters a different phase of the companies business process.
At this point (for whatever fictitious business reason) the fields can no longer
be cleared and the user is not allowed to look up customer or product
information.  But, the user may still need to print the invoice.  To prevent the
accidental press of the hot keys causing the wrong action, those key presses are
disconnected.
</para>
<para>To demonstrate how key press connections can be added and removed through
out the live time of the dialog, this example adds the F9 hot key.  F9 starts a
new order entry cycle and re-connects the hot keys used during the creation of
a customer invoice.  When the user then saves the next completed invoice, key
press connections are removed, when she starts a new invoice key press
connections are restored.  This cycle could continue though out the day without
the user ever closing the main dialog.
<programlisting>
<![CDATA[

::method initDialog

  ...

  -- Capture F2 key presses, but not Ctrl-F2 or Alt-F2, etc..
  self~connectKeyPress(onF2, self~vCode('F2'), "NONE")

  -- Same idea for F3, F4, F5, and F7.  This uses the actual numeric value for
  -- the keys without bothering to use the VirtualKeyCodes class to translate.
  self~connectKeyPress(onF3, 114, "NONE")
  self~connectKeyPress(onF4, 115, "NONE")
  self~connectKeyPress(onF5, 116, "NONE")
  self~connectKeyPress(onF7, 118, "NONE")
  self~connectKeyPress(onF9, 120, "NONE")

  ...

::method onF2
  self~showCustomerLookupDialog

::method onF3

  prodNum = self~getEditControl(IDC_EDIT_PRODUCT)~getText
  if prodNum \== "" then self~showProductInfo(prodNum)

::method onF4
  self~resetAllFields

::method onF5
  self~printInvoice

::method onF7

  self~saveToDataBase
  self~disconnectKeyPress(onF2)
  self~disconnectKeyPress(onF3)
  self~disconnectKeyPress(onF4)

::method onF9

  self~resetAllFields
  self~connectKeyPress(onF2, 112, "NONE")
  self~connectKeyPress(onF3, 114, "NONE")
  self~connectKeyPress(onF4, 115, "NONE")

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

</section>

<section id="mthHasKeyPressConnectionBaseDialog"><title>HasKeyPressConnection</title>
<indexterm><primary>HasKeyPressConnection</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~HasKeyPressConnection(--+--------------+--)--------><
                                       +--methodName--+

]]>
</programlisting>

<para>This method is used to query if a connection to a key press event already
exists.  It returns true or false so it can always be used in a boolean
expression.  If no argument is specified the method returns true if any key
press events have been connected for the dialog and false otherwise.  When the
<computeroutput>methodName</computeroutput> argument is used, the query is only
if there are key press events connected to the specified method.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The single optional argument is:
<variablelist>
<varlistentry><term>methodName</term>
<listitem><para>Query if any key press events are connected to this method.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The returned value is always <computeroutput>true
</computeroutput> or <computeroutput>false</computeroutput>.
<variablelist>
<varlistentry><term>true</term>
<listitem><para>A connection exists.
</para></listitem></varlistentry>
<varlistentry><term>false</term>
<listitem><para>No connection exists.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example could come from a dialog where the user
has the option to use hot keys or not.  When the reset button is pushed the
state of the dialog fields are reset.  The hot keys enabled check box is
set to reflect whether hot keys are currently enabled or not.
<programlisting>
<![CDATA[

::method defineDialog

  ...
  self~addCheckBox(IDC_CHECK_FKEYSENABlED, , 30, 60, , , "Hot Keys Enabled")
  ...
  self~addButton(IDC_PB_RESET, 60, 135, 45, 15, "Reset", onReset)
  ...

::method onReset

  ...
  if self~hasKeyPressConnection then
    self~getCheckControl(IDC_CHECK_FKEYSENABlED)~check
  else
    self~getCheckControl(IDC_CHECK_FKEYSENABlED)~uncheck
  ...

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>


</section>

<section id="mthConnectButton"><title>ConnectButton</title>
<indexterm><primary>ConnectButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectButton(--id--+---------------+--)--------><
                                   +-,--msgToRaise-+


]]>
</programlisting>

<para>The ConnectButton method connects a push button
with a method. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog element.
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is sent each time the button is clicked. You should
provide a method with the matching name.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>

<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method Init
  self~init:super(...)
  self~ConnectButton(203, "SayHello")

::method SayHello
  say "Hello"
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

<note><title>Note</title><para>
Connections are usually placed in the <link linkend="h000025">Init</link> or <link linkend="mthInitDialog">InitDialog</link> method. If both methods
are defined, use Init as the place for this connection - but not before init:super has been called.
</para></note>
</section>

<section id="mthConnectBitmapButton"><title>ConnectBitmapButton</title>
<indexterm><primary>ConnectBitmapButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectBitmapButton(--id--,--+------------+--,--bmpNormal-->
                                            +-msgToRaise-+

>--+----------------------------------------------------------------------------+--)-><
   +-,--bmpFocused--+---------------------------------------------------------+-+
                    +-,--bmpSelected--+-------------------------------------+-+
                                      +-,--bmpDisabled--+-----------------+-+
                                                        +-,--styleOptions-+


]]>
</programlisting>

<para>The ConnectBitmapButton method connects a bitmap
and a method with a push button. The given bitmaps are displayed instead of
a Windows push button.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button.
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent to this object when the button is clicked.
</para></listitem></varlistentry>
<varlistentry><term>bmpNormal</term>
<listitem><para>The name (alphanumeric), resource ID (numeric), or handle (<emphasis role="italic">INMEMORY</emphasis> option) of a bitmap file. This bitmap is displayed when the button is
not selected, not focused, and not disabled. It is used for the other button
states in case the other arguments are omitted.
</para></listitem></varlistentry>
<varlistentry><term>bmpFocused</term>
<listitem><para>This bitmap is displayed when the button is focused. The focused button
is activated when the Enter key is pressed.
</para></listitem></varlistentry>
<varlistentry><term>bmpSelected</term>
<listitem><para>This bitmap is displayed while the button is clicked and held.
</para></listitem></varlistentry>
<varlistentry><term>bmpDisabled</term>
<listitem><para>This bitmap is displayed when the button is disabled.
</para></listitem></varlistentry>
<varlistentry><term>styleOptions</term>
<listitem><para>One of the following keywords:
<variablelist>
<varlistentry><term>FRAME</term>
<listitem><para>Draws a frame around the button.  When using this option, the bitmap
button behaves like a normal Windows button, except that a bitmap is
shown instead of a text.
</para></listitem></varlistentry>
<varlistentry><term>USEPAL</term>
<listitem><para>Stores the colors of the bitmap file as the system color palette.  This
option is needed when the bitmap was created with a palette other than the
default Windows color palette. Use it for one button only,
because only one color palette can be active at any time. <emphasis role="italic">USEPAL</emphasis> is
invalid for a bitmap loaded from a DLL.
</para></listitem></varlistentry>
<varlistentry><term>INMEMORY</term>
<listitem><para>This option must be used if the named bitmaps are already loaded into
memory by using the <link linkend="h000667">LoadBitmap</link> method. In this case, bmpNormal, bmpFocused, bmpSelected, and bmpDisabled specify a bitmap handle instead of a file.
</para></listitem></varlistentry>
<varlistentry><term>STRETCH</term>
<listitem><para>If this option is specified and the extent of the bitmap is smaller
than the extent of the button rectangle, the bitmap is adapted to match the
extent of the button. STRETCH has no effect for bitmaps
loaded through a DLL.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example connects a button with four bitmaps and a method:

<programlisting>
<![CDATA[
      .
      .
      .
::method InitDialog
  self~ConnectBitmapButton(204, "BmpButtonClicked", ,
                           "AddBut_n.bmp", "AddBut_f.bmp", ,
                           "AddBut_s.bmp", "AddBut_d.bmp", "FRAME")
::method BmpButtonClicked
      .
      .
      .
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
<para>See also method <link linkend="h000170">ChangeBitmapButton</link>.</para>
</section>

<section id="h000123"><title>ConnectControl</title>
<indexterm><primary>ConnectControl</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectControl(--id--+---------------+--)-------><
                                    +-,--msgToRaise-+


]]>
</programlisting>

<para>The ConnectControl method connects a dialog control
with a method. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog element.
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent each time the button is clicked. Provide
a method with the matching name.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h111111"><title>ConnectDraw</title>
<indexterm><primary>ConnectDraw</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectDraw--(--id--+---------------+--)--------><
                                   +-,--msgToRaise-+


]]>
</programlisting>

<para>The ConnectDraw method connects the WM_DRAWITEM
event with a method. A WM_DRAWITEM message is sent for owner-drawn buttons
each time they are to be redrawn. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog control. If the ID is omitted, all drawing events
of all owner-drawn buttons are routed to the method.
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent each time the WM_DRAWITEM event occurs.
Provide a method with the matching name. You can use <computeroutput>USE ARG ID</computeroutput> to
retrieve the ID of the item that is to be redrawn.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000132"><title>ConnectList</title>
<indexterm><primary>ConnectList</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectList(--id--+---------------+--)----------><
                                 +-,--msgToRaise-+


]]>
</programlisting>

<para>The ConnectList method connects a list box, multiple
list box, or combo box with a method. The method is called each time the user
selects a new item from the list. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog element.
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent each time the button is pressed. Provide
a method with the matching name.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="clldcm"><title>ConnectListLeftDoubleClick</title>
<indexterm><primary>ConnectListLeftDoubleClick</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectListLeftDoubleClick(--id--,--msgToRaise--)-><


]]>
</programlisting>

<para>The ConnectListLeftDoubleClick method combines
a left double-click within the list box with a method. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The name of the method that is to be called.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000802"><title>ConnectScrollBar</title>
<indexterm><primary>ConnectScrollBar</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectScrollBar(--id--,--msgWhenUp--,--msgWhenDown-->

>--+--------------------------------------------------------------------+-->
   +-,--+-------------+--+--------------------------------------------+-+
        +-msgWhenDrag-+  +-,--+-----+--+----------------------------+-+
                              +-min-+  +-,--+-----+--+------------+-+
                                            +-max-+  +-,--+-----+-+
                                                          +-pos-+

>--+----------------------------------------------------------+-->
   +-,--+----------+--+-------------------------------------+-+
        +-progpgup-+  +-,--+----------+--+----------------+-+
                           +-progpgdn-+  +-,--+---------+-+
                                              +-progtop-+

>--+-------------------+--+------------------------------------+-->
   +-,--+------------+-+  +-,--+-----------+--+--------------+-+
        +-progbuttom-+         +-progtrack-+  +-,--progendsc-+


>--)-----------------------------------------------------------><


]]>
</programlisting>

<para>The ConnectScrollBar method initializes and connects
a scroll bar to an Object Rexx object. Use this method in the <link linkend="mthInitDialog">InitDialog</link> method. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>msgWhenUp</term>
<listitem><para>The method that is called each time the scroll bar is incremented.
</para></listitem></varlistentry>
<varlistentry><term>msgWhenDown</term>
<listitem><para>The method that is called each time the scroll bar is decremented.
</para></listitem></varlistentry>
<varlistentry><term>msgWhenDrag</term>
<listitem><para> The method that is called each time the scroll bar is dragged with
the mouse.
</para></listitem></varlistentry>
<varlistentry><term>min, max</term>
<listitem><para> The minimum and maximum values for the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>pos</term>
<listitem><para>The current or preselected value.
</para></listitem></varlistentry>
<varlistentry><term>progpgup</term>
<listitem><para>The method that is called each time the scroll bar is focused and the
PgUp key is pressed.
</para></listitem></varlistentry>
<varlistentry><term>progpgdn</term>
<listitem><para>The method that is called each time the scroll bar is focused and the
PgDn key is pressed.
</para></listitem></varlistentry>
<varlistentry><term>progtop</term>
<listitem><para>The method that is called each time the scroll bar is focused and the
Home key is pressed.
</para></listitem></varlistentry>
<varlistentry><term>progbottom</term>
<listitem><para>The method that is called each time the scroll bar is focused and the
End key is pressed.
</para></listitem></varlistentry>
<varlistentry><term>progtrack</term>
<listitem><para>The method that is called each time the scroll box is dragged.
</para></listitem></varlistentry>
<varlistentry><term>progendsc</term>
<listitem><para>The method that is called each time the scroll box is released after
the dragging.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>In the following example, scroll bar 255 is connected to three methods
and initialized with 1 as the minimum, 20 as the maximum, and 6 as the current
value:

<programlisting>
<![CDATA[
::class MyDialog subclass UserDialog
     .
     .
     .
::method DefineDialog
self~ConnectScrollBar(255,"Increase","Decrease","Drag",1,20,6)
     .
     .
     .
::method Increase
     .
     .
     .
::method Decrease
     .
     .
     .
::method Drag
     .
     .
     .
/* see CombineElWithSB below for continuation */
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="allsbe"><title>ConnectAllSBEvents</title>
<indexterm><primary>ConnectAllSBEvents</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectAllSBEvents(--id--,--Prog----------------->

>--+----------------------------------------+--)---------------><
   +-,--+-----+--+------------------------+-+
        +-min-+  +-,--+-----+--+--------+-+
                      +-max-+  +-,--pos-+


]]>
</programlisting>

<para>Connects all scroll bar events to one method. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:</para>
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the scroll bar
</para></listitem></varlistentry>
<varlistentry><term>Prog</term>
<listitem><para>The method that is called for all events sent by the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>min, max</term>
<listitem><para> The minimum and maximum values for the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>pos</term>
<listitem><para>The current or preselected value.
</para></listitem></varlistentry>
</variablelist>
</listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="mthAddUserMsg"><title>addUserMsg</title>
<indexterm><primary>addUserMsg</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~addUserMsg(--msgToRaise--,--msgWindows----------->

>--+--------------------------------------------------------------------+-->
   +-,--filt1--+------------------------------------------------------+-+
               +-,--wParam--+---------------------------------------+-+
                            +-,--filt2--+-------------------------+-+
                                        +-,--lParam--+----------+-+
                                                     +-,--filt3-+

>--)-----------------------------------------------------------><


]]>
</programlisting>

<para>The addUserMsg method connects a Windows message with an Object Rexx
method. This method is designed to be used by ooDialog programmers who are
familiar with the Windows API.
</para>
<para>You have to pass the Windows message ID and the two message parameters
(wParam and lParam) to specify the exact event you want to catch. In addition,
you can specify filters for each parameter. Filters are useful for catching more
than one message or one parameter with one method.
</para>
<para>Details for all Windows messages and their parameters are available in the
<link linkend="windowsdoc">Windows documentation</link>.  The numeric value of
the message IDs (and possibly the message parameters) can be looked up in the
<link linkend="platformsdk">Windows platform SDK</link>.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected. You can use it only within the scope of the
BaseDialog class or its subclasses.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent to the Object Rexx dialog object each time
the specified Windows message is caught. Provide a method with the
same name. The maximum size for a message is limited to 256 characters.
</para></listitem></varlistentry>
<varlistentry><term>msgWindows</term>
<listitem><para>The message in the Windows environment that is to be caught.
</para></listitem></varlistentry>
<varlistentry><term>filt1</term>
<listitem><para>This filter is used to binary AND the incoming Windows message.
</para></listitem></varlistentry>
<varlistentry><term>wParam</term>
<listitem><para>This is the first parameter that must be passed with the Windows message.
</para></listitem></varlistentry>
<varlistentry><term>filt2</term>
<listitem><para>This filter is used to binary AND the <emphasis role="italic">wParam</emphasis> argument.
</para></listitem></varlistentry>
<varlistentry><term>lParam</term>
<listitem><para>This is the second message parameter.
</para></listitem></varlistentry>
<varlistentry><term>filt3</term>
<listitem><para>This is the filter for <emphasis role="italic">lParam</emphasis>.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example shows an implementation of the
ConnectList method:</para>

<programlisting>
<![CDATA[
::class BaseDialog
      .
      .
      .
::method ConnectList
  use arg msgToRaise, id
  self~addUserMsg(msgToRaise, "0x00000111", "0xFFFFFFFF", ,
                 "0x0001"||id~d2x(4), "0xFFFFFFFF", 0, 0)
]]>
</programlisting>
<para>Assume that this method is called with ID=254 and msgToRaise=&quot;ListChanged&quot;.
After the <link linkend="h000132">ConnectList</link> is executed, the ListChanged
message is sent to the Object Rexx dialog object if the following conditions are
true: </para>
<itemizedlist>
<listitem><para>Message &quot;0x00000111&quot; (WM_COMMAND) is generated by Windows in
answer to an event (for example, a button is clicked or a list has changed).
The filter &quot;0xFFFFFFFF&quot; ensures that only that message is caught;
if the filter were &quot;0xFFFFEFFF&quot;, the message &quot;0x00001111&quot;
would be caught as well.</para></listitem>
<listitem><para>The first message parameter is &quot;0x000100FF&quot;. The first part, &quot;0x0001&quot;,
specifies the event, and the second part, &quot;0x00FE&quot; (equals decimal
254), specifies the dialog control where the event occurred. By using another
filter it is possible to make more than one event a trigger for the ListChanged method; for example, filter &quot;0xFFFFFFFE&quot; would ignore
the last bit of the ID, and this the same event for dialog item 255 would
call ListChanged as well.</para></listitem>
<listitem><para>The second message parameter and its filter are ignored.</para></listitem></itemizedlist>
<para>The following example invokes a user-defined method <computeroutput>DoubleClick</computeroutput> each time the left mouse button is double-clicked: </para>
<programlisting>
<![CDATA[
self~addUserMsg("DoubleCick","0x00000203","0xFFFFFFFF",0,0,0,0)
]]>
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="man0002"><title>Connect Attribute Methods</title>
<indexterm><primary>connect attribute methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<para>The following methods create a connection between a dialog control and an
attribute of the dialog object. The attribute is used to reflect the value
associated with the dialog control.  For instance the text of an edit control.
</para>
<itemizedlist>
<listitem><para>For data items, such as an entry line, list box, or combo box, an attribute
is created and added to the dialog object. The attribute is used as an interface
to the data of the entry line, list box, or combo box.</para></listitem>
<listitem><para>Check boxes and radio buttons are also data items and are therefore connected
to an attribute. The only valid values for these attributes are 1 for selected
and 0 for not selected.
</para></listitem></itemizedlist>
<para>In a UserDialog the Connect... attribute methods are called automatically
from the Add... methods. The proper place for Connect... attribute methods is
the <link linkend="mthInitDialog">InitDialog</link> method.</para>

<section id="mthConnectEntryLine"><title>ConnectEntryLine</title>
<indexterm><primary>ConnectEntryLine</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectEntryLine(--id--+------------------+--)--><
                                      +-,--attributeName-+


]]>
</programlisting>

<para>The ConnectEntryLine method creates a new attribute
and connects it to the entry line id. The attribute
has to be synchronized with the entry line manually. This can be done globally
with the SetData and GetData methods (see page <link linkend="h000269">GetData</link>),
or for only one item with the SetEntryLine and GetEntryLine methods (see page <link linkend="h000466">GetEntryLine</link>). It is done automatically by <link linkend="h000048">Execute</link> when the dialog starts and after it terminates. If AutoDetection
is enabled, or if the dialog is created dynamically (manually or based on
a resource script), you do not have to use this method or any other Connect... methods that deal with dialog controls). </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the entry field you want to connect.
</para></listitem></varlistentry>
<varlistentry><term>attributeName</term>
<listitem><para>An unused valid Rexx symbol because an attribute with exactly
this name is added to the dialog object with this method. Blank spaces, ampersands
(&amp;), and colons (:) are removed from the attributeName. If this argument is omitted, is not valid, or already exists, and the
ID is numeric, an attribute with the name DATAid is
used, where id is the value of the first argument.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>In the following example, the entry line with ID 202 is associated with
the attribute Name. &quot;Put your name here!&quot;
is assigned to the newly created attribute. Then the dialog is executed. After
the dialog has terminated, the data of the entry line, which the user might
have changed, is copied back to the attribute Name.

<programlisting>
<![CDATA[
MyDialog~ConnectEntryLine(202, "Name")
MyDialog~Name="Put your name here!"
MyDialog~Execute("SHOWTOP")
say MyDialog~Name
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectComboBox"><title>connectComboBox</title>
<indexterm><primary>connectComboBox</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~connectComboBox(--id--+-------------------------------------+-->
                                     +-,--+---------------+--+-----------+-+
                                          +-attributeName-+  +-,--"LIST"-+

>--)-----------------------------------------------------------><


]]>
</programlisting>

<para>The connectComboBox method creates an attribute
and connects it to a combo box. The value of the combo box, that is, the text
in the entry line or the selected list item, is associated with this attribute.
See <link linkend="mthConnectEntryLine">ConnectEntryLine</link> for a more detailed description.</para>
<para>If the combo box is of type &quot;Drop down list&quot;, you must specify &quot;LIST&quot;
to connect an attribute with the combo box.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectCheckBox"><title>ConnectCheckBox</title>
<indexterm><primary>ConnectCheckBox</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectCheckBox(--id--+------------------+--)---><
                                     +-,--attributeName-+


]]>
</programlisting>

<para>The ConnectCheckBox method connects a check box
control to a newly created attribute. A check box attribute has only two valid
values: 1 if the box has a check mark, and 0 if it has not. See <link linkend="mthConnectEntryLine">ConnectEntryLine</link> for
a more detailed description.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectRadioButton"><title>ConnectRadioButton</title>
<indexterm><primary>ConnectRadioButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectRadioButton(--id--+------------------+---->
                                        +-,--attributeName-+

>--)-----------------------------------------------------------><


]]>
</programlisting>

<para>The ConnectRadioButton method connects a radio
button control to a newly created attribute. A radio button attribute has
only two valid values: 1 if the radio button is marked and 0 if it is not.
See <link linkend="mthConnectEntryLine">ConnectEntryLine</link> for a more detailed description.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectListBox"><title>ConnectListBox</title>
<indexterm><primary>ConnectListBox</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectListBox(--id--+------------------+--)----><
                                    +-,--attributeName-+


]]>
</programlisting>

<para>The ConnectListBox method connects a list box to
a newly created attribute. The value of the attribute is the number of the
selected line. Therefore, if the attribute value is 3, the third line is currently
selected or will be selected, depending on whether you set data to the dialog
or receive it. See <link linkend="mthConnectEntryLine">ConnectEntryLine</link> for a more detailed description.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectMultiListBox"><title>ConnectMultiListBox</title>
<indexterm><primary>ConnectMultiListBox</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectMultiListBox(--id--+------------------+--->
                                         +-,--attributeName-+

>--)-----------------------------------------------------------><


]]>
</programlisting>

<para>The ConnectMultiListBox method connects a list
box to a newly created attribute. The list box has the multiple-selection
style enabled (by setting the <emphasis role="italic">MULTI</emphasis> option when adding this list
box), that is, you can select more than one item at the same time. The value
of the attribute is a string containing the numbers of the selected lines.
The numbers are separated by blank spaces. Therefore, if the attribute value
is 3 5 6, the third, fifth, and sixth item are currently selected, or will
be selected if SetData is executed. See <link linkend="mthConnectEntryLine">ConnectEntryLine</link> for a more
detailed description. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example defines a list box with the name of the four seasons.
It then preselects the items Summer and Winter. After execution of the dialog, it parses the value of the attribute.

<programlisting>
<![CDATA[
MyDialog = .ResDialog~new(...)
MyDialog~NoAutoDetection
MyDialog~addListBox(205, ..., "MULTI")
MyDialog~ConnectMultiListBox(205, "ListBox")
seasons.1="Spring"
seasons.2="Summer"
seasons.3="Autumn"
seasons.4="Winter"
do season over seasons
  MyDialog~AddListEntry(205, season)
end
MyDialog~ListBox="2 4"
MyDialog~Execute("SHOWTOP")
selItems = MyDialog~ListBox
do until anItem =""
   parse var selItems anItem selItems
   say "You selected: "seasons.anItem
end
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000274"><title>AddAttribute</title>
<indexterm><primary>AddAttribute</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~AddAttribute(--id--+------------------+--)------><
                                  +-,--attributeName-+


]]>
</programlisting>

<para>The AddAttribute method adds an attribute to the
dialog object. The attribute is associated with the dialog control <emphasis role="italic">id</emphasis>. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is for internal use only.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog control.
</para></listitem></varlistentry>
<varlistentry><term>attributeName</term>
<listitem><para>The name you want to give to the attribute. This name must comply with
the conventions of Object Rexx for valid symbols. AddAttribute checks whether the argument is valid. In case of an invalid argument,
an attribute with the name DATA<emphasis role="italic">id</emphasis> is created, where <emphasis role="italic">id</emphasis> is
the value of the first argument. This method automatically removes blanks,
ampersands (&amp;), and colons (:).
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The first and second lines generate the attributes <computeroutput>Add</computeroutput> and <computeroutput>List all items</computeroutput>. The third line generates the assembled attribute <computeroutput>DATA34</computeroutput> because <computeroutput>ListALLitems</computeroutput> already exists. The fourth line
creates attribute <computeroutput>DATA35</computeroutput> because <computeroutput>Update+Refresh</computeroutput> is not
a valid symbol name.

<programlisting>
<![CDATA[
self~AddAttribute(32, "&Add")
self~AddAttribute(33, "List all items")
self~AddAttribute(34, "ListALLitems:")
self~AddAttribute(35, "Update+Refresh")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="getsetmeth"><title>Get and Set Methods</title>
<indexterm><primary>get and set methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<para>Get methods are used to retrieve the data from all or individual controls
of a dialog. Set methods are used to set the values of all or individual controls,
without changing the associated Object Rexx attributes.</para>

<section id="h000269"><title>GetData</title>
<indexterm><primary>GetData</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetData-----------------------------------------><


]]>
</programlisting>

<para>The GetData method receives data from the Windows dialog
and copies it to the associated object attributes. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example continues the <link linkend="h000264">SetData</link> example:

<programlisting>
<![CDATA[
     .
     .
     .
MyDialog~ConnectEntryLine(102, "ENTRYLINE_1")
MyDialog~ConnectCheckBox(201, )
MyDialog~ConnectListbox(203, "LISTBOX_DAYS")
     .
     .
     .
/* process the dialog */
     .
     .
     .
MyDialog~GetData            /* retrieve dialog item value */
say MyDialog~ENTRYLINE_1
say MyDialog~DATA201
say MyDialog~LISTBOX_DAYS
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000264"><title>SetData</title>
<indexterm><primary>SetData</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetData-----------------------------------------><


]]>
</programlisting>

<para>
  The SetData method transfers the values of the dialog object attributes, that are connected to dialog
  items, to the Windows dialog controls. See the section, <link linkend="man0002">Connect Attribute
  Methods</link> for a discussion of connecting object attributes to the underlying dialog controls.
</para>
<para>
  <emphasis role="bold">Note</emphasis> that this method transfers the data for every connected
  attribute. This may not always be desirable. For instance the focused node of a tree-view control may
  be changed. For finely grained control of which values are transfered the programmer should use the
  <link linkend="h000584">setValue</link>() or <link linkend="h000593">setAttribute</link>() methods.
  Both of these methods transfer the value of a single object attribute that is specified by the
  programmer.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem>
  <para>
    Dialog items with ID 102, 201 and 203 are connected to the attributes
    <computeroutput>ENTRYLINE_1</computeroutput>, <computeroutput>DATA201</computeroutput>, and
    <computeroutput>LISTBOX_DAYS</computeroutput>. Attribute <computeroutput>DATA201</computeroutput> is
    generated by the ConnectCheckBox method. Then the attributes are initialized with some values. This
    does not change the dialog window, unless you run the SetData method.
<programlisting>
<![CDATA[
     .
     .
     .
MyDialog~ConnectEntryLine(102, "ENTRYLINE_1")
MyDialog~ConnectCheckBox(201,)
MyDialog~ConnectListbox(203, "LISTBOX_DAYS")
     .
     .
     .
MyDialog~ENTRYLINE_1="Memorial Day"
MyDialog~DATA201=1
MyDialog~LISTBOX_DAYS="Monday"

MyDialog~SetData
]]>
</programlisting>
  </para>
</listitem></varlistentry>
</variablelist>
</section>

<section id="h001348"><title>ItemTitle</title>
<indexterm><primary>ItemTitle</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ItemTitle(--id--)-------------------------------><


]]>
</programlisting>

<para>The ItemTitle method returns the title of the given
dialog item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog item.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000255"><title>SetStaticText</title>
<indexterm><primary>SetStaticText</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetStaticText(--id--,--aString--)---------------><


]]>
</programlisting>

<para>The SetStaticText method changes the text of a
static text control. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the static text control for which you want to change the text.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The new text for the static text control.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000466"><title>GetEntryLine</title>
<indexterm><primary>GetEntryLine</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetEntryLine(--id--)----------------------------><


]]>
</programlisting>

<para>The GetEntryLine method returns the value of the
given entry line. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the entry line.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000530"><title>SetEntryLine</title>
<indexterm><primary>SetEntryLine</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetEntryLine(--id--,--aString--)----------------><


]]>
</programlisting>

<para>The SetEntryLine method puts the value of a string
into an entry line. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the entry line.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The value to be assigned to the entry line.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>Assume that three methods are connected to push buttons. The SetToDefault
method overrides the value in the Windows dialog entry line 234 with the
value 256 but does not change its associated attribute. Using SetEntryLine
has the same effect as a change to the entry line made by the user. The associated
attribute in the Object Rexx object (<computeroutput>DATA234</computeroutput>) still has the original
value. Thus it is possible to undo the changes or confirm them.

<programlisting>
<![CDATA[
::method SetToDefault
   self~SetEntryLine(234, "256")

::method AcceptValues
   self~GetAttrib(DATA234)

::method UndoChanges
   self~SetAttrib(DATA234)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000474"><title>GetListLine</title>
<indexterm><primary>GetListLine</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetListLine(--id--)-----------------------------><


]]>
</programlisting>

<para>The GetListLine method returns the value of the
currently selected list item. If you need the index of the item, use the <link linkend="h000417">GetCurrentListIndex</link> method. If no item is selected, a null string
is returned. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000539"><title>SetListLine</title>
<indexterm><primary>SetListLine</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetListLine(--id--,--aString--)-----------------><


]]>
</programlisting>

<para>The SetListLine method assigns the value of a string
to the list box. Thus the item with the value of <emphasis role="italic">aString</emphasis> becomes
selected. The first item is selected if the string is not found in the list
box. This method does not apply to a multiple selection list box (see <link linkend="h000575">SetMultiList</link>). </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The value of the item to be selected.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example selects item &quot;New York&quot; in list box 232:

<programlisting>
<![CDATA[
MyBaseDialog~SetListLine(232, "New York")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000506"><title>GetMultiList</title>
<indexterm><primary>GetMultiList</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetMultiList(--id--)----------------------------><


]]>
</programlisting>

<para>The GetMultiList method can be applied
to a multiple-selection list box. It returns a string containing the indexes
of up to 1000 selected items. The numbers are separated by blanks. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the multiple-selection list box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example shows how to handle a multiple-selection list
box. It parses the returned string as long as it contains an index.

<programlisting>
<![CDATA[
selLines = MyDialog~GetMultiList(555)
do until selLines = ""
   parse var selLines aLine selLines
   say aLine
end
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000575"><title>SetMultiList</title>
<indexterm><primary>SetMultiList</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetMultiList(--id--,--data--)-------------------><


]]>
</programlisting>

<para>The SetMultiList method selects one or more lines
in a multiple-selection list box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the multiple-selection list box.
</para></listitem></varlistentry>
<varlistentry><term>data</term>
<listitem><para>The indexes (separated by blanks) of the lines to be selected.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example selects the lines 2, 5, and 6 of list box 345:

<programlisting>
<![CDATA[
MyDialog~SetMultiList(345, "2 5 6")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000482"><title>GetComboLine</title>
<indexterm><primary>GetComboLine</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetComboLine(--id--)----------------------------><


]]>
</programlisting>

<para>The GetComboLine method returns the value of the
currently selected list item of a combo box. If you need the index of the
item, use the <link linkend="h000344">GetCurrentComboIndex</link> method. If no item is selected,
a null string is returned. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000548"><title>SetComboLine</title>
<indexterm><primary>SetComboLine</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetComboLine(--id--,--aString--)----------------><


]]>
</programlisting>

<para>The SetComboLine method assigns a string to the
given combo box. Thus the item with the value of <emphasis role="italic">aString</emphasis> becomes
selected. If <emphasis role="italic">aString</emphasis> is not found in the
combo box, then the first item is selected. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The value of the item to be selected.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000498"><title>GetRadioButton</title>
<indexterm><primary>GetRadioButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetRadioButton(--id--)--------------------------><


]]>
</programlisting>

<para>The GetRadioButton method returns 1 if the radio
button is selected, 0 if it is not selected. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the radio button.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000566"><title>SetRadioButton</title>
<indexterm><primary>SetRadioButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetRadioButton(--id--,--data--)-----------------><


]]>
</programlisting>

<para>The SetRadioButton method marks the radio button
if the given data value is 1, and removes the mark if the value is 0. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the radio button.
</para></listitem></varlistentry>
<varlistentry><term>data</term>
<listitem><para>1 to select the button or 0 to deselect it.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000490"><title>GetCheckBox</title>
<indexterm><primary>GetCheckBox</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetCheckBox(--id--)-----------------------------><


]]>
</programlisting>

<para>The GetCheckBox method returns the value of a check
box: 1 if the check box is selected (has a check mark), 0 if it is not selected. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the check box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000557"><title>SetCheckBox</title>
<indexterm><primary>SetCheckBox</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetCheckBox(--id--,--data--)--------------------><


]]>
</programlisting>

<para>The SetCheckBox method puts a check mark in the
check box if the given data value is 1 and removes the check mark if the value
is 0. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the check box.
</para></listitem></varlistentry>
<varlistentry><term>data</term>
<listitem><para>The value 1 to check the box or 0 to remove the check mark.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000514"><title>GetValue</title>
<indexterm><primary>GetValue</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetValue(--id--)--------------------------------><


]]>
</programlisting>

<para>The GetValue method gets the value of a dialog
item, regardless of its type. The item must have been connected before. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog item.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000584"><title>SetValue</title>
<indexterm><primary>SetValue</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetValue(--id--,--dataString--)-----------------><


]]>
</programlisting>

<para>The SetValue method sets the value of a dialog
item. You do not have to know what kind of item it is. The dialog item must
have been connected before. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog item.
</para></listitem></varlistentry>
<varlistentry><term>dataString</term>
<listitem><para>The value that is assigned to the item. It must be a valid value.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example sets dialog item 123 to (string) value &quot;1
2 3&quot;. This is meaningful if 123 is an entry field, or if it is a list
box that contains the line &quot;1 2 3&quot;. However, it is an error to apply
this against a check box.

<programlisting>
<![CDATA[
MyDialog~SetValue(123, "1 2 3")
]]>
</programlisting>

<note><title>Note</title><para>
If it is a multiple-selection list box, the SetValue
method does not look for an item with &quot;1 2 3&quot; as  value but highlights
the first, second, and third line.
</para></note>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000522"><title>GetAttrib</title>
<indexterm><primary>GetAttrib</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetAttrib(--attributeName--)--------------------><


]]>
</programlisting>

<para>The GetAttrib method assigns the value of a dialog
item to the associated Object Rexx attribute. It does not return a value. You do
not have to know the ID or the type of the dialog item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>attributeName</term>
<listitem><para>The name of the attribute.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example shows how to get the data value of a dialog item
without knowing its ID:

<programlisting>
<![CDATA[
MyDialog~GetAttrib("FirstName")
if MyDialog~FirstName\="" then ...
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000593"><title>SetAttrib</title>
<indexterm><primary>SetAttrib</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetAttrib(--attributeName--)--------------------><


]]>
</programlisting>

<para>The SetAttrib method copies the value of an attribute
to the associated dialog item. You do not have to know the ID or the type
of the dialog item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>attributeName</term>
<listitem><para>The name of the attribute.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example copies the value of the attribute DATA101 to the associated dialog item:

<programlisting>
<![CDATA[
MyBaseDialog~SetAttrib("DATA101")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000289"><title>SetDataStem</title>
<indexterm><primary>SetDataStem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetDataStem(--dataStem.--)----------------------><


]]>
</programlisting>

<para>The SetDataStem method sets all Windows dialog
items to the values within the given stem; the suffixes of the stem variable
are the dialog IDs. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>dataStem.</term>
<listitem><para>A stem variable containing initialization data. Remember the trailing
period.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example initializes the dialog items with ID 21, 22, and
23:

<programlisting>
<![CDATA[
     .
     .
     .
dlgStem.21="Windows 95"
dlgStem.22="0"
dlgStem.23="1 2 3"
self~SetDataStem(dlgStem.)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000298"><title>GetDataStem</title>
<indexterm><primary>GetDataStem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetDataStem(--dataStem.--)----------------------><


]]>
</programlisting>

<para>The GetDataStem method gets the values of all dialog
items and copies them to the given stem. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>dataStem.</term>
<listitem><para>The name of a stem variable to which the data is returned.  Remember
the trailing period.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="man0032"><title>Standard Event Methods</title>
<indexterm><primary>standard event methods</primary></indexterm>
<para>The following methods are abstract methods that are called each time a
push button with ID 1, 2, or 9 is pressed.</para>

<section id="h001444"><title>OK</title>
<indexterm><primary>OK</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~OK----------------------------------------------><


]]>
</programlisting>

<para>The OK method is called in response to a pressed
OK button. It calls <link linkend="h001462">Validate</link> to get its return code.
The default return code is the self~finished attribute,
which is usually 1, in which case the dialog is terminated. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected. You might want to override it in your subclass.
If you do, forward the OK message to the parent class after processing has
finished. Set the self~finished attribute
to 1 or 0 and return it. The dialog continues executing if you return the
value 0. See also <link linkend="h001462">Validate</link>.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example shows how to override the OK method:

<programlisting>
<![CDATA[
::method OK
...
self~ok:super()
self~finished = 1
return self~finished
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001450"><title>Cancel</title>
<indexterm><primary>Cancel</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Cancel------------------------------------------><


]]>
</programlisting>

<para>The Cancel method is called in response to a pressed
Cancel button. The default return code is the self~finished attribute, which is
usually 1, in which case the dialog is terminated. The InitCode attribute is
set to 2 if the dialog is terminated. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected. You might want to override it in your subclass.
If you do, forward the Cancel message to the parent class after processing
has finished. Set the self~finished attribute
to 1 or 0 and return it. The dialog continues executing if you return the
value 0.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001456"><title>Help</title>
<indexterm><primary>Help</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Help--------------------------------------------><


]]>
</programlisting>

<para>The Help method is called in response to a pressed
Help button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected. You might want to override it in your subclass.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001462"><title>Validate</title>
<indexterm><primary>Validate</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Validate----------------------------------------><


]]>
</programlisting>

<para>The Validate method is an abstract method that
is called to determine whether the dialog can be closed. This method is called
by the OK method. The standard implementation is that Validate returns 1 and
the dialog is closed. The dialog is not closed if Validate returns 0. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>The method is designed to be defined in a subclass.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>In the following example Validate checks whether
entry line 203 is empty. If it is empty, Validate returns
0, which indicates that the dialog cannot be closed.

<programlisting>
<![CDATA[
::class MyDialog subclass UserDialog
::method Validate
   if self~GetEntryLine(203) = "" then return 0
   else return 1
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="leavi"><title>Leaving</title>
<indexterm><primary>Leaving</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Leaving-----------------------------------------><


]]>
</programlisting>

<para>The Leaving method is called when the dialog was
closed.</para>
</section>

<section id="h001468"><title>DeInstall</title>
<indexterm><primary>DeInstall</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DeInstall---------------------------------------><


]]>
</programlisting>

<para>The DeInstall method removes the external functions
from the Object Rexx API manager. It should be called at the end of each dialog.
The installed functions are freed when all dialogs are finished.</para>
</section>
</section>

<section id="comboboxmeth"><title>Combo Box Methods</title>
<indexterm><primary>combo box methods</primary></indexterm>
<para>The following methods belong to combo boxes.</para>

<section id="h000307"><title>AddComboEntry</title>
<indexterm><primary>AddComboEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~AddComboEntry(--id--,--aString--)---------------><


]]>
</programlisting>

<para>The AddComboEntry method adds a string to the list
of a combo box. The new item becomes the last one, if the list does not have
the SORT flag set. In the case of a sorted list, the
new item is inserted at the proper position. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of a combo box.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The data to be inserted as a new line.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example adds the new line, <computeroutput>Another item</computeroutput>, to
the list of combo box 103:

<programlisting>
<![CDATA[
MyDialog~AddComboEntry(103, "Another item")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000316"><title>InsertComboEntry</title>
<indexterm><primary>InsertComboEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~InsertComboEntry(--id--,--+-------+--,--string--)-><
                                         +-index-+


]]>
</programlisting>

<para>The InsertComboEntry method inserts a string into
the list of a combo box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index (line number) where you want to insert the new item. If this
argument is omitted, the new item is inserted after the currently selected
item.
</para></listitem></varlistentry>
<varlistentry><term>string</term>
<listitem><para>The data string to be inserted.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>This statement inserts <computeroutput>The new third line</computeroutput> after the second
line into the list of combo box 103:

<programlisting>
<![CDATA[
MyDialog~InsertComboEntry(103, 2, "The new third line")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000326"><title>DeleteComboEntry</title>
<indexterm><primary>DeleteComboEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DeleteComboEntry(--id--,--index--)--------------><


]]>
</programlisting>

<para>The DeleteComboEntry method deletes a string from
the combo box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The line number of the item to be deleted. Use the FindComboEntry method
(see page<link linkend="h000335">FindComboEntry</link>) to retrieve the index of
an item.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example shows a method that deletes the item that is passed
to the method in the form of a text string from combo box 203:

<programlisting>
<![CDATA[
      .
      .
      .
::method DeleteFromCombo
   use arg delStr
   idx = self~FindComboEntry(203, delStr)
   self~DeleteComboEntry(203, idx)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000335"><title>FindComboEntry</title>
<indexterm><primary>FindComboEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~FindComboEntry(--id--,--aString--)--------------><


]]>
</programlisting>

<para>The FindComboEntry method returns the index corresponding
to a given text string in the combo box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The string of which you search the index in the combo box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>See <link linkend="h000326">DeleteComboEntry</link> for an example.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="gcem"><title>GetComboEntry</title>
<indexterm><primary>GetComboEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetComboEntry(--id--,--index--)-----------------><


]]>
</programlisting>

<para>The GetComboEntry method returns the string at
index of the combo box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index of the list entry to be retrieved
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
<![CDATA[
if dlg~GetComboEntry(203,5)="JOHN"
then ...
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000336"><title>GetComboItems</title>
<indexterm><primary>GetComboItems</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetComboItems(--id--)---------------------------><


]]>
</programlisting>

<para>The GetComboItems method returns the number of
items in the combo box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000344"><title>GetCurrentComboIndex</title>
<indexterm><primary>GetCurrentComboIndex</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetCurrentComboIndex(--id--)--------------------><


]]>
</programlisting>

<para>The GetCurrentComboIndex method returns the index
of the currently selected item within the list. See <link linkend="h000482">GetComboLine</link> for
information on how to retrieve the selected combo box item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example displays the line number of the currently selected
combo box item within entry line 240:</para>

<programlisting>
<![CDATA[
::class MyListDialog subclass UserDialog
     .
     .
     .
::method Init
   self~Init:super
   self~ConnectList(230, "ListSelected")
     .
     .
     .
::method ListSelected
   line = self~GetCurrentComboIndex(230)
   SetEntryLine(240, line)
]]>
</programlisting>
<para>Method <computeroutput>ListSelected</computeroutput> is called
each time the selected item within the combo box changes.</para>
</listitem></varlistentry>
</variablelist>
</section>

<section id="h000345"><title>SetCurrentComboIndex</title>
<indexterm><primary>SetCurrentComboIndex</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetCurrentComboIndex(--id--+----------+--)------><
                                          +-,--index-+


]]>
</programlisting>

<para>The SetCurrentComboIndex method selects the item
with the given index within the list. If called without an index, all items
in the list are deselected. See <link linkend="h000548">SetComboLine</link> for information on
how to select a combo box item using a data value. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index within the combo box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000352"><title>ChangeComboEntry</title>
<indexterm><primary>ChangeComboEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ChangeComboEntry(--id--,--+-------+--,--aString--)-><
                                         +-index-+


]]>
</programlisting>

<para>The ChangeComboEntry method changes the value of
a given entry in a combo box to a new string. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index number of the item you want to replace. To retrieve the index,
use the FindComboEntry or GetCurrentComboIndex method (see page <link linkend="h000335">FindComboEntry</link> or <link linkend="h000344">GetCurrentComboIndex</link>).
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The new text.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>In the following example, method <computeroutput>ChangeButtonPressed</computeroutput> changes
the currently selected line of combo box 230 to the value in entry line 250:

<programlisting>
<![CDATA[
     .
     .
     .
::method ChangeButtonPressed
   idx = self~GetCurrentComboEntry(230)
   str = self~GetEntryLine(250)
   self~ChangeComboEntry(230, idx, str)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000362"><title>ComboAddDirectory</title>
<indexterm><primary>ComboAddDirectory</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ComboAddDirectory(--id--,--drvpath--,------------->

      +---------------+
      V               |
>--"----+-READWRITE-+-+--"--)-----------------------------------><
        +-READONLY--+
        +-HIDDEN----+
        +-SYSTEM----+
        +-DIRECTORY-+
        +-ARCHIVE---+


]]>
</programlisting>

<para>The ComboAddDirectory method adds all or selected
file names in the given directory to the combo box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
<varlistentry><term>drvpath</term>
<listitem><para>The drive, path, and name pattern.
</para></listitem></varlistentry>
<varlistentry><term>fileAttributes</term>
<listitem><para>Specify the file attributes that the files must have in order to be
added:
<variablelist>
<varlistentry><term>READWRITE</term>
<listitem><para>Normal read/write files (same as none).
</para></listitem></varlistentry>
<varlistentry><term>READONLY</term>
<listitem><para>Files that have the read-only bit.
</para></listitem></varlistentry>
<varlistentry><term>HIDDEN</term>
<listitem><para>Files that have the hidden bit.
</para></listitem></varlistentry>
<varlistentry><term>SYSTEM</term>
<listitem><para>Files that have the system bit.
</para></listitem></varlistentry>
<varlistentry><term>DIRECTORY</term>
<listitem><para>Files that have the directory bit.
</para></listitem></varlistentry>
<varlistentry><term>ARCHIVE</term>
<listitem><para>Files that have the archive bit.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example fills the combo box list with the names of all
read/write files with extension .REX in the given directory:

<programlisting>
<![CDATA[
MyDialog~ComboAddDirectory(203, drive":\"path"\*.rex", "READWRITE")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000372"><title>ComboDrop</title>
<indexterm><primary>ComboDrop</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ComboDrop(--id--)-------------------------------><


]]>
</programlisting>

<para>The ComboDrop method deletes all items from the
list of the given combo box.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the combo box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="listboxmeth"><title>List Box Methods</title>
<indexterm><primary>list box methods</primary></indexterm>
<para>The following methods deal with list boxes.</para>

<section id="getlistwidth"><title>GetListWidth</title>
<indexterm><primary>GetListWidth</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetListWidth(--id--)----------------------------><


]]>
</programlisting>

<para>The GetListWidth method returns the scrollable
width of a list box, in dialog units. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box of which you want to know the scrollable width.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The width of the scrollable area of the list box, in dialog units.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="setlistwidth"><title>SetListWidth</title>
<indexterm><primary>SetListWidth</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetListWidth(--id--,--scrollwidth--)------------><


]]>
</programlisting>

<para>The SetListWidth method sets the scrollable width
of a list box, in dialog units. If the scrollable width is greater than the
width of the list box and the &quot;HSCROLL&quot; (WS_HSCROLL in the resource
script) style is defined for the list box (see <link linkend="mthAddListBox">addListBox</link>), a
horizontal scroll bar is displayed. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box for which you want to set the scrollable width.
</para></listitem></varlistentry>
<varlistentry><term>scrollwidth</term>
<listitem><para>The width of the scrollable area of the list box, in dialog units.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="setlistcolumnwidth"><title>SetListColumnWidth</title>
<indexterm><primary>SetListColumnWidth</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetListColumnWidth(--id--,--columnwidth--)------><


]]>
</programlisting>

<para>The SetListColumnWidth method sets the width of
all columns in a list box, in dialog units.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box for which you want to set the column width.
</para></listitem></varlistentry>
<varlistentry><term>columnwidth</term>
<listitem><para>The width of the columns in the list box, in dialog units.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000380"><title>AddListEntry</title>
<indexterm><primary>AddListEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~AddListEntry(--id--,--aString--)----------------><


]]>
</programlisting>

<para>The AddListEntry method adds a string to the given
list box. See also <link linkend="h000307">AddComboEntry</link>. The line is added at the end (by
default), or in sorted order if the list box was defined with the sorted flag. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of a list box.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The data to be inserted as a new line.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000389"><title>InsertListEntry</title>
<indexterm><primary>InsertListEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~InsertListEntry(--id--,--+-------+--,--aString--)-><
                                        +-index-+


]]>
</programlisting>

<para>The InsertListEntry method inserts a string into
the given list box. See also <link linkend="h000316">InsertComboEntry</link>. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index (line number starting with 1) of the item after which the
new item is inserted. If this argument is omitted, the new item is inserted
after the currently selected item.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The text string to be inserted.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000399"><title>DeleteListEntry</title>
<indexterm><primary>DeleteListEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DeleteListEntry(--id--,--index--)---------------><


]]>
</programlisting>

<para>The DeleteListEntry method deletes an item from
a list box. See also <link linkend="h000326">DeleteComboEntry</link>. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The line number of the item to be deleted. Use <link linkend="h000408">FindListEntry</link> to
retrieve the index of an item. If this argument is omitted, the currently
selected item is deleted.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000408"><title>FindListEntry</title>
<indexterm><primary>FindListEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~FindListEntry(--id--,--aString--)---------------><


]]>
</programlisting>

<para>The FindListEntry method returns the index of the
given string within the given list box. The first item has index 1, the second
has index 2, and so forth. If the list box does not contain the string, 0
is returned. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The item text you are looking for.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example shows a method that adds the contents of an entry
line (214) to the list box (215) if no item with the same value is already
contained in it:

<programlisting>
<![CDATA[
      .
      .
      .
::method PutEntryInList
   str = self~GetEntryLine(214)
   if self~FindListEntry(215, str) = 0 then
      self~AddListEntry(215, str)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="glem"><title>GetListEntry</title>
<indexterm><primary>GetListEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetListEntry(--id--,--index--)------------------><


]]>
</programlisting>

<para>The GetListEntry method returns the string at index of the list. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index of the list entry to be retrieved.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
<![CDATA[
if dlg~GetListEntry(203,5)="JOHN"
then ...
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000409"><title>GetListItems</title>
<indexterm><primary>GetListItems</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetListItems(--id--)----------------------------><


]]>
</programlisting>

<para>The GetListItems method returns the number of items
in the list box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="getlistitemheight"><title>GetListItemHeight</title>
<indexterm><primary>GetListItemHeight</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetListItemHeight(--id--)-----------------------><


]]>
</programlisting>

<para>The GetListItemHeight method returns the height
of the items in a list box, in dialog units. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box of which you want to know the item height.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The height of the list box items, in dialog units.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="setlistitemheight"><title>SetListItemHeight</title>
<indexterm><primary>SetListItemHeight</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetListItemHeight(--id--,--itemheight--)--------><


]]>
</programlisting>

<para>The SetListItemHeight method sets the height for
all items in a list box, in dialog units. It determines the space between
the individual list box items.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box for which you want to set the item height.
</para></listitem></varlistentry>
<varlistentry><term>itemheight</term>
<listitem><para>The height of the items in the list box, in dialog units.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>A number smaller than 0 if the height that you specify is not valid.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000417"><title>GetCurrentListIndex</title>
<indexterm><primary>GetCurrentListIndex</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetCurrentListIndex(--id--)---------------------><


]]>
</programlisting>

<para>The GetCurrentListIndex method returns the index
of the currently selected list box item, or 0 if no item is selected. See <link linkend="h000474">GetListLine</link> for information on how to retrieve the selected list box
item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000418"><title>SetCurrentListIndex</title>
<indexterm><primary>SetCurrentListIndex</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetCurrentListIndex(--id--+----------+--)-------><
                                         +-,--index-+


]]>
</programlisting>

<para>The SetCurrentListIndex selects the item with the
given index in the list. If called without an index, all items in the list
are deselected. See <link linkend="h000539">SetListLine</link> for information on how to select
a list box item using a data value. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index within the list box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000425"><title>ChangeListEntry</title>
<indexterm><primary>ChangeListEntry</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ChangeListEntry(--id--,--+-------+--,--aString--)-><
                                        +-index-+


]]>
</programlisting>

<para>The ChangeListEntry method changes the contents
of a line in a list box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>index</term>
<listitem><para>The index of the item that you want to replace. If this argument is
omitted, the currently selected item is changed.
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The new text of the item.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000435"><title>SetListTabulators</title>
<indexterm><primary>SetListTabulators</primary></indexterm>
<programlisting>
<![CDATA[
                                          +-,---+
                                          V     |
>>-aBaseDialog~SetListTabulators(--id--,----tab-+--)-----------><


]]>
</programlisting>

<para>The SetListTabulators method sets the tabulators
for a list box. Thus you can use items containing tab characters ("09"x),
which is useful for formatting the list in more than one column. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
<varlistentry><term>tab</term>
<listitem><para>The positions of the tabs relative to the left edge of the list box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example creates a four-column list and adds a tab-formatted
row to the list. The tabulator positions are 10, 20, and 30.

<programlisting>
<![CDATA[
MyDialog~SetListTabulators(102, 10, 20, 30)
MyDialog~AddListEntry(102, var1  "09"x
var2  "09"x  ,
                           var3  "09"x  var4)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000448"><title>ListAddDirectory</title>
<indexterm><primary>ListAddDirectory</primary></indexterm>
<programlisting>
<![CDATA[
                                                        +---------------+
                                                        V               |
>>-aBaseDialog~ListAddDirectory(--id--,--drvPath--,--"----+-READWRITE-+-+--"--)-><
                                                          +-READONLY--+
                                                          +-HIDDEN----+
                                                          +-SYSTEM----+
                                                          +-DIRECTORY-+
                                                          +-ARCHIVE---+


]]>
</programlisting>

<para>The ListAddDirectory method adds all or selected
file names of a given directory to the list box. See <link linkend="h000362">ComboAddDirectory</link> for
more information.</para>
</section>

<section id="h000458"><title>ListDrop</title>
<indexterm><primary>ListDrop</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ListDrop(--id--)-------------------------------><


]]>
</programlisting>

<para>The ListDrop method removes all items from the
list box. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="man0020"><title>Scroll Bar Methods</title>
<indexterm><primary>scroll bar methods</primary></indexterm>
<para>The following methods are used to set or get the behavior of a scroll bar.
You can connect scroll bars with numerical entry fields to edit the value
with the mouse.</para>

<section id="h000782"><title>GetSBRange</title>
<indexterm><primary>GetSBRange</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetSBRange(--id--)-----------------------------><


]]>
</programlisting>

<para>The GetSBRange method returns the range of a scroll
bar control. It returns the two values (minimum and maximum) in one string,
separated by a blank. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the scroll bar.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example demonstrates how to get the minimum and the maximum
values of the scroll bar:

<programlisting>
<![CDATA[
     .
     .
     .
::method DumpSBRange
SBrange = self~GetSBRange(234)
parse var SBrange SBmin SBmax
say SBmin " - " SBmax
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000770"><title>SetSBRange</title>
<indexterm><primary>SetSBRange</primary></indexterm>
<programlisting>
<![CDATA[
                                                   +-1------+
>>-aBaseDialog~SetSBRange(--id--,--min--,--max--,--+--------+--)-><
                                                   +-redraw-+


]]>
</programlisting>

<para>The SetSBRange method sets the range of a scroll
bar control. It sets the minimum and maximum values. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is not intended to be used outside of the BaseDialog class.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of a scroll bar control.
</para></listitem></varlistentry>
<varlistentry><term>min</term>
<listitem><para>The minimum value.
</para></listitem></varlistentry>
<varlistentry><term>max</term>
<listitem><para>The maximum value.
</para></listitem></varlistentry>
<varlistentry><term>redraw</term>
<listitem><para>A flag indicating whether (1) or not (0) the scroll bar should be redrawn.
The default is 1.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example allows the scroll bar to take values between 1
and 10:

<programlisting>
<![CDATA[
MyDialog~SetSBRange(234, 1, 10, 1)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000790"><title>GetSBPos</title>
<indexterm><primary>GetSBPos</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetSBPos(--id--)-------------------------------><


]]>
</programlisting>

<para>The GetSBPos method returns the current value of
a scroll bar control. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the scroll bar.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000791"><title>SetSBPos</title>
<indexterm><primary>SetSBPos</primary></indexterm>
<programlisting>
<![CDATA[
                                         +-1------+
>>-aBaseDialog~SetSBPos(--id--,--pos--,--+--------+--)--------><
                                         +-redraw-+


]]>
</programlisting>

<para>The SetSBPos method sets the current value of a
scroll bar control. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>pos</term>
<listitem><para>The value to which you want to set the scroll bar. It must be within
the defined range.
</para></listitem></varlistentry>
<varlistentry><term>redraw</term>
<listitem><para>A flag indicating whether (1) or not (0) the scroll bar should be redrawn.
The default is 1.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000816"><title>CombineELwithSB</title>
<indexterm><primary>CombineELwithSB</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~CombineELwithSB(--elid--,--sbid--+-------------------------+--)-><
                                                +-,--+------+--+--------+-+
                                                     +-step-+  +-,--pos-+


]]>
</programlisting>

<para>The CombineELwithSB method connects an entry line
with a scroll bar such that each time the slider of the scroll bar is moved,
the value of the entry field is changed. This method must be used in a method
registered with <link linkend="h000802">ConnectScrollBar</link>. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>elid</term>
<listitem><para>The ID of the entry line.
</para></listitem></varlistentry>
<varlistentry><term>sbid</term>
<listitem><para>The ID of the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>step</term>
<listitem><para>The size of one step.  If, for example, step is
3 and the current position is 4, the next position is 7.
</para></listitem></varlistentry>
<varlistentry><term>pos</term>
<listitem><para>If the step value is zero, this sets the position
of the scroll bar and entry line. Use it in the method registered for drag.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example continues the example of ConnectScrollBar. In the registered methods an entry line (251) is combined with the
scroll bar (255).

<programlisting>
<![CDATA[
::method Increase
self~CombineELwithSB(251,255,+20)
::method Decrease
self~CombineELwithSB(251,255,-20)
::method Drag
use arg wparam, lparam                  /* wparam=position */
self~CombineELwithSB(251,255,0,wparam)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="detersb"><title>DetermineSBPosition</title>
<indexterm><primary>DetermineSBPosition</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DetermineSBPosition(--id--,--posdata--+----------------------------+--)-><
                                                     +-,--+--------+--+---------+-+
                                                          +-single-+  +-,--page-+


]]>
</programlisting>

<para>The DetermineSBPosition method calculates and sets
the new scroll bar position based on the position data retrieved from the
scroll bar and the step information.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>posdata</term>
<listitem><para>The position information sent with the connected scroll bar event.
</para></listitem></varlistentry>
<varlistentry><term>single</term>
<listitem><para>This number is added (or subtracted if negative) to the current position
for a single step. If omitted, the single step size is 1.
</para></listitem></varlistentry>
<varlistentry><term>page</term>
<listitem><para>This number is added (or subtracted if negative) to the current position
for a page step. If omitted, the page step size is 10.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The new scroll bar position.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example demonstrates how to update the scroll bar position.
Each time the ScrollBarEventHandler is called by an event for scroll bar SB_SIZE,
the position of the scroll bar is calculated and updated. <computeroutput>posdata</computeroutput> is
sent along with the scroll bar event.

<programlisting>
<![CDATA[
   /* Method ScrollBarEventHandler is connected to item SB_SIZE */
::method ScrollBarEventHandler
    use arg posdata, sbwnd
    pos = self~DetermineSBPosition("SB_SIZE",posdata,1,25)
    return pos

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="man0024"><title>Methods to Query Operating System Values</title>
<indexterm><primary>methods for handles, sizes, and positions</primary></indexterm>
<indexterm><primary>methods to query OS values</primary></indexterm>
<para>The methods in this section return information known to, or used by, the
operating system when it works with dialogs or dialog controls.  This includes
things like window handles, window sizes, and window positions.  It also
includes things like the width of a scroll bar or the number of monitors
attached to the system.
</para>

<section id="mthGetSelf"><title>GetSelf</title>
<indexterm><primary>GetSelf</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetSelf----------------------------------------><


]]>
</programlisting>

<para>The GetSelf method returns the handle of the Windows Dialog associated
with the ooDialog dialog instance. A handle is a unique reference to a
particular Windows object. Handles are used within some of the methods to work
on a specific Windows object.
</para>
<note><title><emphasis role="bold">Note</emphasis></title><para>
Prior to ooRexx 3.2.0, the <computeroutput>GetSelf</computeroutput> method was
not documented.  The <link linkend="h000086">Get</link> method was documented as
if it were the <computeroutput>GetSelf</computeroutput> method. The
<computeroutput>Get</computeroutput> method returns the handle to the most
recently created dialog.  In an application with more than one dialog this may
not be the same as the Windows dialog associated with the instance object the
programmer is working with.
</para></note>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>Below is an example demonstrating these Windows handles and how
they are related.  Assume <computeroutput>showHandles</computeroutput> is a
method of a subclass of BaseDialog and that staticDlg is a saved reference to
another ooDialog object and that the static dialog was just created.  The
<computeroutput>showHandles</computeroutput> method is connected to a push
button and then displays the handles when the user clicks that button.
<programlisting> <![CDATA[
::method showHandles
  expose staticDlg

  hwndTop = self~get
  hwndMyDialogHandle = self~dlgHandle
  hwndMySelf = self~getSelf
  hwndStatic = staticDlg~dlgHandle
  say "Top dialog:      " hwndTop
  say "Self (dlgHandle):" hwndMyDialogHandle
  say "Self (getSelf):  " hwndMySelf
  say "Static dialog:   " hwndStatic

]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Output:</emphasis></term>
<listitem><para>The above might write to the console something like the following:
<programlisting>
<![CDATA[
  Top dialog:       787096
  Self (dlgHandle): 4522228
  Self (getSelf):   4522228
  Static dialog:    787096
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000086"><title>Get</title>
<indexterm><primary>Get</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Get--------------------------------------------><


]]>
</programlisting>

<para>The <computeroutput>Get</computeroutput> method returns the handle of the
Windows Dialog associated with the top ooDialog dialog. A handle is a unique
reference to a particular Windows object. Handles are used within some of the
methods to work on a specific Windows object.
</para>
<note><title>Note</title><para>
If more than one ooDialog exists, the top dialog and the dialog whose method is
executing may not be the same.  When more than one dialog exists, the top dialog
is the one that was created last.
</para></note>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>Below is an example demonstrating that the top dialog and the
executing dialog may not be the same.  Assume display is a method of a subclass
of BaseDialog and that staticDlg is a saved reference to another ooDialog
object.
<programlisting>
<![CDATA[
::method display
  expose staticDlg

  hwndTop = self~get
  hwndSelf = self~dlgHandle
  hwndStatic = staticDlg~dlgHandle
  say "Top dialog:   " hwndTop
  say "Self:         " hwndSelf
  say "Static dialog:" hwndStatic

]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Output:</emphasis></term>
<listitem><para>The above might write to the console something like the following:
<programlisting>
<![CDATA[
  Top dialog:    787096
  Self:          4522228
  Static dialog: 787096
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthGetItem"><title>GetItem</title>
<indexterm><primary>GetItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetItem(--id--+---------+--)-------------------><
                             +-,--hDlg-+


]]>
</programlisting>

<para>The GetItem method returns the handle of a particular
dialog item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog element.
</para></listitem></varlistentry>
<varlistentry><term>hDlg</term>
<listitem><para>The handle of the dialog. If it is omitted, the main dialog handle is
used.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example returns the handle of a push button:

<programlisting>
<![CDATA[
hndPushButton = MyDialog~GetItem(101)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthGetControlID"><title>GetControlID</title>
<indexterm><primary>GetControlID</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetControlID(--hWnd--)-------------------------><


]]>
</programlisting>

<para>Given a valid window handle to a dialog control, the
<computeroutput>GetControlID</computeroutput> method returns the resource ID of
the control.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hWnd</term>
<listitem><para>The window handle of the dialog control.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>Negative values indicate an error.
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The <computeroutput>hWnd</computeroutput> argument is not a
valid window handle.
</para></listitem></varlistentry>
<varlistentry><term>less than -1</term>
<listitem><para>The value is the negated Operating System Error code.  The
absolute value of the return can be used to look up the error reason in the
Windows documentation.
</para></listitem></varlistentry>
<varlistentry><term>other</term>
<listitem><para>The resource ID of the dialog control.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following is a complete working example.  It allows the user
to check a check box with the F2 key and uncheck it with the F3 key.  The F2 and
F3 key press events are connected to the <computeroutput>check</computeroutput>
and <computeroutput>uncheck</computeroutput> methods.  When the user presses the
F2 key, the program determines which control has the focus, uses the returned
window handle to get the control ID, and then uses the ID to check the check
box.  And the same approach if the F3 key is pressed.
</para>
<para>Note that in this dialog, there are only four controls that can have the
focus.  If the OK button has the focus, then nothing is done.  In a more complex
application, the programmer would probably check that the resource ID matches
one of the check boxes instead.
<programlisting> <![CDATA[

/* Simple Grocery List */

  dlg = .SimpleDialog~new
  dlg~constDir[IDC_GB_LIST] = 101
  dlg~constDir[IDC_CB_MILK] = 102
  dlg~constDir[IDC_CB_BREAD] = 103
  dlg~constDir[IDC_CB_FRUIT] = 104
  dlg~constDir[IDC_CB_CEREAL] = 105

  if dlg~initCode = 0 then do
    dlg~create(30, 30, 150, 150, "The Simple Grocery List", "VISIBLE")
    dlg~Execute("SHOWTOP")
    dlg~Deinstall
  end

-- End of entry point.
::requires "oodWin32.cls"

::class SimpleDialog subclass UserDialog inherit AdvancedControls MessageExtensions

::method check

  hWnd = self~getFocus
  id = self~getControlID(hWnd)
  if id == self~constDir[IDOK] then return

  self~getCheckControl(id)~check

::method unCheck

  id = self~getControlID(self~getFocus)
  if id == self~constDir[IDOK] then return

  self~getCheckControl(id)~uncheck

::method defineDialog

  self~addGroupBox(10, 20, 130, 90, "Check Needed Groceries", "", IDC_GB_LIST);
  self~addCheckBox(IDC_CB_MILK, , 30, 35, , , "Milk", "GROUP");
  self~addCheckBox(IDC_CB_BREAD, , 30, 55, , , "Bread", "NOTAB");
  self~addCheckBox(IDC_CB_FRUIT, , 30, 75, , , "Fruit", "NOTAB");
  self~addCheckBox(IDC_CB_CEREAL, , 30, 95, , , "Cereal", "NOTAB");

  self~addButton(IDOK, 105, 120, 35, 15, "OK", , "GROUP")

::method initDialog

  -- We know that the key code for F2 is 113 so we don't need to use the
  -- VirtualKeyCodes class.  We use the 'none' filter so that only a F2 or F3
  -- key press is captured.  (Not Alt-F2, or Shift-F2, etc..)
  self~connectKeyPress(check, 113, "NONE")
  self~connectKeyPress(unCheck, 114, "NONE")

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthGetPos"><title>getPos</title>
<indexterm><primary>GetPos</primary>
<secondary>DialogControl class</secondary></indexterm>
<indexterm><primary>GetPos</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getPos-----------------------------------------------------><

]]>
</programlisting>

<para>
  The getPos method returns the coordinates of the upper left corner a window, either a dialog or a
  dialog control, in dialog units.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The horizontal and vertical position, separated by a blank.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example dialog control:</emphasis></term>
<listitem><para>The following example repositions the tree view control FILES to the
upper left corner of  the window and displays the new position:
<programlisting>
<![CDATA[
obj = MyDialog~GetTreeControl("FILES")
if obj = .Nil then return
obj~Move(1,1)
parse value obj~getPos with x y
say "New horizontal position of window is" x "and new vertical position is" y
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example dialog:</emphasis></term>
<listitem><para>The following example moves the window towards the top left
of the screen.
<programlisting>
<![CDATA[
parse value self~getPos with px py
self~Move(px - 10, py - 10)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000703"><title>GetButtonRect</title>
<indexterm><primary>GetButtonRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetButtonRect(--id--)--------------------------><


]]>
</programlisting>

<para>The GetButtonRect method returns the size and position
of the given button. The four values (left, top, right, bottom) are returned
in one string separated by blanks. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000712"><title>GetWindowRect</title>
<indexterm><primary>GetWindowRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetWindowRect(--hwnd--)------------------------><


]]>
</programlisting>

<para>The GetWindowRect method returns the size and position
of the given window. The four values (left, top, right, bottom) are returned
in one string separated by blanks. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of the window.  There are a number of ways to get the
window handle of objects used in ooDialog. For instance, use the <link
linkend="h000086">GetSelf</link> method to retrieve the window handle of the
dialog instance.  Use the  <link linkend="h000086">Get</link> method to retrieve
the window handle of the most recently created dialog.  To get the window handle
to a dialog control, the <link linkend="mthGetItem">GetItem</link> method can be
used.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthGetSystemMetricsClsBaseDialog"><title>getSystemMetrics <emphasis role="bold">(deprecated)</emphasis></title>
<indexterm>
  <primary>deprecated</primary>
  <secondary>BaseDialog class</secondary>
  <tertiary>getSystemMetrics</tertiary>
</indexterm>
<note><title>Note</title><para>
  This method is deprecated.  It is replaced by the functionally equivalent <link
  linkend="mthGetSystemMetricsClsDlgUtil">getSystemMetrics()</link> method of the .DlgUtil class.  Do not
  use this method in new code. Try to migrate existing code to to the
  <computeroutput>.DlgUtil~getSystemMetrics()</computeroutput> method.  This method may not exist in
  future versions of ooDialog.
</para></note>
</section>

</section>

<section id="man0027"><title>Appearance and Behavior Methods</title>
<indexterm><primary>appearance methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<indexterm><primary>enable methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<indexterm><primary>disable methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<indexterm><primary>hide methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<indexterm><primary>show methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<para>
  The methods listed in this section are related to the appearance or the behavior of the dialog or its
  controls. The section contains methods related to size, position, visibility, and title.
</para>
<para>
  Some of the methods come in two flavors, normal (for example, ShowWindow and fast (for example,
  ShowWindowFast). The fast extension indicates that the method does not redraw the control or window
  immediately. After modifying several items, invoke the Update method (see page <link
  linkend="update">Update</link>) to redraw the dialog.
</para>

<section id="mthGetTextSizeDlgClsPlainBaseDialog"><title>getTextSizeDlg</title>
<indexterm><primary>getTextSizeDlg</primary>
<secondary>PlainBaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getTextSizeDlg(--text--+-------------+--+-------------+--+---------+--)----><
                           +-,-fontname--+  +-,-fontSize--+  +-,-hwnd--+
]]>
</programlisting>

<para>
  Calculates the size, (width and height,) needed to display the given text in the specified font.  The
  size is expressed in dialog units.  To calculate the size in pixels use the <link
  linkend="mthGetTextSizeScreen">getTextSizeScreen</link>() method.
</para>
<para>
  In general, dialog units are only of value in laying out the dialog controls before the underlying
  dialog is created.  Once the underlying dialog is created, it makes more sense to work with pixels.
  Historically, the ooDialog documentation did not make that distinction clear.  In addition, dialog
  units are tied directly to the font used by a dialog.  Therefore, it does not make much sense for
  this method to be an instance method of a dialog control.
</para>
<para>
  The normal use of this method would be to invoke it on a dialog object to help layout the dialog's
  controls prior to the creation of the underlying dialog.  In this use case, the hwnd argument is
  meaningless.  There is no handle to either the dialog window or any of its controls, prior to the
  underlying dialog creation.  There is little point in using a window handle from some other dialog.
  However, to maintain compatibility with previous versions of ooDialog, the hwnd argument remains, and
  the method is still an instance method of a dialog control.
</para>
<para>
  This method replaces the deprecated <link linkend="mthGetTextSize">getTextSize</link>() method.  The
  compatibility restraint is a result of this.  The compatibility restraint makes it harder than
  necessary to document exactly how this method works, because the behavior is different in places if the
  method is inovked on a dialog object or on a dialog control object.
</para>
<para>
  The ooDialog programmer is <emphasis role="bold">strongly</emphasis> encouraged to only inovke this
  method through a dialog object.  Future versions of ooDialog may remove this method from the instance
  methods of the <link linkend="clsDialogControl">DialogControl</link> class.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
    <para>The arguments are:
    <variablelist>
      <varlistentry><term>text</term>
      <listitem>
        <para>
          The string whose size is desired.  If none of the optional arguments are specified then the
          dialog font is used to calculate the size.
        </para>
        <para>
          However, there are some exceptions to this if the method is invoked <emphasis
          role="italic">after</emphasis> the underlying dialog is created.
          <orderedlist>
            <listitem>
            <para>
              If this method is invoked through a dialog control object, then the size is calculated
              using the dialog control font.  This usage is deprecated and the ooDialog programmer is
              <emphasis role="bold">strongly</emphasis> encouraged to not use this method in this manner.
            </para>
            </listitem>
            <listitem>
            <para>
              If the fourth, optional, hwnd argument is used, then the font of that window is used to
              calculate the size. Again, the ooDialog programmer is <emphasis
              role="bold">strongly</emphasis> encouraged to not use this method in this manner.
            </para>
            </listitem>
          </orderedlist>
        </para>
      </listitem></varlistentry>
      <varlistentry><term>fontName</term>
      <listitem>
        <para>
          Optional. The name of the font to use to calculate the size needed for the string.  Use This
          argument when the string will be displayed in a font <emphasis role="bold">different</emphasis>
          than the dialog font.
        </para>
      </listitem></varlistentry>
      <varlistentry><term>fontSize</term>
      <listitem>
        <para>
          Optional. The size of the font named by the fontName argument. If this argument is omitted then
          the defualt font size is used. (Currently the default size is 8.)
        </para>
      </listitem></varlistentry>
      <varlistentry><term>hwnd</term>
      <listitem>
        <para>
          Optional. A valid window handle. The font of this window is used to calculate the text size.
          This argument is always ignored when the fontName argument is specified.  As per the notes
          above the ooDialog programmer is encouraged not to use this argument.
        </para>
      </listitem></varlistentry>
    </variablelist>
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
    <para>
      The size needed for the string is returned in a <link linkend="clsSize">Size</link> object.  The
      size is specified in dialog units.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
    <para>
      This example calculates the size needed to display a message.  It then uses that size to create an
      object that holds the co-ordinates needed to place the text in a dialog.  This is used in
      defineDialog() to add the message text to the dialog.
      <programlisting>
      <![CDATA[
      size = self~getTextSizeDlg(message)
      messageRect = .directory~new
      messageRect~x = 10
      messageRect~y = 10
      messageRect~cx = size~width
      messageRect~cy = size~height
      ...

    ::method defineDialog
      expose message messageRect okRect

      r = messageRect
      self~addText(r~x, r~y, r~cx, r~cy, message)

      ]]>
      </programlisting>
    </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End PlainBaseDialog::getTextSizeDlg() -->


<section id="background"><title>BackgroundColor</title>
<indexterm><primary>BackgroundColor</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~BackgroundColor(--color--)---------------------><


]]>
</programlisting>

<para>The BackgroundColor method sets the background
color of a dialog. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>color</term>
<listitem><para>A color-palette index specifying the background color. For information
on the color numbers, refer to <link linkend="termdef">Definition of Terms</link>.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="show"><title>Show</title>
<indexterm><primary>Show</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
                         +-NORMAL---+
>>-aBaseDialog~Show(--"--+----------+--"--)--------------------><
                         +-DEFAULT--+
                         +-SHOWTOP--+
                         +-HIDE-----+
                         +-MIN------+
                         +-MAX------+
                         +-INACTIVE-+


]]>
</programlisting>

<para>The Show method shows the dialog. It is called by <link
linkend="h000048">Execute</link> or <link linkend="h000057">ExecuteAsync</link>
methods to initially display the dialog.  Once the dialog has been initially
shown, the programmer can use the <computeroutput>Show</computeroutput> to
change the appearance of the dialog.  For instance the dialog can be hidden,
maximized, minimized, etc..
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Argument:</emphasis></term>
<listitem><para>The argument can be one of the following keywords, case is not
significant:
<variablelist>
<varlistentry><term>NORMAL</term>
<listitem><para>Makes the dialog visible with its default window size. This is
the default keyword if the argument is omitted.
</para></listitem></varlistentry>
<varlistentry><term>DEFAULT</term>
<listitem><para><computeroutput>DEFAULT</computeroutput> is an alias for
<computeroutput>NORMAL</computeroutput>. The two keywords are functionally
identical.
</para></listitem></varlistentry>
<varlistentry><term>SHOWTOP</term>
<listitem><para>Shows and makes the dialog the topmost dialog.
</para></listitem></varlistentry>
<varlistentry><term>HIDE</term>
<listitem><para>Makes the dialog invisible.
</para></listitem></varlistentry>
<varlistentry><term>MIN</term>
<listitem><para>Minimizes the dialog.
</para></listitem></varlistentry>
<varlistentry><term>MAX</term>
<listitem><para>Maximizes the dialog.
</para></listitem></varlistentry>
<varlistentry><term>INACTIVE</term>
<listitem><para>Shows the dialog without changing the active window.  When the
<computeroutput>Normal</computeroutput> keyword is used, the dialog is shown and
becomes the active window.  Using the <computeroutput>INACTIVE</computeroutput>
keyword allows the dialog to be shown and let another window remain active.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following statement hides the dialog:

<programlisting>
<![CDATA[
MyDialog~Show("HIDE")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000109"><title>ToTheTop</title>
<indexterm><primary>ToTheTop</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ToTheTop----------------------------------------><


]]>
</programlisting>

<para>The ToTheTop method makes the dialog the topmost
dialog. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example uses the ToTheTop method to make the user aware
of an alarm event:

<programlisting>
aDialog = .MyDialog~new
msg = .Message~new(aDialog, "Remind")
a = .Alarm~new("17:30:00", msg)

::class MyDialog subclass UserDialog
      .
      .
      .
::method Remind
  self~SetStaticText(102, "Don&apos;t forget to go home!")
  self~ToTheTop
</programlisting>

<note><title>Note</title><para>
The Message and Alarm classes
are built-in classes of Object Rexx.
See the <citetitle>Open Object Rexx: Reference</citetitle> for further information.
</para></note>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthEnsureVisible"><title>EnsureVisible</title>
<indexterm><primary>EnsureVisible</primary>
<secondary>BaseDialog class</secondary></indexterm>

<programlisting>
<![CDATA[
>>-aBaseDialog~EnsureVisible-----------------------------------><


]]>
</programlisting>

<para>The <computeroutput>EnsureVisible</computeroutput> method causes the
dialog to reposition itself so that the entire dialog is on the visible screen.
If the entire dialog is already on the visible screen then no action is taken.
</para>
<para>This is useful in a number of situations.  It allows the programmer to
move or resize the dialog and not have to worry that the dialog is off the
screen.  After finishing the move or resizing, the programmer can invoke the
EnsureVisible method and know that the dialog is entirely on the screen.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The method takes no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method always returns 0.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example reads in the previous size and position of
the dialog and then opens the dialog in the position that the user had closed
it.  If the INI file is corrupted, or had been accidently edited, or a number of
other things, it is possible that sizing and positioning the dialog using the
values from the INI file will place the dialog of the screen.  Invoking
<computeroutput>EnsureVisible</computeroutput> will cause the dialog to
reposition itself so that it is completely on the screen, but only if needed.
If the dialog is already completely on the screen, then no action is taken.

<programlisting>
<![CDATA[

  if \.useDefault then
      do
          -- Read oorexxtry.ini position & size the dialog based on its values
          handle = self~getSelf()
          k1 = SysIni('oorexxtry.ini','oorexxtry','k1')
          k2 = SysIni('oorexxtry.ini','oorexxtry','k2')
          k3 = SysIni('oorexxtry.ini','oorexxtry','k3')
          k4 = SysIni('oorexxtry.ini','oorexxtry','k4')
          if k1 = 'ERROR:' | k2 = 'ERROR:' | k3 = 'ERROR:' | k4 = 'ERROR:' then
              nop -- First execution will not find the ini file
          else
              do
                  self~setWindowRect(handle,k1,k2,k3-k1,k4-k2)
                  self~ensureVisible
              end
      end

]]>
</programlisting>

</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthMinimize"><title>Minimize</title>
<indexterm><primary>Minimize</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Minimize----------------------------------------><


]]>
</programlisting>

<para>The <computeroutput>Minimize</computeroutput> method minimizes the dialog
to the taskbar.  This is the identical to the user clicking the minimize button
on the dialog window.  This method will minimize the dialog even if it does not
have the <computeroutput>MINIMIZEBOX</computeroutput> style when it is created.
</para>
<para>This is a convenience method.  It is functionally equivalent to using the
<link linkend="show">Show</link> method with the <computeroutput>MIN
</computeroutput> keyword.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The method takes no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Minimizing was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Minimizing failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>This example creates a secondary dialog to display the contents
of a file.  The secondary dialog is show full screen (maximized.)  At the same
time the parent dialog is minimized to the taskbar.  The complete program
listing is available (see the <link linkend="exampleFileViewer">File
Viewer</link> example.)

<programlisting>
<![CDATA[

::method onView
  expose viewDlg editCntrl

  fileName = editCntrl~getText
  viewDlg = .Viewer~new( , "fileView.h", self, fileName)
  if viewDlg~initCode = 0 then do
    self~disableItem(IDC_PB_VIEW)

    viewDlg~create(30, 30, 170, 180, "Viewer", "MAXIMIZEBOX MINIMIZEBOX")
    viewDlg~popUpAsChild(self, "HIDE", , IDI_DLG_APPICON)

    -- The underlying Windows dialog has to be created before it can be maximized.
    j = SysSleep(.1)

    viewDlg~maximize
    self~minimize
  end

]]>
</programlisting>

</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthMaximize"><title>Maximize</title>
<indexterm><primary>Maximize</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Maximize----------------------------------------><


]]>
</programlisting>

<para>The <computeroutput>Maximize</computeroutput> method maximizes the dialog
on the screen.  This is the identical to the user clicking the maximize button
on the dialog window.  This method will maximize the dialog even if it does not
have the <computeroutput>MAXIMIZEBOX</computeroutput> style when it is created.
</para>
<para>This is a convenience method.  It is functionally equivalent to using the
<link linkend="show">Show</link> method with the <computeroutput>MAX
</computeroutput> keyword.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The method takes no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Maximizing was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Maximizing failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following code snippet minimizes the dialog to the taskbar.
It is used in the FileViewer example.  The complete program listing is available
(see the <link linkend="exampleFileViewer">File Viewer</link> example.)

<programlisting>
<![CDATA[

::method onView
  expose viewDlg editCntrl

  ...

  if viewDlg~initCode = 0 then do
    ...

    viewDlg~maximize
    self~minimize
  end

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthRestore"><title>Restore</title>
<indexterm><primary>Restore</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Restore-----------------------------------------><


]]>
</programlisting>

<para>The <computeroutput>Restore</computeroutput> method restores a minimized
or maximized dialog to its original position.  This is the identical to the user
taking action to restore the dialog window.  The programmer can use this method
to restore a dialog window that he previously minimized or maximized.
</para>
<para>This is a convenience method.  It is functionally equivalent to using the
<link linkend="show">Show</link> method with the <computeroutput>RESTORE
</computeroutput> keyword.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The method takes no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Restoring was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Restoring failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example checks if the parent dialog is minimized
and, if it is, the <computeroutput>Restore</computeroutput> method is used to
show the dialog in the size and position it was prior to being minimized.  The
complete program listing for this code snippet is available (see the <link
linkend="exampleFileViewer">File Viewer</link> example.)

<programlisting>
<![CDATA[
::method cancel
  expose parent
  parent~enableItem(IDC_PB_VIEW)
  if parent~isMinimized then parent~restore
  return self~cancel:super

]]>
</programlisting>

</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthIsMinimized"><title>IsMinimized</title>
<indexterm><primary>IsMinimized</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~IsMinimized-------------------------------------><


]]>
</programlisting>

<para>The <computeroutput>IsMinimized</computeroutput> method is used to check
if a dialog is currently minimized.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The method takes no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>.true</term>
<listitem><para>The dialog is minimized.
</para></listitem></varlistentry>
<varlistentry><term>.false</term>
<listitem><para>The dialog is not minimized.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example checks if the parent dialog is minimized
and, if it is, the <computeroutput>Restore</computeroutput> method is used to
show the dialog in the size and position it was prior to being minimized.  The
complete program listing that this code snippet comes from is available (see the
<link linkend="exampleFileViewer">File Viewer
</link> example.)

<programlisting>
<![CDATA[
::method cancel
  expose parent
  parent~enableItem(IDC_PB_VIEW)
  if parent~isMinimized then parent~restore
  return self~cancel:super

]]>
</programlisting>

</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthIsMaximized"><title>IsMaximized</title>
<indexterm><primary>IsMaximized</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~IsMaximized-------------------------------------><


]]>
</programlisting>

<para>The <computeroutput>IsMaximized</computeroutput> method is used to check
if a dialog is currently maximized.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The method takes no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>.true</term>
<listitem><para>The dialog is maximized.
</para></listitem></varlistentry>
<varlistentry><term>.false</term>
<listitem><para>The dialog is not maximized.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following code snippet would check if the dialog is
maximized and, if it is, restore it to the position and size it was prior to
being maximized.

<programlisting>
<![CDATA[
  if self~isMaximized then self~restore

]]>
</programlisting>

</para></listitem></varlistentry>
</variablelist>
</section>

<section id="focusitem"><title>FocusItem</title>
<indexterm><primary>FocusItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~FocusItem(--id--)------------------------------><


]]>
</programlisting>

<para>The FocusItem method sets the input focus to a
particular dialog item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog item to set the focus to
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method always returns 1.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="tabtonext"><title>TabToNext</title>
<indexterm><primary>TabToNext</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~TabToNext--------------------------------------><


]]>
</programlisting>

<para>The TabToNext method sets the input focus to the next dialog control
with a tab stop.  This performs the same action as if the user pressed the
tab key in the dialog.  Like many of the other methods, TabToNext is a method
of both a BaseDialog and a DialogControl.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>The focus was changed, but the control with the previous focus
could not be determined.
</para></listitem></varlistentry>
<varlistentry><term>Other</term>
<listitem><para>The handle to the control with the previous focus.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="tabtoprevious"><title>TabToPrevious</title>
<indexterm><primary>TabToPrevious</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~TabToPrevious----------------------------------><


]]>
</programlisting>

<para>This method is the reverse of TabToNext and sets the input focus to
the previous dialog control with a tab stop.  This performs the same action
as if the user pressed the shift-tab key in the dialog.  TabToPrevious is a
method of both a BaseDialog and a DialogControl.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>The focus was changed, but the control with the previous focus
could not be determined.
</para></listitem></varlistentry>
<varlistentry><term>Other</term>
<listitem><para>The handle to the control with the previous focus.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthSetGroup"><title>SetGroup</title>
<indexterm><primary>SetGroup</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetGroup(--id--,--+-----------+--)---------------><
                                 +-wantStyle-+

]]>
</programlisting>

<para>Add or remove the <link linkend="wsgroup">group style</link> for the
specified control.  The group style controls how the user can navigate through
the dialog using the keyboard.  For most dialogs this does not change while the
dialog is executing.  However, in some dialogs the programmer may want to change
the navigation depending on the options the user selects.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The resource ID of the dialog control that will gain or lose the
group style.
</para></listitem></varlistentry>
<varlistentry><term>wantStyle</term>
<listitem><para>A boolean (.true or .false) to indicate whether the dialog
control should have or not have the group style.  True (the default) indicates
the control should have the group style and false indicates the control should
not have the style.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>Negative values indicate the function failed, non-negative
values indicate success.
<variablelist>
<varlistentry><term>-4 or less</term>
<listitem><para>The value is the negated Operating System Error code.  The
absolute value of the return can be used to look up the error reason in the
Windows documentation.
</para></listitem></varlistentry>
<varlistentry><term>-3</term>
<listitem><para>The second argument to the method is not a boolean.
</para></listitem></varlistentry>
<varlistentry><term>-2</term>
<listitem><para>There is an (internal) problem with the dialog or the dialog
handle.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>The resource ID of the control is not correct.
</para></listitem></varlistentry>
<varlistentry><term>0 or greater</term>
<listitem><para>The window style of the dialog control prior to adding or
removing the group style.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthSetTabStop"><title>SetTabStop</title>
<indexterm><primary>SetTabStop</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetTabStop(--id--,--+-----------+--)-------------><
                                   +-wantStyle-+

]]>
</programlisting>

<para>Add or remove the <link linkend="wstabstop">tab stop style</link> for the
specified control.  When  a control has the tabstop style, the user can set the
focus to the control by using the tab key.  When a control does not have this
style, the tab key will skip over the control.  Adding or removing this style
during the execution of a dialog allows the programmer to alter how the user
navigates through the dialog controls.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The resource ID of the dialog control that will gain or lose the
tabstop style.
</para></listitem></varlistentry>
<varlistentry><term>wantStyle</term>
<listitem><para>A boolean (.true or .false) to indicate whether the dialog
control should have or not have the tabstop style.  True (the default) indicates
the control should have the tabstop style and false indicates the control should
not have the style.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>Negative values indicate the function failed, non-negative
values indicate success.
<variablelist>
<varlistentry><term>-4 or less</term>
<listitem><para>The value is the negated Operating System Error code.  The
absolute value of the return can be used to look up the error reason in the
Windows documentation.
</para></listitem></varlistentry>
<varlistentry><term>-3</term>
<listitem><para>The second argument to the method is not a boolean.
</para></listitem></varlistentry>
<varlistentry><term>-2</term>
<listitem><para>There is an (internal) problem with the dialog or the dialog
handle.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>The resource ID of the control is not correct.
</para></listitem></varlistentry>
<varlistentry><term>0 or greater</term>
<listitem><para>The window style of the dialog control prior to adding or
removing the tabstop style.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001221"><title>EnableItem</title>
<indexterm><primary>EnableItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~EnableItem(--id--)-----------------------------><


]]>
</programlisting>

<para>The EnableItem method enables the given dialog
item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the item
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001229"><title>DisableItem</title>
<indexterm><primary>DisableItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DisableItem(--id--)----------------------------><


]]>
</programlisting>

<para>The DisableItem method disables the given dialog
item. A disabled dialog item is usually indicated by a gray instead of a black
title or text; it cannot be changed by the user. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the item
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthHideItem"><title>HideItem</title>
<indexterm><primary>HideItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~HideItem(--id--)-------------------------------><


]]>
</programlisting>

<para>The HideItem method makes the given item disappear
from the screen and thus unavailable to the user. In fact, the item is still
in the dialog and you can transfer its data. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the item
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001285"><title>HideItemFast</title>
<indexterm><primary>HideItemFast</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~HideItemFast(--id--)---------------------------><


]]>
</programlisting>

<para>The HideItemFast method hides an item without redrawing
its area. It is similar to the <link linkend="mthHideItem">HideItem</link> method,
but it is faster because the item's area is not redrawn. The HideItemFast method is used when more than one item state is modified.
After the operations, you can manually redraw the dialog window, using the <link linkend="update">Update</link> method. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the item
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthShowItem"><title>ShowItem</title>
<indexterm><primary>ShowItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ShowItem(--id--)-------------------------------><


]]>
</programlisting>

<para>The ShowItem method makes the given dialog item
reappear on the screen. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the item
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001293"><title>ShowItemFast</title>
<indexterm><primary>ShowItemFast</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ShowItemFast(--id--)---------------------------><


]]>
</programlisting>

<para>The ShowItemFast method shows an item without redrawing
its area. It is the counterpart to the <link linkend="h001285">HideItemFast</link> method.</para>
</section>

<section id="h001253"><title>HideWindow</title>
<indexterm><primary>HideWindow</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~HideWindow(--hwnd--)---------------------------><


]]>
</programlisting>

<para>The HideWindow method hides a whole dialog window
or a dialog item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>A handle to the window or dialog item. Use the <link
linkend="mthGetSelf">GetSelf</link> or <link linkend="mthGetItem">GetItem</link>
method to get a handle.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example gets the window handle of the top dialog
(which is not necessarily the executing dialog, see the <link
linkend="h000086">Get</link> method) and hides the whole dialog:

<programlisting>
<![CDATA[
hwnd = MyDialog~Get
MyDialog~HideWindow(hwnd)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001261"><title>HideWindowFast</title>
<indexterm><primary>HideWindowFast</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~HideWindowFast(--hwnd--)-----------------------><


]]>
</programlisting>

<para>The HideWindowFast method is similar to the <link linkend="h001253">HideWindow</link> method, but it is faster because the window's
or item's area is not redrawn. The HideWindowFast method
is used when more than one state is modified. After the operations, you can
manually redraw the dialog window, using the <link linkend="update">Update</link> method. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>A handle to the window or dialog item
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001269"><title>ShowWindow</title>
<indexterm><primary>ShowWindow</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ShowWindow(--hwnd--)---------------------------><


]]>
</programlisting>

<para>The ShowWindow method shows the window or item
again. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of a window or an item
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001277"><title>ShowWindowFast</title>
<indexterm><primary>ShowWindowFast</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ShowWindowFast(--hwnd--)-----------------------><


]]>
</programlisting>

<para>The ShowWindowFast method is the counterpart to
the <link linkend="h001261">HideWindowFast</link> method.</para>
</section>

<section id="mthSetWindowRect"><title>SetWindowRect</title>
<indexterm><primary>SetWindowRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetWindowRect(--hwnd--,--x--,--y--,--width--,--height-->

>--+-----------------------------+--)--------------------------------><
   |       +----------------+    |
   |       V                |    |
   +-,--"----+-NOMOVE-----+-+--"-+
             +-NOSIZE-----+
             +-HIDEWINDOW-+
             +-SHOWWINDOW-+
             +-NOREDRAW---+


]]>
</programlisting>

<para>The SetWindowRect method sets new coordinates for
a specific window. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to the dialog that is to be repositioned.
</para></listitem></varlistentry>
<varlistentry><term>x, y</term>
<listitem><para>The new position of the upper left corner, in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>width</term>
<listitem><para>The new width of the window, in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>height</term>
<listitem><para>The new height of the window, in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>showOptions</term>
<listitem><para>This argument can be one or more of the following keywords, separated
by blanks:
<variablelist>
<varlistentry><term>NOMOVE</term>
<listitem><para>The upper left position of the window has not changed.
</para></listitem></varlistentry>
<varlistentry><term>NOSIZE</term>
<listitem><para>The size of the window has not changed.
</para></listitem></varlistentry>
<varlistentry><term>HIDEWINDOW</term>
<listitem><para>The window is to be made invisible.
</para></listitem></varlistentry>
<varlistentry><term>SHOWWINDOW</term>
<listitem><para>The window is to be made visible.
</para></listitem></varlistentry>
<varlistentry><term>NOREDRAW</term>
<listitem><para>The window is to be repositioned without redrawing it.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Repositioning was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Repositioning failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="redrawwindow"><title>RedrawWindow</title>
<indexterm><primary>RedrawWindow</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~RedrawWindow(--hwnd--)-------------------------><


]]>
</programlisting>

<para>The RedrawWindow method redraws a specific dialog. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to the dialog that is to be redrawn.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Redrawing was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Redrawing failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001301"><title>ResizeItem</title>
<indexterm><primary>ResizeItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ResizeItem(--id--,--width--,--height--+-------------------------+--)-><
                                                     +-,--"--+-HIDEWINDOW-+--"-+
                                                             +-SHOWWINDOW-+
                                                             +-NOREDRAW---+


]]>
</programlisting>

<para>The ResizeItem method changes the size of a dialog
item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog item you want to resize
</para></listitem></varlistentry>
<varlistentry><term>width, height</term>
<listitem><para>The new size in dialog units
</para></listitem></varlistentry>
<varlistentry><term>showOptions</term>
<listitem><para>This argument can be one of the following keywords:
<variablelist>
<varlistentry><term>HIDEWINDOW</term>
<listitem><para>Hides the item
</para></listitem></varlistentry>
<varlistentry><term>SHOWWINDOW</term>
<listitem><para>Shows the item
</para></listitem></varlistentry>
<varlistentry><term>NOREDRAW</term>
<listitem><para>Resizes the item without updating the display. Use the <link linkend="update">Update</link> method to manually update the display.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example resizes a dialog item:

<programlisting>
<![CDATA[
MyDialog~ResizeItem(123, 40, 30, "SHOWWINDOW")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001322"><title>MoveItem</title>
<indexterm><primary>MoveItem</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~MoveItem(--id--,--xPos--,--yPos--+-------------------------+--)-><
                                                +-,--"--+-HIDEWINDOW-+--"-+
                                                        +-SHOWWINDOW-+
                                                        +-NOREDRAW---+


]]>
</programlisting>

<para>The MoveItem method moves a dialog item to another
position within the dialog window. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog item you want to move
</para></listitem></varlistentry>
<varlistentry><term>xPos, yPos</term>
<listitem><para>The new position in dialog units relative to the dialog window
</para></listitem></varlistentry>
<varlistentry><term>showOptions</term>
<listitem><para>This argument can be one of the following keywords:
<variablelist>
<varlistentry><term>HIDEWINDOW</term>
<listitem><para>Hides the dialog
</para></listitem></varlistentry>
<varlistentry><term>SHOWWINDOW</term>
<listitem><para>Shows the dialog
</para></listitem></varlistentry>
<varlistentry><term>NOREDRAW</term>
<listitem><para>Moves the dialog item without updating the display. Use the <link linkend="update">Update</link> method
to manually update the display.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001370"><title>Center</title>
<indexterm><primary>Center</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Center(--"--+-HIDEWINDOW-+--"--)---------------><
                           +-SHOWWINDOW-+
                           +-NOREDRAW---+


]]>
</programlisting>

<para>The Center method moves the dialog to the screen
center. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument can be one of:
<variablelist>
<varlistentry><term>HIDEWINDOW</term>
<listitem><para>Hides the dialog
</para></listitem></varlistentry>
<varlistentry><term>SHOWWINDOW</term>
<listitem><para>Shows the dialog
</para></listitem></varlistentry>
<varlistentry><term>NOREDRAW</term>
<listitem><para>Center the dialog without updating the display. Use the <link linkend="update">Update</link> method
to manually update the display.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000246"><title>SetWindowTitle</title>
<indexterm><primary>SetWindowTitle</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetWindowTitle(--hwnd--,--aString--)-----------><


]]>
</programlisting>

<para>The SetWindowTitle method changes the title of
a window. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of the window whose title you want to change
</para></listitem></varlistentry>
<varlistentry><term>aString</term>
<listitem><para>The new title text
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="exampleFileViewer"><title>FileViewer Example Program</title>
<indexterm><primary>FileViewer.rex</primary>
<secondary>example code</secondary></indexterm>

<para>The FileViewer program is a complete working program that uses many of the
methods of the base dialog.  Portions of this program are presented as examples
in the documentation for these methods. The complete program is shown here as a
reference to how the code snippets all fit together.
</para>
<para>The documentation for the individual methods used in the program has
additional commentary that will help in understanding how the program works.
<itemizedlist>
<listitem><para><link linkend="h000025">Init</link>: This program uses a header
file, <computeroutput>fileView.h</computeroutput> to define symbolic IDs for the
dialog controls. The name of the file is one of the arguments used to create a
new instance of a dialog object. (As in all Rexx classes, the arguments used
in <computeroutput>new</computeroutput> are passed on to the <computeroutput>
init</computeroutput> method of the class.)
</para></listitem>
<listitem><para><link linkend="h000048">Execute</link>: Two dialogs are created
in the example.  The first dialog allows the user to enter the name of a file to
view.  Then the file itself is displayed in a second dialog.  Each dialog uses a
different application icon. The <computeroutput>Execute</computeroutput> method
documentation has more detail on the application icon.
</para></listitem>
<listitem><para><link linkend="mthInitDialog">InitDialog</link> This method is called
after the underlying Windows dialog has been created, but before it is shown on
the screen.  In the viewer dialog the <computeroutput>Init</computeroutput>
method is overridden and the text of the read-only multi-line edit control is
set to the contents of the file.  In both dialogs, this method is used to get
and save a reference to the edit control of the dialog.
</para></listitem>
<listitem><para><link linkend="h001229">DisableItem</link>: When the user clicks
the &quot;View File&quot; button, the button is disabled until the user is
finished viewing the file.  When a button is disabled it can not be clicked by
the user.
</para></listitem>
<listitem><para><link linkend="h001221">EnableItem</link>: When the user closes
the secondary viewer dialog, the &quot;View File&quot; button is enabled so the
user can choose to view another file.
</para></listitem>
<listitem><para><link linkend="mthPopupAsChild">PopupAsChild</link>: The viewer
dialog is executed using this method so that both dialogs run independently,
both dialogs stay enabled.  The <computeroutput>HIDE</computeroutput> keyword is
used for the show argument.  This creates the dialog as invisible and prevents
unnecessary screen flicker.
</para></listitem>
<listitem><para><link linkend="mthMaximize">Maximize</link>: Note that there is
a 100 millisecond sleep right before the <computeroutput>Maximize method
</computeroutput> is invoked.  This allows Windows to finish creating the
dialog.  The <computeroutput>InitDialog</computeroutput> method will have
already finished executing and the contents of the file are loaded into the
multi-line edit control.  Then, <computeroutput>Maximize</computeroutput>
resizes the dialog to take up the whole screen and shows it.  The dialog appears
on the user's screen, with the file displayed, in one screen drawing.  This
reduces the flicker on the screen.
</para></listitem>
<listitem><para><link linkend="mthMinimize">Minimize</link>: When the viewer
dialog is maximized, the main dialog is minimized to the task bar.
</para></listitem>
<listitem><para><link linkend="mthInitAutoDetection">InitAutoDetection</link>:
Because the contents of the file are loaded into the multi-line edit control
during <computeroutput>InitDialog</computeroutput>, auto detection must be
turned off.  Otherwise, after <computeroutput>InitDialog</computeroutput>
finishes executing, auto detection would set the empty string as the text for
the control.  The program overrides this method to turn auto detection off.
</para></listitem>
<listitem><para><link linkend="mthNoAutoDetection">NoAutoDetection</link>: Used
in turning auto detection off.
</para></listitem>
<listitem><para><link linkend="mthConnectResize">ConnectResize</link>: When the
viewer dialog is resized, the <computeroutput>onSize</computeroutput> method is
invoked.  The size of the multi-line edit control is then changed so it
completely takes up the client area of the dialog.  (The client area of a window
is where all the child windows are drawn.  In this case the edit control is the
only child window.)  Since the dialog is not resizeable by the user (it does not
have a sizing border) the only time the size can change is when the dialog is
maximized, minimized, or restored.
</para></listitem>
<listitem><para><link linkend="mthHideItem">HideItem</link>: The edit control in
the viewer dialog is created invisible.  Again, this helps reduce flicker.
</para></listitem>
<listitem><para><link linkend="mthGetItem">GetItem</link>: The window handle of
the edit control is obtained by this method ...
</para></listitem>
<listitem><para><link linkend="mthGetClientRect">GetClientRect</link>: ... then
the size of the client area of the viewer dialog is obtained using this method.
Then ..
</para></listitem>
<listitem><para><link linkend="mthSetWindowRect">SetWindowRect</link>: ... the
size of the edit control window is set using to the size of the dialog's client
area.
</para></listitem>
<listitem><para><link linkend="mthShowItem">ShowItem</link>: The
<computeroutput>ShowItem</computeroutput> method is used to make the edit
control visible when the dialog is initially shown.
</para></listitem>
<listitem><para><link linkend="mthIsMinimized">IsMinimized</link>: When the
viewer dialog is closed, this method checks to see if the main dialog is still
minimized.  Since the dialogs run independently the user may have already
restored this dialog.
</para></listitem>
<listitem><para><link linkend="mthRestore">Restore</link>: If the main dialog is
still minimized, then this method restores it to its normal position.
</para></listitem>
</itemizedlist>
</para>

<programlisting>
<![CDATA[

/* fileView.h  Simple symbolic ID definitions  */

#define IDD_DIALOG1          100
#define IDC_ST_TYPE          105
#define IDC_ENTRYLINE        106
#define IDC_MULTILINE        107
#define IDC_PB_VIEW          111

/* FileViewer.rex  Simple Dialog to view files full screen */

  dlg = .FileView~new( , "fileView.h")
  if dlg~initCode = 0 then do
    dlg~createCenter(170, 90, "The File Viewer Dialog", "VISIBLE MAXIMIZEBOX MINIMIZEBOX")
    dlg~Execute("SHOWTOP", IDI_DLG_OOREXX)
    dlg~Deinstall
  end

-- End of entry point.
::requires "OODWin32.cls"

::class FileView subclass UserDialog inherit AdvancedControls

::method defineDialog

  self~addText(10, 25, 150, 10, " Enter the name of a file to view:", "", IDC_ST_TYPE)
  self~addEntryLine(IDC_ENTRYLINE, , 10, 35, 150, 10, "AUTOSCROLLH")

  -- When the view button is pushed, another dialog will show the file.
  self~addButton(IDC_PB_VIEW, 10, 55, 35, 15, "View File", onView, "DEFAULT GROUP")
  self~addButton(IDOK, 130, 55, 35, 15, "Quit")

::method initDialog
  expose editCntrl
  editCntrl = self~getEditControl(IDC_ENTRYLINE)

::method onView
  expose viewDlg editCntrl

  fileName = editCntrl~getText
  viewDlg = .Viewer~new( , "fileView.h", self, fileName)
  if viewDlg~initCode = 0 then do
    self~disableItem(IDC_PB_VIEW)

    viewDlg~create(30, 30, 170, 180, "Viewer", "MAXIMIZEBOX MINIMIZEBOX")
    viewDlg~popUpAsChild(self, "HIDE", , IDI_DLG_APPICON)

    -- The underlying Windows dialog has to be created before it can be maximized.
    j = SleepMS(100)

    viewDlg~maximize
    self~minimize
  end

::class 'Viewer' subclass UserDialog inherit AdvancedControls

::method init
  expose parent filename
  use arg data, header, parent, fileName
  forward class (super)

::method initAutoDetection
  self~noAutoDetection

::method defineDialog
  expose wasMinimized

  wasMinimized = .false
  style = "VSCROLL HSCROLL MULTILINE READONLY"
  self~addEntryLine(IDC_MULTILINE, "cEntry", 0, 0, 170, 180, style)
  self~connectResize("onSize")

::method initDialog
  expose editControl fileName isHidden

  self~hideItem(IDC_MULTILINE)
  isHidden = .true

  editControl = self~getEditControl(IDC_MULTILINE)
  fObj = .stream~new(fileName)
  text = fObj~charin(1, fObj~chars)
  fObj~close
  if text == "" then text = "   No file  "
  editControl~setText(text)

::method onSize
  expose wasMinimized
  use arg sizeEvent sizeInfo

  if sizeEvent = 1 then wasMinimized = .true

  if sizeEvent = 0 |  sizeEvent = 2 then do
    if \ wasMinimized then self~resizeEditControl
    wasMinimized = .false
  end

::method resizeEditControl
  expose editControl isHidden

  hWnd = self~getItem(IDC_MULTILINE)
  parse value self~getClientRect with wx wy wcx wcy

  self~setWindowRect(hWnd, 0, 0, wcx, wcy)

  if isHidden then do
    self~showItem(IDC_MULTIINE)
    isHidden = .false
  end

::method cancel
  expose parent
  parent~enableItem(IDC_PB_VIEW)
  if parent~isMinimized then parent~restore
  return self~cancel:super

]]>
</programlisting>
</section>

</section>

<section id="man0016"><title>Window Draw Methods</title>
<indexterm><primary>draw methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<para>The methods listed below are used to draw, redraw, and clear window areas.</para>

<section id="h000606"><title>DrawButton</title>
<indexterm><primary>DrawButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DrawButton(--id--)-----------------------------><


]]>
</programlisting>

<para>The DrawButton method draws the given button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000653"><title>RedrawRect</title>
<indexterm><primary>RedrawRect</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
                                                                               +-0--------+
>>-aBaseDialog~RedrawRect(--+------+--,--left--,--top--,--right--,--bottom--,--+----------+--)-><
                            +-hwnd-+                                           +-erasebkg-+


]]>
</programlisting>

<para>The RedrawRect method immediately redraws a rectangle
within the client area of a dialog. You can specify whether the background
of the dialog is to be erased before redrawing. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to the dialog in which parts of the client area are to be
redrawn. See <link linkend="h000086">Get</link> or <link linkend="mthGetItem">GetItem</link> for
information on how to get a window handle. If you omit this argument, the
handle of the dialog instance is used.
</para></listitem></varlistentry>
<varlistentry><term>left, top</term>
<listitem><para>The upper left corner of the rectangle relative to the client area,
in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>right, bottom</term>
<listitem><para>The lower right corner of the rectangle relative to the client area,
in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>erasebkg</term>
<listitem><para>If this argument is 1 or 0, the background of the dialog is erased before
redrawing. The default is 0.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Redrawing was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Redrawing failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000684"><title>RedrawButton</title>
<indexterm><primary>RedrawButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~RedrawButton(--id--+-------------+--)----------><
                                  +-,--erasebkg-+


]]>
</programlisting>

<para>The RedrawButton method redraws the given button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
<varlistentry><term>erasebkg</term>
<listitem><para>Determines whether (1) or not (0) the background of the drawing area
should be erased before redrawing. The default is 0.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000693"><title>RedrawWindowRect</title>
<indexterm><primary>RedrawWindowRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~RedrawWindowRect--+-----------------------------+--><
                                 +-(--hwnd--+-------------+--)-+
                                            +-,--erasebkg-+


]]>
</programlisting>

<para>The RedrawWindowRect method redraws the given window
rectangle. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to the window. See <link linkend="h000086">Get</link>
or <link linkend="mthGetItem">GetItem</link> for information on how to get a window
handle. If you omit this argument, the handle of the dialog instance is used.
</para></listitem></varlistentry>
<varlistentry><term>erasebkg</term>
<listitem><para>Determines whether (1) or not (0) the background of the
drawing area should be erased before redrawing. The default is 0.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000640"><title>ClearRect</title>
<indexterm><primary>ClearRect</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ClearRect(--hwnd--,--left--,--top--,--right--,--bottom--)--><


]]>
</programlisting>

<para>The ClearRect method clears the given rectangle
of a window. The values are in pixels. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of the window. See <link
linkend="mthGetSelf">GetSelf</link> or <link linkend="mthGetItem">GetItem</link>
for information on obtaining a window handle.
</para></listitem></varlistentry>
<varlistentry><term>left</term>
<listitem><para>The horizontal value of the upper-left corner of the rectangle
</para></listitem></varlistentry>
<varlistentry><term>top</term>
<listitem><para>The vertical value of the upper left corner
</para></listitem></varlistentry>
<varlistentry><term>right</term>
<listitem><para>The horizontal value of the lower right corner
</para></listitem></varlistentry>
<varlistentry><term>bottom</term>
<listitem><para>The vertical value of the lower right corner
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example clears a rectangle of the size 20 by 20:

<programlisting>
<![CDATA[
hwnd=MyDialog~GetSelf
MyDialog~ClearRect(hwnd, 2, 4, 22, 24)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000622"><title>ClearButtonRect</title>
<indexterm><primary>ClearButtonRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ClearButtonRect(--id--)------------------------><


]]>
</programlisting>

<para>The ClearButtonRect method erases the draw area
of the given button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the push button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000631"><title>ClearWindowRect</title>
<indexterm><primary>ClearWindowRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ClearWindowRect(--hwnd--)----------------------><


]]>
</programlisting>

<para>The ClearWindowRect method erases the draw area
of the given window. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of the window. See <link
linkend="mthGetSelf">GetSelf</link>, <link linkend="h000086">Get</link>, or
<link linkend="mthGetItem">GetItem</link> for some methods to get a window handle.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example gets the window handle of a dialog control
with resource ID of 211 and then clears the dialog control window:

<programlisting>
<![CDATA[
hwnd = MyDialog~GetItem(211)
MyDialog~ClearWindowRect(hwnd)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="man0018"><title>Bitmap Methods</title>
<indexterm><primary>bitmap methods</primary></indexterm>
<para>The methods listed below deal with bitmaps.</para>

<section id="h000170"><title>ChangeBitmapButton</title>
<indexterm><primary>ChangeBitmapButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ChangeBitmapButton(--id--,--bmpNormal----------------------->

>--+--------------------------------------------------------------------+-->
   +-,bmpFocused--+---------------------------------------------------+-+
                  +-,bmpSelected--+---------------------------------+-+
                                  +-,bmpDisabled--+---------------+-+
                                                  +-,styleOptions-+

>--)----------------------------------------------------------------------><


]]>
</programlisting>

<para>The ChangeBitmapButton method changes the bitmaps
of a bitmap button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are the same as for <link linkend="mthConnectBitmapButton">ConnectBitmapButton</link>,
except for the first argument (msgToRaise), which is skipped in this method.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example replaces the current bitmap with a new
bitmap:

<programlisting>
<![CDATA[
MyDialog~ChangeBitmapButton(501, "NewBB.bmp")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001127"><title>GetBitmapSizeX</title>
<indexterm><primary>GetBitmapSizeX</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetBitmapSizeX(--id--)-------------------------><


]]>
</programlisting>

<para>The GetBitmapSizeX method returns the horizontal
bitmap extension. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the bitmap button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001135"><title>GetBitmapSizeY</title>
<indexterm><primary>GetBitmapSizeY</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetBitmapSizeY(--id--)-------------------------><


]]>
</programlisting>

<para>The GetBitmapSizeY method returns the vertical
bitmap extension. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the bitmap button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001143"><title>DrawBitmap</title>
<indexterm><primary>DrawBitmap</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DrawBitmap(--+------+--,--id---------------------->
                            +-hwnd-+

>--+----------------------------------------------------------+-->
   +-,--px--,--py--+----------------------------------------+-+
                   +-,--srcx--,--srcy--+------------------+-+
                                       +-,--xlen--,--ylen-+

>--)------------------------------------------------------------><


]]>
</programlisting>

<para>The DrawBitmap method draws the bitmap of a button.
You can also use this method to move a bitmap or a part of it. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to the window.  If this argument is omitted, the handle for
the button is used automatically.
</para></listitem></varlistentry>
<varlistentry><term>id</term>
<listitem><para>The ID of the button that has the owner-draw option set
</para></listitem></varlistentry>
<varlistentry><term>px, py</term>
<listitem><para>The upper-left corner of the target space within the button (default
is 0)
</para></listitem></varlistentry>
<varlistentry><term>srcx, srcy</term>
<listitem><para>The upper-left corner within the bitmap (default is 0)
</para></listitem></varlistentry>
<varlistentry><term>xlen, yLen</term>
<listitem><para>The extension of the bitmap or a part of it (default is the whole bitmap)
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001172"><title>ScrollBitmapFromTo</title>
<indexterm><primary>ScrollBitmapFromTo</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ScrollBitmapFromTo(--id--,--fromX--,--fromY--,--toX--,--toY--,-->

>--stepX--,--stepY--,--delay--,--displace--)------------------><


]]>
</programlisting>

<para>The ScrollBitmapFromTo method scrolls a bitmap
from one position to another within an owner-drawn button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
<varlistentry><term>fromX, fromY</term>
<listitem><para>The starting position
</para></listitem></varlistentry>
<varlistentry><term>toX, toY</term>
<listitem><para>The target position
</para></listitem></varlistentry>
<varlistentry><term>stepX, stepY</term>
<listitem><para>The width of one step
</para></listitem></varlistentry>
<varlistentry><term>delay</term>
<listitem><para>The time in milliseconds this method waits after each move before doing
the next move. This determines the speed at which the bitmap moves.
</para></listitem></varlistentry>
<varlistentry><term>displace</term>
<listitem><para>If set to 1 the internal position of the bitmap (bitmap displacement)
is updated after each incremental move. <link linkend="h000726">DisplaceBitmap</link> is
called after each step to adjust the bitmap position.  If the dialog is redrawn,
the bitmap is shown at the correct position, but the drawing is slower.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001045"><title>TiledBackgroundBitmap</title>
<indexterm><primary>TiledBackgroundBitmap</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~TiledBackgroundBitmap(--bmpFilename--)---------><


]]>
</programlisting>

<para>The TiledBackgroundBitmap method sets a bitmap
as the background brush (<trademark class="registered">Windows NT</trademark> only). If the bitmap size is
less than the size of the background, the bitmap is drawn repetitively. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>bmpFilename</term>
<listitem><para>The name of a bitmap file
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001053"><title>BackgroundBitmap</title>
<indexterm><primary>BackgroundBitmap</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~BackgroundBitmap(--bmpFilename------------------->

>--+-------------+--)------------------------------------------><
   +-,--"USEPAL"-+


]]>
</programlisting>

<para>The BackgroundBitmap method sets a bitmap as the
dialog's background picture. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>bmpFilename</term>
<listitem><para>The name of a bitmap file
</para></listitem></varlistentry>
<varlistentry><term>option</term>
<listitem><para>Set the last argument to USEPAL if you want
to use the color palette of the bitmap. See <link linkend="mthConnectBitmapButton">ConnectBitmapButton</link> for more
information.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000726"><title>DisplaceBitmap</title>
<indexterm><primary>DisplaceBitmap</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DisplaceBitmap(--id--,--x--,--y--)-------------><


]]>
</programlisting>

<para>The DisplaceBitmap method sets the position of
a bitmap within a button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of a button
</para></listitem></varlistentry>
<varlistentry><term>x</term>
<listitem><para>The horizontal displacement in screen pixels. A negative value can be
used.
</para></listitem></varlistentry>
<varlistentry><term>y</term>
<listitem><para>The vertical displacement (negative allowed)
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example moves the bitmap within a button
four screen pixels to the right and three pixels upward:

<programlisting>
<![CDATA[
MyBaseDialog~DisplaceBitmap(244, 4, -3)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000737"><title>GetBmpDisplacement</title>
<indexterm><primary>GetBmpDisplacement</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetBmpDisplacement(--id--)---------------------><


]]>
</programlisting>

<para>The GetBmpDisplacement method gets the position
of a bitmap within a button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example shows how to use the <link linkend="h000703">GetButtonRect</link> and <link linkend="h000737">GetBmpDisplacement</link> methods:

<programlisting>
<![CDATA[
bRect = MyBaseDialog~GetButtonRect(244)
parse var bRect left top right bottom
bmpPos = MyBaseDialog~GetBmpDisplacement(244)
parse var bmpPos x y
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="man0021"><title>Device Context Methods</title>
<indexterm><primary>device context methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<para>The methods listed below are used to retrieve and release a device context.</para>
<para>A device context is associated with a window, a dialog, or a push button,
and is a drawing area managed by a window. A device context stores information
about the graphic objects (bitmaps, lines, pixels, ...) that are displayed
and the tools (pen, brush, font, ...) that are used to display them.</para>

<section id="h001062"><title>GetWindowDC</title>
<indexterm><primary>GetWindowDC</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetWindowDC(--hwnd--)--------------------------><


]]>
</programlisting>

<para>The GetWindowDC method returns the device context
of a window. Do not forget to free the device context after you have completed
the operations (see <link linkend="h001086">FreeWindowDC</link>). </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of the window
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001077"><title>GetButtonDC</title>
<indexterm><primary>GetButtonDC</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetButtonDC(--id--)----------------------------><


]]>
</programlisting>

<para>The GetButtonDC method returns the device context
of a button. Do not forget to free the device context after you have completed
the operations (see <link linkend="h001105">FreeButtonDC</link>). </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001086"><title>FreeWindowDC</title>
<indexterm><primary>FreeWindowDC</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~FreeWindowDC(--hwnd--,--dc--)------------------><


]]>
</programlisting>

<para>The FreeWindowDC method frees the device context
of a window. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The window handle
</para></listitem></varlistentry>
<varlistentry><term>dc</term>
<listitem><para>The device context previously received by the <link linkend="h001062">GetWindowDC</link> method
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001105"><title>FreeButtonDC</title>
<indexterm><primary>FreeButtonDC</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~FreeButtonDC(--id--,--dc--)--------------------><


]]>
</programlisting>

<para>The FreeButtonDC method releases the device context
of a button. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
<varlistentry><term>dc</term>
<listitem><para>The device context previously received by the <link linkend="h001077">GetButtonDC</link> method
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="man0022"><title>Text Methods</title>
<indexterm><primary>text methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<para>
  The following methods are used to display text dynamically in a window area and to modify the state of
  a device context. See <link linkend="h001062">GetWindowDC</link>, <link linkend="getdc">GetDC</link>,
  and <link linkend="h001077">GetButtonDC</link> for information on how to retrieve a device context.
</para>

<section id="h000866"><title>Write</title>
<indexterm><primary>Write</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~Write(--xPos--,--yPos--,--text---------------------------------->

>--+------------------------------------------------------------------------+-->
   |    +-"SYSTEM"-+                                                        |
   +-,--+----------+--+---------------------------------------------------+-+
        +-fontName-+  |    +-10-------+                                   |
                      +-,--+----------+--+------------------------------+-+
                           +-fontSize-+  |       +-----------------+    |
                                         |       V +-OPAQUE------+ |    |
                                         +-,--"----+-THIN--------+-+--"-+
                                                   +-EXTRALIGHT--+
                                                   +-LIGHT-------+
                                                   +-MEDIUM------+
                                                   +-SEMIBOLD----+
                                                   +-EXTRABOLD---+
                                                   +-BOLD--------+
                                                   +-HEAVY-------+
                                                   +-UNDERLINE---+
                                                   +-ITALIC------+
                                                   +-STRIKEOUT---+
                                                   +-TRANSPARENT-+
                                                   +-CLIENT------+

>--)--------------------------------------------------------------------------><


]]>
</programlisting>

<para>The Write method enables you to write text to the
dialog in the given font and size, to the given position. This method does
not take a handle or an ID; it always writes to the dialog window. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>See <link linkend="h000826">WriteToWindow</link> for a description of the other arguments.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000879"><title>ScrollText</title>
<indexterm><primary>ScrollText</primary>
<secondary>BaseDialog class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ScrollText(--hwnd--,--text--,--+----------+--,--+----------+-->
                                              +-fontName-+     +-fontSize-+

>--,--+--------------------------+------------------------------------------->
      |    +----------------+    |
      |    V                |    |
      +-"----+-THIN-------+-+--"-+
             +-EXTRALIGHT-+
             +-LIGHT------+
             +-MEDIUM-----+
             +-SEMIBOLD---+
             +-EXTRABOLD--+
             +-BOLD-------+
             +-HEAVY------+
             +-UNDERLINE--+
             +-ITALIC-----+
             +-STRIKEOUT--+

>--,--displaceY--,--step--,--sleep--,--color--)-----------------------------><


]]>
</programlisting>

<para>The ScrollText method scrolls text in a window
with the given size, font, and color. The text is scrolled from right to left.
If the method is started concurrently, call it a second time to
stop scrolling.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:</para>
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of the window in which the text is scrolled
</para></listitem></varlistentry>
<varlistentry><term>text</term>
<listitem><para>A text string that is scrolled
</para></listitem></varlistentry>
<varlistentry><term>displaceY</term>
<listitem><para>The vertical displacement of the text relative to the top of the window's
client area (default 0)
</para></listitem></varlistentry>
<varlistentry><term>step</term>
<listitem><para>The size of one step in screen pixels (default 4)
</para></listitem></varlistentry>
<varlistentry><term>sleep</term>
<listitem><para>The time in milliseconds that the program waits after each movement
(default 10). This determines the speed.
</para></listitem></varlistentry>
<varlistentry><term>color</term>
<listitem><para>The color of the text (default 0, black)
</para></listitem></varlistentry>
</variablelist>
<para>See <link linkend="h000826">WriteToWindow</link> for a description of the other
arguments.</para>
</listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example scrolls the string &quot;Hello world!&quot; from left
to right within the given window. The text is located two pixels below the
top of the client area, one move is 3 screen pixels, and the delay time after
each movement is 15 ms.</para>

<programlisting>
<![CDATA[
MyDialog~ScrollText(hwnd, "Hello world!", , , , 2, 3, 15)
]]>
</programlisting>
</listitem></varlistentry>
</variablelist>

<note><title>Note</title><para>
Only one sleep interval can be set for multiple scrolling
texts within one process. All scrolling text in one process is synchronized
with the first given interval.
</para></note>
</section>

<section id="h000896"><title>ScrollInButton</title>
<indexterm><primary>ScrollInButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ScrollInButton(--id--,--text--,--+----------+--,-->
                                                +-fontName-+

>--+----------+--,--+--------------------------+---------------->
   +-fontSize-+     |    +----------------+    |
                    |    V                |    |
                    +-"----+-THIN-------+-+--"-+
                           +-EXTRALIGHT-+
                           +-LIGHT------+
                           +-MEDIUM-----+
                           +-SEMIBOLD---+
                           +-EXTRABOLD--+
                           +-BOLD-------+
                           +-HEAVY------+
                           +-UNDERLINE--+
                           +-ITALIC-----+
                           +-STRIKEOUT--+

>--,--displaceY--,--step--,--sleep--,--color--)---------------><


]]>
</programlisting>

<para>The ScrollInButton method scrolls text within a
button. It is similar to the <link linkend="h000879">ScrollText</link> method, except
that you have to pass an ID instead of a window handle.</para>
</section>

<section id="h000913"><title>ScrollButton</title>
<indexterm><primary>ScrollButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ScrollButton(--id--,--xPos--,--yPos--,--left--,--top-->

>--,--right--,--bottom--)-------------------------------------><


]]>
</programlisting>

<para>The ScrollButton method moves the rectangle within
a button. It is used to move bitmaps within buttons. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
<varlistentry><term>xPos, yPos</term>
<listitem><para>The new position of the rectangle (in pixels)
</para></listitem></varlistentry>
<varlistentry><term>left, top, right, bottom</term>
<listitem><para>The extension of the rectangle
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="sifm"><title>SetItemFont</title>
<indexterm><primary>SetItemFont</primary></indexterm>
<programlisting>
<![CDATA[
                                                    +-1--------+
>>--aBaseDialog~SetItemFont(--id--,--fonthandle--,--+----------+--)--><
                                                    +--redraw--+


]]>
</programlisting>

<para>The SetItemFont method changes the font for a particular
dialog item.</para>
<para>The best place to call this method is within <link linkend="mthInitDialog">InitDialog</link>.
If the font is no longer needed, for instance, when the dialog is closed or
another font has been assigned to the dialog item, you should free the font
resource by calling <link linkend="deletefont">DeleteFont</link>. A good place to
do this is the <link linkend="leavi">Leaving</link> method.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the dialog item.
</para></listitem></varlistentry>
<varlistentry><term>fonthandle</term>
<listitem><para>The handle returned by <link linkend="mthCreateFontEx">createFontEx</link>.
</para></listitem></varlistentry>
<varlistentry><term>redraw</term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Do not redraw the item.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Redraw the item, which is the default.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example sets a 12-point Arial font for item 101.
<programlisting>
<![CDATA[
::method InitDialog
     .
     .
     .
   hFont=self~createFontEx("Arial",12)
   self~SetItemFont(101,hFont,0)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
<para></para>
</section>

<section id="mthGetTextSize"><title>GetTextSize <emphasis role="bold">(deprecated)</emphasis></title>
<indexterm>
  <primary>deprecated</primary>
  <secondary>PlainBaseDialog class</secondary>
  <tertiary>getTextSize</tertiary>
</indexterm>
<note><title>Note</title>
<para>
  This method is deprecated.  It is maintained for compatibility to versions of ooDialog previous to
  4.0.0. It's functionality is replaced by the <link
  linkend="mthGetTextSizeDlgClsPlainBaseDialog">getTextSizeDlg</link>() method. Do <emphasis
  role="bold">not</emphasis> use this method in new code. Try to migrate existing code to use the
  <computeroutput>getTextSizeDlg()</computeroutput> method. This method may not exist in future versions
  of ooDialog.
</para>
<para>
  This method never worked correctly, the previous documentation for this method was incorrect and /
  or misleading. That has been fixed with with getTextSizeDlg(). The documentation for getTextSizeDlg()
  correctly explains how the method works and, hopefully, is not misleading.
</para></note>
</section>


</section>

<section id="man0025"><title>Animated Buttons</title>
<indexterm><primary>animated button methods</primary></indexterm>
<para>The methods listed below work with animated buttons.</para>

<section id="h001383"><title>AddAutoStartMethod</title>
<indexterm><primary>AddAutoStartMethod</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~AddAutoStartMethod(--+---------+--,--MethodName--+---------------+--)-><
                                    +-InClass-+                 +-,--Parameters-+


]]>
</programlisting>

<para>The AddAutoStartMethod method adds a method name
and parameters to a special internal queue. All methods in this queue will
be started automatically and run concurrently when the dialog is executed.
The given method (MethodName) in the given class (InClass) is started concurrently with the dialog when
the dialog is activated using the <link linkend="h000048">Execute</link> or <link linkend="h000057">ExecuteAsync</link> method. This is useful for processing animated
buttons. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>InClass</term>
<listitem><para>The class where the method is defined. If this argument is omitted,
the method is assumed to be defined in the dialog class.
</para></listitem></varlistentry>
<varlistentry><term>MethodName</term>
<listitem><para>The name of the method
</para></listitem></varlistentry>
<varlistentry><term>Parameters</term>
<listitem><para>All parameters that are passed to this method
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example installs the ExecuteB method
of the MyAnimatedButton class so that it is processed
concurrently with the dialog execution:

<programlisting>
<![CDATA[
MyDialog~AddAutoStartMethod("MyAnimatedButton", "ExecuteB")

::class MyAnimatedButton
::method ExecuteB
     .
     .
     .
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001393"><title>ConnectAnimatedButton</title>
<indexterm><primary>ConnectAnimatedButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectAnimatedButton(--id,--+------------+--,--->
                                            +-msgToRaise-+

>--+-----------+--,--bmpFrom--,--+-------+--,--moveX--,--moveY--,-->
   +-AutoClass-+                 +-bmpTo-+

>--+-------+--,--+-------+--,--delay--,--+------+--,--+------+--)-><
   +-sizeX-+     +-sizeY-+               +-xNow-+     +-yNow-+


]]>
</programlisting>

<para>The ConnectAnimatedButton method installs an animated
button and runs it concurrently with the main activity. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the button
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The name of a method within the same class. This method is called each
time the button is clicked.
</para></listitem></varlistentry>
<varlistentry><term>AutoClass</term>
<listitem><para>The class that controls the animation (default is <link linkend="anibut">AnimatedButton Class</link>)
</para></listitem></varlistentry>
<varlistentry><term>bmpFrom</term>
<listitem><para>The ID of the first bitmap in the animation sequence within a binary
resource. It can also be the name of an array stored in the .local directory
containing handles of bitmaps to be animated and bmpTo is omitted. See <link linkend="h000667">LoadBitmap</link> for how to get bitmap
handles. The array starts at index 1.
</para></listitem></varlistentry>
<varlistentry><term>bmpTo</term>
<listitem><para>The ID of the last bitmap in the animation sequence within a binary
resource. If omitted, bmpFrom is expected to be the
name of an array stored in .local that holds the bitmap handles of the bitmaps
that are to be animated.
</para></listitem></varlistentry>
<varlistentry><term>moveX, moveY</term>
<listitem><para>Size of one move (in pixels)
</para></listitem></varlistentry>
<varlistentry><term>sizeX, sizeY</term>
<listitem><para>Size of the bitmaps (if omitted, the size of the bitmaps is retrieved)
</para></listitem></varlistentry>
<varlistentry><term>delay</term>
<listitem><para>The time in milliseconds the method waits after each move
</para></listitem></varlistentry>
<varlistentry><term>xnow, ynow</term>
<listitem><para>The starting position of the bitmap
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example defines and runs an animated button. The example
loads ten bitmaps (&quot;anibmp1.bmp&quot; to &quot;anibmp10.bmp&quot;) into memory
and stores them into the array "My.Bitmaps" that is stored in the .local directory.
The name "My.Bitmaps" is specified as the <computeroutput>bmpfrom</computeroutput> and <computeroutput>bmpto</computeroutput> is omitted. After the dialog execution the bitmaps are removed from
memory again. The sample also uses a different animation class (".MyAnimation")
which subclasses from .AnimatedButton and overrides method HitRight which
plays a tune each time the animated bitmap hits the right border.
</para></listitem></varlistentry>
</variablelist>

<programlisting>
<![CDATA[
/* store array in .local */
.Local["My.Bitmaps"] = .array~new(10)
/* load 10 bitmaps into .local array */
do i= 1 to 10
  .Local["My.Bitmaps"][i] = Dialog~LoadBitmap("anibmp"i".bmp")
  /* you could also use .My.Bitmaps[i] =  ... */
end

/* connect bitmap sequence and .MyAnimated class with button IDANI */
Dialog~ConnectAnimatedButton("IDANI", ,.MyAnimation,"My.Bitmaps", ,1,1, , ,100)

...
Dialog~Execute
...

/* Free the bitmap previously loaded */
do bmp over .Local["My.Bitmaps"] /* You could also use do bmp over .My.Bitmaps */
   Dialog~RemoveBitmap(bmp)
end


::class MyAnimation subclass AnimatedButton

/* play sound.wav whenever the bitmap hits the right border */

::method HitRight
   ret = Play("sound.wav", yes)
   return self~super:hitright
]]>
</programlisting>
</section>
</section>

<section id="nnn"><title>Menu Methods</title>
<indexterm><primary>menu methods</primary>
<secondary>BaseDialog class</secondary></indexterm>
<para>The methods listed below manipulate a menu connected to the dialog.</para>

<section id="cmim"><title>ConnectMenuItem</title>
<indexterm><primary>ConnectMenuItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~ConnectMenuItem(--id--,--msgToRaise--)---------><


]]>
</programlisting>

<para>The ConnectMenuItem method is called to connect
a menu item selection with a method. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the menu item.
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The name of the method that is to be called.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>See <link linkend="mthConnectButton">ConnectButton</link>.
</para></listitem></varlistentry>
</variablelist>
<para>Do not use one of the menu item methods below, prior to the SetMenu method. If you call one of these methods before SetMenu has been
called, the intended action will not be processed and the return code is unpredictable.</para>
</section>

<section id="emim"><title>EnableMenuItem</title>
<indexterm><primary>EnableMenuItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~EnableMenuItem(--id--)-------------------------><


]]>
</programlisting>

<para>The EnableMenuItem method is called to enable a
menu item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the menu item to be enabled.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="dmim"><title>DisableMenuItem</title>
<indexterm><primary>DisableMenuItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~DisableMenuItem(--id--)------------------------><


]]>
</programlisting>

<para>The DisableMenuItem method is called to disable
a menu item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the menu item to be disabled.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="chmim"><title>CheckMenuItem</title>
<indexterm><primary>CheckMenuItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~CheckMenuItem(--id--)--------------------------><


]]>
</programlisting>

<para>The CheckMenuItem method is called to set the check
mark for a menu item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the menu item to be checked.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="uchmim"><title>UncheckMenuItem</title>
<indexterm><primary>UncheckMenuItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~UncheckMenuItem(--id--)------------------------><


]]>
</programlisting>

<para>The UncheckMenuItem method is called to remove
the check mark from a menu item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the menu item to be unchecked.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="gmim"><title>GrayMenuItem</title>
<indexterm><primary>GrayMenuItem</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GrayMenuItem(--id--)---------------------------><


]]>
</programlisting>

<para>The GrayMenuItem method is called to disable a
menu item. The menu item is grayed.</para>
<para><link linkend="emim">EnableMenuItem</link> is used to reset the grayed state. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the menu item to be grayed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="smirm"><title>SetMenuItemRadio</title>
<indexterm><primary>SetMenuItemRadio</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~SetMenuItemRadio(--idstart--,--idend--,--idset--)><


]]>
</programlisting>

<para>The SetMenuItemRadio method is used to change the
selection for a radio button menu group. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>idstart</term>
<listitem><para>The ID of the first menu item in the group.
</para></listitem></varlistentry>
<varlistentry><term>idend</term>
<listitem><para>The ID of the last menu item in the group.
</para></listitem></varlistentry>
<varlistentry><term>idset</term>
<listitem><para>The ID of the menu item that is to be selected.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example shows how to change the selection within a radio
button group. Menu item 102 gets the radio button.
<programlisting>
<![CDATA[
self~SetMenuItemRadio(101, 105, 102)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="gmism"><title>GetMenuItemState</title>
<indexterm><primary>GetMenuItemState</primary></indexterm>
<programlisting>
<![CDATA[
>>-aBaseDialog~GetMenuItemState(--id--)-----------------------><


]]>
</programlisting>

<para>The GetMenuItemState method returns the state of
a given menu item </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the menu item whose state is of interest.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>Return values:</term>
<listitem><para>CHECKED DISABLED GRAYED HIGHLIGHTED
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="debuggingmeth"><title>Debugging Method</title>
<indexterm><primary>debugging methods</primary></indexterm>
<para>The following method displays the internal setting of the dialog administration
table.</para>

<section id="dumpdialog"><title>Dump</title>
<indexterm><primary>Dump</primary></indexterm>
<para>The Dump method displays the internal settings
of the dialog administration table. This method can be helpful for debugging
OODialog programs.</para>
<programlisting>
<![CDATA[
>>-Dump(--+-------------+--)----------------------------------><
          +-dialogadmin-+


]]>
</programlisting>

<para></para>
<variablelist>
<varlistentry><term><emphasis role="bold">Argument:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>dialogadmin</term>
<listitem><para>A pointer to a particular dialog administration record. If you specify
this argument, you get detailed information on this record. If you omit this
argument, all administration records (one for each dialog of the active process)
are listed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
</variablelist>
</section>
</section>
</chapter>
