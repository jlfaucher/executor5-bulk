<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog Reference SGML file.
    #
    # Copyright (c) 2005-2011, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->


<section id="sctConnectingEvents"><title>Connecting Events</title>
<indexterm><primary>connecting events</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connect event methods</secondary></indexterm>
<indexterm><primary>connect event methods</primary><secondary>dialog object</secondary></indexterm>
<para>
  The dialog object methods that create a connection between a Windows <link linkend="ovvEvents">event</link>
  notification and a method of the Rexx dialog object are all implemented in the <link
  linkend="clsEventNotification">EventNotification</link> class. These methods are documented here.
</para>

<section id="mthConnectHelp"><title>connectHelp</title>
<indexterm><primary>connectHelp</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectHelp</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectHelp</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectHelp(--methodname--)-----------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectHelp</emphasis> method connects the Windows Help event with a method in the dialog. The Windows Help
  event occurs when the user presses the F1 key.  (Only the Help events generated when the dialog is the active window
  are connected.)
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The only argument is:
  <variablelist>
    <varlistentry><term>methodName [required]</term>
    <listitem>
    <para>
      The name of the method that to be invoked when the help event occurs. The name can not be the empty string.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para></listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Note that the Windows help event notification connected by this method is not the same as the help <emphasis
    role="bold">command</emphasis> event notification <link linkend="sctStandardEventMethods">automatically</link>
    connected when a dialog object is instantiated.
  </para>
  <para>
    The method connected to the Help event will receive the following four arguments in the order listed:
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the dialog, dialog control, or menu item that had the focus when the F1 key was pressed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>type</term>
    <listitem>
    <para>
      Specifies if the ID in argument 1 was from a window (a dialog or dialog control) or from a menu item.  This
      argument will either be <computeroutput>WINDOW</computeroutput> or <computeroutput>MENU
    </computeroutput>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mouseX</term>
    <listitem>
    <para>
      The x coordinate of the mouse at the time the F1 key was pressed.  This value is an absolute screen coordinate
      (pixel) and note that the mouse will not necessarily be over the dialog.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mouseY</term>
    <listitem>
    <para>
      The y coordinate of the mouse at the time the F1 key was pressed.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
    <para>
    This method is a member of the <link linkend="clsEventNotification">EventNotification</link> mixin class.
  </para>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    help events happen.
  </para>
  <para>
    In Windows itself, the dialog receives this notification as a WM_HELP message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>

<programlisting>
<![CDATA[

::method init
    self~init:super
    ...
    self~connectResize(onResize)
    self~connectHelp(onHelp)
    ...

::method onHelp
    use arg id, type, mouseX, mouseY
    if type == "MENU" then w = 'Menu id' id; else w = 'Dialog id' id
    say "Help request:"
    say " " w
    say "  Mouse position x:" mouseX "y:" mouseY

/* As the user presses the F1 key at various times when the dialog has the focus
 * the output might be as follows:
 */

Help request:
  Dialog id 12
  Mouse position x: 420 y: 106
Help request:
  Menu id 60
  Mouse position x: 204 y: 93
Help request:
  Menu id 65
  Mouse position x: 203 y: 166
Help request:
  Dialog id 14
  Mouse position x: 218 y: 410
Help request:
  Dialog id 80
  Mouse position x: 387 y: 462
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectResize"><title>connectResize</title>
<indexterm><primary>connectResize</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectResize</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectResize</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectResize(--methodName--)------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectResize</emphasis> method connects a size event notification to the underlying
  dialog with a method in the Rexx dialog. The notification is sent to the dialog after its size has changed.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The only argument is:
  <variablelist>
    <varlistentry><term>methodName [required]</term>
    <listitem>
    <para>
      The name of the method that is invoked each time the size of the dialog has changed. The method name can not be the
      empty string and must be less than 256 characters in length.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    This method is a member of the <link linkend="clsEventNotification">EventNotification</link> mixin class.
  </para>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    size events happen.
  </para>
  <para>
    The underlying dialog receives the WM_SIZE message as the notification for this event.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example 1:</emphasis></term>
  <listitem>

<programlisting>
<![CDATA[
  dlg = .ResizingDialog~new
  dlg~createCenter(100, 60, "Resize Me", "THICKFRAME")
  dlg~execute("SHOWTOP")

::requires 'ooDialog.cls'

::class 'ResizingDialog' subclass UserDialog

::method init
  forward class (super) continue

  self~connectResize("onSize")

::method onSize
  use arg sizeEvent, sizeInfo

  -- sizeInfo contains information about the new width and height in pixels.
  w = .DlgUtil~loWord(sizeinfo)
  h = .DlgUtil~hiWord(sizeinfo)
  say "New width=" w ", new height=" h

]]>
</programlisting>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example 2:</emphasis></term>
  <listitem>
  <para>
    This example is pulled from the <link linkend="exampleFileViewer">File Viewer</link> example at the end of the
    &quot;Appearance and Behavior Methods&quot; section. A complete working example is presented there that uses a
    number of the dialog methods.

<programlisting>
<![CDATA[

::method defineDialog
  expose wasMinimized

  wasMinimized = .false
  style = "VSCROLL HSCROLL MULTILINE READONLY"
  self~createEdit(IDC_MULTILINE, 0, 0, 170, 180, style, "cEntry")
  self~connectResize("onSize")
  ...

/* The first arg, sizeEvent, is a flag that the OS sends specifying the type of
 * size event.  We are only interested in these 3 flags:
 *
 * SIZE_RESTORED   = 0
 * SIZE_MINIMIZED  = 1
 * SIZE_MAXIMIZED  = 2
 */
::method onSize
  expose wasMinimized
  use arg sizeEvent, sizeInfo

  if sizeEvent = 1 then wasMinimized = .true

  if sizeEvent = 0 |  sizeEvent = 2 then do
    if \ wasMinimized then self~resizeEditControl
    wasMinimized = .false
  end

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectResizing"><title>connectResizing</title>
<indexterm><primary>connectResizing</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectResizing</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectResizing</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectResizing(--methodName--)--------------><

]]>
</programlisting>

<para>
  Connects a <emphasis role="italic">sizing</emphasis> <link linkend="ovvEvents">event</link> notification sent to the
  underlying dialog with a method in the Rexx dialog. The notification is sent to the dialog <emphasis
  role="italic">before</emphasis> its size has changed.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The only argument is:
  <variablelist>
    <varlistentry><term>methodName [required]</term>
    <listitem>
    <para>
      The name of the method that is invoked each time the size of the dialog is about to be changed. The method name
      can not be the empty string.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    By processing the sizing event notification, the programmer can monitor the size and position of the drag rectangle
    of the dialog being resized and, if desired, can change its size or position.
  </para>
  <para>
    Common guidelines on <link linkend="paraWhereToConnectEvents">where</link> to invoke the <emphasis
    role="italic">connectResizing</emphasis> method and on <link linkend="sctCodingEventHandlers">how</link>
    to code event handlers are included in the documentation for the <link
    linkend="clsEventNotification">EventNotification</link> class.
  </para>
  <para>
    The interpreter invokes the event handler directly and waits in the window <link
    linkend="ovvWindowMessages">message</link> processing loop for the return from the event handler. Connecting the
    sizing event requires that the programmer reply to the event from the event handler in a timely manner.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Event Handler:</emphasis></term>
  <listitem>
  <para>
    The event handler for the sizing event is invoked when the user is dragging the sizing border of the dialog to
    change the size of the dialog. The programmer must reply <computeroutput>.true</computeroutput> or
    <computeroutput>.false</computeroutput> to this notification.
  </para>
  <para>
    The event handler recieves 2 arguments. The first argument is a <computeroutput>Rect</computeroutput> object with
    the coordinates of the new size for the dialog. The programmer can change the coordinates in the
    <computeroutput>Rect</computeroutput> object and reply <computeroutput>.true</computeroutput>. This causes the
    dialog to be resized to the changed coordinates in the <computeroutput>Rect</computeroutput> object rather than the
    coordinates originally specified.
  </para>
  <para>
    If the programmer replies <computeroutput>.false</computeroutput>, then any changes to the coordinates in the
    <computeroutput>Rect</computeroutput> object are ignored and the dialog's size is changed to the size originally
    specified.
  </para>
  <para>
    A typical event handler would look like this:
  </para>

<programlisting>
<![CDATA[
::method onResizing unguarded
  use arg rect, direction
  ...
  return boolean
]]>
</programlisting>
  <para>
    The arguments to the event handler are:
    <variablelist>
      <varlistentry><term>rect</term>
      <listitem>
      <para>
        A <computeroutput>Rect</computeroutput> object that specifies the size the dialog is about to be changed to.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>direction</term>
      <listitem>
      <para>
        A keyword that specifies which edge of the dialog window is being sized. The keyword will be exactly one of the
        following:
      </para>
      <para>
        <simplelist type='vert' columns='3'>
          <member>BOTTOM</member>   <member>BOTTOMLEFT</member> <member>BOTTOMLEFT</member>
          <member>LEFT</member>     <member>RIGHT</member>      <member>TOP</member>
          <member>TOPLEFT</member>  <member>TOPRIGHT</member>
        </simplelist>
      </para>
      <variablelist>
        <varlistentry><term>BOTTOM</term>
        <listitem>
        <para>
          The bottom edge is being dragged.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>BOTTOMLEFT</term>
        <listitem>
        <para>
          The bottom-left corner is being dragged.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>BOTTOMRIGHT</term>
        <listitem>
        <para>
          The bottom-right corner is being dragged.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>LEFT</term>
        <listitem>
        <para>
          The left edge is being dragged.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>RIGHT</term>
        <listitem>
        <para>
          The right edge is being dragged.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>TOP</term>
        <listitem>
        <para>
          The top edge is being dragged.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>TOPLEFT</term>
        <listitem>
        <para>
          The top-left corner is being dragged.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>TOPRIGHT</term>
        <listitem>
        <para>
          The top-right corner is being dragged.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    This method is a member of the <link linkend="clsEventNotification">EventNotification</link> mixin class.
  </para>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    sizing events happen.
  </para>
  <para>
    The underlying dialog receives the WM_SIZING message as the notification for this event.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example shows, partially, how to prevent a resizable dialog from being sized smaller than 300 pixels high. A
    complete implementation would also have to handle the TOPLEFT, TOPRIGHT, etc., directions. And, normally, an
    implementation would also enforce a minimum width.
  </para>
  <para>
    A complete implementation can be found in the <computeroutput>dlgAreaDemoThree.rex</computeroutput> example program.

<programlisting>
<![CDATA[
::method init
  ...

  self~connectResizing("onSizing")

::method onSizing
  use arg rect, direction

  select
    when direction == 'TOP' then do
      if rect~bottom - rect~top < 300 then do
        rect~top = rect~bottom - 300
        return .true
      end
    end
    when direction == 'BOTTOM' then do
      if rect~bottom - rect~top < 300 then do
        rect~bottom = rect~top + 300
        return .true
      end
    end
    ...
    otherwise
      nop
  end

  return .false

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


<section id="mthConnectSizeMoveEnded"><title>connectSizeMoveEnded</title>
<indexterm><primary>connectSizeMoveEnded</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectSizeMoveEnded</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectSizeMoveEnded</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectSizeMoveEnded(--methodName--+--------------+--)-----><
                                       +-,-willReply--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectSizeMoveEnded</emphasis> method connects the Windows exit size / move <link
  linkend="ovvEvents">event</link> with an event handling method in the Rexx dialog object. This event is sent exactly
  one time when the user has stopped moving or stopped resizing the dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are
  <variablelist>
    <varlistentry><term>methodName [required]</term>
    <listitem>
    <para>
      The name of the event handling method that to be invoked when the the size / move exit event occurs. The name must
      not be the empty string and must be less than 256 characters in length.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The default behavior is for the interpreter to wait in the window <link linkend="ovvWindowMessages">message</link>
      processing loop for the return from the event handler, (the default for <emphasis
      role="italic">willReply</emphasis> is <computeroutput>.true</computeroutput>). However, the operating system
      ignores the return from this event notification. Specifying <computeroutput>.false</computeroutput> changes the
      default behavior so that the interpreter does not wait for the return from the event handling method.
    </para>
    </listitem></varlistentry>
  </variablelist> </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return values are:
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Unlike most event handlers, the event handling method for the size / move ended event does not receive any
    arguments. As noted above, the Windows operating system ignores the return value to the event notification.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
    <para>
    This method is a member of the <link linkend="clsEventNotification">EventNotification</link> mixin class.
  </para>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    exit size / move events happen.
  </para>
  <para>
    In Windows itself, the dialog receives this notification as a WM_EXITSIZEMOVE message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example comes from a resizable dialog implemented through the <link linkend="clsDlgAreaU">DlgAreaU</link>
    class. It turns off forcing the dialog controls to redraw in the <computeroutput>DlgAreaU</computeroutput> object,
    and only has the controls redraw once when the sizing is finished.

<programlisting>
<![CDATA[

::method init
    expose sizing

    self~init:super
    ...
    self~connectResize('onResize')
    self~connectSizeMoveEnded('onExitSizeMove')
    sizing = .false
    ...


::method defineDialog
  expose u

  u = .dlgAreaU~new(self)
  u~updateOnResize = .false


::method onResize unguarded
  expose u sizing
  use arg ignored, sizeinfo

  sizing = .true

  u~resize(self, sizeinfo)
  return 0

::method onExitSizeMove unguarded
    expose sizing

    if sizing then do
      -- The user has stopped sizing the dialog, we'll now show all the dialog
      -- controls we hid previously, and force the controls to redraw.
      self~showAllControls
      self~update
      sizing = .false
    end

    return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectMove"><title>connectMove</title>
<indexterm><primary>connectMove</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectMove</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectMove</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectMove(--methodName--)--------------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectMove</emphasis> method connects a dialog move event notification with a method in
  the Rexx dialog. The notification is sent after the position of the dialog has changed.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The only argument is:
  <variablelist>
    <varlistentry><term>methodName [required]</term>
    <listitem>
    <para>
      The name of the method that will be invoked each time the dialog has moved. The name can not be the empty string
      and it must be less than 256 characters in length.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    This method is a member of the <link linkend="clsEventNotification">EventNotification</link> mixin class.
  </para>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    move events happen.
  </para>
  <para>
    The underlying dialog receives this event notification as a WM_MOVE message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>

<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  forward class (super) continue

  self~connectMove(onMove)

::method onMove
  use arg unUsed, posInfo

  -- The dialog position has changed, print out where we are.
  x = .DlgUtil~loWord(posInfo)
  y = .DlgUtil~hiWord(posInfo)
  say 'At coordinate (' x',' y' ) on the screen. (In pixels.)'

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>
<section id="mthConnectPosChanged"><title>connectPosChanged</title>
<indexterm><primary>connectPosChanged</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectPosChanged</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectPosChanged</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectPosChanged(--methodName--)--------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectPosChanged</emphasis> method connects the position changed event notification sent
  to a dialog to a method in the Rexx dialog object. This notification is sent to the dialog when its size, position, or
  place in the Z order has changed .
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The only argument is:
  <variablelist>
    <varlistentry><term>methodName [required]</term>
    <listitem>
    <para>
      The name of the method that will be invoked each time the dialog has moved. The name can not be the empty string
      and it must be less than 256 characters in length.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method. This could be because the message
      table is full or the interpreter is out of usable memory.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    This method is a member of the <link linkend="clsEventNotification">EventNotification</link> mixin class.
  </para>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    position changed events happen.
  </para>
  <para>
    In Windows itself, the dialog receives this event notification as a WM_WINDOWPOSCHANGED message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>

<programlisting>
<![CDATA[
::class 'MyDlgClass' subclass UserDialog

::method initDialog
  ...
  self~connectPosChanged("onNewPos")

::method onNewPos
  rect = self~windowRect
  say "The new dialog window rectangle is:"
  say "  Left:  " rect~left
  say "  Top:   " rect~top
  say "  Right: " rect~right
  say "  Bottom:" rect~bottom
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectDraw"><title>connectDraw</title>
<indexterm><primary>connectDraw</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectDraw</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectDraw</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectDraw--(--+-----+--+---------------+--)--------------><
                    +--id-+  +-,--methodName-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectDraw</emphasis> method connects the draw control event notification with a method
  in the Rexx dialog. This notification is sent to the underlying dialog by an owner-drawn button, combo box, list box,
  or menu, when a visual aspect of the control or menu has changed.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [optional]</term>
      <listitem>
      <para>
        The resource ID of the dialog control whose notification is being connected. This can be symbolic or numeric. If
        the ID is omitted, all drawing event notifications, of all owner-drawn controls in the dialog, will invoke the
        method.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>methodName [optional]</term>
      <listitem>
      <para>
        The name of the method that is to be invoked each time the draw control event occurs. The method name must not be
        the empty string and must be less than 256 characters in length. If this argument is omitted, then the ooDialog
        framework will connect the notification to the <computeroutput>onDraw</computeroutput> method.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The specified symbolic ID could not be resolved.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The notification was not connected correctly.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    The notification for the draw control is only sent to the above mentioned controls when they have the OWNERDRAW
    style.
  </para>
  <para>
    This method is a member of the <link linkend="clsEventNotification">EventNotification</link> mixin class.
  </para>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    draw events happen.
  </para>
  <para>
    In Windows itself, the dialog receives this event notification as a WM_DRAWITEM message.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectMouseCapture"><title>connectMouseCapture</title>
<indexterm><primary>connectMouseCapture</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectMouseCapture</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectMouseCapture</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectMouseCapture(--methodName--)------------------------><

]]>
</programlisting>

<para>
  An event notification is generated when a window <emphasis role="bold">loses</emphasis> the mouse capture. The
  <emphasis role="italic">connectMouseCapture</emphasis> method connects that event notification to a method in the Rexx
  dialog. This event is generated, for example, when the user moves a dialog with the mouse and then releases the mouse
  button.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
      <varlistentry><term>methodName [required]</term>
      <listitem>
      <para>
        The nane of the method that will be invoked upon receiving this event notification. The name can not be the empty
        string and must be less than 256 characters in length.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method. This could be because the message
      table is full or the interpreter is out of usable memory.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    This method is a member of the <link linkend="clsEventNotification">EventNotification</link> mixin class.
  </para>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    draw events happen.
  </para>
  <para>
    The underlying dialog receives a WM_CAPTURECHANGED message as the notification for this event.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectKeyPressDialogObject"><title>connectKeyPress</title>
<indexterm><primary>connectKeyPress</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectKeyPress</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectKeyPress</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectKeyPress(--methodName--,--keys-+------------+--)----><
                                          +-,--filter--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectKeyPress</emphasis> method connects a key press <link
  linkend="ovvEvents">event</link> notification with a method in the Rexx dialog. A single key or multiple keys can be
  connected to the same method.  Multiple methods can be connected for key press events, but only 1 method can be
  connected to any single key.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>methodName [required]</term>
      <listitem>
      <para>
        The name of the method that is to be invoked when the key press event happens. This argument can not be the
        empty string.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>keys [required]</term>
      <listitem>
      <para>
        The key (or keys) for which the key press event is to be connected. A single key or multiple keys can be
        specified. A range of keys can be used.  Each single key or range of keys is separated by a comma.  A range of
        keys is denoted by using the dash character &quot;-&quot;.  White space within the <emphasis
        role="italic">keys</emphasis> argument is ignored. This argument can not be the empty string.
      </para>
      <para>
        The keys are specified by the numeric value defined by Microsoft for its virtual key set.  These numeric values
        are 0 through 255. There are some integer values between 0 and 255 that do not have a virtual key assigned to
        them. For example, 0, 7, 10, 11, and 255 are not used. The <link linkend="clsVK">VK</link> class contains
        constants for all of the defined virtual keys.
      </para>
      <para>
        In addition, there are a few keywords that can be used to specify some common key ranges. These keywords are:
        <variablelist>
          <varlistentry><term>ALL</term>
          <listitem>
          <para>
            All keys.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>FKEYS</term>
          <listitem>
          <para>
            All Function keys, other than F1.  (In Windows the F1 key is the help key and the <link
            linkend="mthConnectHelp">connectHelp</link> method should be used for F1.)
          </para>
          </listitem></varlistentry>
          <varlistentry><term>ALPHA</term>
          <listitem>
          <para>
            The keys A though Z.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>NUMERIC</term>
          <listitem>
          <para>
            The keys 0 through 9.  Note that these are the normal number keys, not the keypad numbers on an enhanced
            keyboard.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>ALPHANUMERIC</term>
          <listitem>
          <para>
            The keys A through Z and 0 through 9.
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      <para>
        <emphasis role="bold">Note</emphasis> that case is insignificant for these keywords as is the order of the
        keywords. A keyword not in the list will result in a return of -9. However, if the argument contains other valid
        key tokens, those keys will be connected to the method.  If there are no other valid key tokens, then no
        connection is made.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>filter [optional]</term>
      <listitem>
      <para>
        A (simplistic) filter that is applied to the key press event for the key(s) specified.  The filter is a string of
        keywords separated by blanks. (Case is not significant, neither is the order of the words.  Any words other than
        the specified keywords are ignored.) The possible keywords are: <computeroutput>SHIFT, CONTROL, ALT, AND, NONE,
        VIRTUAL.</computeroutput>
      </para>
      <para>
        The VIRTUAL keyword can be abbreviated to VIRT if desired. The VIRTUAL keyword effects how the test for the
        shift, control, and alt key is performed. By default the physical state of the keyboard is checked to see if the
        control, alt, or shift key is depressed. However, it is common in Windows to use keystroke programs that inject
        keystrokes into other application windows. Testing the physical state of the keyboard will not detect
        combination keystrokes like Ctrl-S, Alt-L, etc., that are inserted by keystroke programs because the physical
        state of the modifier keys control and alt will not be depressed. If the VIRTUAL keyword is used, the test for
        the modifier keys being down will be altered in a way that will detect if the virtual state of the key is down.
        This test will detect key events inserted into the Rexx application by third party keystroke programs.
      </para>
      <para>
        Shift, control, and alt specify that the corresponding key must be down at the time of the key press event. These
        keywords are combined in a boolean expression.  The default is an OR expression. If the AND keyword is present
        then the boolean expression is an AND expression. If the NONE keyword is used, it means that none of the shift,
        control, or alt keys can be down at the time of the key press event.  (When NONE is used, all other words,
        except VIRTUAL, in the string are ignored.)
      </para>
      <para>
        Some examples may make this more clear:
  <programlisting>
  <![CDATA[

  ::method initDialog

    -- Using the below, the onAltCD method would be invoked when the user types
    -- Alt-Shift-C or Alt-Shift-D.  But the method would not be invoked for Alt-C
    -- or Shift-D (or any other key press event.)

    keys = .VK~C "," .VK~D
    self~connectKeyPress(onAltCD, keys, "ALT AND SHIFT")

    -- The below would invoke the onAltCD method any time a C or a D was typed
    -- with either the Alt or the Control key down.  This would include Alt-C,
    -- Alt-Shift-C, Ctrl-Alt-Shift-C, etc..

    self~connectKeyPress(onAltCD, keys, "ALT CONTROL")

    -- The below would invoke the onAltCD method only when Alt-C or Alt-D was
    -- typed.

    self~connectKeyPress(onAltCD, keys, "ALT AND")

    -- The below would invoke the onF4 method only when the F4 key was pressed by
    -- itself. Alt-F4, Ctrl-F4, etc., would not invoke the method.

    self~connectKeyPress(onF4, .VK~F4, "NONE")
  ]]>
  </programlisting>

      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The possible return values are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        Success.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-2</term>
      <listitem>
      <para>
        The underlying mechanism in the Windows API that is used to capture key events failed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-6</term>
      <listitem>
      <para>
        The maximum number of connections has been reached.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-7</term>
      <listitem>
      <para>
        The <emphasis role="italic">methodName</emphasis> method is already connected to a key down event for this
        dialog.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-8</term>
      <listitem>
      <para>
        The <computeroutput>filter</computeroutput> argument is not correct.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-9</term>
      <listitem>
      <para>
        An incorrect format for the <computeroutput>keys</computeroutput>.  Note that it is possible to get a return of
        -9 but still have some keys connected. For instance in the following example the C and D keys would be connected
        and the filter applied. The &quot;"dog&quot;" token would result in -9 being returned:

<programlisting>
<![CDATA[

  keys = .VK~C ", dog," .VK~D
  ret = self~connectKeyPress('onAltCD', keys, "ALT AND SHIFT")
  say 'Got a return of:' ret
  say "Have connection to onAltCD?" self~hasKeyPressConnection('onAltCD')

  -- The output would be:
  Got a return of: -1
  Have connection to onAltCD? 1

]]>
</programlisting>

      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks</emphasis></term>
  <listitem>
  <para>
    Unlike most other methods that connect event notifications, the underlying Windows dialog must exist before this
    method can be used. That means it can be used in <link linkend="mthInitDialog">initDialog</link> or any time
    thereafter.  There is a maximum limit of 63 methods, per dialog, that can be connected to key press events.
    Connections can be removed using the <link linkend="mthDisconnectKeyPressDialogObject">disconnectKeyPress</link>
    method if there is no longer a need for a notification of a key press.
  </para>
  <para>
    The dialog control object also has a <link linkend="mthConnectKeyPressDialogControlObject">connectKeyPress</link>()
    method.  It is important to note this distinction between the two methods. The method of the dialog object (this
    method) will capture all key press events when the dialog is the active window. This includes key presses when a
    dialog control in the dialog has the focus.
  </para>
  <para>
    The method of the dialog control object will only capture key press events when the specific dialog control has
    the focus. This implies that if you connect the same key press event to both the dialog and to a specific dialog
    control, if the key press event occurs when the dialog control has the focus, you will receive two event
    notifications.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Detalis</emphasis></term>
  <listitem>
  <para>
    This method is a member of the <link linkend="clsEventNotification">EventNotification</link> mixin class.
  </para>
  <para>
    In general error return codes are used to indicate incorrect usage rather than raised syntax conditions. However,
    syntax errors are raised for missing required arguments, using the empty string for required arguments, or invoking
    this method before the <link linkend="ovvUnderlying">underlying</link> dialog is created.
  </para>
  <para>
    Raises syntax errors when some incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    draw events happen.
  </para>
  <para>
    Due to the nature of key press events, the low-level implementation of capturing the key strokes is different from
    most of the other methods of the <computeroutput>EventNotication</computeroutput> class. There is no single message
    sent to the underlying dialog for a key stroke event.
  </para>
  </listitem></varlistentry>
  <varlistentry id="connectKeyPressEventHandler"><term><emphasis role="bold">Event Handler Method Arguments:</emphasis></term>
  <listitem>
  <para>
    The ooDialog method connected to the key press event will receive the following five arguments in the order listed:
    <variablelist>
      <varlistentry><term>keyCode</term>
      <listitem>
      <para>
        The numeric code of the key pressed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>shift</term>
      <listitem>
      <para>
        A boolean (true or false) that denotes whether a shift key was down or up at the time of the key press. It will
        be true if a shift key was down and false if the shift key was not down.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>control</term>
      <listitem>
      <para>
        True if a control key was down at the time of the key press, false if it was not.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>alt</term>
      <listitem>
      <para>
        True if an alt key was down at the time of the key press, false if it was not.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>extraInfo</term>
      <listitem>
      <para>
        This argument is a string containing keywords.  It supplies extra information about the keyboard state at the
        time of a key press event. The string will contain some combination of these keywords
        <variablelist>
          <varlistentry><term>numOn</term>
          <listitem>
          <para>
            Num Lock was on at the time of the key press event.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>numOff</term>
          <listitem>
          <para>
            Num Lock was off.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>capsOn</term>
          <listitem>
          <para>
            Caps Lock was on at the time of the key press event.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>capsOff</term>
          <listitem>
          <para>
            Caps Lock was off.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>scrollOn</term>
          <listitem>
          <para>
            Scroll Lock was on at the time of the key press event.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>scrollOff</term>
          <listitem>
          <para>
            Scroll Lock was off.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>lShift</term>
          <listitem>
          <para>
            The left shift key was down at the time of the key press event.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>rShift</term>
          <listitem>
          <para>
            The right shift key was down.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>lControl</term>
          <listitem>
          <para>
            The left control key was down at the time of the key press event.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>rControl</term>
          <listitem>
          <para>
            The right control key was down.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>lAlt</term>
          <listitem>
          <para>
            The left alt key was down at the time of the key press event.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>rAlt</term>
          <listitem>
          <para>
            The right alt key was down.
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry id="connectKeyPressExample"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example is from a fictitious customer order system.  As the user is filling out a customer order using
    the customer order dialog, he has the F2 through F5 short cut keys available.  F2 brings up a customer look up
    dialog. F3 looks up info on the product number entered in an edit control.  F4 resets the form by clearing all the
    fields. F5 is used to print out the finished invoice.

<programlisting>
<![CDATA[
::method initDialog

  ...

  -- Capture F2 key presses, but not Ctrl-F2 or Alt-F2, etc..
  self~connectKeyPress(onF2, .VK~VK_F2, "NONE")

  -- Same idea for F3, F4, and F5.  This uses the actual numeric value for the
  -- keys without bothering to use the VK class to translate.
  self~connectKeyPress(onF3, 114, "NONE")
  self~connectKeyPress(onF4, 115, "NONE")
  self~connectKeyPress(onF5, 116, "NONE")

  ...

::method onF2
  self~showCustomerLookupDialog

::method onF3

  prodNum = self~newEdit(IDC_EDIT_PRODUCT)~getText
  if prodNum \== "" then self~showProductInfo(prodNum)

::method onF4
  self~resetAllFields

::method onF5
  self~printInvoice

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectFKeyPressDialogObject"><title>connectFKeyPress</title>
<indexterm><primary>connectFKeyPress</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectFKeyPress</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectFKeyPress(--methodName--)---------------------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectFKeyPress</emphasis> method connects a function key press event notification to a
  method in the Rexx dialog object. </para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single arguments is;
    <variablelist>
      <varlistentry><term>methodName [required]</term>
      <listitem>
      <para>
        The name of the method that is to be invoked when the key press event happens. The argument can not be the empty
        string.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The possible return values are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        Success.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-2</term>
      <listitem>
      <para>
        The underlying mechanism in the Windows API that is used to capture key events failed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-6</term>
      <listitem>
      <para>
        The maximum number of connections has been reached.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-7</term>
      <listitem>
      <para>
        The <emphasis role="italic">methodName</emphasis> method is already connected to a key down event for this
        dialog.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks</emphasis></term>
  <listitem>
  <para>
    This method works for function keys F2 through F24. In Windows the F1 key is the help key and the <link
    linkend="mthConnectHelp">connectHelp</link> method should be used for F1. This method is a convenience method and is
    exactly equivalent to:

<programlisting>
<![CDATA[
::method initDialog
  ...
  keys = .VK~F2 "-" .VK~F24
  self~connectKeyPress(methodName, keys)
]]>
</programlisting>

  </para>
  <para>
    The event handling method recieves the same arguments as the <link
    linkend="connectKeyPressEventHandler">event</link> handler for the <emphasis
    role="italic">connectKeyPress</emphasis> method .
  </para>
  <para>
    Unlike most other methods that connect event notifications, the underlying Windows dialog must exist before this
    method can be used. That means it can be used in <link linkend="mthInitDialog">initDialog</link> or any time
    thereafter.  There is a maximum limit of 63 methods, per dialog, that can be connected to key press events.
    Connections can be removed using the <link linkend="mthDisconnectKeyPressDialogObject">disconnectKeyPress</link>
    method if there is no longer a need for a notification of a key press.
  </para>
  <para>
    The dialog control object also has a <link linkend="mthConnectFKeyPressDialogControlObject">connectFKeyPress</link>()
    method. The method of the dialog object (this method) will capture any F key press event when the dialog is the
    active window. The method of the dialg control object will only capture a F key press when the control has the
    keyboard focus.
  </para>
  <para>
    Due to the nature of key press events, the low-level implementation of capturing the key strokes is different from
    most of the other methods of the <computeroutput>EventNotication</computeroutput> class. There is no single message
    sent to the underlying dialog for a key stroke event.
  </para>
  </listitem>
  </varlistentry>
  <varlistentry><term><emphasis role="bold">Detalis</emphasis></term>
  <listitem>
  <para>
    This method is a member of the <link linkend="clsEventNotification">EventNotification</link> mixin class.
  </para>
  <para>
    In general error return codes are used to indicate incorrect usage rather than raised syntax conditions. However,
    syntax errors are raised if the <emphasis role="italic">methodName</emphasis> argument is missing or the empty
    string, or invoking this method before the <link linkend="ovvUnderlying">underlying</link> dialog is created.
  </para>
  <para>
    Raises syntax errors when some incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any F
    Key key press events happen.
  </para>
  <para>
    Due to the nature of key press events, the low-level implementation of capturing the key strokes is different from
    most of the other methods of the <computeroutput>EventNotication</computeroutput> class. There is no single message
    sent to the underlying dialog for a key stroke event.
  </para>
  </listitem>
  </varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example is a variation on the <link linkend="connectKeyPressExample">example</link> shown for the
    <link linkend="mthConnectKeyPressDialogObject">connectKeyPress</link> method. It connects all the function keys to the
    same method and then determines what action to take by examining which key was pressed.

  <programlisting>
  <![CDATA[
  ::method initDialog

    ...

    -- Capture all function key presses.
    self~connectFKeyPress(onFKey)

    ...

  ::method onFKey
    use arg keyPressed

    select
      when keyPressed == .VK~F2 then self~showCustomerLookupDialog

      when keyPressed = 114 then do
        prodNum = self~newEdit(IDC_EDIT_PRODUCT)~getText
        if prodNum \== "" then self~showProductInfo(prodNum)
      end

      when keyPressed = 115 then self~resetAllFields
      when keyPressed = 116 then self~printInvoice

      otherwise do
        -- Not interested in any other function keys
        nop
      end
    end

  ]]>
  </programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthDisconnectKeyPressDialogObject"><title>disconnectKeyPress</title>
<indexterm><primary>disconnectKeyPress</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>disconnectKeyPress</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>disConnectFKeyPress</secondary></indexterm>
<programlisting>
<![CDATA[
>>--disconnectKeyPress(--+--------------+--)-----><
                         +--methodName--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">disconnectKeyPress</emphasis> method disconnects a key press event from a method that was
  previously connected using <link linkend="mthConnectKeyPressDialogObject">connectKeyPress</link>, or <link
  linkend="mthConnectFKeyPressDialogObject">connectFKeyPress</link>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
      <varlistentry><term>methodName [optional]</term>
      <listitem>
      <para>
        If <emphasis role="italic">methodName</emphasis> is specified, only the key press events connected to that
        method are disconnected. If the argument is omitted, then all key press events for the dialog will be
        disconnected.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The possible return values are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        Success.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-2</term>
      <listitem>
      <para>
        While trying to disconnect the method, the underlying mechanism in the Windows API that is used to capture key
        events had an error. This is unlikely to happen.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-7</term>
      <listitem>
      <para>
        Either the <emphasis role="italic">methodName</emphasis> method is already disconnected, or there are no methods
        connected at all.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The dialog control object also has a <link linkend="mthDisconnectKeyPressDialogControlObject">disconnectKeyPress</link>
    method. The method of the dialog object (this method) can only disconnect key press events that were set with the
    dialog object's versions of <link linkend="mthConnectKeyPressDialogObject">connectKeyPress</link> and <link
    linkend="mthConnectFKeyPressDialogObject">connectFKeyPress</link> methods. This method can not disconnect key press
    events that were set with the dialog control object's versions of <link
    linkend="mthConnectKeyPressDialogControlObject">connectKeyPress</link> and <link
    linkend="mthConnectFKeyPressDialogControlObject">connectFKeyPress</link> methods.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Detalis</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when some incorrect usage is detected.
  </para>
  <para>
    This method is a member of the <link linkend="clsEventNotification">EventNotification</link> mixin class.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example is a variation on the <link linkend="connectKeyPressExample">example</link> shown for the
    <link linkend="mthConnectKeyPressDialogObject">connectKeyPress</link> method. It builds on the fictitious customer
    order system.  The F7 key saves the completed invoice into the system and enters a different phase of the companies
    business process. At this point (for whatever fictitious business reason) the fields can no longer be cleared and
    the user is not allowed to look up customer or product information.  But, the user may still need to print the
    invoice.  To prevent the accidental press of the hot keys causing the wrong action, those key presses are
    disconnected.
  </para>
  <para>
    To demonstrate how key press connections can be added and removed through out the life time of the dialog, this
    example adds the F9 hot key.  F9 starts a new order entry cycle and re-connects the hot keys used during the
    creation of a customer invoice.  When the user then saves the next completed invoice, key press connections are
    removed, when she starts a new invoice key press connections are restored.  This cycle could continue though out the
    day without the user ever closing the main dialog.

<programlisting>
<![CDATA[

::method initDialog

  ...

  -- Capture F2 key presses, but not Ctrl-F2 or Alt-F2, etc..
  self~connectKeyPress(onF2, .VK~F2, "NONE")

  -- Same idea for F3, F4, F5, and F7.  This uses the actual numeric value for
  -- the keys without bothering to use the .VK class to translate.
  self~connectKeyPress(onF3, 114, "NONE")
  self~connectKeyPress(onF4, 115, "NONE")
  self~connectKeyPress(onF5, 116, "NONE")
  self~connectKeyPress(onF7, 118, "NONE")
  self~connectKeyPress(onF9, 120, "NONE")

  ...

::method onF2
  self~showCustomerLookupDialog

::method onF3

  prodNum = self~newEdit(IDC_EDIT_PRODUCT)~getText
  if prodNum \== "" then self~showProductInfo(prodNum)

::method onF4
  self~resetAllFields

::method onF5
  self~printInvoice

::method onF7

  self~saveToDataBase
  self~disconnectKeyPress(onF2)
  self~disconnectKeyPress(onF3)
  self~disconnectKeyPress(onF4)

::method onF9

  self~resetAllFields
  self~connectKeyPress(onF2, 112, "NONE")
  self~connectKeyPress(onF3, 114, "NONE")
  self~connectKeyPress(onF4, 115, "NONE")

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="mthHasKeyPressConnectionDialogObject"><title>hasKeyPressConnection</title>
<indexterm><primary>hasKeyPressConnection</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>hasKeyPressConnection</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>hasKeyPressConnection</secondary></indexterm>
<programlisting>
<![CDATA[
>>--hasKeyPressConnection(--+--------------+--)----------------><
                            +--methodName--+

]]>
</programlisting>

<para>
  This method is used to query if a connection to a key press event already exists.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>The single optional argument is:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      Query if any key press events are connected to the speicified method. If this argument is omitted, the query is if
      any key press events are connected to <emphasis role="bold">any</emphasis> methods.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns <computeroutput>.true</computeroutput> if the method is connected to a key press event or
    <computeroutput>.false</computeroutput> otherwise.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Detalis</emphasis></term>
  <listitem>
  <para>
    The dialog contol object also has a <link
    linkend="mthHasKeyPressConnectionDialogControlObject">hasKeyPressConnection</link> method. The method of the dialog
    object (this method) can only check for connecttions that were set with the dialog object's versions of <link
    linkend="mthConnectKeyPressDialogObject">connectKeyPress</link> and <link
    linkend="mthConnectFKeyPressDialogObject">connectFKeyPress</link> methods. This method can not check for connections
    that were set with the dialog control object's versions of <link
    linkend="mthConnectKeyPressDialogControlObject">connectKeyPress</link> and <link
    linkend="mthConnectFKeyPressDialogControlObject">connectFKeyPress</link> methods.
  </para>
  <para>
    This method is a member of the <link linkend="clsEventNotification">EventNotification</link> mixin class.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example could come from a dialog where the user has the option to use hot keys or not.  When the
    reset button is pushed the state of the dialog fields are reset.  The hot keys enabled check box is set to reflect
    whether hot keys are currently enabled or not.

<programlisting>

<![CDATA[

::method defineDialog

  ...
  self~createCheckBox(IDC_CHECK_FKEYSENABlED, 30, 60, , , , "Hot Keys Enabled")
  ...
  self~createPushButton(IDC_PB_RESET, 60, 135, 45, 15, , "Reset", onReset)
  ...

::method onReset

  ...
  if self~hasKeyPressConnection then
    self~newCheckBox(IDC_CHECK_FKEYSENABlED)~check
  else
    self~newCheckBox(IDC_CHECK_FKEYSENABlED)~uncheck
  ...

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectCommandEvents"><title>connectCommandEvents</title>
<indexterm><primary>connectCommandEvents</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectCommandEvents</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectCommandEvents</secondary></indexterm>

<programlisting>
<![CDATA[
>>--connectCommandEvents(--id--,--methodName--)----------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectCommandEvents</emphasis> method connects a Rexx dialog method to the command <link
  linkend="ovvEvents">event</link> notifications sent by a Windows dialog control to its parent dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the dialog control, may be symbolic or numeric.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>methodName [required]</term>
    <listitem>
    <para>
      The name of the method to be invoked in the Rexx dialog object each time a command event occurs in the dialog
      control. The method name can not be the empty string and must be shorter than 256 characters in length.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The specified symbolic ID could not be resolved.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An error. Most likely, either the message table is full, or the interpreter is out of usable memory.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Two arguments are sent to the connected method.  The first contains the notification code in the high word and the
    ID of the control in the low word. The second argument is the window handle of the control.
  </para>
  <para>
    The number of different notification codes and the meanings of the notifications are dependent on the type of dialog
    control specified. Therefore, it is more advisable to use the specific connectXXXEvent() method for the control.
    Such as the <link linkend="mthConnectListBoxEvent">connectListBoxEvent</link>() method.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
    <para>
      The <emphasis role="italic">connectCommandEvents</emphasis> method is a member of the <link
      linkend="clsEventNotification">EventNotification</link> mixin class.
    </para>
    <para>
      Syntax errors are raised when incorrect usage is detected.
    </para>
    <para>
      If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
      command events happen.
    </para>
    <para>
      In Windows itself, command events are sent to the parent dialog using the WM_COMMAND message.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example connects a list box command event notifications to the <emphasis role="italic">onCommand</emphasis>()
    method of the dialog. Note that the notification code 1 corresponds to the list box SELCHANGE event, 4 is the
    SETFOCUS, and 5 is KILLFOCUS events.
<programlisting>
<![CDATA[

::method initDialog
  ...
  self~connectCommandEvents(IDC_LB_FILES, onCommand)

::method onCommand
  use arg cmdCode, hwnd
  say 'cmdCode:                  ' cmdCode
  say 'hwnd:                     ' hwnd
  say 'hi word notification code:' .DlgUtil~hiWord(cmdCode)
  say 'lo word resource ID:      ' .DlgUtil~loWord(cmdCode)
  say '(List box resource ID)    ' self~constDir[IDC_LB_FILES]
  say

/* Output might be:
cmdCode:                   263147
hwnd:                      0x00100AD0
hi word notification code: 4
lo word resource ID:       1003
(List box resource ID)     1003

cmdCode:                   66539
hwnd:                      0x00100AD0
hi word notification code: 1
lo word resource ID:       1003
(List box resource ID)     1003

cmdCode:                   328683
hwnd:                      0x00100AD0
hi word notification code: 5
lo word resource ID:       1003
(List box resource ID)     1003
*/

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectNotifyEvent"><title>connectNotifyEvent</title>
<indexterm><primary>connectNotifyEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectNotifyEvent</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectNotifyEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectNotifyEvent(--id--,--event--+---------------+--)--------------------><
                                       +-,--methodName-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectNotifyEvent</emphasis> method connects one of the generic event notifications from
  a dialog control to a method in the Rexx dialog object.
</para>
<para>
  Most event notifications are specific to the particular type of control that sends them. These generic event
  notifications are common to a number of dialog controls. In general, if one of the dialog control specific event
  connection methods, such as <link linkend="mthConnectListViewEvent">connectListViewEvent</link> can make a connection
  for the event, then <emphasis role="italic">connectNotifyEvent</emphasis> should not be used. In these cases, the
  dialog control does not send one of the generic event notificaions. It sends a notification specific to itself.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem><para>The arguments are:
  <variablelist>
    <varlistentry><term>id</term>
    <listitem><para>The ID of the dialog control of which a notification is to be connected
    to a method.
    </para></listitem></varlistentry>
    <varlistentry><term>event</term>
    <listitem><para>The event to be connected with a method:
    <variablelist>
      <varlistentry><term>OUTOFMEMORY</term>
      <listitem><para>The dialog control went out of memory.
      </para></listitem></varlistentry>
      <varlistentry><term>CLICK</term>
      <listitem><para>The left mouse button was clicked on the dialog control.
      </para></listitem></varlistentry>
      <varlistentry><term>DBLCLK</term>
      <listitem><para>The left mouse button was double-clicked on the dialog control.
      </para></listitem></varlistentry>
      <varlistentry><term>ENTER</term>
      <listitem><para>The return key was pressed in the dialog item.
      </para></listitem></varlistentry>
      <varlistentry><term>RCLICK</term>
      <listitem><para>The right mouse button was clicked on the dialog item.
      </para></listitem></varlistentry>
      <varlistentry><term>RDBLCLK</term>
      <listitem><para>The right mouse button was double-clicked on the dialog control.
      </para></listitem></varlistentry>
      <varlistentry><term>GOTFOCUS</term>
      <listitem><para>The dialog item got the input focus.
      </para></listitem></varlistentry>
      <varlistentry><term>LOSTFOCUS</term>
      <listitem><para>The dialog item lost the input focus.
      </para></listitem></varlistentry>
    </variablelist>
    </para></listitem></varlistentry>
    <varlistentry><term>methodName</term>
    <listitem><para>The message that is to be sent whenever the specified notification is
    received. Provide a method with a matching name. If you omit this argument,
    the event is preceded by <computeroutput>On</computeroutput>.
    </para></listitem></varlistentry>
  </variablelist>
  </para></listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem><para>The return codes are:
  <variablelist>
    <varlistentry><term>0</term>
    <listitem><para>No error detected.
    </para></listitem></varlistentry>
    <varlistentry><term>-1</term>
    <listitem><para>The resource ID could not be resolved or the event argument is
    incorrect.
    </para></listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem><para>The message was not connected correctly. The message was not connected
    </para></listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
    <para>
      The <emphasis role="italic">connectNovityEvent</emphasis> method is a member of the <link
      linkend="clsEventNotification">EventNotification</link> mixin class.
    </para>
    <para>
      Syntax errors are raised when incorrect usage is detected.
    </para>
    <para>
      If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if the
      connected event happen.
    </para>
    <para>
      In Windows itself, these events are sent to the parent dialog using the WM_NOTIFY message.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example connects the double-click of the left mouse button on dialog control DLGITEM1 with method
    onDblClk:
<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  self~init:super(...)
  self~connectNotifyEvent(DLGITEM1, "DBLCLK")

::method onDblClk
  use arg id, hwnd
  say "Control" id " has been double-clicked! It's window handle is:" hwnd
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectStaticEvent"><title>connectStaticEvent</title>
<indexterm><primary>connectStaticEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectStaticEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectStaticNotify(--id--,--event--,-+---------------+--)-----------------><
                                          +-,--methodName-+

]]>
</programlisting>

<para>
  <emphasis role="italic">connectStaticEvent</emphasis> connects a notification message from a static control to a
  method, defined by the programmer, in the Rexx dialog object.  Normally, static controls do not send notification
  messages.  A static control will only send the messages when it has the NOTIFY style.  The notification messages
  inform the dialog that an event has occurred with regard to the static control.
</para>
<para>
  For user defined dialogs use the NOTIFY style keyword in the <link linkend="sctCreateStaticControls">create...</link>
  static control methods when the control is defined. For dialogs created from a compiled resource or a resource script
  file use the SS_NOTIFY style when defining the control in a resource editor.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the static control. May be numeric or symbolic.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event [required]</term>
    <listitem>
    <para>
      A keyword specifying the event to be connected with a method:
      <variablelist>
        <varlistentry><term>CLICK</term>
        <listitem>
        <para>
          The static control has been clicked with the mouse.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>DBLCLK</term>
        <listitem>
        <para>
          The static control has been double-clicked with the mouse.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>DISABLE</term>
        <listitem>
        <para>
          The static control has been disabled.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ENABLE</term>
        <listitem>
        <para>
          The static control has been enabled.
        </para>
        </listitem></varlistentry>
      </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The method that is to be invoked whenever the specified notification is received from the static control. The
      programmer defines this method. The method name can not be the empty string and must be less than 256 characters
      in length. If this argument is omitted, a method name is automatically generated that consists of the event
      keyword preceded by <computeroutput>on</computeroutput>. For instance, <computeroutput>onClick</computeroutput>.
    </para>
    </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
    <para>
      The return codes are:
      <variablelist>
      <varlistentry><term>0</term>
      <listitem>
        <para>
          No error detected.
        </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
        <para>
          The resource ID could not be resolved or the event argument is incorrect.
        </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
        <para>
          The message was not connected correctly. The message was not connected
        </para>
      </listitem></varlistentry>
      </variablelist>
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <orderedlist>
  <listitem>
  <para>
    There are some <link linkend="paraWhereToConnectEvents">common</link> guidelines for the invocation of the event
    connection methods.
  </para>
  </listitem>
  <listitem>
  <para>
    The defined event-handling method will receive two arguments. The first arg contains information about the
    specific control and its event. The second arg is the window handle of the static control.
  </para>
  <para>
    The low word of the first arg is the control ID and the high word is the event ID.
  </para>
  </listitem>
  </orderedlist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example comes from an application that displays employee statistics.  A single click on the employee
    number field advances the display to the next employee.  A double click on either the employee name or employee job
    duties alllows those fields to be edited.
  </para>
<programlisting>
<![CDATA[
::method initDialog

  self~connectStaticEvent(IDC_ST_EMPNO, "CLICK", empLookup)

  self~connectStaticEvent(IDC_ST_EMPJOB, "DBLCLK", editStats)
  self~connectStaticEvent(IDC_ST_EMPNAME, "DBLCLK", editStats)

  first = self~initDatabase
  self~setStats(first)
]]>
</programlisting>
  <para>
    In this example, (a continuation of the above example,) the control ID determines if the user has double clicked on
    the employee job duties field, or the employee name field.  The event ID is not used, or needed. Its purpose in the
    code snippet is simply an example. The same thing applies to the window handle.
  </para>
<programlisting>
<![CDATA[
::method editStats
  use arg ctrlInfo, ctrlHwnd

  ctrlID = .DlgUtil~loWord(ctrlInfo)
  eventID = .DlgUtil~hiWord(ctrlInfo)

  rec = self~getCurrentRecord

  if self~userUpdate(ctrlID, rec) then self~setStats(rec)
]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectButtonEvent"><title>connectButtonEvent</title>
<indexterm><primary>connectButtonEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectButtonEvent(--id--,--event--+----------------+--)-------------------><
                                       +-,--methodName--+

]]>
</programlisting>

<para>
  Connects a method in the Rexx dialog to the Windows <link linkend="ovvEvents">event</link> notification from a <link
  linkend="clsButton">button</link> control. The <emphasis role="italic">connectButtonEvent</emphasis> method is used
  for all types of buttons (push button, radio button, or check box.)
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the button control this connection applies to. This can be a symbolic ID or the numeric value
        of the ID.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>event [required]</term>
      <listitem>
      <para>
        A keyword specifying the event to be connected with a method. This can be exactly one of the following, case is
        not significant:
        <variablelist>
          <varlistentry><term>CLICKED</term>
          <listitem>
          <para>
            The button has been clicked.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>DBLCLK</term>
          <listitem>
          <para>
            The button has been double-clicked.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>DISABLE</term>
          <listitem>
          <para>
            The button has been disabled.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>GOTFOCUS</term>
          <listitem>
          <para>
            The button got the input focus.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>LOSTFOCUS</term>
          <listitem>
          <para>
            The button lost the input focus.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>HILITE</term>
          <listitem>
          <para>
            The button has been selected.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>UNHILITE</term>
          <listitem>
          <para>
            The highlighting is to be removed (lost selection).
          </para>
          </listitem></varlistentry>
          <varlistentry><term>HOTITEM</term>
          <listitem>
          <para>
            Notifies the dialog that the mouse has moved over the button, or that the mouse is leaving the area
            over the button.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>PAINT</term>
          <listitem>
          <para>
            The button is to be repainted. This notification is only sent for owner-drawn buttons.
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      </listitem></varlistentry>
      <varlistentry><term>methodName [optional]</term>
      <listitem>
      <para>
        The name of the method to inovke whenever the specified notification is received from the button control. Provide
        a method with a matching name. If you omit this argument, a method name is generated automatically. The name
        consists of the event keyword preceded by <computeroutput>on</computeroutput>. For instance:
        <computeroutput>onGotFocus</computeroutput>. The method name can not be the empty string and must be less than 256
        characters in length.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>The return codes are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        No error detected.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
      <para>
        The resource ID could not be resolved or the event argument is incorrect.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
      <para>
        The message was not connected correctly. Most likely the message table is full.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
    <orderedlist>
    <listitem>
    <para>
      The documentation for the <computeroutput>EventNotification</computeroutput> class provides some <link
      linkend="paraWhereToConnectEvents">common</link> guidelines for using the event connection methods.
    </para>
    </listitem>
    <listitem>
    <para>
      For all events other than the HOTITEM event, the event-handling methods will receive two arguments. The first arg
      contains information about the specific control and its event. The second arg is the window handle of the button
      control. The low word of the first arg is the control ID and the high word is the event ID. Example:

<programlisting>
<![CDATA[
::method handler
  use arg info, handle
  id = .DlgUtil~loWord(info)
  eventCode = .DlgUtil~hiWord(info)
  ...
]]>
</programlisting>
    </para>
    </listitem>
    <listitem>
    <para>
      The method for the HOTITEM event also receives two arguments. The first arg is the control id. The second arg is
      .true or .false. True if the mouse moved over the button, false if it left the area over the button. Example:

<programlisting>
<![CDATA[
::method onHover
  use arg id, entering
  say 'onHover() id:' id 'entering:' entering
  ...

/* Output might be:

  onHover() id: 1044 entering: 1
  onHover() id: 1044 entering: 0
  onHover() id: 1001 entering: 1
  onHover() id: 1001 entering: 0

*/
]]>
</programlisting>
     </para>
    </listitem>
    </orderedlist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    In order to recieve the GOTFOCUS, LOSTFOCUS, and DBLCLK event notifications, the button control has to have the
    NOTIFY (BS_NOTIFY) style.  For user defined dialogs use the NOTIFY style keyword in the <link
    linkend="sctCreateMethods">create ...</link> method when the button is defined.  For dialogs created from a
    compiled resource or a resource script file use the BS_NOTIFY style for the button resource.  The other event
    notifications are always sent and it is not necessary to add the NOTIFY style for those events.
  </para>
  <para>
    The <emphasis role="italic">connectButtonEvent</emphasis> method is a member of the <link
    linkend="clsEventNotification">EventNotification</link> mixin class.
  </para>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any of
    the button events occur.
  </para>
  <para>
    In Windows itself, some notifications are sent to the parent dialog using the WM_COMMAND message and others are
    sent using the WM_NOTIFY message.
  </para>
  </listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example displays a message whenever the OK button is selected:</para>
<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  self~init:super(...)
  self~connectButtonEvent("OK", "HILITE")

::method onHilite
  say "The OK button has been selected"
]]>
</programlisting>
</listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectEditEvent"><title>connectEditEvent</title>
<indexterm><primary>connectEditEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectEditEvent(--id--,--event--+---------------+--)----------------------><
                                     +-,--methodName-+
]]>
</programlisting>

<para>The connectEditEvent method connects a particular
WM_NOTIFY message for an edit control with a method. The WM_NOTIFY message
informs the dialog that an event has occurred with regard to the edit control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the edit control of which a notification is to be connected
to a method.
</para></listitem></varlistentry>
<varlistentry><term>event</term>
<listitem><para>The event to be connected with a method:
<variablelist>
<varlistentry><term>CHANGE</term>
<listitem><para>The text has been altered. This notification is sent after the screen
has been updated.
</para></listitem></varlistentry>
<varlistentry><term>UPDATE</term>
<listitem><para>The text has been altered. This notification is sent before the screen
is updated.
</para></listitem></varlistentry>
<varlistentry><term>ERRSPACE</term>
<listitem><para>An out-of-memory problem has occurred.
</para></listitem></varlistentry>
<varlistentry><term>MAXTEXT</term>
<listitem><para>The text inserted exceeds the specified number of characters for the
edit control. This notification is also sent when:
<itemizedlist>
<listitem><para>An edit control does not have the ES_AUTOHSCROLL or AUTOSCROLLH style
and the number of characters to be inserted would exceed the width of the
edit control.</para></listitem></itemizedlist>
<itemizedlist>
<listitem><para>The ES_AUTOVSCROLL or AUTOSCROLLV style is not set and the total number
of lines resulting from a text insertion would exceed the height of the edit
control.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
<varlistentry><term>HSCROLL</term>
<listitem><para>The horizontal scroll bar has been used.
</para></listitem></varlistentry>
<varlistentry><term>VSCROLL</term>
<listitem><para>The vertical scroll bar has been used.
</para></listitem></varlistentry>
<varlistentry><term>GOTFOCUS</term>
<listitem><para>The edit control got the input focus.
</para></listitem></varlistentry>
<varlistentry><term>LOSTFOCUS</term>
<listitem><para>The edit control lost the input focus.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent whenever the specified notification is
received from the edit control. Provide a method with a matching name. If
you omit this argument, the event is preceded by <computeroutput>On</computeroutput>.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The return codes are:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>No error detected.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>The resource ID could not be resolved or the event argument is
incorrect.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The message was not connected correctly. The message was not connected
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
<listitem>
  <orderedlist>
  <listitem>
  <para>
    There are some <link linkend="paraWhereToConnectEvents">common</link> guidelines for the invocation of the event
    connection methods.
  </para>
  </listitem>
  <listitem>
  <para>
    The event-handling method receives two arguments. The first arg contains information about the event. In the
    low-order word is the ID of the edit control. The high-order word contains the event ID. The second arg is the
    handle to the edit control.
  </para>
  <para><emphasis role="bold">Example:</emphasis></para>
  <programlisting>
  <![CDATA[
  ::method Handler
    use arg info, handle
    id = .DlgUtil~loWord(info)
    eventID = .DlgUtil~hiWord(info
    ...
  ]]>
  </programlisting>
  </listitem>
  </orderedlist>
</listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example verifies the input of entry line AMOUNT and resets
it to 0 when a nonnumeric value was entered:
<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  self~init:super(...)
  self~connectEditEvent("AMOUNT", "CHANGE")

::method OnChange
  ec = self~newEdit("AMOUNT")
  if ec~GetText~Space(0) \= "" & ec~GetText~DataType("N") = 0 then do
    ec~setModified(.false)
    ec~select
    ec~replaceSelText("0")
   end
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectListBoxEvent"><title>connectListBoxEvent</title>
<indexterm><primary>connectListBoxEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectListBoxEvent(--id--,--event--+---------------+--)-------------------><
                                        +-,--methodName-+

]]>
</programlisting>

<para>The connectListBoxEvent method connects a particular
WM_NOTIFY message for a list box with a method. The WM_NOTIFY message
informs the dialog that an event has occurred in the list box.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the list box of which a notification is to be connected to
a method.
</para></listitem></varlistentry>
<varlistentry><term>event</term>
<listitem><para>The event to be connected with a method:
<variablelist>
<varlistentry><term>DBLCLK</term>
<listitem><para>An entry in the list box has been selected with a double click.
</para></listitem></varlistentry>
<varlistentry><term>ERRSPACE</term>
<listitem><para>An out-of-memory problem has occurred.
</para></listitem></varlistentry>
<varlistentry><term>GOTFOCUS</term>
<listitem><para>The list box got the input focus.
</para></listitem></varlistentry>
<varlistentry><term>LOSTFOCUS</term>
<listitem><para>The list box lost the input focus.
</para></listitem></varlistentry>
<varlistentry><term>SELCANCEL</term>
<listitem><para>The selection in the list box has been canceled.
</para></listitem></varlistentry>
<varlistentry><term>SELCHANGE</term>
<listitem><para>Another list box entry has been selected.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent whenever the specified notification is
received from the list box. Provide a method with a matching name. If you
omit this argument, the event is preceded by <computeroutput>On</computeroutput>.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The return codes are:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>No error detected.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>The resource ID could not be resolved or the event argument is
incorrect.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The message was not connected correctly. The message was not connected
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example displays the text of the selected list box entry:
<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  self~init:super(...)
  self~connectListBoxEvent("MYLIST", "SELCHANGE", "SelectionChanged")

::method SelectionChanged
  li = self~newListBox("MYLIST")
  say "New selection is:" li~selected
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>


<note><title>Notes TODO FIX THIS</title><para>
<orderedlist>
<listitem><para>Connections are usually placed in the <link linkend="mthNewDialogObject">init</link> or <link linkend="mthInitDialog">initDialog</link> method. If both methods are defined, use init as the place for this connection - but not
before init:super has been called.</para></listitem>
<listitem><para>The event-handling methods receive two arguments: the ID of the list box
(extract the low-order word) and the handle to the list box. Example:
<programlisting>
<![CDATA[
::method Handler
  use arg ev_id, handle
  id = .DlgUtil~loWord(ev_id)
  ...
]]>
</programlisting></para></listitem>
</orderedlist>
</para></note>
</section>

<section id="mthConnectComboBoxEvent"><title>connectComboBoxEvent</title>
<indexterm><primary>connectComboBoxEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectComboBoxEvent(--id--,--event--+---------------+--)------------------><
                                         +-,--methodName-+

]]>
</programlisting>

<para>The connectComboBoxEvent method connects a particular
WM_NOTIFY message for a combo box with a method. The WM_NOTIFY message
informs the dialog that an event has occurred in the combo box.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The <link linkend="defResourceId">resource ID</link> of the combo
box for which a notification is to be connected to a method.
</para></listitem></varlistentry>
<varlistentry><term>event</term>
<listitem><para>The event to be connected with a method:
<variablelist>
<varlistentry><term>CHANGE</term>
<listitem><para>The text in the edit control has been altered. This notification is
sent after Windows updated the screen.
</para></listitem></varlistentry>
<varlistentry><term>UPDATE</term>
<listitem><para>The text in the edit control has been altered. This notification is
sent before Windows updates the screen.
</para></listitem></varlistentry>
<varlistentry><term>CLOSEUP</term>
<listitem><para>The list of the combo box has been closed.
</para></listitem></varlistentry>
<varlistentry><term>DROPDOWN</term>
<listitem><para>The list of the combo box is about to be made visible.
</para></listitem></varlistentry>
<varlistentry><term>DBLCLK</term>
<listitem><para>An entry in the combo box list has been selected with a double click.
</para></listitem></varlistentry>
<varlistentry><term>ERRSPACE</term>
<listitem><para>An out-of-memory problem has occurred.
</para></listitem></varlistentry>
<varlistentry><term>GOTFOCUS</term>
<listitem><para>The combo box got the input focus.
</para></listitem></varlistentry>
<varlistentry><term>LOSTFOCUS</term>
<listitem><para>The combo box lost the input focus.
</para></listitem></varlistentry>
<varlistentry><term>SELCHANGE</term>
<listitem><para>Another entry in the combo box list has been selected.
</para></listitem></varlistentry>
<varlistentry><term>SELENDOK</term>
<listitem><para>The list was closed after another entry was selected.
</para></listitem></varlistentry>
<varlistentry><term>SELENDCANCEL</term>
<listitem><para>After the selection of another entry, another control or dialog was
selected, which canceled the selection of the entry.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent whenever the specified notification is
received from the combo control. Provide a method with a matching name. If
you omit this argument, the event is preceded by <computeroutput>On</computeroutput>.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The return codes are:
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The resource ID could not be resolved or the event argument is
incorrect.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No errors were detected.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The message was not connected correctly. The message was not connected
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example invokes method PlaySong whenever the list
of the combo box with the resource ID of PROFESSIONS is about to be made
visible.  In this case PROFESSIONS is a <link linkend="defSymbolicId">symbolic
ID</link> that has been added to the <link linkend="atrConstDir">constDir</link>
directory of the MyDlgClass in another part of the program:
<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method initDialog
  self~init:super(...)
  self~connectComboBoxEvent("PROFESSIONS", "DROPDOWN", "PlaySong")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

<note><title>Notes TODO FIX THIS</title><para>
<orderedlist>
<listitem><para>Connections are usually placed in the <link
linkend="mthNewDialogObject">init</link>  or <link linkend="mthInitDialog">initDialog</link>
method. If both methods are defined, use init as the place for this connection -
but not before init:super has been called.</para></listitem>
<listitem><para>The event-handling methods receive two arguments: the first is a
combination of the ID of the combo box and the ID of the notification messages.
(Extract the low-order word to get the combo box ID.)  The second argument is
the window handle of the combo box. Example:
<programlisting>
<![CDATA[
::method PlaySong
  use arg eventID, handle
  id = .DlgUtil~loWord(eventID)
  if id == self~constDir["PROFESSIONS"] then
    -- take some action
  ...
]]>
</programlisting></para></listitem>
</orderedlist>
</para></note>
</section>

<section id="sctConnectingScrollBarEvents"><title>Connecting ScrollBar Events</title>
<para>
  For scroll bars, in addition to the typical connect scroll bar event method, the ooDialog framework provides a couple
  of convenience methods for connecting more than one scroll bar event in one step. In most cases, the programmer needs
  to be notified of all scroll bar events, not just one event.
</para>
<section id="mthConnectScrollBarEvent"><title>connectScrollBarEvent</title>
<indexterm><primary>connectScrollBarEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectScrollBarEvent(--id--,--event--+---------------+--)-----------------><
                                          +-,--methodName=+

]]>
</programlisting>

<para>
  Connects a method in the Rexx dialog to the Windows <link linkend="ovvEvents">event</link> notification from a <link
  linkend="clsScrollBar">scroll bar</link> control.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
  <varlistentry><term>id [required]</term>
  <listitem>
  <para>
    The resource ID of the scroll bar whose event notification is to be connected. May be numeric or <link
    linkend="defSymbolicId">symbolic</link>.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>event [required]</term>
  <listitem>
  <para>
    A keyword specifying which scroll bar event should be connected. The keyword must be on of the following, case is
    not significant:
  </para>
  <para>
    <simplelist type='vert' columns='3'>
      <member>UP       </member>
      <member>LINEUP   </member>
      <member>LINELEFT </member>
      <member>DOWN     </member>
      <member>LINEDOWN </member>
      <member>LINERIGHT</member>
      <member>PAGEUP   </member>
      <member>PAGELEFT </member>
      <member>PAGEDOWN </member>
      <member>PAGERIGHT</member>
      <member>POSITION </member>
      <member>DRAG     </member>
      <member>TOP      </member>
      <member>LEFT     </member>
      <member>BOTTOM   </member>
      <member>RIGHT    </member>
      <member>ENDSCROLL</member>
    </simplelist>
    <variablelist>
      <varlistentry><term>T1</term>
      <listitem>
      <para>
        text
      </para>
      </listitem></varlistentry>
      <varlistentry><term>T2</term>
      <listitem>
      <para>
        text
      </para>
      </listitem></varlistentry>
      <varlistentry><term>T3</term>
      <listitem>
      <para>
        text
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term>event</term>
  <listitem><para>The event to be connected with a method:
  <variablelist>
  <varlistentry><term>UP</term>
  <listitem><para>The scroll bar was scrolled to the left or up by one unit.
  </para></listitem></varlistentry>
  <varlistentry><term>DOWN</term>
  <listitem><para>The scroll bar was scrolled to the right or down by one unit.
  </para></listitem></varlistentry>
  <varlistentry><term>TOP</term>
  <listitem><para>The scroll bar was scrolled to the upper left.
  </para></listitem></varlistentry>
  <varlistentry><term>BOTTOM</term>
  <listitem><para>The scroll bar was scrolled to the lower right.
  </para></listitem></varlistentry>
  <varlistentry><term>PAGEUP</term>
  <listitem><para>The scroll bar was scrolled to the left or up by one page size.
  </para></listitem></varlistentry>
  <varlistentry><term>PAGEDOWN</term>
  <listitem><para>The scroll bar was scrolled to the right or down by one page size.
  </para></listitem></varlistentry>
  <varlistentry><term>DRAG</term>
  <listitem><para>The scroll bar has been dragged.
  </para></listitem></varlistentry>
  <varlistentry><term>ENDSCROLL</term>
  <listitem><para>Scrolling has been ended, that is, the appropriate key or mouse button
  has been released.
  </para></listitem></varlistentry>
  <varlistentry><term>POSITION</term>
  <listitem><para>The scroll bar was scrolled to an absolute position (the left mouse
  button has been released).
  </para></listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term>msgToRaise</term>
  <listitem><para>The message that is to be sent whenever the specified notification is
  received from the scroll bar. Provide a method with a matching name. If you
  omit this argument, the event is preceded by <computeroutput>On</computeroutput>.
  </para>
  </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return codes are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        No error detected.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
      <para>
        The resource ID could not be resolved or the event argument is
      incorrect.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
      <para>
        The messages was not connected correctly.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example connects the POSITION event with method onPosition automatically. Since the third argument is
    omitted,t he ooDialog framword automatically connects the event to onPosition. The event handler extracts the new
    position from the notification arguments and sets the postion for the scroll bar. It also displays the new position
    and the event type. The <computeroutput>ScrollBar</computeroutput> class provides the THUMBPOSITION constant, whose
    value is the value of the POSITION event code.

<programlisting>
<![CDATA[
::class 'SimpleDialog subclass UserDialog

::method initDialog

  self~connectScrollBarEvent(IDC_SB_FILE, "POSITION")

::method onPosition
  use arg posData, hwnd
  pos = .DlgUtil~hiWord(posData)

  -- Set the scroll bar to the new position and have it redraw itself.
  self~newScrollBar(IDC_SB_FILE)~setPos(pos, .true)

  say "Pos:" pos
  say "Verify event code:
  say "  THUMBPOSITION:" .ScrollBar~THUMBPOSITION
  say "  This event:   " .DlgUtil~loWord(posData)
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<note><title>Notes</title>
<orderedlist>
<listitem><para>The method can only be called after the scroll bar was created by Windows. A good location for this connection is the initDialog method.</para></listitem>
<listitem><para>The event-handling methods receive two arguments: an event-position pair
and the handle to the scroll bar. You can retrieve the scroll bar position
by extracting the high-order word.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[
::method Handler
  use arg ev_pos, handle
  position = .DlgUtil~hiWord(ev_pos)
]]>
</programlisting>
<para>
  If the user changed the
scroll bar position, you must set the scroll bar position with <link linkend="mthSetPos">setPos</link> to keep the
selected position.
</para>
</listitem>
</orderedlist>
</note>
</section>

<section id="mthConnectEachSBEvent"><title>connectEachSBEvent</title>
<indexterm><primary>connectEachSBEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectEachSBEvent(-id-,-mthWhenUp-,-mthWhenDown-+---------------+-+-------+-+-------+-+-------+-->
                                                     +-,-mthWhenDrag-+ +-,-min-+ +-,-max-+ +-,-pos-+

>--+-----------+-+-----------+-+----------+-+--------------+-+-------------+-+-------------+-)--------><
   +-,-mthPgUp-+ +-,-mthPgDn-+ +-,-mthTop-+ +-,-progbuttom-+ +-,-progtrack-+ +-,-progendsc-+



]]>
</programlisting>

<para>The connectEachSBEvent method initializes and connects
a scroll bar to an Object Rexx object. Use this method in the <link linkend="mthInitDialog">initDialog</link> method. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>msgWhenUp</term>
<listitem><para>The method that is called each time the scroll bar is incremented.
</para></listitem></varlistentry>
<varlistentry><term>msgWhenDown</term>
<listitem><para>The method that is called each time the scroll bar is decremented.
</para></listitem></varlistentry>
<varlistentry><term>msgWhenDrag</term>
<listitem><para> The method that is called each time the scroll bar is dragged with
the mouse.
</para></listitem></varlistentry>
<varlistentry><term>min, max</term>
<listitem><para> The minimum and maximum values for the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>pos</term>
<listitem><para>The current or preselected value.
</para></listitem></varlistentry>
<varlistentry><term>progpgup</term>
<listitem><para>The method that is called each time the scroll bar is focused and the
PgUp key is pressed.
</para></listitem></varlistentry>
<varlistentry><term>progpgdn</term>
<listitem><para>The method that is called each time the scroll bar is focused and the
PgDn key is pressed.
</para></listitem></varlistentry>
<varlistentry><term>progtop</term>
<listitem><para>The method that is called each time the scroll bar is focused and the
Home key is pressed.
</para></listitem></varlistentry>
<varlistentry><term>progbottom</term>
<listitem><para>The method that is called each time the scroll bar is focused and the
End key is pressed.
</para></listitem></varlistentry>
<varlistentry><term>progtrack</term>
<listitem><para>The method that is called each time the scroll box is dragged.
</para></listitem></varlistentry>
<varlistentry><term>progendsc</term>
<listitem><para>The method that is called each time the scroll box is released after
the dragging.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>In the following example, scroll bar 255 is connected to three methods
and initialized with 1 as the minimum, 20 as the maximum, and 6 as the current
value:

<programlisting>
<![CDATA[
::class MyDialog subclass UserDialog
     .
     .
     .
::method defineDialog
self~connectEachSBEvent(255,"Increase","Decrease","Drag",1,20,6)
     .
     .
     .
::method Increase
     .
     .
     .
::method Decrease
     .
     .
     .
::method Drag
     .
     .
     .
/* see CombineElWithSB below for continuation */
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectAllSBEvents"><title>connectAllSBEvents</title>
<indexterm><primary>connectAllSBEvents</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectAllSBEvents(--id--,--methodName--+-------+-+-------+-+-------+--)---><
                                            +-,-min-+ +-,-max-+ +-,-pos-+


]]>
</programlisting>

<para>Connects all scroll bar events to one method. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Protected:</emphasis></term>
<listitem><para>This method is protected.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:</para>
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the scroll bar
</para></listitem></varlistentry>
<varlistentry><term>Prog</term>
<listitem><para>The method that is called for all events sent by the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>min, max</term>
<listitem><para> The minimum and maximum values for the scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>pos</term>
<listitem><para>The current or preselected value.
</para></listitem></varlistentry>
</variablelist>
</listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The specified symbolic ID could not be resolved.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>No error.
</para></listitem></varlistentry>
</variablelist>
</listitem></varlistentry>
</variablelist>
</section>


</section>

<section id="mthConnectListViewEvent"><title>connectListViewEvent</title>
<indexterm><primary>connectListViewEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>-connectListViewEvent(--id--,--event--+---------------+--)-------------------><
                                        +-,--methodName-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectListViewEvent</emphasis> method connects a particular <link
  linkend="ovvEvents">event</link> notification from a list-view control with an event handling method in the Rexx
  dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The ID of the list-view control for which a notification is to be connected. This can be symbolic or numeric.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event [required]</term>
    <listitem>
    <para>
      The event keyword. Use exactly one of the following keywords, case is not significant:
    <variablelist>
      <varlistentry><term>ACTIVATE</term>
      <listitem>
      <para>
        An item is activated by double-clicking the left mouse button.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>BEGINDRAG</term>
      <listitem>
      <para>
        A drag-and-drop operaton was initiated. See <link linkend="mthDefListDragHandler">defListDragHandler</link> for
        information on how to implement a drag-and-drop handler.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>BEGINRDRAG</term>
      <listitem>
      <para>
        A drag-and-drop operaton involving the right mouse button was initiated. See <link
        linkend="mthDefListDragHandler">defListDragHandler</link> for information on how to implement a drag-and-drop
        handler.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>BEGINEDIT</term>
      <listitem>
      <para>
        Editing a label has been started. Do not connect this event if you are using the DEFAULTEDIT keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>ENDEDIT</term>
      <listitem>
      <para>
        Label editing has ended. Do not connect this event if you are using the DEFAULTEDIT keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kwListViewDEFAULTEDIT"><term>DEFAULTEDIT</term>
      <listitem>
      <para>
        This keyword connects the event that label editing has been started and the ended event with event handling
        methods supplied by the ooDialog framework. The supplied methods extract the newly entered text from the
        notification and modifies the item label which was edited. If this keyword is not used you must provide your own
        event-handling methods and connect them with the begin edit and end edit events. Otherwise, the edited text is
        lost and the item label remains unchanged.
      </para>
      <para>
        When you specify this event, omit the <emphasis role="italic">methodName</emphasis> argument. This keyword
        tells the ooDialog framework to use its default methods for both the begin and end edit events.
      </para> </listitem></varlistentry>
      <varlistentry><term>CHANGING</term>
      <listitem>
      <para>
        An item is about to change. The notification for this event is sent before the item is changed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>CHANGED</term>
      <listitem>
      <para>
        An item has changed. The notification for this event is sent after the item changed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>CHECKBOXCHANGED</term>
      <listitem>
      <para>
        The check box state of an item changed.  (The check box was checked or unchecked.) This event can only occur if
        the list-view has the check box <link linkend="mthAddExtendedStyle">extended</link> list-view style.  Use this
        keyword instead of the CHANGED keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>CLICK</term>
      <listitem>
      <para>
        This event is generated when the list-view is clicked with the left mouse button. However, in report view only,
        this excludes the column headers. Connecting the CLICK event is a replacement for the <link
        linkend="mthConnectNotifyEvent">connectNotifyEvent</link> method's CLICK event.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>COLUMNCLICK</term>
      <listitem>
      <para>
        In report view only, a column header has been clicked.  Contrast this wiht the CLICK keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>DELETE</term>
      <listitem>
      <para>
        An item has been deleted.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>DELETEALL</term>
      <listitem>
      <para>
        All items have been deleted.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>FOCUSCHANGED</term>
      <listitem>
      <para>
        The focus state of an item changed.  (The item gained or lost the focus.) Use this keyword instead of the
        CHANGED keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>INSERTED</term>
      <listitem>
      <para>
        A new item has been inserted.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>KEYDOWN</term>
      <listitem>
      <para>
        A key was pressed inside the list view. This notification is not sent while a label is being edited.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>SELECTCHANGED</term>
      <listitem>
      <para>
        The selection state of an item changed.  (The item was selected or unselected.)  Use this keyword instead of the
        CHANGED keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>SELECTFOCUSCHANGED</term>
      <listitem>
      <para>
        The selection state or the focus state of an item changed.  This event argument combines the selection changed
        and the focus changed event into one connection.  When this event is connected, separate selection changed and
        focus changed events can not be connected.  This keyword can be abbreviated to SELECTFOCUS. Use this keyword
        instead of the CHANGED keyword.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>methodName</term>
    <listitem>
    <para>
      The name of the event handling method. This method is invoked each time the specified event occurs for the list
      view control. The method name can not be the empty string and must be less than 256 characters in length. If you
      omit this argument, the event handler method name is generated for you. This name will be the event keyword,
      preceded by <computeroutput>On</computeroutput>. For example: <emphasis role="italic">onColumnClick</emphasis>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error detected.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The resource ID could not be resolved or the event argument is incorrect.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The event was not connected correctly. The error is likely caused by the message table being full, but could also
      indicate the interpreter is out of memory.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Microsoft continually enhances the Windows User Interface and therefore the dialog controls evolve over time. The
    <computeroutput>connectListViewEvent</computeroutput> method uses several event keywords that provide more
    information, for the same event, than that provided by the original ooDialog implementation.  For instance, the
    CHECKBOXCHANGED, SELECTIONCHANGED, FOCUSCHANGED, and SELECTFOCUSCHANGED keywords all connect the same event as the
    CHANGED keyword.  Howver, these keyword connections all provide more specific, detailed information in the arguments
    passed to the connected method than that provided by using the CHANGED keyword.
  </para>
  <para>
    Likewise, the <computeroutput>connectListViewEvent</computeroutput> CLICK keyword provides much better information
    than that provided by the <link linkend="mthConnectNotifyEvent">connectNotifyEvent</link>'s CLICK keyword.
  </para>
  <para>
    <emphasis role="bold">Note:</emphasis> If the same event, for the same control, is connected using two different
    connectXXX methods, only one connection will be in effect.  This will be the connection whose connectXXX method is
    invoked first.  For example, take a dialog that has a list-view control with resource ID of 109.  If the mouse click
    event is connected for that control using the <computeroutput>connectNotifyEvent</computeroutput> method and then
    the mouse click event is also connected using the <computeroutput>connectListViewEvent</computeroutput> method, only
    one connection will be active.  Which one is active is dependent on the order of invocation of the connectXXX
    methods.
  </para>
  <para>
    When using <computeroutput>connectListViewEvent</computeroutput> a separate method can be connected to each of the
    CHECKBOXCHANGED, SELECTIONCHANGED, and FOCUSCHANGED events.  These event connectionss are all replacements for the
    CHANGED event.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example connects the column-clicked event for the list-view EMPLOYEES with method ColumnAction and
    changes the style of the list-view from REPORT to SMALLICON:
  </para>
  <programlisting>
  <![CDATA[
  ::class MyDlgClass subclass UserDialog

  ::method init
    self~init:super(...)
    self~connectListViewEvent("EMPLOYEES", "COLUMNCLICK", "ColumnAction")

  ::method ColumnAction
    use arg id, column
    lc = self~newListView("EMPLOYEES")
    lc~replaceStyle("REPORT", "SMALLICON EDIT SINGLESEL ASCENDING")
    if column > 0 then ...
  ]]>
  </programlisting>
  </listitem></varlistentry>
</variablelist>

<section id="evtListViewCLICK"><title>Click Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>CLICK</secondary></indexterm>
<para>
  The event handling method for the CLICK event is invoked when the user clicks on the list-view with the left mouse.
  This excludes the column headers in report view. Note that the user can click on a list-view item, or on the
  background of the list view. When the click is on the background of the list-view then both the <emphasis
  role="italic">itemIndex</emphasis> and <emphasis role="italic">columnInex</emphasis> will be -1. The method will
  receive four arugments:
</para>

<programlisting>
<![CDATA[
  ::method onClick
    use arg id, itemIndex, columnIndex, keyState

]]>
</programlisting>

<variablelist>
  <varlistentry><term>id</term>
  <listitem>
  <para>
    The resource ID of the list-view control whose item was clicked.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>itemIndex</term>
  <listitem>
  <para>
    The zero-based index of the item that was clicked, or -1 if the background of the list-view was clicked. In report
    view this is often thought of as the row index.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>columnIndex</term>
  <listitem>
  <para>
    The zero-based index of the subitem that was clicked, or -1 if the click was on the background of the list view. In
    report view this is often thought of as the column of row. In all views other than report view, this arg will always
    be 0.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>keyState</term>
  <listitem>
  <para>
    This argument reports the state of the shift, control, and alt keys at the time of the mouse click.  The argument is
    a string of keywords separated by blanks.  The keywords consist of: SHIFT, CONTROL, ALT, or NONE. The presence of a
    keyword indicates the key was held down when the user clicked on the list-view control.  NONE of course indicates
    that none of the keys were down.  If the user managed to hold all three of the keys down at the time of the mouse
    click, the argument would be the string: &quot;SHIFT CONTROL ALT&quot;
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="evtListViewCHECKBOXCHANGED"><title>CheckBoxChanged Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>CHECKBOXCHANGED</secondary></indexterm>
<para>
  The event handler for the checkbox changed event is invoked when the user checks or unchecks a checkbox in the
  <computeroutput>ListView</computeroutput> control. The method recieves three arguments:
</para>

<programlisting>
<![CDATA[
::method onCheckboxChanged
  use arg id, itemIndex, state

]]>
</programlisting>
<variablelist>
  <varlistentry><term>id</term>
  <listitem>
  <para>
    The resource ID of the list-view control whose item had the checkbox state changed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>itemIndex</term>
  <listitem>
  <para>
    The index of the item whose checkbox was changed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>state</term>
  <listitem><para>This argument reports whether the check box was checked or
  unchecked.  Its value will be either &quot;CHECKED&quot; or &quot;UNCHECKED&quot;
  </para></listitem></varlistentry>
</variablelist>
<para>
  <emphasis role="bold">Example:</emphasis> The following example is from an address book application. A list-view
  control is filled with the information from the address book, one item for each entry.  The check box changed event is
  connected to the <emphasis role="italic">onCheckboxChanged</emphasis> method. The <emphasis
  role="italic">onCheckboxChanged</emphasis> method will receive 3 arguments: the resource ID of the control, the index
  of the item whose check box changed, and the changed state. If the user checks the check box, that entry is added to a
  mail merge being constructed.  If the user unchecks the box, the entry is removed from the mail merge.
</para>
<programlisting>
<![CDATA[
::class MailingListDlg subclass UserDialog

::method initDialog
  expose mailList

  ...
  mailList = self~newListView(IDC_LV_ADDRESSES)
  ...

  -- Since the methodName argument is omitted, ooDialog will construct a default
  -- name of 'onCheckboxChanged'
  self~connectListViewEvent(IDC_LV_ADDRESSES, "CHECKBOXCHANGED")
  ...

::method onCheckboxChanged
  expose mailList
  use arg id, itemIndex, state

  if state == "CHECKED" then
    self~addToMailMerge(mailList, itemIndex)
  else
    self~removeFromMailMerge(mailList, itemIndex)

]]>
</programlisting>

</section>  <!-- End CheckBoxChanged Event Handler -->

<section id="evtListViewSELECTCHANGE"><title>SelectChange Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>SELECTCHANGE</secondary></indexterm>
<para>
  The event handler for the selection changed event is invoked when the selection state of an item changes. The method
  recieves three arguments:
</para>

<programlisting>
<![CDATA[
::method onSelectChanged
  use arg id, itemIndex, state

]]>
</programlisting>

<variablelist>
  <varlistentry><term>id</term>
  <listitem>
  <para>
    The resource ID of the list-view control whose item had the selection changed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>itemIndex</term>
  <listitem>
  <para>
    The index of the item whose selection was changed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>state</term>
  <listitem>
  <para>
    This argument reports whether the item was selected or unselected.  Its value will be either
    &quot;SELECTED&quot; or &quot;UNSELECTED&quot;
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="evtListViewFOCUSCHANGED"><title>FocusChanged Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>FOCUSCHANGED</secondary></indexterm>
<para>
  The event handler for the focus changed event is invoked when an item gains or loses focus. The method recieves three
  arguments:
</para>

<programlisting>
<![CDATA[
::method onFocusChanged
  use arg id, itemIndex, state

]]>
</programlisting>
<variablelist>
  <varlistentry><term>id</term>
  <listitem>
  <para>
    The resource ID of the list-view control whose item had the focus changed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>itemIndex</term>
  <listitem>
  <para>
    The index of the item which gained or lost the focus.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>state</term>
  <listitem>
  <para>
    This argument reports whether the focus was gained or lost.  Its value will be either &quot;FOCUSED&quot; or
    &quot;UNFOCUSED&quot;
  </para>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="evtListViewSELECTFOCUSCHANGED"><title>SelectFocusChanged Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>SELECTFOCUSCHANGED</secondary></indexterm>
<para>
  The event handle for the selection or focus changed event is invoked when either the selection or the focus of an item
  changes. The method recieves 3 arguments:
</para>

<programlisting>
<![CDATA[
::method onSelectFocusChanged
  use arg id, itemIndex, state

]]>
</programlisting>

<variablelist>
  <varlistentry><term>id</term>
  <listitem>
  <para>
    The resource ID of the list-view control whose item had the either the focus or the selection changed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>itemIndex</term>
  <listitem>
  <para>
    The index of the item where the state was changed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term>state</term>
  <listitem>
  <para>
    This argument reports whether the focus was gained or lost and whether the selection was gained or lost. Its
    value will contain at least one of the keywords: &quot;SELECTED&quot;, &quot;UNSELECTED&quot;,
    &quot;FOCUSED&quot; or &quot;UNFOCUSED&quot;.  It is possible for both the selection and focus changed to be
    reported at once, however sometimes each change is reported separately. (This has nothing to do with ooDialog,
    it is how the operating system sends the messages.)
  </para>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="evtListViewENDEDIT"><title>EndEdit Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>ENDEDIT</secondary></indexterm>
<para>
  The event-handling method connected to ENDEDIT receives two arguments: the item ID of which the label has been edited
  and the newly entered text.
</para>

<programlisting>
<![CDATA[
::method OnEndEdit
  use arg item, newText
]]>
</programlisting>

</section>

<section id="evtListViewCOLUMNCLICK"><title>ColumnClick Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>COLUMNCLICK</secondary></indexterm>
<para>
  The event-handling method connected to COLUMNCLICK receives two arguments: the control ID of the list-view control and
  the zero-based column number of which the header button was pressed.
</para>

<programlisting>
<![CDATA[
::method OnColumnClick
  use arg id, column
]]>
</programlisting>

</section>

<section id="evtListViewKEYDOWN"><title>KeyDown Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>KEYDOWN</secondary></indexterm>
<para>
  The event-handling method connected to KEYDOWN receives two arguments: the control ID of the list-view control and the
  virtual key code pressed. Use the <link linkend="mthKey2Name">key2name</link> method of the <link
  linkend="clsVK">VK</link> class to determine which key was pressed.
</para>

<programlisting>
<![CDATA[
::method OnKeyDown
  use arg id, vkey
  say "Key" .VK~key2name(vkey) "was pressed."
]]>
</programlisting>

</section>

<section id="evtListViewBEGINDRAG"><title>BeginDrag Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>BEGINDRAG</secondary></indexterm>

<para>
  The event-handling method connected to BEGINDRAG receives three arguments: the control ID of the list-view control,
  the index of the list item to be dragged, and the point where the mouse cursor was pressed (x and y positions,
  separated by a blank).
</para>

<programlisting>
<![CDATA[
::method 0nBeginDrag
  use arg id, item, where
]]>
</programlisting>
</section>

<section id="evtListViewBEGINRDRAG"><title>BeginRDrag Event Handler</title>
<indexterm><primary>ListView Event</primary><secondary>BEGINRDRAG</secondary></indexterm>

<para>
  The event-handling method connected to BEGINRDRAG receives three arguments: the control ID of the list-view control,
  the index of the list item to be dragged, and the point where the mouse cursor was pressed (x and y positions,
  separated by a blank).
</para>

<programlisting>
<![CDATA[
::method 0nBeginRightDrag
  use arg id, item, where
]]>
</programlisting>
</section>

</section>

<section id="mthConnectTreeViewEvent"><title>connectTreeViewEvent</title>
<indexterm><primary>connectTreeViewEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>-connectTreeViewEvent(--id--,--event--+----------------+--)------------------><
                                        +-,--methodName--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectTreeViewEvent</emphasis> method connects a method in a Rexx dialog to a particular
  tree view <link linkend="ovvEvents">event</link>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem><para>The arguments are:</para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the tree view control. This can be the numeric or symbolic ID.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event</term>
    <listitem>
    <para>
      A keyword indicating which event is to be connected. The keyword must be one of the following:
      <variablelist>
        <varlistentry><term>BEGINDRAG</term>
        <listitem>
        <para>
          A drag-and-drop operaton using the left mouse button was initiated. The documentation for the <link
          linkend="mthDefTreeDragHandler">defTreeDragHandler</link>() method contains further information on how to
          implement a drag-and-drop handler.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>BEGINRDRAG</term>
        <listitem>
        <para>
          A drag-and-drop operaton involving the right mouse button was initiated. The documentation for the <link
          linkend="mthDefTreeDragHandler">defTreeDragHandler</link>() method contains further information on how to
          implement a drag-and-drop handler.
        handler.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>BEGINEDIT</term>
        <listitem><para>Editing a label has been started.
        </para></listitem></varlistentry>
        <varlistentry id="evtTreeViewENDEDIT"><term>ENDEDIT</term>
        <listitem><para>Label editing has ended.
        </para></listitem></varlistentry>
        <varlistentry id="evtTreeViewDEFAULTEDIT"><term>DEFAULTEDIT</term>
        <listitem><para>This event connects the notification that label editing has been started
        and ended with a predefined event-handling method. This method extracts the
        newly entered text from the notification and modifies the item of which the
        label was edited. If this event is not connected you must provide your own
        event-handling method and connect it with the BEGINEDIT and ENDEDIT events.
        Otherwise, the edited text is lost and the item remains unchanged.</para>
        <para>When
        you specify this event, omit the <emphasis role="italic">msgToRaise</emphasis> argument.</para>
        </listitem></varlistentry>
        <varlistentry><term>EXPANDING</term>
        <listitem><para>An item is about to expand or collapse. This notification is sent before
        the item has expanded or collapsed.
        </para></listitem></varlistentry>
        <varlistentry><term>EXPANDED</term>
        <listitem><para>An item has expanded or collapsed. This notification is sent after the
        item expanded or collapsed.
        </para></listitem></varlistentry>
        <varlistentry><term>DELETE</term>
        <listitem><para>An item has been deleted.
        </para></listitem></varlistentry>
        <varlistentry><term>KEYDOWN</term>
        <listitem><para>A key was pressed inside the tree view. This notification is not sent
        while a label is being edited.
        </para></listitem></varlistentry>
        <varlistentry><term>SELCHANGING</term>
        <listitem><para>Another item is about to be selected. This notification is sent before
        the selection has changed.
        </para></listitem></varlistentry>
        <varlistentry><term>SELCHANGED</term>
        <listitem><para>Another item was selected. This notification is sent after the selection
        was changed.
        </para></listitem></varlistentry>
      </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>methodName</term>
    <listitem>
    <para>
      The name of the event handling method. This method is invoked each time the specified event occurs for the tree
      view control. If you omit this argument, the method name is generated for you. This name will be the event
      keyword, preceded by <computeroutput>on</computeroutput>. For example: <emphasis
      role="italic">onExpanded</emphasis>. The method name can not be the empty string and must be less than 256
      characters in length
    </para>
    </listitem></varlistentry>
  </variablelist> </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        No error detected.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
      <para>
        The resource ID was symbolic and it could not be resolved, or the event keyword is not correct.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
      <para>
        Some other error and the message was not connected correctly. This may indicate the message table is full, or the
        interpreter is out of usable memory.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
    <para>
      The <emphasis role="italic">connectTreeViewEvent</emphasis> method is a member of the <link
      linkend="clsEventNotification">EventNotification</link> mixin class.
    </para>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    command events happen.
  </para>
  <para>
    In Windows itself, tree view event notifications are sent to the parent dialog using the WM_NOTIFY message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example connects the selection-changed event for the tree view FileTree with method NewTreeSelection
    and displays the text of the new selection:
  <programlisting>
  <![CDATA[
  ::class MyDlgClass subclass UserDialog

  ::method init
    self~init:super(...)
    self~connectTreeViewEvent("FileTree", "SELCHANGED", "NewTreeSelection")

  ::method NewTreeSelection
    tc = self~newTreeView("FileTree")
    info. = tc~itemInfo(tc~selected)
    say "New selection is:" info.!text
  ]]>
  </programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<note><title>Note TODO FIX THIS</title><para>
<orderedlist>
<listitem><para>Connections are usually placed in the <link linkend="mthNewDialogObject">init</link> or <link linkend="mthInitDialog">initDialog</link> method. If both methods are defined, use init as the place for this connection - but not
before init:super has been called.</para></listitem>
<listitem><para>The event-handling method connected to ENDEDIT receives two arguments:
the item handle of which the label has been edited and the newly entered text.
Example:
<programlisting>
<![CDATA[
::method OnEndEdit
  use arg item, newText
]]>
</programlisting></para></listitem>
<listitem>
<para>
  The event-handling method connected to KEYDOWN receives two arguments: the control ID of the tree view control and the
  virtual key code pressed. Use the <link linkend="mthKey2Name">key2name</link>method of the <link
  linkend="clsVK">VK</link> class to determine which key was pressed. Example:
<programlisting> <![CDATA[
::method OnKeyDown
  use arg id, vkey
  say "Key" .VK~name2key(vkey) "was pressed."
]]>
</programlisting></para></listitem>
<listitem><para>The event-handling method connected to EXPANDED or EXPANDING receives
three arguments: the control ID of the tree view control, the tree item expanded
or collapsed, and a string that indicates whether the item was expanded or
collapsed. Example:
<programlisting>
<![CDATA[
::method OnExpanding
  use arg id, item, what
  say "Item with handle" item "is going to be" what
]]>
</programlisting></para></listitem>
<listitem><para>The event-handling method connected to BEGINDRAG or BEGINRDRAG receives
three arguments: the control ID of the tree view control, the tree item to
be dragged, and the point where the mouse cursor was pressed (x and y positions,
separated by a blank). Example:
<programlisting>
<![CDATA[
::method OnBeginDrag
  use arg id, item, where
  say "Item with handle" item "is in drag-and-drop mode"
  parse var where x y
  say "The drag operation started at point ("x","y")"
]]>
</programlisting></para></listitem>
</orderedlist>
</para></note>

</section>

<section id="mthConnectTabEvent"><title>connectTabEvent</title>
<indexterm><primary>connectTabEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectTabEvent(--id--,--event--+---------------+--+--------------+--)-----><
                                    +-,--methodName-+  +-,--willReply-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectTabEvent</emphasis> method connects a specific <link
  linkend="ovvEvents">event</link> notification from a tab control with an event handling method in the Rexx
  dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the tab control whose event notification is to be connected to a method in the Rexx dialog.
        May be numeric or <link linkend="defSymbolicId">symbolic</link>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>event [required]</term>
      <listitem>
      <para>
        A single keyword indicating which event is to be connected. The event keywords are:
        <variablelist>
          <varlistentry><term>KEYDOWN</term>
          <listitem>
          <para>
            The notification is sent when a key has been pressed while the tab control has the focus.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>SELCHANGE</term>
          <listitem>
          <para>
            A new tab has been selected in the tab control. This method is called after the selection has changed.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>SELCHANGING</term>
          <listitem>
          <para>
            A new tab has been selected in the tab control. This method is called before the selection is changed.  TODO
            fix this paragraph.  Note that args to event handler are different if willReply is .false than if .true
          </para>
          <para>
            The programmer can prevent the selection from changing by returning <computeroutput>.false</computeroutput>
            from the event handler for this event. Return <computeroutput>.true</computeroutput> to allow the change.
            The event handling method must be marked as a TODO ADD LINK direct reply method by supplying the optional
            <emphasis role="italic">willReply</emphasis> argument.
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      </listitem></varlistentry>
      <varlistentry><term>msgToRaise</term>
      <listitem>
      <para>
        The message that is to be sent whenever the specified notification is received from the tab control. Provide a
        method with a matching name. If you omit this argument, the event is preceded by
        <computeroutput>On</computeroutput>.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return codes are:
    <variablelist>
    <varlistentry><term>0</term>
    <listitem><para>No error detected.
    </para></listitem></varlistentry>
    <varlistentry><term>-1</term>
    <listitem><para>The resource ID could not be resolved or the event argument is
    incorrect.
    </para></listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem><para>The messages was not connected correctly.
    </para></listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem><para>The following example invokes method OnSelChange whenever another tab
  is selected in the tab control PAGE:

<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  self~init:super(...)
  self~connectTabEvent("PAGE", "SELCHANGE")
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<note><title>Notes TODO FIX THIS</title><para>
<orderedlist>
<listitem><para>Connections are usually placed in the <link linkend="mthNewDialogObject">init</link> or <link linkend="mthInitDialog">initDialog</link> method. If both methods are defined, use init as the place for this connection - but not
before init:super has been called.</para></listitem>
<listitem>
<para>
  The event-handling method that is connected to KEYDOWN receives two arguments: the control ID of the tab control and
  the virtual key code that has been pressed. Use the <link linkend="mthKey2Name">key2name</link> method of the <link
  linkend="clsVK">VK</link> class to determine which key was pressed. Example:

<programlisting>
<![CDATA[
::method OnKeyDown
  use arg id, vkey
  say "Key" .VK~name2key(vkey) "was pressed."
]]>
</programlisting>
  </para>
</listitem>
<listitem><para>All other event-handling methods receive two arguments: the ID of the
tab control (extract the low-order word) and the handle to the tab control.
Example:
<programlisting>
<![CDATA[
::method Handler
  use arg ev_id, handle
  id = .DlgUtil~loWord(ev_id)
]]>
</programlisting></para></listitem>
</orderedlist>
</para></note>
</section>

<section id="mthConnectTrackBarEvent"><title>connectTrackBarEvent</title>
<indexterm><primary>connectTrackBarEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectTrackBarEvent(--id--,--event--+---------------+--)------------------><
                                         +-,--methodName-+

]]>
</programlisting>

<para>The connectTrackBarEvent method connects a particular
WM_NOTIFY message for a trackbar control, which is also called a track bar,
with a method. The WM_NOTIFY message informs the dialog that an event has
occurred with regard to the trackbar control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of the trackbar control of which a notification is to be connected
to a method.
</para></listitem></varlistentry>
<varlistentry><term>event</term>
<listitem><para>The event to be connected with a method:
<variablelist>
<varlistentry><term>UP</term>
<listitem><para>The Up or right key has been pressed.
</para></listitem></varlistentry>
<varlistentry><term>DOWN</term>
<listitem><para>The Down or left key has been pressed.
</para></listitem></varlistentry>
<varlistentry><term>TOP</term>
<listitem><para>The Home key has been pressed.
</para></listitem></varlistentry>
<varlistentry><term>BOTTOM</term>
<listitem><para>The End key has been pressed.
</para></listitem></varlistentry>
<varlistentry><term>PAGEUP</term>
<listitem><para>The PgUp key has been pressed.
</para></listitem></varlistentry>
<varlistentry><term>PAGEDOWN</term>
<listitem><para>The PgDn key has been pressed.
</para></listitem></varlistentry>
<varlistentry><term>DRAG</term>
<listitem><para>The trackbar has been moved.
</para></listitem></varlistentry>
<varlistentry><term>POSITION</term>
<listitem><para>The left mouse button has been released, following a DRAG notification.
</para></listitem></varlistentry>
<varlistentry><term>ENDTRACK</term>
<listitem><para>The trackbar movement is completed, that is, the appropriate key or mouse
button has been released.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>msgToRaise</term>
<listitem><para>The message that is to be sent whenever the specified notification is
received from the trackbar control. Provide a method with a matching name. If
you omit this argument, the event is preceded by <computeroutput>On</computeroutput>.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The return codes are:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>No error detected.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>The resource ID could not be resolved or the event argument is
incorrect.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The messages was not connected correctly.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example connects the POSITION event (release mouse button
after dragging) with method PosSet, which extracts the new trackbar position
from the notification arguments and displays it together with the event type
for POSITION, which should be 4:
<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method initDialog
  self~InitDialog:super(...)
  self~connectTrackBarEvent("MYSLIDER", "POSITION", PosSet)

::method PosSet
  use arg ev_pos, hnd
  pos = .DlgUtil~hiWord(ev_pos)

  say "Verify event code (should be 4):" .DlgUtil~loWord(ev_pos)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

<note><title>Notes</title><para>
<orderedlist>
<listitem><para>The method can only be called after the trackbar was created by Windows.
A good location for this connection is the initDialog method.</para></listitem>
<listitem><para>The event-handling methods receive two arguments: an event-position pair
and the handle to the trackbar control. For some events, you can retrieve the
trackbar position by extracting the high-oder word. Example:
<programlisting>
<![CDATA[
::method Handler
  use arg ev_pos, handle
  position = .DlgUtil~hiWord(ev_pos)
]]>
</programlisting></para></listitem>
</orderedlist>
</para></note>
</section>

<section id="mthConnectDateTimePickerEvent"><title>connectDateTimePickerEvent</title>
<indexterm><primary>connectDateTimePickerEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectDateTimePickerEvent(--id--,--event--+---------------+--)------------><
                                               +-,--methodName-+

]]>
</programlisting>

<para>
  PLEASE FIXE ME TODO
</para>
<para>
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
    <varlistentry><term>id</term>
    <listitem>
      <para>
        The resource ID of the static control.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event</term>
    <listitem>
      <para>
        A keyword specifying the event to be connected with a method:
        <variablelist>
          <varlistentry><term>CLICK</term>
          <listitem>
            <para>
              The static control has been clicked with the mouse.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>DBLCLK</term>
          <listitem>
            <para>
              The static control has been double-clicked with the mouse.
            </para>
          </listitem></varlistentry>
          <varlistentry><term>DISABLE</term>
          <listitem>
            <para>
              The static control has been disabled.
            </para>
          </listitem></varlistentry>
          <varlistentry><term>ENABLE</term>
          <listitem>
            <para>
              The static control has been enabled.
            </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
    </listitem></varlistentry>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
      <para>
        The method that is to be invoked whenever the specified notification is received from the static control. The
        programmer defines this method. The method name can not be the empty string and must be less than 256 characters
        in length. If this argument is omitted, a method name is automatically generated that consists of the event
        keyword preceded by <computeroutput>on</computeroutput>. For instance, <computeroutput>onClick</computeroutput>.
      </para>
    </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
    <para>
      The return codes are:
      <variablelist>
      <varlistentry><term>0</term>
      <listitem>
        <para>
          No error detected.
        </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
        <para>
          The resource ID could not be resolved or the event argument is incorrect.
        </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
        <para>
          The message was not connected correctly. The message was not connected
        </para>
      </listitem></varlistentry>
      </variablelist>
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <orderedlist>
  <listitem>
  <para>
    There are some <link linkend="paraWhereToConnectEvents">common</link> guidelines for the invocation of the event
    connection methods.
  </para>
  </listitem>
  <listitem>
  <para>
    The defined event-handling method will receive two arguments. The first arg contains information about the
    specific control and its event. The second arg is the window handle of the static control.
  </para>
  <para>
    The low word of the first arg is the control ID and the high word is the event ID.
  </para>
  </listitem>
  </orderedlist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
    <para>
      The following example comes from an application that displays employee statistics.  A single click
      on the employee number field advances the display to the next employee.  A double click on either
      the employee name or employee job duties alllows those fields to be edited.
    </para>
<programlisting>
<![CDATA[
::method initDialog

  self~connectStaticEvent(IDC_ST_EMPNO, "CLICK", empLookup)

  self~connectStaticEvent(IDC_ST_EMPJOB, "DBLCLK", editStats)
  self~connectStaticEvent(IDC_ST_EMPNAME, "DBLCLK", editStats)

  first = self~initDatabase
  self~setStats(first)
]]>
</programlisting>
      <para>
        In this example, (a continuation of the above example,) the control ID determines if the user has
        double clicked on the employee job duties field, or the employee name field.  The event ID is not
        used, or needed. Its purpose in the code snippet is simply an example. The same thing applies to
        the window handle.
      </para>
<programlisting>
<![CDATA[
::method editStats
  use arg ctrlInfo, ctrlHwnd

  ctrlID = .DlgUtil~loWord(ctrlInfo)
  eventID = .DlgUtil~hiWord(ctrlInfo)

  rec = self~getCurrentRecord

  if self~userUpdate(ctrlID, rec) then self~setStats(rec)
]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>
</section>

<section id="mthConnectMonthCalendarEvent"><title>connectMonthCalendarEvent</title>
<indexterm><primary>connectMonthCalendarEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectMonthCalendarEvent</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectMonthCalendarEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectMonthCalendarEvent(--id-,-event-+-----------+-+---------------+-)---><
                                           +-,-methodName-+ +-,-wilReply-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectMonthCalendarEvent</emphasis> method connects an <link
  linkend="ovvEvents">event</link> notification message from a <link linkend="clsMonthCalendar">month calendar</link>
  control to a method in the Rexx dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [reguired]</term>
      <listitem>
      <para>
        The resource ID of the month calendar control. May be numeric or <link linkend="defSymbolicId">symbolic</link>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>event [required]</term>
      <listitem>
      <para>
        Exactly one of the following keywords. The keyword specifies the event to be connected. Case is not significant:
      </para>
      <para>
        <simplelist type='vert' columns='3'>
          <member>GETDAYSTATE</member>  <member>SELECT</member>          <member>VIEWCHANGE</member>
          <member>RELEASED</member>     <member>SELCHANGE</member>
        </simplelist>
      </para>
      <variablelist>
        <varlistentry><term>GETDAYSTATE</term>
        <listitem>
        <para>
           Sent by a month calendar control to request information about how individual days should be displayed. This
           notification message is only sent if the month calendar control has the DAYSTATE style. The <emphasis
           role="italic">willReply</emphasis> argument is ignored for this event, the event handler must
           <link linkend="sctCodingEventHandlers">return</link> a reply.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>RELEASED</term>
        <listitem>
        <para>
          Sent by the month calendar when the control is releasing the mouse capture. The return value from the event
          handler is ignored for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>SELECT</term>
        <listitem>
        <para>
          Sent by a month calendar control when the user makes an explicit date selection within the control. The return
          value from the event handler is ignored for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>SELCHANGE</term>
        <listitem>
        <para>
          Sent by a month calendar control when the currently selected date or range of dates changes. The return value
          from the event handler is ignored for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>VIEWCHANGE</term>
        <listitem>
        <para>
          <emphasis role="bold">Requires Windows Vista or later</emphasis>. Sent by a month calendar control when the
          current view changes. The return value from the event handler is ignored for this event.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
      <varlistentry><term>methodName [optional]</term>
      <listitem>
      <para>
        The name of the method that is to be invoked whenever the specified notification is received from the month
        calendar control. The programmer defines this method. If this argument is omitted, a method name is
        automatically generated that consists of the event keyword preceded by <computeroutput>on</computeroutput>. For
        instance, <computeroutput>onGetDayState</computeroutput>. The method name can not be the empty string and must
        be less than 256 characters in length.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>willReply [optional]</term>
      <listitem>
      <para>
        The <emphasis role="italic">willReply</emphasis> argument controls whether the interpreters waits for the reply
        from the event handler. The default is <computeroutput>.true</computeroutput>. If <emphasis
        role="italic">willReply</emphasis> is <computeroutput>.false</computeroutput>, the interpreter will not wait
        for the reply. However, this argument is ignored for the GETDAYSTATE event.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    This method returns <computeroutput>.true</computeroutput> if the event notifications was connected correctly,
    otherwise <computeroutput>.false</computeroutput> .
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Common guidelines on <link linkend="paraWhereToConnectEvents">where</link> to invoke the <emphasis
    role="italic">connectMonthCalendarEvent</emphasis> method and on <link linkend="sctCodingEventHandlers">how</link>
    to code event handlers are included in the documentation for the <link
    linkend="clsEventNotification">EventNotification</link> class.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    This method is a member of the <link linkend="clsEventNotification">EventNotification</link> mixin class.
  </para>
  <para>
    Syntax errors are raised when incorrect usage is detected, including the use of an invalid symbolic ID or an
    unrecognized event keyword. A syntax error is raised if the programmer tries to connect the VIEWCHANGED event when
    the operating system is not Windows Vista or later.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if the
    connected event happens.
  </para>
  <para>
    The underlying dialog recieves the MCN_* messages as the notifications for the month calendar events.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example updates the text of a static control whenever the user selects a new date in the calendar.
  </para>
<programlisting>
<![CDATA[

::method initDialog

  self~connectMonthCalendarEvent(IDC_MC, "SELECT", onSelect)

::method onSelect unguarded
  expose dateText
  use arg startDate, endDate

  dateText~setText(self~formatDate(startDate))
  return 0

]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>


<section id="evtMonthCalendarGETDAYSTATE"><title>GetDayState Event Handler</title>
<indexterm><primary>MonthCalendar class</primary><secondary>events</secondary><tertiary>GETDAYSTATE</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onGetDayState unguarded
  use arg startDate, count, id, hwnd

  return dayStateBuffer
]]>
</programlisting>

<para>
  The event handler for the get day state event is invoked when the month calendar control requests information on how
  to dispaly days in the calendar. The notification is only sent when the month calendar has the DAYSTATE style. The
  programmer must reply to this notification and <emphasis role="bold">must</emphasis> use the <link
  linkend="clsDayStates">DayStates</link> class to properly construct the reply. The interpreter waits for the reply.
</para>
<para>
  The reply is a buffer containing a sequential collection of <link linkend="clsDayState">DayState</link> values. Each
  individual day state value specifies how each day in a single month should be displayed. If a day in the day state
  value is turned on, the day is displayed in bold. If a day is not turned on, it is displayed with no emphasis. The
  <computeroutput>DayStates</computeroutput> and <computeroutput>DayState</computeroutput> classes provide methods to
  properly construct the day state values and the buffer containing the values.
</para>
<para>
  Essentially, the programmer constructs a number of day state values and then returns a buffer containing those values.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method recieves three arguments:
  </para>
  <variablelist>
    <varlistentry><term>startDate</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that specifies the start date the month calendar control needs
      day state values for. Each day state value specifies the state for every day in a month, even if the <emphasis
      role="italic">dayState</emphasis> arg is a date in the middle of a month. I.e., if the start date is January 11,
      2011, the first day state value should be for the month of January.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>count</term>
    <listitem>
    <para>
      The number of day state values required.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID for the month calendar control requesting the information.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window <link linkend="defHandle">handle</link> for the month calendar control requesting the information.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The reply is a buffer containing a sequential collection of <link linkend="clsDayState">DayState</link> values. Each
    individual day state value specifies how each day in a single month should be displayed. If a day in the day state
    value is turned on, the day is displayed in bold. If a day is not turned on, it is displayed with no emphasis. The
    returned buffer must be constructed by using the <link linkend="clsDayStates">DayStates</link> class.
  </para>
  <para>
    The <computeroutput>DayStates</computeroutput> and <computeroutput>DayState</computeroutput> classes provide methods
    to properly construct the day state values and the buffer containing the values. Essentially, the programmer
    constructs a number of day state values and then returns a buffer containing those values.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example is used in a application that displays the 1st and the 15th of each month in bold. The start
    date can be ignored in this case because the day state value is the same for any month.

<programlisting>
<![CDATA[

::method initDialog

  -- Connect the GETDAYSTATE event.
  self~connectMonthCalendarEvent(IDC_MC_PAYDAYS, "GETDAYSTATE", onGetDayState)

::method onGetDayState unguarded
  use arg startDate, count, id, hwnd

  dayStates = .array~new(count)
  do i = 1 to count
    dayStates[i] = .DayState~new(1, 15)
  end

  buffer = .DayStates~makeDayStateBuffer(dayStates)
  return buffer

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End GetDayState Event Handler -->


<section id="evtMonthCalendarRELEASED"><title>Released Event Handler</title>
<indexterm><primary>MonthCalendar class</primary><secondary>events</secondary><tertiary>RELEASED</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onReleased unguarded
  use arg id, hwnd

  return 0
]]>
</programlisting>

<para>
  The event handler for the released event is invoked when the month calendar releases the mouse capture. The
  interpreter waits, or does not wait, for the reply as specified by the programmer in the <link
  linkend="mthConnectMonthCalendarEvent">connectMonthCalendarEvent</link> method. The operating system ignores the value
  of the reply.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method recieves two arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the month calendar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window <link linkend="defHandle">handle</link> for the month calendar control sending the notification
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    Since the return value is ignored by the operating system, any value can be used. Typically, 0 is returned.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Released Event Handler -->


<section id="evtMonthCalendarSELCHANGED"><title>SelChanged Event Handler</title>
<indexterm><primary>MonthCalendar class</primary><secondary>events</secondary><tertiary>SELCHANGED</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onSelChanged unguarded
  use arg selStart, selEnd, id, hwnd

  return 0
]]>
</programlisting>

<para>
  The event handler for the selection changed event is invoked when the currently selected date or range of dates
  changes. This notification is sent when the user explicitly changes the selection within the current month or when the
  selection is implicitly changed by the user navigating to another month. The operating system also sends this
  notification at regular intervals so that the month calendar control can respond to date changes.
</para>
<para>
  The notification is similar to the <link linkend="evtMonthCalendarSELECT">SELECT</link> notification, except that the SELECT
  notification is only sent when the user explicitly changes the date. This notification is sent when the selected date
  is changed for any reason.
</para>
<para>
  The interpreter waits, or does not wait, for the reply as specified by the programmer in the <link
  linkend="mthConnectMonthCalendarEvent">connectMonthCalendarEvent</link> method. The operating system ignores the value
  of the reply.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method recieves three arguments:
  </para>
  <variablelist>
    <varlistentry><term>selStart</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the new selected date, or the first selected date in a
      range of selected dates.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>selEnd</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the last selected date in a range of selected dates. If
      only a single date is selected, then <emphasis role="italic">selEnd</emphasis> will be the same date as <emphasis
      role="italic">selStart</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the month calendar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window <link linkend="defHandle">handle</link> for the month calendar control sending the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The return value is ignored by the operating system and the programmer can return any value. Typically 0 is
    returned.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End SelChanged Event Handler -->

<section id="evtMonthCalendarSELECT"><title>Select Event Handler</title>
<indexterm><primary>MonthCalendar class</primary><secondary>events</secondary><tertiary>SELECT</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onSelect unguarded
  use arg selStart, selEnd, id, hwnd

  return 0
]]>
</programlisting>

<para>
  The SELECT event handler is invoked when the user explicity selects a new date. Contrast this with the <link
  linkend="evtMonthCalendarSELCHANGED">SELCHANGE</link> event handler which is invoked when the selected date is changed for any
  reason.
</para>
<para>
  The interpreter waits, or does not wait, for the reply as specified by the programmer in the <link
  linkend="mthConnectMonthCalendarEvent">connectMonthCalendarEvent</link> method. The operating system ignores the value
  of the reply.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method recieves four arguments:
  </para>
  <variablelist>
    <varlistentry><term>selStart</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the new selected date, or the first selected date in a
      range of selected dates.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>selEnd</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the last selected date in a range of selected dates. If
      only a single date is selected, then <emphasis role="italic">selEnd</emphasis> will be the same date as <emphasis
      role="italic">selStart</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the month calendar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window <link linkend="defHandle">handle</link> for the month calendar control sending the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The programmer can return any value because the operating system ingores the returned value. Typically 0 is
    returned.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Select Event Handler -->

<section id="evtMonthCalendarVIEWCHANGE"><title>ViewChange Event Handler</title>
<indexterm><primary>MonthCalendar class</primary><secondary>events</secondary><tertiary>VIEWCHANGE</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onViewChange unguarded
  use arg oldView, newView, id, hwnd

  return 0
]]>
</programlisting>

<para>
  The view change notification is sent when the current view changes. The notification is only sent on Windows Vista or
  later. A syntax exception is raised if the VIEWCHANGE event is connected when the program is not running on Vista or
  later.
</para>
<para>
  The interpreter waits, or does not wait, for the reply as specified by the programmer in the <link
  linkend="mthConnectMonthCalendarEvent">connectMonthCalendarEvent</link> method. The operating system ignores the value
  of the reply.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method recieves four arguments:
  </para>
  <variablelist>
    <varlistentry><term>oldView</term>
    <listitem>
    <para>
      The <emphasis role="italic">oldView</emphasis> argument is a keyword denoting what the previous view was. It will be
      one of: month, year, decade, or centuary.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>newView</term>
    <listitem>
    <para>
      The <emphasis role="italic">newView</emphasis> argument is a keyword denoting what the view was changed to. It also
      will be one of: month, year, decade, or centuary.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the month calendar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window <link linkend="defHandle">handle</link> for the month calendar control sending the notification
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End ViewChange Event Handler -->

</section>  <!-- End EventNotification::connectionMonthCalendarEvent() -->

<section id="mthConnectUpDownEvent"><title>connectUpDownEvent</title>
<indexterm><primary>connectUpDownEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectUpDownEvent</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectUpDownEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectUpDownEvent(--id--,--event--+----------------+--)-------------------><
                                       +--,-methodName--+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectUpDownEvent</emphasis> method connects an <link linkend="ovvEvents">event</link>
  notification message from a <link linkend="clsUpDown">up-down</link> control to a method in the Rexx dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the up-down control whose notification message is to be connected to a Rexx dialog's method.
        May be numeric or <link linkend="defSymbolicId">symbolic</link>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>event [required]</term>
      <listitem>
      <para>
        Exactly one of the following keywords. The keyword specifies the event to be connected and case is not
        significant. Unlike most controls, the up-down control only has one event notification.
      </para>
      <variablelist>
        <varlistentry><term>DELTAPOS</term>
        <listitem>
        <para>
           Sent when the position of the control is about to change. This happens when the user requests a change in the
           value by pressing the control's up or down arrow. The event handler must <link
           linkend="sctCodingEventHandlers">return</link> a reply for this event. The intrepreter waits for that reply.
        </para>
        <para>
          The DELTAPOS notification is sent before the scroll message which actually changes the control's position.
          This allows the programmer to examine, allow, modify, or disallow the change in position.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
      <varlistentry><term>methodName [optional]</term>
      <listitem>
      <para>
        The name of the method that is to be invoked whenever the specified notification is received from the up-down
        control. The programmer defines this method. If this argument is omitted, a method name is automatically
        generated that consists of the event keyword preceded by <computeroutput>on</computeroutput>. For instance,
        <computeroutput>onDeltaPos</computeroutput>. The method name can not be the empty string and must be less
        than 256 characters in length.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns <computeroutput>.true</computeroutput> if the event was connected corrrectly, otherwise
   <computeroutput>.false</computeroutput>.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Common guidelines on <link linkend="paraWhereToConnectEvents">where</link> to invoke the <emphasis
    role="italic">connectUpDownEvent</emphasis> method and on <link linkend="sctCodingEventHandlers">how</link> to
    code event handlers are included in the documentation for the <link
    linkend="clsEventNotification">EventNotification</link> class.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    This method is a member of the <link linkend="clsEventNotification">EventNotification</link> mixin class.
  </para>
  <para>
    Syntax errors are raised when incorrect usage is detected, including the use of an invalid symbolic ID or an
    unrecognized event keyword.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if the
    connected event happens.
  </para>
  <para>
    The underlying dialog recieves the UDN_* messages as the notifications for the up-down events.
  </para>
  </listitem></varlistentry>
</variablelist>


<section id="evtUpDownDELTAPOS"><title>DeltaPos Event Handler</title>
<indexterm><primary>UpDown class</primary><secondary>events</secondary><tertiary>DELTAPOS</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onDeltaPos unguarded
  use arg pos, delta, id, hwnd

  return buffer
]]>
</programlisting>

<para>
  The event handler for the up-down DELTAPOS event is invoked when when the position of the control is about to change.
  The arguments the event handler recieves allow the programmer to examine the proposed change in position, to modify
  the change, or to cancel the change all together.
</para>
<para>
  The programmer must return a value from the event handler and the interpreter waits for this return. The <link
  linkend="mthDeltaPosReply">deltaPosReply</link> class method of the <link linkend="clsUpDown">UpDown</link> class is
  used to properly construct the return value from the event handler.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method recieves four arguments:
  </para>
  <variablelist>
    <varlistentry><term>pos</term>
    <listitem>
    <para>
      A signed whole number that contains the up-down control's current position.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>delta</term>
    <listitem>
    <para>
      A signed whole number that contains the proposed change in the up-down control's position. This is positive if the
      user has clicked the up button or used the up arrow key. If the user has clicked the down button or used the down
      arrow key, this number will be negative.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the up-down control whose position is about to change.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window <link linkend="defHandle">handle</link> of the up-down control whose position is about to change.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    A delta position buffer must be returned by the event handler.  This buffer can only be constructed properly by
    using the <link linkend="clsUpDown">UpDown</link> class's <link linkend="mthDeltaPosReply">deltaPosReply</link>
    method. The arguments to <emphasis role="italic">deltaPosReply</emphasis> allow the programmer to return a value
    that makes no change to the new position, cancels altogether the change in position, or modifies the resulting new
    position.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example examines the change in position in the up-down control and modifies it so that the position in
    the up-down control is always an even number. Note that the <emphasis role="italic">deltaPosReply</emphasis> method
    ignores the second and third arguments when the first arguement is <computeroutput>.false</computeroutput>. So, in
    the code below, if <emphasis role="italic">change</emphasis> remains <computeroutput>.false</computeroutput>, then
    the values of <emphasis role="italic">cancel</emphasis> and <emphasis role="italic">delta</emphasis> do not matter.

<programlisting>
<![CDATA[

::method initDialog
...
  self~connectUpDownEvent(IDC_UPD, "DELTAPOS", onPosChange)
...

::method onPosChange unguarded
  use arg pos, delta, id, hwnd

  change = .false
  cancel = .false

  if ((pos + delta) // 2) <> 0 then do
    change = .true
    if delta > 0 then delta += 1
    else delta -= 1
  end

  return .UpDown~deltaPosReply(change, cancel, delta)

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End DeltaPos Event Handler -->

</section>  <!-- End EventNotification::connectUpDownEvent() -->

<section id="mthAddUserMsg"><title>addUserMsg</title>
<indexterm><primary>addUserMsg</primary></indexterm>
<programlisting>
<![CDATA[
>>--addUserMsg(-msg-,-winMsg-+------+-+----------+-+------+-+----------+-+------+-)-><
                             +-,-f1-+ +-,-wParam-+ +-,-f2-+ +-,-lParam-+ +-,-f3-+

]]>
</programlisting>

<para>The addUserMsg method connects a Windows message with an Object Rexx
method. This method is designed to be used by ooDialog programmers who are
familiar with the Windows API.
</para>
<para>You have to pass the Windows message ID and the two message parameters
(wParam and lParam) to specify the exact event you want to catch. In addition,
you can specify filters for each parameter. Filters are useful for catching more
than one message or one parameter with one method.
</para>
<para>Details for all Windows messages and their parameters are available in the
<link linkend="defWindowsDoc">Windows documentation</link>.  The numeric value of
the message IDs (and possibly the message parameters) can be looked up in the
<link linkend="defPlatformSDK">Windows platform SDK</link>.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>msg</term>
<listitem>
<para>
  The message that is to be sent to the Object Rexx dialog object each time
the specified Windows message is caught. Provide a method with the
same name. The maximum size for a message is limited to 256 characters.
</para></listitem></varlistentry>
<varlistentry><term>winMsg</term>
<listitem><para>The message in the Windows environment that is to be caught.
</para></listitem></varlistentry>
<varlistentry><term>f1</term>
<listitem><para>This filter is used to binary AND the incoming Windows message.
</para></listitem></varlistentry>
<varlistentry><term>wParam</term>
<listitem><para>This is the first parameter that must be passed with the Windows message.
</para></listitem></varlistentry>
<varlistentry><term>filt2</term>
<listitem><para>This filter is used to binary AND the <emphasis role="italic">wParam</emphasis> argument.
</para></listitem></varlistentry>
<varlistentry><term>lParam</term>
<listitem><para>This is the second message parameter.
</para></listitem></varlistentry>
<varlistentry><term>filt3</term>
<listitem><para>This is the filter for <emphasis role="italic">lParam</emphasis>.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem>
<para>
  TODO REWRITE THIS EXAMPLE TO CREATE A NEW METHOD, connectButtonClick. The following example shows an implementation of
  the ConnectList method:
</para>

<programlisting>
<![CDATA[
::class BaseDialog
      .
      .
      .
::method ConnectList
  use arg msgToRaise, id
  self~addUserMsg(msgToRaise, "0x00000111", "0xFFFFFFFF", ,
                 "0x0001"||id~d2x(4), "0xFFFFFFFF", 0, 0)
]]>
</programlisting>
<para>Assume that this method is called with ID=254 and msgToRaise=&quot;ListChanged&quot;.
After the ConnectList is executed, the ListChanged message is sent to the Object Rexx dialog object if the following
conditions are true: </para>
<itemizedlist>
<listitem><para>Message &quot;0x00000111&quot; (WM_COMMAND) is generated by Windows in
answer to an event (for example, a button is clicked or a list has changed).
The filter &quot;0xFFFFFFFF&quot; ensures that only that message is caught;
if the filter were &quot;0xFFFFEFFF&quot;, the message &quot;0x00001111&quot;
would be caught as well.</para></listitem>
<listitem><para>The first message parameter is &quot;0x000100FF&quot;. The first part, &quot;0x0001&quot;,
specifies the event, and the second part, &quot;0x00FE&quot; (equals decimal
254), specifies the dialog control where the event occurred. By using another
filter it is possible to make more than one event a trigger for the ListChanged method; for example, filter &quot;0xFFFFFFFE&quot; would ignore
the last bit of the ID, and this the same event for dialog item 255 would
call ListChanged as well.</para></listitem>
<listitem><para>The second message parameter and its filter are ignored.</para></listitem></itemizedlist>
<para>The following example invokes a user-defined method <computeroutput>DoubleClick</computeroutput> each time the left mouse button is double-clicked: </para>
<programlisting>
<![CDATA[
self~addUserMsg("DoubleCick","0x00000203","0xFFFFFFFF",0,0,0,0)
]]>
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>

<section id="mthDefListDragHandler"><title>defListDragHandler</title>
<indexterm><primary>defListDragHandler</primary></indexterm>
<programlisting>
<![CDATA[
>>-defListDragHandler(--id--,--item--,--point--)---------------><

]]>
</programlisting>

<para>
  A list-view control does not handle a drag-and-drop operation itself. It defers that handling to the programmer by
  sending a BEGINGDRAG, (left mouse drag,) or a BEGINRDRAG, (right mouse drag,) event notification. The programmer can
  code his own <link linkend="ovvEvents">event</link> handling method and use <link
  linkend="mthConnectListViewEvent">connectListViewEvent</link>() method to connect the method to the drag-and-drop
  operation.
</para>
<para>
  The <emphasis role="italic">defListDragHandler</emphasis> method is an event handling method supplied by the ooDialog
  framework and the programmer can use this method rather than code his own.
</para>
<para>
  This method implementation allows the user to drag an item from one location to another within an icon view and
  a small icon view. The cursor shape is changed to a crosshair during the drag operation. The user can cancel the drag
  operation by clicking the other mouse button while holding the button that started the drag operation. Note that the
  final icon position is not flexible when the list-view control has the AUTOARRANGE style.
</para>
<para>
  If the programmer wants to implement her own drag-and-drop event handler, she may want to examine the how the
  <emphasis role="italic">defListDragHandler</emphasis> method in the <computeroutput>ooDialog.cls</computeroutput>
  file. In addition the <computeroutput>oodlist.rex</computeroutput> example progam uses the <emphasis
  role="italic">defListDragHandler</emphasis>. Running the example program will show the behavior of the current
  <emphasis role="italic">defListDragHandler</emphasis> implementation.
</para>
<para>
  <emphasis role="bold">Example:</emphasis>
<programlisting>
<![CDATA[
::method initDialog

  ...

  self~connectListViewEvent(ID_LV_ICON, "BEGINDRAG", "defListDragHandler")
  -- Drag and drop operations are not automatically handled.
]]>
</programlisting>
</para>
</section>

<section id="mthDefTreeDragHandler"><title>defTreeDragHandler</title>
<indexterm><primary>defTreeDragHandler</primary></indexterm>
<programlisting>
<![CDATA[
>>-defTreeDragHandler(--id--,--item--,--point--)---------------><

]]>
</programlisting>

<para>
  A tree view control does not handle a drag-and-drop operation itself. It defers that handling to the programmer by
  sending a BEGINGDRAG, (left mouse drag,) or a BEGINRDRAG, (right mouse drag,) event notification. The programmer can
  code his own <link linkend="ovvEvents">event</link> handling method and use <link
  linkend="mthConnectTreeViewEvent">connectTreeViewEvent</link>() method to connect the method to the drag-and-drop
  operation.
</para>
<para>
  The <emphasis role="italic">defTreeDragHandler</emphasis> method is an event handling method supplied by the ooDialog
  framework and the programmer can use this method rather than code his own.
</para>
<para>
  This method implementation allows the user to move an item, or a node with all its subitems, from one parent node to
  another within the tree view. The cursor shape is changed to a crosshair during the drag operation. If the cursor is
  moved over the item dragged, the cursor shape is changed to a slashed circle. The user can cancel the drag operation
  by clicking the other mouse button while holding the button that started the drag operation.
</para>
<para>
  If the programmer wants to implement her own drag-and-drop event handler, she may want to examine the how the
  <emphasis role="italic">defTreeDragHandler</emphasis> method in the <computeroutput>ooDialog.cls</computeroutput>
  file. In addition both the <computeroutput>oodtree.rex</computeroutput> and
  <computeroutput>propdemo.rex</computeroutput> example progams uses the <emphasis
  role="italic">defTreeDragHandler</emphasis>. Running these example programs will show the behavior of the current
  <emphasis role="italic">defTreeDragHandler</emphasis> implementation.
</para>
<para>
  <emphasis role="bold">Example:</emphasis>
<programlisting>
<![CDATA[
::method initDialog

  ...

  self~connectTreeViewEvent("IDC_TREE","BEGINDRAG", "defTreeDragHandler")
  -- Drag and drop operations are not automatically handled.
]]>
</programlisting>
</para>
</section>

</section>
