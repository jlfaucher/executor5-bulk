<!--#########################################################################
    #
    # Description: Open Object Rexx: OODialog Reference SGML file.
    #
    # Copyright (c) 2005-2007, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<chapter id="chapButtonControls"><title>Button Controls</title>
<indexterm><primary>Button Controls</primary></indexterm>
<para>
  In Windows the Button control has a number of different types or kinds.  Most
  button types have a number of different styles.  The style of a button effects
  its behavior and appearance.  The appearance of a button is usually maintained
  by the operating system in combination with the programmer.
</para>
<para>
  In general people refer to "pushing," "clicking," or "checking" a button.  The
  mouse is used to click a button and the enter key to push a button.  Checking
  a button can be done with the mouse or the keyboard.  Buttons have a state,
  the most common of which are checked, unchecked, pushed, and focused.
</para>
<para>
  The five kinds of buttons are:
  <itemizedlist>
    <listitem><para>Push Buttons</para></listitem>
    <listitem><para>Check Boxes</para></listitem>
    <listitem><para>Radio Buttons</para></listitem>
    <listitem><para>Group Boxes</para></listitem>
    <listitem><para>Owner Drawn Buttons</para></listitem>
  </itemizedlist>
</para>
<para>
  ooDialog provides these classes to allow the programmer to interface with the
  underlying button controls:
<table id="tButtonControls" frame="all">
<title>ooDialog Button Control Classes</title>
<tgroup cols="2">
<thead>
<row>
<entry>Button Control Type</entry>
<entry>ooDialog Class</entry>
</row>
</thead>
<tbody>
<row>
<entry>Push Button</entry>
<entry><link linkend="buttoncontrolc">ButtonControl Class</link></entry>
</row>
<row>
<entry>Check Box Button</entry>
<entry><link linkend="checkboxc">CheckBox Class</link></entry>
</row>
<row>
<entry>Raido Button</entry>
<entry><link linkend="radiobuttonc">RadioButton Class</link></entry>
</row>
<row>
<entry>Group Box</entry>
<entry><link linkend="clsGroupBox">GroupBox Class</link></entry>
</row>
<row>
<entry>Owner Drawn Button</entry>
<entry><link linkend="anibut">AnimatedButton Class</link>,
<link linkend="buttoncontrolc">ButtonControl Class</link></entry>
</row>
</tbody></tgroup>
</table>
</para>
<section id="buttoncontrolc"><title>ButtonControl Class</title>
<indexterm><primary>ButtonControl class</primary></indexterm>
<para>
  The ButtonControl class provides methods to query and modify push button controls. In addition, the
  class has methods that allow the ooRexx programmer to partially implement owner drawn buttons using
  bitmaps.
</para>
<variablelist>
  <varlistentry><term>Requires:</term>
  <listitem>
    <para>
      The ButtonControl class requires the class definition file
      <computeroutput>oodwin32.cls</computeroutput>:
<programlisting>
<![CDATA[
::requires "oodwin32.cls"
]]>
</programlisting>
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Subclass of:</emphasis></term>
  <listitem>
    <para>
      The button control class is a subclass of the <link linkend="clsDialogControl">DialogControl</link>
      class and therefore inherits all methods of that class.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Mixin Class Inherits:</emphasis></term>
  <listitem>
    <para>
      The button control class inherits from the following mixin classes, (indirectly through the
      DialogControl class.)
    </para>
    <para>
      The <link linkend="clsWindowBase">WindowBase</link>
    </para>
    <para>
      The <link linkend="clsWindowExtensions">WindowExtensions</link>
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Instantiation:</emphasis></term>
  <listitem>
    <para>
      Use the <link linkend="getbuttoncontrol">getButtonControl</link>() method to retrieve an object of
      the button control class.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Dynamic Definition:</emphasis></term>
  <listitem>
    <para>
      To dynamically define a button control in a <link linkend="clsUserDialog">UserDialog</link> class,
      use one of the add button methods described in the <link linkend="sectAddButtonControls">Add Button
      Control</link> section. That section also describes methods for adding radio buttons, check boxes,
      etc.. Only the addButton... methods are used to add a ButtonControl object.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Event Notification</emphasis></term>
  <listitem>
    <para>
      To recieve notification of button control events use the <link
      linkend="mthConnectStaticNotify">connectStaticNotify</link>)() method.
    </para>
  </listitem></varlistentry>
<varlistentry><term>Methods:</term>
<listitem>
<para>
  The ButtonControl class implements the class and instance methods listed in the following table.
</para>
<table id="t000023" frame="all">
<title>ButtonControl Instance Methods</title>
<tgroup cols="2">
<thead>
<row>
<entry>Method...</entry>
<entry>...on page</entry>
</row>
</thead>
<tbody>
<row>
<entry>changeBitmap</entry>
<entry><link linkend="changebitmap">changeBitmap</link></entry>
</row>
<row>
<entry>click</entry>
<entry><link linkend="mthClick">click</link></entry>
</row>
<row>
<entry>dimBitmap</entry>
<entry><link linkend="dimbitmap">dimBitmap</link></entry>
</row>
<row>
<entry>displaceBitmap</entry>
<entry><link linkend="displacebitmap">displaceBitmap</link></entry>
</row>
<row>
<entry>drawBitmap</entry>
<entry><link linkend="drawbitmap">drawBitmap</link></entry>
</row>
<row>
<entry>getBitmapSizeX</entry>
<entry><link linkend="getbitmapsizex">getBitmapSizeX</link></entry>
</row>
<row>
<entry>getBitmapSizeY</entry>
<entry><link linkend="getbitmapsizey">getBitmapSizeY</link></entry>
</row>
<row>
<entry>getBmpDisplacement</entry>
<entry><link linkend="getbmpdisplacement">getBmpDisplacement</link></entry>
</row>
<row>
<entry>getIdealSize</entry>
<entry><link linkend="mthGetIdealSize">getIdealSize</link></entry>
</row>
<row>
<entry>getImage</entry>
<entry><link linkend="mthGetImage">getImage</link></entry>
</row>
<row>
<entry>getImageList</entry>
<entry><link linkend="mthGetImageList">getImageList</link></entry>
</row>
<row>
<entry>getTextMargin</entry>
<entry><link linkend="mthGetTextMargin">getTextMargin</link></entry>
</row>
<row>
<entry>push</entry>
<entry><link linkend="mthPush">push</link></entry>
</row>
<row>
<entry>scroll</entry>
<entry><link linkend="scrollbc">scroll</link></entry>
</row>
<row>
<entry>scrollBitmapFromTo</entry>
<entry><link linkend="scrollbitmapfromto">scrollBitmapFromTo</link></entry>
</row>
<row>
<entry>scrollText</entry>
<entry><link linkend="scrolltextbc">scrollText</link></entry>
</row>
<row>
<entry>setImage</entry>
<entry><link linkend="mthSetImage">setImage</link></entry>
</row>
<row>
<entry>setImageList</entry>
<entry><link linkend="mthSetImageList">setImageList</link></entry>
</row>
<row>
<entry>setTextMargin</entry>
<entry><link linkend="mthSetTextMargin">setTextMargin</link></entry>
</row>
<row>
<entry>state</entry>
<entry><link linkend="state">state</link></entry>
</row>
<row>
<entry>state=</entry>
<entry><link linkend="statenew">state=</link></entry>
</row>
<row>
<entry>style=</entry>
<entry><link linkend="stylenew">style=</link></entry>
</row>
</tbody></tgroup>
</table>
</listitem></varlistentry>
</variablelist>


<section id="mthPush"><title>push</title>
<indexterm><primary>push</primary>
<secondary>ButtonControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--push---------------------------------------><
]]>
</programlisting>

<para>
  The push method simulates the user pushing the associated button control.  It
  allows an ooRexx programmer to produce the exact same behavior from within an
  ooDialog program, as the behavior produced by the user pushing the button in
  the dialog.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>There are no arguments to this method.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>This example comes from an imaginary program that has a list of
  window handles.  The dialog has a Refresh button that the user can push to
  update the window list.  The code comes from a section of the program that is
  checking if a specific window handle is valid.  If the handle is not valid,
  the code simulates the user pushing the Refresh button to update the window
  list.
<programlisting>
<![CDATA[
::method validate private
    use strict arg hwnd
    if \ self~isWindowHandle(hwnd) then do
        self~getButtonControl(IDC_PB_REFRESH)~push
        return .false
    end
    ...
return .true
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthClick"><title>click</title>
<indexterm><primary>click</primary>
<secondary>ButtonControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--click----------------------------------------><
]]>
</programlisting>

<para>
  The click method programmatically clicks the associated button control.  It simulates the user clicking
  the button and produces exactly the same behavior as if the user had clicked on the button with the
  mouse.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>This method takes no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return any value.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>This example closes the dialog as if the user had clicked the
  cancel button.  (Provided of course that the dialog has a cancel button.)
<programlisting>
<![CDATA[
self~getButtonControl(IDCANCEL)~click
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="state"><title>State</title>
<indexterm><primary>State</primary></indexterm>
<programlisting>
<![CDATA[
>>--state----------------------------------------><
]]>
</programlisting>

<para>
  The state method retrieves the current state of the associated button control.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>A text string that can contain one or more of the following keywords,
separated by blanks:
<variablelist>
<varlistentry><term>&quot;CHECKED&quot;</term>
<listitem><para>The radio button or the check box is checked.  A radio button is
checked when it contains a black dot, a check box is checked when it contains a
check mark.
</para></listitem></varlistentry>
<varlistentry><term>&quot;UNCHECKED&quot;</term>
<listitem><para>The radio button or the check box is not checked.  A radio
button is not checked when it does not contain a black dot and a check box is
not checked when it does not contain a check mark.
</para></listitem></varlistentry>
<varlistentry><term>&quot;INDETERMINATE&quot;</term>
<listitem><para>A 3-state check box button is neither checked nor unchecked.
Only 3-state check box buttons can be in this state.  When in the indeterminate
state, the check box button is drawn in a visually distinctive manner that is
different from checked or unchecked.  Exactly how the indeterminate state is
drawn is dependent on the operating system version.
</para></listitem></varlistentry>
<varlistentry><term>&quot;PUSHED&quot;</term>
<listitem><para>When a button is in the pushed state it is drawn as a sunken
button, otherwise it is drawn as a raised button.  The user causes a button to
be in the pushed state by clicking the button with the left mouse button.  As
long as the mouse button is held down, the button will be drawn as pushed. When
the user releases the mouse button, the button will resume its not pushed state.
When this keyword is not in the text string, the button is not in the pushed
state.
</para></listitem></varlistentry>
<varlistentry><term>&quot;FOCUS&quot;</term>
<listitem><para>The button has the keyboard focus.  When this keyword is missing
from the text string, the button does not have the focus.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
<![CDATA[
button = MyDialog~GetButtonControl("IDOK")
if button == .Nil then return
say button~State
]]>
</programlisting></para>
<para>The result could be &quot;UNCHECKED FOCUS&quot;.</para>
</listitem></varlistentry>
</variablelist>
</section>

<section id="statenew"><title>state=</title>
<indexterm><primary>sState=</primary></indexterm>
<programlisting>
<![CDATA[
>>--state=--newState-----------------------------><

]]>
</programlisting>

<para>
  The state= method sets the state for the associated button control.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>newState</term>
<listitem>
  <para>
    A text string that contains one or more of the following keywords, separated by a blank:
    <simplelist type='horiz' columns='2'>
    <member>CHECKED</member>       <member>UNCHECKED</member>
    <member>PUSHED</member>        <member>NOTPUSHED</member>
    <member>INDETERMINATE</member> <member>FOCUS</member>
    </simplelist>
    <variablelist>
    <varlistentry><term>CHECKED</term>
    <listitem><para>
      The radio button or the check box is to be set to the &quot;checked&quot; state.
    </para></listitem></varlistentry>
    <varlistentry><term>UNCHECKED</term>
    <listitem><para>
      The radio button or the check box is to be set to the &quot;unchecked&quot; state.
    </para></listitem></varlistentry>
    <varlistentry><term>PUSHED</term>
    <listitem><para>
      The button is to be set to the &quot;pushed&quot; state.
    </para></listitem></varlistentry>
    <varlistentry><term>NOTPUSHED</term>
    <listitem><para>
      The &quot;pushed&quot; state is to be removed from the button.
    </para></listitem></varlistentry>
    <varlistentry><term>INDETERMINATE</term>
    <listitem><para>
      The 3-state check box button is to be set to the &quot;indeterminate&quot; state.  This state can
      only be applied to 3-state check box buttons.
    </para></listitem></varlistentry>
    <varlistentry><term>FOCUS</term>
    <listitem><para>
      The button is to be set to the &quot;focused&quot; state.
    </para></listitem></varlistentry>
    </variablelist>
  </para>
</listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
<![CDATA[
button = MyDialog~GetButtonControl("IDOK")
if button == .Nil then return
button~state="FOCUS PUSHED"
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Notes:</emphasis></term>
<listitem><para>Some points to remember when using this method.
<orderedlist>
<listitem><para>The checked, unchecked or indeterminate states have no meaning
for a push button.  Setting a push button to one of these states therefore has
no effect.
</para></listitem>
<listitem><para>A radio button or check box can be set to only one of the
checked, unchecked or indeterminate states.  If more than one of these states is
specified in the text string the button is set to the state that is first in the
string.
</para></listitem>
<listitem><para>Only 3-state check box buttons can be set to the indeterminate
state.  If this keyword is used for a button that is not a 3-state button then
the button's state is not changed.
</para></listitem>
<listitem><para>To change a button state to not focused programmatically use
one of the ooDialog methods that move the focus: <link linkend="tabtonext">TabToNext</link>,
<link linkend="tabtoprevious">TabToPrevious</link>, <link linkend="setfocus">SetFocus</link>,
<link linkend="focusitem">FocusItem</link>, etc..
</para></listitem>
</orderedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="stylenew"><title>style=</title>
<indexterm><primary>style=</primary>
<secondary>ButtonControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--style=--newStyle-----------------------------><

]]>
</programlisting>

<para>
  The style= method changes the style of the associated button control.
<note><title>Note</title>
<para>
  In the past, the documentation for this method was incomplete or misleading.
  There are really two aspects to a button, its type (or kind) and its style.
  Many of the button styles only have meaning within the same type of button.
  These styles can not be applied to a button of a different type after the
  button has been created.
</para>
<para>
  For instance, the AUTOCHECKBOX style can only be applied to a check box type
  of button.  Trying to give this style to a radio type button has no effect.
  Because of this, certain of the style key words have no effect.  They are
  listed here only because they were listed in previous versions of the
  documentation.  This may have lead someone to use the key word in their code.
  An example is the GROUPBOX key word. The group box type of button only has one
  style. This style can not be applied to any other type of button, so setting
  the style of any button to GROUPBOX has no effect, and has never had any
  effect.
</para>
<para>
  However, within each type of button, the styles that apply to that type of
  button can be changed.  For instance, a check box type of button that has the
  3STATE style, can be changed to have the AUTOCHECKBOX style or to have the
  AUTO3STATE style.
</para>
</note></para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>newStyle</term>
<listitem>
<para>
  A text string containing one or more of the following keywords separated by blanks.  Common sense
  should be used when constructing the newStyle string. If mutually exclusive key words are used, the
  outcome will be dependent on the order of the key words.
</para>
<para>
  <simplelist type='vert' columns='3'>
  <member>DEFPUSHBUTTON</member> <member>LEFTTEXT   </member> <member>BOTTOM      </member>
  <member>PUSHBOX      </member> <member>RIGHTBUTTON</member> <member>VCENTER     </member>
  <member>RADIO        </member> <member>NOTLEFTTEXT</member> <member>PUSHLIKE    </member>
  <member>AUTORADIO    </member> <member>TEXT       </member> <member>MULTILINE   </member>
  <member>CHECKBOX     </member> <member>ICON       </member> <member>NOTIFY      </member>
  <member>AUTOCHECKBOX </member> <member>BITMAP     </member> <member>FLAT        </member>
  <member>3STATE       </member> <member>LEFT       </member> <member>NOTPUSHLIKE </member>
  <member>AUTO3STATE   </member> <member>RIGHT      </member> <member>NOTMULTILINE</member>
  <member>GROUPBOX     </member> <member>HCENTER    </member> <member>NOTNOTIFY   </member>
  <member>OWNERDRAW    </member> <member>TOP        </member> <member>NOTFLAT     </member>
  </simplelist>
<variablelist>
<varlistentry><term>DEFPUSHBUTTON</term>
<listitem><para>In a dialog, the default push button is the button that is
  pushed when the Enter key is pressed.  Changing the default push button will
  change the behavior of the dialog when the user presses the enter key.
</para></listitem></varlistentry>
<varlistentry><term>PUSHBOX</term>
<listitem><para>A push button that does not display the button face or border,
  only the text appears.  This button style is not applicable when Windows
  themes are in use.
</para></listitem></varlistentry>
<varlistentry><term>RADIO</term>
<listitem><para>A radio button the state of which has to be maintained by the
  programmer.
</para></listitem></varlistentry>
<varlistentry><term>AUTO</term>
<listitem><para>A radio button where the operating system maintains the check
state for all radio buttons in the same group.  When one radio button in the
group is checked by the user, the operating system unchecks all other buttons in
the group.
</para></listitem></varlistentry>
<varlistentry><term>CHECKBOX</term>
<listitem><para>A check box where the state has to be maintained by the
  programmer.  The state can only be checked or unchecked.
</para></listitem></varlistentry>
<varlistentry><term>AUTOCHECKBOX</term>
<listitem><para>A check box where the operating system maintains the check state
  for the programmer.
</para></listitem></varlistentry>
<varlistentry><term>3STATE</term>
<listitem><para>A check box button that has a grayed state as well as checked or
unchecked.  The greyed state shows that the check state of the button is not
determined.  The programmer needs to manage the state of the button when it is
clicked.
</para></listitem></varlistentry>
<varlistentry><term>AUTO3STATE</term>
<listitem><para>A check box button that is the same as a three-state check box
except that the operating system maintains the check state for the programmer.
</para></listitem></varlistentry>
<varlistentry><term>GROUPBOX</term>
<listitem><para>This key word has no effect.
</para></listitem></varlistentry>
<varlistentry><term>OWNERDRAW</term>
<listitem><para>This key word has no effect.
</para></listitem></varlistentry>
<varlistentry><term>LEFTTEXT</term>
<listitem><para>Places the text on the left of the button for a radio button or
  check box.  This style and RIGHTBUTTON are equivalent.
</para></listitem></varlistentry>
<varlistentry><term>RIGHTBUTTON</term>
<listitem><para>Places the button on the right of the text for a radio button
  or a check box. This style is the same as LEFTTEXT.
</para></listitem></varlistentry>
<varlistentry><term>NOTLEFTTEXT</term>
<listitem><para>Removes the LEFTTEXT style.
</para></listitem></varlistentry>
<varlistentry><term>TEXT</term>
<listitem><para>The button displays text.
</para></listitem></varlistentry>
<varlistentry><term>ICON</term>
<listitem><para>The button displays an icon image.
</para></listitem></varlistentry>
<varlistentry><term>BITMAP</term>
<listitem><para>The button displays a bitmap image.
</para></listitem></varlistentry>
<varlistentry><term>LEFT</term>
<listitem><para>The button has its text left-justified in the button rectangle.
</para></listitem></varlistentry>
<varlistentry><term>RIGHT</term>
<listitem><para>The button has its text right-justified in the button rectangle.
</para></listitem></varlistentry>
<varlistentry><term>HCENTER</term>
<listitem><para>The button has its text centered horizontally in the button
  rectangle.
</para></listitem></varlistentry>
<varlistentry><term>TOP</term>
<listitem><para>The text is placed at the top of the button rectangle.
</para></listitem></varlistentry>
<varlistentry><term>BOTTOM</term>
<listitem><para>The text is placed at the bottom of the button rectangle.
</para></listitem></varlistentry>
<varlistentry><term>VCENTER</term>
<listitem><para>The text is vertically centered in the button rectanble.
</para></listitem></varlistentry>
<varlistentry><term>PUSHLIKE</term>
<listitem><para>Causes a radio button or check box button to behave like a push
  button.
</para></listitem></varlistentry>
<varlistentry><term>MULTILINE</term>
<listitem><para>Causes the text for a button to wrap to multiple lines if the
  text is too long for the width of the button.
</para></listitem></varlistentry>
<varlistentry><term>NOTIFY</term>
<listitem><para>Enables a button to send the kill focus and set focus messages.
  See the <link linkend="mthConnectButtonNotify">connectButtonNotify</link> method
  of the <link linkend="clsMessageExtensions">MessageExtensions Class</link>.  If the button
  does not have this style, kill and set focus events will not be received, if
  the programmer does <computeroutput>connectButtonNotify()</computeroutput> to
  connect those events.
</para></listitem></varlistentry>
<varlistentry><term>FLAT</term>
<listitem><para>Gives the button a flat appearance.  This style is not
  applicable when Windows themes are in effect.
</para></listitem></varlistentry>
<varlistentry><term>NOTPUSHLIKE</term>
<listitem><para>Removes the push like style.
</para></listitem></varlistentry>
<varlistentry><term>NOTMULTILINE</term>
<listitem><para>Removes the multi-line style.
</para></listitem></varlistentry>
<varlistentry><term>NOTNOTIFY</term>
<listitem><para>Removes the notify style.
</para></listitem></varlistentry>
<varlistentry><term>NOTFLAT</term>
<listitem><para>Removes the flat style.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example 1:</emphasis></term>
<listitem><para>The following example makes the OK button the default button:
<programlisting>
<![CDATA[
button = MyDialog~GetButtonControl("IDOK")
if button == .Nil then return
button~style="DEFPUSHBUTTON"
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example 2:</emphasis></term>
<listitem><para>This example changes the text of a check box button depending on
  the state another check box.  When the button text is long, the multi-line
  style is added and the placement of the text in relation to the button
  rectangle is changed.  When the text is short, the button style is set back to
  the default style.
<programlisting> <![CDATA[
::method idCheckOne
  use arg wParam, lParam

  id = .DlgUtil~loWord(wParam)
  if self~getCheckControl(id)~checked then do
    chkButton = self~getCheckControl(IDC_CHECK_TWO)
    chkButton~style = "MULTILINE TOP HCENTER"
    chkButton~setTitle("Use IPv6 not IPv4 during this connection")
  end
  else do
    chkButton = self~getCheckControl(IDC_CHECK_TWO)
    chkButton~style = "NOTMULTILINE VCENTER LEFT"
    chkButton~setTitle("Connect")
  end

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthGetIdealSize"><title>getIdealSize</title>
<indexterm><primary>getIdealSize</primary></indexterm>
<programlisting>
<![CDATA[
>>--getIdealSize---------------------------------><

]]>
</programlisting>
<para>
  This method queries the button control for its ideal size.  The ideal size is the size that best fits
  its text or image.  (If the button has an image list.)
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">ComCtl32 dependent </emphasis></term>
<listitem>
<para>
  This method requires <link linkend="comctl32">Common Control Library</link>
  version 6.0 or later. If necessary use the <link
  linkend="mthComCtl32Version">comCtl32Version</link>() method to determine the
  current version of the library.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>This method has no arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The possible return values are:
<variablelist>
<varlistentry><term>A <link linkend="clsSize">.Size</link> object</term>
<listitem><para>The ideal size for the button.
</para></listitem></varlistentry>
<varlistentry><term>The <computeroutput>.nil</computeroutput> object</term>
<listitem><para>Some unanticipated error.  This is very unlikely to happen.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
<![CDATA[
size = self~getButtonControl(IDC_PB_REVIEW)~getIdealSize
say 'The ideal height for the button is' size~height'
say 'The ideal width for the button is' size~width

/* Output might be for example:
 *   The ideal height for the button is 24
 *   The ideal width for the button is 45
 */
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthGetTextMargin"><title>getTextMargin</title>
<indexterm><primary>getTextMargin</primary></indexterm>
<programlisting>
<![CDATA[
>>--getTextMargin--------------------------------><
]]>
</programlisting>

<para>
  This method retrieves the margins used to draw text within the assoicated
  button control.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">ComCtl32 dependent</emphasis></term>
<listitem>
<para>
  This method requires <link linkend="comctl32">Common Control Library</link>
  version 6.0 or later. If necessary use the <link
  linkend="mthComCtl32Version">comCtl32Version</link>() method to determine the
  current version of the library.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>This method does not take any arguments.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The possible return values are:
<variablelist>
<varlistentry><term>A <link linkend="clsRect">.Rect</link> object</term>
<listitem><para>The margin for drawing text in the button.
</para></listitem></varlistentry>
<varlistentry><term>The <computeroutput>.nil</computeroutput> object.</term>
<listitem><para>An unanticipated error.  This is not likely to happen.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
<![CDATA[
margins = self~getButtonControl(IDC_PB_REDRAW)~getTextMagin
say 'The text margins for the "Redraw" button:'
say '  Left:  ' margins~left
say '  Top:   ' margins~top
say '  Right: ' margins~right
say '  Bottom:' margins~bottom

/* Output might be for example:
 *   The text margins for the "Redraw" button:
 *     Left:   1
 *     Top:    1
 *     Right:  1
 *     Bottom: 1
 */
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthSetTextMargin"><title>setTextMargin</title>
<indexterm><primary>setTextMargin</primary>
<secondary>ButtonControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--setTextMargin(--margins--)-------------------><

]]>
</programlisting>

<para>
  This method sets the margins for drawing text in the associated button control.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">ComCtl32 dependent</emphasis></term>
<listitem>
<para>
  This method requires <link linkend="comctl32">Common Control Library</link>
  version 6.0 or later. If necessary use the <link
  linkend="mthComCtl32Version">comCtl32Version</link>() method to determine the
  current version of the library.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>margins</term>
<listitem>
<para>
  A <link linkend="clsRect">.Rect</link> object describing the new margins.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The possible return values are:
<variablelist>
<varlistentry><term><computeroutput>.true</computeroutput></term>
<listitem><para>Success
</para></listitem></varlistentry>
<varlistentry><term><computeroutput>.false</computeroutput></term>
<listitem><para>Failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>This example sets a new text margin of 5 for the button control.
<programlisting>
<![CDATA[
margins = .Rect~new(5, 5, 5, 5)
self~getButtonControl(IDC_PB_SHOW_DETAILS)~setTextMargin(margins)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthGetImageList"><title>getImageList</title>
<indexterm><primary>getImageList</primary>
<secondary>ButtonControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>--getImageList---------------------------------><

]]>
</programlisting>

<para>
  This method retrieves information describing the image list for the associated
  button, if there is one.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The are no arguments to this method.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The return value is:
<variablelist>
<varlistentry><term>A <computeroutput>.Directory</computeroutput> object.</term>
<listitem>
<para>The image list information is returned in a Directory object. The
  directory object has the following entries:
  <variablelist>
  <varlistentry><term>handle</term>
  <listitem><para>The Windows handle to the image list.
  </para></listitem></varlistentry>
  <varlistentry><term>rect</term>
  <listitem><para>A <link linkend="clsRect">.Rect</link> object that specifies
    the margin around the image.
  </para></listitem></varlistentry>
  <varlistentry><term>alignment</term>
  <listitem><para>A key word that specifies the alignment of the image list.
    The key word will be exactly one of these words: TOP LEFT RIGHT BOTTOM
    CENTER.
  </para></listitem></varlistentry>
  </variablelist>
</para></listitem></varlistentry>
<varlistentry><term>The <computeroutput>.nil</computeroutput> object</term>
<listitem>
  <para>
    The .nil object is returned if the button does not have an image list, or for some other
    unanticipated error.
  </para>
</listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>This example ...
<programlisting>
<![CDATA[
  pbBig  = self~getButtonControl(IDC_PB_BIGRECT)
  if pbBig <> .nil then do
    d = pbBig~getImageList
    if d <> .nil thend
      p = d~handle

      say 'Got image list:' d
      say '  handle: ' d~handle
      say '  rect:   ' d~rect
      say '  align:  ' d~alignment

      say 'Image margins:' d~rect~left',' d~rect~top',' d~rect~right',' d~rect~bottom
    end
  end

/* Output might be for example:
 *   Got image list: a Directory
 *     handle:  0x000E60F0
 *     rect:    a Rect
 *     align:   BOTTOM
 *   Image margins: 5, 5, 5, 5
 */
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthSetImageList"><title>setImageList</title>
<indexterm><primary>setImageList</primary></indexterm>
<programlisting>
<![CDATA[
>>--setImageList(--imageList--,--+--------+--,--+-------+--)-------------------><
                                 +-margin-+     +-align-+

]]>
</programlisting>

<para></para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>x</term>
<listitem><para>xx.
</para></listitem></varlistentry>
<varlistentry><term>y</term>
<listitem><para>yyy,
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem>
  <para>
    The possible return values are:
    <variablelist>
    <varlistentry><term>0</term>
    <listitem>
      <para>
        Success
      </para>
    </listitem></varlistentry>
    <varlistentry><term>-1</term>
    <listitem>
      <para>
        Some error.
      </para>
    </listitem></varlistentry>
    </variablelist>
  </para>
</listitem></varlistentry>
<varlistentry id="exampleSetImageList"><term><emphasis role="bold">Example:</emphasis></term>
<listitem>
<para>
  In addition to the setImageList() method, this example uses a number of other methods
  related to using image lists with buttons. Such as, <link
  linkend="mthGetImageList">getImageList</link>, <link
  linkend="mthGetIdealSize">getIdealSize</link>, and <link
  linkend="mthComCtl32Version">comCtl32Version</link>.

<programlisting>
<![CDATA[
x = y
return 0
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthGetImage"><title>getImage</title>
<indexterm><primary>getImage</primary>
<secondary>ButtonControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aButtonControl~getImage(--x--,--y--)------------------><


]]>
</programlisting>

<para></para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>x</term>
<listitem><para>xx.
</para></listitem></varlistentry>
<varlistentry><term>y</term>
<listitem><para>yyy,
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The possible return values are:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Success
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>Some error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>This example ...
<programlisting>
<![CDATA[
x = y
return 0
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="mthSetImage"><title>setImage</title>
<indexterm><primary>setImage</primary>
<secondary>ButtonControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aButtonControl~setImage(--x--,--y--)------------------><

]]>
</programlisting>

<para></para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>x</term>
<listitem><para>xx.
</para></listitem></varlistentry>
<varlistentry><term>y</term>
<listitem><para>yyy,
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The possible return values are:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Success
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>Some error.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>This example ...
<programlisting>
<![CDATA[
x = y
return 0
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>


<section id="changebitmap"><title>ChangeBitmap</title>
<indexterm><primary>ChangeBitmap</primary></indexterm>
<programlisting>
<![CDATA[
>>-aButtonControl~ChangeBitmap(--bmpNormal--,--+------------+--,-->
                                               +-bmpFocused-+

>--+-------------+--,--+-------------+--+-----------------+--)-><
   +-bmpSelected-+     +-bmpDisabled-+  +-,--+-FRAME----+-+
                                             +-USEPAL---+
                                             +-INMEMORY-+
                                             +-STRETCH--+


]]>
</programlisting>

<para>The ChangeBitmap method changes the bitmap of a
bitmap button.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>bmpNormal</term>
<listitem><para>The (alphanumeric) name, (numeric) resource ID, or handle of a bitmap
that is displayed when the button is neither selected, nor focused, nor disabled.
If you specify the bitmap handle, the INMEMORY option must be specified.</para>
<para>This option is used if none of the other arguments is specified.</para>
</listitem></varlistentry>
<varlistentry><term>bmpFocused</term>
<listitem><para>The (alphanumeric) name, (numeric) resource ID, or handle of a bitmap
that is displayed when the button is focused. The focused button is activated
when the Enter key is pressed. If you specify the bitmap handle, the INMEMORY
option must be specified.
</para></listitem></varlistentry>
<varlistentry><term>bmpSelected</term>
<listitem><para>The (alphanumeric) name, (numeric) resource ID, or handle of a bitmap
that is displayed when the button is clicked and held. If you specify the
bitmap handle, the INMEMORY option must be specified.
</para></listitem></varlistentry>
<varlistentry><term>bmpDisabled</term>
<listitem><para>The (alphanumeric) name, (numeric) resource ID, or handle of a bitmap
that is displayed when the button is disabled. If you specify the bitmap handle,
the INMEMORY option must be specified.
</para></listitem></varlistentry>
<varlistentry><term>styleOptions</term>
<listitem><para>The last argument can be one of the following:
<variablelist>
<varlistentry><term>FRAME</term>
<listitem><para>Draws a frame around the button. When you use this option, the bitmap
button behaves like a normal Windows button except that a bitmap is
shown instead of text.
</para></listitem></varlistentry>
<varlistentry><term>USEPAL</term>
<listitem><para>Takes the colors of the bitmap file and stores them as the system color
palette. This option is needed when the bitmap was created with a palette
other than the default Windows color palette. Use it for one
button only because only one color palette can be active at a time.</para>
<para>This
option is not valid for a bitmap loaded from a dynamic-link library.</para>
</listitem></varlistentry>
<varlistentry><term>INMEMORY</term>
<listitem><para>This option must be used if the named bitmaps are already loaded into
memory by using the LoadBitmap method (see
<link linkend="h000667">LoadBitmap</link>).
In this case, you must specify a bitmap handle instead of a file name or ID.
</para></listitem></varlistentry>
<varlistentry><term>STRETCH</term>
<listitem><para>If this option is specified and the extent of the bitmap is smaller
than the extent of the button rectangle, the bitmap is adapted to match the
extent of the button. This option has no effect on bitmaps loaded from a dynamic-link
library.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
<![CDATA[
button = MyDialog~GetButtonControl("IDOK")
if button == .Nil then return
button~ChangeBitmap("AddBut_n.bmp", "AddBut_f.bmp", "AddBut_s.bmp", ,
"AddBut_d.bmp", "FRAME")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
<para>See also <link linkend="mthConnectBitmapButton">ConnectBitmapButton</link>.</para>
</section>

<section id="displacebitmap"><title>DisplaceBitmap</title>
<indexterm><primary>DisplaceBitmap</primary>
<secondary>ButtonControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aButtonControl~DisplaceBitmap(--x--,--y--)------------------><


]]>
</programlisting>

<para>The DisplaceBitmap method sets the position of
a bitmap within a bitmap button.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>x</term>
<listitem><para>The horizontal displacement, in screen pixels. A negative value can
also be used.
</para></listitem></varlistentry>
<varlistentry><term>y</term>
<listitem><para>The vertical displacement, in screen pixels. A negative value can also
be used.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example moves the bitmap within the associated bitmap
button 4 screen pixels to the right and 3 pixels upward:
<programlisting>
<![CDATA[
button = MyDialog~GetButtonControl("IDOK")
if button == .Nil then return
parse value button~GetBmpDisplacement with dx dy
button~DisplacementBitmap(244, dx+4, dy-3)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="getbmpdisplacement"><title>GetBmpDisplacement</title>
<indexterm><primary>GetBmpDisplacement</primary>
<secondary>ButtonControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aButtonControl~GetBmpDisplacement---------------------------><


]]>
</programlisting>

<para>The GetBmpDisplacement method retrieves the position
of a bitmap within a bitmap button.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The horizontal and vertical positions of the bitmap, in screen pixels
and separated by a blank.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>See <link linkend="displacebitmap">DisplaceBitmap</link>.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="scrollbc"><title>Scroll</title>
<indexterm><primary>Scroll</primary>
<secondary>ButtonControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aButtonControl~Scroll(--xPos--,--yPos--,--left--,--top--,--right--,--bottom--)-><


]]>
</programlisting>

<para>The Scroll method moves the rectangle within the
associated button and redraws the uncovered area with the button background
color. It is used to move bitmaps within bitmap buttons.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>xPos, yPos</term>
<listitem><para>The new position of the rectangle, in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>left, top, right, bottom</term>
<listitem><para>The upper left and lower right corner of the rectangle to be moved.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="scrolltextbc"><title>ScrollText</title>
<indexterm><primary>ScrollText</primary>
<secondary>ButtonControl class</secondary></indexterm>
<programlisting>
<![CDATA[
                                                         +-10-------+
>>-aButtonControl~ScrollText(--text--,--+----------+--,--+----------+--,------>
                                        +-fontName-+     +-fontSize-+

                                    +-0---------+     +-4----+     +-10----+
>--+--------------------------+--,--+-----------+--,--+------+--,--+-------+-->
   |    +----------------+    |     +-displaceY-+     +-step-+     +-sleep-+
   |    V                |    |
   +-"----+-THIN-------+-+--"-+
          +-EXTRALIGHT-+
          +-LIGHT------+
          +-MEDIUM-----+
          +-SEMIBOLD---+
          +-EXTRABOLD--+
          +-BOLD-------+
          +-HEAVY------+
          +-UNDERLINE--+
          +-ITALIC-----+
          +-STRIKEOUT--+

      +-0-----+
>--,--+-------+--)----------------------------------------------------------><
      +-color-+


]]>
</programlisting>

<para>The ScrollText method scrolls text in the associated
button with the given font, size, and color. The text is scrolled from right
to left. If the method is started concurrently, call it a second time to stop
scrolling. The associated button must have the OWNERDRAWN style.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>text</term>
<listitem><para>A text string that is displayed and scrolled.
</para></listitem></varlistentry>
<varlistentry><term>fontName</term>
<listitem><para>The name of the font used to write the text. If omitted, the system
font is used.
</para></listitem></varlistentry>
<varlistentry><term>fontSize</term>
<listitem><para>The size of the font used to write the text. If omitted, the standard
size (10) is used.
</para></listitem></varlistentry>
<varlistentry><term>fontStyle</term>
<listitem><para>This argument can be one or more of the keywords listed in the syntax
diagram. If you use more than one keyword, put them in one string, separated
by blanks.
</para></listitem></varlistentry>
<varlistentry><term>displaceY</term>
<listitem><para>The vertical displacement of the text relative to the top of the client
area of the window. The default is 0.
</para></listitem></varlistentry>
<varlistentry><term>step</term>
<listitem><para>The amount of screen pixels that the text is moved in each cycle. The
default is 4.
</para></listitem></varlistentry>
<varlistentry><term>sleep</term>
<listitem><para>The time, in milliseconds, that the program waits after each movement
to determine the scrolling speed. The default is 10.
</para></listitem></varlistentry>
<varlistentry><term>color</term>
<listitem><para>The color index used for the text. The default is 0, which is black.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example scrolls the string "Hello world!" from left to
right within the associated button. The text is located 2 pixels below the
top of the client area, one move is 3 screen pixels, and the delay time after
each movement is 15 ms.
<programlisting>
<![CDATA[
button = MyDialog~GetButtonControl("IFOK")
if button == .Nil then return
button~ScrollText("Hello world!", "Arial", 36, "BOLD ITALIC", 2, 3, 15, 4)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="getbitmapsizex"><title>GetBitmapSizeX</title>
<indexterm><primary>GetBitmapSizeX</primary>
<secondary>ButtonControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aButtonControl~GetBitmapSizeX-------------------------------><


]]>
</programlisting>

<para>The GetBitmapSizeX method retrieves the width of
the bitmap that is set for the associated button.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The width of the bitmap, in screen pixels.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="getbitmapsizey"><title>GetBitmapSizeY</title>
<indexterm><primary>GetBitmapSizeY</primary>
<secondary>ButtonControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aButtonControl~GetBitmapSizeY-------------------------------><


]]>
</programlisting>

<para>The GetBitmapSizeY method retrieves the height
of the bitmap that is set for the associated button.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The height of the bitmap, in screen pixels.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="drawbitmap"><title>DrawBitmap</title>
<indexterm><primary>DrawBitmap</primary>
<secondary>ButtonControl class</secondary></indexterm>
<programlisting>
<![CDATA[
                               +-0----+     +-0----+     +-0----+
>>-aButtonControl~DrawBitmap(--+------+--,--+------+--,--+------+--,-->
                               +-tarx-+     +-tary-+     +-srcx-+

   +-0----+     +-0-----+     +-0------+
>--+------+--,--+-------+--,--+--------+--)--------------------><
   +-srcy-+     +-width-+     +-height-+


]]>
</programlisting>

<para>The DrawBitmap method draws the bitmap of the associated
bitmap button. You can also use this method to move a bitmap or part of it.</para>
<para>Contrary to the method <link linkend="displacebitmap">DisplaceBitmap</link>, which sets a permanent
position for the bitmap, DrawBitmap immediately draws the bitmap, or part
of it, at the specified position. If the button must be refreshed, the bitmap
is drawn at the position set with DisplaceBitmap. DrawBitmap is used by <link linkend="scrollbitmapfromto">ScrollBitmapFromTo</link>, for example.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>tarx,tary</term>
<listitem><para>The position relative to the client area of the button where the bitmap
is to be displayed. The default is 0,0.
</para></listitem></varlistentry>
<varlistentry><term>srcx,srcy</term>
<listitem><para>The offsets that specify the first pixel in the bitmap to be displayed.
If you omit these arguments, the pixel at position 0,0 is the first pixel
displayed.
</para></listitem></varlistentry>
<varlistentry><term>width,height</term>
<listitem><para>The width and height of the bitmap. If you omit these arguments or specify
0, the entire bitmap is displayed at the specified position. You can use these
arguments to display only parts of the bitmap.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>0 if the bitmap could be drawn.
</para></listitem></varlistentry>
</variablelist>

<note><title>Note</title><para>
You can use the DrawBitmap method to animate a bitmap by providing
a bitmap that contains several images and use the offset and extension arguments
to display a single image of the bitmap.
</para></note>
</section>

<section id="dimbitmap"><title>DimBitmap</title>
<indexterm><primary>DimBitmap</primary></indexterm>
<programlisting>
<![CDATA[
>>-aButtonControl~DimBitmap(--bmpHandle--,--width--,--height--,-->

   +-2-----+     +-2-----+     +-10----+
>--+-------+--,--+-------+--,--+-------+--)--------------------><
   +-stepx-+     +-stepy-+     +-steps-+


]]>
</programlisting>

<para>The DimBitmap method draws a bitmap step by step.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>bmpHandle</term>
<listitem><para>A handle to the bitmap loaded with
<link linkend="h000667">LoadBitmap</link>.
</para></listitem></varlistentry>
<varlistentry><term>width, height</term>
<listitem><para>The extensions of the bitmap.
</para></listitem></varlistentry>
<varlistentry><term>stepx, stepy</term>
<listitem><para>The number of incremental pixels displayed at each step.
The default is 2,2.
</para></listitem></varlistentry>
<varlistentry><term>steps</term>
<listitem><para>The number of iterations used to display the bitmap.
The default is 10.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>This method does not return a value.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="scrollbitmapfromto"><title>ScrollBitmapFromTo</title>
<indexterm><primary>ScrollBitmapFromTo</primary>
<secondary>ButtonControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aButtonControl~ScrollBitmapFromTo(--fromX--,--fromY--,--toX--,--toY--,-->

>--stepx--,--stepy--,--delay--,--displace--)-------------------><


]]>
</programlisting>

<para>The ScrollBitmapFromTo method scrolls the bitmap
within the associated bitmap button from one position to another.</para>
<para>For an explanation of the arguments, refer to
<link linkend="h001172">ScrollBitmapFromTo</link>.</para>
</section>
</section>

<section id="radiobuttonc"><title>RadioButton Class</title>
<indexterm><primary>RadioButton class</primary></indexterm>
<para>The RadioButton class provides methods to query
and modify radio button controls. It inherits all methods of the ButtonControl
and DialogControl classes (see
<link linkend="buttoncontrolc">ButtonControl Class</link>
and <link linkend="clsDialogControl">DialogControl Class</link>).</para>
<para>Use the GetRadioControl (see
<link linkend="getradiocontrol">GetRadioControl</link>)
to retrieve an object of the RadioButton class.</para>
<variablelist>
<varlistentry><term>Requires:</term>
<listitem><para>The RadioButton class requires the class definition
file <computeroutput>oodwin32.cls</computeroutput>:
<programlisting>
<![CDATA[
::requires "oodwin32.cls"
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>Methods:</term>
<listitem><para>Instances of the RadioControl class implement
the methods listed in the
<link linkend="t000024">RadioButton Instance Methods</link> table.</para>

<table id="t000024" frame="all">
<title>RadioButton Instance Methods</title>
<tgroup cols="2">
<thead>
<row>
<entry>Method...</entry>
<entry>...on page</entry>
</row>
</thead>
<tbody>
<row>
<entry>Check</entry>
<entry><link linkend="check">Check</link></entry>
</row>
<row>
<entry>Indeterminate</entry>
<entry><link linkend="indeterminate">Indeterminate</link></entry>
</row>
<row>
<entry>IsChecked</entry>
<entry><link linkend="ischecked">IsChecked</link></entry>
</row>
<row>
<entry>Uncheck</entry>
<entry><link linkend="uncheck">Uncheck</link></entry>
</row>
</tbody></tgroup>
</table>
</listitem></varlistentry>
</variablelist>
<para>Events for instances of the RadioButton class may be captured using the
<link linkend="mthConnectButtonNotify">connectButtonNotify</link> method of the
<link linkend="clsMessageExtensions">MessageExtensions Class</link>.</para>

<section id="ischecked"><title>IsChecked</title>
<indexterm><primary>IsChecked</primary></indexterm>
<programlisting>
<![CDATA[
>>-aRadioButton~IsChecked--------------------------------------><


]]>
</programlisting>

<para>The IsChecked method retrieves the current state
of the associated button control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>One of the following values:
<variablelist>
<varlistentry><term>&quot;CHECKED&quot;</term>
<listitem><para>The radio button is selected or the check box is checked.
</para></listitem></varlistentry>
<varlistentry><term>&quot;UNCHECKED&quot;</term>
<listitem><para>The radio button is not selected or the check box is unchecked.
</para></listitem></varlistentry>
<varlistentry><term>&quot;INDETERMINATE&quot;</term>
<listitem><para>The Auto-3-State button is grayed to indicate an indeterminate
state.
</para></listitem></varlistentry>
<varlistentry><term>&quot;UNKNOWN&quot;</term>
<listitem><para>No information on the current state available.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="check"><title>Check</title>
<indexterm><primary>Check</primary></indexterm>
<programlisting>
<![CDATA[
>>-aRadioButton~Check------------------------------------------><


]]>
</programlisting>

<para>The Check method marks the associated button control
as checked.</para>
</section>

<section id="uncheck"><title>Uncheck</title>
<indexterm><primary>Uncheck</primary></indexterm>
<programlisting>
<![CDATA[
>>-aRadioButton~Uncheck----------------------------------------><


]]>
</programlisting>

<para>The Uncheck method deletes the check mark of the
button control.</para>
</section>

<section id="indeterminate"><title>Indeterminate</title>
<indexterm><primary>Indeterminate</primary></indexterm>
<programlisting>
<![CDATA[
>>-aRadioButton~Indeterminate----------------------------------><


]]>
</programlisting>

<para>The Indeterminate method grays the check box of
an Auto-3-State button to indicate an indeterminate
state.</para>
</section>
</section>

<section id="checkboxc"><title>CheckBox Class</title>
<indexterm><primary>CheckBox class</primary></indexterm>
<para>The CheckBox class provides methods to query and
modify check box controls. It inherits all methods of:</para>
<itemizedlist>
<listitem><para>The RadioButton class (see
<link linkend="radiobuttonc">RadioButton Class</link>)</para></listitem>
<listitem><para>The ButtonControl class (see
<link linkend="buttoncontrolc">ButtonControl Class</link>)</para></listitem>
<listitem><para>The DialogControl class (see
<link linkend="clsDialogControl">DialogControl Class</link>)
</para></listitem>
</itemizedlist>
<para>The CheckBox class requires the class definition
file <computeroutput>oodwin32.cls</computeroutput>:</para>
<programlisting>
<![CDATA[
::requires "oodwin32.cls"
]]>
</programlisting>
<para>Use the GetCheckControl method (see
<link linkend="getcheckcontrol">GetCheckControl</link>)
to retrieve an object of the CheckBox class.</para>
<para>Events for instances of the CheckBox class may be captured using the
<link linkend="mthConnectButtonNotify">connectButtonNotify</link> method of the
<link linkend="clsMessageExtensions">MessageExtensions Class</link>.</para>
</section>

<section id="clsGroupBox"><title>GroupBox Class</title>
<indexterm><primary>GroupBox class</primary></indexterm>
<para>
  The Windows Group Box control is actually a button control, not a static
  control.  Its purpose is to group together a set of related controls.  It
  consists of a label and a rectangle.  The related controls are placed within
  the rectangle. Group boxes have no state, they can not be selected, and an
  application can not send messages to the control. In addition, a group box
  does not send notifications to its parent so there are no events to connect ot
  a group box.
</para>
<para>
  The GroupBox class provides methods to work with group box controls. It
  inherits all methods of:
</para>
<itemizedlist>
<listitem><para>The DialogControl class (see
<link linkend="clsDialogControl">DialogControl Class</link>)
</para></listitem>
</itemizedlist>
<para>The GroupBox class requires the class definition file
<computeroutput>oodwin32.cls</computeroutput>:</para>
<programlisting>
<![CDATA[
::requires "oodwin32.cls"
]]>
</programlisting>
<para>Use the GetGroupBox method (see
<link linkend="getgroupbox">GetCheckControl</link>)
to retrieve an object of the GroupBox class.</para>

<section id="mthGBStyleEquals"><title>Style=</title>
<indexterm><primary>Style=</primary>
<secondary>GroupBox class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aControl~style=-"--+-LEFT-----+--"-------------------><
                      +-RIGHT----+

]]>
</programlisting>

<para>
  Assigns a new text alignment to the group box.  By default the text of a group
  box is in the upper left corner.  The alignment can also be set to the right,
  although this is not commonly done.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>new_style</term>
<listitem><para>A text string that is either:
<variablelist>
<varlistentry><term>LEFT</term>
<listitem><para>The group box label is aligned to the upper left.
</para></listitem></varlistentry>
<varlistentry><term>RIGHT</term>
<listitem><para>The label is aligned to the upper right.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
<![CDATA[
gb = dlg~getGroupBox(IDC_GB_AREACODES)
if gb == .Nil then return
gb~style="RIGHT"
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="anibut"><title>AnimatedButton Class</title>
<indexterm><primary>AnimatedButton class</primary></indexterm>
<para>The AnimatedButton class provides the methods to
implement an animated button within a dialog. The attributes and methods are
only described briefly in this document. An example program,
<computeroutput>oowalker.rex</computeroutput>,
is provided with the OODialog sample programs. </para>
<variablelist>
<varlistentry><term>ParentDlg</term>
<listitem><para>Attribute holding the handle of the parent dialog
</para></listitem></varlistentry>
<varlistentry><term>Stopped</term>
<listitem><para>Animation ends when set to 1 (see Stop method)
</para></listitem></varlistentry>
<varlistentry><term>Init</term>
<listitem><para>Initialize the animation parameters:</para>
<programlisting>
<![CDATA[
but = .AnimatedButton~new(buttonid,from,to, ,
                          movex,movey,sizex,sizey,delay, ,
                          startx,starty,parentdialog)
]]>
</programlisting>
<para>The values are
stored in a stem variable: </para>
<variablelist>
<varlistentry><term>sprite.buttonid</term>
<listitem><para>ID of animation button
</para></listitem></varlistentry>
<varlistentry><term>sprite.from</term>
<listitem><para>Array of in-memory bitmap handles, or a bitmap resource ID in a DLL,
or the name of an array in the .local directory containing handles to bitmaps
loaded with <link linkend="h000667">LoadBitmap</link>.
The array has to start with 1 and continue in increments by 1.
</para></listitem></varlistentry>
<varlistentry><term>sprite.to</term>
<listitem><para>0 if sprite.from is an array, or the name of
an array stored in <computeroutput>.local</computeroutput>,
or a bitmap resource ID in a DLL
</para></listitem></varlistentry>
<varlistentry><term>sprite.movex</term>
<listitem><para>Size of one move horizontally (pixels)
</para></listitem></varlistentry>
<varlistentry><term>sprite.movey</term>
<listitem><para>Size of one move vertically
</para></listitem></varlistentry>
<varlistentry><term>sprite.sizex</term>
<listitem><para>Horizontal size of all bitmaps (pixels)
</para></listitem></varlistentry>
<varlistentry><term>sprite.sizey</term>
<listitem><para>Vertical size of all bitmaps
</para></listitem></varlistentry>
<varlistentry><term>sprite.delay</term>
<listitem><para>Time delay between moves (ms)
</para></listitem></varlistentry>
</variablelist>
<para>Startx and starty
are the initial bitmap position, and parentdialog
is stored in the ParentDlg attribute.</para>
<para>Two more
values are initialized in the stem variable: </para>
<variablelist>
<varlistentry><term>sprite.smooth</term>
<listitem><para>Set to 1 for smooth edge change (can be changed to 0 for
a bouncy edge change)
</para></listitem></varlistentry>
<varlistentry><term>sprite.step</term>
<listitem><para>Set to 1 as the step size between sprite.from
and sprite.to for bitmaps in a DLL
</para></listitem></varlistentry>
</variablelist>
</listitem></varlistentry>
<varlistentry><term>SetSprite</term>
<listitem><para>Set all the sprite. animation values using a stem:
<programlisting>
<![CDATA[
mysprite.from = .array~of(bmp1,bmp2,...)
mysprite.to = 0
mysprite.movex = ...
...
self~setSprite(mysprite.)
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>GetSprite</term>
<listitem><para>Retrieve the animation values into a stem:
<programlisting>
<![CDATA[
self~getSprite(mysprite.)
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>SetFromTo</term>
<listitem><para>Set bitmap information (sprite.from and sprite.to):
<programlisting>
<![CDATA[
self~setFromTo(bmpfrom,bmpto)
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>SetMove</term>
<listitem><para>Set size of one move (sprite.movex and sprite.movey):
<programlisting>
<![CDATA[
self~setMove(movex,movey)
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>SetDelay</term>
<listitem><para>Set delay between moves in milliseconds (sprite.delay):
<programlisting>
<![CDATA[
self~setDelay(delay)
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>SetSmooth</term>
<listitem><para>Set smooth (1) or bouncy (0) edges (sprite.smooth):
<programlisting>
<![CDATA[
self~setSmooth(smooth)  /* 1 or 0 */
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>SetStep</term>
<listitem><para>Set the step size (sprite.step) between sprite.from and
sprite.to for bitmaps in a DLL, for example, if bitmap resources are numbered
202, 204, 206, etc:
<programlisting>
<![CDATA[
self~setFromTo(202,210)
self~setStep(2)
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>Run</term>
<listitem><para>Run the animation by going through all the bitmaps repetitively
until dialog is stopped; invokes MoveSeq:
<programlisting>
<![CDATA[
self~run
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>MoveSeq</term>
<listitem><para>Animate one sequence through all the bitmaps in the given move
steps; invokes MovePos:
<programlisting>
<![CDATA[
self~moveSeq
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>MovePos</term>
<listitem><para>Move the bitmaps by the arguments:
<programlisting>
<![CDATA[
self~movePos(movex,movey)
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>MoveTo</term>
<listitem><para>Move the bitmaps in the predefined steps to
the given position; invokes MoveSeq:
<programlisting>
<![CDATA[
self~moveTo(posx,posy)
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>SetPos</term>
<listitem><para>Set the new starting position of the bitmaps:
<programlisting>
<![CDATA[
self~setPos(newx,newy)
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>GetPos</term>
<listitem><para>Retrieve the current position into a stem:
<programlisting>
<![CDATA[
self~getPos(pos.)
say "pos=" pos.x pos.y
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>ParentStopped</term>
<listitem><para>Check the parent dialog window and return its finished attribute (1
means finished)
</para></listitem></varlistentry>
<varlistentry><term>Stop</term>
<listitem><para>Stop animation by setting the stopped attribute to 1
</para></listitem></varlistentry>
<varlistentry><term>HitRight</term>
<listitem><para>Invoked by run when the bitmap hits the right edge (returns 1 and bitmap
starts at left again; you can return 0 and set the new position yourself)
</para></listitem></varlistentry>
<varlistentry><term>HitLeft</term>
<listitem><para>Invoked when the bitmap hits the left edge (default action is to start
at right again)
</para></listitem></varlistentry>
<varlistentry><term>HitBottom</term>
<listitem><para>Invoked when the bitmap hits the bottom edge (default action is to start
at top again)
</para></listitem></varlistentry>
<varlistentry><term>HitTop</term>
<listitem><para>Invoked when the bitmap hits the top edge (default action is to start
at bottom again)
</para></listitem></varlistentry>
</variablelist>
<para>To use an animated button a dialog has to: </para>
<itemizedlist>
<listitem><para>Define a button in a resource file (owner-drawn)</para></listitem>
<listitem><para>Load the bitmaps of the animation into memory using an array</para></listitem>
<listitem><para>Initialize the animated button with the animation parameters</para></listitem>
<listitem><para>Invoke the run method of the animated button</para></listitem>
<listitem><para>Stop the animation and remove the bitmaps from memory</para></listitem>
</itemizedlist>
<para>The dialog may also dynamically change the parameters (for example, the
size of a move, or the speed) and override actions, such as hitting an edge.</para>
<para>See the <computeroutput>oowalker.rex</computeroutput> and
<computeroutput>oowalk2.rex</computeroutput> examples in
<computeroutput>OODIALOG\SAMPLES</computeroutput>.</para>
<para>For further information see
<link linkend="h001393">ConnectAnimatedButton</link>.</para>
</section>

</chapter>
