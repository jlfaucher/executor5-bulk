<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog Reference SGML file.
    #
    # Copyright (c) 2005-2011, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<chapter id="chpBaseObjects"><title>Base and Mixin Classes</title>
<indexterm><primary>Base classes</primary></indexterm>
<indexterm><primary>Base Mixin classes</primary></indexterm>
<para>
   ooDialog programs primarily deal with dialog and dialog control objects. The top-level objects in the programs, say
   a <link linkend="clsUserDialog">user dialog</link> or a <link linkend="clsButton">button control</link> are
   actually composed of a number of base objects and / or mixin classes. All dialog and dialog control objects contain
   the methods of their component base classes.
</para>
<para>
  To make it easier to understand the methods and attributes that all dialogs have in common, this documentation treats
  <link linkend="chpDialogObject">the dialog object</link> as a whole.  The dialog object chapter shows all the methods
  and attributes that every dialog has, without making much distinction as to what specific mixin or base class the
  method belongs to. The <link linkend="chpDialogControlObject">dialog control object</link>, is treated in a similar fashion
  it its chapter.
</para>
<para>
  This chapter describes the base and mixin classes that make up the dialog object and the dialog control object and
  shows how they fit together. In addition, it contains the detailed information for the mixin classes inherited by both
  the dialog and dialog control object. The <link linkend="chpDialogObject">dialog object</link> and the <link
  linkend="chpDialogControlObject">dialog control object</link> chapters link back to this chapter for the detailed
  information where needed.
</para>

<section id="sctComponentClassesDiagram"><title>Component Classes Diagram</title>
<para>
  The diagram shown here shows the relation between the dialog and the dialog control objects and their respective
  component classes. The abstract classes are shown in red. The mixin classes in green.  And the concrete subclasses in
  blue.
</para>

<figure id="figComponentClassesDiagram"><title>Components</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="dialog_dialogControl_objects_classDiagram.jpg" scale="50">
</imageobject>
</mediaobject>
</figure>
</section>

<section id="clsPlainBaseDialog"><title>PlainBaseDialog</title>
<indexterm><primary>PlainBaseDialog Class</primary></indexterm>
<para>
  PlainBaseDialog is the base class of all dialog classes in the ooDialog framework.  It implements methods that are
  common to every dialog.  PlainBaseDialog is an abstract class. A programmer can not instantiate a new PlainBaseDialog
  object and display a dialog on the screen. Rather, the ooDialog programmer subclasses one of the concrete classes
  provided by the ooDialog framework, such as the <link linkend="clsResDialog">ResDialog</link>, the <link
  linkend="clsRcDialog">RcDialog</link>, or the <link linkend="clsUserDialog">UserDialog</link>, to create and
  execute a real dialog.
</para>
<para>
  Many of the methods of the PlainBaseDialog are actually implemented in one of the mixin classes inherited by the
  PlainBaseDialog. See this <link linkend="figComponentClassesDiagram">diagram</link> to visualize the inheritance. In
  essence the PlainBaseDialog is the <link linkend="chpDialogObject">dialog object</link>. All the methods and
  attributes of the PlainBaseDialog are listed in the dialog object chapter. This includes the methods and attributes of
  its inherited mixin classes.
</para>
<para>
  The PlainBaseDialog inherits the following mixin classes:
  <itemizedlist>
  <listitem><para><link linkend="clsWindowBase">WindowBase</link></para></listitem>
  <listitem><para><link linkend="clsWindowExtensions">WindowExtensions</link></para></listitem>
  <listitem><para><link linkend="clsDialogExtensions">DialogExtensions</link></para></listitem>
  <listitem><para><link linkend="clsEventNotification">EventNotification</link></para></listitem>
  <listitem><para><link linkend="clsResourceutils">ResourceUtils</link></para></listitem>
  </itemizedlist>
</para>
</section>

<section id="clsDialogControl"><title>DialogControl</title>
<indexterm><primary>DialogControl Class</primary></indexterm>
<para>
  In a similar manner to <link linkend="clsPlainBaseDialog">PlainBaseDialog</link> and dialogs, <emphasis
  role="italic">DialogControl</emphasis> is the base class of all dialog control classes in the ooDialog framework.  It
  implements methods that are common to every dialog control. DialogControl is also an abstract class. A programmer can
  not instantiate a new DialogControl object. Rather, one of the concrete dialog control classes such as, the <link
  linkend="clsDateTimePicker">DateTimePicker</link> or the <link linkend="clsListView">ListView</link>, are used.
</para>
<para>
  See this <link linkend="figComponentClassesDiagram">diagram</link> to visualize the mixin classes that the
  DialogControl inherits. In essence the DialogControl is the <link linkend="chpDialogControlObject">dialog control
  object</link>. All the methods and attributes of the DialogControl are listed and documented in the dialog control
  object chapter. This includes the methods and attributes of its inherited mixin classes.
</para>
<para>
  The DialogControl inherits the following mixin classes:
  <itemizedlist>
  <listitem><para><link linkend="clsWindowBase">WindowBase</link></para></listitem>
  <listitem><para><link linkend="clsWindowExtensions">WindowExtensions</link></para></listitem>
  </itemizedlist>
</para>
</section>

<!-- <section id="clsWindowBase"><title>WindowBase Mixin Class</title> START -->
&windowBase;
<!-- <section id="clsWindowBase"><title>WindowBase Mixin Class</title> END   -->

<!-- <section id="clsWindowExtensions"><title>WindowExtensions Mixin Class</title> START -->
&windowExtensions;
<!-- <section id="clsWindowExtensions"><title>WindowExtensions Mixin Class</title> END   -->

<section id="clsDialogExtensions"><title>DialogExtensions Mixin Class</title>
<indexterm><primary>DialogExtensions Class</primary></indexterm>
<para>
  x
</para>
</section>

<section id="clsEventNotification"><title>EventNotification Mixin Class</title>
<indexterm><primary>EventNotification class</primary></indexterm>
<para>
  The event notification class is a <emphasis role="italic">Mixin</emphasis> class that contains methods that connect
  the notification of a Windows <link linkend="ovvEvents">event</link> sent to the <link
  linkend="ovvUnderlying">underlying</link> dialog with a method in the Rexx dialog object. Except as noted below, the
  Rexx programmer adds the method to her dialog subclass. Once the event notification is connected, each time the event
  occurs, the connected method is invoked. The programmer codes the method to take the appropriate action for the event.
</para>
<para>
  In the Windows user interface, as the user interacts with the system, events are generated that specify what the
  action of the user was. Mouse clicks, keyboard presses, moving or sizing windows, all generate events.
</para>
<para>
  Some simple examples of how this works:
<itemizedlist>
<listitem>
<para>
  Push buttons notify their parent dialog of a number of events. The programmer connects one of these events to a method
  in his Rexx dialog. Typically the CLICKED event is connected. Then, the connected method is called each time the
  button is pressed (clicked.)
</para>
</listitem>
<listitem>
<para>
  List boxes, multiple-select list boxes, and combo boxes can be connected to a method that is called each time a line
  in the list box or combo box is selected.
</para>
</listitem>
<listitem>
<para>
  For a scroll bar, the programmer can specify different methods that are called depending on the user action. The user
  can click on the arrow buttons, drag the thumb, or use the page down / page up keys. Each of these events can be
  connected to a method in the Rexx dialog.
</para>
</listitem></itemizedlist>
</para>
<para>
  Whenever a dialog object is instantiated, the ooDialog framework <link
  linkend="sctStandardEventMethods">automatically</link> makes several event connections. For all other events the Rexx
  programmer, usually, needs to specifically connect the event to his dialog, through one of the event notification
  methods, to be able to respond to the event. In a <link linkend="clsUserDialog">UserDialog</link>, some of the methods
  that create dialog controls have an option that automatically connects an event to a dialog method. But, for most
  events, say the resize or move events, the connection needs to be made explicitly.  Indeed, except for trivial
  dialogs, most of the programming is deciding which events to be notified of and taking action upon receiving the
  notification.
</para>
<para id="paraWhereToConnectEvents">
  In general, events should be connected before the dialog is shown on the screen, or immediately after the dialog is
  created. There is no reason why the programmer can not place the invocation where ever it makes the most sense.
  Connecting the events in the <link linkend="mthInitDialog">initDialog</link>() method is usually sufficient. In a
  <computeroutput>UserDialog</computeroutput>, the <link linkend="mthDefineDialog">defineDialog</link>() method also
  makes a good place for the connect event methods. If the programmer is overriding the <emphasis
  role="italic">init</emphasis>() method, the connect event methods can be placed there.  In this case, do not invoke
  the connect event method until <emphasis role="bold">after</emphasis> the <link
  linkend="mthNewDialogObject">superclass</link> has been initialized.
</para>

<section id="sctCodingEventHandlers"><title>Coding Event Handlers</title>
<indexterm><primary>coding event handlers</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>coding event handlers</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>coding event handlers</secondary></indexterm>

<para>
  The methods in a Rexx dialog object connected to Windows event notifications are commonly called event handlers
  because the method handles the event. In order to properly code an event handler, the Rexx programmer needs to
  understand somewhat the underlying mechanism of event notification. This is particularly important in ooDialog 4.2.0
  and later with its ability to <link linkend="ovvEventsDirectReply">directly</link> invoke the event handling method
  from the window <link linkend="ovvWindowMessages">message</link> processing loop.
</para>
<para>
  When the operating system sends an event notification to the underlying dialog, the operating system waits for a reply
  to the notification in the message processing loop. This is significant because while the operating system is
  waiting, in general, other messages can not be processed by the window. If an application does not reply in a timely
  manner to the notification messages, it can cause the application to appear hung. With today's fast processors there
  are plenty of CPU cycles for an event handler to process and reply to event notifications. But, if an application were
  to do something like sleep for 10 seconds in an event handler, the user would think the application was hung.
</para>
<para>
  Prior to ooDialog 4.2.0, the ooDialog framework could not directly invoke the event handling method in the Rexx dialog
  object. To invoke the method, the framework used a cumbersome process involving queues and interpret. In the message
  processing loop, the framework essentially queued up the method to be invoked <emphasis role="italic">at some later
  time</emphasis> and replied immediately to the notification. Because of this, the event handling method could not
  reply to the event notification, and in fact any return was simply lost. This meant much of the capability of a
  Windows dialog was unavailable. It also meant it did not matter if the method returned in a timely manner.
</para>
<para>
  With ooDialog 4.2.0 and later, the event handling method in the Rexx dialog object is invoked by the interpreter
  directly from the message processing loop in the underlying Windows dialog. This allows the Rexx programmer
  to <link linkend="exampleEventHandler1">return</link> a value to the notification, to <link
  linkend="exampleEventHandler1">synchronize</link> the handling of notifications, or to <link
  linkend="exampleEventHandler3">veto</link> an event. Remember, with this direct invocation of the event handling
  methods, the interpreter is waiting in the message processing loop for the return from the method. Therefore, the
  programmer needs to return from the method in a reasonable amount of time. Do not be overly worried about this, the
  interpreter processes a large number of statements in a very short time. There is adequate time to process and return
  a value in the event handler.
</para>
<para>
  However, having the interpreter waiting for the return of an event handling method could conceivably be a problem for
  some few existing programs. Since, in older ooDialog versions, the return from an event handler method was
  meaningless, some programmers may not have returned from the method in a timely manner, and never realized this was a
  mistake. In addition, there are a large number of event notifications in Windows where the operating system ignores
  the reply. Therefore, the ooDialog framework uses two different ways to invoke the event handling method. The first,
  preferred, method is for the interpreter to invoke the method directly, wait for the return, and then use the return
  to reply to the Windows event notification. The second is to invoke the event handling method using the <emphasis
  role="italic">startWith</emphasis>() method of the <computeroutput>Object</computeroutput> class. This starts the
  event handling method concurrently, and the ooDialog framework replies to the Windows event notification immediately.
</para>
<para>
  In general, whether the ooDialog framework invokes the event handling method and waits for the return, or uses
  <emphasis role="italic">startWith</emphasis>() and replies to the Windows event notification immediately is determined
  using these rules:
</para>
<orderedlist>
<listitem>
<para>
  Event connections made using the event connection methods that existed prior to ooDialog 4.2.0, using the existing
  event keywords, and existing arguments, use <emphasis role="italic">startWith</emphasis> to invoke the event handlers.
  The programmer can not change this. For the purpose of this discussion, these methods will be called existing
  connection methods.
</para>
</listitem>
<listitem>
<para>
  All event connections made using event connection methods introduced after ooDialog 4.1.0 assume the programmer wants
  the event handler invoked directly and for the ooDialog framework to wait for the return. These methods will be called
  new connection methods. For instance, the <link linkend="clsDateTimePicker">date time</link> picker control did not
  exist in ooDialog 4.1.0, so its event connection method, <link
  linkend="mthConnectDateTimePickerEvent">connectDateTimePickerEvent</link> falls into this category.
</para>
</listitem>
<listitem>
<para>
  For new connection methods, when the reply to an event notification has a meaning for the notification, the framework
  always invokes the event handler directly and waits for the return. The programmer can not change this. If the
  programmer does not want to reply to the event, then he should simply not connect the event.
</para>
</listitem>
<listitem>
<para>
  All new connection methods have an optional argument that allows the programmer to specify whether she wants the
  framework to wait for the return, or use <emphasis role="italic">startWith</emphasis> and reply immediately. When the
  reply to an event is ignored by the operating system, the optional argument will be used to direct the framework to
  invoke the event handler directly or use <emphasis role="italic">startWith</emphasis>. By default, the framework
  invokes the connected method directly.
</para>
</listitem>
<listitem>
<para>
  Over time, the existing connections will be enhanced to also take a fourth optional argument. This will allow the
  programmer to specify that the framework invoke the event handler directly and wait for the return. This enhancement
  has started, but is far from complete.
</para>
</listitem>
<listitem>
<para>
  The documentation for each event connection method, for each event, will specify how the event handler will be
  invoked.
</para>
</listitem>
</orderedlist>

<para>
  The following code snippets and examples expand on these details.
</para>
<para>
  Best practice would be to always code event handlers as if they are expected to return a value to the operating
  system's event notification message. The considerations would be that the method does not block and that a value is
  returned to the operating system in a reasonable amount of time. In general, the event handler should be unguarded to
  preclude the possibility that some guarded method in the dialog object is executing at the time the event notification
  is generated.
</para>
<para>
  Below is a code snippet for an application that displays the current date and time, with a push button that refreshes
  the display. Note these points about the code snippet. Since the <emphasis role="italic">connectButtonEvent</emphasis>
  method is the replacement for the <link linkend="ovvDeprecated">deprecated</link> <emphasis
  role="italic">connectButtonNotify</emphasis> it is in essence an existing connection method, using the original
  arguments. Therefore, the method is invoked from the message processing loop using <emphasis
  role="italic">startWith</emphasis>. Because of this, technically, it does not have to be unguarded and does not have
  to return a value. Nevertheless, it is the <emphasis role="italic">correct</emphasis> way to code the event handler.
<programlisting>
<![CDATA[
::method initDialog
  ...
  self~connectButtonEvent(IDC_PB_REFRESH, "CLICKED", updateTime)
  ...

::method updateTime unguarded
  use arg info, hwnd

  now = .DateTime~new
  self~refreshDisplay(now)
  return 0

]]>
</programlisting>

</para>
<para>
  Consider this snippet from a similar program, but where the push button starts a process that calculates the grains of
  sand in the universe. Since it is not expected that the calculation will finish in a reasonable amount of time, an
  early reply is used to return a value in a timely manner. The handler also disables the push button so tha the user
  can not start a second calculation until the first calculation finishes.
<programlisting>
<![CDATA[
::method initDialog
  ...
  self~connectButtonEvent(IDC_PB_CALC_SAND, "CLICKED", onCalculateGrains)
  ...

::method onCalculateGrains unguarded
  use arg info, hwnd

  self~newPushButton(IDC_PB_CALC_SAND)~disable
  reply 0

  number = self~calculateSandInUniverse
  self~refreshDisplay(number)
  self~newPushButton(IDC_PB_CALC_SAND)~enable
  return

]]>
</programlisting>

</para>
<para>
  The following examples are all for events where the event handler must return a value.
</para>
<variablelist>
  <varlistentry id="exampleEventHandler1"><term><emphasis role="bold">Returning Values</emphasis></term>
  <listitem>
  <para>
    The <link linkend="clsMonthCalendar">month calendar</link> control has the <link
    linkend="evtMonthCalendarGETDAYSTATE">GETDAYSTATE</link> event that is sent to request information on how certain
    days are to be shown. The programmer can customize the calendar by returning a set of days that should be displayed
    in bold. For instance, in a business application paid holidays could be displayed in bold.
  </para>
  <para>
    Since the <emphasis role="italic">connectMonthCalendarEvent</emphasis> method did not exist in ooDialog 4.1.0 and
    the return value for this event is meaningful, the second and third rules above apply.  That is, the interpreter
    invokes the event handler directly, waits for the reply, and the programmer can not change this behavior.
  </para>

<programlisting>
<![CDATA[

::method initDialog
  expose calendar

  calendar = self~newMonthCalendar(IDC_MC_HOLIDAYS)

  -- Connect the GETDAYSTATE event.
  self~connectMonthCalendarEvent(IDC_MC_HOLIDAYS, "GETDAYSTATE", onGetDayState)

  -- Restrict the calendar so that it only displays the year 2011.
  start = .DateTime~fromStandardDate("20110101")
  end = .DateTime~fromStandardDate("20111231")

  ...

::method onGetDayState unguarded
  expose calendar
  use arg startDate, count

  -- Create the array to hold the .DayState objects.
  dayStates = .array~new(count)

  month = startDate~month
  if month == 12 then month = 0

  do i = 1 to count
    j = month + i - 1

    select
      when j ==  1 then dayStates[i] = .DayState~new(17)
      when j ==  2 then dayStates[i] = .DayState~new(21)
      when j ==  3 then dayStates[i] = .DayState~new
      when j ==  4 then dayStates[i] = .DayState~new
      when j ==  5 then dayStates[i] = .DayState~new(30)
      when j ==  6 then dayStates[i] = .DayState~new
      when j ==  7 then dayStates[i] = .DayState~new(4)
      when j ==  8 then dayStates[i] = .DayState~new
      when j ==  9 then dayStates[i] = .DayState~new(5)
      when j == 10 then dayStates[i] = .DayState~new
      when j == 11 then dayStates[i] = .DayState~new(24, 25)
      when j == 12 then dayStates[i] = .DayState~new(23, 30)
      otherwise dayStates[i] = .DayState~new()
    end
  end

  buffer = .DayStates~makeDayStateBuffer(dayStates)
  return buffer

]]>
</programlisting>
  </listitem></varlistentry>
  <varlistentry id="exampleEventHandler2"><term><emphasis role="bold">Event Synchronization</emphasis></term>
  <listitem>
  <para>
    The <link linkend="clsDateTimePicker">DTP</link> (date time picker) control has the <link
    linkend="mthConnectDateTimePickerEvent">DROPDOWN</link> event notification that is sent when the drop down calendar
    is shown. This gives the programmer a chance to customize the month calendar that is shown. Since the month calendar
    is not shown until the event handling method returns, replying directly to the notification allows the programmer to
    completely finish the customizations before the month calendar appears on the screen.
  </para>

<programlisting>
<![CDATA[

::method initDialog

  self~connectDateTimePickerEvent(IDC_DTP, "DROPDOWN", onDropDown)
  ...


::method onDropDown unguarded
  use arg idFrom, hwndFrom

  dt = self~newDateTimePicker(IDC_DTP);
  monthCal = dt~getMonthCal
  monthCal~setFirstDayOfWeek(3)
  monthCal~addStyle("NOTODAY")

  return 0

]]>
</programlisting>
  <para>
    In the above example, the <emphasis role="italic">connectDateTimePickerEvent</emphasis> method did not exist in
    ooDialog 4.1.0, but the return value for this event is ignored by the OS. Therefore, the second and fourth rules
    above apply. That is, by default the interpreter invokes the event handler directly and waits for a reply. However
    the programmer can change this behavior if he wants. If there is no reason to have the interpreter wait until the
    event handler finishes, then the programmer could use the fourth optional argument. The
    <computeroutput>.false</computeroutput> value tells the ooDialog framework to use the <emphasis
    role="italic">startWith</emphasis> method to invoke the event handler.
  </para>

<programlisting>
<![CDATA[

::method initDialog

  self~connectDateTimePickerEvent(IDC_DTP, "DROPDOWN", onDropDown, .false)
  ...


::method onDropDown unguarded
  expose userDidSeeCalendar
  use arg idFrom, hwndFrom

  userDidSeeCalendar = .true

]]>
</programlisting>
  </listitem></varlistentry>
  <varlistentry id="exampleEventHandler3"><term><emphasis role="bold">Veto Events</emphasis></term>
  <listitem>
  <para>
    The <link linkend="clsTab">tab</link> control has the <link linkend="mthConnectTabEvent">SELCHANGING</link> event.
    It is sent when the user selects a different tab, and is sent <emphasis role="bold">before</emphasis> the selected
    tab is changed. The programmer can <emphasis role="italic">veto</emphasis> the change to a new tab by returning
    <computeroutput>.false</computeroutput> to the event notification, or allow the change by returning
    <computeroutput>.true</computeroutput>. One reason for preventing the change might be that the user had entered
    invalid data in the current tab page.
  </para>
  <para>
    <emphasis role="bold">Note:</emphasis> Since the <emphasis role="italic">connectTabEvent</emphasis> method is the
    replacement for the <emphasis role="italic">ovvDeprecated</emphasis> <emphasis
    role="italic">connectTabNotify</emphasis> method, it essentially is a method that existed in ooDialog 4.1.0. The
    above rules one and five apply. That is, when the same arguments are used as existed in 4.1.0, the event handler is
    invoked using <emphasis role="italic">startWith</emphasis> and the interpreter does not wait for a return value.
    With this behavior, it is impossible for the programmer to veto the change to a new tab. Therefore the programmer
    has to use the fourth optional argument to change the default behavior. Specifying
    <computeroutput>.true</computeroutput> causes the ooDialog framework to invoke the <emphasis
    role="italic">onTabChanging</emphasis> method directly and wait for the return value.
  </para>
<programlisting>
<![CDATA[

::method defineDialog

  self~connectTabEvent(IDC_TAB, SELCHANGING, onTabChanging, .true)

::method onTabChanging unguarded
  expose tabContent
  use arg idFrom, hwndFrom

  index = self~newTab(idFrom)~selectedIndex + 1
  dlg = tabContent[index]

  if dlg~validate then return .true
  else return .false

]]>
</programlisting>
  <para>
    In the above example, since the <emphasis role="italic">validate</emphasis> method is returning
    <computeroutput>.true</computeroutput> or <computeroutput>.false</computeroutput> the event handler could have been
    coded this way:
  </para>
<programlisting>
<![CDATA[
::method onTabChanging unguarded

  ...

  return dlg~validate
]]>
</programlisting>
  <para>
    The example used:
<programlisting>
<![CDATA[
  if dlg~validate then return .true
  else return .false
]]>
</programlisting>
    to emphasize that the event handler needs to return <computeroutput>.true</computeroutput> or
    <computeroutput>.false</computeroutput>.
  </para>
  </listitem></varlistentry>
  <varlistentry id="exampleEventHandler4"><term><emphasis role="bold">Lengthy Processing</emphasis></term>
  <listitem>
  <para>
    As previously noted, the Rexx programmer does not need to be overly worried about taking to much time to return a
    value from an event handler. In most very case there is plenty of time to process the event and return a value.
    However, sometimes the programmer may want to, or need to, do some lengthy processing in the event handler. For
    these cases, the programmer needs to figure out how to return a value from the event handler and also do the needed
    processing. This is really a <emphasis role="italic">concurrency</emphasis> problem, not an event handling problem.
  </para>
  <para>
    The two common ways to solve this problem would be to use an <emphasis role="italic">early reply</emphasis> or to
    start a <emphasis role="italic">second activity</emphasis> running to do the processing. Using the <link
    linkend="exampleEventHandler3">onTabChanging</link> event handler above, here are two typical ways to handle the
    event when some lengthy processing is involved. As a hypothetical, say that when the user changes to a new tab, the
    program needs to gather up all the data on the validated page and write it to disk, or send it somewhere. One
    approach would be to validate the page, do an early reply, and then finish up the processing:
  </para>
<programlisting>
<![CDATA[

::method defineDialog

  self~connectTabEvent(IDC_TAB, SELCHANGING, onTabChanging, .true)

::method onTabChanging unguarded
  expose tabContent
  use arg idFrom, hwndFrom

  index = self~newTab(idFrom)~selectedIndex + 1
  dlg = tabContent[index]

  if \ dlg~validate then return .false  -- Tab will not be changed

  reply .true  -- Tab is changed for the user.

  -- Now gather up the data entered on the page we just switched from.
  data = dlg~getUserDataDirectory
  self~writeDataToFile(data)

]]>
</programlisting>
  <para>
    Another approach could be to start a new activity which will run concurrently. It might be coded this way:
  </para>
<programlisting>
<![CDATA[
::method onTabChanging unguarded
  expose tabContent
  use arg idFrom, hwndFrom

  index = self~newTab(idFrom)~selectedIndex + 1
  dlg = tabContent[index]

  if dlg~validate then do
    dp = .DataProcesser~new
    dp~start("processDlgData", dlg)
    return .true
  end
  else do
    return .false
  end
]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="sctMethodsEventNotification"><title>Method Table</title>
<para>
  The following table list the methods of the <computeroutput>EventNotification</computeroutput> class:
</para>
<table id="tblEventNotificationMethods" frame="all">
<title>EventNotification Methods</title>
<tgroup cols="2">
<colspec colwidth="1.5in">
<thead>
<row>
<entry>Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry><link linkend="enAddUserMsg">addUserMsg</link></entry>
<entry>Connects an operating system window message with a method in the Rexx dialog object.</entry>
</row>
<row>
<entry><link linkend="enConnectButtonEvent">connectButtonEvent</link></entry>
<entry>Connect an event notification from a button control to a method in the Rexx Dialog</entry>
</row>
<row>
<entry><link linkend="enConnectComboBoxEvent">connectComboBoxEvent</link></entry>
<entry>Connects an event notification from a combo box to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectCommandEvents">connectCommandEvents</link></entry>
<entry>Connects a command event notification from a dialog control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectDateTimePickerEvent">connectDateTimePickerEvent</link></entry>
<entry>Connects an event notification form a date time picker to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectDraw">connectDraw</link></entry>
<entry>Connects the draw item event notification to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectEachSBEvent">connectEachSBEvent</link></entry>
<entry>Connects each specified event notification from a scroll bar to a separate method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectEditEvent">connectEditEvent</link></entry>
<entry>Connects an event notification from an edit control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectHelp">connectHelp</link></entry>
<entry>Connects the Windows Help event to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectListBoxEvent">connectListBoxEvent</link></entry>
<entry>Connects an event notification from a list box control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectListViewEvent">connectListViewEvent</link></entry>
<entry>Connects an event notification from a list-view control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectMonthCalendarEvent">connectMonthCalendarEvent</link></entry>
<entry>Connects an event notification from a month calendar to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectMove">connectMove</link></entry>
<entry>Connects the move event notification to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectMouseCapture">connectMouseCapture</link></entry>
<entry>Connects the losing the mouse capture event notification to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectNotifyEvent">connectNotifyEvent</link></entry>
<entry>Connects a generic event notification from a dialog control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectPosChanged">connectPosChanged</link></entry>
<entry>Connects the position has changed event notification to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectResize">connectResize</link></entry>
<entry>Connects the size event notification to a method in the Rexx dialog</entry>
</row>
<row>
<entry><link linkend="enConnectResizing">connectResizing</link></entry>
<entry>Connects the sizing event notification to a method in the Rexx dialog</entry>
</row>
<row>
<entry><link linkend="enConnectScrollBarEvent">connectScrollBarEvent</link></entry>
<entry>Connects an event notification from a scroll bar control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectSizeMoveEnded">connectSizeMoveEnded</link></entry>
<entry>Connects the size / move ended event notification to a method in the Rexx dialog object.</entry>
</row>
<row>
<entry><link linkend="enConnectStaticEvent">connectStaticEvent</link></entry>
<entry>Connects an event notification from a static control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectTabEvent">connectTabEvent</link></entry>
<entry>Connects an event notification from a tab control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectTrackBarEvent">connectTrackBarEvent</link></entry>
<entry>Connects an event notification from a track bar control to a method in the Rexx dialog. </entry>
</row>
<row>
<entry><link linkend="enConnectTreeViewEvent">connectTreeViewEvent</link></entry>
<entry>Connects an event notification from a tree view control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enConnectUpDownEvent">connectUpDownEvent</link></entry>
<entry>Connects an event notification from an UpDown control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><link linkend="enDefListDragHandler">defListDragHandler</link></entry>
<entry>Default implementation of a drag and drop handler for a list-view control.</entry>
</row>
<row>
<entry><link linkend="enDefTreeDragHandler">defTreeDragHandler</link></entry>
<entry>Default implementation of a drag and drop handler for a tree view control.</entry>
</row>
</tbody></tgroup>
</table>
</section>


<section id="enConnectHelp"><title>connectHelp</title>
<programlisting>
<link linkend="mthConnectHelp">connectHelp</link>

<![CDATA[
>>--connectHelp(--methodname--)------------------><
]]>
</programlisting>
</section>

<section id="enConnectResize"><title>connectResize</title>
<programlisting>
<link linkend="mthConnectResize">connectResize</link>

<![CDATA[
>>--connectResize(--methodName--)----------------><
]]>
</programlisting>
</section>

<section id="enConnectResizing"><title>connectResizing</title>
<programlisting>
<link linkend="mthConnectResizing">connectResizing</link>

<![CDATA[
>>--connectResizing(--methodName--)--------------><
]]>
</programlisting>
</section>

<section id="enConnectSizeMoveEnded"><title>connectSizeMoveEnded</title>
<programlisting>
<link linkend="mthConnectSizeMoveEnded">connectSizeMoveEnded</link>

<![CDATA[
>>--connectSizeMoveEnded(--methodName--+--------------+--)---------------------><
                                       +-,-willReply--+

]]>
</programlisting>
</section>

<section id="enConnectMove"><title>connectMove</title>
<programlisting>
<link linkend="mthConnectMove">connectMove</link>

<![CDATA[
>>--connectMove(--methodName--)------------------><
]]>
</programlisting>
</section>

<section id="enConnectPosChanged"><title>connectPosChanged</title>
<programlisting>
<link linkend="mthConnectPosChanged">connectPosChanged</link>

<![CDATA[
>>--connectPosChanged(--methodName--)------------><
]]>
</programlisting>
</section>

<section id="enConnectDraw"><title>connectDraw</title>
<programlisting>
<link linkend="mthConnectDraw">connectDraw</link>

<![CDATA[
>>--connectDraw--(--+-----+--+---------------+--)------------------------------><
                    +--id-+  +-,--methodName-+
]]>
</programlisting>
</section>

<section id="enConnectMouseCapture"><title>connectMouseCapture</title>
<programlisting>
<link linkend="mthConnectMouseCapture">connectMouseCapture</link>

<![CDATA[
>>--connectMouseCapture(--methodName--)----------><
]]>

</programlisting>
</section>

<section id="enConnectButtonEvent"><title>connectButtonEvent</title>
<programlisting>
<link linkend="mthConnectButtonEvent">connectButtonEvent</link>

<![CDATA[
>>--connectButtonEvent(--id--,--event--+---------------+--)--------------------><
                                       +-,--methodName=+
]]>
</programlisting>
</section>

<section id="enConnectCommandEvents"><title>connectCommandEvents</title>
<programlisting>
<link linkend="mthConnectCommandEvents">connectCommandEvents</link>

<![CDATA[
>>--connectCommandEvents(--id--,--methodName--)--><
]]>
</programlisting>
</section>

<section id="enConnectComboBoxEvent"><title>connectComboBoxEvent</title>
<programlisting>
<link linkend="mthConnectComboBoxEvent">connectComboBoxEvent</link>

<![CDATA[
>>--connectComboBoxEvent(--id--,--event--+---------------+--)------------------><
                                         +-,--methodName=+
]]>
</programlisting>
</section>

<section id="enConnectNotifyEvent"><title>connectNotifyEvent</title>
<programlisting>
<link linkend="mthConnectNotifyEvent">connectNotifyEvent</link>

<![CDATA[
>>--connectNotifyEvent(--id--,--event--+---------------+--)--------------------><
                                       +-,--methodName=+
]]>
</programlisting>
</section>

<section id="enConnectEditEvent"><title>connectEditEvent</title>
<programlisting>
<link linkend="mthConnectEditEvent">connectEditEvent</link>

<![CDATA[
>>--connectEditEvent(--id--,--event--+---------------+--)----------------------><
                                     +-,--methodName=+
]]>
</programlisting>
</section>

<section id="enConnectListBoxEvent"><title>connectListBoxEvent</title>
<programlisting>
<link linkend="mthConnectListBoxEvent">connectListBoxEvent</link>

<![CDATA[
>>--connectListBoxEvent(--id--,--event--+---------------+--)-------------------><
                                        +-,--methodName=+
]]>
</programlisting>
</section>

<section id="enConnectListViewEvent"><title>connectListViewEvent</title>
<programlisting>
<link linkend="mthConnectListViewEvent">connectListViewEvent</link>

<![CDATA[
>>--connectListviewEvent(--id--,--event--+---------------+--)------------------><
                                         +-,--methodName=+
]]>
</programlisting>
</section>

<section id="enConnectScrollBarEvent"><title>connectScrollBarEvent</title>
<programlisting>
<link linkend="mthConnectScrollBarEvent">connectScrollBarEvent</link>

<![CDATA[
>>--connectScrollBarEvent(--id--,--event--+---------------+--)-----------------><
                                          +-,--methodName=+
]]>
</programlisting>
</section>

<section id="enConnectEachSBEvent"><title>connectEachSBEvent</title>
<programlisting>
<link linkend="mthConnectEachSBEvent">connectEachSBEvent</link>

<![CDATA[
>>--connectEachSBEvent(-id-,-mthWhenUp-,-mthWhenDown-+---------------+-+-------+-+-------+-+-------+-->
                                                     +-,-mthWhenDrag-+ +-,-min-+ +-,-max-+ +-,-pos-+

>--+-----------+-+-----------+-+----------+-+--------------+-+-------------+-+-------------+-)--------><
   +-,-mthPgUp-+ +-,-mthPgDn-+ +-,-mthTop-+ +-,-progbuttom-+ +-,-progtrack-+ +-,-progendsc-+
]]>
</programlisting>
</section>

<section id="enConnectTrackBarEvent"><title>connectTrackBarEvent</title>
<programlisting>
<link linkend="mthConnectTrackBarEvent">connectTrackBarEvent</link>

<![CDATA[
>>--connectTrackBarEvent(--id--,--event--+---------------+--)------------------><
                                         +-,--methodName-+
]]>
</programlisting>
</section>

<section id="enConnectStaticEvent"><title>connectStaticEvent</title>
<programlisting>
<link linkend="mthConnectStaticEvent">connectStaticEvent</link>

<![CDATA[
>>--connectStaticNotify(--id--,--event--,-+---------------+--)-----------------><
                                          +-,--methodName-+
]]>
</programlisting>
</section>

<section id="enConnectTabEvent"><title>connectTabEvent</title>
<programlisting>
<link linkend="mthConnectTabEvent">connectTabEvent</link>

<![CDATA[
>>--connectTabEvent(--id--,--event--+---------------+--+--------------+--)-----><
                                    +-,--methodName-+  +-,-willReply--+
]]>
</programlisting>
</section>

<section id="enConnectTreeViewEvent"><title>connectTreeViewEvent</title>
<programlisting>
<link linkend="mthConnectTreeViewEvent">connectTreeViewEvent</link>

<![CDATA[
>>--connectTreeViewEvent(--id--,--event--+---------------+--)------------------><
                                         +-,--methodName-+
]]>
</programlisting>
</section>

<section id="enConnectDateTimePickerEvent"><title>connectDateTimePickerEvent</title>
<programlisting>
<link linkend="mthConnectDateTimePickerEvent">connectDateTimePickedEvent</link>

<![CDATA[
>>--connectDateTimePickerEvent(--id--,--event--+---------+--+-------------+-)--><
                                               +-,-mName-+  +-,-willReply-+
]]>
</programlisting>
</section>

<section id="enConnectMonthCalendarEvent"><title>connectMonthCalendarEvent</title>
<programlisting>
<link linkend="mthConnectMonthCalendarEvent">connectMonthCalendarEvent</link>

<![CDATA[
>>--connectMonthCalendarEvent(--id--,--event--+---------+--+-------------+-)---><
                                              +-,-mName-+  +-,-willReply-+
]]>
</programlisting>
</section>

<section id="enConnectUpDownEvent"><title>connectUpDownEvent</title>
<programlisting>
<link linkend="mthConnectUpDownEvent">connectUpDownEvent</link>

<![CDATA[
>>--connectUpDownEvent(--id--,--event--+--------------+--+-------------+-)-----><
                                       +-,-methodName-+  +-,-willReply-+
]]>
</programlisting>

</section>

<section id="enAddUserMsg"><title>addUserMsg</title>
<programlisting>
<link linkend="mthAddUserMsg">addUserMsg</link>

<![CDATA[
>>--addUserMsg(-methodName-,-winMsg-+------+-+----------+-+------+-+----------+-+------+-)-><
                                    +-,-f1-+ +-,-wParam-+ +-,-f2-+ +-,-lParam-+ +-,-f3-+

]]>
</programlisting>

</section>

<section id="enDefListDragHandler"><title>defListDragHandler</title>
<programlisting>

<link linkend="mthDefListDragHandler">defListDragHandler</link>

<![CDATA[
>>--defListDragHandler(--id--,--item--,--point--)------------------------------><

]]>
</programlisting>
</section>

<section id="enDefTreeDragHandler"><title>defTreeDragHandler</title>
<programlisting>
<link linkend="mthDefTreeDragHandler">defTreeDragHandler</link>

<![CDATA[
>>--defTreeDragHandler(--id--,--item--,--point--)------------------------------><

]]>
</programlisting>
</section>

</section>

<section id="clsResourceUtils"><title>ResourceUtils Mixin Class</title>
<indexterm><primary>ResourceUtils Class</primary></indexterm>
<para>
  The <computeroutput>ResourceUtils</computeroutput> class provides utility methods for dealing with resource <link
  linkend="defResourceID">IDs</link> and parsing resource <link linkend="defResourceScript">script</link> files. The
  class is inherited by the <link linkend="chpDialogObject">dialog</link> object and also by the <link
  linkend="chpMenus">menu</link> classes.
</para>
<para>
  Most of the methods of the <computeroutput>ResourceUtils</computeroutput> class are used <link
  linkend="ovvUndocumented">internally</link> and not documented. However, the most important member of the class is the
  <emphasis role="italic">constDir</emphasis>. The use of this attribute should be understood by the progammer and is
  documented in the <link linkend="chpDialogObject">dialog</link> object chapter.
</para>

<section id="ruConstDir"><title>constDir</title>
<programlisting>
<link linkend="atrConstDir">constDir</link>

<![CDATA[
>>--constDir-------------------------------------><

>>--constDir[symbol]-=-numericValue--------------><
]]>
</programlisting>
</section>

</section>

<section id="clsDynamicDialog"><title>DynamicDialog Mixin Class</title>
<indexterm><primary>DynamicDialog Class</primary></indexterm>
<para>
  The ooDialog framework allows the Rexx programmer to dynamically define a dialog <link
  linkend="ovvDialogTemplate">template</link> in her code. This functionality is implemented by the
  <computeroutput>DynamicDialog</computeroutput> class. This class is inherited by the <link
  linkend="clsUserDialog">UserDialog</link> and its methods are fully documented there.
</para>
<para>
  Historically the ooDialog documentation did not distinguish the difference between the
  <computeroutput>UserDialog</computeroutput> methods and the <computeroutput>DynamicDialog</computeroutput> methods.
  The documentation merely treated the <computeroutput>DynamicDialog</computeroutput> methods as methods of the
  <computeroutput>UserDialog</computeroutput>. The <computeroutput>DynamicDialog</computeroutput> methods are listed
  here as a reference with a link to the full documentation in the <computeroutput>UserDialog</computeroutput> chapter.
</para>

<section id="ddCreate"><title>create</title>
<programlisting>
<link linkend="mthCreate">create</link>

<![CDATA[
>>--create(--x--,--y--,--cx--,--cy--,--title-+-----------+--+------------+----->
                                             +-,-options-+  +-,-dlgClass-+

>----+------------+--+------------+--+------------+--)-------------------------><
     +-,-fontName-+  +-,-fontSize-+  +-,-expected-+
]]>
</programlisting>
</section>

<section id="ddCreateCenter"><title>createCenter</title>
<programlisting>
<link linkend="mthCreateCenter">createCenter</link>

<![CDATA[
>>--createCenter(--cx--,--cy--,--title-+-----------+--+------------+----------->
                                       +-,-options-+  +-,-dlgClass-+

>----+------------+--+------------+--+------------+--)-------------------------><
     +-,-fontName-+  +-,-fontSize-+  +-,-expected-+
]]>
</programlisting>
</section>

<section id="ddDefineDialog"><title>defineDialog</title>
<programlisting>
<link linkend="mthDefineDialog">defineDialog</link>

<![CDATA[
>>--defineDialog---------------------------------><
]]>
</programlisting>
</section>

</section>

</chapter>
