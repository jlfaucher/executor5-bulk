<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "oodialog.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog Reference XML file.
    #
    # Copyright (c) 2005-2022 Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<section id="clsEventNotification" xreflabel="EventNotification"><title>EventNotification Mixin Class</title>
<indexterm><primary>EventNotification class</primary></indexterm>
<para>
  The event notification class is a <emphasis role="italic">Mixin</emphasis> class that contains methods that connect
  the notification of a Windows <xref linkend="ovvEvents"/> sent to the
  <xref linkend="ovvUnderlying"/> dialog with a method in the Rexx dialog object. Except as noted below, the
  Rexx programmer adds the method to her dialog subclass. Once the event notification is connected, each time the event
  occurs, the connected method is invoked. The programmer codes the method to take the appropriate action for the event.
</para>
<para>
  In the Windows user interface, as the user interacts with the system, events are generated that specify what the
  action of the user was. Mouse clicks, keyboard presses, moving or sizing windows, all generate events.
</para>
<para>
  Some simple examples of how this works:
<itemizedlist>
<listitem>
<para>
  Push buttons notify their parent dialog of a number of events. The programmer connects one of these events to a method
  in his Rexx dialog. Typically the CLICKED event is connected. Then, the connected method is called each time the
  button is pressed (clicked.)
</para>
</listitem>
<listitem>
<para>
  List boxes, multiple-select list boxes, and combo boxes can be connected to a method that is called each time a line
  in the list box or combo box is selected.
</para>
</listitem>
<listitem>
<para>
  For a scroll bar, the programmer can specify different methods that are called depending on the user action. The user
  can click on the arrow buttons, drag the thumb, or use the page down / page up keys. Each of these events can be
  connected to a method in the Rexx dialog.
</para>
</listitem></itemizedlist>
</para>
<para>
  Whenever a dialog object is instantiated, the ooDialog framework <link
  linkend="sctStandardEventMethods">automatically</link> makes several event connections. For all other events the Rexx
  programmer, usually, needs to specifically connect the event to his dialog, through one of the event notification methods,
  to be able to respond to the event. In a <xref linkend="clsUserDialog"/>, some of the methods that create dialog controls
  have an option that automatically connects an event to a dialog method. But, for most events, say the resize or move
  events, the connection needs to be made explicitly.  Indeed, except for trivial dialogs, most of the programming is
  deciding which events to be notified of and taking action upon receiving the notification.
</para>

<section id="sctConnectingEventHandlers"><title>Connecting Event Handlers</title>
<indexterm><primary>connecting event handlers</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connecting event handlers</secondary></indexterm>
<indexterm><primary>event notification</primary><secondary>connecting event handlers</secondary></indexterm>
<para>
  In general, events should be connected before the dialog is shown on the screen, or immediately after the dialog is
  created. There is no reason why the programmer can not place the invocation where ever it makes the most sense.
  Connecting the events in the <xref linkend="mthInitDialog"/>() method is usually sufficient. In a
  <computeroutput>UserDialog</computeroutput>, the <xref linkend="mthDefineDialog"/>() method also
  makes a good place for the connect event methods. If the programmer is overriding the <emphasis
  role="italic">init</emphasis>() method, the connect event methods can be placed there.  In this case, do not invoke
  the connect event method until <emphasis role="bold">after</emphasis> the superclass has been <link
  linkend="mthNewDialogObject">initialized</link>.
</para>
</section>

<section id="sctCodingEventHandlers"><title>Coding Event Handlers</title>
<indexterm><primary>coding event handlers</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>coding event handlers</secondary></indexterm>
<indexterm><primary>event notification</primary><secondary>coding event handlers</secondary></indexterm>

<para>
  The methods in a Rexx dialog object connected to Windows event notifications are commonly called event handlers
  because the method handles the event. In order to properly code an event handler, the Rexx programmer needs to
  understand somewhat the underlying mechanism of event notification. This is particularly important in ooDialog 4.2.0
  and later with its ability to <link linkend="ovvEventsDirectReply">directly</link> invoke the event handling method from
  the window <link linkend="ovvWindowMessages">message</link> processing loop.
</para>
<para>
  When the operating system sends an event notification to the underlying dialog, the operating system waits for a reply
  to the notification in the message processing loop. This is significant because while the operating system is
  waiting, in general, other messages can not be processed by the window. If an application does not reply in a timely
  manner to the notification messages, it can cause the application to appear hung. With today's fast processors there
  are plenty of CPU cycles for an event handler to process and reply to event notifications. But, if an application were
  to do something like sleep for 10 seconds in an event handler, the user would think the application was hung.
</para>
<para>
  Prior to ooDialog 4.2.0, the ooDialog framework could not directly invoke the event handling method in the Rexx dialog
  object. To invoke the method, the framework used a cumbersome process involving queues and interpret. In the message
  processing loop, the framework essentially queued up the method to be invoked <emphasis role="italic">at some later
  time</emphasis> and replied immediately to the notification. Because of this, the event handling method could not
  reply to the event notification, and in fact any return was simply lost. This meant much of the capability of a
  Windows dialog was unavailable. It also meant it did not matter if the method returned in a timely manner.
</para>
<para>
  With ooDialog 4.2.0 and later, the event handling method in the Rexx dialog object is invoked by the interpreter
  directly from the message processing loop in the underlying Windows dialog. This allows the Rexx programmer to
  <link linkend="exampleEventHandler1">return</link> a value to the notification, to <link
  linkend="exampleEventHandler1">synchronize</link> the handling of notifications, or to
  <link linkend="exampleEventHandler3">veto</link> an event. Remember, with this direct invocation of the event handling
  methods, the interpreter is waiting in the message processing loop for the return from the method. Therefore, the
  programmer needs to return from the method in a reasonable amount of time. Do not be overly worried about this, the
  interpreter processes a large number of statements in a very short time. There is adequate time to process and return
  a value in the event handler.
</para>
<para>
  However, having the interpreter waiting for the return of an event handling method could conceivably be a problem for
  some few existing programs. Since, in older ooDialog versions, the return from an event handler method was
  meaningless, some programmers may not have returned an actual value from the method, and / or they may not have returned
  from the method in a timely manner. The programmer may not have realized this was a mistake.
</para>
<para>
  In addition, there are a large number of event notifications in Windows where the operating system ignores the reply.
  Therefore, the ooDialog framework uses three different ways to invoke the event handling method. This is controlled by the
  <link linkend="sctCommonWillReply">willReply</link> argument that is common to all event connection methods.
</para>
<para>
  The first, preferred, method is for the interpreter to invoke the method directly, wait for the return, and then use the
  return value to reply to the Windows event notification. The second is to return 0 immediately to the operaring system,
  and invoke the event handling method to run concurrently as a separate activity. The third is to invoke the event handler
  directly, wait for the reply from the event handler, but ignore the returned value.
</para>
<note><title>Event handling methods must be public</title>
<para>
  Event handling methods must be public, they <emphasis role="italic">can not</emphasis> be private. The dialog object has
  no way of knowing an event has happened. Some object, some thing, outside of the dialog object, knows of the event. That
  other object must notify the dialog that the event has happened. In this case the other object is the operating system.
</para>
<para>
  Private methods of an object can not be invoked from outside of the object. If an event handling method is private, there
  is no way for the operating system to invoke that method to notify the dialog that the event has happened.
</para>
</note>
</section>


<section id="sctCodingEventHandlerExamples"><title>Coding Event Handler Examples</title>
<indexterm><primary>coding event handler examples</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>coding event handler examples</secondary></indexterm>
<indexterm><primary>event notification</primary><secondary>coding event handler examples</secondary></indexterm>
<para>
  The following code snippets and examples expand on the discussion of how to code event handling methods.
</para>
<para>
  Best practice would be to always code event handlers as if they are expected to return a value to the operating
  system's event notification message. The considerations would be that the method does not block and that a value is
  returned to the operating system in a reasonable amount of time. In general, the event handler should be unguarded to
  preclude the possibility that some guarded method in the dialog object is executing at the time the event notification
  is generated.
</para>
<para>
  Below is a code snippet for an application that displays the current date and time, with a push button that refreshes
  the display. Note these points about the code snippet. Since the <emphasis role="italic">connectButtonEvent</emphasis>
  method is the replacement for the <xref linkend="ovvDeprecated"/> <emphasis
  role="italic">connectButtonNotify</emphasis> it is in essence an existing connection method, using the original
  arguments. Therefore, by default, the method is invoked from the message processing loop to run concurrently as a separate
  activity. Because of this, technically, it does not have to be unguarded and does not have to return a value. Nevertheless,
  the example is the <emphasis role="italic">correct</emphasis> way to code the event handler.
<programlisting>
<![CDATA[
::method initDialog
  ...
  self~connectButtonEvent(IDC_PB_REFRESH, "CLICKED", updateTime)
  ...

::method updateTime unguarded
  use arg info, hwnd

  now = .DateTime~new
  self~refreshDisplay(now)
  return 0

]]>
</programlisting>

</para>
<para>
  Consider this snippet from a similar program, but where the push button starts a process that calculates the grains of
  sand in the universe. Since it is not expected that the calculation will finish in a reasonable amount of time, an
  early reply is used to return a value in a timely manner. The handler also disables the push button so that the user
  can not start a second calculation until the first calculation finishes.
<programlisting>
<![CDATA[
::method initDialog
  ...
  self~connectButtonEvent(IDC_PB_CALC_SAND, "CLICKED", onCalculateGrains)
  ...

::method onCalculateGrains unguarded
  use arg info, hwnd

  self~newPushButton(IDC_PB_CALC_SAND)~disable
  reply 0

  number = self~calculateSandInUniverse
  self~refreshDisplay(number)
  self~newPushButton(IDC_PB_CALC_SAND)~enable
  return

]]>
</programlisting>

</para>
<para>
  The following examples are all for events where having the interpreter wait for the returned value from the event handler
  is the best way to handle the notifications.
</para>
<variablelist>
  <varlistentry id="exampleEventHandler1"><term><emphasis role="bold">Returning Values</emphasis></term>
  <listitem>
  <para>
    The <xref linkend="clsMonthCalendar"/> control has the <xref linkend="evtMonthCalendarGETDAYSTATE"/> event that is sent
    to request information on how certain days are to be shown. The programmer can customize the calendar by returning a set
    of days that should be displayed in bold. For instance, in a business application paid holidays could be displayed in
    bold.
  </para>
  <para>
    Since the <emphasis role="italic">connectMonthCalendarEvent</emphasis> method did not exist in ooDialog 4.1.0 and
    the return value for this event controls what the operating system does, the <link
    linkend="sctCommonWillReply">willReply</link> argument is forced to true by the ooDialog framework. That is, the
    interpreter invokes the event handler directly, waits for the reply value, and returns that value to the operating
    system., The programmer can not change this behavior. If the programmer does not wish to return a meaningful value from
    the event handler, the event should not be connected.
  </para>

<programlisting>
<![CDATA[

::method initDialog
  expose calendar

  calendar = self~newMonthCalendar(IDC_MC_HOLIDAYS)

  -- Connect the GETDAYSTATE event.
  self~connectMonthCalendarEvent(IDC_MC_HOLIDAYS, "GETDAYSTATE", onGetDayState)

  -- Restrict the calendar so that it only displays the year 2011.
  start = .DateTime~fromStandardDate("20110101")
  end = .DateTime~fromStandardDate("20111231")

  ...

::method onGetDayState unguarded
  expose calendar
  use arg startDate, count

  -- Create the array to hold the .DayState objects.
  dayStates = .array~new(count)

  month = startDate~month
  if month == 12 then month = 0

  do i = 1 to count
    j = month + i - 1

    select
      when j ==  1 then dayStates[i] = .DayState~new(17)
      when j ==  2 then dayStates[i] = .DayState~new(21)
      when j ==  3 then dayStates[i] = .DayState~new
      when j ==  4 then dayStates[i] = .DayState~new
      when j ==  5 then dayStates[i] = .DayState~new(30)
      when j ==  6 then dayStates[i] = .DayState~new
      when j ==  7 then dayStates[i] = .DayState~new(4)
      when j ==  8 then dayStates[i] = .DayState~new
      when j ==  9 then dayStates[i] = .DayState~new(5)
      when j == 10 then dayStates[i] = .DayState~new
      when j == 11 then dayStates[i] = .DayState~new(24, 25)
      when j == 12 then dayStates[i] = .DayState~new(23, 30)
      otherwise dayStates[i] = .DayState~new()
    end
  end

  buffer = .DayStates~makeDayStateBuffer(dayStates)
  return buffer

]]>
</programlisting>
  </listitem></varlistentry>
  <varlistentry id="exampleEventHandler2"><term><emphasis role="bold">Event Synchronization</emphasis></term>
  <listitem>
  <para>
    The <xref linkend="clsDateTimePicker"/> control has the DROPDOWN event notification that is sent when the drop down
    calendar is shown. This gives the programmer a chance to customize the month calendar that is shown. Since the month
    calendar is not shown until the event handling method returns, replying directly to the notification allows the
    programmer to completely finish the customizations before the month calendar appears on the screen.
  </para>

<programlisting>
<![CDATA[

::method initDialog

  self~connectDateTimePickerEvent(IDC_DTP, "DROPDOWN", onDropDown)
  ...


::method onDropDown unguarded
  use arg idFrom, hwndFrom

  dt = self~newDateTimePicker(IDC_DTP);
  monthCal = dt~getMonthCal
  monthCal~setFirstDayOfWeek(3)
  monthCal~addStyle("NOTODAY")

  return 0

]]>
</programlisting>
  <para>
    In the above example, the <emphasis role="italic">connectDateTimePickerEvent</emphasis> method did not exist in
    ooDialog 4.1.0. Therefore, by default the interpreter invokes the event handler directly, waits for a reply, and expects
    a returned value. However, the operating system ignores the actual value of the return. The programmer can change the
    default behavior if he wants. If there is no reason to have the interpreter wait until the event handler finishes, then
    the programmer could use the optional <emphasis role="italic">willReply</emphasis> argument. The
    <computeroutput>.false</computeroutput> value tells the ooDialog framework to invoke the event handler to run
    concurrently as a separate activity.
  </para>

<programlisting>
<![CDATA[

::method initDialog

  self~connectDateTimePickerEvent(IDC_DTP, "DROPDOWN", onDropDown, .false)
  ...


::method onDropDown unguarded
  expose userDidSeeCalendar
  use arg idFrom, hwndFrom

  userDidSeeCalendar = .true

]]>
</programlisting>
  <para>
    However, if the programmer is going to customize the calendar, having the event handler run concurrently is likely to
    have the calendar shown before the customization is finished. So, it makes much more sense to at least use the <emphasis
    role="italic">sync</emphasis> option in this way:
  </para>
<programlisting>
<![CDATA[

::method initDialog

  self~connectDateTimePickerEvent(IDC_DTP, "DROPDOWN", onDropDown, 'SYNC')
  ...


::method onDropDown unguarded
  use arg idFrom, hwndFrom

  dt = self~newDateTimePicker(IDC_DTP);
  monthCal = dt~getMonthCal
  monthCal~setFirstDayOfWeek(3)
  monthCal~addStyle("NOTODAY")

]]>
</programlisting>
  </listitem></varlistentry>
  <varlistentry id="exampleEventHandler3"><term><emphasis role="bold">Veto Events</emphasis></term>
  <listitem>
  <para>
    The <xref linkend="clsTab"/> control has the SELCHANGING event. It is sent when the user selects a different tab, and is
    sent <emphasis role="bold">before</emphasis> the selected tab is changed. The programmer can <emphasis
    role="italic">veto</emphasis> the change to a new tab by returning <computeroutput>.false</computeroutput> to the event
    notification, or allow the change by returning <computeroutput>.true</computeroutput>. One reason for preventing the
    change might be that the user had entered invalid data in the current tab page.
  </para>
  <para>
    <emphasis role="bold">Note:</emphasis> Since the <emphasis role="italic">connectTabEvent</emphasis> method is the
    replacement for the <emphasis role="italic">ovvDeprecated</emphasis> <emphasis
    role="italic">connectTabNotify</emphasis> method, it essentially is a method that existed in ooDialog 4.1.0. When the
    same arguments are used as existed in 4.1.0, the default for <emphasis role="italic">willReply</emphasis> is false. The
    event handler is invoked to run concurrently as a separate activity and the interpreter does not wait for a return value.
    With this behavior, it is impossible for the programmer to veto the change to a new tab. Therefore the programmer has to
    use the optional <emphasis role="italic">willReply</emphasis> argument to change the default behavior. Specifying
    <computeroutput>.true</computeroutput> causes the ooDialog framework to invoke the <emphasis
    role="italic">onTabChanging</emphasis> method directly, wait for the return value, and pass that value to the operating
    system.
  </para>
<programlisting>
<![CDATA[

::method defineDialog

  self~connectTabEvent(IDC_TAB, SELCHANGING, onTabChanging, .true)

::method onTabChanging unguarded
  expose tabContent
  use arg idFrom, hwndFrom

  index = self~newTab(idFrom)~selectedIndex + 1
  dlg = tabContent[index]

  if dlg~allowChange then return .true
  else return .false

]]>
</programlisting>
  <para>
    In the above example, since the <emphasis role="italic">allowChange</emphasis> method is returning
    <computeroutput>.true</computeroutput> or <computeroutput>.false</computeroutput> the event handler could have been
    coded this way:
  </para>
<programlisting>
<![CDATA[
::method onTabChanging unguarded

  ...

  return dlg~allowChange
]]>
</programlisting>
  <para>
    The example used:
<programlisting>
<![CDATA[
  if dlg~allowChange then return .true
  else return .false
]]>
</programlisting>
    to emphasize that the event handler needs to return <computeroutput>.true</computeroutput> or
    <computeroutput>.false</computeroutput>.
  </para>
  </listitem></varlistentry>
  <varlistentry id="exampleEventHandler4"><term><emphasis role="bold">Lengthy Processing</emphasis></term>
  <listitem>
  <para>
    As previously noted, the Rexx programmer does not need to be overly worried about taking too much time to return a
    value from an event handler. In most every case there is plenty of time to process the event and return a value.
    However, sometimes the programmer may want to, or need to, do some lengthy processing in the event handler. For
    these cases, the programmer needs to figure out how to return a value from the event handler and also do the needed
    processing. This is really a <emphasis role="italic">concurrency</emphasis> problem, not an event handling problem.
  </para>
  <para>
    The two common ways to solve this problem would be to use an <emphasis role="italic">early reply</emphasis> or to
    start a <emphasis role="italic">second activity</emphasis> running to do the processing. Using the
    <link linkend="exampleEventHandler3">onTabChanging</link> event handler above, here are two typical ways to handle the
    event when some lengthy processing is involved. As a hypothetical, say that when the user changes to a new tab, the
    program needs to gather up all the data on the validated page and write it to disk, or send it somewhere. One approach
    would be to validate the page, do an early reply, and then finish up the processing:
  </para>
<programlisting>
<![CDATA[

::method defineDialog

  self~connectTabEvent(IDC_TAB, SELCHANGING, onTabChanging, .true)

::method onTabChanging unguarded
  expose tabContent
  use arg idFrom, hwndFrom

  index = self~newTab(idFrom)~selectedIndex + 1
  dlg = tabContent[index]

  if \ dlg~allowChange then return .false  -- Tab will not be changed

  reply .true  -- Tab is changed for the user.

  -- Now gather up the data entered on the page we just switched from.
  data = dlg~getUserDataDirectory
  self~writeDataToFile(data)

]]>
</programlisting>
  <para>
    Another approach could be to start a new activity which will run concurrently. It might be coded this way:
  </para>
<programlisting>
<![CDATA[
::method onTabChanging unguarded
  expose tabContent
  use arg idFrom, hwndFrom

  index = self~newTab(idFrom)~selectedIndex + 1
  dlg = tabContent[index]

  if dlg~allowChange then do
    dp = .DataProcesser~new
    dp~start("processDlgData", dlg)
    return .true
  end
  else do
    return .false
  end
]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>

</section> <!-- End Coding Event Handler Examples section -->


<section id="sctCommonWillReply"><title>Common <emphasis role="italic">willReply</emphasis> argument</title>
<indexterm><primary>Common willReply argument</primary></indexterm>
<indexterm><primary>event notification</primary><secondary>connecting event handlers</secondary><tertiary>common willReply argument</tertiary></indexterm>

<para>
  It is the intent that every event connection method have an optional <emphasis role="italic">willReply</emphasis> argument
  to give the programmer some control of how the interpreter invokes the event handler. For each event connection method, 3
  values are accepted for the <emphasis role="italic">willReply</emphasis> argument:
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">.true</emphasis></term>
  <listitem>
  <para>
    When <emphasis role="italic">willReply</emphasis> is true, the interpreter waits for the return value from the event
    handler and enforces that the method has returned a value. That is, the event handling method must return some value.
    That value is returned to the operating system.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">.false</emphasis></term>
  <listitem>
  <para>
    When <emphasis role="italic">willReply</emphasis> is false, the interpreter immediately returns 0 to the operating
    system. It then invokes the event handling method to run concurrently as a separate activity. The return from the event
    handling method, if any, is ignored.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">sync</emphasis></term>
  <listitem>
  <para>
    When <emphasis role="italic">willReply</emphasis> is the keyword <emphasis role="italic">sync</emphasis>, the interpreter
    waits for the return from the event handler, but it discards the value returned. It does not enforce that a value is
    actually returned.
  </para>
  </listitem></varlistentry>
</variablelist>
<para>
  The default value if the argument is omitted varies depending on the event connection method. In general, the default for
  event connections that existed prior to ooDialog 4.2.0 is false and for event connections that were added in ooDialog 4.2.0
  and afterwards is true.
</para>

</section> <!-- End Common willReply argument section -->

<section id="sctMethodsEventNotification"><title>Method Table</title>
<para>
  The following table list the methods of the <computeroutput>EventNotification</computeroutput> class:
</para>
<table id="tblEventNotificationMethods" frame="all">
<title>EventNotification Methods</title>
<tgroup cols="2">
<colspec colwidth="2*" />
<colspec colwidth="4*" />
<thead>
<row>
<entry>Method</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry><xref linkend="mthAddUserMsg"/></entry>
<entry>Connects an operating system window message with a method in the Rexx dialog object.</entry>
</row>
<row>
<entry><xref linkend="mthConnectActivate"/></entry>
<entry>Connects the window activation event to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectAllSBEvents"/></entry>
<entry>Connects all event notifications from a scroll bar control to a single method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectButtonEvent"/></entry>
<entry>Connects an event notification from a button control to a method in the Rexx Dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectComboBoxEvent"/></entry>
<entry>Connects an event notification from a combo box to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectCommandEvents"/></entry>
<entry>Connects a command event notification from a dialog control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectDateTimePickerEvent"/></entry>
<entry>Connects an event notification form a date time picker to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectDraw"/></entry>
<entry>Connects the draw item event notification to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectEachSBEvent"/></entry>
<entry>Connects each specified event notification from a scroll bar to a separate method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectEditEvent"/></entry>
<entry>Connects an event notification from an edit control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectFKeyPressDialogObject"/></entry>
<entry>Connects a F Key key press (a F key is typed) with a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectHelp"/></entry>
<entry>Connects the Windows Help event to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectKeyPressDialogObject"/></entry>
<entry>Connects a key press (a key is typed) with a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectListBoxEvent"/></entry>
<entry>Connects an event notification from a list box control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectListViewEvent"/></entry>
<entry>Connects an event notification from a list-view control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectMonthCalendarEvent"/></entry>
<entry>Connects an event notification from a month calendar to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectMove"/></entry>
<entry>Connects the move event notification to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectNotifyEvent"/></entry>
<entry>Connects a generic event notification from a dialog control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectPosChanged"/></entry>
<entry>Connects the position has changed event notification to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectResize"/></entry>
<entry>Connects the size event notification to a method in the Rexx dialog</entry>
</row>
<row>
<entry><xref linkend="mthConnectResizing"/></entry>
<entry>Connects the sizing event notification to a method in the Rexx dialog</entry>
</row>
<row>
<entry><xref linkend="mthConnectScrollBarEvent"/></entry>
<entry>Connects an event notification from a scroll bar control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectSizeMoveEnded"/></entry>
<entry>Connects the size / move ended event notification to a method in the Rexx dialog object.</entry>
</row>
<row>
<entry><xref linkend="mthConnectStaticEvent"/></entry>
<entry>Connects an event notification from a static control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectTabEvent"/></entry>
<entry>Connects an event notification from a tab control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectToolBarEvent"/></entry>
<entry>Connects an event notification from a toolbar control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectToolTipEvent"/></entry>
<entry>Connects an event notification from a ToolTip control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectTrackBarEvent"/></entry>
<entry>Connects an event notification from a track bar control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectTreeViewEvent"/></entry>
<entry>Connects an event notification from a tree view control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthConnectUpDownEvent"/></entry>
<entry>Connects an event notification from an UpDown control to a method in the Rexx dialog.</entry>
</row>
<row>
<entry><xref linkend="mthDefListDragHandler"/></entry>
<entry>Default implementation of a drag and drop handler for a list-view control.</entry>
</row>
<row>
<entry><xref linkend="mthDefTreeDragHandler"/></entry>
<entry>Default implementation of a drag and drop handler for a tree view control.</entry>
</row>
<row>
<entry><xref linkend="mthDisconnectKeyPressDialogObject"/></entry>
<entry>Disconnects a method that was previously connected to key press event.</entry>
</row>
<row>
<entry><xref linkend="mthHasKeyPressConnectionDialogObject"/></entry>
<entry>Queries if a connection to a key press event already exists.</entry>
</row>
</tbody></tgroup>
</table>
</section>

<section id="mthAddUserMsg" xreflabel="addUserMsg"><title>addUserMsg</title>
<indexterm><primary>addUserMsg</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>addUserMsg</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>addUserMsg</secondary></indexterm>
<programlisting>
<![CDATA[
>>--addUserMsg(mth-,-winMsg-+------+-+------+-+------+-+------+-+------+-+----------+)--><
                            +-,-f1-+ +-,-wP-+ +-,-f2-+ +-,-lP-+ +-,-f3-+ +-,-wlRply-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">addUserMsg</emphasis> method connects a Windows window <xref linkend="ovvWindowMessages"/>,
  with specific parameters, sent to the <xref linkend="ovvUnderlying"/> dialog with a method in the Rexx dialog.
</para>
<note><title>Note</title>
<para>
  This method is designed to be used by ooDialog programmers who are familiar with the Windows API. It's use will require
  access to the Windows <xref linkend="defWindowsDoc"/> at a minimum, and will likely also require access to the Windows
  header files in the Windows platform <xref linkend="defPlatformSDK"/>.
</para>
</note>
<para>
  Each added user message and each connected event generates a message entry in an ooDialog table. Internally, ooDialog
  examines every window message, and its parameters, that the Windows dialog receives. If the window message and its
  parameters match an entry in the message table, ooDialog invokes the method specified in the message table. For <emphasis
  role="italic">addUserMsg</emphasis>, this is the method specified by the <emphasis role="italic">mth</emphasis> argument.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    All arguments, except for <emphasis role="italic">mth</emphasis>, <emphasis role="italic">rxMsg</emphasis>, and <emphasis
    role="italic">wlRply</emphasis>, represent whole numbers in their hexidecimal format. For convenience, the programmer can
    either use the numeric value for these argument, or the numbers can be expressed in conventional <xref
    linkend="defConventionalHex"/> format. It is important to realize that since bitwise <emphasis
    role="italic">and</emphasis> is used with <emphasis role="italic">winMsg</emphasis>, <emphasis
    role="italic">wP</emphasis>, and <emphasis role="italic">lP</emphasis> and their respective filters, it is the
    hexidecimal format of the whole numbers that is relevant.
  </para>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>mth [required]</term>
      <listitem>
      <para>
        The method in the Rexx dialog to invoke when, or if, the window message and its parameters sent to the underlying
        dialog match a message entry in the message table.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>winMsg [required]</term>
      <listitem>
      <para>
        The numeric value of the window message to match.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>f1 [optional]</term>
      <listitem>
      <para>
        A filter to apply to <emphasis role="italic">winMsg</emphasis>. The filter is bitwise <emphasis
        role="italic">anded</emphasis> with <emphasis role="italic">winMsg</emphasis> and if the result equals the actual
        window messge sent, it is considered a match. If omitted a filter of 0xFFFFFFFF is used.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>wP [optional]</term>
      <listitem>
      <para>
        The numeric value of the <link linkend="ovvWindowMessages">WPARAM</link> parameter in the window message to
        match. This defaults to 0.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>f2 [optional]</term>
      <listitem>
      <para>
        A filter to apply to the <emphasis role="italic">wP</emphasis> argument. The filter is bitwise <emphasis
        role="italic">anded</emphasis> with <emphasis role="italic">wP</emphasis> and if the result equals the actual numeric
        value of the wParam sent, it is considered a match. If omitted a filter of 0 is used.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>lP [optional]</term>
      <listitem>
      <para>
        The numeric value of the <link linkend="ovvWindowMessages">LPARAM</link> parameter in the window message to match.
        This defaults to 0.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>f3 [optional]</term>
      <listitem>
      <para>
        A filter to apply to the <emphasis role="italic">lP</emphasis> argument. The filter is bitwise <emphasis
        role="italic">anded</emphasis> with <emphasis role="italic">lP</emphasis> and if the result equals the numeric value
        of the actual lParam sent, it is considered a match. If omitted a filter of 0 is used. Note that WM_NOTIFY messages
        are treated slightly different, see the remarks.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>wlRply [optional]</term>
      <listitem>
      <para>
        The <link linkend="sctCommonWillReply">wlRply</link> argument controls how the interpreter invokes the event handler
        for the connected event The default if <emphasis role="italic">willReply</emphasis> is omitted is
        <computeroutput>.false</computeroutput>.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return value is 0 for success and 1 for failure.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method is not intended for every ooDialog programmer. In particular, it requires some understanding of window
    messages, the message parameters, and bitwise <emphasis role="italic">and</emphasis>. If the ooDialog programmer does
    not know what a bitwise <emphasis role="italic">and</emphasis> is, that is a good indication that this method is not for
    them.
  </para>

  <warning><title>Incorrect use can crash your program.</title>
  <para>
    If the <emphasis role="italic">wlRply</emphasis> is set to .true, an incorrect return from the connected event handler
    can crash your application.
  </para>
  <para>
    The ooRexx interpreter strives to prevent the ooRexx programmer from shooting himself in the foot. However, the
    assumption is that if the programmer uses the <emphasis role="italic">addUserMsg</emphasis> method, despite the warnings,
    that he knows what he is doing. When <emphasis role="italic">wlRply</emphasis> is true, the value returned from the event
    handler is passed on to the operating system as is. It is possible, although unlikely, that an incorrect value could
    cause the program to crash. For instance, if the operating system is expecting a pointer to memory and the numeric value
    passed back from the event handler is not pointing to valid memory, the program will crash.
  </para>
  </warning>

  <para>
    Details for all window messages and their parameters are available in the Windows
    <xref linkend="defWindowsDoc"/>. The numeric value of the message IDs (and possibly the message parameters) can be
    looked up in the Windows platform <xref linkend="defPlatformSDK"/>.
  </para>
  <para>
    In all cases, it is preferable to use specific connect event methods provided by ooDialog.  Such as
    <xref linkend="mthConnectEditEvent"/>, <xref linkend="mthConnectResize"/>, etc..
    <emphasis role="italic">addUserMsg</emphasis> is provided for those cases where the specific connect event method
    the programmer needs is not present in ooDialog.
  </para>

<note><title>WM_NOTIFY is special cased.</title>
<para>
  The WM_NOTIFY window message is handled as a special case. The LPARAM argument sent with the WM_NOTIFY message has a number
  of pieces of information embedded within it. One of those pieces is the numeric notification code for the message. This is
  the important piece that the ooDialog framework uses to filter the messages, Therefore, if the <emphasis
  role="italic">winMsg</emphasis> argument is WM_NOTIFY, the <emphasis role="italic">lP</emphasis> argument should be the
  notification code for the desired message and the filter should be <emphasis role="italic">0xffffffff</emphasis>.
</para>
<para>
  A quick example:  Windows Vista adds a new style to buttons called a <emphasis role="italic">split button</emphasis>.
  Split buttons send a new notification message, BCN_DROPDOWN, when the user clicks on the down arrow of the button. Before
  ooDialog added support for the split button, a programmer could have used it in their ooDialog programs by creating a
  dialog template in a resource only DLL with a split button and using <emphasis role="italic">addUserMsg</emphasis> to
  capture the drop down notification. Looking up the numeric values for this notification, the programmer would have found
  that WM_NOTIFY == '0x004E' and that BCN_DROPDOWN == '0xfffffb20'. Assuming the ID for the split button is 1004. The
  programmer would code <emphasis role="italic">addUserMsg</emphasis> like this:
<programlisting>
<![CDATA[
  addUserMsg('onDropDown', '0x004E', '0xFFFFFFFF', 1004, '0xFFFFFFFF', '0xfffffb20', '0xFFFFFFFF', .true)
]]>
</programlisting>
</para>
</note>

  <para>
    Note that the arguments the event handling method receives are dependent on the window message being connected. There are
    3 types of event handlers:
  </para>

  <variablelist>
    <varlistentry><term><emphasis role="bold">WM_NOTIFY handlers:</emphasis></term>
    <listitem>
    <para>
      The event <link linkend="evtAddUserMsgNotify">handler</link> for WM_NOTIFY messages receives 4 arguments.
    </para>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">WM_COMMAND handlers:</emphasis></term>
    <listitem>
    <para>
      The event <link linkend="evtAddUserMsgCommand">handler</link> for WM_COMMAND messages receives 5 arguments.
    </para>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">All Others</emphasis></term>
    <listitem>
    <para>
      The event <link linkend="evtAddUserMsgOther">handler</link> for all other messages receives 2 arguments.
    </para>
    </listitem></varlistentry>
  </variablelist>

  <para>
    Note that some of the arguments sent to the event handlers will be the numeric value of the WPARAM and LPARAM parameters
    for the window message. If either WPARAM or LPARAM are pointers, the numeric value will not do the ooDialog programmer
    any good. There is no way in ooDialog Rexx code to access whatever the pointer points to.
  </para>
  <para>
    The exception to this would be if ooDialog already had a connect event method for the specific window message. In this
    case the ooDialog framework accesses the memory and sends the correct, appropriate arguments to the event handler. In
    which case there is no need to use <emphasis role="italic">addUserMsg</emphasis>.
  </para>
  <para>
    Filters can be used to ensure that only the specific message desired is connected to the Rexx method, or to match
    several messages and connect them to the same Rexx method.
  </para>
  <para>
    Take the window messages WM_KEYDOWN (0x0100) and WM_KEYUP (0x0101.) When the following arguments are used:
<programlisting>
<![CDATA[

  winMsg == '0x0100'
  f1     == '0xFFFF'
  addUserMsg('onKeyDown', winMsg, f1, 0, 0, 0, 0)

]]>
</programlisting>
    only the WM_KEYDOWN message will match and <emphasis role="italic">onKeyDown</emphasis> is only invoked for that
    message.
  </para>
  <para>
    However, when the arguments are:
<programlisting>
<![CDATA[

  winMsg == '0x0100'
  f1     == '0xFFFE'
  addUserMsg('onKey', winMsg, f1, 0, 0, 0, 0)

]]>
</programlisting>
    both the WM_KEYDOWN and WM_KEYUP messages will match and the <emphasis role="italic">onKey</emphasis> method will be
    invoked for either window message.
  </para>
  <para>
    In a similar fashion, both the LBN_SETFOCUS (0x4) and the LBN_KILLFOCUS (0x5) notifications are sent to a list box
    using the WM_COMMAND (0x0111) message.  For the WM_COMMAND message, the WPARAM parameter contains the control ID in
    the low word of the parameter and the notification code in the high word of the parameter.
  </para>
  <para>
    Say the list box control has an ID of 256 (0xFF,) when the arguments are:
<programlisting>
<![CDATA[

  winMsg == '0x0111'
  f1     == '0xFFFF'

  wP     == '0x000400FF'
  f2     == '0xFFFFFFFF'
  addUserMsg('onSetFocus', winMsg, f1, wP, f2, 0, 0)

]]>
</programlisting>
   only the LBN_SETFOCUS notification sent to the list box with ID of 256 will invoke the <emphasis
   role="italic">onSetFocus</emphasis> method.
  </para>
  <para>
   However, in the following case:
<programlisting>
<![CDATA[

  winMsg == '0x0111'
  f1     == '0xFFFF'

  wP     == '0x000400FF'
  f2     == '0xFFFEFFFF'
  addUserMsg('onFocus', winMsg, f1, wP, f2, 0, 0)

]]>
</programlisting>
    both the LBN_SETFOCUS and LBN_KILLFOCUS notifications to the listbox will invoke the <emphasis
    role="italic">onFocus</emphasis> method.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when incorrect usage is detected.
  </para>
  </listitem></varlistentry>
  <varlistentry id="exampleAddUserMsg"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The WM_CANCELMODE message is sent to cancel certain modes, such as mouse capture. This example shows how an ooDialog
    program that captures the mouse for some reason could add an event handler for the WM_CANCELMODE message and release
    the mouse if the program had currently captured it. This is a hypothetical situation intended to show how to use the
    <emphasis role="italic">addUserMsg</emphasis> method and not necessarily of any practical value.
<programlisting>
<![CDATA[

::method init
    expose mouseIsCaptured
    ...

    WM_CANCELMODE = '0x001F'
    ret = self~addUserMsg('onCancelMode', WM_CANCELMODE, '0xFFFF', 0, 0, 0, 0)
    if ret == 1 then do
        -- Do some error handling stuff.
        -- But, really this is unlikely to happen.
    end

    mouseIsCaptured = .false


::method doCaptureMouse private
    expose mouseIsCaptured

    self~captureMouse
    mouseIsCaptured = .true

    ...  -- more code


::method onCancelMode unguarded
    expose mouseIsCaptured
    use arg wParam, lParam

    -- For WM_CANCELMODE wParam and lParam have no meaning.

    if mouseIsCaptured then do
        self~releaseMouseCapture
        mouseIsCaptured = .false

        ...  -- maybe some more code
    end

    return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtAddUserMsgOther"><title>addUserMsg Other Message Event Handler</title>
<indexterm><primary>addUserMsg</primary><secondary>event handlers</secondary><tertiary>other messages</tertiary></indexterm>
<para>
  The event handler connected through the <xref linkend="mthAddUserMsg"/> is invoked when ooDialog
  internally matches a message sent to the <xref linkend="ovvUnderlying"/> Windows dialog using the arguments specified to
  the <emphasis role="italic">addUserMsg</emphasis> method. The <emphasis role="italic">other message</emphasis> event
  handler is invoked when the window message matched is not WM_NOTIFY or WM_COMMAND.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthAddUserMsg"/> method determines
  how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onEvent unguarded
  use arg wParam, lParam

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    This event handling method receives two arguments.
  </para>
  <variablelist>
    <varlistentry><term>wParam</term>
    <listitem>
    <para>
      The numeric value of the<link linkend="ovvWindowMessages">WPARAM</link> parameter sent with the window message that
      was connected through <emphasis role="italic">addUserMsg</emphasis>. This numeric value of WPARAM may or may not be of
      use to the programmer depending on the specific window message.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>lParam</term>
    <listitem>
    <para>
      The numeric value of the <link linkend="ovvWindowMessages">LPARAM</link> parameter sent with the window message that
      was connected through <emphasis role="italic">addUserMsg</emphasis>. Again, this numeric value of LPARAM may or may
      not be of use to the programmer depending on the specific window message.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
   If the <link linkend="sctCommonWillReply">willReply</link> argument for the <emphasis
   role="italic">addUserMsg</emphasis> method was true, then the event handler <emphasis role="italic">must</emphasis> return
   a numeric value. This value is passed on unchanged to the operating system. Otherwise the return, if any, from the event
   handler is ignored.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The WM_QUERYOPEN message is sent to a window when it is minimized. If the window returns true, it is restored. If it
    returns false, the window remains minimized. In the following example, if the user minimizes the dialog, when the user
    goes to restore the dialog, it will only be restored, randomly, half of the time:

<programlisting>
<![CDATA[
::method initDialog
    ...

    WM_QUERYOPEN = '0x0013'
    self~addUserMsg(onQueryOpen, WM_QUERYOPEN, '0xFFFFFFFF', 0, 0, 0, 0, .true)
    ...

::method onQueryOpen  unguarded
    use arg wParam, lParam

    n = random(0, 200)

    if n // 2 == 0 then return .true
    else return .false

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End Other message Event Handler -->

<section id="evtAddUserMsgCommand"><title>addUserMsg WM_COMMAND Message Event Handler</title>
<indexterm><primary>addUserMsg</primary><secondary>event handlers</secondary><tertiary>WM_COMMAND messages</tertiary></indexterm>
<para>
  The event handler connected through the <xref linkend="mthAddUserMsg"/> is invoked when ooDialog internally matches a
  message sent to the <xref linkend="ovvUnderlying"/> Windows dialog using the arguments specified to the <emphasis
  role="italic">addUserMsg</emphasis> method. The <emphasis role="italic">WM_COMMAND message</emphasis> event handler is
  invoked when the window message matched is WM_COMMAND.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthAddUserMsg"/> method determines
  how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onWmCommand unguarded
  use arg wParam, lParam, id, notifyCode, controlObj

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    This event handling method receives five arguments. The <emphasis role="italic">wParam</emphasis> and <emphasis
    role="italic">lParam</emphasis> arguments have to be retained for backwards compatibility, but the last 3 arguments are
    really what are useful.
  </para>
  <variablelist>
    <varlistentry><term>wParam</term>
    <listitem>
    <para>
      The numeric value of the<link linkend="ovvWindowMessages">WPARAM</link> parameter sent with the window message that
      was connected through <emphasis role="italic">addUserMsg</emphasis>. This numeric value will contain the resource ID
      of the control sending the message and the numeric code of the event that caused the notification to be sent. However,
      the ooDialog framework extracts these values and sends them as the <emphasis role="italic">id</emphasis> and <emphasis
      role="italic">notifyCode</emphasis> arguments.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>lParam</term>
    <listitem>
    <para>
      The numeric value of the <link linkend="ovvWindowMessages">LPARAM</link> parameter sent with the window message that
      was connected through <emphasis role="italic">addUserMsg</emphasis>. If a dialog control sent the notification, then
      the LPARAM value is always the window handle of the control sending the notification. If a menu item or accelerator key
      sent the notification, then this value will always be zero.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource id of the object sending the notification. Typically this will be a dialog control, however it
      could be a menu item or an accelerator key. See the remarks section.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>notifyCode</term>
    <listitem>
    <para>
      The numeric notification code of the event that caused the notification to be sent. If the notification was sent by a
      menu item this will always be 0. If sent by an accelerator key, it will always be 1. When the notification is sent by a
      dialog control, it will be a notification code defined by the control. Note that notification codes do not have unique
      values. For example, the list box LBN_SETFOCUS notification code has the value of 4, as does the button's BN_DISABLED
      code.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>controlObj</term>
    <listitem>
    <para>
      The Rexx dialog control object that represents the underlying dialog control that sent the notification, if a dialog
      control sent the notification. When a menu item or an accelerator key sent the notification, this will be the
      <computeroutput>.nil</computeroutput> object.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
   If the <link linkend="sctCommonWillReply">willReply</link> argument for the <emphasis
   role="italic">addUserMsg</emphasis> method was true, then the event handler <emphasis role="italic">must</emphasis> return
   a numeric value. This value is passed on unchanged to the operating system. Otherwise the return, if any, from the event
   handler is ignored.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The following table can be used to determine if the <emphasis role="italic">id</emphasis> argument is a dialog control
    ID, a menu item ID, or an accelerator key ID:.
  </para>
  <table id="tblWmCommandArgs" frame="all">
  <title>WM_COMMAND Event Handler Arguments</title>
  <tgroup cols="4">
  <colspec colwidth="2*" />
  <colspec colwidth="4*" />
  <colspec colwidth="4*" />
  <colspec colwidth="4*" />
  <thead>
  <row>
  <entry>Source</entry>
  <entry>notifyCode</entry>
  <entry>ID</entry>
  <entry>Control Object</entry>
  </row>
  </thead>
  <tbody>
  <row>
  <entry>Menu</entry>
  <entry>0</entry>
  <entry>Menu item ID</entry>
  <entry>The <computeroutput>.nil</computeroutput> object</entry>
  </row>
  <row>
  <entry>Accelerator</entry>
  <entry>1</entry>
  <entry>Accelerator key ID</entry>
  <entry>The <computeroutput>.nil</computeroutput> object</entry>
  </row>
  <row>
  <entry>Dialog Control</entry>
  <entry>Control defined code</entry>
  <entry>Resource ID of the control</entry>
  <entry>Rexx dialog control</entry>
  </row>
  </tbody></tgroup>
  </table>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    Button controls send a BN_CLICK notification when the user clicks on a button. Typically radio buttons are created with
    the BS_AUTORADIOBUTTON style, and the operating system handles setting the checked or unchecked appearance of all the
    radio buttons in a group. This example shows how to use the <emphasis role="italic">addUserMsg</emphasis> method to
    connect the notification to a Rexx method and how to code the event handler to properly set the checked / unchecked
    appearance of the 2 radio buttons in the group. BN_CLICK notifications are sent using the WM_COMMAND message:

<programlisting>
<![CDATA[
::method initDialog
    expose rb1 rb2 BN_CLICK
    ...

    rb1 = self~newRadioButton(IDC_RADIO1)
    rb2 = self~newRadioButton(IDC_RADIO2)

    WM_COMMAND = '0x0111'
    BN_CLICK   = 0
    id         =  rb1~id
    wParam     = .DlgUtil~makeWParam(id, BN_CLICK)

    self~addUserMsg(onRbClick, WM_COMMAND, '0xFFFFFFFF', wParam, '0xFFFFFFFF', -
                    0, 0, .true)

    id     =  rb2~id
    wParam = .DlgUtil~makeWParam(id, BN_CLICK)

    self~addUserMsg(onRbClick, WM_COMMAND, '0xFFFFFFFF', wParam, '0xFFFFFFFF', -
                    0, 0, .true)

    ...

::method onRbClick unguarded
    expose rb1 rb2 BN_CLICK
    use arg wParam, lParam, id, code, rbObj

    if code == BN_CLICK then do
      if id == rb1~id then do
        rb1~check
        rb2~uncheck
      end
      else if id == rb2~id then do
        rb2~check
        rb1~uncheck
      end
    end

  return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End WM_COMMAND message Event Handler -->

<section id="evtAddUserMsgNotify"><title>addUserMsg WM_NOTIFY Message Event Handler</title>
<indexterm><primary>addUserMsg</primary><secondary>event handlers</secondary><tertiary>WM_NOTIFY messages</tertiary></indexterm>
<para>
  The event handler connected through the <xref linkend="mthAddUserMsg"/> is invoked when ooDialog internally matches a
  message sent to the <xref linkend="ovvUnderlying"/> Windows dialog using the arguments specified to the <emphasis
  role="italic">addUserMsg</emphasis> method. The <emphasis role="italic">notify message</emphasis> event handler is invoked
  when the window message matched is WM_NOTIFY.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthAddUserMsg"/> method determines
  how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onWmNotify unguarded
  use arg idFrom, hwndFrom, notifyCode, rexxControl

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    This event handling method receives four arguments.
  </para>
  <variablelist>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The numeric resource ID of the dialog control sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the dialog control sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>notifyCode</term>
    <listitem>
    <para>
      The numeric notification code for the event that caused the dialog control to send the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>rexxControl</term>
    <listitem>
    <para>
      The Rexx dialog control object that is sending the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
   If the <link linkend="sctCommonWillReply">willReply</link> argument for the <emphasis
   role="italic">addUserMsg</emphasis> method was true, then the event handler <emphasis role="italic">must</emphasis> return
   a numeric value. This value is passed on unchanged to the operating system. Otherwise the return, if any, from the event
   handler is ignored.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>

<programlisting>
<![CDATA[

::method initDialog
    ...
    WM_NOTIFY    = '0x004E'
    BCN_DROPDOWN = '0xfffffb20'
    self~addUserMsg('onDropDown', WM_NOTIFY, '0xFFFFFFFF', 2, '0xFFFFFFFF', -
                    BCN_DROPDOWN, '0xFFFFFFFF', .true)
    ...

::method onDropDown unguarded
  use arg idFrom, hwndFrom, notifyCode, rexxControl

  say 'Got split button drop down'
  say 'idFrom:     ' idFrom
  say 'hwndFrom:   ' hwndFrom
  say 'notifyCode: ' notifyCode
  say 'rexxControl:' rexxControl

  return 0

/*  Output would be, note that the window handle will vary:

Got split button drop down
idFrom:      2
hwndFrom:    0x00000000002F0448
notifyCode:  4294966048
rexxControl: a Button

*/
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End WM_NOTIFY message Event Handler -->

</section>  <!-- End EventNotification::addUserMsg() -->


<section id="mthConnectActivate" xreflabel="connectActivate"><title>connectActivate</title>
<indexterm><primary>connectActivate</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectActivate</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectActivate</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectActivate(--+--------------+--+--------------+)-------><
                      +--methodName--+  +-,-willReply--+
]]>
</programlisting>

<para>
  Connects an <emphasis role="italic">activate</emphasis> <xref linkend="ovvEvents"/> notification sent to
  the underlying dialog with a method in the Rexx dialog. This event notification is sent to both the window being
  activated and the window being deactivated
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that is invoked each time the dialog gains or loses the activation. The method name
      can not be the empty string. When this argument is omitted the name defaults to <emphasis
      role="italic">onActivate</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. <emphasis role="bold">Note:</emphasis> All event connection methods accept the
      <emphasis role="italic">willReply</emphasis> argument. However, for the <emphasis
      role="italic">connectActivate</emphasis> method, the value of the argument is forced to true. That is, event handling
      method must always return a value to the operating system.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The <emphasis role="italic">active</emphasis> window is the <emphasis role="italic">top-level</emphasis> window that
    the user is currently working with. The activate notification is only sent to top-level windows. The activate
    notification is always sent in pairs, one notification to the window losing the activation and one to the window
    gaining the activation. The arguments to the event handler for the notification allow the programmer to determine if
    the window is gaining or losing the activation.
  </para>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  <para>
    The interpreter invokes the event handler directly and waits in the window <xref linkend="ovvWindowMessages"/> processing
    loop for the return from the event handler. Connecting the activate event requires that the programmer reply to the event
    from the event handler in a timely manner.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    activate events happen.
  </para>
  <para>
    The underlying dialog receives the WM_ACTIVATE message as the notification for this event.
  </para>
  </listitem></varlistentry>
</variablelist>


<section id="evtACTIVATE" xreflabel="ACTIVATE"><title>Activate Event Handler</title>
<indexterm><primary>dialog object</primary><secondary>events</secondary><tertiary>ACTIVATE</tertiary></indexterm>
<para>
  The event handler for the ACTIVATE event is invoked when the dialog window is either losing or gaining the active
  window status.
</para>
<para>
  The programmer must return a value from the event handler and the interpreter waits for the return value from the
  event handler.
</para>

<programlisting>
<![CDATA[
::method onActivate unguarded
  use arg status, hwnd, hFocus, isMinimized

  return .false
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives four arguments:
  </para>
  <variablelist>
    <varlistentry><term>status</term>
    <listitem>
    <para>
      A keyword that indicates if the dialog is gaining or losing the activation. The keyword will be exactly one of the
      following:
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>ACTIVE</member> <member>CLICKACTIVE</member> <member>INACTIVE</member>
      </simplelist>
    </para>
    <variablelist>
      <varlistentry><term>ACTIVE</term>
      <listitem>
      <para>
        The dialog is gaining the activation through some means other than the user clicking the mouse on the window.
        For example the user may select the window through the ALT-Tab mechanism.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>CLICKACTIVE</term>
      <listitem>
      <para>
        The dialog is gaining the activation through a mouse click.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>INACTIVE</term>
      <listitem>
      <para>
        The dialog is losing the activation.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window <xref linkend="defHandle"/> of the window being activated or deactivated, depending on the
      <emphasis role="italic">status</emphasis> argument. If the keyword is INACTIVE, then this is the handle of the
      window gaining the activation. If the keyword is ACTIVE or CLICKACTIVE, it is the handle of the window losing the
      activation.
    </para>
    <para>
      <emphasis role="bold">Note</emphasis> that this argument may be 0, indicating the operating system did not pass a
      window handle with the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hFocus</term>
    <listitem>
    <para>
      The window handle of the dialog control with the current focus when the dialog is being deactivated.  When the
      dialog is being activated <emphasis role="italic">hFocus</emphasis> will be 0.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>isMinimized</term>
    <listitem>
    <para>
      Specifies the minimized state of the window being activated or deactivated. <emphasis
      role="italic">isMinimized</emphasis> will be <computeroutput>.true</computeroutput> if the window is minimized,
      otherwise <computeroutput>.false</computeroutput>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The event handler for this notification must return <computeroutput>.true</computeroutput> or
    <computeroutput>.false</computeroutput>. A return of true indicates that the notification has been processed and a
    return of false indicates that the notification has not been processed. When the notification has not been processed
    the interpreter passes the notification on to the operating system for its default processing.
  </para>
  <para>
    The default processing done by the operating system includes things like restoring the focus to the dialog control
    that had the focus when the dialog was deactivated, highlighting the text in an edit control if that control has the
    focus, etc.. Under most circumstances, the programmer should return <computeroutput>.false</computeroutput> to allow
    the dialog manager to perform this default processing. If not, the programmer should take care of these details or
    the dialog may not behave as the user expects.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example comes from code ooDialog uses internally to handle a problem with a <xref linkend="clsListView"/>
    control when it is used in a <xref linkend="clsTab"/> control. When the dialog is being inactivated the handle of the
    focused control is saved. When it is being activated, the handle of the last focused control is passed on the to <xref
    linkend="clsControlDialog"/> that contains the list-view for processing.

<programlisting>
<![CDATA[

::method onActivate unguarded
  expose listViewPageDialog lastFocused
  use arg flag, hwnd, hFocused, isMinimized

  reply .false

  if flag == 'INACTIVE' then lastFocused = hFocused
  else listViewPageDialog~updateListView(lastFocused)

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Activate Event Handler -->

</section>  <!-- End connectActivate() -->


<section id="mthConnectButtonEvent" xreflabel="connectButtonEvent"><title>connectButtonEvent</title>
<indexterm><primary>connectButtonEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectButtonEvent</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectButtonEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectButtonEvent(--id--,--event--+-----------+--+--------------+--)------><
                                       +-,--mName--+  +-,-willReply--+
]]>
</programlisting>

<para>
  Connects a method in the Rexx dialog to the Windows <xref linkend="ovvEvents"/> notification from a
 <xref linkend="clsButton"/> control. The <emphasis role="italic">connectButtonEvent</emphasis> method is used
  for all types of buttons (push button, radio button, or check boxes.)
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the button control this connection applies to. This can be a symbolic ID or the numeric value
        of the ID.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>event [required]</term>
      <listitem>
      <para>
        A keyword specifying the event to be connected with a method. This can be exactly one of the following, case is
        not significant:
        <variablelist>
          <varlistentry><term><link linkend="evtButtonGeneral">CLICKED</link></term>
          <listitem>
          <para>
            The button has been clicked.
          </para>
          </listitem></varlistentry>
          <varlistentry><term><link linkend="evtButtonGeneral">DBLCLK</link></term>
          <listitem>
          <para>
            The button has been double-clicked.
          </para>
          </listitem></varlistentry>
          <varlistentry><term><link linkend="evtButtonGeneral">DISABLE</link></term>
          <listitem>
          <para>
            The button has been disabled.
          </para>
          </listitem></varlistentry>
          <varlistentry><term><xref linkend="evtButtonDROPDOWN"/></term>
          <listitem>
          <para>
            Requires Windows version <emphasis role="bold">Vista</emphasis> or later.
          </para>
          <para>
            The user has clicked on the down arrow in a <emphasis role="italic">split</emphasis> button.
          </para>
          </listitem></varlistentry>
          <varlistentry><term><link linkend="evtButtonGeneral">GOTFOCUS</link></term>
          <listitem>
          <para>
            The button got the input focus.
          </para>
          </listitem></varlistentry>
          <varlistentry><term><link linkend="evtButtonGeneral">LOSTFOCUS</link></term>
          <listitem>
          <para>
            The button lost the input focus.
          </para>
          </listitem></varlistentry>
          <varlistentry><term><link linkend="evtButtonGeneral">HILITE</link></term>
          <listitem>
          <para>
            The button has been selected.
          </para>
          </listitem></varlistentry>
          <varlistentry><term><xref linkend="evtButtonHOTITEM"/></term>
          <listitem>
          <para>
            Requires Common Control <xref linkend="ovvComctl32"/> version <emphasis role="bold">6.0</emphasis> or later.
          </para>
          <para>
            Notifies the dialog that the mouse has moved over the button, or that the mouse is leaving the area over the
            button.
          </para>
          </listitem></varlistentry>
          <varlistentry><term><link linkend="evtButtonGeneral">PAINT</link></term>
          <listitem>
          <para>
            The button is to be repainted. This notification is only sent for owner-drawn buttons.
          </para>
          </listitem></varlistentry>
          <varlistentry><term><link linkend="evtButtonGeneral">UNHILITE</link></term>
          <listitem>
          <para>
            The highlighting is to be removed (lost selection).
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      </listitem></varlistentry>
      <varlistentry><term>mName [optional]</term>
      <listitem>
      <para>
        The name of the method to invoke whenever the specified notification is received from the button control. Provide
        a method with a matching name. If you omit this argument, a method name is generated automatically. The name
        consists of the event keyword preceded by <computeroutput>on</computeroutput>. For instance:
        <computeroutput>onGotFocus</computeroutput>. The method name can not be the empty string.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>willReply [optional]</term>
      <listitem>
      <para>
        The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
        handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
        <computeroutput>.false</computeroutput>.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>The return codes are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        No error detected.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
      <para>
        The resource ID could not be resolved or the event argument is incorrect.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
      <para>
        The message was not connected correctly. From ooDialog 4.2.0 and on, it is not likely the return value will be
        1.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
    <para>
      In order to receive the GOTFOCUS, LOSTFOCUS, and DBLCLK event notifications, the button control has to have the
      NOTIFY (BS_NOTIFY) style.  For user defined dialogs use the NOTIFY style keyword in the <link
      linkend="sctCreateMethods">create</link> method when the button is defined.  For dialogs created from a compiled resource
      or a resource script file use the BS_NOTIFY style for the button resource.  The other event notifications are always sent
      and it is not necessary to add the NOTIFY style for those events.
    </para>
    <para>
      See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
      linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any of
    the button events occur.
  </para>
  <para>
    In Windows itself, some notifications are sent to the parent dialog using the WM_COMMAND message and others are
    sent using the WM_NOTIFY message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example displays a message whenever the OK button is selected:
<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  self~init:super(...)
  self~connectButtonEvent("OK", "HILITE")

::method onHilite unguarded
  say "The OK button has been selected"
  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>


<section id="evtButtonDROPDOWN" xreflabel="DROPDOWN"><title>DropDown Event Handler</title>
<indexterm><primary>Button class</primary><secondary>events</secondary><tertiary>DROPDOWN</tertiary></indexterm>
<para>
  The event handler for the DROPDOWN event is invoked when the user clicks on the down arrow in a split button. Typically,
  the programmer uses this notification to display a context menu beneath the split button
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectButtonEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onDropDown unguarded
  use arg id, buttonRect, rxButton

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 3 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource id of the button sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>buttonRect</term>
    <listitem>
    <para>
      A <xref linkend="clsRect"/> object that specifies the size and postion of the button sending the notification. Use this
      rectangle to properly position a context menu.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>rxButton</term>
    <listitem>
    <para>
      The Rexx button object that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this notification. 0 is a good value to return.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End DropDown Event Handler -->


<section id="evtButtonGeneral" xreflabel="General"><title>General Button Event Handler</title>
<indexterm><primary>Button class</primary><secondary>events</secondary><tertiary>CLICKED</tertiary></indexterm>
<indexterm><primary>Button class</primary><secondary>events</secondary><tertiary>DBLCLK</tertiary></indexterm>
<indexterm><primary>Button class</primary><secondary>events</secondary><tertiary>DISABLE</tertiary></indexterm>
<indexterm><primary>Button class</primary><secondary>events</secondary><tertiary>GOTFOCUS</tertiary></indexterm>
<indexterm><primary>Button class</primary><secondary>events</secondary><tertiary>HILITE</tertiary></indexterm>
<indexterm><primary>Button class</primary><secondary>events</secondary><tertiary>LOSTFOCUS</tertiary></indexterm>
<indexterm><primary>Button class</primary><secondary>events</secondary><tertiary>PAINT</tertiary></indexterm>
<indexterm><primary>Button class</primary><secondary>events</secondary><tertiary>UNHILITE</tertiary></indexterm>
<para>
  The event handler for most of the button events receives the same arguments and is coded in the same fashion. When the
  handler is invoked is fairly clear from the name of the event. The CLICKED event handler is invoked when the button is
  clicked, etc..
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectButtonEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onButtonEvent unguarded
  use arg info, hwnd, id, notifyCode, buttonObj

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 5 arguments. The first and second arguments need to be retained for backwards
    compatibility, but the last 3 arguments are really what is needed:
  </para>
  <variablelist>
    <varlistentry><term>info</term>
    <listitem>
    <para>
      A numeric value that contains info about the event. The low order word contains the resource ID of the button sending
      the event. The high order word contains the button event code. However, the ooDialog framework now extracts these
      values for you and sends them as the third and fourth arguments.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window handle of the button that sent the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource id of the button sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>notifyCode</term>
    <listitem>
    <para>
      The numeric notification code of the event that caused the notification to be sent. Each dialog control has its own
      specific notification codes.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>controlObj</term>
    <listitem>
    <para>
      The Rexx button control object that represents the underlying dialog control that sent the notification. It is possible
      this will be the <computeroutput>.nil</computeroutput> object if some error happened, but this is very unlikely.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this notification. 0 makes a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example uses one event handler for all the push buttons in the application. It uses the <emphasis
    role="italic">id</emphasis> argument to determine which button was pushed:

<programlisting>
<![CDATA[
::method onButtonEvent unguarded
  use arg info, handle, id, notifyCode, pushButton

  select
    when id = .constDir[IDC_PB_SLEEP] then do
      reply 0
      pushButton~disable
      self~putToSleep
      pushButton~enable
      return
    end

  when id = .constDir[IDC_PB_LOAD] then do
    reply 0
    pushButton~disable
    self~loadNext
    pushButton~enable
    return
  end

  when id = .constDir[IDC_PB_REPORT] then do
    self~emailStatus
  end

    otherwise nop
  end

  ...

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End General Button Event Handler -->

<section id="evtButtonHOTITEM" xreflabel="HOTITEM"><title>HotItem Event Handler</title>
<indexterm><primary>Button class</primary><secondary>events</secondary><tertiary>HOTITEM</tertiary></indexterm>
<para>
  The event handler for the HOTITEM event is invoked when the user hovers the mouse over a button and when the user moves the
  mouse off of the area of a button.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectButtonEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onHotItem unguarded
  use arg id, entering, rxButton

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 3 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource id of the button sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>entering</term>
    <listitem>
    <para>
      This argument is always true or false. If true, the user has started hovering the mouse over the button. If false, the
      user was hovering the mouse and has now moved the mouse so it is no longer over the button.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>rxButton</term>
    <listitem>
    <para>
      The Rexx button object that represents the button sending the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the value of the return. 0 makes a good value to return.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example is from a program that has 2 buttons with the HOTITEM event connected to the same event handler.
    Each time the event handler is invoked it prints out some information about the event:

<programlisting>
<![CDATA[
::method onHover unguarded
  use arg id, entering, rxButton

  if entering then msg = 'mouse is entering'
  else msg = 'mouse is leaving'

  say 'onHover() button with id:' id msg
  ...
  return 0

/* Output might be:

  onHover() button with id: 1044 is entering
  onHover() button with id: 1044 is leaving
  onHover() button with id: 1001 is entering
  onHover() button with id: 1001 is leaving
*/
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End HotItem Event Handler -->

</section>  <!-- End EventNotification::connectButtonEvent() -->


<section id="mthConnectComboBoxEvent" xreflabel="connectComboBoxEvent"><title>connectComboBoxEvent</title>
<indexterm><primary>connectComboBoxEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectComboBoxEvent</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectComboBoxEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectComboBoxEvent(--id--,--event--+----------+--+--------------+--)-----><
                                         +-,--mName-+  +-,-willReply--+

]]>
</programlisting>

<para>
  Connects a method in the Rexx dialog to the Windows <xref linkend="ovvEvents"/> notification from a
  <xref linkend="clsComboBox"/> control.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The <xref linkend="defResourceId"/> of the combo box for which a notification is to be connected to a method.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event</term>
    <listitem>
    <para>
      Exactly one of the following key words, case is not significant, that specified the event to be connected with a
      method:
    </para>
    <variablelist>
      <varlistentry><term><link linkend="evtComboBoxGeneral">CHANGE</link></term>
      <listitem>
      <para>
        The text in the edit control has been altered. This notification is sent after Windows updated the screen.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtComboBoxGeneral">CLOSEUP</link></term>
      <listitem>
      <para>
        The list of the combo box has been closed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtComboBoxGeneral">DBLCLK</link></term>
      <listitem>
      <para>
        An entry in the combo box list has been selected with a double click.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtComboBoxGeneral">DROPDOWN</link></term>
      <listitem>
      <para>
        The list of the combo box is about to be made visible.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtComboBoxGeneral">ERRSPACE</link></term>
      <listitem>
      <para>
        An out-of-memory problem has occurred.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtComboBoxGeneral">GOTFOCUS</link></term>
      <listitem>
      <para>
        The combo box got the input focus.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtComboBoxGeneral">LOSTFOCUS</link></term>
      <listitem>
      <para>
        The combo box lost the input focus.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtComboBoxGeneral">SELCHANGE</link></term>
      <listitem>
      <para>
        Another entry in the combo box list has been selected.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtComboBoxGeneral">SELENDCANCEL</link></term>
      <listitem>
      <para>
        After the selection of another entry, another control or dialog was selected, which canceled the selection of the
        entry.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtComboBoxGeneral">SELENDOK</link></term>
      <listitem>
      <para>
        The list was closed after another entry was selected.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtComboBoxGeneral">UPDATE</link></term>
      <listitem>
      <para>
        The text in the edit control has been altered. This notification is sent before Windows updates the screen.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term>mName</term>
    <listitem>
    <para>
      The name of the method that is to be invoked whenever the specified notification is received from the combo control.
      Provide a method with a matching name. If you omit this argument, a method name is generated automatically. The name
      consists of the event keyword preceded by <computeroutput>on</computeroutput>. For instance:
      <computeroutput>onSelEndOk</computeroutput>. The method name can not be the empty string.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.false</computeroutput>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return codes are:
  </para>
  <variablelist>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The resource ID could not be resolved or the event argument is incorrect.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No errors were detected.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The message was not connected correctly.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example invokes method PlaySong whenever the list of the combo box with the resource ID of
    IDC_CB_PROFESSIONS is about to be made visible.  In this case IDC_CB_PROFESSIONS is a <xref
    linkend="defSymbolicId"/> ID that has been added to the <xref linkend="atrConstDir"/> directory of the MyDlgClass in
    another part of the program:

<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method initDialog
  self~connectComboBoxEvent("IDC_CB_PROFESSIONS", "DROPDOWN", "PlaySong")
]]>
</programlisting>

  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtComboBoxGeneral" xreflabel="General"><title>General ComboBox Event Handler</title>
<indexterm><primary>ComboBox class</primary><secondary>events</secondary><tertiary>CHANGE</tertiary></indexterm>
<indexterm><primary>ComboBox class</primary><secondary>events</secondary><tertiary>CLOSEUP</tertiary></indexterm>
<indexterm><primary>ComboBox class</primary><secondary>events</secondary><tertiary>DBLCLK</tertiary></indexterm>
<indexterm><primary>ComboBox class</primary><secondary>events</secondary><tertiary>DROPDOWN</tertiary></indexterm>
<indexterm><primary>ComboBox class</primary><secondary>events</secondary><tertiary>ERRSPACE</tertiary></indexterm>
<indexterm><primary>ComboBox class</primary><secondary>events</secondary><tertiary>GOTFOCUS</tertiary></indexterm>
<indexterm><primary>ComboBox class</primary><secondary>events</secondary><tertiary>LOSTFOCUS</tertiary></indexterm>
<indexterm><primary>ComboBox class</primary><secondary>events</secondary><tertiary>SELCHANGE</tertiary></indexterm>
<indexterm><primary>ComboBox class</primary><secondary>events</secondary><tertiary>SELENDCANCEL</tertiary></indexterm>
<indexterm><primary>ComboBox class</primary><secondary>events</secondary><tertiary>SELENDOK</tertiary></indexterm>
<indexterm><primary>ComboBox class</primary><secondary>events</secondary><tertiary>UPDATE</tertiary></indexterm>
<para>
  The event handler for all of the combo box events receives the same arguments and is coded in the same fashion. When the
  handler is invoked is fairly clear from the name of the event. The DROPDOWN event handler is invoked when the drop down
  arrow is pushed, etc..
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectComboBoxEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onComboBoxEvent unguarded
  use arg info, hwnd, id, notifyCode, comboBox

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 5 arguments. The first and second arguments need to be retained for backwards
    compatibility, but only the last 3 arguments are really needed:
  </para>
  <variablelist>
    <varlistentry><term>info</term>
    <listitem>
    <para>
      A numeric value that contains info about the event. The low order word contains the resource ID of the combo box
      sending the event. The high order word contains the combo box event code. The <xref linkend="mthLoWord"/> and <xref
      linkend="mthHiWord"/> methods of the <xref linkend="clsDlgUtil"/> class can be used to extract these values. However,
      the ooDialog framework now extracts those values for you and sends them as the third and fourth arguments.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window handle of the combo box that sent the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource id of the combo box sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>notifyCode</term>
    <listitem>
    <para>
      The numeric notification code of the event that caused the notification to be sent. Each dialog control has its own
      specific notification codes.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>controlObj</term>
    <listitem>
    <para>
      The Rexx combo box control object that represents the underlying dialog control that sent the notification. It is
      possible this will be the <computeroutput>.nil</computeroutput> object if some error happened, but this is very
      unlikely.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this notification. 0 makes a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example connects the CLOSEUP event of a combo box. The event handler checks if the item selected was
    Apple, and if it was, the selection is changed to Cherry:

<programlisting>
<![CDATA[
::method init

  ,,,

  self~connectComboBoxEvent(IDC_CB_DROPDOWNLIST, CLOSEUP, onCbCloseUp)

::method onCbCloseUp unguarded
  use arg info, hwnd, id, notifyCode, comboBox

  if comboBox~selected == 'Apple' then comboBox~select('Cherry')

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End General combo box Event Handler -->

</section>  <!-- End EventNotification::connectionComboBoxEvent() -->


<section id="mthConnectCommandEvents" xreflabel="connectCommandEvents"><title>connectCommandEvents</title>
<indexterm><primary>connectCommandEvents</primary><secondary>EventNotification class</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectCommandEvents</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectCommandEvents</secondary></indexterm>

<programlisting>
<![CDATA[
>>--connectCommandEvents(--id--,--methodName--+--------------+--)--------------><
                                              +-,-willReply--+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectCommandEvents</emphasis> method connects a Rexx dialog method to the command
  <xref linkend="ovvEvents"/> notifications sent by a Windows dialog control to its parent dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the dialog control, may be symbolic or numeric.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>methodName [required]</term>
    <listitem>
    <para>
      The name of the method to be invoked in the Rexx dialog object each time a command event occurs in the dialog
      control. The method name can not be the empty string.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.false</computeroutput>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The specified symbolic ID could not be resolved.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An error. Most likely, either the message table is full, or the interpreter is out of usable memory.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  <para>
    The number of different notification codes and the meanings of the notifications are dependent on the type of dialog
    control specified. Therefore, it is more advisable to use the specific connectXXXEvent() method for the control.
    Such as the <xref linkend="mthConnectListBoxEvent"/>() method.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
    <para>
      Syntax errors are raised when incorrect usage is detected.
    </para>
    <para>
      If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
      command events happen.
    </para>
    <para>
      In Windows itself, command events are sent to the parent dialog using the WM_COMMAND message.
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example connects list box command event notifications to the <emphasis role="italic">onEvent</emphasis> method of
    the dialog. Note that the notification code 1 corresponds to the list box SELCHANGE event, 4 is the SETFOCUS, and 5 is
    KILLFOCUS events.
<programlisting>
<![CDATA[

::method initDialog
  ...
  self~connectCommandEvents(IDC_LB_FILES, onEvent)


::method onEvent unguarded
  use arg info, hwnd, id, notifyCode, lb

  LBN_SELCHANGE = 1

  say 'Control ID:          ' id
  say 'Notification code:   ' notifyCode
  say 'Dialog control:      ' lb

  if notifyCode == LBN_SELCHANGE then do
    say 'Current selection is:' lb~selected
  end
  say


/* Output might be:

Control ID:           1003
Notification code:    4
Dialog control:       a ListBox

Control ID:           1003
Notification code:    1
Dialog control:       a ListBox
Current selection is: Bakersfield

Control ID:           1003
Notification code:    1
Dialog control:       a ListBox
Current selection is: San Jose

Control ID:           1003
Notification code:    1
Dialog control:       a ListBox
Current selection is: New York

Control ID:           1003
Notification code:    1
Dialog control:       a ListBox
Current selection is: Los Angles

*/
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtGeneralCOMMAND"><title>Connect COMMAND Event Handler</title>
<indexterm><primary>connectCommandEvent</primary><secondary>event handler</secondary></indexterm>
<para>
  The event handler connected through the <xref linkend="mthConnectCommandEvents"/> is invoked when ooDialog internally
  matches a message sent to the <xref linkend="ovvUnderlying"/> Windows dialog using the arguments specified to the <emphasis
  role="italic">connectCommandEvents</emphasis> method.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectCommandEvents"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onCommandEvent unguarded
  use arg wParam, lParam, id, notifyCode, controlObj

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    This event handling method receives five arguments. The <emphasis role="italic">wParam</emphasis> and <emphasis
    role="italic">lParam</emphasis> arguments have to be retained for backwards compatibility, but the last 3 arguments are
    really what are useful.
  </para>
  <variablelist>
    <varlistentry><term>wParam</term>
    <listitem>
    <para>
      The numeric value of the<link linkend="ovvWindowMessages">WPARAM</link> parameter sent with the window message that
      was connected through <emphasis role="italic">connectCommandEvents</emphasis>. This numeric value will contain the
      resource ID of the control sending the message and the numeric code of the event that caused the notification to be
      sent. However, the ooDialog framework extracts these values and sends them as the <emphasis role="italic">id</emphasis>
      and <emphasis role="italic">notifyCode</emphasis> arguments.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>lParam</term>
    <listitem>
    <para>
      The numeric value of the <link linkend="ovvWindowMessages">LPARAM</link> parameter sent with the window message that
      was connected through <emphasis role="italic">connectCommandEvents</emphasis>. The LPARAM value is always the window
      handle of the control sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource id of the dialog control sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>notifyCode</term>
    <listitem>
    <para>
      The numeric notification code of the event that caused the notification to be sent. It will be a notification code
      defined by the control. Note that notification codes do not have unique values. For example, the list box LBN_SETFOCUS
      notification code has the value of 4, as does the button's BN_DISABLED code.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>controlObj</term>
    <listitem>
    <para>
      The Rexx dialog control object that represents the underlying dialog control that sent the notification. If an error
      occurred, this will be the <computeroutput>.nil</computeroutput> object. It is very unlikely that an error will occur.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The command event notification is sent as a WM_COMMAND window message. In general the operating system ignores the
    return from a WM_COMMAND message. This makes 0 a good value to return. However, the MSDN documentation is the authority
    on what return value the operating system expects from a particular event notification and the ooDialog programmer should
    consult that documentation for a specific COMMAND event being connected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
   The example displays the 3 different types of combo box controls and shows all the event notifications sent from the combo
   boxes. The ::constant directive is used to define the numeric value of all notifications a combo box might possibly send
   and the <emphasis role="italic">connectCommandEvents</emphasis> method is used to connect all notifications to a single
   event handler. That event handler decodes each notification and displays it:

<programlisting>
<![CDATA[

::class 'ComboBoxTypes' subclass RcDialog

::constant CB_SIMPLE        1001
::constant CB_DROPDOWN      1003
::constant CB_DROPDOWNLIST  1005

::constant  CBN_ERRSPACE        -1
::constant  CBN_SELCHANGE       1
::constant  CBN_DBLCLK          2
::constant  CBN_SETFOCUS        3
::constant  CBN_KILLFOCUS       4
::constant  CBN_EDITCHANGE      5
::constant  CBN_EDITUPDATE      6
::constant  CBN_DROPDOWN        7
::constant  CBN_CLOSEUP         8
::constant  CBN_SELENDOK        9
::constant  CBN_SELENDCANCEL    10

::method init

  forward class (super) continue

  self~connectCommandEvents(IDC_CB_SIMPLE, onEvent, .true)
  self~connectCommandEvents(IDC_CB_DROPDOWN, onEvent, .true)
  self~connectCommandEvents(IDC_CB_DROPDOWNLIST, onEvent, .true)

::method onEvent unguarded
    use arg , , id, code, cb

    say 'id:  ' id
    say 'code:' code
    say 'cb:  ' cb

    select
      when id == self~CB_SIMPLE then cbName = 'The simple combo box'
      when id == self~CB_DROPDOWN then cbName = 'The drop down combo box'
      when id == self~CB_DROPDOWNLIST then cbName = 'The drop down list combo box'
      otherwise cbName = 'An error has occurred'
    end

    select
      when code == self~CBN_ERRSPACE     then msg = 'sent a error space notification message.'
      when code == self~CBN_SELCHANGE    then msg = 'sent a selection change notification message.'
      when code == self~CBN_DBLCLK       then msg = 'sent a double click notification message.'
      when code == self~CBN_SETFOCUS     then msg = 'sent a set focus notification message.'
      when code == self~CBN_KILLFOCUS    then msg = 'sent a kill focus notification message.'
      when code == self~CBN_EDITCHANGE   then msg = 'sent a edit change notification message.'
      when code == self~CBN_EDITUPDATE   then msg = 'sent a edit update notification message.'
      when code == self~CBN_DROPDOWN     then msg = 'sent a drop down notification message.'
      when code == self~CBN_CLOSEUP      then msg = 'sent a close up notification message.'
      when code == self~CBN_SELENDOK     then msg = 'sent a selection ended ok notification message.'
      when code == self~CBN_SELENDCANCEL then msg = 'sent a selection ended cancel notification message.'
      otherwise msg = 'processing the event notification.'
    end
    -- End select

    say cbName msg
    say

    return 0

/*  Output might be:

id:   1001
code: 3
cb:   a ComboBox
The simple combo box sent a set focus notification message.

id:   1001
code: 4
cb:   a ComboBox
The simple combo box sent a kill focus notification message.

id:   1003
code: 3
cb:   a ComboBox
The drop down combo box sent a set focus notification message.

id:   1003
code: 7
cb:   a ComboBox
The drop down combo box sent a drop down notification message.

id:   1003
code: 10
cb:   a ComboBox
The drop down combo box sent a selection ended cancel notification message.

id:   1003
code: 8
cb:   a ComboBox
The drop down combo box sent a close up notification message.

id:   1003
code: 10
cb:   a ComboBox
The drop down combo box sent a selection ended cancel notification message.
*/
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End WM_COMMAND message Event Handler -->


</section>

<section id="mthConnectDateTimePickerEvent" xreflabel="connectDateTimePickerEvent"><title>connectDateTimePickerEvent</title>
<indexterm><primary>connectDateTimePickerEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectDateTimePickerEvent</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectDateTimePickerEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectDateTimePickerEvent(--id-,-evt--+----------+-+------------+-)-------><
                                           +-,--mName-+ +-,-wilReply-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectDateTimePickerEvent</emphasis> method connects an <xref linkend="ovvEvents"/>
  notification message from a <xref linkend="clsDateTimePicker"/> control to a method in the Rexx dialog.
</para>
<para>
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the date time picker control. May be numeric or <xref linkend="defSymbolicId"/>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>evt [required]</term>
    <listitem>
    <para>
      Exactly one of the following keywords. The keyword specifies the event to be connected. For each event, the
      documentation for the event handler, <xref linkend="evtDateTimePickerCLOSEUP"/>), <xref
      linkend="evtDateTimePickerDATETIMECHANGE"/>, etc., will contain additional information about the event. Case is not
      significant:
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>CLOSEUP       </member>
        <member>DATETIMECHANGE</member>
        <member>DROPDOWN      </member>
        <member>FORMAT        </member>
        <member>FORMATQUERY   </member>
        <member>KEYDOWN       </member>
        <member>KILLFOCUS     </member>
        <member>SETFOCUS      </member>
        <member>USERSTRING    </member>
      </simplelist>
      <variablelist>
        <varlistentry><term><xref linkend="evtDateTimePickerCLOSEUP"/></term>
        <listitem>
        <para>
          Sent by a date and time picker (DTP) control when the user closes the drop-down month calendar. The month
          calendar is closed when the user chooses a date from the month calendar or clicks the drop-down arrow while
          the calendar is open. The return value from the event handler is ignored by the operating system for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtDateTimePickerDATETIMECHANGE"/></term>
        <listitem>
        <para>
          Sent by a date and time picker (DTP) control whenever a change occurs. The return value from the event
          handler is ignored by the operating system for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtDateTimePickerDROPDOWN"/></term>
        <listitem>
        <para>
          Sent by a date and time picker (DTP) control when the user activates the drop-down month calendar. The return
          value from the event handler is ignored by the operating system for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtDateTimePickerFORMAT"/></term>
        <listitem>
        <para>
          Sent by a date and time picker (DTP) control to request text to be displayed in a
          <link linkend="sctDTPCallback">callback</link> field. The <emphasis role="italic">willReply</emphasis> argument is
          ignored for this event, the event handler must <link linkend="sctCodingEventHandlers">return</link> a reply.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtDateTimePickerFORMATQUERY"/></term>
        <listitem>
        <para>
          Sent by a date and time picker (DTP) control to retrieve the maximum allowable size of the string that will be
          displayed in a <link linkend="sctDTPCallback">callback</link> field. The <emphasis
          role="italic">willReply</emphasis> argument is ignored for this event, the event handler must
          <link linkend="sctCodingEventHandlers">return</link> a reply.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtDateTimePickerKEYDOWN"/></term>
        <listitem>
        <para>
          Sent by a date and time picker (DTP) control when the user types in a <link
          linkend="sctDTPCallback">callback</link> field. The <emphasis role="italic">willReply</emphasis> argument is
          ignored for this event, the event handler must <link linkend="sctCodingEventHandlers">return</link> a reply.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtDateTimePickerKILLFOCUS"/></term>
        <listitem>
        <para>
          Notifies a date and time picker control's parent window, (which is the dialog window,) that the control has
          lost the input focus. The return value from the event handler is ignored by the operating system for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtDateTimePickerSETFOCUS"/></term>
        <listitem>
        <para>
          Notifies a date and time picker control's parent window, (which is the dialog window,) that the control has
          received the input focus. The return value from the event handler is ignored by the operating system for this
          event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtDateTimePickerUSERSTRING"/></term>
        <listitem>
        <para>
          Sent by a date and time picker (DTP) control when a user finishes editing a string in the control. This
          notification message is only sent by DTP controls that have the CANPARSE style. The <emphasis
          role="italic">willReply</emphasis> argument is ignored for this event, the event handler must
          <link linkend="sctCodingEventHandlers">return</link> a reply.
        </para>
        </listitem></varlistentry>
      </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mName [optional]</term>
    <listitem>
    <para>
      The name of the method that is to be invoked whenever the specified notification is received from the date time
      picker control. The programmer defines this method. If this argument is omitted, a method name is automatically
      generated that consists of the event keyword preceded by <computeroutput>on</computeroutput>. For instance,
      <computeroutput>onCloseUp</computeroutput>. If the method name is supplied, it can not be the empty string.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.true</computeroutput>.
    </para>
    <para>
      However, this argument is ignored for the USERSTRING, KEYDOWN, FORMAT, and FORMATQUERY events. If the programmer
      connects any of these events, the interpreter waits for the returned value from the connected method. That value is
      then returned to the operating system. This can not be changed.
    </para>
    </listitem>
    </varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    This method returns <computeroutput>.true</computeroutput> if the event notification was connected correctly,
    otherwise <computeroutput>.false</computeroutput> .
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected, including the use of an invalid symbolic ID or an
    unrecognized event keyword.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if the
    connected event happens.
  </para>
  <para>
    The underlying dialog receives the DTN_* messages as the notifications for the date time picker events.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example creates a DTP control in the dialog template of a <computeroutput>UserDialog</computeroutput>
    and then connects the drop down and close up events:
  </para>
<programlisting>
<![CDATA[

::method defineDialog

  self~createDateTimePicker(IDC_DTP_REPORT_DATE,  10, 7, 280, 15, "BORDER SHORT SHOWNONE")

  self~createPushButton(IDOK, 85, 74, 50, 14, "DEFAULT", "Ok")
  self~createPushButton(IDCANCEL, 140, 74, 50, 14, , "Cancel")

  self~connectDateTimePickerEvent(IDC_DTP_REPORT_DATE, "CLOSEUP", onCloseUp)
  self~connectDateTimePickerEvent(IDC_DTP_REPORT_DATE, "DROPDOWN", onDropDown)

]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>

<section id="evtDateTimePickerCLOSEUP" xreflabel="CLOSEUP"><title>CloseUp Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>CLOSEUP</secondary></indexterm>
<para>
  The event handler for the close up event is invoked when the user closes the drop-down month calendar. The month
  calendar is closed when the user chooses a date from the month calendar or clicks the drop-down arrow while the
  calendar is open.
</para>
<para>
  The programmer can specify for the interpreter to wait, or not wait, for the return from the event handler by
  using the <emphasis role="italic">willReply</emphasis> argument in the
 <xref linkend="mthConnectDateTimePickerEvent"/> method. The actual value returned from the
  event handler is ignored.
</para>
<para>
  This event notification signals that the DTP control has destroyed the child month calendar control. The DTP control
  creates a new month calendar each time the month calendar needs to be shown and destroys it each time the drop-down is
  closed. The close up notification is sent when the month calendar is destroyed.
</para>
<para>
  The programmer may have instantiated a Rexx month calendar object during the
   <xref linkend="evtDateTimePickerDROPDOWN"/> event notification. Once the underlying Windows month calendar is
  destroyed, the Rexx <computeroutput>MonthCalendar</computeroutput> is no longer valid.
</para>

<programlisting>
<![CDATA[
::method onCloseUp unguarded
  use arg idFrom, hwndFrom, code, dtpObj

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives r arguments:
  </para>
  <variablelist>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>code</term>
    <listitem>
    <para>
      The date time picker event code the caused the event notification to be sent.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dtpObj</term>
    <listitem>
    <para>
      The Rexx date time picker object that represents the date time picker control that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The return value from the event handler is ignored by the operating system.  0 makes a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following is an example event handler for the close up event. When the close up happens, the user may or may not
    have changed the selected date.  The example checks if a new data has been selected and does something if it has
    been changed:

<programlisting>
<![CDATA[

::method onCloseUp unguarded
  expose lastChange
  use arg id, hwnd, code, dtp

  newDate = dtp~getDateTime
  if newDate \= lastChange then do
    lastChange = newDate
    self~updateDateInfo(newDate)
  end

  return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End CloseUp Event Handler -->


<section id="evtDateTimePickerDATETIMECHANGE" xreflabel="DATETIMECHANGE"><title>DateTimeChange Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>DATETIMECHANGE</secondary></indexterm>
<para>
  The event handler for the date time change event is invoked whenever a change in the underlying DTP control takes
  place
</para>
<para>
  The programmer can specify for the interpreter to wait, or not wait, for the return from the event handler by
  using the <emphasis role="italic">willReply</emphasis> argument in the
 <xref linkend="mthConnectDateTimePickerEvent"/> method. The actual value returned from the
  date time change event handler is ignored.
</para>

<programlisting>
<![CDATA[
::method onDateTimeChange unguarded
  use arg dateTime, valid, idFrom, hwndFrom, code, dtpObj

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 6 arguments:
  </para>
  <variablelist>
    <varlistentry><term>dateTime</term>
    <listitem>
    <para>
      The <emphasis role="italic">dateTime</emphasis> argument is a <computeroutput>DateTime</computeroutput> object.
      When the <emphasis role="italic">valid</emphasis> argument is true, <emphasis role="italic">dateTime</emphasis>
      specifies the new displayed date and time in the DTP control. When <emphasis role="italic">valid</emphasis> is
      false, <emphasis role="italic">dateTime</emphasis> will be the exact date and time that the notification was
      received.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>valid</term>
    <listitem>
    <para>
      True or false indicating whether the date time change is valid or not. <emphasis role="italic">valid</emphasis>
      can only be false when the DTP control has the SHOWNONE style and the user has unchecked the check box to indicate
      that no date and time is currently selected.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>code</term>
    <listitem>
    <para>
      The date time picker event code the caused the event notification to be sent.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dtpObj</term>
    <listitem>
    <para>
      The Rexx date time picker object that represents the date time picker control that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The return from the event handler is ignored. Returning 0 is sensible.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example updates a static control with the currently selected date and time whenever the user changes
    the date and time:

<programlisting>
<![CDATA[

::method initDialog
  expose dtp staticMsg

  self~connectDateTimePickerEvent(IDC_DTP, "DATETIMECHANGE", onChange)

  dtp = self~newDateTimePicker(IDC_DTP);
  dtp~setFormat("hh':'mm':'ss dddd MMM dd', 'yyyy")

  staticMsg = self~newStatic(IDC_ST1)
  ...

::method onChange unguarded
  expose staticMsg
  use arg dateTime, valid, idFrom, hwndFrom

  if valid then do
    sf = .SimpleFormatter~new(dateTime)
    staticMsg~setText(sf~time 'on' sf~date)
  end
  else do
    staticMsg~setText("No valid date selected.")
  end

  return 0

::class 'SimpleFormatter' public

::method init
  expose dateTime
  use strict arg dateTime

::method date
  expose dateTime

  dayNum = dateTime~usaDate~substr(4, 2)~strip('L', '0')
  year = dateTime~standardDate~left(4)

  return dateTime~dayName || ',' dateTime~monthName dayNum || ',' year

::method time
  expose dateTime

  return dateTime~civilTime

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End DateTimeChange Event Handler -->


<section id="evtDateTimePickerDROPDOWN" xreflabel="DROPDOWN"><title>DropDown Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>DROPDOWN</secondary></indexterm>
<para>
  The event handler for the drop down event is invoked when the user activates the drop down month calendar. The DTP
  control sends the notification for the event after it has created the child month calendar control.
</para>
<para>
  The programmer can specify for the interpreter to wait, or not wait, for the return from the event handler by
  using the <emphasis role="italic">willReply</emphasis> argument in the
 <xref linkend="mthConnectDateTimePickerEvent"/> method. The actual value returned from the
  event handler for the drop down event is ignored.
</para>

<programlisting>
<![CDATA[
::method onDropDown unguarded
  use arg idFrom, hwndFrom, code, dtpObj

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The drop down event handler receives 4 arguments:
  </para>
  <variablelist>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>code</term>
    <listitem>
    <para>
      The date time picker event code the caused the event notification to be sent.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dtpObj</term>
    <listitem>
    <para>
      The Rexx date time picker object that represents the date time picker control that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The return from the event handler is ignored. Returning 0 is sensible.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    One reason for handling the drop down event is to adjust the style of the month calendar control when it is
    displayed. Note that the DTP control creates the child month calendar control when it is needed and destroys the
    month calendar when the drop down is closed up. Therefore you can not save a reference to the month calendar object
    and use it later. When the <xref linkend="ovvUnderlying"/> month calendar control is destroyed the
    Rexx month calendar object is no longer valid.
  </para>
  <para>
    In Windows Vista and later versions of Windows, the DTP control has the <xref linkend="mthSetMonthCalStyle"/> method
    which can be used to set the month calendar's style once and the DTP control will then use that style each time it
    creates the month calendar. Therefore, the technique of setting the month calendar style during the drop down event
    handler is really only needed for Windows XP and earlier.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example demonstrates how to change the month calendar style in the drop down event handler. If the
    operating system the program is running on is Vista or later, the whole process is bypassed:

<programlisting>
<![CDATA[

::method initDialog
  dtp = self~newDateTimePicker(IDC_DTP_APPOINTMENT_TIME);

  if .OS~isAtLeastVista then do
    dtp~setMonthCalStyle("NOCIRCLE NOTRAILING")
  end
  else
    self~connectDateTimePickerEvent(IDC_DTP_APPOINTMENT_TIME, "DROPDOWN", onDropDown)
  do
  ...

::method onDropDown unguarded
  use arg idFrom, hwndFrom, code, dtp

  -- We know this is not Vista or later, othewise we would not
  -- have gotten the event notification.

  mc = dtp~getMonthCal
  mc~replaceStyle('DAYSTATE MULTI WEEKNUMBERS', "NOCIRCLE NOTODAY")

  return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End DropDown Event Handler -->

<section id="evtDateTimePickerFORMAT" xreflabel="FORMAT"><title>Format Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>FORMAT</secondary></indexterm>
<para>
  The event handler for the format event is invoked when the DTP control requests the text to be displayed in a
  <link linkend="sctDTPCallback">callback</link> field.
</para>
<para>
  The programmer must return the text to display for the callback field and the interpreter waits for this return. This
  behaviour can not be changed.
</para>

<programlisting>
<![CDATA[
::method onFormat unguarded
  use arg field, dateTime, idFrom, hwndFrom, code, dtpObj

  return text
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 6 arguments:
  </para>
  <variablelist>
    <varlistentry><term>field</term>
    <listitem>
    <para>
      The text of the callback field identifier.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dateTime</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the currently displayed date and time in the DTP
      control.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>code</term>
    <listitem>
    <para>
      The date time picker event code the caused the event notification to be sent.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dtpObj</term>
    <listitem>
    <para>
      The Rexx date time picker object that represents the date time picker control that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The text to display for the specified callback field. The text must be no longer than 63 characters or a syntax
    condition is raised.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The <computeroutput>FORMAT</computeroutput>, <xref linkend="evtDateTimePickerFORMATQUERY"/>, and <xref
    linkend="evtDateTimePickerKEYDOWN"/> event notifications all work together to provide the functionality for call back
    fields. It is a little difficult to grasp the concepts from small snippets of code, so a complete example program is
    included in the ooDialog samples: <computeroutput>samples\oodialog\controls\fiscalReports.rex</computeroutput>.
  </para>
  <para>
    This is an example FORMAT event handler. It comes from the complete
    <computeroutput>fiscalReports.rex</computeroutput> program:

<programlisting>
<![CDATA[

::method onFormat unguarded
  expose periods types currentType currentPeriod
  use arg field, dt, id, hwnd

  select
    when field == 'XX' then do
      ret = self~getPeriodNumber(dt)
    end

    when field == 'XXX' then do
      ret = periods[currentPeriod]
    end

    otherwise do
      ret = types[currentType]
    end
  end
  -- End select

  return ret

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Format Event Handler -->


<section id="evtDateTimePickerFORMATQUERY" xreflabel="FORMATQUERY"><title>FormatQuery Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>FORMATQUERY</secondary></indexterm>
<para>
  The event handler for the format query event is invoked when the DTP control requests the maximum size needed to
  display a string in a <link linkend="sctDTPCallback">callback</link> field.
</para>
<para>
  The programmer must fill in a <xref linkend="clsSize"/> object with the maximum size needed and return a
  value from the event handler. The interpreter waits for this return. This behavior can not be changed.
</para>

<programlisting>
<![CDATA[
::method onFormatQuery unguarded
  use arg field, size, id, hwnd, code, dtpObj

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 6 arguments:
  </para>
  <variablelist>
    <varlistentry><term>field</term>
    <listitem>
    <para>
      The text of the callback field identifier.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>size</term>
    <listitem>
    <para>
      A <computeroutput>Size</computeroutput> object that is set to the maximum size required to display the
      string in the call back field.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>code</term>
    <listitem>
    <para>
      The date time picker event code the caused the event notification to be sent.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dtpObj</term>
    <listitem>
    <para>
      The Rexx date time picker object that represents the date time picker control that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The actual value returned from the event handler is ignored by the operating system. Rather the return signals the
    operating system that the <emphasis role="italic">size</emphasis> argument is now valid to access, and the OS can
    use its values. Returning zero is sensible.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The <computeroutput>FORMATQUERY</computeroutput>, <xref linkend="evtDateTimePickerFORMAT"/>, and <xref
    linkend="evtDateTimePickerKEYDOWN"/> event notifications all work together to provide the functionality for call back
    fields. It is a little difficult to grasp the concepts from small snippets of code, so a complete example program is
    included in the ooDialog samples: <computeroutput>samples\oodialog\controls\fiscalReports.rex</computeroutput>.
  </para>
  <para>
    The following example FORMATQUERY event handler comes from that example program:

<programlisting>
<![CDATA[

::method onFormatQuery unguarded
  expose haveSizes xxSize xxxSize xxxxSize
  use arg field, size, id, hwnd, code, dtp

  if \ haveSizes then do
    xxSize  = self~calcSize('XX')
    xxxSize = self~calcSize('XXX')
    xxxxSize = self~calcSize('XXXX')
    haveSizes = .true
  end

  -- The equateTo() method sets the cx and cy attributes of the receiver .Size
  -- object to the cx and cy attributes of the argument .Size object.
  select
    when field == 'XX' then size~equateTo(xxSize)
    when field == 'XXX' then size~equateTo(xxxSize)
    otherwise size~equateTo(xxxxSize)
  end
  -- End select

  return 0


]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End FormatQuery Event Handler -->


<section id="evtDateTimePickerKEYDOWN" xreflabel="KEYDOWN"><title>KeyDown Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>KEYDOWN</secondary></indexterm>
<para>
  The event handler for the key down event is invoked when the user types a key in a
  <link linkend="sctDTPCallback">callback</link> field.
</para>
<para>
  The programmer must return a <computeroutput>DateTime</computeroutput> object and the interpreter waits for this
  return. This behavior can not be changed.
</para>

<programlisting>
<![CDATA[
::method onKeyDown unguarded
  use arg field, dateTime, vKey, idFrom, hwndFrom, code, dtpObj

  return dateTime
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 7 arguments:
  </para>
  <variablelist>
    <varlistentry><term>field</term>
    <listitem>
    <para>
      The text of the callback field identifier.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dateTime</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the currently displayed date and time in the DTP
      control.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>vKey</term>
    <listitem>
    <para>
      The virtual key code of the key the user typed in the call back field. The <xref linkend="clsVK"/> class
      can be used to map the numeric key code to a symbol, making it easier to work with the codes.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>code</term>
    <listitem>
    <para>
      The date time picker event code the caused the event notification to be sent.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dtpObj</term>
    <listitem>
    <para>
      The Rexx date time picker object that represents the date time picker control that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The programmer returns a <computeroutput>DateTime</computeroutput> object. If the return is a date / time different
    than the <emphasis role="italic">dateTime</emphasis> argument, the DTP control's date / time is updated. If it is he
    same, then no action is taken by the DTP control.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    By examining the <emphasis role="italic">dateTime</emphasis> and <emphasis role="italic">vKey</emphasis> arguments
    the programmer can produce custom responses to the user's typed keys. The custom response is achieved by returning a
    <computeroutput>DateTime</computeroutput> object that specifies a different date than the currently displayed date.
    For instance, if the currently displayed date is 8:00 am July 4th 1998 and the user types the <emphasis
    role="italic">home</emphasis> key, the programmer could return a date of 12:00 am January 1st 1998 to set the DTP
    control's display to the first of January in 1998. Likewise, if the user typed the <emphasis
    role="italic">end</emphasis> key the programmer could return December 31 1998 at 11:59 pm to set the display to the
    end of the current year.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The <computeroutput>KEYDOWN</computeroutput>, <xref linkend="evtDateTimePickerFORMAT"/>, and <xref
    linkend="evtDateTimePickerFORMATQUERY"/> event notifications all work together to provide the functionality for call
    back fields. It is a little difficult to grasp the concepts from small snippets of code, so a
    complete example program is included in the ooDialog samples:
    <computeroutput>samples\oodialog\controls\fiscalReports.rex</computeroutput>.
  </para>
  <para>
    The following example shows the KEYDOWN event handler from the <computeroutput>fiscalReports.rex</computeroutput>
    example program:

<programlisting>
<![CDATA[

::method onKeyDown unguarded
  use arg field, dt, vKey, idFrom, hwndFrom, code, dtpObj

  select
    when field == 'XX' then do
      newDT = self~updatePeriodNumber(dt, vKey)
    end

    when field == 'XXX' then do
      newDT = self~updatePeriod(dt, vKey)
    end

    otherwise do
      newDT = self~updateReport(dt, vKey)
    end
  end
  -- End select

  return newDT

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End KEYDOWN Event Handler -->


<section id="evtDateTimePickerKILLFOCUS" xreflabel="KILLFOCUS"><title>KillFocus Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>KILLFOCUS</secondary></indexterm>
<para>
  The event handler for the kill focus event is invoked when the DTP control loses the input focus.
</para>
<para>
  The programmer can specify for the interpreter to wait, or not wait, for the return from the event handler by
  using the <emphasis role="italic">willReply</emphasis> argument in the
 <xref linkend="mthConnectDateTimePickerEvent"/> method. The actual value returned from the
  event handler for the kill focus event is ignored.
</para>

<programlisting>
<![CDATA[
::method onKillFocus unguarded
  use arg idFrom, hwndFrom, code, dtpObj

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The kill focus event handler receives 4 arguments:
  </para>
  <variablelist>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>code</term>
    <listitem>
    <para>
      The date time picker event code the caused the event notification to be sent.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dtpObj</term>
    <listitem>
    <para>
      The Rexx date time picker object that represents the date time picker control that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The return from the event handler is ignored. Returning 0 is sensible.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End KillFocus Event Handler -->


<section id="evtDateTimePickerSETFOCUS" xreflabel="SETFOCUS"><title>SetFocus Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>SETFOCUS</secondary></indexterm>
<para>
  The event handler for the set focus event is invoked when the DTP control gains the input focus.
</para>
<para>
  The programmer can specify for the interpreter to wait, or not wait, for the return from the event handler by
  using the <emphasis role="italic">willReply</emphasis> argument in the
 <xref linkend="mthConnectDateTimePickerEvent"/> method. The actual value returned from the
  event handler for the set focus event is ignored.
</para>

<programlisting>
<![CDATA[
::method onSetFocus unguarded
  use arg idFrom, hwndFrom, code, dtpObj

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The set focus event handler receives 4 arguments:
  </para>
  <variablelist>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>code</term>
    <listitem>
    <para>
      The date time picker event code the caused the event notification to be sent.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dtpObj</term>
    <listitem>
    <para>
      The Rexx date time picker object that represents the date time picker control that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The return from the event handler is ignored. Returning 0 is sensible.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End SetFocus Event Handler -->

<section id="evtDateTimePickerUSERSTRING" xreflabel="USERSTRING"><title>UserString Event Handler</title>
<indexterm><primary>DateTimePicker Event</primary><secondary>USERSTRING</secondary></indexterm>
<para>
  The event handler for the USERSTRING event is invoked when the user has finished editing a string in the DTP control.
  This event notification only occurs when the DTP control has the CANPARSE style.
</para>
<para>
  The programmer must return a value from the event handler and the interpreter waits for this return. This behavior can
  not be changed.
</para>

<programlisting>
<![CDATA[
::method onUserString unguarded
  use arg dateTime, userStr, idFrom, hwndFrom, code, dtpObj

  return newDateTime
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 6 arguments:
  </para>
  <variablelist>
    <varlistentry><term>dateTime</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that reflects the date and time the DTP control is currently
      displaying.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>userStr</term>
    <listitem>
    <para>
      The string the user has just finished typing into the DTP control.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>idFrom</term>
    <listitem>
    <para>
      The <emphasis role="italic">idFrom</emphasis> argument is the resource ID of the date time picker that generated
      the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the date and time picker.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>code</term>
    <listitem>
    <para>
      The date time picker event code the caused the event notification to be sent.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dtpObj</term>
    <listitem>
    <para>
      The Rexx date time picker object that represents the date time picker control that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The event handler must return a <computeroutput>DateTime</computeroutput> object or the
    <computeroutput>.nil</computeroutput> object.
  </para>
  <para>
    After parsing the user string, the programmer returns a new <computeroutput>DateTime</computeroutput> object that
    reflects the new date and time the DTP control should display. If the returned
    <computeroutput>DateTime</computeroutput> object reflects the exact same date and time as the <emphasis
    role="italic">dateTime</emphasis> argument, then the DTP control takes no action. Otherwise, the DTP control updates
    its display to the new date and time.
  </para>
  <para>
    If, and only if, the DTP control has the SHOWNONE style, the programmer can return the
    <computeroutput>.nil</computeroutput> object to change the date and time to <emphasis role="italic">no date and
    time</emphasis> selected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This event notification allows the programmer to provide a custom response to what the user types into the DTP
    control's display field. The programmer parses the string entered by the user and then updates the DTP control in a
    way that corresponds to the entered string.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The distribution of the ooDialog framework contains an example program:
    <computeroutput>samples\oodialog\controls\userStringDTP.rex</computeroutput> that focuses on the USERSTRING
    notification. This example is a portion of the event handler for the USERSTRING event from that program.
  </para>
  <para>
    The DTP control in the program is initially set to the current system date and time. Naturally, as the program runs,
    the system date and time continue to advance. It would be difficult for the user to reset the DTP control to the
    current system date and time, so the program allows the user to type a <emphasis role="italic">r</emphasis> or a
    <emphasis role="italic">c</emphasis> in the DTP to reset its display to the current system date and time:

<programlisting>
<![CDATA[

::method onUserString unguarded
  expose resetting stInvalid
  use arg dt, userStr, id, hwnd, code, dtpObj

  stInvalid~setText('')

  -- Check for the shortcut to set the DTP to the current date and time.
  upStr = userStr~upper
  if upStr == 'C' | upStr == 'R' | upStr == 'CANCEL' | upStr == 'RESET' then do
    resetting = .true
    return .DateTime~new
  end

  ...

  return newDT

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End UserString Event Handler -->

</section>  <!-- End EventNotification::connectDateTimePickerEvent() -->


<section id="mthConnectDraw" xreflabel="connectDraw"><title>connectDraw</title>
<indexterm><primary>connectDraw</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectDraw</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectDraw</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectDraw--(--+-----+--+---------------+--+--------------+--)--------------><
                    +--id-+  +-,-methodName--+  +-,-willReply--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectDraw</emphasis> method connects the draw control event notification with a method
  in the Rexx dialog. This notification is sent to the underlying dialog by an owner-drawn button, combo box, list box,
  static, or menu, when a visual aspect of the control or menu has changed. In addition, if a tab control or a list-view have
  the owner draw fixed style, they also receive the notification.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [optional]</term>
      <listitem>
      <para>
        The resource ID of the dialog control whose notification is being connected. This can be symbolic or numeric. If
        the ID is omitted, all drawing event notifications, of all owner-drawn controls in the dialog, will invoke the
        method.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>methodName [optional]</term>
      <listitem>
      <para>
        The name of the method that is to be invoked each time the draw control event occurs. The method name must not be
        the empty string. If this argument is omitted, then the ooDialog framework will connect the notification to the
        <computeroutput>onDraw</computeroutput> method.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>willReply [optional]</term>
      <listitem>
      <para>
        The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
        handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
        <computeroutput>.false</computeroutput>.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The specified symbolic ID could not be resolved.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The notification was not connected correctly.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The notification for the draw control is only sent to the above mentioned controls when they have the OWNERDRAW or
    OWNERDRAWFIXED styles. The notification itself is to inform the application that it needs to draw the control at this
    time. Note that the ooDialog framework is not well suited to drawing operations and it is unlikely that this notification
    is of much use except when the drawing to be done is not very complex.
  </para>
  <para>
    Prior to ooDialog 4.2.4, the arguments sent to the event handler for this connection were not helpful in attempting to do
    owner draw. The arguments now sent to the event handler will make the task easier and ambitious programmers may want to
    try owner draw in medium complex applications. <emphasis role="bold">Note</emphasis> however that the <emphasis
    role="italic">willReply</emphasis> argument must be set to <computeroutput>.true</computeroutput> or <emphasis
    role="italic">SYNC</emphasis> or the drawing efforts will produce highly unpredictable results.
  </para>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    draw events happen.
  </para>
  <para>
    In Windows itself, the dialog receives this event notification as a WM_DRAWITEM message.
  </para>
  </listitem></varlistentry>
</variablelist>


<section id="evtEventNotificationDRAW" xreflabel="DRAW"><title>Draw Event Handler</title>
<indexterm><primary>EventNotification class</primary><secondary>events</secondary><tertiary>DRAW</tertiary></indexterm>
<para>
  The event handler for the Draw event is invoked when a button, combo box, list box, or menu, with the owner-draw style,
  needs to be redrawn.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectDraw"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onDraw unguarded
  use arg id, lp, drawObj, itemID, flags, hDC, rcItem, itemData

  return .true
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 8 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the control that needs to be drawn. This value is not valid for menu items
    </para>
    </listitem></varlistentry>
    <varlistentry><term>lp</term>
    <listitem>
    <para>
      The numeric value of a pointer to a memory location. This is of no use to the ooDialog programmer. There is no way to
      access the data the pointer points to from the ooDialog program. This argument is retained for backwards compatibility.
      The following arguments contain the values of the data the pointer points to. They are the important arguments.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>drawObj</term>
    <listitem>
    <para>
      The Rexx dialog control object that represents the control that needs to be drawn. If it is a menu item that needs to
      be drawn, this may be the <computeroutput>.nil</computeroutput> object. <emphasis role="bold">Please Note:</emphasis>
      In future versions of ooDialog this may be the Rexx menu object that contains the menu item needing to be drawn.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>itemID</term>
    <listitem>
    <para>
      The menu item ID for a menu item or the one-based index of the item in a list box or combo box. For an empty list box
      or combo box, this member can be 0. This allows the application to draw only the focus rectangle at the coordinates
      specified by the rcItem member even though there are no items in the control. This indicates to the user whether the
      list box or combo box has the focus. Which keywords are present in the <emphasis role="italic">flags</emphasis>
      determines whether the rectangle is to be drawn as though the list box or combo box has the focus.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>flags</term>
    <listitem>
    <para>
      A list of the following keywords separated by spaces, case is not significant. The keywords are separated into 3
      groups, type, action, and state. The keywords in the same group all start with the same prefix, ODT_ for type, ODA_ for
      action, and ODS_ for state. The list will contain at least one keyword from the type group. The keywords provide
      information that allows the application to determine what drawing operation needs to be done:
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>ODT_BUTTON       </member>
        <member>ODT_COMBOBOX     </member>
        <member>ODT_HEADER       </member>
        <member>ODT_LISTBOX      </member>
        <member>ODT_LISTVIEW     </member>
        <member>ODT_MENU         </member>
        <member>ODT_STATIC       </member>
        <member>ODT_TAB          </member>
        <member>ODT_UNKNOWN      </member>
        <member>ODA_DRAWENTIRE   </member>
        <member>ODA_FOCUS        </member>
        <member>ODA_SELECT       </member>
        <member>ODS_CHECKED      </member>
        <member>ODS_COMBOBOXEDIT </member>
        <member>ODS_DEFAULT      </member>
        <member>ODS_DISABLED     </member>
        <member>ODS_FOCUS        </member>
        <member>ODS_GRAYED       </member>
        <member>ODS_HOTLIGHT     </member>
        <member>ODS_INACTIVE     </member>
        <member>ODS_NOACCEL      </member>
        <member>ODS_NOFOCUSRECT  </member>
        <member>ODS_SELECTED     </member>
      </simplelist>
      <variablelist>
        <varlistentry><term>ODT_BUTTON</term>
        <listitem>
        <para>
          An owner-drawn button is sending the notification.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODT_COMBOBOX</term>
        <listitem>
        <para>
          A owner-drawn combo box is sending the notification.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODT_HEADER</term>
        <listitem>
        <para>
          A header control is sending the notification. It is unlikely this keyword will ever be seen. ooDialog does not yet
          have support for header controls and MSDN does not document this.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODT_LISTBOX</term>
        <listitem>
        <para>
          An owner-drawn list box is sending the notification.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODT_LISTVIEW</term>
        <listitem>
        <para>
          A list-view is sending the notification.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODT_MENU</term>
        <listitem>
        <para>
          An owner-drawn menu item is sending the notification.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODT_STATIC</term>
        <listitem>
        <para>
          An owner-drawn static control is sending the notification.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODT_TAB</term>
        <listitem>
        <para>
          A tab control is sending the notification.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODT_UNKNOWN</term>
        <listitem>
        <para>
          The notification was sent by something unexpected to the ooDialog framework. It is doubtful that this keyword will
          ever be seen.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODA_DRAWENTIRE</term>
        <listitem>
        <para>
          The entire control needs to be drawn.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODA_FOCUS</term>
        <listitem>
        <para>
          The control has lost or gained the keyboard focus. The state keywords should be checked to determine whether the
          control has the focus.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODA_SELECT</term>
        <listitem>
        <para>
          The selection status has changed. The state keywords should be checked to determine the new selection state.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODS_CHECKED</term>
        <listitem>
        <para>
          The menu item is to be checked. This keyword is used only in a menu.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODS_COMBOBOXEDIT</term>
        <listitem>
        <para>
          The drawing takes place in the selection field (edit control) of an owner-drawn combo box.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODS_DEFAULT</term>
        <listitem>
        <para>
          The item is the default item.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODS_DISABLED</term>
        <listitem>
        <para>
          The item is to be drawn as disabled.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODS_FOCUS</term>
        <listitem>
        <para>
          The item has the keyboard focus.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODS_GRAYED</term>
        <listitem>
        <para>
          The item is to be grayed. This keyword is used only in a menu.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODS_HOTLIGHT</term>
        <listitem>
        <para>
          The item is being hot-tracked, that is, the item will be highlighted when the mouse is on the item.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODS_INACTIVE</term>
        <listitem>
        <para>
          The item is inactive and the window associated with the menu is inactive.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODS_NOACCEL</term>
        <listitem>
        <para>
          The control is drawn without the keyboard accelerator cues.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODS_NOFOCUSRECT</term>
        <listitem>
        <para>
          The control is drawn without focus indicator cues.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ODS_SELECTED</term>
        <listitem>
        <para>
          The menu item's status is selected.
        </para>
        </listitem></varlistentry>
      </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hDC</term>
    <listitem>
    <para>
      The <xref linkend="defDeviceContext"/> for the drawing area. This device context must be used to do the drawing. It is
      passed by the operating system and <emphasis role="italic">must not</emphasis> freed by the application. In addition,
      upon return from the event handler, the device context must be set back to the same state it was on entry to the event
      handler.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>rcItem</term>
    <listitem>
    <para>
      A <xref linkend="clsRect"/> object that defines the boundaries of the control to be drawn. This rectangle is in the
      device context specified by the <emphasis role="italic">hDC</emphasis> argument. The operating system automatically
      clips anything that the owner window draws in the device context for combo boxes, list boxes, and buttons, but does not
      clip menu items. When drawing menu items, the owner window must not draw outside the boundaries of the rectangle
      defined by this argument.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>itemData</term>
    <listitem>
    <para>
      The item data associated with the menu item or control, or the <computeroutput>.nil</computeroutput> object when there
      is no item data. Menu items and many dialog controls allow the application to associate a user object with each item.
      However, ooDialog does not completely support this at this time. For instance, the <xref
      linkend="mthGetItemDataClsListView"/> and <xref linkend="mthSetItemDataClsListView"/> methods support associating user
      objects with the list-view items. But the support has not yet been added to combo boxes and list boxes. Because of
      this, it is likely that the <emphasis role="italic">itemData</emphasis> argument will usually be the
      <computeroutput>.nil</computeroutput> object.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The MSDN documentation says that the event handler should return true when the application has handled the DRAW event
    notification. Which implies that false should be returned otherwise. Therefore, the ooDialog programmer should probably
    return true from the event handler. However, some experimentation with returning false has not shown any discernable
    difference than returning true.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Although this documentation says the device context passed in the <emphasis role="italic">hDC</emphasis> argument
    must be used to do the drawing in the event handler, ooDialog has examples that did not do this. Examples written prior
    to ooDialog 4.2.0 did not have the device context passed into the event handler. These examples used the <xref
    linkend="mthGetControlDC"/> method to get a device context for the owner-drawn control. This technique seems to work
    okay. Nevertheless, if the ooDialog programmer is trying to use owner-drawn controls, it is highly likely that performing
    the user drawing the way it is intended to be done is more likely to have success.
  </para>
  <para>
    When the device context passed as the <emphasis role="italic">hDC</emphasis> argument is used to perform the drawing, as
    intended by the operating system, it is critical that the <link linkend="sctCommonWillReply">willReply</link> argument be
    set to true or <emphasis role="italic">SYNC</emphasis>. The result of any drawing operations done with the device context
    when the interpreter does not wait for the event handler to return will be highly unpredictable.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example creates a large owner-drawn button that takes up most of the dialog. The client area of the button
    is then used as a <emphasis role="italic">canvass</emphasis> to draw on. The event handler is invoked every time the
    button needs to be drawn. The event handler draws a circle on the button area and writes <emphasis
    role="italic">Circle</emphasis> on the button. This is a complete example that allows the user to experiment a little. An
    interesting experiment is to uncomment the say statement in the <emphasis role="italic">drawIt</emphasis> method to see
    when the event handler is executing:

<programlisting>
<![CDATA[

  dlg = .OwnerDrawDlg~new
  if dlg~initCode <> 0 then return 99
  dlg~execute("SHOWTOP")

return 0

::requires "ooDialog.cls"

::class 'OwnerDrawDlg' subclass UserDialog

::method init

  forward class (super) continue
  self~create(6, 15, 187, 135, "Owner-drawn Button Dialog", "CENTER")

  self~connectDraw(10, "drawIt", .true)

::method defineDialog
  self~createPushButton(10, 6, 6, 175, 123, "OWNER", "")

::method drawIt unguarded
  use arg id, lp, drawObj, itemID, flags, dc, r, itemData

  -- Uncomment this line to seen when the event handler is executed:
  --say 'Draw It'

  -- Create a pen to draw a circle with.
  pen    = drawObj~createPen(5, "SOLID", 1)
  oldPen = drawObj~objectToDc(dc, pen)

  -- Create a font to use to draw text with.
  properties = .directory~new
  properties~weight = 700
  properties~italic = .true

  font    = drawObj~createFontEx("Arial", 24, properties)
  oldFont = drawObj~fontToDC(dc, font)

  drawObj~transparentText(dc)

  -- Get the midpoint of the button rectangle and set the text align to center
  pos = .Point~new(r~right % 2, r~bottom  % 2)
  oldAlign = drawObj~setTextAlign(dc, 'CENTER BASELINE NOUPDATECP')

  -- Get a rectangle indented 5 from the button's area.
  dr = .Rect~new(r~left + 5, r~top + 5, r~right - 10, r~bottom - 10)

  -- Draw a circle, within the rectangle
  drawObj~drawArc(dc, dr~left, dr~top, dr~right, dr~bottom)

  -- Write some text at the position we calculated above.
  drawObj~writeDirect(dc, pos~x, pos~y, 'Circle')

  -- Now restore the DC so it is the same as passed into us.
  drawObj~setTextAlign(dc, oldAlign)
  drawObj~fontToDC(dc, oldFont)
  drawObj~objectToDc(dc, oldPen)

  drawObj~opaqueText(dc)

  drawObj~deleteFont(font)
  drawObj~deleteObject(pen)

  return .true

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Draw Event Handler -->

</section>  <!-- End EventNotification::connectDraw() -->

<section id="mthConnectEditEvent" xreflabel="connectEditEvent"><title>connectEditEvent</title>
<indexterm><primary>connectEditEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectEditEvent(--id--,--event--+----------+--+--------------+--)---------><
                                     +-,-mName--+  +-,-willReply--+
]]>
</programlisting>

<para>
  Connects a method in the Rexx dialog to the Windows <xref linkend="ovvEvents"/> notification from a
 <xref linkend="clsEdit"/> control.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem><para>The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The ID of the edit control whose notification event is to be connected to a method.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event [required]</term>
    <listitem>
    <para>
      A single keyword, case is not significant, specifying the event to be connected with a method:
    </para>
    <variablelist>
      <varlistentry><term><link linkend="evtEditGeneral">CHANGE</link></term>
      <listitem>
      <para>
        The text has been altered. This notification is sent after the screen has been updated.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtEditGeneral">ERRSPACE</link></term>
      <listitem>
      <para>
        An out-of-memory problem has occurred.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtEditGeneral">GOTFOCUS</link></term>
      <listitem>
      <para>
        The edit control got the input focus.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtEditGeneral">HSCROLL</link></term>
      <listitem>
      <para>
        The horizontal scroll bar has been used.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtEditGeneral">LOSTFOCUS</link></term>
      <listitem>
      <para>
        The edit control lost the input focus.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtEditGeneral">MAXTEXT</link></term>
      <listitem>
      <para>
        The text inserted exceeds the specified number of characters for the edit control. This notification is also sent
        when:
      </para>
      <itemizedlist>
        <listitem>
        <para>
          An edit control does not have the ES_AUTOHSCROLL or AUTOSCROLLH style and the number of characters to be inserted
          would exceed the width of the edit control.
        </para>
        </listitem>
        <listitem>
        <para>
          The ES_AUTOVSCROLL or AUTOSCROLLV style is not set and the total number of lines resulting from a text insertion
          would exceed the height of the edit control.
        </para>
        </listitem>
      </itemizedlist>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtEditGeneral">UPDATE</link></term>
      <listitem>
      <para>
        The text has been altered. This notification is sent before the screen is updated.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtEditGeneral">VSCROLL</link></term>
      <listitem>
      <para>
        The vertical scroll bar has been used.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term>mName [optional]</term>
    <listitem>
    <para>
      The name of the method to invoke whenever the specified notification is received from the edit control. Provide a
      method with a matching name. If you omit this argument, a method name is generated automatically. The name consists of
      the event keyword preceded by <computeroutput>on</computeroutput>. For instance:
      <computeroutput>onLostFocus</computeroutput>. The method name can not be the empty string.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.false</computeroutput>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return codes are:
  </para>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error detected.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The resource ID could not be resolved or the event argument is incorrect.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The message was not connected correctly.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
    <para>
      The following example verifies the input of the edit control with the symbolic ID of IDC_EDIT_AMOUNT and resets it to 0
      if a nonnumeric value was entered:
<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  self~init:super(...)
  self~connectEditEvent("IDC_EDIT_AMOUNT", "CHANGE")

::method onChange unguarded
  ec = self~newEdit("IDC_EDIT_AMOUNT")
  if ec~getText~space(0) \== "" & ec~getText~dataType("N") == 0 then do
    ec~setModified(.false)
    ec~select
    ec~replaceSelText("0")
  end
  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtEditGeneral" xreflabel="General"><title>General Edit Event Handler</title>
<indexterm><primary>Edit class</primary><secondary>events</secondary><tertiary>CHANGE</tertiary></indexterm>
<indexterm><primary>Edit class</primary><secondary>events</secondary><tertiary>ERRSPACE</tertiary></indexterm>
<indexterm><primary>Edit class</primary><secondary>events</secondary><tertiary>HSCROLL</tertiary></indexterm>
<indexterm><primary>Edit class</primary><secondary>events</secondary><tertiary>GOTFOCUS</tertiary></indexterm>
<indexterm><primary>Edit class</primary><secondary>events</secondary><tertiary>LOSTFOCUS</tertiary></indexterm>
<indexterm><primary>Edit class</primary><secondary>events</secondary><tertiary>MAXTEXT</tertiary></indexterm>
<indexterm><primary>Edit class</primary><secondary>events</secondary><tertiary>UPDATE</tertiary></indexterm>
<indexterm><primary>Edit class</primary><secondary>events</secondary><tertiary>VSCROLL</tertiary></indexterm>
<para>
  The event handler for all of the edit control events receives the same arguments and is coded in the same fashion. When
  the handler is invoked is fairly clear from the name of the event. The GOTFOCUS event handler is invoked when the edit
  control gets the focus, etc..
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectEditEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onEditEvent unguarded
  use arg info, hwnd, id, notifyCode, controlObj

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 5 arguments. The first and second arguments need to be retained for backwards
    compatibility, but only the last 3 arguments are really needed:
  </para>
  <variablelist>
    <varlistentry><term>info</term>
    <listitem>
    <para>
      A numeric value that contains info about the event. The low order word contains the resource ID of the edit control
      sending the event. The high order word contains the edit control event code. The <xref linkend="mthLoWord"/> and <xref
      linkend="mthHiWord"/> methods of the <xref linkend="clsDlgUtil"/> class can be used to extract these values. However,
      the ooDialog framework now extracts those values for you and sends them as the third and fourth arguments.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window handle of the edit control that sent the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource id of the edit control sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>notifyCode</term>
    <listitem>
    <para>
      The numeric notification code of the event that caused the notification to be sent. Each dialog control has its own
      specific notification codes.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>controlObj</term>
    <listitem>
    <para>
      The Rexx edit control object that represents the underlying dialog control that sent the notification. It is possible
      this will be the <computeroutput>.nil</computeroutput> object if some error happened, but this is very unlikely.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this notification. 0 makes a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example connects several edit controls to the same event handle and then uses the <emphasis
    role="italic">id</emphasis> argument to determine which edit control is sending the notification and take some action
    specific to that edit control. The code is somewhat simplistic as it ignores what the notification code is. In a real
    word program the actions taken would depend on what the event was:

<programlisting>
<![CDATA[
::method onEditEvent unguarded
  use arg info, hwnd, id, notifyCode, editObj

  if id == .constDir[IDC_EDIT_AMOUNT] then do
    if editObj~getText~space(0) \== "" & editObj~getText~dataType("N") == 0 then do
      editObj~setModified(.false)
      editObj~select
      editObj~replaceSelText("0")
    end
  end
  else if id == .constDir[IDC_EDIT_ZIP] then do
    zip = editObj~getText~strip
      if \ self~validZipCode(zip) then doe
        -- Put up message box telling
        -- user what the problem is ...
        editObj~setText("")
      end
  end

  ...

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End General Edit Evnt Handler -->

</section>  <!-- End EventNotification::connectEditEvent() -->

<section id="mthConnectHelp" xreflabel="connectHelp"><title>connectHelp</title>
<indexterm><primary>connectHelp</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectHelp</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectHelp</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectHelp(--+--------------+--+--------------+--)---------><
                  +--methodName--+  +-,-willReply--+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectHelp</emphasis> method connects the Windows Help event with a method in the dialog. The
  Windows Help event occurs when the user presses the F1 key.  (Only the Help events generated when the dialog is the active
  window are connected.)
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that to be invoked when the help event occurs. The name can not be the empty string. When
      this argument is omitted the name defaults to <emphasis role="italic">onHelp</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.false</computeroutput>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para></listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Note that the Windows help event notification connected by this method is not the same as the help <emphasis
    role="bold">command</emphasis> event notification <link linkend="sctStandardEventMethods">automatically</link> connected
    when a dialog object is instantiated.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    help events happen.
  </para>
  <para>
    In Windows itself, the dialog receives this notification as a WM_HELP message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>

<programlisting>
<![CDATA[

::method init
    self~init:super
    ...
    self~connectResize(onResize)
    self~connectHelp(onHelp)
    ...

::method onHelp unguarded
    use arg id, type, mouseX, mouseY, cntxID, helpObj
    if type == "MENU" then w = 'Menu id' id; else w = 'Dialog id' id
    say "Help request:"
    say " " w
    say "  Mouse position x:" mouseX "y:" mouseY 'help object:' helpObj

    return 0

/* As the user presses the F1 key at various times when the dialog has the focus
 * the output might be as follows:
 */

Help request:
  Dialog id 12
  Mouse position x: 420 y: 106 help object: a Button
Help request:
  Menu id 60
  Mouse position x: 204 y: 93 help object: the NIL object
Help request:
  Menu id 65
  Mouse position x: 203 y: 166 help object: the NIL object
Help request:
  Dialog id 14
  Mouse position x: 218 y: 410 help object: a RadioButton
Help request:
  Dialog id 80
  Mouse position x: 387 y: 462 help object: a Tab
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtEventNotificationHELP" xreflabel="HELP"><title>Help Event Handler</title>
<indexterm><primary>EventNotification class</primary><secondary>events</secondary><tertiary>HELP</tertiary></indexterm>
<para>
  The event handler for the Help event is invoked when the user presses the F1 key when the active window is the dialog.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectHelp"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onHelp unguarded
  use arg id, type, mouseX, mouseY, cntxID, helpObj

  return .true
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 6 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the dialog, dialog control, or menu item that had the focus when the F1 key was pressed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>type</term>
    <listitem>
    <para>
      Specifies if the ID in argument 1 was from a window (a dialog or dialog control) or from a menu item.  This
      argument will either be <computeroutput>WINDOW</computeroutput> or <computeroutput>MENU</computeroutput>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mouseX</term>
    <listitem>
    <para>
      The x coordinate of the mouse at the time the F1 key was pressed.  This value is an absolute screen coordinate
      (pixel.) Note that the mouse will not necessarily be over the dialog.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mouseY</term>
    <listitem>
    <para>
      The y coordinate of the mouse at the time the F1 key was pressed. The same caveats as for the <emphasis
      role="italic">mouseX</emphasis> argument apply.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>cntxID</term>
    <listitem>
    <para>
      The help context identifier of the dialog, control, or menu. ooDialog does not yet have good support for setting help
      context IDs for dialogs or dialog controls. However, ooDialog does support setting the help ID for menus. If the
      <emphasis role="italic">type</emphasis> argument is <emphasis role="italic">WINDOW</emphasis>, this argument will
      probably be 0.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>helpObj</term>
    <listitem>
    <para>
      The Rexx dialog object or the Rexx dialog control object that had the focus when the F1 key was pressed. Otherwise,
      the <computeroutput>.nil</computeroutput> object if it was a menu item that had the focus. <emphasis
      role="bold">Note:</emphasis> It is anticipated that future versions of ooDialog will return the Rexx menu object that
      contains the menu item instead of the <computeroutput>.nil</computeroutput> object.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The MSDN documentation says to return true from the event handler.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example shows a simple event handler that prints out the values of the arguments sent to it. This can be
    useful is understanding how the event handler for the <emphasis role="italic">connectHelp</emphasis> method works:

<programlisting>
<![CDATA[

::method init
  expose menubar

  forward class (super) continue

  if \ self~createMenuBar then do
    self~initCode = 1
    return
  end

  self~connectHelp('onHelp', 'SYNC')

::method onHelp unguarded
  use arg id, type, x, y, cntxID, helpObj

  say 'onHelp'
  say 'id:' id 'type:' type 'x:' x 'y:' y 'cntxID:' cntxID 'helpObj:' heldObj

  return .true

/* Output might be for example:
onHelp
id: 1 type: WINDOW x: 796 y: 463 cntxID: 0 helpObj: a Button
onHelp
id: 2 type: WINDOW x: 796 y: 463 cntxID: 0 helpObj: a Button
onHelp
id: 1002 type: WINDOW x: 796 y: 463 cntxID: 0 helpObj: a Tab
onHelp
id: 65535 type: WINDOW x: 796 y: 463 cntxID: 0 helpObj: a GroupBox
onHelp
id: 1003 type: WINDOW x: 796 y: 463 cntxID: 0 helpObj: a RadioButton
onHelp
id: 833 type: MENU x: 976 y: 319 cntxID: 46 helpObj: The NIL object
onHelp
id: 821 type: MENU x: 976 y: 319 cntxID: 45 helpObj: The NIL object
onHelp
id: 821 type: MENU x: 323 y: 161 cntxID: 45 helpObj: The NIL object
onHelp
id: 812 type: MENU x: 323 y: 161 cntxID: 44 helpObj: The NIL object
onHelp
id: 1003 type: WINDOW x: 796 y: 375 cntxID: 0 helpObj: a RadioButton
onHelp
id: 1003 type: WINDOW x: 473 y: 347 cntxID: 0 helpObj: a RadioButton

*/

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Help Event Handler -->

</section>  <!-- End EventNotification::connectHelp() -->


<section id="sctConnectingKeyPressEvents"><title>Connecting Key Press Events</title>
<indexterm><primary>Connecting Key Press Events</primary></indexterm>

<para>
  This section contains methods related to connecting key press events.
</para>

<section id="mthConnectFKeyPressDialogObject" xreflabel="connectFKeyPress"><title>connectFKeyPress</title>
<indexterm><primary>connectFKeyPress</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectFKeyPress</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectFKeyPress(--methodName--)-------------><

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectFKeyPress</emphasis> method connects a function key press event notification to a
  method in the Rexx dialog object. </para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single arguments is;
    <variablelist>
      <varlistentry><term>methodName [required]</term>
      <listitem>
      <para>
        The name of the method that is to be invoked when the key press event happens. The argument can not be the empty
        string.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The possible return values are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        Success.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-2</term>
      <listitem>
      <para>
        The underlying mechanism in the Windows API that is used to capture key events failed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-6</term>
      <listitem>
      <para>
        The maximum number of connections has been reached.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-7</term>
      <listitem>
      <para>
        The <emphasis role="italic">methodName</emphasis> method is already connected to a key down event for this
        dialog.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks</emphasis></term>
  <listitem>
  <para>
    This method works for function keys F2 through F24. In Windows the F1 key is the help key and the
    <xref linkend="mthConnectHelp"/> method should be used for F1. This method is a convenience method and is
    exactly equivalent to:

<programlisting>
<![CDATA[
::method initDialog
  ...
  keys = .VK~F2 "-" .VK~F24
  self~connectKeyPress(methodName, keys)
]]>
</programlisting>

  </para>
  <para>
    Both the <emphasis role="italic">connectFKeyPress</emphasis> and the <xref linkend="mthConnectKeyPressDialogObject"/>
    methods use the same event <link linkend="evtEventNotificationKEYPRESS">handler</link>.
  </para>
  <para>
    Unlike most other methods that connect event notifications, the underlying Windows dialog must exist before this
    method can be used. That means it can be used in <xref linkend="mthInitDialog"/> or any time thereafter.  There is a
    maximum limit of 63 methods, per dialog, that can be connected to key press events. Connections can be removed using the
    <xref linkend="mthDisconnectKeyPressDialogObject"/> method if there is no longer a need for a notification of a key
    press.
  </para>
  <para>
    The dialog control object also has a <xref linkend="mthConnectFKeyPressDialogControlObject"/>()
    method. The method of the dialog object (this method) will capture any F key press event when the dialog is the
    active window. The method of the dialog control object will only capture a F key press when the control has the
    keyboard focus.
  </para>
  <para>
    Due to the nature of key press events, the low-level implementation of capturing the key strokes is different from
    most of the other methods of the <computeroutput>EventNotification</computeroutput> class. There is no single message
    sent to the underlying dialog for a key stroke event.
  </para>
  </listitem>
  </varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    In general error return codes are used to indicate incorrect usage rather than raised syntax conditions. However,
    syntax errors are raised if the <emphasis role="italic">methodName</emphasis> argument is missing or the empty
    string, or invoking this method before the <xref linkend="ovvUnderlying"/> dialog is created.
  </para>
  <para>
    Raises syntax errors when some incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any F
    Key key press events happen.
  </para>
  </listitem>
  </varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example is a variation on the <link linkend="connectKeyPressExample">example</link> shown for the
    <xref linkend="mthConnectKeyPressDialogObject"/> method. It connects all the function keys to the
    same method and then determines what action to take by examining which key was pressed.

  <programlisting>
  <![CDATA[
  ::method initDialog

    ...

    -- Capture all function key presses.
    self~connectFKeyPress(onFKey)

    ...

  ::method onFKey unguarded
    use arg keyPressed

    select
      when keyPressed == .VK~F2 then self~showCustomerLookupDialog

      when keyPressed = 114 then do
        prodNum = self~newEdit(IDC_EDIT_PRODUCT)~getText
        if prodNum \== "" then self~showProductInfo(prodNum)
      end

      when keyPressed = 115 then self~resetAllFields
      when keyPressed = 116 then self~printInvoice

      otherwise do
        -- Not interested in any other function keys
        nop
      end
    end

    return 0
  ]]>
  </programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End EventNotification::connectFKeyPress() -->

<section id="mthConnectKeyPressDialogObject" xreflabel="connectKeyPress"><title>connectKeyPress</title>
<indexterm><primary>connectKeyPress</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectKeyPress</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectKeyPress</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectKeyPress(--methodName--,--keys-+------------+--)-----><
                                          +-,--filter--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectKeyPress</emphasis> method connects a key press
  <xref linkend="ovvEvents"/> notification with a method in the Rexx dialog. A single key or multiple keys can be
  connected to the same method.  Multiple methods can be connected for key press events, but only 1 method can be
  connected to any single key.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>methodName [required]</term>
      <listitem>
      <para>
        The name of the method that is to be invoked when the key press event happens. This argument can not be the
        empty string.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>keys [required]</term>
      <listitem>
      <para>
        The key (or keys) for which the key press event is to be connected. A single key or multiple keys can be
        specified. A range of keys can be used.  Each single key or range of keys is separated by a comma.  A range of
        keys is denoted by using the dash character &quot;-&quot;.  White space within the <emphasis
        role="italic">keys</emphasis> argument is ignored. This argument can not be the empty string.
      </para>
      <para>
        The keys are specified by the numeric value defined by Microsoft for its virtual key set.  These numeric values
        are 0 through 255. There are some integer values between 0 and 255 that do not have a virtual key assigned to
        them. For example, 0, 7, 10, 11, and 255 are not used. The <xref linkend="clsVK"/> class contains
        constants for all of the defined virtual keys.
      </para>
      <para>
        In addition, there are a few keywords that can be used to specify some common key ranges. These keywords are:
        <variablelist>
          <varlistentry><term>ALL</term>
          <listitem>
          <para>
            All keys.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>FKEYS</term>
          <listitem>
          <para>
            All Function keys, other than F1.  (In Windows the F1 key is the help key and the
            <xref linkend="mthConnectHelp"/> method should be used for F1.)
          </para>
          </listitem></varlistentry>
          <varlistentry><term>ALPHA</term>
          <listitem>
          <para>
            The keys A though Z.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>NUMERIC</term>
          <listitem>
          <para>
            The keys 0 through 9.  Note that these are the normal number keys, not the keypad numbers on an enhanced
            keyboard.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>ALPHANUMERIC</term>
          <listitem>
          <para>
            The keys A through Z and 0 through 9.
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      <para>
        <emphasis role="bold">Note</emphasis> that case is insignificant for these keywords as is the order of the
        keywords. A keyword not in the list will result in a return of -9. However, if the argument contains other valid
        key tokens, those keys will be connected to the method.  If there are no other valid key tokens, then no
        connection is made.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>filter [optional]</term>
      <listitem>
      <para>
        A (simplistic) filter that is applied to the key press event for the key(s) specified.  The filter is a string of
        keywords separated by blanks. (Case is not significant, neither is the order of the words.  Any words other than
        the specified keywords are ignored.) The possible keywords are: <computeroutput>SHIFT, CONTROL, ALT, AND, NONE,
        VIRTUAL.</computeroutput>
      </para>
      <para>
        The VIRTUAL keyword can be abbreviated to VIRT if desired. The VIRTUAL keyword effects how the test for the
        shift, control, and alt key is performed. By default the physical state of the keyboard is checked to see if the
        control, alt, or shift key is depressed. However, it is common in Windows to use keystroke programs that inject
        keystrokes into other application windows. Testing the physical state of the keyboard will not detect
        combination keystrokes like Ctrl-S, Alt-L, etc., that are inserted by keystroke programs because the physical
        state of the modifier keys control and alt will not be depressed. If the VIRTUAL keyword is used, the test for
        the modifier keys being down will be altered in a way that will detect if the virtual state of the key is down.
        This test will detect key events inserted into the Rexx application by third party keystroke programs.
      </para>
      <para>
        Shift, control, and alt specify that the corresponding key must be down at the time of the key press event. These
        keywords are combined in a boolean expression.  The default is an OR expression. If the AND keyword is present
        then the boolean expression is an AND expression. If the NONE keyword is used, it means that none of the shift,
        control, or alt keys can be down at the time of the key press event.  (When NONE is used, all other words,
        except VIRTUAL, in the string are ignored.)
      </para>
      <para>
        Some examples may make this more clear:
  <programlisting>
  <![CDATA[

  ::method initDialog

    -- Using the below, the onAltCD method would be invoked when the user types
    -- Alt-Shift-C or Alt-Shift-D.  But the method would not be invoked for Alt-C
    -- or Shift-D (or any other key press event.)

    keys = .VK~C "," .VK~D
    self~connectKeyPress(onAltCD, keys, "ALT AND SHIFT")

    -- The below would invoke the onAltCD method any time a C or a D was typed
    -- with either the Alt or the Control key down.  This would include Alt-C,
    -- Alt-Shift-C, Ctrl-Alt-Shift-C, etc..

    self~connectKeyPress(onAltCD, keys, "ALT CONTROL")

    -- The below would invoke the onAltCD method only when Alt-C or Alt-D was
    -- typed.

    self~connectKeyPress(onAltCD, keys, "ALT AND")

    -- The below would invoke the onF4 method only when the F4 key was pressed by
    -- itself. Alt-F4, Ctrl-F4, etc., would not invoke the method.

    self~connectKeyPress(onF4, .VK~F4, "NONE")
  ]]>
  </programlisting>

      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The possible return values are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        Success.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-2</term>
      <listitem>
      <para>
        The underlying mechanism in the Windows API that is used to capture key events failed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-6</term>
      <listitem>
      <para>
        The maximum number of connections has been reached.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-7</term>
      <listitem>
      <para>
        The <emphasis role="italic">methodName</emphasis> method is already connected to a key down event for this
        dialog.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-8</term>
      <listitem>
      <para>
        The <computeroutput>filter</computeroutput> argument is not correct.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-9</term>
      <listitem>
      <para>
        An incorrect format for the <computeroutput>keys</computeroutput>.  Note that it is possible to get a return of
        -9 but still have some keys connected. For instance in the following example the C and D keys would be connected
        and the filter applied. The &quot;"dog&quot;" token would result in -9 being returned:

<programlisting>
<![CDATA[

  keys = .VK~C ", dog," .VK~D
  ret = self~connectKeyPress('onAltCD', keys, "ALT AND SHIFT")
  say 'Got a return of:' ret
  say "Have connection to onAltCD?" self~hasKeyPressConnection('onAltCD')

  -- The output would be:
  Got a return of: -1
  Have connection to onAltCD? 1

]]>
</programlisting>

      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks</emphasis></term>
  <listitem>
  <para>
    Unlike most other methods that connect event notifications, the underlying Windows dialog must exist before this
    method can be used. That means it can be used in <xref linkend="mthInitDialog"/> or any time
    thereafter.  There is a maximum limit of 63 methods, per dialog, that can be connected to key press events.
    Connections can be removed using the <xref linkend="mthDisconnectKeyPressDialogObject"/>
    method if there is no longer a need for a notification of a key press.
  </para>
  <para>
    The dialog control object also has a <xref linkend="mthConnectKeyPressDialogControlObject"/>()
    method.  It is important to note this distinction between the two methods. The method of the dialog object (this
    method) will capture all key press events when the dialog is the active window. This includes key presses when a
    dialog control in the dialog has the focus.
  </para>
  <para>
    The method of the dialog control object will only capture key press events when the specific dialog control has
    the focus. This implies that if you connect the same key press event to both the dialog and to a specific dialog
    control, if the key press event occurs when the dialog control has the focus, you will receive two event
    notifications.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    In general error return codes are used to indicate incorrect usage rather than raised syntax conditions. However,
    syntax errors are raised for missing required arguments, using the empty string for required arguments, or invoking
    this method before the <xref linkend="ovvUnderlying"/> dialog is created.
  </para>
  <para>
    Raises syntax errors when some incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    draw events happen.
  </para>
  <para>
    Due to the nature of key press events, the low-level implementation of capturing the key strokes is different from
    most of the other methods of the <computeroutput>EventNotification</computeroutput> class. There is no single message
    sent to the underlying dialog for a key stroke event.
  </para>
  </listitem></varlistentry>
  <varlistentry id="connectKeyPressExample"><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example is from a fictitious customer order system.  As the user is filling out a customer order using
    the customer order dialog, he has the F2 through F5 short cut keys available.  F2 brings up a customer look up
    dialog. F3 looks up info on the product number entered in an edit control.  F4 resets the form by clearing all the
    fields. F5 is used to print out the finished invoice.

<programlisting>
<![CDATA[
::method initDialog

  ...

  -- Capture F2 key presses, but not Ctrl-F2 or Alt-F2, etc..
  self~connectKeyPress(onF2, .VK~VK_F2, "NONE")

  -- Same idea for F3, F4, and F5.  This uses the actual numeric value for the
  -- keys without bothering to use the VK class to translate.
  self~connectKeyPress(onF3, 114, "NONE")
  self~connectKeyPress(onF4, 115, "NONE")
  self~connectKeyPress(onF5, 116, "NONE")

  ...

::method onF2 unguarded
  self~showCustomerLookupDialog
  return 0

::method onF3 unguarded

  prodNum = self~newEdit(IDC_EDIT_PRODUCT)~getText
  if prodNum \== "" then self~showProductInfo(prodNum)
  return 0

::method onF4 unguarded
  self~resetAllFields
  return 0

::method onF5 unguarded
  self~printInvoice
  return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section> <!-- End EventNotification::connectKeyPress() -->

<section id="mthDisconnectKeyPressDialogObject" xreflabel="disconnectKeyPress"><title>disconnectKeyPress</title>
<indexterm><primary>disconnectKeyPress</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>disconnectKeyPress</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>disconnectFKeyPress</secondary></indexterm>
<programlisting>
<![CDATA[
>>--disconnectKeyPress(--+--------------+--)-----><
                         +--methodName--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">disconnectKeyPress</emphasis> method disconnects a key press event from a method that was
  previously connected using <xref linkend="mthConnectKeyPressDialogObject"/>, or
 <xref linkend="mthConnectFKeyPressDialogObject"/>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The single argument is:
    <variablelist>
      <varlistentry><term>methodName [optional]</term>
      <listitem>
      <para>
        If <emphasis role="italic">methodName</emphasis> is specified, only the key press events connected to that
        method are disconnected. If the argument is omitted, then all key press events for the dialog will be
        disconnected.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The possible return values are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        Success.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-2</term>
      <listitem>
      <para>
        While trying to disconnect the method, the underlying mechanism in the Windows API that is used to capture key
        events had an error. This is unlikely to happen.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-7</term>
      <listitem>
      <para>
        Either the <emphasis role="italic">methodName</emphasis> method is already disconnected, or there are no methods
        connected at all.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The dialog control object also has a <xref linkend="mthDisconnectKeyPressDialogControlObject"/>
    method. The method of the dialog object (this method) can only disconnect key press events that were set with the
    dialog object's versions of <xref linkend="mthConnectKeyPressDialogObject"/> and
 <xref linkend="mthConnectFKeyPressDialogObject"/> methods. This method can not disconnect key press
    events that were set with the dialog control object's versions of
 <xref linkend="mthConnectKeyPressDialogControlObject"/> and
 <xref linkend="mthConnectFKeyPressDialogControlObject"/> methods.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    Raises syntax errors when some incorrect usage is detected.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example is a variation on the <link linkend="connectKeyPressExample">example</link> shown for the
    <xref linkend="mthConnectKeyPressDialogObject"/> method. It builds on the fictitious customer
    order system.  The F7 key saves the completed invoice into the system and enters a different phase of the companies
    business process. At this point (for whatever fictitious business reason) the fields can no longer be cleared and
    the user is not allowed to look up customer or product information.  But, the user may still need to print the
    invoice.  To prevent the accidental press of the hot keys causing the wrong action, those key presses are
    disconnected.
  </para>
  <para>
    To demonstrate how key press connections can be added and removed through out the life time of the dialog, this
    example adds the F9 hot key.  F9 starts a new order entry cycle and re-connects the hot keys used during the
    creation of a customer invoice.  When the user then saves the next completed invoice, key press connections are
    removed, when she starts a new invoice key press connections are restored.  This cycle could continue though out the
    day without the user ever closing the main dialog.

<programlisting>
<![CDATA[

::method initDialog

  ...

  -- Capture F2 key presses, but not Ctrl-F2 or Alt-F2, etc..
  self~connectKeyPress(onF2, .VK~F2, "NONE")

  -- Same idea for F3, F4, F5, and F7.  This uses the actual numeric value for
  -- the keys without bothering to use the .VK class to translate.
  self~connectKeyPress(onF3, 114, "NONE")
  self~connectKeyPress(onF4, 115, "NONE")
  self~connectKeyPress(onF5, 116, "NONE")
  self~connectKeyPress(onF7, 118, "NONE")
  self~connectKeyPress(onF9, 120, "NONE")

  ...

::method onF2 unguarded
  self~showCustomerLookupDialog

  return 0

::method onF3 unguarded

  prodNum = self~newEdit(IDC_EDIT_PRODUCT)~getText
  if prodNum \== "" then self~showProductInfo(prodNum)
  return 0

::method onF4
  self~resetAllFields
  return 0

::method onF5
  self~printInvoice
  return 0

::method onF7

  self~saveToDataBase
  self~disconnectKeyPress(onF2)
  self~disconnectKeyPress(onF3)
  self~disconnectKeyPress(onF4)
  return 0

::method onF9

  self~resetAllFields
  self~connectKeyPress(onF2, 112, "NONE")
  self~connectKeyPress(onF3, 114, "NONE")
  self~connectKeyPress(onF4, 115, "NONE")
  return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End EventNotification::disconnectKeyPress() -->

<section id="mthHasKeyPressConnectionDialogObject" xreflabel="hasKeyPressConnection"><title>hasKeyPressConnection</title>
<indexterm><primary>hasKeyPressConnection</primary><secondary>dialog object</secondary></indexterm>
<indexterm><primary>dialog object</primary><secondary>hasKeyPressConnection</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>hasKeyPressConnection</secondary></indexterm>
<programlisting>
<![CDATA[
>>--hasKeyPressConnection(--+--------------+--)--><
                            +--methodName--+

]]>
</programlisting>

<para>
  This method is used to query if a connection to a key press event already exists.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>The single optional argument is:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      Query if any key press events are connected to the specified method. If this argument is omitted, the query is if
      any key press events are connected to <emphasis role="bold">any</emphasis> methods.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns <computeroutput>.true</computeroutput> if the method is connected to a key press event or
    <computeroutput>.false</computeroutput> otherwise.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details</emphasis></term>
  <listitem>
  <para>
    The dialog control object also has a
 <xref linkend="mthHasKeyPressConnectionDialogControlObject"/> method. The method of the dialog
    object (this method) can only check for connections that were set with the dialog object's versions of
 <xref linkend="mthConnectKeyPressDialogObject"/> and
 <xref linkend="mthConnectFKeyPressDialogObject"/> methods. This method can not check for connections
    that were set with the dialog control object's versions of
 <xref linkend="mthConnectKeyPressDialogControlObject"/> and
 <xref linkend="mthConnectFKeyPressDialogControlObject"/> methods.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example could come from a dialog where the user has the option to use hot keys or not.  When the
    reset button is pushed the state of the dialog fields are reset.  The hot keys enabled check box is set to reflect
    whether hot keys are currently enabled or not.

<programlisting>

<![CDATA[

::method defineDialog

  ...
  self~createCheckBox(IDC_CHECK_FKEYSENABlED, 30, 60, , , , "Hot Keys Enabled")
  ...
  self~createPushButton(IDC_PB_RESET, 60, 135, 45, 15, , "Reset", onReset)
  ...

::method onReset unguarded

  ...
  if self~hasKeyPressConnection then
    self~newCheckBox(IDC_CHECK_FKEYSENABlED)~check
  else
    self~newCheckBox(IDC_CHECK_FKEYSENABlED)~uncheck
  ...
  return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End EventNotification::hasKeyPressConnection() -->

<section id="evtEventNotificationKEYPRESS" xreflabel="KEYPRESS"><title>KeyPress Event Handler</title>
<indexterm><primary>EventNotification class</primary><secondary>events</secondary><tertiary>KEYPRESS</tertiary></indexterm>
<para>
  The event handler for the key press event is invoked when a key connected through the <xref
  linkend="mthConnectKeyPressDialogObject"/> or the <xref linkend="mthConnectFKeyPressDialogObject"/> method is typed when the
  dialog has the focus.
</para>
<para>
  The interpreter replies immediately to the operating system when the key is pressed. Tthe event handler is then invoked
  concurrently as a separate activity and the interpreter does not wait for the return. The value returned from the event
  handler is ignored and the programmer need not return a value from the handler. However, good practice would be to always
  return a value from an event handler.
</para>

<programlisting>
<![CDATA[
::method onKeyPress unguarded
  use arg keyCode, shift, control, alt, extraInfo

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 5 arguments:
  </para>
  <variablelist>
    <varlistentry><term>keyCode</term>
    <listitem>
    <para>
      The numeric code of the key pressed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>shift</term>
    <listitem>
    <para>
      A boolean (true or false) that denotes whether a shift key was down or up at the time of the key press. It will
      be true if a shift key was down and false if the shift key was not down.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>control</term>
    <listitem>
    <para>
      True if a control key was down at the time of the key press, false if it was not.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>alt</term>
    <listitem>
    <para>
      True if an alt key was down at the time of the key press, false if it was not.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>extraInfo</term>
    <listitem>
    <para>
      This argument is a string containing keywords.  It supplies extra information about the keyboard state at the
      time of a key press event. The string will contain some combination of these keywords
      <variablelist>
        <varlistentry><term>numOn</term>
        <listitem>
        <para>
          Num Lock was on at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>numOff</term>
        <listitem>
        <para>
          Num Lock was off.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>capsOn</term>
        <listitem>
        <para>
          Caps Lock was on at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>capsOff</term>
        <listitem>
        <para>
          Caps Lock was off.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>scrollOn</term>
        <listitem>
        <para>
          Scroll Lock was on at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>scrollOff</term>
        <listitem>
        <para>
          Scroll Lock was off.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>lShift</term>
        <listitem>
        <para>
          The left shift key was down at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>rShift</term>
        <listitem>
        <para>
          The right shift key was down.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>lControl</term>
        <listitem>
        <para>
          The left control key was down at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>rControl</term>
        <listitem>
        <para>
          The right control key was down.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>lAlt</term>
        <listitem>
        <para>
          The left alt key was down at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>rAlt</term>
        <listitem>
        <para>
          The right alt key was down.
        </para>
        </listitem></varlistentry>
      </variablelist>
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The return value from the event handler is discarded. Zero would make a good value to return.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example comes from an application where the user can type F3 to close the current dialog and Alt-F3 to
    close the entire application. The event handler checks that only the Alt key is down when the F3 key is pressed and
    closes the application if that is true. Otherwise, if only the F3 key is pressed, then the handler closes the dialog:

<programlisting>
<![CDATA[
::method initDialog
  self~connectKeyPress(onQuitKey, .VK~F3)

::method onQuitKey
  use arg key, shift, control, alt, info
  say 'Key press:' key 'shift?' shift 'control?' control || -
      ' alt?' alt 'extra info:' info

  if shift then return
  if control then return
  if alt then return self~quitApplication

  -- Only F3 is pressed, close this dialog
  return self~cancel:super

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End KeyPress Event Handler -->

</section> <!-- End Connecting Key Press Events section -->


<section id="mthConnectListBoxEvent" xreflabel="connectListBoxEvent"><title>connectListBoxEvent</title>
<indexterm><primary>connectListBoxEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectListBoxEvent(--id--,--event--+----------+--+--------------+--)------><
                                        +-,--mName-+  +-,-willReply--+

]]>
</programlisting>

<para>
  Connects a method in the Rexx dialog to the Windows <xref linkend="ovvEvents"/> notification from a <xref
  linkend="clsListBox"/> control.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  </para>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the list box whose event notification is to be connected to the method.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event [required]</term>
    <listitem>
    <para>
      A single keyword, case is not significant, which specifies the event to be connected:
    <variablelist>
      <varlistentry><term><link linkend="evtListBoxGeneral">DBLCLK</link></term>
      <listitem>
      <para>
        An entry in the list box has been selected with a double click.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtListBoxGeneral">ERRSPACE</link></term>
      <listitem>
      <para>
        An out-of-memory problem has occurred.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtListBoxGeneral">GOTFOCUS</link></term>
      <listitem>
      <para>
        The list box has gained the input focus.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtListBoxGeneral">LOSTFOCUS</link></term>
      <listitem>
      <para>
        The list box has lost the input focus.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtListBoxGeneral">SELCANCEL</link></term>
      <listitem>
      <para>
        The selection in the list box has been canceled.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtListBoxGeneral">SELCHANGE</link></term>
      <listitem>
      <para>
        Another list box entry has been selected.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mName [optional]</term>
    <listitem>
    <para>
      The name of the method to be invoked whenever the specified notification is received from the list box. Provide an
      event handling method with a matching name. If this argument is omitted, ooDialog generates a name that consists of the
      event keyword preceded by <computeroutput>on</computeroutput>. For example <emphasis
      role="italic">onLostFocus</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.false</computeroutput>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return codes are:
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error detected.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The resource ID could not be resolved or the event argument is incorrect.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The message was not connected correctly.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example displays the text of the selected list box entry each time the user selects a new item:
<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  self~connectListBoxEvent(IDC_LB_PLAYLIST, "SELCHANGE", "onSelectionChanged")

::method onSelectionChanged unguarded
  use arg , , id, code, lbox

  say "New selection is:" lbox~selected
  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtListBoxGeneral" xreflabel="General"><title>General ListBox Event Handler</title>
<indexterm><primary>ListBox class</primary><secondary>events</secondary><tertiary>DBLCLK</tertiary></indexterm>
<indexterm><primary>ListBox class</primary><secondary>events</secondary><tertiary>ERRSPACE</tertiary></indexterm>
<indexterm><primary>ListBox class</primary><secondary>events</secondary><tertiary>GOTFOCUS</tertiary></indexterm>
<indexterm><primary>ListBox class</primary><secondary>events</secondary><tertiary>LOSTFOCUS</tertiary></indexterm>
<indexterm><primary>ListBox class</primary><secondary>events</secondary><tertiary>SELCANCEL</tertiary></indexterm>
<indexterm><primary>ListBox class</primary><secondary>events</secondary><tertiary>SELCHANGE</tertiary></indexterm>
<para>
  The event handler for all of the list box events receives the same arguments and is coded in the same fashion. When
  the handler is invoked is fairly clear from the name of the event. The GOTFOCUS event handler is invoked when the list box
  gets the focus, etc..
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectListBoxEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onListBoxEvent unguarded
  use arg info, hwnd, id, notifyCode, listBox

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 5 arguments. The first and second arguments need to be retained for backwards
    compatibility, but only the last 3 arguments are really needed:
  </para>
  <variablelist>
    <varlistentry><term>info</term>
    <listitem>
    <para>
      A numeric value that contains info about the event. The low order word contains the resource ID of the list box sending
      the event. The high order word contains the list box event code. The <xref linkend="mthLoWord"/> and <xref
      linkend="mthHiWord"/> methods of the <xref linkend="clsDlgUtil"/> class can be used to extract these values. However,
      the ooDialog framework now extracts those values for you and sends them as the third and fourth arguments.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window handle of the list box that sent the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource id of the list box sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>notifyCode</term>
    <listitem>
    <para>
      The numeric notification code of the event that caused the notification to be sent. Each dialog control has its own
      specific notification codes.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>listBox</term>
    <listitem>
    <para>
      The Rexx list box object that represents the underlying dialog control that sent the notification. It is possible
      this will be the <computeroutput>.nil</computeroutput> object if some error happened, but this is very unlikely.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this notification. 0 makes a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example comes from an application that fills a list box with the names of movies. When the user clicks on a
    movie in the list box, the application fills a number of other controls with information specific to the selected movie:

<programlisting>
<![CDATA[
::method onMovieClick unguarded
   expose movieData
   use arg , , id, nCode, listBox

   movieName = listBox~selected

   combo = self~newComboBox(35)
   combo~deleteAll

   -- If no movie in the list box is selected, set everything blank, otherwise,
   -- set everything to match the selected movie.
   if movieName == "" then do
     self~newEdit(32)~setText("")
     self~newEdit(33)~setText("")
     self~newEdit(34)~setText("")
     combo~add("")
   end
   else do
     d = movieData[movieName]
     self~newEdit(32)~setText(d~produced)
     self~newEdit(33)~setText(d~star)
     self~newEdit(34)~setText(d~director)

     do n over d~with
        combo~add(n)
     end
     combo~selectIndex(1)
   end

   return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End General ListBox Event Handler -->

</section> <!-- End EventNotification::connectListBoxEvent() -->

<section id="mthConnectListViewEvent" xreflabel="connectListViewEvent"><title>connectListViewEvent</title>
<indexterm><primary>connectListViewEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>-connectListViewEvent(--id--,--event--+---------------+--+-------------+--)--><
                                        +-,--methodName-+  +-,-willReply-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectListViewEvent</emphasis> method connects a particular
  <xref linkend="ovvEvents"/> notification from a list-view control with an event handling method in the Rexx
  dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The ID of the list-view control for which a notification is to be connected. This can be symbolic or numeric.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event [required]</term>
    <listitem>
    <para>
      The event keyword. Use exactly one of the following keywords, case is not significant. Each keyword in the list is
      linked to the event handler documentation for that event:
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>ACTIVATE</member>
        <member>BEGINDRAG</member>
        <member>BEGINEDIT</member>
        <member>BEGINRDRAG</member>
        <member>BEGINSCROLL</member>
        <member>CHANGING</member>
        <member>CHANGED</member>
        <member>CHECKBOXCHANGED</member>
        <member>CLICK</member>
        <member>COLUMNCLICK</member>
        <member>DBLCLK</member>
        <member>DEFAULTEDIT</member>
        <member>DELETE</member>
        <member>DELETEALL</member>
        <member>ENDEDIT</member>
        <member>ENDSCROLL</member>
        <member>FOCUSCHANGED</member>
        <member>GETINFOTIP</member>
        <member>INSERTED</member>
        <member>KEYDOWN</member>
        <member>KEYDOWNEX</member>
        <member>SELECTCHANGED</member>
        <member>SELECTFOCUSCHANGED</member>
      </simplelist>
    </para>
    <variablelist>
      <varlistentry><term><link linkend="evtListViewGeneral">ACTIVATE</link></term>
      <listitem>
      <para>
        A list view item has been activated. One way an item is activated by is double-clicking the item with the left mouse
        button.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><xref linkend="evtListViewBEGINDRAG"/> </term>
      <listitem>
      <para>
        A drag-and-drop operation was initiated. See <xref linkend="mthDefListDragHandler"/> for information on how to
        implement a drag-and-drop handler.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywListViewBEGINEDIT" xreflabel="BEGINEDIT"><term><xref linkend="evtListViewBEGINEDIT"/> </term>
      <listitem>
      <para>
        Editing a label has been started. Do not connect this event if you are using the DEFAULTEDIT keyword. The results are
        undefined. The list-view must have the <xref linkend="styListViewEDIT"/> style for this notification to be sent.
      </para>
      <para>
        The event notification for this event has been enhanced since the original ooDialog implementation. To use the
        enhanced event notification, the <emphasis role="italic">willReply</emphasis> argument must be used. The value of the
        argument, true or false, does not matter. If <emphasis role="italic">willReply</emphasis> is omitted, the old style
        notification is used. The documentation for the <link linkend="evtListViewBEGINEDIT">BEGINEDIT</link> event handler
        explains the difference between the two types of notifications.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtListViewBEGINDRAG">BEGINRDRAG</link></term>
      <listitem>
      <para>
        A drag-and-drop operation involving the right mouse button was initiated. See
        <xref linkend="mthDefListDragHandler"/> for information on how to implement a drag-and-drop
        handler.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtListViewBEGINSCROLL">BEGINSCROLL</link></term>
      <listitem>
      <para>
        A scrolling operation is starting.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtListViewGeneral">CHANGED</link></term>
      <listitem>
      <para>
        An item has changed. The notification for this event is sent after the item changed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtListViewGeneral">CHANGING</link></term>
      <listitem>
      <para>
        An item is about to change. The notification for this event is sent before the item is changed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><xref linkend="evtListViewCHECKBOXCHANGED"/></term>
      <listitem>
      <para>
        The check box state of an item changed.  (The check box was checked or unchecked.) This event can only occur if
        the list-view has the check box <link linkend="mthAddExtendedStyle">extended</link> list-view style.  Use this
        keyword instead of the CHANGED keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><xref linkend="evtListViewCLICK"/></term>
      <listitem>
      <para>
        This event notification is generated when the list-view is clicked with the left mouse button. However, in report
        view only, this excludes the column headers. Connecting the CLICK event is a replacement for the
        <xref linkend="mthConnectNotifyEvent"/> method's CLICK event.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><xref linkend="evtListViewCOLUMNCLICK"/></term>
      <listitem>
      <para>
        In report view only, a column header has been clicked. Contrast this with the CLICK keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtListViewCOLUMNCLICK">DBLCLK</link></term>
      <listitem>
      <para>
        This event is generated when the list-view is double-clicked with the left mouse button. However, in
        report view only, this excludes the column headers. Connecting the DBLCLK event is a replacement for the
        <xref linkend="mthConnectNotifyEvent"/> method's DBLCLK event.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtListViewGeneral">DELETE</link></term>
      <listitem>
      <para>
        An item has been deleted.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtListViewGeneral">DELETEALL</link></term>
      <listitem>
      <para>
        All items have been deleted.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywListViewDEFAULTEDIT" xreflabel="DEFAULTEDIT"><term>DEFAULTEDIT</term>
      <listitem>
      <para>
        This keyword is used to activate the internal handling of the list-view label editing operation. With this keyword,
        the ooDialog framework internally handles the BEGINEDIT and ENDEDIT notifications. The list-view must have the <xref
        linkend="styListViewEDIT"/> style for the BEGINEDIT / ENDEDIT notification to be sent. While using the DEFAULTEDIT
        connection may seem easier than using the BEGINEDIT / ENDEDIT connections, it does not provide the same flexibility
        as using the BEGINEDIT / ENDEDIT connections.
      </para>
      <para>
        When you specify this event connection, omit the <emphasis role="italic">methodName</emphasis> argument, the arugment
        is ignored. Do not connect either the BEGINEDIT or ENDEDIT events when also using the DEFAULTEDIT connection. The
        result is undefined.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywListViewENDEDIT" xreflabel="ENDEDIT"><term><xref linkend="evtListViewENDEDIT"/></term>
      <listitem>
      <para>
        Label editing has ended. Do not connect this event if you are using the DEFAULTEDIT keyword. The results are
        undefined. The list-view must have the <xref linkend="styListViewEDIT"/> style for this notification to be sent.
      </para>
      <para>
        The event notification for this event has been enhanced since the original ooDialog implementation. To use the
        enhanced event notification, the <emphasis role="italic">willReply</emphasis> argument must be used. The value of the
        argument, true or false, does not matter. If <emphasis role="italic">willReply</emphasis> is omitted, the old style
        notification is used. The documentation for the <link linkend="evtListViewENDEDIT">ENDEDIT</link> event handler
        explains the difference between the two types of notifications.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtListViewBEGINSCROLL">ENDSCROLL</link></term>
      <listitem>
      <para>
        A scrolling operation has ended.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><xref linkend="evtListViewFOCUSCHANGED"/></term>
      <listitem>
      <para>
        The focus state of an item changed.  (The item gained or lost the focus.) Use this keyword instead of the
        CHANGED keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywListViewGETINFOTIP" xreflabel="GETINFOTIP"><term><xref linkend="evtListViewGETINFOTIP"/></term>
      <listitem>
      <para>
        The list-view control is requesting text to display an info tip. The notification is only sent when the list-view
        control has the extended <link linkend="styListViewInfoTip">INFOTIP</link> style. The extended list-view styles must
        be set using the <link linkend="mthAddExtendedStyle">addExtendedStyle</link> method.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><link linkend="evtListViewGeneral">INSERTED</link></term>
      <listitem>
      <para>
        A new item has been inserted.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><xref linkend="evtListViewKEYDOWN"/> </term>
      <listitem>
      <para>
        A key was pressed inside the list view. This notification is not sent while a label is being edited.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><xref linkend="evtListViewKEYDOWNEX"/></term>
      <listitem>
      <para>
        A key was pressed inside the list view. This notification is not sent while a label is being edited.
      </para>
      <para>
        This event is exactly the same as the KEYDOWN event. Except, when this keyword is used, the ooDialog framework sends
        a different set of arguments to the event handler. The additional arguments provide more information to the
        programmer than the arguments sent when the KEYDOWN keyword is used. The two keywords are needed to provide backwards
        compatibility.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><xref linkend="evtListViewSELECTCHANGED"/></term>
      <listitem>
      <para>
        The selection state of an item changed.  (The item was selected or unselected.)  Use this keyword instead of the
        CHANGED keyword.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><xref linkend="evtListViewSELECTFOCUSCHANGED"/></term>
      <listitem>
      <para>
        The selection state or the focus state of an item changed.  This event argument combines the selection changed
        and the focus changed event into one connection.  When this event is connected, separate selection changed and
        focus changed events can not be connected.  This keyword can be abbreviated to SELECTFOCUS. Use this keyword
        instead of the CHANGED keyword.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the event handling method. This method is invoked each time the specified event occurs for the list
      view control. The method name can not be the empty string. If you omit this argument, the event handler method
      name is generated for you. This name will be the event keyword, preceded by <computeroutput>on</computeroutput>. For
      example: <emphasis role="italic">onColumnClick</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.false</computeroutput>.
    </para>
    <para>
      <emphasis role="bold">Note:</emphasis> The <emphasis role="italic">willReply</emphasis> argument is ignored for the
      GETINFOTIP event, the interpreter always waits for the reply. It makes no sense to connect this event when not planning
      to return a value.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error detected.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The resource ID could not be resolved or the event argument is incorrect.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The event was not connected correctly. The error is likely caused by the message table being full, but could also
      indicate the interpreter is out of memory.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Microsoft continually enhances the Windows User Interface and therefore the dialog controls evolve over time. The
    <computeroutput>connectListViewEvent</computeroutput> method uses several event keywords that provide more
    information, for the same event, than that provided by the original ooDialog implementation.  For instance, the
    CHECKBOXCHANGED, SELECTIONCHANGED, FOCUSCHANGED, and SELECTFOCUSCHANGED keywords all connect the same event as the
    CHANGED keyword.  However, these keyword connections all provide more specific, detailed information in the arguments
    passed to the connected method than that provided by using the CHANGED keyword.
  </para>
  <para>
    Likewise, the <computeroutput>connectListViewEvent</computeroutput> CLICK keyword provides much better information
    than that provided by the <xref linkend="mthConnectNotifyEvent"/>'s CLICK keyword.
  </para>
  <para>
    <emphasis role="bold">Note:</emphasis> If the same event, for the same control, is connected using two different
    connectXXX methods, only one connection will be in effect. Which connectXXX method is invoked is undefined.  For example,
    take a dialog that has a list-view control with resource ID of 109.  If the mouse click event is connected for that
    control using the <computeroutput>connectNotifyEvent</computeroutput> method and then the mouse click event is also
    connected using the <computeroutput>connectListViewEvent</computeroutput> method, only one connection will be active.
    Which one is active is undefined.
  </para>
  <para>
    When using <computeroutput>connectListViewEvent</computeroutput> a separate method can be connected to each of the
    CHECKBOXCHANGED, SELECTIONCHANGED, and FOCUSCHANGED events. These event connections are all replacements for the CHANGED
    event.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example connects the column-clicked event for the list-view EMPLOYEES with method ColumnAction and
    changes the style of the list-view from REPORT to SMALLICON:
  </para>
  <programlisting>
  <![CDATA[
  ::class MyDlgClass subclass UserDialog

  ::method init
    self~init:super(...)
    self~connectListViewEvent("EMPLOYEES", "COLUMNCLICK", "columnAction")

  ::method columnAction unguarded
    use arg id, column
    lc = self~newListView("EMPLOYEES")
    lc~replaceStyle("REPORT", "SMALLICON EDIT SINGLESEL ASCENDING")
    if column > 0 then ...

    return 0
  ]]>
  </programlisting>
  </listitem></varlistentry>
</variablelist>


<section id="evtListViewBEGINDRAG" xreflabel="BEGINDRAG"><title>BeginDrag / BeginRDrag Event Handler</title>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>BEGINDRAG</tertiary></indexterm>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>BEGINRDRAG</tertiary></indexterm>
<para>
  The event handler for the BegingDrag or BeginRDrag events is invoked when a drag-and-drop operation involving the left
  mouse button or the right mouse button is being initiated.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectListViewEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onBeginDrag unguarded
  use arg id, item, point, isLMB, listView

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 5 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource ID of the list view sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>item</term>
    <listitem>
    <para>
      The index of the item being dragged.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>point</term>
    <listitem>
    <para>
      The point where the mouse cursor was pressed (x and y positions, separated by a blank).
    </para>
    </listitem></varlistentry>
    <varlistentry><term>isLMB</term>
    <listitem>
    <para>
      True if the drag was started with the left mouse button, false if the drag was started with the right mouse button.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>listView</term>
    <listitem>
    <para>
      The Rexx list view object that represents the underlying list view that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return value from the event handler. 0 makes a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The defListDragHandler() method is an example of coding a begin drag handler. This method can be found in the
    ooDialog.cls file.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End BeginDrag Event Handler -->


<section id="evtListViewBEGINEDIT" xreflabel="BEGINEDIT"><title>BeginEdit Event Handler</title>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>BEGINEDIT</tertiary></indexterm>
<para>
  The event handler for the BEGINEDIT event is invoked when the user begins a label editing operation on an item of the
  list-view. When label editing begins, an edit control is created by the operating system, but not positioned or displayed.
  Before it is displayed, the tree-view control sends a BEGINEDIT notification message. A label editing operation is only
  available when the list-view has the <xref linkend="styListViewEDIT"/> style.
</para>
<para>
  In general, the programmer would connect both the BEGINEDIT and <xref linkend="evtListViewENDEDIT"/> notifications. Both of
  these event notifications have been enhanced since the original ooDialog implementation. If the <emphasis
  role="italic">willReply</emphasis> argument to the <xref linkend="mthConnectListViewEvent"/> method is omitted the old
  implementation is used. If the argument is not omitted, the new implementation is used. How the two event handlers work is
  described separately.
</para>

<variablelist>
  <varlistentry><term><emphasis role="bold">New event handler description:</emphasis></term>
  <listitem>
    <para>
      Whether the programmer must return a value and if the interpreter waits, or does not wait, for this return is
      determined by the value of the <emphasis role="italic">willReply</emphasis> argument. If <emphasis
      role="italic">willReply</emphasis> is true, the programmer must return true or false from the event handler and the
      interpreter waits for that reply. If <emphasis role="italic">willReply</emphasis> is false the interpreter does not
      wait for a reply.
    </para>

    <programlisting>
    <![CDATA[
    ::method onBeginEdit unguarded
      use arg id, itemID, editCtrl, listViewCtrl

      return zz
    ]]>
    </programlisting>

    <variablelist>
      <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
      <listitem>
      <para>
        The event handling method receives 4 arguments:
      </para>
      <variablelist>
        <varlistentry><term>id</term>
        <listitem>
        <para>
          The resource id of the list-view sending the notification.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>itemID</term>
        <listitem>
        <para>
          The item index whose label is about to be edited.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>editCtrl</term>
        <listitem>
        <para>
          The Rexx edit control object used for the editing operation. The programmer can customize the editing operation by
          using the methods of the <link linkend="clsEdit">Edit</link> class.
        </para>
        <para>
          <emphasis role="bold">Note</emphasis> that this object is only valid during the editing operation. When the user
          ends the editing, the operating system destroys the underlying edit control and the Rexx object is no longer valid.
          Each time the user starts a new editing operation, the operating system creates a new edit control.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>listViewCtrl</term>
        <listitem>
        <para>
          The Rexx list-view object whose underlying list-view control has sent the notification. This is a convenience for
          the programmer. It is the same Rexx object the programmer would receive through the <xref
          linkend="mthNewListView"/> method. Unlike the <emphasis role="italic">editCtrl</emphasis> object, this object is
          valid as long as the dialog is executing.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
      <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
      <listitem>
      <para>
        When the programmer used true for the <emphasis role="italic">willReply</emphasis> argument, the event handler must
        return true or false. To allow the editing operation to begin, return true. To cancel the editing operation, return
        false. Returning a value from the event handler gives the programmer the option determining if the label for the
        specific list-view item should or should not be edited.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><emphasis role="bold">Example</emphasis></term>
      <listitem>
      <para>
        The following example shows a possible event handler for the BEGINEDIT event.  It uses the <emphasis
        role="italic">itemIndex</emphasis> argument to determine which item is about the have its label edited, and checks
        that editing is allowed for that item. If it is, it returns true to allow the operation. If it is not, it returns
        false to cancel the operation and puts up a message box to inform the user:

<programlisting>
<![CDATA[

::method onBeginEdit unguarded
  use arg id, itemIndex, editCtrl, listViewCtrl

  rec = listViewCtrl~getItemData(itemIndex)
  if rec~isEditable then return .true

  reply .false

  msg = "The record for" rec~FirstName rec~LastName 'can not be changed.'
  title = "Label Edit Error"
  j = MessageDialog(msg, self~hwnd, title, , "WARNING")

  return

]]>
</programlisting>
      </para>
      </listitem></varlistentry>
    </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Old event handler description:</emphasis></term>
  <listitem>
  <para>
    The old style event notification is used when the programmer omits the <emphasis role="italic">willReply</emphasis>
    argument in the invocation of the <xref linkend="mthConnectListViewEvent"/> method. The return from the event handler is
    completely ignored, the interpreter does not wait for this return.
  </para>

  <programlisting>
  <![CDATA[
  ::method onBeginEdit unguarded
    use arg id, useless
  ]]>
  </programlisting>

  <variablelist>
    <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
    <listitem>
    <para>
      The event handling method receives 2 arguments:
    </para>
    <variablelist>
      <varlistentry><term>id</term>
      <listitem>
      <para>
        The resource id of the list-view sending the notification.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>useless</term>
      <listitem>
      <para>
        This is an operating system value that has no meaning within Rexx code. It can not be used for anything and its value
        does not correlate with anything accessible to the Rexx programmer.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
    <listitem>
    <para>
      Returning, or not returning, a value has no meaning.
    </para>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Remarks</emphasis></term>
    <listitem>
    <para>
      Connecting this event and not using the <emphasis role="italic">willReply</emphasis> argument does not make much sense.
      The event handler really serves no purpose.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End BeginEdit Event Handler -->


<section id="evtListViewBEGINSCROLL" xreflabel="BEGINSCROLL"><title>BeginScroll / EndScroll Event Handler</title>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>BEGINSCROLL</tertiary></indexterm>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>ENDSCROLL</tertiary></indexterm>
<para>
  The event handler for the begin scroll event is invoked when a scrolling operation starts and the event handler for the
  end scroll event is invoked when a scrolling operation ends. The scrolling operation can be either horizontal or vertical
  scrolling. Both event handlers receive the same arguments and are basically coded the same.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectListViewEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onBeginScroll unguarded
  use arg ctrlID, dx, dy, listView, isBeginScroll

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 5 arguments:
  </para>
  <variablelist>
    <varlistentry><term>ctrlID</term>
    <listitem>
    <para>
      The resource ID of the list-view that generated the event notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dx</term>
    <listitem>
    <para>
      The Microsoft documentation says that this value specifies in pixels the horizontal position where a scrolling
      operation should begin. However, a similar description for the <emphasis role="italic">dy</emphasis> value is not
      correct, making it difficult to see if the Microsoft documentation is accurate for the <emphasis
      role="italic">dx</emphasis> value.
    </para>
    <para>
      The value is 0 if the scrolling operation was vertical. It is negative if the horizontal scrolling was to the left, and
      positive if the operation was to the right.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>dy</term>
    <listitem>
    <para>
      The Microsoft documentation says that this value specifies in pixels the vertical position where a scrolling
      operation should begin. However, experimentation shows that is actually the number of items scrolled.
    </para>
    <para>
      The value is 0 if the scrolling operation was horizontal. It is negative if the vertical scrolling was towards the
      top, and positive if the operation was towards the bottom.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>listView</term>
    <listitem>
    <para>
      The Rexx list view object that represents the underlying list view that generated the event notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>isBeginScroll</term>
    <listitem>
    <para>
      The event handlers for both the BEGINSCROLL and ENDSCROLL are identical. This argument allows the Rexx programmer to
      connect both events to the same method and then distinguish in the event handler which event occurred. This argument is
      true if the event which caused the event handler to be invoked was the BEGINSCROLL event and false if the event was
      ENDSCROLL.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The value of the return is ignored by the operating system. 0 makes a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example connects both the BEGINSCROLL and ENDSCROLL events to the same event handling method. The method
    simply prints out the values sent by the operating system:

<programlisting>
<![CDATA[

::method onScroll unguarded
  use arg id, dx, dy, listView, isBeginScroll

  if isBegin then op = 'beginScroll'
  else op = 'endScroll'

  say 'id:' id 'dx:' dx 'dy:' dy 'listView:' listView op

  return 0

/* Output might be for example: */

id 200 dx: 5 dy: 0 listView: a ListView beginScroll
id 200 dx: 5 dy: 0 listView: a ListView endScroll
id 200 dx: 5 dy: 0 listView: a ListView beginScroll
id 200 dx: 5 dy: 0 listView: a ListView endScroll
id 200 dx: 5 dy: 0 listView: a ListView beginScroll
id 200 dx: 5 dy: 0 listView: a ListView endScroll
id 200 dx: 158 dy: 0 listView: a ListView beginScroll
id 200 dx: 158 dy: 0 listView: a ListView endScroll
id 200 dx: -173 dy: 0 listView: a ListView beginScroll
id 200 dx: -173 dy: 0 listView: a ListView endScroll
id 200 dx: 0 dy: 1 listView: a ListView beginScroll
id 200 dx: 0 dy: 1 listView: a ListView endScroll

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End BeginScroll / EndScroll Event Handler -->


<section id="evtListViewCHECKBOXCHANGED" xreflabel="CHECKBOXCHANGED"><title>CheckBoxChanged Event Handler</title>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>CHECKBOXCHANGED</tertiary></indexterm>
<para>
  The event handler for the checkbox changed event is invoked when the user checks or unchecks a checkbox in the
  <computeroutput>ListView</computeroutput> control.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectListViewEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onCheckboxChanged unguarded
  use arg id, itemIndex, state, listView

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 4 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the list view control sending the notification message.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>itemIndex</term>
    <listitem>
    <para>
      The index of the item whose checkbox was changed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>state</term>
    <listitem>
    <para>
      This argument reports whether the check box was checked or unchecked.  Its value will be either
      <emphasis role="italic">CHECKED</emphasis> or <emphasis role="italic">UNCHECKED</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>listView</term>
    <listitem>
    <para>
      The Rexx list view object that represents the underlying list view that generated the event notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this event handler. 0 makes a good return values.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example is from an address book application. A list-view control is filled with the information from the
    address book, one item for each entry. The check box changed event is connected to the <emphasis
    role="italic">onCheckboxChanged</emphasis> method. The <emphasis
    role="italic">onCheckboxChanged</emphasis> method will receive 3 arguments: the resource ID of the control, the index of
    the item whose check box changed, and the changed state. If the user checks the check box, that entry is added to a mail
    merge being constructed. If the user unchecks the box, the entry is removed from the mail merge.

<programlisting>
<![CDATA[
::class MailingListDlg subclass UserDialog

::method initDialog
  expose mailList

  ...
  mailList = self~newListView(IDC_LV_ADDRESSES)
  ...

  -- Since the methodName argument is omitted, ooDialog will construct a default
  -- name of 'onCheckboxChanged'
  self~connectListViewEvent(IDC_LV_ADDRESSES, "CHECKBOXCHANGED")
  ...

::method onCheckboxChanged unguarded
  use arg id, itemIndex, state, mailList

  if state == "CHECKED" then
    self~addToMailMerge(mailList, itemIndex)
  else
    self~removeFromMailMerge(mailList, itemIndex)

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End CheckBoxChanged Event Handler -->


<section id="evtListViewCLICK" xreflabel="CLICK"><title>Click / Double Click Event Handler</title>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>CLICK</tertiary></indexterm>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>DBLCLK</tertiary></indexterm>
<para>
  The event handling method for the CLICK event is invoked when the user clicks on the list-view with the left mouse.
  The event handler for the DBLCLK is invoked when the user double clicks on the list-view. This excludes the column
  headers in report view. Both event handlers receive the same arguments and are coded the same way.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectListViewEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>
<para>
  Note that the user can click on a list-view item, or on the background of the list view. When the click is on the
  background of the list-view then both the <emphasis role="italic">itemIndex</emphasis> and <emphasis
  role="italic">columnIndex</emphasis> will be -1. The method will receive four arguments:
</para>

<programlisting>
<![CDATA[
  ::method onClick unguarded
    use arg id, itemIndex, columnIndex, keyState, listView

    return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 5 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the list view control sending the notification message.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>itemIndex</term>
    <listitem>
    <para>
      The index of the item that was clicked on.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>columnIndex</term>
    <listitem>
    <para>
      The index of the column in the item that was clicked on. If not in report view, this will always be 0.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>keyState</term>
    <listitem>
    <para>
      One or more keywords, separated by blanks, that report the shift, alt, control key state. It will either be the single
      key word: <emphasis role="italic">NONE</emphasis>, or any combination of <emphasis role="italic">SHIFT</emphasis>
      <emphasis role="italic">CONTROL</emphasis> <emphasis role="italic">ALT</emphasis>. The keywords report which of the
      keys were pressed at the time of the mouse click or double click.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>listView</term>
    <listitem>
    <para>
      The Rexx list view object that represents the underlying list view that generated the event notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this event handler. 0 makes a good return values.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>


<section id="evtListViewCOLUMNCLICK" xreflabel="COLUMNCLICK"><title>ColumnClick Event Handler</title>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>COLUMNCLICK</tertiary></indexterm>
<para>
  The event handler for the column click event is invoked when when the user clicks on a column header in a list view in
  report view.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectListViewEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onColumnClick unguarded
  use arg id, col, listView

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 3 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the list view control sending the notification message.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>col</term>
    <listitem>
    <para>
      The zero-based index of the column that was clicked.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>listView</term>
    <listitem>
    <para>
      The Rexx list view object that represents the underlying list view that generated the event notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return for this notification. 0 makes a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example comes from and application that allows the user to sort the columns in the list view when it is in
    report view. When the application is first opened none of the columns are sorted and the first click on any column sorts
    the list-view items on that column in ascending order. Subsequent clicks on the column header reverses the current state.
    If the column is sorted in ascending order, a click sorts it in descending order ...

<programlisting>
<![CDATA[
::method connectEvents private

    self~connectButtonEvent(IDC_RB_REPORT, "CLICKED", onReport, .true)
    self~connectButtonEvent(IDC_RB_LIST, "CLICKED", onList, sync)
    self~connectButtonEvent(IDC_RB_ICON, "CLICKED", onIcon)
    self~connectButtonEvent(IDC_RB_SMALL_ICON, "CLICKED", onSmallIcon, .false)
    self~connectListViewEvent(IDC_LV_VIEWS, "COLUMNCLICK", onColClick, .true)
    self~connectListViewEvent(IDC_LV_VIEWS, "BEGINDRAG", defListDragHandler)


::method onColClick unguarded
    expose itemColumns
    use arg id, colIndex, listView

    -- Adjust for 0-based indexes
    i = colIndex + 1

    d = .directory~new
    d~column = colIndex
    d~caseless = .false

    if itemColumns[i] == -1 then do
      d~ascending = .true
      itemColumns[i] = 0
    end
    else if itemColumns[i] == 0 then do
      d~ascending = .false
      itemColumns[i] = 1
    end
    else do
      d~ascending = .true
      itemColumns[i] = 0
    end

    listView~sortItems('InternalListViewSort', d)
    return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End ColumnClick Event Handler -->


<section id="evtListViewENDEDIT" xreflabel="ENDEDIT"><title>EndEdit Event Handler</title>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>ENDEDIT</tertiary></indexterm>
<para>
  The event handler for the ENDEDIT event is invoked when the user finishes a label editing operation on an item of the
  list-view. A label editing operation is only available when the list-view has the <xref linkend="styListViewEDIT"/> style.
</para>
<para>
  In general, the programmer would connect both the <xref linkend="evtListViewBEGINEDIT"/> and ENDEDIT notifications. Both
  of these event notifications have been enhanced since the original ooDialog implementation. If the <emphasis
  role="italic">willReply</emphasis> argument to the <xref linkend="mthConnectListViewEvent"/> method is omitted the old
  implementation is used. If the argument is not omitted, the new implementation is used. How the two event handlers work is
  described separately.
</para>

<variablelist>
  <varlistentry><term><emphasis role="bold">New event handler description:</emphasis></term>
  <listitem>
  <para>
    The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectListViewEvent"/> method
    determines how the event handler needs to respond to the notification.
  </para>

<programlisting>
<![CDATA[
::method onEndEdit unguarded
  use arg id, itemID, text, listViewCtrl

  return trueOrFalse
]]>
</programlisting>

  <variablelist>
    <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
    <listitem>
    <para>
      The event handling method receives 4 arguments:
    </para>
    <variablelist>
      <varlistentry><term>id</term>
      <listitem>
      <para>
        The resource id of the list-view sending the notification.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>itemID</term>
      <listitem>
      <para>
        The item index whose label being edited.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>text</term>
      <listitem>
      <para>
        If the user canceled the edit operation then the <emphasis role="italic">text</emphasis> argument will be the .nil
        object. If the edit operation was not canceled then this argument will be the text the user entered.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>listViewCtrl</term>
      <listitem>
      <para>
        The Rexx list-view object whose underlying list-view control has sent the notification. This is a convenience for
        the programmer. It is the same Rexx object the programmer would receive through the <xref
        linkend="mthNewListView"/> method.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
    <listitem>
    <para>
      When the programmer used true for the <emphasis role="italic">willReply</emphasis> argument, the event handler must
      return true or false. To accept the edit text, return true. To disallow the change to the label, return false.
      If, the edit operation was canceled by the user, the operating system ignores the return from the event handler.
      Returning a value from the event handler gives the programmer the option of determining if the new label for the
      specific list-view item is acceptable.
    </para>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Example</emphasis></term>
    <listitem>
    <para>
      The following example checks the new text entered by the user. The label for the list-view items is displayed as last
      name, comma, first name. If the user's text is not in that format, the new text is rejected by returning false:

<programlisting>
<![CDATA[

::method onEndEdit unguarded
use arg id, itemIndex, text, listViewCtrl

if text == .nil then return .false

if text~words == 2 & text~word(1)~right(1) == ',' then do
  reply .true

  rec = listViewCtrl~getItemData(itemIndex)
  rec~FirstName = text~word(2)
  rec~LastName  = text~word(1)~strip('T', ',')

  return
end

reply .false

msg = "The format for a record label must be" || .endOfLine || -
      "last name, comma, first name.  For"    || .endOfLine || -
      "example: Swift, Tom"                   || .endOfLine~copies(2) || -
      "The change is rejected."

title = "Label Editing Error"
j = MessageDialog(msg, self~hwnd, title, , "WARNING")

return

]]>
</programlisting>
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Old event handler description:</emphasis></term>
  <listitem>
  <para>
    The old style event notification is used when the programmer omits the <emphasis role="italic">willReply</emphasis>
    argument in the invocation of the <xref linkend="mthConnectListViewEvent"/> method. The return from the event handler is
    completely ignored, the interpreter does not wait for this return. If the user canceled the edit operation, the label
    will be unchanged. If the user did not cancel the edit operation, the label of the item is changed to the text the user
    entered.
  </para>

  <programlisting>
  <![CDATA[
  ::method onEndEdit unguarded
    use arg id, itemIndex, maybeText, listView
  ]]>
  </programlisting>

  <variablelist>
    <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
    <listitem>
    <para>
      The event handling method receives 4 arguments:
    </para>
    <variablelist>
      <varlistentry><term>id</term>
      <listitem>
      <para>
        The resource id of the list-view sending the notification.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>itemIndex</term>
      <listitem>
      <para>
        The index of the list-view item that was edited.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>text [optional]</term>
      <listitem>
      <para>
        If the user canceled the edit operation, the <emphasis role="italic">text</emphasis> argument is omitted. If the user
        did not cancel, then the <emphasis role="italic">text</emphasis> argument is the text the user entered.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>listView</term>
      <listitem>
      <para>
        The Rexx list-view object that represents the underlying list-view control has sent the notification.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
    <listitem>
    <para>
      Returning, or not returning, a value has no meaning. The interpreter does not wait for the return and its value, if any
      is discarded. However, best practice would be to always return a value from an event handler, 0 makes a good return
      value.
    </para>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Remarks</emphasis></term>
    <listitem>
    <para>
      When the user does not cancel the edit operation, the operating system automatically changes the label of the item to
      what the user entered. To prevent this behavior, the programmer needs to use the new style event handler by using the
      <emphasis role="italic">willReply</emphasis> argument to the <xref linkend="mthConnectListViewEvent"/> method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End EndEdit Event Handler -->


<section id="evtListViewFOCUSCHANGED" xreflabel="FOCUSCHANGED"><title>FocusChanged Event Handler</title>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>FOCUSCHANGED</tertiary></indexterm>
<para>
  The event handler for the focus changed event is invoked when a list view item gains or loses the focus.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectListViewEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onFocusChanged unguarded
  use arg id, itemIndex, state, listView

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 4 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the list view control that sent the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>itemIndex</term>
    <listitem>
    <para>
      The index of the item which gained or lost the focus.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>state</term>
    <listitem>
    <para>
      This argument reports whether the focus was gained or lost. Its value will be either <emphasis
      role="italic">FOCUSED</emphasis> or <emphasis role="italic">UNFOCUSED</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>listView</term>
    <listitem>
    <para>
      The Rexx <computeroutput>ListView</computeroutput> object whose underlying Windows list view sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this notification. 0 make a good return value.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End FocusChanged Event Handler -->


<section id="evtListViewGeneral" xreflabel="General"><title>General ListView Event Handler</title>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>General</tertiary></indexterm>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>ACTIVATE</tertiary></indexterm>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>CHANGED</tertiary></indexterm>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>CHANGING</tertiary></indexterm>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>DELETE</tertiary></indexterm>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>DELETEALL</tertiary></indexterm>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>INSERTED</tertiary></indexterm>
<para>
  A number of the list view events are processed internally by ooDialog in the same manner. The event handlers for these
  events are sent the same arguments and are essentially coded the same way. This <emphasis role="italic">general</emphasis>
  event handler is described here for the ACTIVATE, CHANGED, CHANGING, DELETE, DELETEALL, INSERTED events. The description
  for event keyword in the <xref linkend="mthConnectListViewEvent"/> documentation details when each event will invoke this
  event handler.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectListViewEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onListViewEvent unguarded
  use arg id, ptr, notifyCode, listView

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 4 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource ID of the list view sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>ptr</term>
    <listitem>
    <para>
      The numeric value of a pointer to a memory location in the running application. This is of no conceivable use to the
      ooDialog programmer, but is retained for backwards compatibility.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>notifyCode</term>
    <listitem>
    <para>
      The numeric notification code of the event that caused the notification to be sent. Each dialog control has its own
      specific notification codes.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>listView</term>
    <listitem>
    <para>
      The Rexx list view object that represents the underlying dialog control that sent the notification. It is possible
      this will be the <computeroutput>.nil</computeroutput> object if some error happened, but this is very unlikely.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The implementation for these general list view events has been in ooDialog for a very long time. The implementation
    returns 0 to the operating system. 0 makes a good return value.
  </para>
  <para>
    However, beginning in ooDialog 4.2.4, <emphasis role="italic"><emphasis role="bold">if</emphasis></emphasis> the <link
    linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectListViewEvent"/> method is set to
    true by the programmer, the ooDialog framework will take the value returned from the event handler and return that value
    to the operating system. See the remarks section for some guidance on the meaning of a returned value for these general
    events.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The return from the event notifications in this <emphasis role="italic">general</emphasis> category is ignored by the
    operating system for some of the events, but has meaning for some of the other events. ooDialog has been enhanced to
    allow the programmer to return a meaningful value to the operating system from this general event handler. If the
    <emphasis role="italic">willReply</emphasis> argument is set to true, the interpreter waits for the return value from the
    event handler and returns that value to the operating system. Here is a brief description of the meaning for the returned
    value for the general events:
  </para>
  <variablelist>
    <varlistentry><term>ACTIVATE</term>
    <listitem>
    <para>
      MSDN says the event handler must return 0 for this event.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>CHANGED</term>
    <listitem>
    <para>
      The operating system ignores the return for this event. 0 makes a good return value.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>CHANGING</term>
    <listitem>
    <para>
      Return true to prevent the change or false to allow the change. Note however that this general event handler is not
      sent sufficient information for the programmer ot make a good decision if she should prevent the change. A future
      enhancement to ooDialog may allow better handling of this event notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>DELETE</term>
    <listitem>
    <para>
      The operating system ignores the return for this event. 0 makes a good return value.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>DELETEALL</term>
    <listitem>
    <para>
      The operating system sends this notification when all items in a list view are about to be deleted. After that a DELETE
      notification is sent for each item that is deleted. If the event handler returns true for the DELETEALL notification
      the individual DELETE notifications are not sent. If the event handler returns false, the individual notifications are
      sent.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>INSERTED</term>
    <listitem>
    <para>
      The operating system ignores the return for this event. 0 makes a good return value.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End General ListView Event Handler -->


<section id="evtListViewGETINFOTIP" xreflabel="GETINFOTIP"><title>GetInfoTip Event Handler</title>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>GETINFOTIP</tertiary></indexterm>
<para>
  The event handler method connected to the get info tip event is invoked when the list-view control requests the text to
  display in the info tip. The programmer must return a string value and the interpreter waits for this return. The <emphasis
  role="italic">willRepy</emphasis> argument of the <link linkend="mthConnectListViewEvent">connectListViewEvent</link>
  method is ignored for this event.
</para>

<programlisting>
<![CDATA[
::method onGetInfoTip unguarded
  use arg id, itemIndex, text, maxLen, listView

  return infoText
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 5 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the list-view control requesting the info tip text.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>itemIndex</term>
    <listitem>
    <para>
      The index of the list-view item that the info tip is for.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>text</term>
    <listitem>
    <para>
      The current text the list-view intends to display. Note that most often this is the empty string. However, in some
      cases it will not be the empty string. For instance, in report view, if the column is not wide enough to display the
      entire text for the item, the <emphasis role="italic">text</emphasis> argument will contain the entire item's text.
      Microsoft suggests that if <emphasis role="italic">text</emphasis> is not the empty string, the application should
      append its text to the end of the string.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>maxLen</term>
    <listitem>
    <para>
      The maximum length of the string that will be displayed. The programmer should not assume what this length is. However,
      testing shows that it is usually 1023. If the returned text is longer than the <emphasis
      role="italic">maxLen</emphasis> value, the text will automatically be truncated to <emphasis
      role="italic">maxLen</emphasis> characters.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>listView</term>
    <listitem>
    <para>
      The Rexx list view object that represents the underlying dialog control that sent the notification. It is possible
      this will be the <computeroutput>.nil</computeroutput> object if some error happened, but this is very unlikely.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The event handler must return a string value. If the string is not the empty string, it will be displayed as the info
    tip. If the empty string is returned, then the previous value of <emphasis role="italic">text</emphasis> is
    displayed. That is, if <emphasis role="italic">text</emphasis> is the empty string, no info tip will be shown. However,
    if <emphasis role="italic">text</emphasis> is not the empty string, that text will be displayed unchanged.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example example displays an info tip that shows expanded record information for the list-view item. The
    <emphasis role="italic">useInfoTips</emphasis> variable is used to determine if an info tip should be displayed or not.
    If <emphasis role="italic">useInfoTips</emphasis> is false, no tip is displayed. If true the record information is
    formatted and returned. Note that new line characters are used to break up the information into lines:

<programlisting>
<![CDATA[

::method onGetInfoTip unguarded
  expose records useInfoTips
  use arg id, item, text, maxLen, listView

  text = ''

  if useInfoTips then do
    r = records[item + 1]
    text = r~firstName r~lastName '('r~age')' || .endOfLine || -
           r~street                           || .endOfLine || -
           r~city',' r~state r~zipcode
  end

  return text
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End GetInfoTip Event Handler -->


<section id="evtListViewKEYDOWN" xreflabel="KEYDOWN"><title>KeyDown Event Handler</title>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>KEYDOWN</tertiary></indexterm>
<para>
  The event handler for the key down event is invoked when the user types a key when the list view has the focus.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectListViewEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onKeyDown unguarded
  use arg id, vKey, listView

  return zz
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 3 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the list-view control that sent the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>vKey</term>
    <listitem>
    <para>
      The virtual key code of of the key pressed. The <xref linkend="clsVK"/> class can be used to determine which key was
      pressed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>listView</term>
    <listitem>
    <para>
      The Rexx list view object that represents the underlying dialog control that sent the notification. It is possible
      this will be the <computeroutput>.nil</computeroutput> object if some error happened, but this is very unlikely.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return for this notification. 0 make a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example is from an application that allows the user to delete a list view item by pressing the Del key when
    the item to be deleted is selected. The list view is single selection

<programlisting>
<![CDATA[
::method onKeyDown unguarded
  use arg id, vkey, listView

  if vKey == .VK~DELETE then do
    selectedIndex = listView~selected
    if selectedIndex <> -1 then do
      listView~delete(selectedIndex)
      if selectedIndex == listView~items then do
        if selectedIndex == 0 then do
          -- Do nothing, there are no items in the list-view now.
          nop
        end
        else do
          listView~select(selectedIndex - 1)
        end
      end
      else do
        listView~select(selectedIndex)
      end
    end
  end

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End KeyDown Event Handler -->


<section id="evtListViewKEYDOWNEX" xreflabel="KEYDOWNEX"><title>KeyDown (extended) Event Handler</title>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>KEYDOWNEX</tertiary></indexterm>
<para>
  The event-handling method connected through the KEYDOWNEX keyword is similar to the event handler for the <link
  linkend="evtListViewKEYDOWN">KeyDown</link> event handler. It is invoked for the same event, when the user presses a key
  within the list-view. However, it receives a different set of arguments than that provided when the KEYDOWN keyword is
  used. The arguments sent to the KEYDOWNEX event handler provide more information about the event. This allows the
  programmer to write a more flexible event handler.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectListViewEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onKeyDownEx unguarded
  use arg vKey, isShift, isCtrl, isAlt, extraInfo, listViewObj, id

  return response
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Event Handler Method Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 7 arguments:
  </para>
  <variablelist>
    <varlistentry><term>vKey</term>
    <listitem>
    <para>
      The virtual key code of of the key pressed. The <xref linkend="clsVK"/> class can be used to determine which key was
      pressed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>isShift</term>
    <listitem>
    <para>
      A boolean (true or false) that denotes whether a shift key was down or up at the time of the key press. It will
      be true if a shift key was down and false if the shift key was not down.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>isCtrl</term>
    <listitem>
    <para>
      True if a control key was down at the time of the key press, false if it was not.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>isAlt</term>
    <listitem>
    <para>
      True if an alt key was down at the time of the key press, false if it was not.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>extraInfo</term>
    <listitem>
    <para>
      This argument is a string containing keywords.  It supplies extra information about the keyboard state at the
      time of a key press event. The string will contain some combination of these keywords
      <variablelist>
        <varlistentry><term>extended</term>
        <listitem>
        <para>
          The character event is for one of the extended keys previously mentioned, INS, DEL, HOME, END, PAGE UP, PAGE
          DOWN, or one of the arrow keys.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>numOn</term>
        <listitem>
        <para>
          Num Lock was on at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>numOff</term>
        <listitem>
        <para>
          Num Lock was off.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>capsOn</term>
        <listitem>
        <para>
          Caps Lock was on at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>capsOff</term>
        <listitem>
        <para>
          Caps Lock was off.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>scrollOn</term>
        <listitem>
        <para>
          Scroll Lock was on at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>scrollOff</term>
        <listitem>
        <para>
          Scroll Lock was off.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>lShift</term>
        <listitem>
        <para>
          The left shift key was down at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>rShift</term>
        <listitem>
        <para>
          The right shift key was down.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>lControl</term>
        <listitem>
        <para>
          The left control key was down at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>rControl</term>
        <listitem>
        <para>
          The right control key was down.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>lAlt</term>
        <listitem>
        <para>
          The left alt key was down at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>rAlt</term>
        <listitem>
        <para>
          The right alt key was down.
        </para>
        </listitem></varlistentry>
      </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>listViewObj</term>
    <listitem>
    <para>
      The Rexx <computeroutput>ListView</computeroutput> object whose underlying Windows list-view had the keydown event.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the list-view control that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>

  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    When the <emphasis role="italic">willReply</emphasis> argument to the <xref linkend="mthConnectListViewEvent"/> method is
    true, the event handler must return a value. However, the operating system ignores the return value, so any value can be
    used. 0 makes a good return.
  </para>
  <para>
    If <emphasis role="italic">willReply</emphasis> is false or SYNC, the event handler does not <emphasis
    role="italic">have</emphasis> to return a value, but good practice would be to always return a value from an event
    handler.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example uses an event handler that deletes the selected item if the user presses the DEL key while holding
    down the control key. The next item following the deleted item is then selected. However, if the deleted item is the last
    item in the last, then the previous item is selected.  If the deleted item is the last item in the list, then nothing is
    selected:

<programlisting>
<![CDATA[

::method onKeyDownEx unguarded
    use arg vKey, isShift, isCtrl, isAlt, extraInfo, listViewObj, id

    if vKey == .VK~DELETE & isCtrl then do
        selectedIndex = listView~selected
        if selectedIndex <> -1 then do
            listView~delete(selectedIndex)
            if selectedIndex == listView~items then do
                if selectedIndex == 0 then do
                    -- Do nothing, there are no items in the list-view now.
                    nop
                end
                else do
                    listView~select(selectedIndex - 1)
                end
            end
            else do
                listView~select(selectedIndex)
            end
          end
    end

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End KeyDown (extended) Event Handler -->


<section id="evtListViewSELECTCHANGED" xreflabel="SELECTCHANGED"><title>SelectChanged Event Handler</title>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>SELECTCHANGED</tertiary></indexterm>
<para>
  The event handler for the select changed event is invoked when only the selection state of a list view item has changed.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectListViewEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onSelectChanged unguarded
  use arg id, itemIndex, state, listView

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 4 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the list view that sent the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>itemIndex</term>
    <listitem>
    <para>
      The index of the list view item whose selection was changed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>state</term>
    <listitem>
    <para>
      This argument reports whether the item was selected or unselected.  Its value will be either <emphasis
      role="italic">SELECTED</emphasis> or <emphasis role="italic">UNSELECTED</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>listView</term>
    <listitem>
    <para>
      The Rexx <computeroutput>ListView</computeroutput> object that represents the underlying Windows list view that sent
      the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this notification. 0 makes a good return value.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End SelectChanged Event Handler -->



<section id="evtListViewSELECTFOCUSCHANGED" xreflabel="SELECTFOCUSCHANGED"><title>SelectFocusChanged Event Handler</title>
<indexterm><primary>ListView class</primary><secondary>events</secondary><tertiary>SELECTFOCUSCHANGED</tertiary></indexterm>
<para>
  The event handler for the selection or focus changed event is invoked when either the selection or the focus of a list view
  item changes.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectListViewEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onSelectFocusChanged unguarded
  use arg id, itemIndex, listView

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 4 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the list view that sent the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>itemIndex</term>
    <listitem>
    <para>
      The index of the list view item where the state was changed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>state</term>
    <listitem>
    <para>
      This argument reports whether the focus was gained or lost and whether the selection was gained or lost. Its
      value will contain at least one of the keywords: <emphasis role="italic">SELECTED</emphasis>, <emphasis
      role="italic">UNSELECTED</emphasis>, <emphasis role="italic">FOCUS</emphasis>, or <emphasis
      role="italic">UNFOCUSED</emphasis>. It is possible for both the selection and focus changed to be reported at once, however
      sometimes each change is reported separately. (This has nothing to do with ooDialog, it is how the operating system
      sends the messages.)
    </para>
    </listitem></varlistentry>
    <varlistentry><term>listView</term>
    <listitem>
    <para>
      The Rexx <computeroutput>ListView</computeroutput> object that represents the underlying Windows list view that sent
      the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this notification. 0 makes a good return value.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End SelectFocusChanged Event Handler -->

</section>  <!-- End EventNotification::connectionListViewEvent() -->


<section id="mthConnectMonthCalendarEvent" xreflabel="connectMonthCalendarEvent"><title>connectMonthCalendarEvent</title>
<indexterm><primary>connectMonthCalendarEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectMonthCalendarEvent</secondary></indexterm>
<indexterm><primary>EventNotification</primary><secondary>connectMonthCalendarEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectMonthCalendarEvent(--id-,-event-+---------+-+------------+--)-------><
                                           +-,-mName-+ +-,-wilReply-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectMonthCalendarEvent</emphasis> method connects an <xref linkend="ovvEvents"/>
  notification message from a <xref linkend="clsMonthCalendar"/> control to a method in the Rexx dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the month calendar control. May be numeric or <xref linkend="defSymbolicId"/>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>event [required]</term>
      <listitem>
      <para>
        Exactly one of the following keywords. The keyword specifies the event to be connected. Case is not significant:
      </para>
      <para>
        <simplelist type='vert' columns='3'>
          <member>GETDAYSTATE</member>
          <member>RELEASED</member>
          <member>SELCHANGE</member>
          <member>SELECT</member>
          <member>VIEWCHANGE</member>
        </simplelist>
      </para>
      <variablelist>
        <varlistentry><term><xref linkend="evtMonthCalendarGETDAYSTATE"/></term>
        <listitem>
        <para>
           Sent by a month calendar control to request information about how individual days should be displayed. This
           notification message is only sent if the month calendar control has the DAYSTATE style. The <emphasis
           role="italic">willReply</emphasis> argument is ignored for this event, the event handler must
           <link linkend="sctCodingEventHandlers">return</link> a reply.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtMonthCalendarRELEASED"/></term>
        <listitem>
        <para>
          Sent by the month calendar when the control is releasing the mouse capture. The return value from the event
          handler is ignored for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtMonthCalendarSELECT"/></term>
        <listitem>
        <para>
          Sent by a month calendar control when the user makes an explicit date selection within the control. The return
          value from the event handler is ignored for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtMonthCalendarSELCHANGED"/></term>
        <listitem>
        <para>
          Sent by a month calendar control when the currently selected date or range of dates changes. The return value
          from the event handler is ignored for this event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtMonthCalendarVIEWCHANGE"/></term>
        <listitem>
        <para>
          <emphasis role="bold">Requires Windows Vista or later</emphasis>. Sent by a month calendar control when the
          current view changes. The return value from the event handler is ignored for this event.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
      <varlistentry><term>mName [optional]</term>
      <listitem>
      <para>
        The name of the method that is to be invoked whenever the specified notification is received from the month
        calendar control. The programmer defines this method. If this argument is omitted, a method name is
        automatically generated that consists of the event keyword preceded by <computeroutput>on</computeroutput>. For
        instance, <computeroutput>onGetDayState</computeroutput>. If the method name is supplied, it can not be the
        empty string.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>willReply [optional]</term>
      <listitem>
      <para>
        The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
        handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
        <computeroutput>.true</computeroutput>.
      </para>
      <para>
        However, this argument is ignored for the GETDAYSTATE event. If the programmer connects the GETDAYSTATE, the event
        handler must return a value. This can not be changed.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    This method returns <computeroutput>.true</computeroutput> if the event notification was connected correctly,
    otherwise <computeroutput>.false</computeroutput> .
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected, including the use of an invalid symbolic ID or an
    unrecognized event keyword. A syntax error is raised if the programmer tries to connect the VIEWCHANGED event when
    the operating system is not Windows Vista or later.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if the
    connected event happens.
  </para>
  <para>
    The underlying dialog receives the MCN_* messages as the notifications for the month calendar events.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example updates the text of a static control whenever the user selects a new date in the calendar.
  </para>
<programlisting>
<![CDATA[

::method initDialog

  self~connectMonthCalendarEvent(IDC_MC, "SELECT", onSelect)

::method onSelect unguarded
  expose dateText
  use arg startDate, endDate

  dateText~setText(self~formatDate(startDate))
  return 0

]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>


<section id="evtMonthCalendarGETDAYSTATE" xreflabel="GETDAYSTATE"><title>GetDayState Event Handler</title>
<indexterm><primary>MonthCalendar class</primary><secondary>events</secondary><tertiary>GETDAYSTATE</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onGetDayState unguarded
  use arg startDate, count, id, hwnd

  return dayStateBuffer
]]>
</programlisting>

<para>
  The event handler for the get day state event is invoked when the month calendar control requests information on how
  to display days in the calendar. The notification is only sent when the month calendar has the DAYSTATE style. The
  programmer must reply to this notification and <emphasis role="bold">must</emphasis> use the
 <xref linkend="clsDayStates"/> class to properly construct the reply. The interpreter waits for the reply.
</para>
<para>
  The reply is a buffer containing a sequential collection of <xref linkend="clsDayState"/> values. Each
  individual day state value specifies how each day in a single month should be displayed. If a day in the day state
  value is turned on, the day is displayed in bold. If a day is not turned on, it is displayed with no emphasis. The
  <computeroutput>DayStates</computeroutput> and <computeroutput>DayState</computeroutput> classes provide methods to
  properly construct the day state values and the buffer containing the values.
</para>
<para>
  Essentially, the programmer constructs a number of day state values and then returns a buffer containing those values.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives three arguments:
  </para>
  <variablelist>
    <varlistentry><term>startDate</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that specifies the start date the month calendar control needs
      day state values for. Each day state value specifies the state for every day in a month, even if the <emphasis
      role="italic">dayState</emphasis> arg is a date in the middle of a month. I.e., if the start date is January 11,
      2011, the first day state value should be for the month of January.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>count</term>
    <listitem>
    <para>
      The number of day state values required.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID for the month calendar control requesting the information.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window <xref linkend="defHandle"/> for the month calendar control requesting the information.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The reply is a buffer containing a sequential collection of <xref linkend="clsDayState"/> values. Each
    individual day state value specifies how each day in a single month should be displayed. If a day in the day state
    value is turned on, the day is displayed in bold. If a day is not turned on, it is displayed with no emphasis. The
    returned buffer must be constructed by using the <xref linkend="clsDayStates"/> class.
  </para>
  <para>
    The <computeroutput>DayStates</computeroutput> and <computeroutput>DayState</computeroutput> classes provide methods
    to properly construct the day state values and the buffer containing the values. Essentially, the programmer
    constructs a number of day state values and then returns a buffer containing those values.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example is used in a application that displays the 1st and the 15th of each month in bold. The start
    date can be ignored in this case because the day state value is the same for any month.

<programlisting>
<![CDATA[

::method initDialog

  -- Connect the GETDAYSTATE event.
  self~connectMonthCalendarEvent(IDC_MC_PAYDAYS, "GETDAYSTATE", onGetDayState)

::method onGetDayState unguarded
  use arg startDate, count, id, hwnd

  dayStates = .array~new(count)
  do i = 1 to count
    dayStates[i] = .DayState~new(1, 15)
  end

  buffer = .DayStates~makeDayStateBuffer(dayStates)
  return buffer

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End GetDayState Event Handler -->


<section id="evtMonthCalendarRELEASED" xreflabel=""><title>Released Event Handler</title>
<indexterm><primary>MonthCalendar class</primary><secondary>events</secondary><tertiary>RELEASED</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onReleased unguarded
  use arg id, hwnd

  return 0
]]>
</programlisting>

<para>
  The event handler for the released event is invoked when the month calendar releases the mouse capture. The
  interpreter waits, or does not wait, for the reply as specified by the programmer in the
 <xref linkend="mthConnectMonthCalendarEvent"/> method. The operating system ignores the value
  of the reply.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives two arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the month calendar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window <xref linkend="defHandle"/> for the month calendar control sending the notification
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    Since the return value is ignored by the operating system, any value can be used. Typically, 0 is returned.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Released Event Handler -->


<section id="evtMonthCalendarSELCHANGED" xreflabel="SELCHANGED"><title>SelChanged Event Handler</title>
<indexterm><primary>MonthCalendar class</primary><secondary>events</secondary><tertiary>SELCHANGED</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onSelChanged unguarded
  use arg selStart, selEnd, id, hwnd

  return 0
]]>
</programlisting>

<para>
  The event handler for the selection changed event is invoked when the currently selected date or range of dates
  changes. This notification is sent when the user explicitly changes the selection within the current month or when the
  selection is implicitly changed by the user navigating to another month. The operating system also sends this
  notification at regular intervals so that the month calendar control can respond to date changes.
</para>
<para>
  The notification is similar to the <xref linkend="evtMonthCalendarSELECT"/> notification, except that the SELECT
  notification is only sent when the user explicitly changes the date. This notification is sent when the selected date
  is changed for any reason.
</para>
<para>
  The interpreter waits, or does not wait, for the reply as specified by the programmer in the
 <xref linkend="mthConnectMonthCalendarEvent"/> method. The operating system ignores the value
  of the reply.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives three arguments:
  </para>
  <variablelist>
    <varlistentry><term>selStart</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the new selected date, or the first selected date in a
      range of selected dates.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>selEnd</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the last selected date in a range of selected dates. If
      only a single date is selected, then <emphasis role="italic">selEnd</emphasis> will be the same date as <emphasis
      role="italic">selStart</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the month calendar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window <xref linkend="defHandle"/> for the month calendar control sending the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The return value is ignored by the operating system and the programmer can return any value. Typically 0 is
    returned.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End SelChanged Event Handler -->

<section id="evtMonthCalendarSELECT" xreflabel="SELECT"><title>Select Event Handler</title>
<indexterm><primary>MonthCalendar class</primary><secondary>events</secondary><tertiary>SELECT</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onSelect unguarded
  use arg selStart, selEnd, id, hwnd

  return 0
]]>
</programlisting>

<para>
  The SELECT event handler is invoked when the user explicitly selects a new date. Contrast this with the <xref
  linkend="evtMonthCalendarSELCHANGED"/> event handler which is invoked when the selected date is changed for any reason.
</para>
<para>
  The interpreter waits, or does not wait, for the reply as specified by the programmer in the
 <xref linkend="mthConnectMonthCalendarEvent"/> method. The operating system ignores the value
  of the reply.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives four arguments:
  </para>
  <variablelist>
    <varlistentry><term>selStart</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the new selected date, or the first selected date in a
      range of selected dates.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>selEnd</term>
    <listitem>
    <para>
      A <computeroutput>DateTime</computeroutput> object that is the last selected date in a range of selected dates. If
      only a single date is selected, then <emphasis role="italic">selEnd</emphasis> will be the same date as <emphasis
      role="italic">selStart</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the month calendar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window <xref linkend="defHandle"/> for the month calendar control sending the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The programmer can return any value because the operating system ignores the returned value. Typically 0 is
    returned.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Select Event Handler -->

<section id="evtMonthCalendarVIEWCHANGE" xreflabel="VIEWCHANGE"><title>ViewChange Event Handler</title>
<indexterm><primary>MonthCalendar class</primary><secondary>events</secondary><tertiary>VIEWCHANGE</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onViewChange unguarded
  use arg oldView, newView, id, hwnd

  return 0
]]>
</programlisting>

<para>
  The view change notification is sent when the current view changes. The notification is only sent on Windows Vista or
  later. A syntax exception is raised if the VIEWCHANGE event is connected when the program is not running on Vista or
  later.
</para>
<para>
  The interpreter waits, or does not wait, for the reply as specified by the programmer in the
 <xref linkend="mthConnectMonthCalendarEvent"/> method. The operating system ignores the value
  of the reply.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives four arguments:
  </para>
  <variablelist>
    <varlistentry><term>oldView</term>
    <listitem>
    <para>
      The <emphasis role="italic">oldView</emphasis> argument is a keyword denoting what the previous view was. It will be
      one of: month, year, decade, or century.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>newView</term>
    <listitem>
    <para>
      The <emphasis role="italic">newView</emphasis> argument is a keyword denoting what the view was changed to. It also
      will be one of: month, year, decade, or century.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the month calendar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window <xref linkend="defHandle"/> for the month calendar control sending the notification
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End ViewChange Event Handler -->

</section>  <!-- End EventNotification::connectionMonthCalendarEvent() -->

<section id="mthConnectMove" xreflabel="connectMove"><title>connectMove</title>
<indexterm><primary>connectMove</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectMove</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectMove</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectMove(--+--------------+--+--------------+--)---------><
                  +--methodName--+  +-,-willReply--+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectMove</emphasis> method connects a dialog move event notification with a method in
  the Rexx dialog. The notification is sent after the position of the dialog has changed.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that will be invoked each time the dialog has moved. The name can not be the empty string.
      When this argument is omitted the name defaults to <emphasis role="italic">onMove</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.false</computeroutput>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    move events happen.
  </para>
  <para>
    The underlying dialog receives this event notification as a WM_MOVE message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>

<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  forward class (super) continue

  self~connectMove(onMove)

::method onMove unguarded
  use arg unUsed, posInfo

  -- The dialog position has changed, print out where we are.
  x = .DlgUtil~loWord(posInfo)
  y = .DlgUtil~hiWord(posInfo)
  say 'At coordinate (' x',' y' ) on the screen. (In pixels.)'

  return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtEventNotificationMOVE" xreflabel="MOVE"><title>Move Event Handler</title>
<indexterm><primary>EventNotification class</primary><secondary>events</secondary><tertiary>MOVE</tertiary></indexterm>
<para>
  The event handler for the Move event is invoked when the position of the dialog has changed.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectMove"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onMove unguarded
  use arg wParam, lParam

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 2 arguments:
  </para>
  <variablelist>
    <varlistentry><term>wParam</term>
    <listitem>
    <para>
      The numeric value of the WPARAM parameter of the notification <xref linkend="ovvWindowMessages"/>. This argument has no
      meaning and is likely 0. Even if it is not 0, it still has no meaning.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>lParam</term>
    <listitem>
    <para>
      The numeric value of the LPARAM parameter of the notivication message. This value contains the new position
      coordinates of the dialog. The low word of the number contains the new X position and the high word contains new y
      position. The <xref linkend="mthLoWord"/> and <xref linkend="mthHiWord"/> methods can be used to extract these values.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The MSDN documentation says to return 0 from the event handler.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    A complete working example to play with:

<programlisting>
<![CDATA[
/* Simple connectMove() example */

  dlg = .MoveDlg~new
  dlg~execute("SHOWTOP", IDI_DLG_OOREXX)

::requires "ooDialog.cls"

::class 'MoveDlg' subclass UserDialog

::method init
  forward class (super) continue

  self~connectMove(onMove, .true)

  self~create(30, 30, 257, 123, "Move Me Dialog", "CENTER")

::method defineDialog

  self~createPushButton(IDOK, 142, 99, 50, 14, "DEFAULT", "Ok")
  self~createPushButton(IDCANCEL, 197, 99, 50, 14, , "Cancel")

::method onMove unguarded
  use arg unUsed, posInfo

  -- Get the new position ...
  x = .DlgUtil~loWord(posInfo)
  y = .DlgUtil~hiWord(posInfo)

  -- If x is greater than 400, the move us back
  -- to an x position of 50
  if x > 400 then do
    p = .Point~new(50, y)
    self~moveTo(p)
    j = SysSleep(.01)
  end

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Move Event Handler -->

</section>  <!-- End EventNotification::connectMove() -->

<section id="mthConnectNotifyEvent" xreflabel="connectNotifyEvent"><title>connectNotifyEvent</title>
<indexterm><primary>connectNotifyEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectNotifyEvent</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectNotifyEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectNotifyEvent(--id--,--event--+---------------+--+--------------+--)--><
                                       +-,--methodName-+  +-,-willReply--+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectNotifyEvent</emphasis> method connects one of the generic event notifications from
  a dialog control to a method in the Rexx dialog object.
</para>
<para>
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  </para>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the dialog control for which the notification is to be connected. This can be numeric or symbolic.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event [required]</term>
    <listitem>
    <para>
      Exactly one of the following key words, case is not significant, that specifies which event is to be connected:
    </para>
    <variablelist>
      <varlistentry><term>CLICK</term>
      <listitem>
      <para>
        The left mouse button was clicked on the dialog control.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>DBLCLK</term>
      <listitem>
      <para>
        The left mouse button was double-clicked on the dialog control.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>ENTER</term>
      <listitem>
      <para>
        The return key was pressed in the dialog item.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>GOTFOCUS</term>
      <listitem>
      <para>
        The dialog item got the input focus.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>LOSTFOCUS</term>
      <listitem>
      <para>
        The dialog item lost the input focus.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>OUTOFMEMORY</term>
      <listitem>
      <para>
        The dialog control is out of memory.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>RCLICK</term>
      <listitem>
      <para>
        The right mouse button was clicked on the dialog item.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>RDBLCLK</term>
      <listitem>
      <para>
        The right mouse button was double-clicked on the dialog control.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the event handling method. This method is invoked each time the specified event occurs. The method name can
      not be the empty string. If you omit this argument, the event handler method name is generated for you. This name will
      be the event keyword, preceded by <computeroutput>on</computeroutput>. For example: <emphasis
      role="italic">onLostFocus</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.false</computeroutput>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return codes are:
  </para>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error detected.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The resource ID could not be resolved or the event argument is incorrect.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The message was not connected correctly.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>

  <warning><title>Use of the <emphasis role="italic">connectNotifyEvent method is discouraged</emphasis></title>
  <para>
    Most event notifications are specific to the particular type of control that sends them. These generic event
    notifications are common to a number of dialog controls. In general, if one of the dialog control specific event
    connection methods, such as <xref linkend="mthConnectListViewEvent"/>, can make a connection for the event, then
    <emphasis role="italic">connectNotifyEvent</emphasis> should not be used. In these cases, the dialog control does not
    send one of the generic event notifications. It sends a notification specific to itself.
  </para>
  <para>
    In addition, most of the dialog control specific event connections provide better information to the event handler than
    that provided by the event handler used for a generic connection.
  </para>
  </warning>

  <para>
    In Windows itself, these events are sent to the parent dialog using the WM_NOTIFY message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if the
    connected event happen.
  </para>
  <para>
    In Windows itself, these events are sent to the parent dialog using the WM_NOTIFY message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example connects the double-click of the left mouse button on dialog control DLGITEM1 with method
    onDblClk:
<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  self~init:super(...)
  self~connectNotifyEvent(DLGITEM1, "DBLCLK")

::method onDblClk unguarded
  use arg id, hwnd
  say "Control" id " has been double-clicked! Its window handle is:" hwnd

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtNotifyGeneral" xreflabel="General"><title>General Notify Event Handler</title>
<indexterm><primary>connectNotifyEvent</primary><secondary>events</secondary><tertiary>OUTOFMEMORY</tertiary></indexterm>
<indexterm><primary>connectNotifyEvent</primary><secondary>events</secondary><tertiary>CLICK</tertiary></indexterm>
<indexterm><primary>connectNotifyEvent</primary><secondary>events</secondary><tertiary>DBLCLK</tertiary></indexterm>
<indexterm><primary>connectNotifyEvent</primary><secondary>events</secondary><tertiary>ENTER</tertiary></indexterm>
<indexterm><primary>connectNotifyEvent</primary><secondary>events</secondary><tertiary>RCLICK</tertiary></indexterm>
<indexterm><primary>connectNotifyEvent</primary><secondary>events</secondary><tertiary>RDBLCLK</tertiary></indexterm>
<indexterm><primary>connectNotifyEvent</primary><secondary>events</secondary><tertiary>GOTFOCUS</tertiary></indexterm>
<indexterm><primary>connectNotifyEvent</primary><secondary>events</secondary><tertiary>LOSTFOCUS</tertiary></indexterm>
<para>
  All event handlers connected through the <xref linkend="mthConnectNotifyEvent"/> method are sent the same arguments and
  are essentially coded the same way.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <emphasis
  role="italic">connectNotifyEvent</emphasis> method determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onNotifyEvent unguarded
  use arg id, ptr, notifyCode, controlObj

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 4 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource ID of the dialog control sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>ptr</term>
    <listitem>
    <para>
      The numeric value of a pointer to a memory location in the running application. This is of no conceivable use to the
      ooDialog programmer, but is retained for backwards compatibility.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>notifyCode</term>
    <listitem>
    <para>
      The numeric notification code of the event that caused the notification to be sent.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>controlObj</term>
    <listitem>
    <para>
      The Rexx dialog control object that represents the underlying dialog control that sent the notification. It is possible
      this will be the <computeroutput>.nil</computeroutput> object if some error happened, but this is very unlikely.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    In general, 0 should be returned. For most of the events connected through the <emphasis
    role="italic">connectNotifyEvent</emphasis> method, the operating system ignores the returned value.
  </para>
  <para>
    Nevertheless, beginning in ooDialog 4.2.4, <emphasis role="italic"><emphasis role="bold">if</emphasis></emphasis> the
    <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectNotifyEvent"/> method is set
    to true by the programmer, the ooDialog framework will take the value returned from the event handler and return that
    value to the operating system. If, through research, the ooDialog programmer determines a better return value for his
    particular use of <emphasis role="italic">connectNotifyEvent</emphasis>, then he is encouraged to set <emphasis
    role="italic">willReply</emphasis> to true and return the better value from his event handler.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End General Notify Event Handler -->

</section>  <!-- End EventNotification::connectionNotifyEvent() -->


<section id="mthConnectPosChanged" xreflabel="connectPosChanged"><title>connectPosChanged</title>
<indexterm><primary>connectPosChanged</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectPosChanged</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectPosChanged</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectPosChanged(--+--------------+--+--------------+--)---><
                        +--methodName--+  +-,-willReply--+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectPosChanged</emphasis> method connects the position changed event notification sent
  to a dialog to a method in the Rexx dialog object. This notification is sent to the dialog when its size, position, or
  place in the Z order has changed.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that will be invoked each time the dialog has moved. The name can not be the empty string.
      When this argument is omitted the name defaults to <emphasis role="italic">onPosChanged</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.false</computeroutput>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    position changed events happen.
  </para>
  <para>
    In Windows itself, the dialog receives this event notification as a WM_WINDOWPOSCHANGED message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>

<programlisting>
<![CDATA[
::class 'MyDlgClass' subclass UserDialog

::method initDialog
  ...
  self~connectPosChanged("onNewPos")

::method onNewPos unguarded
  use arg wp, lp
  rect = self~windowRect
  say "The new dialog window rectangle is:"
  say "  Left:  " rect~left
  say "  Top:   " rect~top
  say "  Right: " rect~right
  say "  Bottom:" rect~bottom

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtEventNotificationPOSCHANGED" xreflabel="POSCHANGED"><title>PosChanged Event Handler</title>
<indexterm><primary>EventNotification class</primary><secondary>events</secondary><tertiary>POSCHANGED</tertiary></indexterm>
<para>
  The event handler for the Position Changed event is invoked when the size, position, or place in the Z order of the dialog
  has changed.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectMove"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onPosChanged unguarded
  use arg wParam, lParam

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 2 arguments:
  </para>
  <variablelist>
    <varlistentry><term>wParam</term>
    <listitem>
    <para>
      The numeric value of the WPARAM parameter of the notification <xref linkend="ovvWindowMessages"/>. This argument has no
      meaning and is likely 0. Even if it is not 0, it still has no meaning.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>lParam</term>
    <listitem>
    <para>
      The numeric value of the LPARAM parameter of the notivication message. This is a pointer to a memory location and has
      no conceivable use in the ooDialog program.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The event handler should probably return 0.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End PosChanged Event Handler -->

</section>

<section id="mthConnectReBarEvent" xreflabel="connectReBarEvent"><title>connectReBarEvent</title>
<indexterm><primary>connectReBarEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectReBarEvent</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectReBarEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectReBarEvent(--id--,--event--+-----------+--+-------------+--)--------><
                                      +-,-mthName-+  +-,-willReply-+
]]>
</programlisting>

<para>
  Connects an event notification message from a rebar control to a method in the Rexx dialog object.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  </para>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the rebar control whose notification message is to be connected to a method in the Rexx dialog.
      May be numeric or <xref linkend="defSymbolicId"/>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event [required]</term>
    <listitem>
    <para>
      Exactly one of the following keywords. The keyword specifies the event to be connected. Case is not significant.
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>AUTOBREAK       </member>
        <member>AUTOSIZE        </member>
        <member>BEGINDRAG       </member>
        <member>CHEVRONPUSHED   </member>
        <member>CHILDSIZE       </member>
        <member>DELETEDBAND     </member>
        <member>DELETINGBAND    </member>
        <member>ENDDRAG         </member>
        <member>GETOBJECT       </member>
        <member>HEIGHTCHANGE    </member>
        <member>LAYOUTCHANGED   </member>
        <member>MINMAX          </member>
        <member>NCHITTEST       </member>
        <member>RELEASEDCAPTURE </member>
        <member>SPLITTERDRAG    </member>
      </simplelist>
    </para>
    <variablelist>
      <varlistentry id="kywReBarAUTOBREAK" xreflabel="AUTOBREAK"><term><xref linkend="evtReBarAUTOBREAK"/></term>
      <listitem>
      <para>
        Notifies the dialog that a break will appear in the bar. The dialog determines whether to make the break.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywReBarNCHITTEST" xreflabel="NCHITTEST"><term><xref linkend="evtReBarNCHITTEST"/> </term>
      <listitem>
      <para>
        Sent by a rebar control when the control receives a hit test request.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywReBarRELEASEDCAPTURE" xreflabel="RELEASEDCAPTURE"><term><xref linkend="evtReBarRELEASEDCAPTURE"/></term>
      <listitem>
      <para>
        Notifies the dialog window that the rebar control is releasing the mouse capture.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that is to be invoked whenever the specified event happens. The programmer defines this method.
      If this argument is omitted, a method name is automatically generated that consists of the event keyword preceded by
      <computeroutput>on</computeroutput>. For instance, <computeroutput>onAutoBreak</computeroutput>. The method name can
      not be the empty string. The empty string is treated as an omitted argument.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.true</computeroutput>.
    </para>
    <para>
      For those event notifications that the operating system expects a return value, the <emphasis
      role="italic">willReply</emphasis> argument is ignored. For these events, the event handler must always return a value
      of the correct type. I.e., if the operating system expects a reply of true or false, the event handler must always
      return true or false. The events in the following list fall into this category:
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>NCHITTEST     </member>
        <member>AUTOBREAK     </member>
        <member>BEGINDRAG     </member>
        <member>CHILDSIZE     </member>
        <member>GETOBJECT     </member>
        <member>MINMAX        </member>
      </simplelist>
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns <computeroutput>.true</computeroutput> if the event was connected correctly, otherwise
   <computeroutput>.false</computeroutput>.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected, including the use of an invalid symbolic ID or an
    unrecognized event keyword.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if the
    connected event happens.
  </para>
  <para>
    The underlying dialog receives the RBN_* messages as the notifications for the rebar events.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example ...
  </para>

<programlisting>
<![CDATA[

]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>


<section id="evtReBarAUTOBREAK" xreflabel="AUTOBREAK"><title>AutoBreak Event Handler</title>
<indexterm><primary>ReBar class</primary><secondary>events</secondary><tertiary>AUTOBREAK</tertiary></indexterm>
<para>
  The event handler for the auto break event is invoked when a break will appear in the bar. The application can allow, or
  disallow, the break by responding to the notification.
</para>
<para>
  If this event notification is connected, the event handler must respond and return a value to the notification.
</para>

<programlisting>
<![CDATA[
::method onAutoBreak unguarded
  use arg id, bandIndex, wID, style, reBar, itemData, msgID

  return .true
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 7 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource ID of the control that sent the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>bandIndex</term>
    <listitem>
    <para>
     The one based index of the band affected by the notification. This is 0 if no band is affected.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>wID</term>
    <listitem>
    <para>
      The application-defined ID of the band.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>style</term>
    <listitem>
    <para>
      A list of style keywords that specify the current style of the band.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>rebar</term>
    <listitem>
    <para>
      The Rexx rebar object that represents the underlying rebar control.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>itemData</term>
    <listitem>
    <para>
      The item data assigned to the band, or the <computeroutput>.nil</computeroutput> object if there is no item data
      assigned.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>msgID</term>
    <listitem>
    <para>
      TBD what is this?
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The event handler must return true or false. True allows the break to occur and false prevents the break.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    xxx
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example connects several rebar events in the <emphasis role="italic">initDialog</emphasis> method:

<programlisting>
<![CDATA[
::method initDialog

  self~connectReBarEvent(IDC_RBAR, "RELEASEDCAPTURE", onRelease, sync)
  self~connectReBarEvent(IDC_RBAR, "NCHITTEST", onNcHitTest)
  self~connectReBarEvent(IDC_RBAR, "AUTOBREAK", onBreak)

  rb = self~newReBar(IDC_RBAR)
  ...
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End AutoBreak Event Handler -->


<section id="evtReBarNCHITTEST" xreflabel="NCHITTEST"><title>NcHitTest Event Handler</title>
<indexterm><primary>ReBar class</primary><secondary>events</secondary><tertiary>NCHITTEST</tertiary></indexterm>
<para>
  The event handler for the non-client hit test event is invoked when the rebar control receives a hit test request. The
  control then sends the NcHitTest notification to the dialog. The event handler can choose to allow the rebar to perform
  default processing of the hit test message, or to return its own value to over-ride the default hit test processing.
</para>
<para>
  The event handler must always return a value for this notification.
</para>

<programlisting>
<![CDATA[
::method onNcHitTest unguarded
  use arg id, bandIndex, pos, hit, rebar

  return 'CAPTION'
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 5 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource ID of the control that sent the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>bandIndex</term>
    <listitem>
    <para>
     The one based index of the band affected by the notification. This is 0 if no band is affected.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pos</term>
    <listitem>
    <para>
      A <xref linkend="clsPoint"/> object specifying the mouse coordinates of the hit test message.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hit</term>
    <listitem>
    <para>
      One of the keywords in the <link linkend="tblHitTestKeyWord">hit test table</link>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>rebar</term>
    <listitem>
    <para>
      The Rexx rebar object that represents the underlying rebar control that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    Return zero to allow the rebar to perform default processing of the hit test message, or return one of the <link
    linkend="tblHitTestKeyWord">hit keywords</link> to override the default hit test processing.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The NCHITTEST event connection is provided for completeness. It is not entirely clear to the author what the use of the
    notification is, or what effect over-riding the default processing has.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example prints out the values sent by the rebar control for the notification and if the <emphasis
    role="italic">hit</emphasis> argument is SIZE returns a non-zero value:

<programlisting>
<![CDATA[
::method onNcHitTest unguarded
  use arg id, bandIndex, pos, ht, reBar
  say 'onNcHitTest() id:' id 'bandIndex:' bandIndex 'pos:' pos 'ht:' ht 'reBar:' reBar

  if ht == 'SIZE' then return 'NOWHERE'
  else return 0

/* Output might be for example:

onNcHitTest() id: 1003 bandIndex: 5 pos: a Point (233, 13) ht: CAPTION reBar: a ReBar
onNcHitTest() id: 1003 bandIndex: 5 pos: a Point (230, 14) ht: SIZE reBar: a ReBar
onNcHitTest() id: 1003 bandIndex: 5 pos: a Point (227, 14) ht: SIZE reBar: a ReBar
onNcHitTest() id: 1003 bandIndex: 5 pos: a Point (225, 15) ht: SIZE reBar: a ReBar
onNcHitTest() id: 1003 bandIndex: 5 pos: a Point (223, 15) ht: SIZE reBar: a ReBar
onNcHitTest() id: 1003 bandIndex: 0 pos: a Point (222, 16) ht: CLIENT reBar: a ReBar
onNcHitTest() id: 1003 bandIndex: 4 pos: a Point (220, 16) ht: CAPTION reBar: a ReBar
onNcHitTest() id: 1003 bandIndex: 4 pos: a Point (219, 16) ht: CAPTION reBar: a ReBar
*/
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End NcHitTest Event Handler -->

<section id="evtReBarRELEASEDCAPTURE" xreflabel="RELEASEDCAPTURE"><title>ReleasedCapture Event Handler</title>
<indexterm><primary>ReBar class</primary><secondary>events</secondary><tertiary>RELEASEDCAPTURE</tertiary></indexterm>
<para>
  The event handler for the released capture event is invoked the rebar control has released the mouse capture.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectReBarEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onReleasedCapture unguarded
  use arg id, rebar

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 2 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource ID of the control that sent the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>rebar</term>
    <listitem>
    <para>
      The Rexx rebar object that represents the underlying rebar control that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this notification. 0 makes a good value to return.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example prints out the values of the arguments sent by the rebar control for the released capture event:

<programlisting>
<![CDATA[
::method onRelease unguarded
  use arg id, reBar
  say 'onRelease() id:' id 'reBar:' reBar
  return 0

/* Output might be:

onRelease() id: 1003 reBar: a ReBar
onRelease() id: 1003 reBar: a ReBar
onRelease() id: 1003 reBar: a ReBar
*/
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End ReleasedCapture Event Handler -->

</section>  <!-- End EventNotification::connectReBarEvent() -->


<section id="mthConnectResize" xreflabel="connectResize"><title>connectResize</title>
<indexterm><primary>connectResize</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectResize</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectResize</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectResize(--+--------------+--+--------------+--)-------><
                    +--methodName--+  +-,-willReply--+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectResize</emphasis> method connects a size event notification to the underlying
  dialog with a method in the Rexx dialog. The notification is sent to the dialog after its size has changed.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that is invoked each time the size of the dialog has changed. The method name can not be the
      empty string. When this argument is omitted the name defaults to <emphasis role="italic">onResize</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>SYNC</computeroutput>. See the <emphasis role="italic">Remarks</emphasis> section for some discussion
      on why the default is not false as it normally would be for older event connection methods.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>synch [optional]</term>
    <listitem>
    <para>
      A boolean value that specifies if the interpreter should invoke the event handler <xref
      linkend="ovvEventsDirectReply"/>, or not. The default is <computeroutput>.true</computeroutput>, see the remarks. If
      this behavior is not desired, the <emphasis role="italic">synch</emphasis> argument can be used to specify that the
      interpreter should not wait for a reply.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  <para>
    Typically when the user is resizing a window, there are many event notifications that come quickly. In older
    ooDialog versions, where the notification was placed on a queue to be processed at a later date, this caused a
    number of notifications to be placed on the queue before a single notification was processed. Programs that
    connected the resize event performed poorly when many notifications pile up before they are processed.
  </para>
  <para>
    The poor performance is mostly fixed by having the interpreter invoke the event handler directly and wait for the return
    from the event handler, which causes each notification to be processed one by one. When <emphasis
    role="italic">willReply</emphasis> is set to <emphasis role="italic">SYNC</emphasis>, all ooDialog programs that connect
    the resize event are likely to perform much better. This is why the default for <emphasis
    role="italic">willReply</emphasis> is set to <emphasis role="italic">SYNC</emphasis>
  </para>
  <para>
    Normally, when the interpreter waits for the event handler to return, a syntax condition is raised if a value is not
    returned from the event handler. The <emphasis role="italic">SYNCH</emphasis> option causes the interpreter to wait
    until the event handler returns, but to not expect a returned value. This provides backwards compatibility for older
    programs where the programmer <emphasis role="bold"><emphasis role="italic">mistakenly</emphasis></emphasis> did not
    return a value from event handlers. Best practice is to <emphasis role="italic">always</emphasis> return a value
    from an event handler. If the operating system ignores the return value, return 0.
  </para>
  <para>
    <emphasis role="bold">Note</emphasis> that when the <xref linkend="clsResizingAdmin"/> is inherited by a dialog to
    produce a resizable dialog, the <emphasis role="italic">connectResize</emphasis> method has no effect. The event
    notification events are handled internally by the <computeroutput>ResizingAdmin</computeroutput> object.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    size events happen.
  </para>
  <para>
    The underlying dialog receives the WM_SIZE message as the notification for this event.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>

<programlisting>
<![CDATA[
  dlg = .ResizingDialog~new
  dlg~createCenter(100, 60, "Resize Me", "THICKFRAME")
  dlg~execute("SHOWTOP")

::requires 'ooDialog.cls'

::class 'ResizingDialog' subclass UserDialog

::method init
  forward class (super) continue

  self~connectResize("onSize")

::method onSize unguarded
  use arg sizeEvent, sizeInfo

  -- sizeInfo contains information about the new width and height in pixels.
  w = .DlgUtil~loWord(sizeinfo)
  h = .DlgUtil~hiWord(sizeinfo)
  say "New width=" w ", new height=" h

  return 0
]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>

<section id="evtEventNotificationRESIZE" xreflabel="RESIZE"><title>Resize Event Handler</title>
<indexterm><primary>EventNotification class</primary><secondary>events</secondary><tertiary>RESIZE</tertiary></indexterm>
<para>
  The event handler for the Resize event is invoked when the size of the dialog has changed.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectResize"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onResize unguarded
  use arg wParam, lParam

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 2 arguments:
  </para>
  <variablelist>
    <varlistentry><term>wParam</term>
    <listitem>
    <para>
      A numeric code that specifies the type of resizing. The dialog object provides a number of <link
      linkend="tblConstantsDlgObject">constant</link> values to make it easier to decode the numeric value of the <emphasis
      role="italic">wParam</emphasis> argument. The constants all begin with <emphasis role="italic">SIZE_</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>lParam</term>
    <listitem>
    <para>
      The numeric value of the LPARAM parameter of the notivication message. This value contains the new size coordinates of
      the dialog. The low word of the number contains the new width and the high word contains new height. The <xref
      linkend="mthLoWord"/> and <xref linkend="mthHiWord"/> methods can be used to extract these values.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The MSDN documentation says to return 0 from the event handler.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example is pulled from the File Viewer <link linkend="exampleFileViewer">example</link> at the end of the <xref
    linkend="sctAppearanceBehaviorMethods"/> section. A complete working example is presented there that uses a number of the
    dialog methods:

<programlisting>
<![CDATA[
::method defineDialog
  expose wasMinimized

  wasMinimized = .false
  style = "VSCROLL HSCROLL MULTILINE READONLY"
  self~createEdit(IDC_MULTILINE, 0, 0, 170, 180, style, "cEntry")
  self~connectResize("onSize", .true)
  ...

/* The first arg, sizeEvent, is a flag that the OS sends specifying the type of
 * size event.  We are only interested in these 3 flags:
 *
 * SIZE_RESTORED   = 0
 * SIZE_MINIMIZED  = 1
 * SIZE_MAXIMIZED  = 2
 */
::method onSize unguarded
  expose wasMinimized
  use arg sizeEvent, sizeInfo

  if sizeEvent == self~SIZE_MINIMIZED then wasMinimized = .true

  if sizeEvent == self~SIZE_RESTORED |  sizeEvent == self~SIZE_MAXIMIZED then do
    if \ wasMinimized then self~resizeEditControl
    wasMinimized = .false
  end

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Resize Event Handler -->

</section>  <!-- End EventNotification::connectResize() -->

<section id="mthConnectResizing" xreflabel="connectResizing"><title>connectResizing</title>
<indexterm><primary>connectResizing</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectResizing</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectResizing</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectResizing(--+--------------+--+--------------+--)-----><
                      +--methodName--+  +-,-willReply--+
]]>
</programlisting>

<para>
  Connects a <emphasis role="italic">sizing</emphasis> <xref linkend="ovvEvents"/> notification sent to the
  underlying dialog with a method in the Rexx dialog. The notification is sent to the dialog <emphasis
  role="italic">before</emphasis> its size has changed.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that is invoked each time the size of the dialog is about to be changed. The method name
      can not be the empty string. When this argument is omitted the name defaults to <emphasis
      role="italic">onResizing</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      Although the <link linkend="sctCommonWillReply">willReply</link> argument is accepted so that the <emphasis
      role="italic">connectResizing</emphasis> method is similar to the other event connection methods, its value is always
      considered to be true. That is, the interpreter waits for the return value from the event handler. The event handler
      must always return true or false.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      An (internal) error prevented the message from being connected to a method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    By processing the sizing event notification, the programmer can monitor the size and position of the drag rectangle
    of the dialog being resized and, if desired, can change its new size or position.
  </para>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  <para>
    The interpreter invokes the event handler directly and waits in the window <xref linkend="ovvWindowMessages"/> processing
    loop for the return from the event handler. Connecting the sizing event requires that the programmer reply to the event
    from the event handler in a timely manner.
  </para>
  <para>
    <emphasis role="bold">Note</emphasis> that when the <xref linkend="clsResizingAdmin"/> is inherited by a dialog to
    produce a resizable dialog, the <emphasis role="italic">connectResizing</emphasis> method has no effect. The event
    notification events are handled internally by the <computeroutput>ResizingAdmin</computeroutput> object.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    sizing events happen.
  </para>
  <para>
    The underlying dialog receives the WM_SIZING message as the notification for this event.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example shows, partially, how to prevent a resizable dialog from being sized smaller than 300 pixels high. A
    complete implementation would also have to handle the TOPLEFT, TOPRIGHT, etc., directions. And, normally, an
    implementation would also enforce a minimum width.
  </para>
  <para>
    A complete implementation can be found in the <computeroutput>dlgAreaUDemoThree.rex</computeroutput> example program.

<programlisting>
<![CDATA[
::method init
  ...

  self~connectResizing("onSizing", .true)

::method onSizing unguarded
  use arg rect, direction

  select
    when direction == 'TOP' then do
      if rect~bottom - rect~top < 300 then do
        rect~top = rect~bottom - 300
        return .true
      end
    end
    when direction == 'BOTTOM' then do
      if rect~bottom - rect~top < 300 then do
        rect~bottom = rect~top + 300
        return .true
      end
    end
    ...
    otherwise
      nop
  end

  return .false

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtEventNotificationRESIZING" xreflabel="RESIZING"><title>Resizing Event Handler</title>
<indexterm><primary>EventNotification class</primary><secondary>events</secondary><tertiary>RESIZING</tertiary></indexterm>
<para>
  The event handler for the Resizing event is invoked when the size of the dialog is about to be changed. That is, it is
  invoked with arguments specifying the new size of the dialog, but before the change is actually made.
</para>
<para>
  The operating system expects the application to reply to this message, either to allow the change or to disallow the
  change. The Rexx event hander must reply to this notification, this can not be changed.
</para>

<programlisting>
<![CDATA[
::method onResize unguarded
  use arg wParam, lParam

  return .false
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 2 arguments:
  </para>
  <variablelist>
    <varlistentry><term>rect</term>
    <listitem>
    <para>
      A <computeroutput>Rect</computeroutput> object that specifies the size the dialog is about to be changed to.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>direction</term>
    <listitem>
    <para>
      A keyword that specifies which edge of the dialog window is being sized. The keyword will be exactly one of the
      following:
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>BOTTOM</member>   <member>BOTTOMLEFT</member> <member>BOTTOMLEFT</member>
        <member>LEFT</member>     <member>RIGHT</member>      <member>TOP</member>
        <member>TOPLEFT</member>  <member>TOPRIGHT</member>
      </simplelist>
    </para>
    <variablelist>
      <varlistentry><term>BOTTOM</term>
      <listitem>
      <para>
        The bottom edge is being dragged.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>BOTTOMLEFT</term>
      <listitem>
      <para>
        The bottom-left corner is being dragged.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>BOTTOMRIGHT</term>
      <listitem>
      <para>
        The bottom-right corner is being dragged.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>LEFT</term>
      <listitem>
      <para>
        The left edge is being dragged.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>RIGHT</term>
      <listitem>
      <para>
        The right edge is being dragged.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>TOP</term>
      <listitem>
      <para>
        The top edge is being dragged.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>TOPLEFT</term>
      <listitem>
      <para>
        The top-left corner is being dragged.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>TOPRIGHT</term>
      <listitem>
      <para>
        The top-right corner is being dragged.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    Return false to indicate the coordinates specified in the <emphasis role="italic">rect</emphasis> arg are unchanged.
    Otherwise, return true to indicate the coordinates have been changed and the operating system will set the new size of
    the dialog to the changed coordinates.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The application can effect how the dialog is resized by changing the values of the <emphasis
    role="italic">rect</emphasis> argument and returning true. The operating updates the size of the drag rectangle with the
    new values in the <emphasis role="italic">rect</emphasis> argument rather than with the original values. Typically this
    is done to prevent the user from resizing the dialog too small or too  big.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example shows an event handler that prevents the dialog from being sized smaller than a minimum size, but puts no
    restriction on the maximum size.

<programlisting>
<![CDATA[

::method onResizing unguarded
  expose minWidth minHeight
  use arg r, direction

  select
    when direction == 'TOP' then do
      if minHeight > r~bottom - r~top then do
        r~top = r~bottom - minHeight
        return .true
      end
    end
    when direction == 'BOTTOM' then do
      if minHeight > r~bottom - r~top then do
        r~bottom = r~top + minHeight
        return .true
      end
    end
    when direction == 'LEFT' then do
      if minWidth > r~right - r~left then do
        r~left = r~right - minWidth
        return .true
      end
    end
    when direction == 'RIGHT' then do
      if minWidth > r~right - r~left then do
        r~right = r~left + minWidth
        return .true
      end
    end
    when direction == 'BOTTOMLEFT' then do
      didChange = .false

      if minHeight > r~bottom - r~top then do
        r~bottom = r~top + minHeight
        didChange = .true
      end

      if minWidth > r~right - r~left then do
        r~left = r~right - minWidth
        didChange = .true
      end

      return didChange
    end
    when direction == 'BOTTOMRIGHT' then do
      didChange = .false

      if minHeight > r~bottom - r~top then do
        r~bottom = r~top + minHeight
        didChange = .true
      end

      if minWidth > r~right - r~left then do
        r~right = r~left + minWidth
        didChange = .true
      end

      return didChange
    end
    when direction == 'TOPLEFT' then do
      didChange = .false

      if minHeight > r~bottom - r~top then do
        r~top = r~bottom - minHeight
        didChange = .true
      end

      if minWidth > r~right - r~left then do
        r~left = r~right - minWidth
        didChange = .true
      end

      return didChange
    end
    when direction == 'TOPRIGHT' then do
      didChange = .false

      if minHeight > r~bottom - r~top then do
        r~top = r~bottom - minHeight
        didChange = .true
      end

      if minWidth > r~right - r~left then do
        r~right = r~left + minWidth
        didChange = .true
      end

      return didChange
    end
    otherwise
      nop
  end
  -- End select
  return .false

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Resizing Event Handler -->

</section>  <!-- End EventNotification::connectResizing -->


<section id="sctConnectingScrollBarEvents"><title>Connecting Scroll Bar Events</title>
<indexterm><primary>Connecting Scroll Bar Events</primary></indexterm>

<para>
  For connecting scroll bars, ooDialog provides the typical <emphasis role="italic">connectScrollBarEvent</emphasis> method
  along with 2 convenience methods.
</para>

<section id="mthConnectAllSBEvents" xreflabel="connectAllSBEvents"><title>connectAllSBEvents</title>
<indexterm><primary>connectAllSBEvents</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectAllSBEvents</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectAllSBEvents</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectAllSBEvents(-id-,-mName-+------+-+------+-+-----+-+--------------+-)--><
                                   +-,-mn-+ +-,-mx-+ +-,-p-+ +-,-willReply--+

]]>
</programlisting>

<para>
  Connects all scroll bar events to one method.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  </para>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the scroll bar.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mName [required]</term>
    <listitem>
    <para>
      The method that is invoked for all events sent by the scroll bar. There is no default name for the method, the name
      must be specified.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mn, mx [optional]</term>
    <listitem>
    <para>
      Sets the minimum and maximum values for the range of the scroll bar.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>p [optional]</term>
    <listitem>
    <para>
      Sets the current position of the scroll bar.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.false</computeroutput>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <variablelist>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The specified symbolic ID could not be resolved.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method requires that the <xref linkend="ovvUnderlying"/> scroll bar exists. Therefore, the method
    is best invoked in the <xref linkend="mthInitDialog"/> method.
  </para>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers. The section
    for the <xref linkend="evtScrollBarSCROLL"/> event handler contains information specific to the event handler for scroll
    bar events.
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End EventNotification::connectAllSBEvents -->

<section id="mthConnectEachSBEvent" xreflabel="connectEachSBEvent"><title>connectEachSBEvent</title>
<indexterm><primary>connectEachSBEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectEachSBEvent(-id-,-mthWhenUp-,-mthWhenDown-+---------------+--------->
                                                     +-,-mthWhenDrag-+

>--+-------+-+-------+-+-------+--+-----------+-+-----------+-+----------+----->
   +-,-min-+-+-,-max-+ +-,-pos-+  +-,-mthPgUp-+ +-,-mthPgDn-+ +-,-mthTop-+

>--+-------------+-+------------+-+------------+-+-------------+--)------------><
   +-,-mthButtom-+ +-,-mthTrack-+ +-,-mthEndSc-+ +-,-willReply-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectEachSBEvent</emphasis> method connects an <xref linkend="ovvEvents"/> notification
  message from a scroll bar to a method in the Rexx dialog object. Optionally, the method can also initialize the scroll bar,
  (set the range and current position.)
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  </para>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
                The ID of the scroll bar.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mthWhenUp [required]</term>
    <listitem>
    <para>
                The method that is called each time the scroll bar is incremented.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mthWhenDown [required]</term>
    <listitem>
    <para>
                The method that is called each time the scroll bar is decremented.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mthWhenDrag [optional]</term>
    <listitem>
    <para>
                The method that is called each time the scroll bar is dragged with
    the mouse.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>min, max [optional]</term>
    <listitem>
    <para>
                The minimum and maximum values for the scroll bar.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pos [optional]</term>
    <listitem>
    <para>
                The current or preselected value.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mthPgUp [optional]</term>
    <listitem>
    <para>
                The method that is called each time the scroll bar is focused and the
    PgUp key is pressed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mthPgDn [optional]</term>
    <listitem>
    <para>
                The method that is called each time the scroll bar is focused and the
    PgDn key is pressed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mthTop [optional]</term>
    <listitem>
    <para>
                The method that is called each time the scroll bar is focused and the
    Home key is pressed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mthBottom [optional]</term>
    <listitem><para>
      The method that is called each time the scroll bar is focused and the End key is pressed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mthTrack [optional]</term>
    <listitem>
    <para>
      The method that is called each time the scroll box is dragged.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mthEndSc [optional]</term>
    <listitem>
    <para>
      The method that is called each time the scroll box is released after the dragging.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.false</computeroutput>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
  <variablelist>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The specified symbolic ID could not be resolved.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    This method requires that the <xref linkend="ovvUnderlying"/> scroll bar exists. Therefore, the method
    is best invoked in the <xref linkend="mthInitDialog"/> method.
  </para>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers. The section
    for the <xref linkend="evtScrollBarSCROLL"/> event handler contains information specific to the event handler for scroll
    bar events.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    In the following example, scroll bar with symbolic ID IDC_SB is connected to three methods. The range is initialized
    to 1 as the minimum and 20 as the maximum. The current position is set to 6:

<programlisting>
<![CDATA[
::class MyDialog subclass UserDialog
  ...
::method initDialog

  self~connectEachSBEvent(IDC_SB,"Increase", "Decrease", "Drag", 1, 20, 6)
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End EventNotification::connectEachSBEvent -->

<section id="mthConnectScrollBarEvent" xreflabel="connectScrollBarEvent"><title>connectScrollBarEvent</title>
<indexterm><primary>connectScrollBarEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectScrollBarEvent(--id--,--event--+---------+-+-------------+--)-------><
                                          +-,-mName-+ +-,-willReply-+

]]>
</programlisting>

<para>
  Connects a method in the Rexx dialog to the Windows <xref linkend="ovvEvents"/> notification from a
  scroll <xref linkend="clsScrollBar"/> control.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the scroll bar whose event notification is to be connected. May be numeric or
      <xref linkend="defSymbolicId"/>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event [required]</term>
    <listitem>
    <para>
      A keyword specifying which scroll event should be connected. This methods connects either a vertical or a horizontal
      scroll bar. The symbolic keyword names are orientated towards which type the scroll bar is. But the values that the
      scroll bar sends are the same for similar events.
    </para>
    <para>
      I.e., one event is to move 1 unit towards the upper left. For a vertical scroll bar this is one line up (LINEUP),
      for a horizontal scroll bar this is one unit to the left (LINELEFT). But, the numeric value that a scroll bar sends
      for the event is the same. Therefore, the LINEUP and LINELEFT keywords produce the identical effect. If the scroll
      bar is a vertical scroll bar, using the LINELEFT keyword produces the same effect as using the LINEUP keyword. The
      programmer can use whichever keyword makes the most sense.
    </para>
    <para>
      The keyword must be one of the following, case is not significant:
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>LINEUP   </member>
        <member>LINELEFT </member>
        <member>LINEDOWN </member>
        <member>LINERIGHT</member>
        <member>PAGEUP   </member>
        <member>PAGELEFT </member>
        <member>PAGEDOWN </member>
        <member>PAGERIGHT</member>
        <member>POSITION </member>
        <member>DRAG     </member>
        <member>TOP      </member>
        <member>LEFT     </member>
        <member>BOTTOM   </member>
        <member>RIGHT    </member>
        <member>ENDSCROLL</member>
      </simplelist>
      <variablelist>
        <varlistentry><term>LINEUP LINELEFT</term>
        <listitem>
        <para>
          The scroll bar was scrolled to the left or up by one unit.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>LINEDOWN LINERIGHT</term>
        <listitem>
        <para>
          The scroll bar was scrolled to the right or down by one unit.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>PAGELEFT PAGEUP</term>
        <listitem>
        <para>
          The scroll bar was scrolled to the left or up by one page size.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>PAGERIGHT PAGEDOWN</term>
        <listitem>
        <para>
          The scroll bar was scrolled to the right or down by one page size.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>DRAG</term>
        <listitem>
        <para>
          The user is dragging the scroll box. This message is sent repeatedly until the user releases the mouse button.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>TOP LEFT</term>
        <listitem>
        <para>
          The scroll bar was scrolled completely to the top or to the left.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>BOTTOM RIGHT</term>
        <listitem>
        <para>
          The scroll bar was scrolled completely to the bottom or to the right.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>ENDSCROLL</term>
        <listitem>
        <para>
          Scrolling has been ended, that is, the appropriate key or mouse button has been released.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>POSITION</term>
        <listitem>
        <para>
          The scroll box (thumb) of the scroll bar was dragged and the user has released the mouse button.
        </para>
        </listitem></varlistentry>
      </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mName [optional]</term>
    <listitem>
    <para>
      The name of the method that is to be invoked whenever the specified notification is received from the scroll bar. If
      this argument is omitted, the method name is automatically generated by concatenating <emphasis
      role="italic">on</emphasis> with the event keyword. For example, <emphasis role="italic">onLineUp</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.false</computeroutput>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return codes are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        No error detected.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
      <para>
        The resource ID could not be resolved or the event argument is incorrect.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
      <para>
        The messages was not connected correctly.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks</emphasis></term>
  <listitem>
  <para>
    This method requires that the <xref linkend="ovvUnderlying"/> scroll bar exists. Therefore, the method
    is best invoked in the <xref linkend="mthInitDialog"/> method. At some later point in the life cycle
    of the dialog is fine. If the method is invoked before the underlying dialog has been created a syntax condition is
    raised.
  </para>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers. The section
    for the <xref linkend="evtScrollBarSCROLL"/> event handler contains information specific to the event handler for scroll
    bar events.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example connects the POSITION scroll event with a method in the Rexx dialog. Since the third argument is
    omitted, the ooDialog framework automatically connects the event to the <emphasis
    role="italic">onPosition</emphasis> method. The event handler extracts the new position from the notification
    arguments and sets the position for the scroll bar. The easist way to do this is to use the <xref
    linkend="mthDeterminePosition"/> method.
  </para>
  <para>
    This example also shows how to calculate the new position without using the <emphasis
    role="italic">determinePosition</emphasis> method and then displays the new position and the event type. The
    <computeroutput>ScrollBar</computeroutput> class provides <xref linkend="sctSBEventCode"/>, one of which is the
    THUMBPOSITION constant, whose value is the value of the POSITION event code.

<programlisting>
<![CDATA[
::class 'SimpleDialog' subclass UserDialog

::method initDialog

  self~connectScrollBarEvent(IDC_SB_FILE, "POSITION")

::method onPosition unguarded
  use arg posInfo, hwnd, scrollBar

  -- Set the scroll bar to the new position and have it redraw itself.
  newPos = scrollBar~determinePosition(posInfo)
  scrollBar~setPos(newPos, .true)

  -- Determine the new position ourself and the display it for comparison
  pos       = .DlgUtil~hiWord(posInfo)
  eventCode = .DlgUtil~loWord(posInfo)

  say "New Position:     " pos
  say "Verify event code:"
  say "  THUMBPOSITION:" .ScrollBar~THUMBPOSITION
  say "  This event:   " eventCode

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End EventNotification::connectScrollBarEvent -->

<section id="evtScrollBarSCROLL" xreflabel="SCROLL"><title>Scroll Event Handler</title>
<indexterm><primary>ScrollBar class</primary><secondary>events</secondary><tertiary>SCROLL</tertiary></indexterm>
<para>
  The event handler for the Scroll event is invoked when the user moves the scroll box (the thumb box) in a scroll bar.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the method connecting the scroll event, <xref
  linkend="mthConnectScrollBarEvent"/>, <xref linkend="mthConnectAllSBEvents"/>, etc., determines how the event handler
  needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onScroll unguarded
  use arg posInfo, hwnd, scrollBar

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 3 arguments:
  </para>
  <variablelist>
    <varlistentry><term>posInfo</term>
    <listitem>
    <para>
      The <emphasis role="italic">posInfo</emphasis> argument contains the scroll event code in the low word of the
      argument. For the POSITION and the DRAG scroll events only, the high word contains the position of the scroll box. For
      the other events, the high word is not used.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      When the notification comes from a <xref linkend="clsScrollBar"/> bar control, the <emphasis
      role="italic">hwnd</emphasis> argument is the window handle of the scroll bar. When the
      notification does not come from a scroll bar control, <emphasis role="italic">hwnd</emphasis> is 0.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>scrollBar</term>
    <listitem>
    <para>
      When the notification comes from a <xref linkend="clsScrollBar"/> bar control, the <emphasis
      role="italic">scrollBar</emphasis> argument is the Rexx <computeroutput>ScrollBar</computeroutput> object representing
      the underlying scroll bar. When the notification does not come from a scroll bar control, <emphasis
      role="italic">scrollBar</emphasis> will be the <computeroutput>.nil</computeroutput> object.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this notification so 0 makes a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    When the user interacts with a scroll bar, the operating system does not reposition the scroll box (the thumb box.)
    Rather, the operating system relies on the application, (in essence the programmer,) to update the scroll bar position
    during the scroll bar event notification. Therefore, if the scroll bar event is not connected, or the programmer
    does not reposition the scroll box in the event handler, it will appear to the user that the scroll box can not be
    moved.
  </para>
  <para>
    The <xref linkend="clsScrollBar"/> class provides the <xref linkend="mthDeterminePosition"/> method as a convenience to
    determine the new position of the scroll bar. To use this method, pass the <emphasis role="italic">posInfo</emphasis>
    argument to the method:

<programlisting>
<![CDATA[
::method onScroll unguarded
  use arg posInfo, hwnd, scrollBar

  -- Set the scroll bar to the new position and have it redraw itself.
  newPos = scrollBar~determinePosition(posInfo)
  scrollBar~setPos(newPos, .true)
]]>
</programlisting>
  </para>
  <para>
    The <computeroutput>ScrollBar</computeroutput> class provides <xref linkend="sctSBEventCode"/>, which can be helpful in
    determining the new position without using the <emphasis role="italic">determinePosition</emphasis> method
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example connects all the scroll events to a single event handler. In the event handler the <emphasis
    role="italic">determinePosition</emphasis> method is used to find the new positiona and the scroll bar is updated with
    the new postion:

<programlisting>
<![CDATA[
::class 'FileReader' subclass UserDialog

...

::method initDialog

  self~connectAllSBEvents(IDC_SB_FILE, onScroll)

::method onScroll unguarded
  use arg posInfo, hwnd, scrollBar

  -- Set the scroll bar to the new position and have it redraw itself.
  newPos = scrollBar~determinePosition(posInfo)
  scrollBar~setPos(newPos, .true)

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Scroll Event Handler -->

</section>  <!-- End Connecting Scroll Bar Events section -->


<section id="mthConnectSizeMoveEnded" xreflabel="connectSizeMoveEnded"><title>connectSizeMoveEnded</title>
<indexterm><primary>connectSizeMoveEnded</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectSizeMoveEnded</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectSizeMoveEnded</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectSizeMoveEnded(--+--------------+--+--------------+--)---------------><
                           +--methodName--+  +-,-willReply--+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectSizeMoveEnded</emphasis> method connects the Windows exit size / move
  <xref linkend="ovvEvents"/> with an event handling method in the Rexx dialog object. This event is sent exactly
  one time when the user has stopped moving or stopped resizing the dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  <variablelist>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the event handling method that to be invoked when the size / move exit event occurs. The name must
      not be the empty string. When this argument is omitted the name defaults to <emphasis
      role="italic">onSizeMoveEnded</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.true</computeroutput>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns 0 on success and 1 if an (internal) error prevented the message from being connected to a method.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Unlike most event handlers, the event handling method for the size / move ended event does not receive any
    arguments. The Windows operating system ignores the return value to the event notification.
  </para>
  <para>
    <emphasis role="bold">Note</emphasis> that when the <xref linkend="clsResizingAdmin"/> is inherited by a dialog to
    produce a resizable dialog, the <emphasis role="italic">connectSizeMoveEnded</emphasis> method has no effect. The event
    notification events are handled internally by the <computeroutput>ResizingAdmin</computeroutput> object.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    exit size / move events happen.
  </para>
  <para>
    In Windows itself, the dialog receives this notification as a WM_EXITSIZEMOVE message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example comes from a resizable dialog implemented through the <xref linkend="clsDlgAreaU"/>
    class. It turns off forcing the dialog controls to redraw in the <computeroutput>DlgAreaU</computeroutput> object,
    and only has the controls redraw once when the sizing is finished.

<programlisting>
<![CDATA[

::method init
    expose sizing

    self~init:super
    ...
    self~connectResize('onResize')
    self~connectSizeMoveEnded('onExitSizeMove')
    sizing = .false
    ...


::method defineDialog
  expose u

  u = .dlgAreaU~new(self)
  u~updateOnResize = .false


::method onResize unguarded
  expose u sizing
  use arg ignored, sizeinfo

  sizing = .true

  u~resize(self, sizeinfo)
  return 0

::method onExitSizeMove unguarded
    expose sizing

    if sizing then do
      -- The user has stopped sizing the dialog, we will now show all the dialog
      -- controls we hid previously, and force the controls to redraw.
      self~showAllControls
      self~update
      sizing = .false
    end

    return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtEventNotificationSIZEMOVEENDED" xreflabel="SIZEMOVEENDED"><title>SizeMoveEnded Event Handler</title>
<indexterm><primary>EventNotification class</primary><secondary>events</secondary><tertiary>SIZEMOVEENDED</tertiary></indexterm>
<para>
  The event handler for the SizeMoveEnded event is invoked once, and only once, when the user has ended moving or ended
  sizing a window.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectMove"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onSizeMoveEnded unguarded
  use arg

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method does not receive any arguments.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores any return from this notification. 0 make a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    This example uses the resize and the size move ended event together. Rather than redraw the dialog controls for every new
    size while the user is dragging the dialog border, it waits and only redraws the controls when the user finishes resizing.
    To do this it sets a flag when the user starts to resize the dialog and then waits for the size move ended event to know
    that the user has finished:

<programlisting>
<![CDATA[
::method onResize unguarded
  expose u sizing minMaximized lastSizeInfo
  use arg sizingType, sizeinfo

  -- Save the size information so we know the final size of the dialog.
  lastSizeInfo = sizeInfo

  -- The size / move ended event does not occur when the user maximizes,
  -- minimizes, or restores from maximized / minimized.  Because of that, we
  -- need to redraw the client area under those conditions.

  if sizingType == self~SIZE_MAXIMIZED | sizingType == self~SIZE_MINIMIZED then do
    minMaximized = .true
    if sizingType == self~SIZE_MAXIMIZED then do
      u~resize(self, sizeinfo)
      self~redrawClient(.true)
    end
  end
  else if sizingType == self~SIZE_RESTORED, minMaximized then do
    minMaximized = .false
    u~resize(self, sizeinfo)
    self~redrawClient(.true)
  end
  else do
    -- We are resizing now.
    sizing = .true
  end

  return 0


::method onSizeMoveEnded unguarded
  expose u sizing lastSizeInfo

  -- If we were resizing, force the dialog controls to redraw themselves.
  if sizing then do
    u~resize(self, lastSizeInfo)
    self~redrawClient(.true)
  end

  -- We are not resizing anymore.
  sizing = .false
  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End SizeMoveEnded Event Handler -->

</section>  <!-- End EventNotification::connecSizeMoveEnded() -->

<section id="mthConnectStaticEvent" xreflabel="connectStaticEvent"><title>connectStaticEvent</title>
<indexterm><primary>connectStaticEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectStaticEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectStaticNotify(--id--,--event--,-+----------+--+--------------+--)----><
                                          +-,--mName-+  +-,-willReply--+

]]>
</programlisting>

<para>
  <emphasis role="italic">connectStaticEvent</emphasis> connects a notification message from a static control to a
  method, defined by the programmer, in the Rexx dialog object.  Normally, static controls do not send notification
  messages.  A static control will only send the messages when it has the NOTIFY style.  The notification messages
  inform the dialog that an event has occurred with regard to the static control.
</para>
<para>
  For user defined dialogs use the NOTIFY style keyword in the <link linkend="sctCreateStaticControls">create...</link>
  static control methods when the control is defined. For dialogs created from a compiled resource or a resource script file
  use the SS_NOTIFY style when defining the control in a resource editor.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the static control. May be numeric or symbolic.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event [required]</term>
    <listitem>
    <para>
      A keyword specifying the event to be connected with a method:
      <variablelist>
        <varlistentry><term><link linkend="evtStaticGeneral">CLICK</link></term>
        <listitem>
        <para>
          The static control has been clicked with the mouse.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><link linkend="evtStaticGeneral">DBLCLK</link></term>
        <listitem>
        <para>
          The static control has been double-clicked with the mouse.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><link linkend="evtStaticGeneral">DISABLE</link></term>
        <listitem>
        <para>
          The static control has been disabled.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><link linkend="evtStaticGeneral">ENABLE</link></term>
        <listitem>
        <para>
          The static control has been enabled.
        </para>
        </listitem></varlistentry>
      </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>mName [optional]</term>
    <listitem>
    <para>
      The method that is to be invoked whenever the specified notification is received from the static control. The
      programmer defines this method. The method name can not be the empty string. If this argument is omitted, a
      method name is automatically generated that consists of the event keyword preceded by
      <computeroutput>on</computeroutput>. For instance, <computeroutput>onClick</computeroutput>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.false</computeroutput>.
    </para>
    </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
    <para>
      The return codes are:
      <variablelist>
      <varlistentry><term>0</term>
      <listitem>
        <para>
          No error detected.
        </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
        <para>
          The resource ID could not be resolved or the event argument is incorrect.
        </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
        <para>
          The message was not connected correctly. The message was not connected
        </para>
      </listitem></varlistentry>
      </variablelist>
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example comes from an application that displays employee statistics.  A single click on the employee
    number field advances the display to the next employee.  A double click on either the employee name or employee job
    duties allows those fields to be edited.
  </para>
<programlisting>
<![CDATA[
::method initDialog

  self~connectStaticEvent(IDC_ST_EMPNO, "CLICK", empLookup)

  self~connectStaticEvent(IDC_ST_EMPJOB, "DBLCLK", editStats)
  self~connectStaticEvent(IDC_ST_EMPNAME, "DBLCLK", editStats)

  first = self~initDatabase
  self~setStats(first)
]]>
</programlisting>
  <para>
    In this example, (a continuation of the above example,) the control ID determines if the user has double clicked on
    the employee job duties field, or the employee name field. The first 2 and the fourth args are not needed or used so they
    are just discarded. The last arg, the Rexx static control object is passed on the userUpdate() method:
  </para>
<programlisting>
<![CDATA[
::method editStats unguarded
  use arg , , id, , staticCtrl

  rec = self~getCurrentRecord

  if self~userUpdate(id, staticCtrl, rec) then self~setStats(rec)

  return 0
]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>

<section id="evtStaticGeneral" xreflabel="General"><title>General Static Event Handler</title>
<indexterm><primary>Static class</primary><secondary>events</secondary><tertiary>CLICKED</tertiary></indexterm>
<indexterm><primary>Static class</primary><secondary>events</secondary><tertiary>DBLCLK</tertiary></indexterm>
<indexterm><primary>Static class</primary><secondary>events</secondary><tertiary>DISABLE</tertiary></indexterm>
<indexterm><primary>Static class</primary><secondary>events</secondary><tertiary>ENABLE</tertiary></indexterm>
<para>
  The event handler for all the static control events receives the same arguments and is coded in the same fashion. When the
  handler is invoked is fairly clear from the name of the event. The CLICKED event handler is invoked when the static control
  is clicked, etc..
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectStaticEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onStaticEvent unguarded
  use arg info, hwnd, id, notifyCode, staticObj

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 5 arguments. The first and second arguments need to be retained for backwards
    compatibility, but the last 3 arguments are really what is needed:
  </para>
  <variablelist>
    <varlistentry><term>info</term>
    <listitem>
    <para>
      A numeric value that contains info about the event. The low order word contains the resource ID of the static control
      sending the event. The high order word contains the static control event code. However, the ooDialog framework now
      extracts these values for you and sends them as the third and fourth arguments.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window handle of the static control that sent the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource id of the static control sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>notifyCode</term>
    <listitem>
    <para>
      The numeric notification code of the event that caused the notification to be sent. Each dialog control has its own
      specific notification codes.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>controlObj</term>
    <listitem>
    <para>
      The Rexx static control object that represents the underlying dialog control that sent the notification. It is possible
      this will be the <computeroutput>.nil</computeroutput> object if some error happened, but this is very unlikely.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this notification. 0 makes a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example comes from an application that uses a static image control. When the user double clicks on the
    static control, the application switches to the next application mode and the image on the control switches to the icon
    that represents the current mode of the application:

<programlisting>
<![CDATA[
::method defineDialog
  expose someIcon questionIcon isQuestion

  self~createStaticImage(IDC_ICON_QUESTION, 14, 17, 20, 20, "NOTIFY ICON SIZEIMAGE")
  self~createStaticText(IDC_ST_QUESTION, 59, 17, 122, 20)
  self~createPushButton(IDOK, 126, 74, 50, 14, "DEFAULT", 'Ok')

  self~connectStaticEvent(IDC_ICON_QUESTION, "DBLCLK", onDoubleClick, .true)

  questionIcon = .Image~getImage(IDI_QUESTION, ICON)
  ...

::method onDoubleClick unguarded
  use arg info, hwnd, id, notifyCode, static

  self~swapIcons(static)
  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End General Static Event Handler -->

</section>  <!-- End EventNotification::connectStaticEvent() -->


<section id="mthConnectStatusBarEvent" xreflabel="connectStatusBarEvent"><title>connectStatusBarEvent</title>
<indexterm><primary>connectStatusBarEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectStatusBarEvent</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectStatusBarEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectStatusBarEvent(--id--,--event--+-----------+--+-------------+--)----><
                                          +-,-mthName-+  +-,-willReply-+
]]>
</programlisting>

<para>
  Connects an event notification message from a status bar control to a method in the Rexx dialog object.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  </para>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the status bar control whose notification message is to be connected to a method in the Rexx dialog.
      May be numeric or <xref linkend="defSymbolicId"/>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event [required]</term>
    <listitem>
    <para>
      Exactly one of the following keywords. The keyword specifies the event to be connected. Case is not significant.
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>CLICK           </member>
        <member>DBLCLK          </member>
        <member>RCLICK          </member>
        <member>RDBLCLK         </member>
        <member>SIMPLEMODECHANGE</member>
      </simplelist>
    </para>
    <variablelist>
      <varlistentry id="kywStatusBarCLICK" xreflabel="CLICK"><term><link linkend="evtStatusBarGeneral">CLICK</link></term>
      <listitem>
      <para>
        Sent by a status bar control to notify the dialog that the user has clicked the left mouse button within the
        control. The event handler returns true to indicate that the mouse click was handled and to suppress the default
        processing by the operating system. Return false to allow default processing of the click.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywStatusBarDBLCLK" xreflabel="DBLCLK"><term><link linkend="evtStatusBarGeneral">DBLCLK</link></term>
      <listitem>
      <para>
        Sent by a status bar control to notify the dialog that the user has double-clicked the left mouse button within the
        control. The event handler returns true to indicate that the mouse click was handled and to suppress the default
        processing by the operating system. Return false to allow default processing of the click.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywStatusBarRCLICK" xreflabel="RCLICK"><term><link linkend="evtStatusBarGeneral">RCLICK</link></term>
      <listitem>
      <para>
        Sent by a status bar control to notify the dialog that the user has clicked the right mouse button within the
        control. The event handler returns true to indicate that the mouse click was handled and to suppress the default
        processing by the operating system. Return false to allow default processing of the click.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywStatusBarRDBLCLK" xreflabel="RDBLCLK"><term><link linkend="evtStatusBarGeneral">RDBLCLK</link></term>
      <listitem>
      <para>
        Sent by a status bar control to notify the dialog that the user has double-clicked the right mouse button within the
        control. The event handler returns true to indicate that the mouse click was handled and to suppress the default
        processing by the operating system. Return false to allow default processing of the click.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywStatusBarSIMPLEMODECHANGE" xreflabel="SIMPLEMODECHANGE"><term><xref linkend="evtStatusBarSIMPLEMODECHANGE"/></term>
      <listitem>
      <para>
        Sent by a status bar control when the simple mode changes due to the invocation of the <xref linkend="mthSimple"/>
        method. The reply from the event handler is ignored by the operating system.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that is to be invoked whenever the specified event happens. The programmer defines this method.
      If this argument is omitted, a method name is automatically generated that consists of the event keyword preceded by
      <computeroutput>on</computeroutput>. For instance, <computeroutput>onClick</computeroutput>. The method name can
      not be the empty string. The empty string is treated as an omitted argument.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.true</computeroutput>.
    </para>
    <para>
      For those event notifications that the operating system expects a return value, the <emphasis
      role="italic">willReply</emphasis> argument is ignored. For these events, the event handler must always return a value
      of the correct type. I.e., if the operating system expects a reply of true or false, the event handler must always
      return true or false. The events in the following list fall into this category:
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>CLICK           </member>
        <member>DBLCLK          </member>
        <member>RCLICK          </member>
        <member>RDBLCLK         </member>
      </simplelist>
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns <computeroutput>.true</computeroutput> if the event was connected correctly, otherwise
   <computeroutput>.false</computeroutput>.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected, including the use of an invalid symbolic ID or an
    unrecognized event keyword.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if the
    connected event happens.
  </para>
  <para>
    The underlying dialog receives the SBN_* messages as the notifications for the status bar events.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example shows the programmer connecting left and right mouse clicks, along with a simple mode change to the
    status bar in the application:

<programlisting>
<![CDATA[
::method initDialog

  self~connectStatusBarEvent(IDC_STATUSBAR, "RCLICK", onRightClick)
  self~connectStatusBarEvent(IDC_STATUSBAR, "CLICK", onClick)
  self~connectStatusBarEvent(IDC_STATUSBAR, "SIMPLEMODECHANGE", onModeChange)
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtStatusBarGeneral" xreflabel="General"><title>General StatusBar Mouse Click Event Handler</title>
<indexterm><primary>StatusBar class</primary><secondary>events</secondary><tertiary>General</tertiary></indexterm>
<indexterm><primary>StatusBar class</primary><secondary>events</secondary><tertiary>CLICK</tertiary></indexterm>
<indexterm><primary>StatusBar class</primary><secondary>events</secondary><tertiary>DBLCLK</tertiary></indexterm>
<indexterm><primary>StatusBar class</primary><secondary>events</secondary><tertiary>RCLICK</tertiary></indexterm>
<indexterm><primary>StatusBar class</primary><secondary>events</secondary><tertiary>RDBLCLK</tertiary></indexterm>
<para>
  A number of the statusbar events related to mouse clicks are processed internally by ooDialog in the same manner. The event
  handlers for these events are sent the same arguments and are essentially coded the same way. This <emphasis
  role="italic">general</emphasis> event handler is described here for the CLICK, DBLCLK, RCLICK, and RDBLCLK events. The
  description for the event keyword in the <xref linkend="mthConnectStatusBarEvent"/> documentation details when each event
  will invoke this event handler.
</para>
<para>
  The event handler must always reply either true or false to respond to these notification.
</para>

<programlisting>
<![CDATA[
::method onStatusBarClick unguarded
  use arg id, nCode, index, pt, statusBar

  return .true
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 5 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource ID of the statusbar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>notifyCode</term>
    <listitem>
    <para>
      The numeric notification code of the event that caused the notification to be sent. Each dialog control has its own
      specific notification codes.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>index</term>
    <listitem>
    <para>
      The one-based index of the section that was clicked. When a status bar is in simple mode there is only one part and the
      index will always be one.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pt</term>
    <listitem>
    <para>
      A <xref linkend="clsPoint"/> object that specifies the location of the click. Note that MSDN says this point is in
      screen <xref linkend="defScreenCoordinates"/>, but from experimentation it appears to actually be in client
      coordinates.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>statusBar</term>
    <listitem>
    <para>
      The Rexx status bar object that represents the underlying dialog control that sent the notification. It is possible
      this will be the <computeroutput>.nil</computeroutput> object if some error happened, but this is very unlikely.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The event handler must return true or false. Return true to indicate that the mouse click was handled and suppress
    default processing by the operating system. Return false to allow default processing of the click.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example has a status bar divided into 4 sections. The fourth section allows the user to toggle between
    simple status bar mode and normal by right clicking on section 4. Note that when the status bar is in simple mode, the
    user can click anywhere to take the status bar out of simple mode:

<programlisting>
<![CDATA[
::method onRightClick unguarded
  use arg id, nCode, index, pt, sb

  if sb~isSimple then do
    sb~simple(.false)
  end
  else if index == 4 then do
    sb~simple(.true)
  end

  return .true
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End General StatusBar Event Handler -->

<section id="evtStatusBarSIMPLEMODECHANGE" xreflabel="SIMPLEMODECHANGE"><title>SimpleModeChange Event Handler</title>
<indexterm><primary>StatusBar class</primary><secondary>events</secondary><tertiary>SIMPLEMODECHANGE</tertiary></indexterm>
<para>
  The event handler for the simple mode change event is invoked when the simple mode of the statusbar changes due to a <xref
  linkend="mthSimple"/> message.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectStatusBarEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onModeChange unguarded
  use arg id, code, sb

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 3 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource ID of the statusbar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>notifyCode</term>
    <listitem>
    <para>
      The numeric notification code of the event that caused the notification to be sent.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>controlObj</term>
    <listitem>
    <para>
      The Rexx dialog control object that represents the underlying dialog control that sent the notification. It is possible
      this will be the <computeroutput>.nil</computeroutput> object if some error happened, but this is very unlikely.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this notification. 0 makes a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example comes from an application that runs in <emphasis role="italic">basic</emphasis> and in an <emphasis
    role="italic">advanced</emphasis> mode. The status bar for the application contains a short cut to switch modes by double
    clicking on a section in the status bar. The user can also switch modes with the F3 key, or from the menu. No matter
    which method is used, the application switches mode by invoking the <xref linkend="mthSimple"/> method of the
    status bar. Therefore all the work of switching modes is done in th simple mode change event handler:

<programlisting>
<![CDATA[
::method onModeChange unguarded
  use arg id, code, sb

  if sb~isSimple then do
      self~statusBarUpdates = 'off'
      self~setSimpleTasks
      self~useWizrds = .true
  end
  else do
      self~statusBarUpdates = 'on'
      self~useAdvancedTasks
      self~useWizrds = .false
  end
  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End SimpleModeChange Event Handler -->

</section>  <!-- End EventNotification::connectStatusBarEvent() -->


<section id="mthConnectTabEvent" xreflabel="connectTabEvent"><title>connectTabEvent</title>
<indexterm><primary>connectTabEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectTabEvent(--id--,--event--+---------------+--+--------------+--)-----><
                                    +-,--methodName-+  +-,--willReply-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectTabEvent</emphasis> method connects a specific
  <xref linkend="ovvEvents"/> notification from a tab control with an event handling method in the Rexx
  dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the tab control whose event notification is to be connected to a method in the Rexx dialog.
        May be numeric or <xref linkend="defSymbolicId"/>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>event [required]</term>
      <listitem>
      <para>
        A single keyword indicating which event is to be connected. Case is not significant. The event keywords are:
        <variablelist>
          <varlistentry><term><xref linkend="evtTabKEYDOWN"/></term>
          <listitem>
          <para>
            The notification is sent when a key has been pressed while the tab control has the focus.
          </para>
          </listitem></varlistentry>
          <varlistentry><term><xref linkend="evtTabSELCHANGE"/></term>
          <listitem>
          <para>
            A new tab has been selected in the tab control. This method is called after the selection has changed.
          </para>
          </listitem></varlistentry>
          <varlistentry><term><xref linkend="evtTabSELCHANGING"/></term>
          <listitem>
          <para>
            A new tab has been selected in the tab control. This method is called before the selection is changed. The
            programmer can prevent the selected tab being changed at this point if the <emphasis
            role="italic">willReply</emphasis> argument is set to <computeroutput>.true</computeroutput>.
          </para>
          <para>
            The selection is prevented from changing by returning <computeroutput>.false</computeroutput>
            from the event handler for this event. Returning <computeroutput>.true</computeroutput> allows the change.
            Again, <emphasis role="bold">note</emphasis>, that preventing the change is only possible by specifying
            <computeroutput>.true</computeroutput> for the <emphasis role="italic">willReply</emphasis> argument. If
            <emphasis role="italic">willReply</emphasis> is <computeroutput>.false</computeroutput>, the default, the
            reply from the event handling method is ignored.
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      </listitem></varlistentry>
      <varlistentry><term>methodName [optional]</term>
      <listitem>
      <para>
        The method name that is invoked whenever the specified notification is received from the tab control. Provide
        a method with a matching name. If you omit this argument, the method name is automatically generated by the
        ooDialog framework. The generated name will be the event keyword preceded by
        <computeroutput>on</computeroutput>, for example <emphasis role="italic">onSelChanging</emphasis>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>willReply [optional]</term>
      <listitem>
      <para>
        The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
        handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
        <computeroutput>.false</computeroutput>.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return codes are:
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        No error detected.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
      <para>
        The resource ID could not be resolved or the event argument is incorrect.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
      <para>
        The messages was not connected correctly.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example invokes the method <emphasis role="italic">onSelChange</emphasis> whenever another tab is
    selected in the tab control:

<programlisting>
<![CDATA[
::class MyDlgClass subclass UserDialog

::method init
  self~connectTabEvent(IDC_TAB, "SELCHANGE")
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>


<section id="evtTabKEYDOWN" xreflabel="KEYDOWN"><title>KeyDown Event Handler</title>
<indexterm><primary>Tab class</primary><secondary>events</secondary><tertiary>KEYDOWN</tertiary></indexterm>
<para>
  The event handler for the key down event is invoked when the user types a key when the tab control has the focus.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectTabEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onKeyDown unguarded
  use arg id, vKey, tabControl

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 3 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource ID of the tab control sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>vKey</term>
    <listitem>
    <para>
      The virtual key code of the key typed. The <xref linkend="clsVK"/> class can be used to decode this value.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>arg2</term>
    <listitem>
    <para>
      The Rexx <xref linkend="clsTab"/> object representing the underlying tab control that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this notification so 0 makes a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example lets the user navigate through the tabs by typing N for next tab, P for previous tab, HOME for the
    first tab and END for the last tab:

<programlisting>
<![CDATA[
::method onKeyDown unguarded
  use arg id, vKey, tabControl

  lastTab = tabControl~items

  select
    when vKey == .VK~N then self~onNext
    when vKey == .VK~P then self~onPrevious
    when vKey == .VK~home then self~goTo(tabControl, 0)
    when vKey == .VK~end then self~goTo(tabControl, lastTab)
    otherwise nop  -- ignore all other keys
  end
  -- End select

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>
</section>  <!-- End KeyDown Event Handler -->


<section id="evtTabSELCHANGE" xreflabel="SELCHANGE"><title>SelChange Event Handler</title>
<indexterm><primary>Tab class</primary><secondary>events</secondary><tertiary>SELCHANGE</tertiary></indexterm>
<para>
  The event handler for the SELCHANGE event is invoked when the currently selected tab of the control has changed. Note that
  the notification is sent after the change has happened.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectTabEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onSelChange unguarded
  use arg id, hwndFrom, tabControl

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 3 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource ID of the tab control sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the tab control sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>tabControl</term>
    <listitem>
    <para>
      The Rexx <xref linkend="clsTab"/> object representing the underlying tab control that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this notification so 0 makes a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example comes from a program that sometimes allows hexidecimal numbers to be used and at other times does
    not. When the user changes the tab to the one with index 3, and if hexidecimal numbers are currently allowed, the
    hexidecimal entry field is enabled, otherwise it is disabled:
<programlisting>
<![CDATA[
::method onSelChange unguarded
  use arg id, hwndFrom, tabControl

  edit = self~newEdit(IDC_EDIT_HEX)

  if tabControl~selectedIndex == 3 & self~allowHexidecimal then edit~enable
  else edit~disable

  return 0
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End SelChange Event Handler -->


<section id="evtTabSELCHANGING" xreflabel="SELCHANGING"><title>SelChanging Event Handler</title>
<indexterm><primary>Tab class</primary><secondary>events</secondary><tertiary>SELCHANGING</tertiary></indexterm>
<para>
  The event handler for the SELCHANGING event is invoked when the user has selected a new tab. The notification is sent
  before the change has been made.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectTabEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onSelChanging unguarded
  use arg id, hwndFrom, tabControl

  return .true
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 3 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource ID of the tab control sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwndFrom</term>
    <listitem>
    <para>
      The window handle of the tab control sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>tabControl</term>
    <listitem>
    <para>
      The Rexx <xref linkend="clsTab"/> object representing the underlying tab control that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    When the <emphasis role="italic">willReply</emphasis> argument was set to true in the connect tab event method, the event
    handler must return true or false. A return of true allows the tab to be changed, a return of false prevents the tab from
    changing.
  </para>
  <para>
    When the <emphasis role="italic">willReply</emphasis> argument was set to false or SYNC in the connect tab event method,
    the ooDialog framwork replies to the operating system allowing the tab to change. The return from the event handler
    is ignored, but returning 0 is best practice.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example validates the data entered on a page of the tab control when the user goes to switch pages. If
    invalid data was entered on the current page of the tab control, the user is prevented from switching to a different tab
    until she enters valid data.

    A message dialog might be put saying something like: <emphasis role="italic">Your work telephone number is required.
    Please enter a valid telephone number before changing to a new page.</emphasis>
<programlisting>
<![CDATA[
::method initDialog

  self~connectTabEvent(IDC_TAB, "SELCHANGING", .true)

::method onSelChanging unguarded
  use arg id, hwndFrom, tabControl

  currentTab = tabControl~selectedIndex
  if \ self~validateTab(currentTab) then do
    -- The programmer should put up a message explaining
    -- why the page of the tab is not changing ...
    return .false
  end

  return .true
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End SelChanging Event Handler -->

</section>  <!-- End connectTabEvent() -->

<section id="mthConnectToolBarEvent" xreflabel="connectToolBarEvent"><title>connectToolBarEvent</title>
<indexterm><primary>connectToolBarEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectToolBarEvent</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectToolBarEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectToolBarEvent(--id--,--event--+-----------+--+-------------+--)------><
                                        +-,-mthName-+  +-,-willReply-+
]]>
</programlisting>

<para>
  Connects an event notification message from a toolbar control to a method in the Rexx dialog object.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  </para>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the toolbar control whose notification message is to be connected to a method in the Rexx dialog.
      May be numeric or <xref linkend="defSymbolicId"/>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event [required]</term>
    <listitem>
    <para>
      Exactly one of the following keywords. The keyword specifies the event to be connected. Case is not significant.
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>BEGINADJUST   </member>
        <member>BEGINDRAG     </member>
        <member>CHAR          </member>
        <member>CLICK         </member>
        <member>CUSTHELP      </member>
        <member>DBLCLK        </member>
        <member>DELETINGBUTTON</member>
        <member>DRAGOUT       </member>
        <member>DRAGOVER      </member>
        <member>DROPDOWN      </member>
        <member>DUPACCELERATOR</member>
        <member>ENDADJUST     </member>
        <member>ENDDRAG       </member>
        <member>GETBUTTONINFO </member>
        <member>GETDISPINFO   </member>
        <member>GETINFOTIP    </member>
        <member>GETOBJECT     </member>
        <member>HOTITEMCHANGE </member>
        <member>INITCUSTOMIZE </member>
        <member>KEYDOWN       </member>
        <member>LDOWN         </member>
        <member>MAPACCELERATOR</member>
        <member>QUERYDELETE   </member>
        <member>QUERYINSERT   </member>
        <member>RCLICK        </member>
        <member>RDBLCLK       </member>
        <member>RELEASEDCAPTURE</member>
        <member>RESET         </member>
        <member>RESTORE       </member>
        <member>SAVE          </member>
        <member>TOOLBARCHANGE </member>
        <member>WRAPACCELERATOR</member>
        <member>WRAPHOTITEM   </member>
      </simplelist>
    </para>
    <variablelist>
      <varlistentry id="kywToolBarBEGINADJUST" xreflabel="BEGINADJUST"><term><link linkend="evtToolBarGeneral">BEGINADJUST</link></term>
      <listitem>
      <para>
        Notifies the dialog that the user has begun customizing a toolbar
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarBEGINDRAG" xreflabel="BEGINDRAG"><term>BEGINDRAG</term>
      <listitem>
      <para>
        Notifies the dialog that the user has begun dragging a button in a toolbar.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarCHAR" xreflabel="CHAR"><term>CHAR</term>
      <listitem>
      <para>
        Sent by the toolbar when a character key is pressed.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarCLICK" xreflabel="CLICK"><term><link linkend="evtToolBarGeneralClick">CLICK</link></term>
      <listitem>
      <para>
        Sent by a toolbar control to notify the dialog that the user has clicked the left mouse button within the
        control.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarCUSTHELP" xreflabel="CUSTHELP"><term><link linkend="evtToolBarGeneral">CUSTHELP</link></term>
      <listitem>
      <para>
        Notifies the dialog that the user has chosen the Help button in the Customize Toolbar dialog box.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarDBLCLK" xreflabel="DBLCLK"><term><link linkend="evtToolBarGeneralClick">DBLCLK</link></term>
      <listitem>
      <para>
        Sent by a toolbar control to notify the dialog that the user has double-clicked the left mouse button within the
        control.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarDELETINGBUTTON" xreflabel="DELETINGBUTTON"><term>DELETINGBUTTON</term>
      <listitem>
      <para>
        Sent by a toolbar when a button is about to be deleted.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarDUPACCELERATOR" xreflabel="DUPACCELERATOR"><term>DUPACCELERATOR</term>
      <listitem>
      <para>
        Sent by a toolbar to determine whether an accelerator key can be used on two or more active toolbars.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarDRAGOUT" xreflabel="DRAGOUT"><term>DRAGOUT</term>
      <listitem>
      <para>
        Sent by a toolbar control when the user clicks a button and then moves the cursor off the button.
      </para>
      <para>
        This notification allows an application to implement drag-and-drop functionality for toolbar buttons. When processing
        this notification, the application would begin the drag-and-drop operation.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarDRAGOVER" xreflabel="DRAGOVER"><term>DRAGOVER</term>
      <listitem>
      <para>
        Sent by a toolbar control to determine whether a <xref linkend="mthMarkButton"/> message should be sent for a button
        that is being dragged over.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarDROPDOWN" xreflabel="DROPDOWN"><term>DROPDOWN</term>
      <listitem>
      <para>
        Sent by a toolbar control when the user clicks a dropdown button.
      </para>
      <para>
        Dropdown buttons can be plain (DROPDOWN style), display an arrow next to the button image (WHOLEDROPDOWN style), or
        display an arrow that is separated from the image (DRAWDDARROWS extended style). If a separated arrow is used,
        DROPDOWN is sent only if the user clicks the arrow portion of the button. If the user clicks the main part of the
        button, a button CLICKED event notification is sent, just as with a standard button. For the other two styles of
        dropdown button, DROPDOWN is sent when the user clicks any part of the button.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarENDDRAG" xreflabel="ENDDRAG"><term>ENDDRAG</term>
      <listitem>
      <para>
        Notifies the dialog that the user has stopped dragging a button in a toolbar.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarENDADJUST" xreflabel="ENDADJUST"><term><link linkend="evtToolBarGeneral">ENDADJUST</link></term>
      <listitem>
      <para>
        Notifies the dialog that the user has ended customizing a toolbar.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarGETBUTTONINFO" xreflabel="GETBUTTONINFO"><term>GETBUTTONINFO</term>
      <listitem>
      <para>
        Retrieves toolbar customization information and notifies the dialog of any changes being made to the toolbar.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarGETDISPINFO" xreflabel="GETDISPINFO"><term>GETDISPINFO</term>
      <listitem>
      <para>
        Retrieves display information for a toolbar item.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarGETINFOTIP" xreflabel="GETINFOTIP"><term>GETINFOTIP</term>
      <listitem>
      <para>
        Retrieves infotip information for a toolbar item.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarGETOBJECT" xreflabel="GETOBJECT"><term>GETOBJECT</term>
      <listitem>
      <para>
        Sent by a toolbar control that uses the REGISTERDROP style to request a drop target object when the pointer passes
        over one of its buttons.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarHOTITEMCHANGE" xreflabel="HOTITEMCHANGE"><term>HOTITEMCHANGE</term>
      <listitem>
      <para>
        Sent by a toolbar control when the hot (highlighted) item changes.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarINITCUSTOMIZE" xreflabel="INITCUSTOMIZE"><term>INITCUSTOMIZE</term>
      <listitem>
      <para>
        Notifies the dialog that customizing has started.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarKEYDOWN" xreflabel="KEYDOWN"><term>KEYDOWN</term>
      <listitem>
      <para>
        Sent by a toolbar control when the control has the keyboard focus and the user presses a key.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarLDOWN" xreflabel="LDOWN"><term>LDOWN</term>
      <listitem>
      <para>
        Notifies the dialog that the left mouse button has been pressed.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarMAPACCELERATOR" xreflabel="MAPACCELERATOR"><term>MAPACCELERATOR</term>
      <listitem>
      <para>
        Requests the index of the button in the toolbar corresponding to the specified accelerator character.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarQUERYDELETE" xreflabel="QUERYDELETE"><term>QUERYDELETE</term>
      <listitem>
      <para>
        Notifies the dialog whether a button may be deleted from a toolbar while the user is customizing the toolbar. The
        event handler can accept or refuse the deletion.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarQUERYINSERT" xreflabel="QUERYINSERT"><term>QUERYINSERT</term>
      <listitem>
      <para>
        Notifies the dialog that a button may be inserted to the left of the specified button while the user is customizing a
        toolbar. The event handler can accept or refuse the insertion.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarRCLICK" xreflabel="RCLICK"><term><link linkend="evtToolBarGeneralClick">RCLICK</link></term>
      <listitem>
      <para>
        Sent by a toolbar control to notify the dialog that the user has clicked the right mouse button within the
        control.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarRDBLCLK" xreflabel="RDBLCLK"><term><link linkend="evtToolBarGeneralClick">RDBLCLK</link></term>
      <listitem>
      <para>
        Sent by a toolbar control to notify the dialog that the user has double-clicked the right mouse button within the
        control.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarRELEASEDCAPTURE" xreflabel="RELEASEDCAPTURE"><term>RELEASEDCAPTURE</term>
      <listitem>
      <para>
        Notifies the dialog that the toolbar is releasing the mouse capture.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarRESET" xreflabel="RESET"><term>RESET</term>
      <listitem>
      <para>
        Notifies the dialog that the user has reset the content of the Customize Toolbar dialog box.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarRESTORE" xreflabel="RESTORE"><term>RESTORE</term>
      <listitem>
      <para>
        Notifies the dialog that a toolbar is in the process of being restored.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarSAVE" xreflabel="SAVE"><term>SAVE</term>
      <listitem>
      <para>
        Notifies the dialog that a toolbar is in the process of being saved.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarTOOLBARCHANGE" xreflabel="TOOLBARCHANGE"><term><link linkend="evtToolBarGeneral">TOOLBARCHANGE</link></term>
      <listitem>
      <para>
        Notifies the dialog that the user has customized a toolbar.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarWRAPACCELERATOR" xreflabel="WRAPACCELERATOR"><term>WRAPACCELERATOR</term>
      <listitem>
      <para>
        Requests the index of the button in one or more toolbars corresponding to the specified accelerator character.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolBarWRAPHOTITEM" xreflabel="WRAPHOTITEM"><term>WRAPHOTITEM</term>
      <listitem>
      <para>
        Notifies an application with two or more toolbars that the hot item is about to change.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that is to be invoked whenever the specified event happens. The programmer defines this method.
      If this argument is omitted, a method name is automatically generated that consists of the event keyword preceded by
      <computeroutput>on</computeroutput>. For instance, <computeroutput>onBeginAdjust</computeroutput>. The method name can
      not be the empty string. The empty string is treated as an omitted argument.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.true</computeroutput>.
    </para>
    <para>
      For those event notifications that the operating system expects a return value, the <emphasis
      role="italic">willReply</emphasis> argument is ignored. For these events, the event handler must always return a value
      of the correct type. I.e., if the operating system expects a reply of true or false, the event handler must always
      return true or false. The events in the following list fall into this category:
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>CHAR          </member>
        <member>CLICK         </member>
        <member>KEYDOWN       </member>
        <member>RCLICK        </member>
        <member>RDBLCLK       </member>
        <member>DROPDOWN      </member>
        <member>GETBUTTONINFO </member>
        <member>GETDISPINFO   </member>
        <member>GETINFOTIP    </member>
        <member>GETOBJECT     </member>
        <member>HOTITEMCHANGE </member>
        <member>INITCUSTOMIZE </member>
        <member>MAPACCELERATOR</member>
        <member>QUERYDELETE   </member>
        <member>QUERYINSERT   </member>
        <member>RESTORE       </member>
      </simplelist>
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns <computeroutput>.true</computeroutput> if the event was connected correctly, otherwise
   <computeroutput>.false</computeroutput>.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected, including the use of an invalid symbolic ID or an
    unrecognized event keyword.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if the
    connected event happens.
  </para>
  <para>
    The underlying dialog receives the TBN_* messages as the notifications for the toolbar events.
  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtToolBarGeneral" xreflabel="General"><title>General ToolBar Event Handler</title>
<indexterm><primary>ToolBar class</primary><secondary>events</secondary><tertiary>General</tertiary></indexterm>
<indexterm><primary>ToolBar class</primary><secondary>events</secondary><tertiary>BEGINADJUST</tertiary></indexterm>
<indexterm><primary>ToolBar class</primary><secondary>events</secondary><tertiary>CUSTHELP</tertiary></indexterm>
<indexterm><primary>ToolBar class</primary><secondary>events</secondary><tertiary>ENDJUST</tertiary></indexterm>
<indexterm><primary>ToolBar class</primary><secondary>events</secondary><tertiary>TOOLBARCHANGE</tertiary></indexterm>
<para>
  A number of the toolbar events are processed internally by ooDialog in the same manner. The event handlers for these events
  are sent the same arguments and are essentially coded the same way. This <emphasis role="italic">general</emphasis> event
  handler is described here for the BEGINADJUST, CUSTHELP, ENDADJUST, and TOOLBARCHANGE events. The description for event
  keyword in the <xref linkend="mthConnectStatusBarEvent"/> documentation details when each event will invoke this event
  handler.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectToolBarEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onToolBarEvent unguarded
  use arg id, notifyCode, toolBar

  return .true
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 3 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource ID of the statusbar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>notifyCode</term>
    <listitem>
    <para>
      The numeric notification code of the event that caused the notification to be sent. Each dialog control has its own
      specific notification codes.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>toolBar</term>
    <listitem>
    <para>
      The Rexx toolbar object that represents the underlying dialog control that sent the notification. It is possible this
      will be the <computeroutput>.nil</computeroutput> object if some error happened, but this is very unlikely.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return value for these events. 0 makes a good value to return.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example

<programlisting>
<![CDATA[

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End General ToolBar Event Handler -->

<section id="evtToolBarGeneralClick" xreflabel="General"><title>General ToolBar Mouse Click Event Handler</title>
<indexterm><primary>ToolBar class</primary><secondary>events</secondary><tertiary>General</tertiary></indexterm>
<indexterm><primary>ToolBar class</primary><secondary>events</secondary><tertiary>CLICK</tertiary></indexterm>
<indexterm><primary>ToolBar class</primary><secondary>events</secondary><tertiary>DBLCLK</tertiary></indexterm>
<indexterm><primary>ToolBar class</primary><secondary>events</secondary><tertiary>RCLICK</tertiary></indexterm>
<indexterm><primary>ToolBar class</primary><secondary>events</secondary><tertiary>RDBLCLK</tertiary></indexterm>
<para>
  A number of the toolbar events related to mouse clicks are processed internally by ooDialog in the same manner. The event
  handlers for these events are sent the same arguments and are essentially coded the same way. This <emphasis
  role="italic">general</emphasis> click event handler is described here for the CLICK, DBLCLK, RCLICK, and RDBLCLK events.
  The description for event keyword in the <xref linkend="mthConnectToolBarEvent"/> documentation details when each event
  will invoke this event handler.
</para>
<para>
  The event handler must always reply either true or false to respond to these notification.
</para>

<programlisting>
<![CDATA[
::method onToolBarClick unguarded
  use arg id, nCode, buttonID, pt, toolBar

  return .true
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 5 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The numeric resource ID of the toolbar sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>nCode</term>
    <listitem>
    <para>
      The numeric notification code of the event that caused the notification to be sent. Each dialog control has its own
      specific notification codes.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>index</term>
    <listitem>
    <para>
      The resource ID of the button that was clicked, or 0 if the click was not on a button in the toolbar.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>pt</term>
    <listitem>
    <para>
      A <xref linkend="clsPoint"/> object that specifies the location of the click. Not that MSDN says this point is in
      screen <xref linkend="defScreenCoordinates"/>, but from experimentation it appears to actually be in client
      coordinates.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>toolBar</term>
    <listitem>
    <para>
      The Rexx toolbar object that represents the underlying dialog control that sent the notification. It is possible
      this will be the <computeroutput>.nil</computeroutput> object if some error happened, but this is very unlikely.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The event handler must return true or false. Return true to indicate that the mouse click was handled and suppress
    default processing by the operating system. Return false to allow default processing of the click.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example has a toolbar with 3 buttons. The application allows the user to right click on the buttons to
    perform an extended action of the buttons purpose. For instance, one button is a File Open button. A regular click opens
    a file in the default encoding, a right click allows the user to specify the encoding  to open the file:

<programlisting>
<![CDATA[
::method onRightClick unguarded
  use arg id, nCode, buttonID, pt, toolBar

  if buttonID <> 0 then do
    self~buttonExtendedAction(buttonID, toolBar)
  end

  return .true
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End General ToolBar Click Event Handler -->

</section>  <!-- End EventNotification::connectToolBarEvent() -->


<section id="mthConnectToolTipEvent" xreflabel="connectToolTipEvent"><title>connectToolTipEvent</title>
<indexterm><primary>connectToolTipEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectToolTipEvent</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectToolTipEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectToolTipEvent(--id--,--event--+-----------+--+-------------+--)------><
                                        +-,-mthName-+  +-,-willReply-+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectToolTipEvent</emphasis> method connects an <xref linkend="ovvEvents"/> notification
  message from a <xref linkend="clsToolTip"/> control to a method in the Rexx dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  </para>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the tool tip control whose notification message is to be connected to a method in the Rexx dialog.
      May be numeric or <xref linkend="defSymbolicId"/>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event [required]</term>
    <listitem>
    <para>
      Exactly one of the following keywords. The keyword specifies the event to be connected. Case is not significant.
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>LINKCLICK</member>
        <member>NEEDTEXT</member>
        <member>POP</member>
        <member>SHOW</member>
      </simplelist>
    </para>
    <variablelist>
      <varlistentry id="kywToolTipLINKCLICK" xreflabel="LINKCLICK"><term>LINKCLICK</term>
      <listitem>
      <para>
        Requires Common Control <xref linkend="ovvComctl32"/> version 6.0 or later.
      </para>
      <para>
        This notification is sent when a text link inside a balloon ToolTip is clicked. MSDN provides this example of when
        this notification is sent. Assume that the balloon ToolTip contains the following text:

<programlisting>
<![CDATA[
        "This is a <A>link</A>".
]]>
</programlisting>

        When <emphasis role="italic">link</emphasis> is clicked, the LINKCLICK notification is sent.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolTipNEEDTEXT" xreflabel="NEEDTEXT"><term>NEEDTEXT</term>
      <listitem>
      <para>
        This notification is sent when the ToolTip control needs to retrieve the text used to display a ToolTip window.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolTipPOP" xreflabel="POP"><term>POP</term>
      <listitem>
      <para>
        This notification is sent when a ToolTip is about to be hidden.
      </para>
      </listitem></varlistentry>
      <varlistentry id="kywToolTipSHOW" xreflabel="SHOW"><term>SHOW</term>
      <listitem>
      <para>
        This notification is sent when a ToolTip control is about to be displayed.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term>methodName [optional]</term>
    <listitem>
    <para>
      The name of the method that is to be invoked whenever the specified event happens. The programmer defines this method.
      If this argument is omitted, a method name is automatically generated that consists of the event keyword preceded by
      <computeroutput>on</computeroutput>. For instance, <computeroutput>onNeedText</computeroutput>. The method name can not
      be the empty string. The empty string is treated as an omitted argument.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.true</computeroutput>.
    </para>
    <para>
      However, for the SHOW and NEEDTEXT events, the <emphasis role="italic">willReply</emphasis> argument is ignored. The
      event handler for those events must always return a value.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns <computeroutput>.true</computeroutput> if the event was connected correctly, otherwise
   <computeroutput>.false</computeroutput>.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected, including the use of an invalid symbolic ID or an
    unrecognized event keyword.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if the
    connected event happens.
  </para>
  <para>
    The underlying dialog receives the TTN_* messages as the notifications for the tool tip events.
  </para>
  </listitem></varlistentry>
</variablelist>


<section id="evtToolTipLINKCLICK" xreflabel="LINKCLICK"><title>LinkClick Event Handler</title>
<indexterm><primary>ToolTip class</primary><secondary>events</secondary><tertiary>LINKCLICK</tertiary></indexterm>
<para>
  The event handler for the LINKCLICK event is invoked when the text link inside a Balloon ToolTip is clicked.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectToolTipEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onLinkClick unguarded
  use arg rxToolID, rxToolTip

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives two arguments:
  </para>
  <variablelist>
    <varlistentry><term>rxToolID</term>
    <listitem>
    <para>
      The Rexx object used as the second part of the tool <link linkend="sctToolIdentification">identification</link> the
      operating system uses. This can be the Rexx dialog control object or the numeric ID that identifies the tool.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>rxToolTip</term>
    <listitem>
    <para>
      The Rexx tool tip object.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The actual value of the return has no meaning. 0 makes a good return.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End LinkClick Event Handler -->


<section id="evtToolTipNEEDTEXT" xreflabel="NEEDTEXT"><title>NeedText Event Handler</title>
<indexterm><primary>ToolTip class</primary><secondary>events</secondary><tertiary>NEEDTEXT</tertiary></indexterm>
<para>
  The event handler for the NEEDTEXT event is invoked when the ToolTip is about to be displayed and the ToolTip needs the
  text to be displayed. When a tool is <link linkend="mthAddTool">added</link> to a ToolTip, the programmer normally supplies
  a literal string to be used as the text. However, the ToolTip provides a special value which essentially tells the ToolTip
  to call back to the application when it needs the text to be displayed. The ToolTip calls back by sending the NEEDTEXT
  notification.
</para>
<para>
  The programmer must return a string to be used for the text and the interpreter waits for this return. The returned text is
  passed back to the ToolTip.
</para>

<programlisting>
<![CDATA[
::method onNeedText unguarded
  use arg toolID, toolTip, info

  return .true
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 3 arguments:
  </para>
  <variablelist>
    <varlistentry><term>toolID</term>
    <listitem>
    <para>
      The Rexx object used as the second part of the tool <link linkend="sctToolIdentification">identification</link> the
      operating system uses. This can be the Rexx dialog control object or the numeric ID that identifies the tool.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>toolTip</term>
    <listitem>
    <para>
      The Rexx tool tip object.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>info</term>
    <listitem>
    <para>
      A <computeroutput>Directory</computeroutput> object whose indexes are used to convey information concerning the event
      notification to the event handler and with which the event handler returns the requested text. On invocation of the
      event handler, the <computeroutput>Directory</computeroutput> object will have the following indexes with the
      corresponding information:
    </para>
    <variablelist>
      <varlistentry><term><emphasis role="bold">TEXT</emphasis></term>
      <listitem>
      <para>
        The event handler sets this index to the text to be used for the displayed ToolTip. If this index is set to the
        empty string, then no ToolTip is displayed. The length of the returned text must be less than 1024 characters. The
        index is set to the empty string when the <emphasis role="italic">info</emphasis> argument is passed to the event
        handler.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><emphasis role="bold">USERDATA</emphasis></term>
      <listitem>
      <para>
        This index is set to the <emphasis role="italic">user data</emphasis> specified for the tool. For example, in the
        <xref linkend="mthAddTool"/>, <xref linkend="mthAddToolEx"/>, or <xref linkend="mthAddToolRect"/> methods. If there
        is no user data, the index is set to the <computeroutput>.nil</computeroutput> object.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><emphasis role="bold">FLAGS</emphasis></term>
      <listitem>
      <para>
        Zero or more blank separated keywords indicating the tool's flags. The possible flag keywords are:
      </para>
      <para>
        <simplelist type='vert' columns='3'>
          <member>ABSOLUTE   </member>
          <member>CENTERTIP  </member>
          <member>IDISHWND   </member>
          <member>PARSELINKS </member>
          <member>RTLREADING </member>
          <member>SUBCLASS   </member>
          <member>TRACK      </member>
          <member>TRANSPARENT</member>
        </simplelist>
        <variablelist>
          <varlistentry><term>ABSOLUTE</term>
          <listitem>
          <para>
            Positions the ToolTip window at the exact same coordinates specified by the <xref linkend="mthTrackPosition"/>
            method. Without this flag the ToolTip control chooses where to display the ToolTip window based on the
            coordinates specified, which places the ToolTip close to the tool. This flag must be used with the TRACK flag.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>CENTERTIP</term>
          <listitem>
          <para>
            Indicates that the ToolTip window is centered below the tool.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>IDISHWND</term>
          <listitem>
          <para>
            Indicates that the ID part of the tool <link linkend="sctToolIdentification">identification</link> is the window
            handle to the tool. If this flag is not set, the ID part is the tool's identification number.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>PARSELINKS</term>
          <listitem>
          <para>
            Indicates that links in the ToolTip text should be parsed.
          </para>
          <para>
            Only available with Common Control <xref linkend="ovvComctl32"/> version 6.0 or later.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>RTLREADING</term>
          <listitem>
          <para>
            Indicates that the ToolTip text will be displayed in the opposite direction to the text in the parent window.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>SUBCLASS</term>
          <listitem>
          <para>
            Indicates that the ToolTip control should subclass the tool's window to intercept messages, such as WM_MOUSEMOVE.
            If this flag is not set, the mouse messages must be forwarded to the ToolTip control.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>TRACK</term>
          <listitem>
          <para>
             Positions the ToolTip window next to the tool to which it corresponds and moves the window according to
             coordinates supplied by the <xref linkend="mthTrackPosition"/> method.
          </para>
          </listitem></varlistentry>
          <varlistentry><term>TRANSPARENT</term>
          <listitem>
          <para>
            Causes the ToolTip control to forward mouse event messages to the parent window. This is limited to mouse events
            that occur within the bounds of the ToolTip window.
          </para>
          </listitem></varlistentry>
        </variablelist>
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The event handler must return true or false. When false is returned, the ToolTip continues to generate NEEDTEXT
    notifications each time it is about to display the tool tip window. If true is returned, the ToolTip control stores the
    information and will not request it again.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example shows a simple NEEDTEXT event handler that sets the tool tip text when the mouse hovers over a push
    button. True is returned to indicate that the ToolTip should store the text for that tool and need not ask for it again:

<programlisting>
<![CDATA[

::method onNeedText unguarded
    use arg id, toolTip, info

    info~text = 'Press Test to execute the regression test suite ...'
    return .true

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End NeedText Event Handler -->


<section id="evtToolTipPOP" xreflabel="POP"><title>Pop Event Handler</title>
<indexterm><primary>ToolTip class</primary><secondary>events</secondary><tertiary>POP</tertiary></indexterm>
<para>
  The event handler for the POP event is invoked when the ToolTip is about to hide a displayed tip.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectToolTipEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onPop unguarded
  use arg rxToolID, rxToolTip

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives two arguments:
  </para>
  <variablelist>
    <varlistentry><term>rxToolID</term>
    <listitem>
    <para>
      The Rexx object used as the second part of the tool <link linkend="sctToolIdentification">identification</link> the
      operating system uses. This can be the Rexx dialog control object or the numeric ID that identifies the tool.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>rxToolTip</term>
    <listitem>
    <para>
      The Rexx tool tip object.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The actual value of the return has no meaning. 0 makes a good return value.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Pop Event Handler -->


<section id="evtToolTipSHOW" xreflabel="SHOW"><title>Show Event Handler</title>
<indexterm><primary>ToolTip class</primary><secondary>events</secondary><tertiary>SHOW</tertiary></indexterm>

<programlisting>
<![CDATA[
::method onShow unguarded
  use arg rxToolID, rxToolTip

  return trueOrFalse
]]>
</programlisting>

<para>
  The event handler for the SHOW event is invoked when the ToolTip is about to display its window.
</para>
<para>
  The programmer must always return a value from the event handler and the interpreter waits for this return. The <emphasis
  role="italic">willReply</emphasis> argument of the <xref linkend="mthConnectToolTipEvent"/> method is ignored for this
  event. If the programmer does not intend to return a value from the event handler, the event should not be connected.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives two arguments:
  </para>
  <variablelist>
    <varlistentry><term>rxToolID</term>
    <listitem>
    <para>
      The Rexx object used as the second part of the tool <link linkend="sctToolIdentification">identification</link> the
      operating system uses. This can be the Rexx dialog control object or the numeric ID that identifies the tool.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>rxToolTip</term>
    <listitem>
    <para>
      The Rexx tool tip object.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    To display the ToolTip in its default position, return false. To customize the position, reposition the window and return
    true.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    Writing an event handler for the SHOW event gives the programmer the opportunity to customize the position of the
    ToolTip. Within the event handler, calculate the desired position of the ToolTip, then use the <xref
    linkend="mthSetWindowPos"/> to place the ToolTip window in that position. The event handler needs to return true to
    inform the ToolTip that custom positioning has been performed. Note that MSDN says that only the position of the window
    should be changed and that trying to change the size of the window will produce unpredictable results.
  </para>
  <para>
    A ToolTip's window rectangle is somewhat larger than its text display rectangle, and its origin is offset up and to the
    left. If the application needs to accurately position the text display rectangle of a ToolTip, use the <xref
    linkend="mthAdjustRect"/> method. This converts a text display rectangle into the corresponding ToolTip window rectangle
    and vice versa.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example uses the ToolTip ID to determine which ToolTip tool is about to display. It then calculates the
    position the ToolTip should be shown at, and uses <emphasis role="italic">setWindowPos</emphasis> to position the window
    at the point calculated. Finally, true is returned, so the ToolTip knows not to position itself at its default position:

<programlisting>
<![CDATA[

::method onShow unguarded
  expose r1 r2 r3 r4
  use arg toolID, toolTip

  select
    when toolID == .constDir[IDTOOL_DLG_RECT1] then pos = .Point~new(r1~left, r1~top)
    when toolID == .constDir[IDTOOL_DLG_RECT2] then pos = .Point~new(r2~left, r2~top)
    when toolID == .constDir[IDTOOL_DLG_RECT3] then pos = .Point~new(r3~left, r3~top)
    when toolID == .constDir[IDTOOL_DLG_RECT4] then pos = .Point~new(r4~left, r4~top)
    otherwise pos = .Point~new
  end
  -- End select

  self~client2screen(pos)
  toolTip~setWindowPos(TOPMOST, pos, .Size~new(0, 0), "NOACTIVATE NOSIZE NOZORDER")

  return .true

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End ToolTip SHOW Event Handler -->

</section>  <!-- End EventNotification::connectToolTipEvent() -->


<section id="mthConnectTrackBarEvent" xreflabel="connectTrackBarEvent"><title>connectTrackBarEvent</title>
<indexterm><primary>connectTrackBarEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>--connectTrackBarEvent(--id--,--event--+----------+--+-------------+--)------><
                                         +-,--mName-+  +-,-willReply-+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectTrackBarEvent</emphasis> method connects a particular trackbar POSITION event
  notification to a method in the Rexx dialog.
</para>

<note><title>Take Note</title>
<para>
  The method can only be called after the underlying trackbar has been created. A good location for this connection is
  the <xref linkend="mthInitDialog"/>  method.
</para>
</note>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
  </para>
  <variablelist>
    <varlistentry><term>id [required]</term>
    <listitem>
    <para>
      The resource ID of the trackbar control whose notification is to be connected.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event [required]</term>
    <listitem>
    <para>
      Exactly one of the following keywords that specifies the event to be connected. Case is not significant:
    </para>
    <variablelist>
      <varlistentry><term>UP</term>
      <listitem>
      <para>
        The Up or right key has been pressed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>DOWN</term>
      <listitem>
      <para>
        The Down or left key has been pressed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>TOP</term>
      <listitem>
      <para>
        The Home key has been pressed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>BOTTOM</term>
      <listitem>
      <para>
        The End key has been pressed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>PAGEUP</term>
      <listitem>
      <para>
        The PgUp key has been pressed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>PAGEDOWN</term>
      <listitem>
      <para>
        The PgDn key has been pressed.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>DRAG</term>
      <listitem>
      <para>
        The thumb of the trackbar has been moved.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>POSITION</term>
      <listitem><para>
        The left mouse button has been released, following a DRAG notification.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>ENDTRACK</term>
      <listitem>
      <para>
        The trackbar movement is completed, that is, the appropriate key or mouse button has been released.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term>mName [optional]</term>
    <listitem>
    <para>
      The name of the method to invoke whenever the specified notification is received the dialog. Provide a
      method with a matching name. If this argument is omitted, the ooDialog framework generates a method name automatically.
      The name will the event keyword preceded by <computeroutput>on</computeroutput>. For example, <emphasis
      role="italic">onDrag</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.false</computeroutput>.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    The return codes are:
  </para>
  <variablelist>
    <varlistentry><term>0</term>
    <listitem>
    <para>
      No error detected.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>-1</term>
    <listitem>
    <para>
      The resource ID could not be resolved or the event argument is incorrect.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>1</term>
    <listitem>
    <para>
      The messages was not connected correctly.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example connects the POSITION event (the mouse button is released after dragging) with method <emphasis
    role="italic">posSet</emphasis>, which extracts the new trackbar position from the notification arguments and
    displays it together with the event type for POSITION, which should be 4:

<programlisting>
<![CDATA[
::class ExampleDialog subclass UserDialog

::method initDialog

  self~connectTrackBarEvent("MYSLIDER", "POSITION", onPosition, 'SYNC')

::method onPosition unguarded
  use arg posInfo, hwnd, trackBar

  pos = .DlgUtil~hiWord(posInfo)

  say 'TrackBar new position:          ' pos
  say "Verify event code (should be 4):" .DlgUtil~loWord(posInfo)

  return 0

/*  Output might be:

TrackBar new position:           80
Verify event code (should be 4): 4
TrackBar new position:           0
Verify event code (should be 4): 4
TrackBar new position:           29
Verify event code (should be 4): 4

*/
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtTrackBarMOVE" xreflabel="MOVE"><title>TrackBar Move Event Handler</title>
<indexterm><primary>TrackBar class</primary><secondary>events</secondary><tertiary>MOVE</tertiary></indexterm>
<para>
  The event handler for the Move event is invoked when the user moves the moves the slider in a trackbar.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectTrackBarEvent"/> method
  determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onPage unguarded
  use arg posInfo, hwnd, trackBar

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 3 arguments:
  </para>
  <variablelist>
    <varlistentry><term>posInfo</term>
    <listitem>
    <para>
      The <emphasis role="italic">posInfo</emphasis> argument contains the move event code in the low word of the
      argument. For the POSITION and the DRAG move events only, the high word contains the position of the thumb box of the
      slider in the trackbar. For all the other events, the high word will be zero.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The <emphasis role="italic">hwnd</emphasis> argument is the window handle of the trackbar.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>trackBar</term>
    <listitem>
    <para>
      The Rexx trackbar object that represents the underlying trackbar that sent the notification.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The operating system ignores the return from this notification so 0 makes a good return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    For the event notifications where the high word of <emphasis role="italic">posInfo</emphasis> is zero, the position can
    be gotten directly from the <emphasis role="italic">trackBar</emphasis> object sent as the third argument
  </para>
  <para>
    The <xref linkend="clsTrackBar"/> class provides some <link linkend="sctConstantsClsTrackBar">constant</link> values as a
    convenience to help decode the numeric move event code:

<programlisting>
<![CDATA[
::method onMove unguarded
  use arg posInfo, hwnd, trackBar

  code = .DlgUtil~lowWord(posInfo)

  if code == trackBar~UP then do
    ...
  end
  else if code == trackBar~DOWN then do
    ...
  end
  else if code == trackBar~PAGEUP then do
    ...
  end
  --- and so on ...
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example sets a static text label to the new position of a trackbar each time a move event occurs.

<programlisting>
<![CDATA[
    ::method onEndTrack unguarded
    expose tbLabels
    use arg eventInfo, hwndTrackBar, trackBar

    -- Get the resource ID of the trackBar and use that as an index into the
    -- table of the labels.
    id = trackBar~id
    tbLabels[id]~setText(trackBar~pos)

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Trackbar General Event Handler -->

</section>  <!-- End EventNotification::connectTrackBarEvent -->

<section id="mthConnectTreeViewEvent" xreflabel="connectTreeViewEvent"><title>connectTreeViewEvent</title>
<indexterm><primary>connectTreeViewEvent</primary></indexterm>
<programlisting>
<![CDATA[
>>-connectTreeViewEvent(--id--,--event--+-------------+--+-------------+--)----><
                                        +-,--mthName--+  +-,-willReply-+

]]>
</programlisting>

<para>
  The <emphasis role="italic">connectTreeViewEvent</emphasis> method connects a method in a Rexx dialog to a particular
  tree view <xref linkend="ovvEvents"/>.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem><para>The arguments are:</para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the tree view control. This can be the numeric or symbolic ID.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>event</term>
    <listitem>
    <para>
      A keyword indicating which event is to be connected. Case is not significant. The keyword must be one of the following:
    </para>
    <para>
      <simplelist type='vert' columns='3'>
        <member>BEGINDRAG</member>
        <member>BEGINEDIT</member>
        <member>BEGINRDRAG</member>
        <member>DEFAULTEDIT</member>
        <member>DELETE</member>
        <member>ENDEDIT</member>
        <member>EXPANDED</member>
        <member>EXPANDING</member>
        <member>GETINFOTIP</member>
        <member>KEYDOWN</member>
        <member>KEYDOWNEX</member>
        <member>SELECTCHANGED</member>
        <member>SELECTCHANGING</member>
      </simplelist>
    </para>
      <variablelist>
        <varlistentry id="kywTreeViewBEGINDRAG" xreflabel="BEGINDRAG"><term><link linkend="evtTreeViewBEGINDRAG">BEGINDRAG</link></term>
        <listitem>
        <para>
          A drag-and-drop operation using the left mouse button was initiated. The documentation for the
          <xref linkend="mthDefTreeDragHandler"/>() method contains further information on how to implement a drag-and-drop
          handler. Not that if the tree-view control is give the <xref linkend="styTreeViewNODRAG"/> style, the BEGINDRAG
          notification is not sent.
        </para>
        </listitem></varlistentry>
        <varlistentry id="kywTreeViewBEGINEDIT" xreflabel="BEGINEDIT"><term><xref linkend="evtTreeViewBEGINEDIT"/></term>
        <listitem>
        <para>
          Editing a label has been started. Do not connect this event if you are using the DEFAULTEDIT keyword. The results are
          undefined. The tree-view must have the <xref linkend="styTreeViewEDIT"/> style for this notification to be sent.
        </para>
        <para>
          The event notification for this event has been enhanced since the original ooDialog implementation. To use the
          enhanced event notification, the <emphasis role="italic">willReply</emphasis> argument must be used. The value of the
          argument, true or false, does not matter. If <emphasis role="italic">willReply</emphasis> is omitted, the old style
          notification is used. The documentation for the <link linkend="evtTreeViewBEGINEDIT">BEGINEDIT</link> event handler
          explains the difference between the two types of notifications.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><link linkend="evtTreeViewBEGINDRAG">BEGINRDRAG</link></term>
        <listitem>
        <para>
          A drag-and-drop operation involving the right mouse button was initiated. The documentation for the
          <xref linkend="mthDefTreeDragHandler"/>() method contains further information on how to
          implement a drag-and-drop handler. handler.
        </para>
        </listitem></varlistentry>
        <varlistentry id="kywTreeViewDEFAULTEDIT" xreflabel="DEFAULTEDIT"><term><xref linkend="evtTreeViewDEFAULTEDIT"/></term>
        <listitem>
        <para>
          This keyword is used to activate the internal handling of the tree-view label editing operation. With this keyword,
          the ooDialog framework internally handles the BEGINEDIT and ENDEDIT notifications. The tree-view must have the
          <xref linkend="styTreeViewEDIT"/> style for the BEGINEDIT / ENDEDIT notification to be sent. While using the
          DEFAULTEDIT connection may seem easier than using the BEGINEDIT / ENDEDIT connections, it does not provide the same
          flexibility as using the BEGINEDIT / ENDEDIT connections.
        </para>
        <para>
          When you specify this event connection, omit the <emphasis role="italic">methodName</emphasis> argument, the arugment
          is ignored. Do not connect either the BEGINEDIT or ENDEDIT events when also using the DEFAULTEDIT connection. The
          result is undefined.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtTreeViewDELETE"/> </term>
        <listitem>
        <para>
          An item has been deleted.
        </para>
        </listitem></varlistentry>
        <varlistentry id="kywTreeViewENDEDIT" xreflabel="ENDEDIT"><term><xref linkend="evtTreeViewENDEDIT"/> </term>
        <listitem>
        <para>
          Label editing has ended. Do not connect this event if you are using the DEFAULTEDIT keyword. The results are
          undefined. The tree-view must have the <xref linkend="styTreeViewEDIT"/> style for this notification to be sent.
        </para>
        <para>
          The event notification for this event has been enhanced since the original ooDialog implementation. To use the
          enhanced event notification, the <emphasis role="italic">willReply</emphasis> argument must be used. The value of the
          argument, true or false, does not matter. If <emphasis role="italic">willReply</emphasis> is omitted, the old style
          notification is used. The documentation for the <link linkend="evtTreeViewENDEDIT">ENDEDIT</link> event handler
          explains the difference between the two types of notifications.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtTreeViewEXPANDED"/></term>
        <listitem>
        <para>
          An item has expanded or collapsed. This notification is sent after the item expanded or collapsed.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtTreeViewEXPANDING"/></term>
        <listitem>
        <para>
          An item is about to expand or collapse. This notification is sent before the item has expanded or collapsed.
        </para>
        </listitem></varlistentry>
        <varlistentry id="kywTreeViewGETINFOTIP" xreflabel="GETINFOTIP"><term><xref linkend="evtTreeViewGETINFOTIP"/></term>
        <listitem>
        <para>
          The tree-view control is requesting text to display an info tip. The notification is only sent when the tree-view
          control has the <link linkend="styTreeViewINFOTIP">INFOTIP</link> style.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtTreeViewKEYDOWN"/></term>
        <listitem>
        <para>
          A key was pressed inside the tree view. This notification is not sent while a label is being edited.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtTreeViewKEYDOWNEX"/> </term>
        <listitem>
        <para>
          A key was pressed inside the tree view. This notification is not sent while a label is being edited.
        </para>
        <para>
          This event is exactly the same as the KEYDOWN event. Except, when this keyword is used, the ooDialog framework sends
          a different set of arguments to the event handler. The additional arguments provide more information to the
          programmer than the arguments sent when the KEYDOWN keyword is used. The two keywords are needed to provide
          backwards compatibility.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtTreeViewSELCHANGED"/></term>
        <listitem>
        <para>
          Another item was selected. This notification is sent after the selection was changed.
        </para>
        </listitem></varlistentry>
        <varlistentry><term><xref linkend="evtTreeViewSELCHANGING"/> </term>
        <listitem>
        <para>
          Another item is about to be selected. This notification is sent before the selection has changed.
        </para>
        </listitem></varlistentry>
      </variablelist>
    </listitem></varlistentry>
    <varlistentry><term>mthName</term>
    <listitem>
    <para>
      The name of the event handling method. This method is invoked each time the specified event occurs for the tree
      view control. If you omit this argument, the method name is generated for you. This name will be the event
      keyword, preceded by <computeroutput>on</computeroutput>. For example: <emphasis
      role="italic">onExpanded</emphasis>. The method name can not be the empty string.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>willReply [optional]</term>
    <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
      handler for the connected event. The default if <emphasis role="italic">willReply</emphasis> is omitted is
      <computeroutput>.false</computeroutput>.
    </para>
    <para>
      The operating system expects a return value from the GETINFOTIP notification. When that event is connected the
      <emphasis role="italic">willReply</emphasis> argument is ignored. The event handler for GETINFOTIP must always return a
      string value.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    <variablelist>
      <varlistentry><term>0</term>
      <listitem>
      <para>
        No error detected.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>-1</term>
      <listitem>
      <para>
        The resource ID was symbolic and it could not be resolved, or the event keyword is not correct.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>1</term>
      <listitem>
      <para>
        Some other error and the message was not connected correctly. This may indicate the message table is full, or the
        interpreter is out of usable memory.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  <para>
    <emphasis role="bold">Note:</emphasis> The original implementation of ooDialog was limited in the arguments sent to the
    event handlers for many event notifications. In many cases, the Windows notification provides more information than was
    provided to the event handlers in the original implementation. Many of the event notifications for the tree-view have
    been enhanced to provide the event handlers with more complete information. To maintain backwards compatibility, if the
    <emphasis role="italic">willReply</emphasis> argument is omitted, the old event notification implementation is used. To
    use the enhanced implementation, the programmer simply includes the <emphasis role="italic">willReply</emphasis>
    argument. Whether the argument is false or true does not matter. It is the process of including the argument that signals
    the programmer wants to use the enhanced notification.
  </para>
  <para>
    However, the <emphasis role="italic">willReply</emphasis> argument is ignored for the GETINFOTIP event. For this
    event, the interpreter always waits for the reply. If the programmer does not wish to return a value from the event
    handler for the GETINFOTIP, then he should not connect that event.
  </para>
  <para>
    For each tree-view event keyword, there is a section describing the details of the event handler for that keyword. These
    sections immediately follow this section.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if any
    command events happen.
  </para>
  <para>
    In Windows itself, tree view event notifications are sent to the parent dialog using the WM_NOTIFY message.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
  <para>
    The following example connects the selection-changed event for the tree-view with the symbolic ID of IDC_TV_FILES with
    the method newTreeSelection in the Rexx dialog. The event handling method displays the text of the new selection:
  <programlisting>
  <![CDATA[
  ::class 'FileDlg' subclass UserDialog

  ::method init
    self~connectTreeViewEvent(IDC_TV_FILES, "SELCHANGED", "newTreeSelection", .true)

  ::method newTreeSelection unguarded
    use arg id, hItemOld, userOld, hItemNew, userNew, action, rxTv
    textNew = rxTv~itemText(hItemNew)
    say "The label of the new selection is:" text

    return 0
  ]]>
  </programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

<section id="evtTreeViewBEGINDRAG" xreflabel="BEGINDRAG"><title>BeginDrag / BeginRDrag Event Handler</title>
<indexterm><primary>TreeView class</primary><secondary>events</secondary><tertiary>BEGINDRAG</tertiary></indexterm>
<indexterm><primary>TreeView class</primary><secondary>events</secondary><tertiary>BEGINRDRAG</tertiary></indexterm>

<para>
  The event handler for the BEGINDRAG event is invoked when a drag-and-drop operation involving the left mouse button is
  being initiated in the tree-view. The event handler for the BEGINRDRAG event is invoked when a drag-and-drop operation
  involving the right mouse button is being initiated in the tree-view. The arguments sent to, and the behaviour of, both
  event handlers is identical. Both event handlers are described in this single section.
</para>
<para>
  Both of these event notifications have been enhanced since the original ooDialog implementation. If the <emphasis
  role="italic">willReply</emphasis> argument to the <xref linkend="mthConnectTreeViewEvent"/> method is omitted the old
  implementation is used. If the argument is not omitted, the new implementation is used. In addition, ooDialog provides a
  default handler for these events. If the <emphasis role="italic">mthName</emphasis> argument is specified as <emphasis
  role="italic">defTreeDragHandler</emphasis>, then this default event handler is used. How the event handlers work is
  described separately below:
</para>

<variablelist>
  <varlistentry><term><emphasis role="bold">New event handler description:</emphasis></term>
  <listitem>
  <para>
    The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectTreeViewEvent"/> method
    determines how the event handler needs to respond to the notification.
  </para>

<programlisting>
<![CDATA[
::method onBeginDrag unguarded
  use arg id, hItem, pos, treeView, itemData

  return 0
]]>
</programlisting>

    <variablelist>
      <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
      <listitem>
      <para>
        The event handling method receives 5 arguments:
      </para>
      <variablelist>
        <varlistentry><term>id</term>
        <listitem>
        <para>
          The resource id of the tree-view sending the notification.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>hItem</term>
        <listitem>
        <para>
          The tree-view item handle that is being dragged
        </para>
        </listitem></varlistentry>
        <varlistentry><term>pos</term>
        <listitem>
        <para>
          The position, in client <link linkend="defScreenCoordinates">coordinates</link>, where the drag started. <emphasis
          role="italic">pos</emphasis> is a <xref linkend="clsPoint"/> object.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>treeView</term>
        <listitem>
        <para>
          The Rexx tree-view object whose underlying tree-view control has sent the notification. This is a convenience for
          the programmer. It is the same Rexx object the programmer would receive through the <xref
          linkend="mthNewTreeView"/> method.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>itemData</term>
        <listitem>
        <para>
          The item <link linkend="mthSetItemDataClsTreeView">data</link> object assigned to the tree-view item being dragged.
          If no item data has been assigned, this argument will be the <computeroutput>.nil</computeroutput> object.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
      <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
      <listitem>
      <para>
        The operating system ignores the returned value, so any value can be used. 0 makes a good return.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Old event handler description:</emphasis></term>
  <listitem>
  <para>
    The old style event notification is used when the programmer omits the <emphasis role="italic">willReply</emphasis>
    argument in the invocation of the <xref linkend="mthConnectListViewEvent"/> method. The return from the event handler is
    completely ignored, the interpreter does not wait for this return.
  </para>

  <programlisting>
  <![CDATA[
  ::method onBeginDrag unguarded
    use arg id, hItem, where, treeView
  ]]>
  </programlisting>

  <variablelist>
    <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
    <listitem>
    <para>
      The event handling method receives 3 arguments:
    </para>
    <variablelist>
      <varlistentry><term>id</term>
      <listitem>
      <para>
        The resource id of the tree-view sending the notification.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>hItem</term>
      <listitem>
      <para>
        The handle to the tree-view item being dragged
      </para>
      </listitem></varlistentry>
      <varlistentry><term>where</term>
      <listitem>
      <para>
        Specifies the postion of the cursor when the drag operation was initiated as a 2 word string. The first word is the x
        position, the second word is the y postion. The position is expressed in client <link
        linkend="defScreenCoordinates">coordinates</link>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>treeView</term>
      <listitem>
      <para>
        The Rexx tree-view object whose underlying tree-view control has sent the notification. This is a convenience for
        the programmer. It is the same Rexx object the programmer would receive through the <xref
        linkend="mthNewTreeView"/> method.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
    <listitem>
    <para>
      The return value is ignored by the operating system. 0 makes a good return value.
    </para>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
    <listitem>

<programlisting>
<![CDATA[

::method onBeginDrag unguarded
  use arg id, item, where, treeView
  say "Item with handle" item "is in drag-and-drop mode"
  parse var where x y
  say "The drag operation started at point ("x","y")"

  return 0
]]>
</programlisting>

    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">defTreeDragHandler event handler description:</emphasis></term>
  <listitem>
  <para>
    If the <emphasis role="italic">mthName</emphasis> argument for the BEGINDRAG or BEGINRDRAG event connections is <emphasis
    role="italic">defTreeDragHandler</emphasis>, then a method supplied by the ooDialog framework is connected. The
    programmer does not take any other action. Since the ooDialog framework is handling things internally, the <emphasis
    role="italic">willReply</emphasis> argument is ignored when <emphasis role="italic">defTreeDragHandler</emphasis> is
    used.
  </para>

  </listitem></varlistentry>
</variablelist>

</section>  <!-- End BeginDrag Event Handler -->


<section id="evtTreeViewBEGINEDIT" xreflabel="BEGINEDIT"><title>BeginEdit Event Handler</title>
<indexterm><primary>TreeView class</primary><secondary>events</secondary><tertiary>BEGINEDIT</tertiary></indexterm>
<para>
  The event handler for the BEGINEDIT event is invoked when the user begins a label editing operation on an item of the
  tree-view. When label editing begins, an edit control is created by the operating system, but not positioned or displayed.
  Before it is displayed, the tree-view control sends a BEGINEDIT notification message. A label editing operation is only
  available when the tree-view has the <xref linkend="styTreeViewEDIT"/> style.
</para>
<para>
  In general, the programmer would connect both the BEGINEDIT and <xref linkend="kywTreeViewENDEDIT"/> notifications. Both of
  these event notifications have been enhanced since the original ooDialog implementation. If the <emphasis
  role="italic">willReply</emphasis> argument to the <xref linkend="mthConnectTreeViewEvent"/> method is omitted the old
  implementation is used. If the argument is not omitted, the new implementation is used. How the two event handlers work is
  described separately.
</para>

<variablelist>
  <varlistentry><term><emphasis role="bold">New event handler description:</emphasis></term>
  <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectTreeViewEvent"/>
      method determines how the event handler needs to respond to the notification.
    </para>

    <programlisting>
    <![CDATA[
    ::method onBeginEdit unguarded
      use arg id, hItem, editCtrl, treeViewCtrl, itemData

      return zz
    ]]>
    </programlisting>

    <variablelist>
      <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
      <listitem>
      <para>
        The event handling method receives 5 arguments:
      </para>
      <variablelist>
        <varlistentry><term>id</term>
        <listitem>
        <para>
          The resource id of the tree-view sending the notification.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>hItem</term>
        <listitem>
        <para>
          The tree-view item handle whose label is about to be edited.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>editCtrl</term>
        <listitem>
        <para>
          The Rexx edit control object used for the editing operation. The programmer can customize the editing operation by
          using the methods of the <link linkend="clsEdit">Edit</link> class.
        </para>
        <para>
          <emphasis role="bold">Note</emphasis> that this object is only valid during the editing operation. When the user
          ends the editing, the operating system destroys the underlying edit control and the Rexx object is no longer valid.
          Each time the user starts a new editing operation, the operating system creates a new edit control.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>treeViewCtrl</term>
        <listitem>
        <para>
          The Rexx tree-view object whose underlying tree-view control has sent the notification. This is a convenience for
          the programmer. It is the same Rexx object the programmer would receive through the <xref
          linkend="mthNewTreeView"/> method. Unlike the <emphasis role="italic">editCtrl</emphasis> object, this object is
          valid as long as the dialog is executing.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>itemData</term>
        <listitem>
        <para>
          The item <link linkend="mthSetItemDataClsTreeView">data</link> object assigned to the tree-view item whose label is
          about to be edited. If no item data has been assigned, this argument will be the
          <computeroutput>.nil</computeroutput> object.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
      <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
      <listitem>
      <para>
        When the programmer used true for the <emphasis role="italic">willReply</emphasis> argument, the event handler must
        return true or false. To allow the editing operation to begin, return true. To cancel the editing operation, return
        false. Returning a value from the event handler gives the programmer the option determining if the label for the
        specific tree-view item should or should not be edited.
      </para>
      <para>
        IF the programmer used false or SYNC for the <emphasis role="italic">willReply</emphasis> argument, the ooDialog
        framework always replies to the operaring system to allow the editing operation to begin.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><emphasis role="bold">Example</emphasis></term>
      <listitem>
      <para>
        The following example shows a possible event handler for the BEGINEDIT event.  It uses the <emphasis
        role="italic">hItem</emphasis> argument to determine which item is about the have its label edited, and checks that
        editing is allowed for that item. If it is, it returns true to allow the operation. If it is not, it returns false to
        cancel the operation and puts up a message box to inform the user. Note that the <emphasis
        role="italic">itemData</emphasis> argument is assigned to the <emphasis role="italic">rec</emphasis> variable in this
        example, just to make it clear that the argument sent to the event handler is the item data object. In this
        particular program the item data object is a record object:

<programlisting>
<![CDATA[

::method onBeginEdit unguarded
  use arg id, hItem, editCtrl, treeViewCtrl, itemData

  rec = itemData
  if rec~isEditable then return .true

  reply .false

  msg = "The record for" rec~FirstName rec~LastName 'can not be changed.'
  title = "Label Edit Error"
  j = MessageDialog(msg, self~hwnd, title, , "WARNING")

  return

]]>
</programlisting>
      </para>
      </listitem></varlistentry>
    </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Old event handler description:</emphasis></term>
  <listitem>
  <para>
    The old style event notification is used when the programmer omits the <emphasis role="italic">willReply</emphasis>
    argument in the invocation of the <xref linkend="mthConnectTreeViewEvent"/> method. The return from the event handler is
    completely ignored, the interpreter does not wait for this return.
  </para>

  <programlisting>
  <![CDATA[
  ::method onBeginEdit unguarded
    use arg id, hItem, treeView
  ]]>
  </programlisting>

  <variablelist>
    <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
    <listitem>
    <para>
      The event handling method receives 2 arguments:
    </para>
    <variablelist>
      <varlistentry><term>id</term>
      <listitem>
      <para>
        The resource id of the tree-view sending the notification.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>hItem</term>
      <listitem>
      <para>
        The handle to the tree-view item whose label is about to be edited.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>treeView</term>
      <listitem>
      <para>
        The Rexx tree-view object whose underlying tree-view control has sent the notification. This is a convenience for
        the programmer. It is the same Rexx object the programmer would receive through the <xref
        linkend="mthNewTreeView"/> method.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
    <listitem>
    <para>
      Returning, or not returning, a value has no meaning.
    </para>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Remarks</emphasis></term>
    <listitem>
    <para>
      Connecting this event and not using the <emphasis role="italic">willReply</emphasis> argument does not make much sense.
      The event handler really serves no purpose.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End BeginEdit Event Handler -->


<section id="evtTreeViewDEFAULTEDIT" xreflabel="DEFAULTEDIT"><title>DefaultEdit Event Handler</title>
<indexterm><primary>TreeView class</primary><secondary>events</secondary><tertiary>DEFAULTEDIT</tertiary></indexterm>
<para>
  When the programmer specifies the DEFAULTEDIT event keyword for the <emphasis role="italic">event</emphasis> argument in
  the <xref linkend="mthConnectTreeViewEvent"/> method, the ooDialog framework handles both the BEGINEDIT and ENDEDIT events
  internally. These events are only generated when the tree-view has the <xref linkend="styTreeViewEDIT"/> style.
</para>
<para>
  The internal handling of the events changes the label of the item if the user does not cancel the editing operation. If the
  user cancels the editing operation, the original lable is left unchanged. Allowing ooDialog to handle these events is less
  work for the programmer, but it is also inflexible.
</para>

</section>  <!-- End DefaultEdit Event Handler -->


<section id="evtTreeViewDELETE" xreflabel="DELETE"><title>Delete Event Handler</title>
<indexterm><primary>TreeView class</primary><secondary>events</secondary><tertiary>DELETE</tertiary></indexterm>
<para>
  The event handler for the DELETE event is invoked when the user deletes an item in the tree-view.
</para>
<para>
  This event notification has been enhanced since the original ooDialog implementation. If the <emphasis
  role="italic">willReply</emphasis> argument to the <xref linkend="mthConnectTreeViewEvent"/> method is omitted the old
  implementation is used. If the argument is not omitted, the new implementation is used. How the two event handlers work is
  described separately below.
</para>

<variablelist>
  <varlistentry><term><emphasis role="bold">New event handler description:</emphasis></term>
  <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectTreeViewEvent"/>
      method determines how the event handler needs to respond to the notification.
    </para>

    <programlisting>
    <![CDATA[
    ::method onDelete unguarded
      use arg, id, hItem, rxTv, itemData

      return 0
    ]]>
    </programlisting>

    <variablelist>
      <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
      <listitem>
      <para>
        The event handling method receives 4 arguments:
      </para>
      <variablelist>
        <varlistentry><term>id</term>
        <listitem>
        <para>
          The resource id of the tree-view sending the notification.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>hItem</term>
        <listitem>
        <para>
          The item handle of the item being deleted.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>rxTv</term>
        <listitem>
        <para>
          The Rexx tree-view object whose underlying tree-view control has sent the notification. This is a convenience for
          the programmer. It is the same Rexx object the programmer would receive through the <xref
          linkend="mthNewTreeView"/> method.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>itemData</term>
        <listitem>
        <para>
          The item <link linkend="mthSetItemDataClsTreeView">data</link> object assigned to the tree-view item that is being
          deleted. If no item data has been assigned, this argument will be the <computeroutput>.nil</computeroutput> object.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
      <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
      <listitem>
      <para>
        The operating system ignores the return from this notification. 0 makes a good return for cases where the operating
        system ignores the return value from an event notification.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Old event handler description:</emphasis></term>
  <listitem>
  <para>
    The old style event notification is used when the programmer omits the <emphasis role="italic">willReply</emphasis>
    argument in the invocation of the <xref linkend="mthConnectTreeViewEvent"/> method. The return from the event handler is
    completely ignored, the interpreter does not wait for this return.
  </para>

  <programlisting>
  <![CDATA[
  ::method onDelete unguarded
    use arg id, useLess, rxTv
  ]]>
  </programlisting>

  <variablelist>
    <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
    <listitem>
    <para>
      The event handling method receives 3 arguments:
    </para>
    <variablelist>
      <varlistentry><term>id</term>
      <listitem>
      <para>
        The resource id of the tree-view sending the notification.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>useLess</term>
      <listitem>
      <para>
        This argument is a number that has no meaning within the Rexx code. The old implementation of this event notification
        sent the numeric value of a pointer to memory to the event handler. However, there is nothing that can be done with
        the number in a Rexx program.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>rxTv</term>
      <listitem>
      <para>
        The Rexx tree-view object whose underlying tree-view control has sent the notification. This is a convenience for
        the programmer. It is the same Rexx object the programmer would receive through the <xref
        linkend="mthNewTreeView"/> method.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
    <listitem>
    <para>
      The interpreter does not wait for the return from the event handler, so the return has no meaning. Good practice would
      be to return a value anyway. 0 makes a good return value.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Delete Event Handler -->


<section id="evtTreeViewENDEDIT" xreflabel="ENDEDIT"><title>EndEdit Event Handler</title>
<indexterm><primary>TreeView class</primary><secondary>events</secondary><tertiary>ENDEDIT</tertiary></indexterm>
<para>
  The event handler for the ENDEDIT event is invoked when the user finishes a label editing operation on an item of the
  tree-view. A label editing operation is only available when the tree-view has the <xref linkend="styTreeViewEDIT"/> style.
</para>
<para>
  In general, the programmer would connect both the <xref linkend="evtTreeViewBEGINEDIT"/> and ENDEDIT notifications. Both of
  these event notifications have been enhanced since the original ooDialog implementation. If the <emphasis
  role="italic">willReply</emphasis> argument to the <xref linkend="mthConnectTreeViewEvent"/> method is omitted the old
  implementation is used. If the argument is not omitted, the new implementation is used. How the two event handlers work is
  described separately below.
</para>

<variablelist>
  <varlistentry><term><emphasis role="bold">New event handler description:</emphasis></term>
  <listitem>
    <para>
      The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectTreeViewEvent"/>
      method determines how the event handler needs to respond to the notification.
    </para>

    <programlisting>
    <![CDATA[
    ::method onEndEdit unguarded
      use arg id, hItem, text, treeViewCtrl, itemData

      return trueOrFalse
    ]]>
    </programlisting>

    <variablelist>
      <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
      <listitem>
      <para>
        The event handling method receives 5 arguments:
      </para>
      <variablelist>
        <varlistentry><term>id</term>
        <listitem>
        <para>
          The resource id of the tree-view sending the notification.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>hItem</term>
        <listitem>
        <para>
          The item handle of the tree-view item that was edited by the user.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>text</term>
        <listitem>
        <para>
          If the user canceled the edit operation then the <emphasis role="italic">text</emphasis> argument will be the .nil
          object. If the edit operation was not canceled then this argument will be the text the user entered.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>treeViewCtrl</term>
        <listitem>
        <para>
          The Rexx tree-view object whose underlying tree-view control has sent the notification. This is a convenience for
          the programmer. It is the same Rexx object the programmer would receive through the <xref
          linkend="mthNewTreeView"/> method.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>itemData</term>
        <listitem>
        <para>
          The item <link linkend="mthSetItemDataClsTreeView">data</link> object assigned to the tree-view item whose label
          was edited. If no item data has been assigned, this argument will be the <computeroutput>.nil</computeroutput>
          object.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
      <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
      <listitem>
      <para>
        When the programmer used true for the <emphasis role="italic">willReply</emphasis> argument, the event handler must
        return true or false. To accept the edited text, return true. To disallow the change to the label, return false.
        If, the edit operation was canceled by the user, the operating system ignores the return from the event handler.
        Returning a value from the event handler gives the programmer the option of determining if the new label for the
        specific tree-view item is acceptable.
      </para>
      </listitem></varlistentry>
      <varlistentry><term><emphasis role="bold">Example</emphasis></term>
      <listitem>
      <para>
        The following example checks the new text entered by the user. The label for each tree-view item is a part number.
        If the user's text is not a valid part number, the new text is rejected by returning false:

<programlisting>
<![CDATA[

::method onEndEdit unguarded
  use arg id, hItem, text, treeViewCtrl, itemData

  if text == .nil then return .false

  if self~isValidPart(text) then do
    reply .true

    rec = itemData
    oldPartNo = rec~partNo
    rec~partNo = text
    self~updateRecord(oldPartNo, rec)

    return
  end

  reply .false

  msg = text "is not a valid part number." || .endOfLine~copies(2 || -
        "The change is rejected."

  title = "Label Editing Error"
  j = MessageDialog(msg, self~hwnd, title, , "WARNING")

  return

]]>
</programlisting>
      </para>
      </listitem></varlistentry>
    </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Old event handler description:</emphasis></term>
  <listitem>
  <para>
    The old style event notification is used when the programmer omits the <emphasis role="italic">willReply</emphasis>
    argument in the invocation of the <xref linkend="mthConnectTreeViewEvent"/> method. The return from the event handler is
    completely ignored, the interpreter does not wait for this return. If the user canceled the edit operation, the label
    will be unchanged. If the user did not cancel the edit operation, the label of the item is changed to the text the user
    entered.
  </para>

  <programlisting>
  <![CDATA[
  ::method onEndEdit unguarded
    use arg id, hItem, maybeText
  ]]>
  </programlisting>

  <variablelist>
    <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
    <listitem>
    <para>
      The event handling method receives 3 arguments:
    </para>
    <variablelist>
      <varlistentry><term>id</term>
      <listitem>
      <para>
        The resource id of the tree-view sending the notification.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>hItem</term>
      <listitem>
      <para>
        The handle of the tree-view item that was edited.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>text [optional]</term>
      <listitem>
      <para>
        If the user canceled the edit operation, the <emphasis role="italic">text</emphasis> argument is omitted. If the user
        did not cancel, then the <emphasis role="italic">text</emphasis> argument is the text the user entered.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
    <listitem>
    <para>
      Returning, or not returning, a value has no meaning. The interpreter does not wait for the return and its value, if any
      is discarded.
    </para>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Remarks</emphasis></term>
    <listitem>
    <para>
      When the user does not cancel the edit operation, the operating system automatically changes the label of the item to
      what the user entered. To prevent this behavior, the programmer needs to use the new style event handler by using the
      <emphasis role="italic">willReply</emphasis> argument to the <xref linkend="mthConnectTreeViewEvent"/> method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End EndEdit Event Handler -->


<section id="evtTreeViewEXPANDED" xreflabel="EXPANDED"><title>Expanded Event Handler</title>
<indexterm><primary>TreeView class</primary><secondary>events</secondary><tertiary>EXPANDED</tertiary></indexterm>
<para>
  The event handler for the EXPANDED event is invoked after a tree-view item has been expanded or collapsed.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectTreeViewEvent"/>
  method determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onExpanded unguarded
  use arg id, hItem, what, extra, treeView, notifyCode

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 6 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the tree-view control sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hItem</term>
    <listitem>
    <para>
      The handle of the tree-view item that expanded or collapsed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>what</term>
    <listitem>
    <para>
      A string that indicates whether the item was expanded or collapsed. The string will be either <emphasis
      role="italic">EXPANDED</emphasis> or <emphasis role="italic">COLLAPSED</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>extra</term>
    <listitem>
    <para>
      The <emphasis role="italic">extra</emphasis> arugment will usually be the empty string. The Microsoft documentation
      seems to indicate that when an item is expanded, the action may be expanded partial and when the action is collapsed,
      it may be collapsed and reset. If expanded partial is detected, the <emphasis role="italic">extra</emphasis> argument
      will be <emphasis role="italic">PARTIAL</emphasis>. If collapse and reset is detected, the <emphasis
      role="italic">extra</emphasis> argument will be <emphasis role="italic">RESET</emphasis>. However, in testing, neither
      of these 2 actions were ever detected and the Microsoft documentation is unclear here. It may be that the <emphasis
      role="italic">extra</emphasis> argument will always be the empty string.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>treeView</term>
    <listitem>
    <para>
      The Rexx tree-view object whose underlying tree-view control has sent the notification. This is a convenience for
      the programmer. It is the same Rexx object the programmer would receive through the <xref linkend="mthNewTreeView"/>
      method.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>notifyCode</term>
    <listitem>
    <para>
      The numeric notification code of the event that caused the notification to be sent.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The return from the EXPANDED event handler is ignored by the operating system, any value can be returned. 0 makes a good
    return value.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The event handlers for both the EXPANDED and the <xref linkend="evtTreeViewEXPANDING"/> events are similar and are sent
    the same arguments. It is possible to connect both events to the same event handler and use the 6th <emphasis
    role="italic">notifyCode</emphasis> to determine which event caused the event handler to be invoked.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example displays the expanded or collapsed action that has just happened:

<programlisting>
<![CDATA[

::method onExpanded unguarded
  use arg id, item, what, extra, treeView, notifyCode
  say "The item with handle" item "has been" what

  return 0

/*
  Possible output:

  The item with handle 0x00000000001AD3E0 has been COLLAPSED
*/

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Expanded Event Handler -->


<section id="evtTreeViewEXPANDING" xreflabel="EXPANDING"><title>Expanding Event Handler</title>
<indexterm><primary>TreeView class</primary><secondary>events</secondary><tertiary>EXPANDING</tertiary></indexterm>
<para>
  The event handler for the EXPANDING event is invoked <emphasis role="italic">before</emphasis> a tree-view item is
  going to be expanded or collapsed.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectTreeViewEvent"/>
  method determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onExpanding unguarded
  use arg id, hItem, what, extra, treeView, notifyCode

  return trueOrFalse
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 6 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the tree-view control sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hItem</term>
    <listitem>
    <para>
      The handle of the tree-view item that is about to expand or collapse.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>what</term>
    <listitem>
    <para>
      A string that indicates whether the item is going to expand or collapsed. The string will be either <emphasis
      role="italic">EXPANDED</emphasis> or <emphasis role="italic">COLLAPSED</emphasis>.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>extra</term>
    <listitem>
    <para>
      The <emphasis role="italic">extra</emphasis> arugment will usually be the empty string. The Microsoft documentation
      seems to indicate that when an item is going to expand, the action may be expanded partial and when the action is
      collapsed, it may be collapsed and reset. If expanded partial is detected, the <emphasis role="italic">extra</emphasis>
      argument will be <emphasis role="italic">PARTIAL</emphasis>. If collapse and reset is detected, the <emphasis
      role="italic">extra</emphasis> argument will be <emphasis role="italic">RESET</emphasis>. However, in testing, neither
      of these 2 actions were ever detected and the Microsoft documentation is unclear here. It may be that the <emphasis
      role="italic">extra</emphasis> argument will always be the empty string.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>treeView</term>
    <listitem>
    <para>
      The Rexx tree-view object whose underlying tree-view control has sent the notification. This is a convenience for
      the programmer. It is the same Rexx object the programmer would receive through the <xref linkend="mthNewTreeView"/>
      method.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>notifyCode</term>
    <listitem>
    <para>
      The numeric notification code of the event that caused the notification to be sent.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    If the programmer used the <emphasis role="italic">willReply</emphasis> argument with a true value, the event handler
    must return true or false. This allows the application to control the expansion or collapse of the tree-view items.
  </para>
  <para>
    Returning true, allows the expansion or collapse to happen. Returning false prevents the expansion or collapse. If the
    <emphasis role="italic">willReply</emphasis> argument was false, SYNC or omitted, the application can not control the
    action. Expansion or collapse is always allowed. The event handler can return any value, or not return a value at all.
    Good practice would be to always return a value from an event handler.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The event handlers for both the EXPANDING and the <xref linkend="evtTreeViewEXPANDED"/> events are similar and are sent
    the same arguments. It is possible to connect both events to the same event handler and use the 6th <emphasis
    role="italic">notifyCode</emphasis> to determine which event caused the event handler to be invoked.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example allows the expansion or collapse to continue and simply prints out what is about to happen:

<programlisting>
<![CDATA[

::method onExpanding unguarded
  use arg id, item, what, extra, rxTv, notifyCode
  say "Item with handle" item "is going to be" what

  return .true

  /*
    Possible output:

    Item with handle 0x00000000001AD680 is going to be EXPANDED
  */

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End Expanding Event Handler -->


<section id="evtTreeViewGETINFOTIP" xreflabel="GETINFOTIP"><title>GetInfoTip Event Handler</title>
<indexterm><primary>TreeView class</primary><secondary>events</secondary><tertiary>GETINFOTIP</tertiary></indexterm>
<para>
  The event handler method connected to the get info tip event is invoked when the tree-view control requests the text to
  display in the info tip. The programmer must return a string value and the interpreter waits for this return. The <emphasis
  role="italic">willRepy</emphasis> argument of the <link linkend="mthConnectTreeViewEvent">connectTreeViewEvent</link>
  method is ignored for this event. The event handler must always return a value.
</para>

<programlisting>
<![CDATA[
::method onGetInfoTip unguarded
  use arg id, hItem, text, maxLen, itemData, rxTv

  return infoText
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 6 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the tree-view control requesting the info tip text.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hItem</term>
    <listitem>
    <para>
      The handle of the tree-view item that the info tip is for.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>text</term>
    <listitem>
    <para>
      The current text the tree-view intends to display. Note that most often this is the empty string. However, in some
      cases it might not be the empty string. Microsoft suggests that if <emphasis role="italic">text</emphasis> is not the
      empty string, the application should append its text to the end of the string.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>maxLen</term>
    <listitem>
    <para>
      The maximum length of the string that will be displayed. The programmer should not assume what this length is. However,
      testing shows that it is usually 1023. If the returned text is longer than the <emphasis
      role="italic">maxLen</emphasis> value, the text will automatically be truncated to <emphasis
      role="italic">maxLen</emphasis> characters.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>itemData</term>
    <listitem>
    <para>
      The item <link linkend="mthSetItemDataClsTreeView">data</link> associated with the tree-view item that the info tip is
      for. If no item data has been associated with the item, then this argument will be the
      <computeroutput>.nil</computeroutput> object.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>rxTv</term>
    <listitem>
    <para>
      The Rexx tree-view object whose underlying tree-view control has sent the notification. This is a convenience for
      the programmer. It is the same Rexx object the programmer would receive through the <xref linkend="mthNewTreeView"/>
      method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    The event handler must return a string value. If the returned string is not the empty string, it will be displayed as the
    info tip. If the empty string is returned, then the previous value of <emphasis role="italic">text</emphasis> is
    displayed. That is, if <emphasis role="italic">text</emphasis> is the empty string, no info tip will be shown. However,
    if <emphasis role="italic">text</emphasis> is not the empty string, that text will be displayed unchanged.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    In the following example, the item data associated with the tree-view item that the info tip is for, is inspected to see
    if it is the string: '...'  If it is, then a info tip is displayed, otherwise no tip is displayed.

<programlisting>
<![CDATA[

::method onGetInfoTip unguarded
    expose tv
    use arg id, hItem, text, maxLen, itemData

    if itemData == '...' then return 'There are too many books to list'
    else return ''
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End GetInfoTip Event Handler -->


<section id="evtTreeViewKEYDOWN" xreflabel="KEYDOWN"><title>KeyDown Event Handler</title>
<indexterm><primary>TreeView class</primary><secondary>events</secondary><tertiary>KEYDOWN</tertiary></indexterm>
<para>
  The event handler for the key down event is invoked when the user types a key when the tree-view control has the keyboard
  focus. The event handler is similar to the event handler for the <link linkend="evtTreeViewKEYDOWNEX">KEYDOWNEX</link>
  event, it is invoked for the same event. However, when the KEYDOWN keyword is use, the event handler receives fewer
  arguments than when the KEYDOWNEX key word is used.
</para>
<para>
  The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectTreeViewEvent"/>
  method determines how the event handler needs to respond to the notification.
</para>

<programlisting>
<![CDATA[
::method onKeyDown unguarded
  use arg id, vKey, rxTv

  return 0
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 3 arguments:
  </para>
  <variablelist>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the tree-view control sending the notification.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>vKey</term>
    <listitem>
    <para>
      The virtual key code of the key typed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>rxTv</term>
    <listitem>
    <para>
      The Rexx tree-view object whose underlying tree-view control has sent the notification. This is a convenience for
      the programmer. It is the same Rexx object the programmer would receive through the <xref linkend="mthNewTreeView"/>
      method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    Using the KEYDOWN event keyword, as opposed to using the KEYDOWNEX keyword, causes the ooDialog framework to use the
    original ooDialog implementation. In the original implementation, the return from an event handler was ignored. Returning
    a value from the KEYDOWN event handler has no effect. So no return is required. However, good practice would be to always
    return a value from an event handler. See the <xref linkend="evtTreeViewKEYDOWNEX"/> event handler for a discussion of
    what the operating system expects from a key down event handler.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The <xref linkend="clsVK"/> class can be used to determine which virtual key was pressed.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example simply displays on the screen the key typed by the user:

<programlisting>
<![CDATA[

::method onKeyDown unguarded
  use arg id, vkey
  say "Key" .VK~name2key(vkey) "was pressed."

  return 0

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End KeyDown Event Handler -->


<section id="evtTreeViewKEYDOWNEX" xreflabel="KEYDOWNEX"><title>KeyDown (extended) Event Handler</title>
<indexterm><primary>TreeView class</primary><secondary>events</secondary><tertiary>KEYDOWNEX</tertiary></indexterm>
<para>
  The event-handling method connected through the KEYDOWNEX keyword is similar to the event handler for the KEYDOWN event
  handler. It is invoked for the same event, when the user presses a key within the tree-view. However, it receives a
  different set of arguments than that provided when the KEYDOWN keyword is used.
</para>

<programlisting>
<![CDATA[
::method onKeyDownEx unguarded
  use arg vKey, isShift, isCtrl, isAlt, extraInfo, treeViewObj

  return response
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Event Handler Method Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 6 arguments:
  </para>
  <variablelist>
    <varlistentry><term>vKey</term>
    <listitem>
    <para>
      The virtual key code of of the key pressed. The <xref linkend="clsVK"/> class can be used to determine which key was
      pressed.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>isShift</term>
    <listitem>
    <para>
      A boolean (true or false) that denotes whether a shift key was down or up at the time of the key press. It will
      be true if a shift key was down and false if the shift key was not down.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>isCtrl</term>
    <listitem>
    <para>
      True if a control key was down at the time of the key press, false if it was not.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>isAlt</term>
    <listitem>
    <para>
      True if an alt key was down at the time of the key press, false if it was not.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>extraInfo</term>
    <listitem>
    <para>
      This argument is a string containing keywords.  It supplies extra information about the keyboard state at the
      time of a key press event. The string may be the empty string, otherwise it will contain some combination of these
      keywords:
      <variablelist>
        <varlistentry><term>extended</term>
        <listitem>
        <para>
          The key down event is for one of the extended keys.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>numOn</term>
        <listitem>
        <para>
          Num Lock was on at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>numOff</term>
        <listitem>
        <para>
          Num Lock was off.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>capsOn</term>
        <listitem>
        <para>
          Caps Lock was on at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>capsOff</term>
        <listitem>
        <para>
          Caps Lock was off.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>scrollOn</term>
        <listitem>
        <para>
          Scroll Lock was on at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>scrollOff</term>
        <listitem>
        <para>
          Scroll Lock was off.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>lShift</term>
        <listitem>
        <para>
          The left shift key was down at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>rShift</term>
        <listitem>
        <para>
          The right shift key was down.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>lControl</term>
        <listitem>
        <para>
          The left control key was down at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>rControl</term>
        <listitem>
        <para>
          The right control key was down.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>lAlt</term>
        <listitem>
        <para>
          The left alt key was down at the time of the key press event.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>rAlt</term>
        <listitem>
        <para>
          The right alt key was down.
        </para>
        </listitem></varlistentry>
      </variablelist>
    </para>
    </listitem></varlistentry>
    <varlistentry><term>treeViewObj</term>
    <listitem>
    <para>
      The Rexx <computeroutput>TreeView</computeroutput> object whose underlying Windows tree-view had the key down event.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>

  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    When the <emphasis role="italic">willReply</emphasis> argument to the <link
    linkend="mthConnectTreeViewEvent">connectTreeViewEvent</link> method is true, the event handler must return a value.
  </para>
  <para>
    If the key pressed was a character key, the character is used as part of an incremental search. The event handler returns
    true to allow the character to be added to the incremental search and false to prevent the character from being added. If
    the key pressed was not a character key, then the return is ignored by the operating system. 0 makes a good return when
    the operating system ignores the return value.
  </para>
  <para>
    If <emphasis role="italic">willReply</emphasis> was omitted, false, or SYNC, the event handler does not <emphasis
    role="italic">have</emphasis> to return a value, but good practice would be to always return a value from an event
    handler.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example allows the user to type Ctrl-Ins (control insert) to add a new item to the tree view:

<programlisting>
<![CDATA[

::method onKeyDownEx unguarded
    use arg vKey, isShift, isCtrl, isAlt, extraInfo, treeViewObj

    if vKey == .VK~INSERT, isCtrl then do
        reply .false

        self~addNewItem(treeViewObj)
        return
    end

    return .true
]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End KeyDownEx Event Handler -->


<section id="evtTreeViewSELCHANGED" xreflabel="SELCHANGED"><title>SelChanged Event Handler</title>
<indexterm><primary>TreeView class</primary><secondary>events</secondary><tertiary>SELCHANGED</tertiary></indexterm>
<para>
  The event handler for the selection changed event is invoked when the selection has changed from one item to another.
</para>
<para>
  This event notification has been enhanced since the original ooDialog implementation. If the <emphasis
  role="italic">willReply</emphasis> argument to the <xref linkend="mthConnectTreeViewEvent"/> method is omitted the old
  implementation is used. If the argument is not omitted, the new implementation is used. How the two event handlers work is
  described separately below:
</para>

<variablelist>
  <varlistentry><term><emphasis role="bold">New event handler description:</emphasis></term>
  <listitem>
    <para>
      Whether the programmer must return a value and if the interpreter waits, or does not wait, for this return is
      determined by the value of the <emphasis role="italic">willReply</emphasis> argument. If <emphasis
      role="italic">willReply</emphasis> is true, the programmer must return a value from the event handler and the
      interpreter waits for that reply. If <emphasis role="italic">willReply</emphasis> is false the interpreter does not
      wait for a reply. If <emphasis role="italic">willReply</emphasis> was SYNC, the interpreter waits for the reply, but
      the actual value of the reply is disregarded.
    </para>

    <programlisting>
    <![CDATA[
    ::method onSelChanged unguarded
      use arg id, hItemOld, userOld, hItemNew, userNew, action, rxTv, nCode

      return 0
    ]]>
    </programlisting>

    <variablelist>
      <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
      <listitem>
      <para>
        The event handling method receives 8 arguments:
      </para>
      <variablelist>
        <varlistentry><term>id</term>
        <listitem>
        <para>
          The resource id of the tree-view sending the notification.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>hItemOld</term>
        <listitem>
        <para>
          The handle of the tree-view item handle that has lost the selction. This may be 0 if no item had the selection.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>userOld</term>
        <listitem>
        <para>
          The user <link linkend="mthSetItemDataClsTreeView">data</link> object assigned to the tree-view item that lost the
          selection. If no item data has been assigned to that item, of if <emphasis role="italic">hItemOld</emphasis> is 0,
          this argument will be the <computeroutput>.nil</computeroutput> object.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>hItemNew</term>
        <listitem>
        <para>
          The handle of the tree-view item handle that gained the selction.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>userNew</term>
        <listitem>
        <para>
          The user <link linkend="mthSetItemDataClsTreeView">data</link> object assigned to the tree-view item that gained
          the selection. If no item data has been assigned to that item, this argument will be the
          <computeroutput>.nil</computeroutput> object.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>action</term>
        <listitem>
        <para>
          A keyword that indicates the type of action that caused the selection to change. This will be one of the following
          keywords:
        </para>
        <para>
          <simplelist type='vert' columns='3'>
            <member>KEYBOARD  </member>
            <member>MOUSECLICK</member>
            <member>UNKNOWN   </member>
          </simplelist>
          <variablelist>
            <varlistentry><term>KEYBOARD</term>
            <listitem>
            <para>
              By a keystroke.
            </para>
            </listitem></varlistentry>
            <varlistentry><term>MOUSECLICK</term>
            <listitem>
            <para>
              By a mouseclick.
            </para>
            </listitem></varlistentry>
            <varlistentry><term>UNKNOWN</term>
            <listitem>
            <para>
              Unknown.
            </para>
            </listitem></varlistentry>
          </variablelist>
        </para>
        </listitem></varlistentry>
        <varlistentry><term>rxTv</term>
        <listitem>
        <para>
          The Rexx tree-view object whose underlying tree-view control has sent the notification. This is a convenience for
          the programmer. It is the same Rexx object the programmer would receive through the <xref
          linkend="mthNewTreeView"/> method.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>nCode</term>
        <listitem>
        <para>
          The numeric notification code of the event that caused the notification to be sent. Each dialog control has its own
          specific notification codes.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
      <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
      <listitem>
      <para>
        The operarting system ignores the returned value for this event notification. In these cases, 0 makes a good return.
        Good practice would be to always return a value from an event handler.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Old event handler description:</emphasis></term>
  <listitem>
  <para>
    The old style event notification is used when the programmer omits the <emphasis role="italic">willReply</emphasis>
    argument in the invocation of the <xref linkend="mthConnectTreeViewEvent"/> method. The return from the event handler is
    completely ignored, the interpreter does not wait for this return.
  </para>

  <programlisting>
  <![CDATA[
  ::method onSelChanged unguarded
    use arg id, useLess, rxTv, nCode
  ]]>
  </programlisting>

  <variablelist>
    <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
    <listitem>
    <para>
      The event handling method receives 4 arguments:
    </para>
    <variablelist>
      <varlistentry><term>id</term>
      <listitem>
      <para>
        The resource id of the tree-view sending the notification.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>useLess</term>
      <listitem>
      <para>
        This argument is a number that has no meaning within the Rexx code. It is the value the old implementation of the
        event notification sent to the event handler.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>rxTv</term>
      <listitem>
      <para>
        The Rexx <computeroutput>TreeView</computeroutput> object whose underlying Windows tree-view sent the selection
        changed notification.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>nCode</term>
      <listitem>
      <para>
        The numeric notification code of the event that caused the notification to be sent. Each dialog control has its own
        specific notification codes.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
    <listitem>
    <para>
      The operating system ignores the returned value from this notification. Good practice would be to always return a value
      from any event handler. 0 is a good value for cases where the operating system ignores the returned value.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The event handlers for both the SELCHANGED and the <xref linkend="evtTreeViewSELCHANGING"/> events are similar and are
    sent the same arguments. It is possible to connect both events to the same event handler and use the <emphasis
    role="italic">nCode</emphasis> argument to determine which event caused the event handler to be invoked.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End SELCHANGED Event Handler -->


<section id="evtTreeViewSELCHANGING" xreflabel="SELCHANGING"><title>SelChanging Event Handler</title>
<indexterm><primary>TreeView class</primary><secondary>events</secondary><tertiary>SELCHANGING</tertiary></indexterm>
<para>
  The event handler for the CHANGING event is invoked when the selection is about to change from one item to another. The
  notification is sent before the change is made.
</para>
<para>
  This event notification has been enhanced since the original ooDialog implementation. If the <emphasis
  role="italic">willReply</emphasis> argument to the <xref linkend="mthConnectTreeViewEvent"/> method is omitted the old
  implementation is used. If the argument is not omitted, the new implementation is used. Replying to the notification gives
  the programmer the opportunity to cancel the change in selection. How the two event handlers work is described separately
  below:
</para>

<variablelist>
  <varlistentry><term><emphasis role="bold">New event handler description:</emphasis></term>
  <listitem>
  <para>
    The <link linkend="sctCommonWillReply">willReply</link> argument in the <xref linkend="mthConnectTreeViewEvent"/>
    method determines how the event handler needs to respond to the notification. Replying to this notification gives the
    application the opportunity to cancel the selection change
  </para>

<programlisting>
<![CDATA[
::method onSelChanging unguarded
  use arg id, hItemOld, userOld, hItemNew, userNew, action, rxTv, nCode

  return trueOrFalse
]]>
</programlisting>

    <variablelist>
      <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
      <listitem>
      <para>
        The event handling method receives 8 arguments:
      </para>
      <variablelist>
        <varlistentry><term>id</term>
        <listitem>
        <para>
          The resource id of the tree-view sending the notification.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>hItemOld</term>
        <listitem>
        <para>
          The handle of the tree-view item handle that is about to lose the selction. This may be 0 if no item has the
          selection.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>userOld</term>
        <listitem>
        <para>
          The user <link linkend="mthSetItemDataClsTreeView">data</link> object assigned to the tree-view item that is about
          to lose the selection. If no item data has been assigned to that item, of if <emphasis
          role="italic">hItemOld</emphasis> is 0, this argument will be the <computeroutput>.nil</computeroutput> object.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>hItemNew</term>
        <listitem>
        <para>
          The handle of the tree-view item handle that will gain the selction.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>userNew</term>
        <listitem>
        <para>
          The user <link linkend="mthSetItemDataClsTreeView">data</link> object assigned to the tree-view item that will
          gain the selection. If no item data has been assigned to that item, this argument will be the
          <computeroutput>.nil</computeroutput> object.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>action</term>
        <listitem>
        <para>
          A keyword that indicates the type of action that will cause the selection to change. This will be one of the
          following keywords:
        </para>
        <para>
          <simplelist type='vert' columns='3'>
            <member>KEYBOARD  </member>
            <member>MOUSECLICK</member>
            <member>UNKNOWN   </member>
          </simplelist>
          <variablelist>
            <varlistentry><term>KEYBOARD</term>
            <listitem>
            <para>
              By a keystroke.
            </para>
            </listitem></varlistentry>
            <varlistentry><term>MOUSECLICK</term>
            <listitem>
            <para>
              By a mouseclick.
            </para>
            </listitem></varlistentry>
            <varlistentry><term>UNKNOWN</term>
            <listitem>
            <para>
              Unknown.
            </para>
            </listitem></varlistentry>
          </variablelist>
        </para>
        </listitem></varlistentry>
        <varlistentry><term>rxTv</term>
        <listitem>
        <para>
          The Rexx tree-view object whose underlying tree-view control has sent the notification. This is a convenience for
          the programmer. It is the same Rexx object the programmer would receive through the <xref
          linkend="mthNewTreeView"/> method.
        </para>
        </listitem></varlistentry>
        <varlistentry><term>nCode</term>
        <listitem>
        <para>
          The numeric notification code of the event that caused the notification to be sent. Each dialog control has its own
          specific notification codes.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
      <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
      <listitem>
      <para>
        When the programmer used true for the <emphasis role="italic">willReply</emphasis> argument, the event handler must
        return true or false. Return true to allow the selection change. Return false to cancel the selection change.
      </para>
      <para>
        Otherwise, the interpreter does not pass the returned value on to the operating system, and the event handler is not
        required to return a value. However, good practice would probably be to always return a value from an event handler.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Old event handler description:</emphasis></term>
  <listitem>
  <para>
    The old style event notification is used when the programmer omits the <emphasis role="italic">willReply</emphasis>
    argument in the invocation of the <xref linkend="mthConnectTreeViewEvent"/> method. The return from the event handler is
    completely ignored, the interpreter does not wait for this return.
  </para>

  <programlisting>
  <![CDATA[
  ::method onSelChanging unguarded
    use arg id lParam, rxTv, nCode
  ]]>
  </programlisting>

  <variablelist>
    <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
    <listitem>
    <para>
      The event handling method receives 4 arguments:
    </para>
    <variablelist>
      <varlistentry><term>id</term>
      <listitem>
      <para>
        The resource id of the tree-view sending the notification.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>lParam</term>
      <listitem>
      <para>
        This argument is a number that has no meaning within the Rexx code. It is the value the old implementation of the
        event notification sent to the event handler.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>rxTv</term>
      <listitem>
      <para>
        The Rexx tree-view object whose underlying tree-view control has sent the notification. This is a convenience for
        the programmer. It is the same Rexx object the programmer would receive through the <xref
        linkend="mthNewTreeView"/> method.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>nCode</term>
      <listitem>
      <para>
        The numeric notification code of the event that caused the notification to be sent. Each dialog control has its own
        specific notification codes.
      </para>
      </listitem></varlistentry>
    </variablelist>
    </listitem></varlistentry>
    <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
    <listitem>
    <para>
      The interpreter does not wait for the return from the event handler, so the return has no meaning. Good practice would
      be to return a value anyway.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    The event handlers for both the SELCHANGING and the <xref linkend="evtTreeViewSELCHANGED"/> events are similar and are
    sent the same arguments. It is possible to connect both events to the same event handler and use the <emphasis
    role="italic">nCode</emphasis> argument to determine which event caused the event handler to be invoked.
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End SELCHANGING Event Handler -->


</section>  <!-- End EventNotification::connectTreeViewEvent() -->


<section id="mthConnectUpDownEvent" xreflabel="connectUpDownEvent"><title>connectUpDownEvent</title>
<indexterm><primary>connectUpDownEvent</primary></indexterm>
<indexterm><primary>dialog object</primary><secondary>connectUpDownEvent</secondary></indexterm>
<indexterm><primary>EventNotification class</primary><secondary>connectUpDownEvent</secondary></indexterm>
<programlisting>
<![CDATA[
>>--connectUpDownEvent(--id--,--event--+---------------+--+-------------+--)---><
                                       +-,-methodName--+  +-,-willReply-+
]]>
</programlisting>

<para>
  The <emphasis role="italic">connectUpDownEvent</emphasis> method connects an <xref linkend="ovvEvents"/>
  notification message from an <xref linkend="clsUpDown"/> control to a method in the Rexx dialog.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The arguments are:
    <variablelist>
      <varlistentry><term>id [required]</term>
      <listitem>
      <para>
        The resource ID of the up-down control whose notification message is to be connected to a Rexx dialog's method.
        May be numeric or <xref linkend="defSymbolicId"/>.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>event [required]</term>
      <listitem>
      <para>
        Exactly one of the following keywords. The keyword specifies the event to be connected and case is not
        significant. Unlike most controls, the up-down control only has one event notification.
      </para>
      <variablelist>
        <varlistentry><term><xref linkend="evtUpDownDELTAPOS"/></term>
        <listitem>
        <para>
           Sent when the position of the control is about to change. This happens when the user requests a change in the
           value by pressing the control's up or down arrow. The event handler must
           <link linkend="sctCodingEventHandlers">return</link> a reply for this event. The interpreter waits for that reply.
        </para>
        <para>
          The DELTAPOS notification is sent before the scroll message which actually changes the control's position.
          This allows the programmer to examine, allow, modify, or disallow the change in position.
        </para>
        </listitem></varlistentry>
      </variablelist>
      </listitem></varlistentry>
      <varlistentry><term>methodName [optional]</term>
      <listitem>
      <para>
        The name of the method that is to be invoked whenever the specified notification is received from the up-down
        control. The programmer defines this method. If this argument is omitted, a method name is automatically
        generated that consists of the event keyword preceded by <computeroutput>on</computeroutput>. For instance,
        <computeroutput>onDeltaPos</computeroutput>. The method name can not be the empty string.
      </para>
      </listitem></varlistentry>
      <varlistentry><term>willReply [optional]</term>
      <listitem>
      <para>
        The <link linkend="sctCommonWillReply">willReply</link> argument controls how the interpreter invokes the event
        handler for the connected event. However, currently the up-down control only has one event notification and the
        operating system expects a return value from that notification. When the event is connected the <emphasis
        role="italic">willReply</emphasis> argument is ignored. The event handler for DELTAPOS must always return a delta
        postion buffer.
      </para>
      </listitem></varlistentry>
    </variablelist>
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
  <listitem>
  <para>
    Returns <computeroutput>.true</computeroutput> if the event was connected correctly, otherwise
   <computeroutput>.false</computeroutput>.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Remarks:</emphasis></term>
  <listitem>
  <para>
    See the sections on <link linkend="sctConnectingEventHandlers">connecting</link> and <link
    linkend="sctCodingEventHandlers">coding</link> event handlers for additional information on event handlers.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Details:</emphasis></term>
  <listitem>
  <para>
    Syntax errors are raised when incorrect usage is detected, including the use of an invalid symbolic ID or an
    unrecognized event keyword.
  </para>
  <para>
    If the programmer does not provide a matching method in the Rexx dialog, a syntax condition will be raised if the
    connected event happens.
  </para>
  <para>
    The underlying dialog receives the UDN_* messages as the notifications for the up-down events.
  </para>
  </listitem></varlistentry>
</variablelist>


<section id="evtUpDownDELTAPOS" xreflabel="DELTAPOS"><title>DeltaPos Event Handler</title>
<indexterm><primary>UpDown class</primary><secondary>events</secondary><tertiary>DELTAPOS</tertiary></indexterm>
<para>
  The event handler for the up-down DELTAPOS event is invoked when when the position of the control is about to change.
  The arguments the event handler receives allow the programmer to examine the proposed change in position, to modify
  the change, or to cancel the change all together.
</para>
<para>
  The programmer must return a value from the event handler and the interpreter waits for this return. The <xref
  linkend="mthDeltaPosReply"/> class method of the <xref linkend="clsUpDown"/> class is used to properly construct the return
  value from the event handler. This return value can not be manually constructed in Rexx code, so the programmer must use
  the <emphasis role="italic">deltaPosReply</emphasis> method to return a value from the event handler.
</para>

<programlisting>
<![CDATA[
::method onDeltaPos unguarded
  use arg pos, delta, id, hwnd, rxUpd

  return buffer
]]>
</programlisting>

<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
  <para>
    The event handling method receives 5arguments:
  </para>
  <variablelist>
    <varlistentry><term>pos</term>
    <listitem>
    <para>
      A signed whole number that contains the up-down control's current position.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>delta</term>
    <listitem>
    <para>
      A signed whole number that contains the proposed change in the up-down control's position. This is positive if the
      user has clicked the up button or used the up arrow key. If the user has clicked the down button or used the down
      arrow key, this number will be negative.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>id</term>
    <listitem>
    <para>
      The resource ID of the up-down control whose position is about to change.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>hwnd</term>
    <listitem>
    <para>
      The window <xref linkend="defHandle"/> of the up-down control whose position is about to change.
    </para>
    </listitem></varlistentry>
    <varlistentry><term>rxUpd</term>
    <listitem>
    <para>
      The Rexx up-down object whose underlying up-down has sent the notification. This is a convenience for the
      programmer. It is the same Rexx object the programmer would receive through the <xref linkend="mthNewUpDown"/> method.
    </para>
    </listitem></varlistentry>
  </variablelist>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Return:</emphasis></term>
  <listitem>
  <para>
    A delta position buffer must be returned by the event handler.  This buffer can only be constructed properly by
    using the <xref linkend="clsUpDown"/> class's <xref linkend="mthDeltaPosReply"/> method. The arguments to <emphasis
    role="italic">deltaPosReply</emphasis> allow the programmer to return a value that makes no change to the new position,
    cancels altogether the change in position, or modifies the resulting new position.
  </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example</emphasis></term>
  <listitem>
  <para>
    The following example examines the change in position in the up-down control and modifies it so that the position in
    the up-down control is always an even number. Note that the <emphasis role="italic">deltaPosReply</emphasis> method
    ignores the second and third arguments when the first argument is <computeroutput>.false</computeroutput>. So, in
    the code below, if <emphasis role="italic">change</emphasis> remains <computeroutput>.false</computeroutput>, then
    the values of <emphasis role="italic">cancel</emphasis> and <emphasis role="italic">delta</emphasis> do not matter.

<programlisting>
<![CDATA[

::method initDialog
...
  self~connectUpDownEvent(IDC_UPD, "DELTAPOS", onPosChange)
...

::method onPosChange unguarded
  use arg pos, delta, id, hwnd

  change = .false
  cancel = .false

  if ((pos + delta) // 2) <> 0 then do
    change = .true
    if delta > 0 then delta += 1
    else delta -= 1
  end

  return .UpDown~deltaPosReply(change, cancel, delta)

]]>
</programlisting>
  </para>
  </listitem></varlistentry>
</variablelist>

</section>  <!-- End DeltaPos Event Handler -->

</section>  <!-- End EventNotification::connectUpDownEvent() -->


<section id="mthDefListDragHandler" xreflabel="defListDragHandler"><title>defListDragHandler</title>
<indexterm><primary>defListDragHandler</primary></indexterm>
<programlisting>
<![CDATA[
>>-defListDragHandler(--id--,--item--,--point--,--isLMB--,--listView--)--------><

]]>
</programlisting>

<para>
  A list-view control does not handle a drag-and-drop operation itself. It defers that handling to the programmer by
  sending a BEGINGDRAG, (left mouse drag,) or a BEGINRDRAG, (right mouse drag,) event notification. The programmer can
  code his own <xref linkend="ovvEvents"/> handling method and use
 <xref linkend="mthConnectListViewEvent"/>() method to connect the method to the drag-and-drop
  operation.
</para>
<para>
  The <emphasis role="italic">defListDragHandler</emphasis> method is an event handling method supplied by the ooDialog
  framework and the programmer can use this method rather than code his own.
</para>
<para>
  This method implementation allows the user to drag an item from one location to another within an icon view and
  a small icon view. The cursor shape is changed to a crosshair during the drag operation. The user can cancel the drag
  operation by clicking the other mouse button while holding the button that started the drag operation. Note that the
  final icon position is not flexible when the list-view control has the AUTOARRANGE style.
</para>
<para>
  If the programmer wants to implement her own drag-and-drop event handler, she may want to examine the how the
  <emphasis role="italic">defListDragHandler</emphasis> method in the <computeroutput>ooDialog.cls</computeroutput>
  file. In addition the <computeroutput>oodListViews.rex</computeroutput> example program uses the <emphasis
  role="italic">defListDragHandler</emphasis>. Running the example program will show the behavior of the current
  <emphasis role="italic">defListDragHandler</emphasis> implementation.
</para>
<para>
  <emphasis role="bold">Example:</emphasis>
<programlisting>
<![CDATA[
::method initDialog

  ...

  self~connectListViewEvent(ID_LV_ICON, "BEGINDRAG", "defListDragHandler")
  -- The ooDialog framework now automatically handles Drag and drop operations.
]]>
</programlisting>
</para>
</section>

<section id="mthDefTreeDragHandler" xreflabel="defTreeDragHandler"><title>defTreeDragHandler</title>
<indexterm><primary>defTreeDragHandler</primary></indexterm>
<programlisting>
<![CDATA[
>>-defTreeDragHandler(--id--,--item--,--point--)----------------><

]]>
</programlisting>

<para>
  A tree view control does not handle a drag-and-drop operation itself. It defers that handling to the programmer by
  sending a BEGINGDRAG, (left mouse drag,) or a BEGINRDRAG, (right mouse drag,) event notification. The programmer can
  code his own <xref linkend="ovvEvents"/> handling method and use
 <xref linkend="mthConnectTreeViewEvent"/>() method to connect the method to the drag-and-drop
  operation.
</para>
<para>
  The <emphasis role="italic">defTreeDragHandler</emphasis> method is an event handling method supplied by the ooDialog
  framework and the programmer can use this method rather than code his own.
</para>
<para>
  This method implementation allows the user to move an item, or a node with all its subitems, from one parent node to
  another within the tree view. The cursor shape is changed to a crosshair during the drag operation. If the cursor is
  moved over the item dragged, the cursor shape is changed to a slashed circle. The user can cancel the drag operation
  by clicking the other mouse button while holding the button that started the drag operation.
</para>
<para>
  If the programmer wants to implement her own drag-and-drop event handler, she may want to examine the how the
  <emphasis role="italic">defTreeDragHandler</emphasis> method in the <computeroutput>ooDialog.cls</computeroutput>
  file. In addition both the <computeroutput>oodtree.rex</computeroutput> and
  <computeroutput>propdemo.rex</computeroutput> example programs uses the <emphasis
  role="italic">defTreeDragHandler</emphasis>. Running these example programs will show the behavior of the current
  <emphasis role="italic">defTreeDragHandler</emphasis> implementation.
</para>
<para>
  <emphasis role="bold">Example:</emphasis>
<programlisting>
<![CDATA[
::method initDialog

  ...

  self~connectTreeViewEvent("IDC_TREE","BEGINDRAG", "defTreeDragHandler")
  -- Drag and drop operations are not automatically handled.
]]>
</programlisting>
</para>
</section>

</section>
