<!--#########################################################################
    #
    # Description: Open Object Rexx: OODialog Reference SGML file.
    #
    # Copyright (c) 2005-2007, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<chapter id="clsDialogControl"><title>DialogControl Class</title>
<indexterm><primary>DialogControl class</primary></indexterm>
<para>
  The DialogControl class provides methods that are common to all dialog controls. It is a generic
  class that serves as a superclass to all dialog control specific classes.  In the graphical user
  interface (GUI) for the Windows operating system both dialogs and dialog controls are windows.
  Therefore, many of the methods of the DialogControl class are the same as the methods of the
  ooDialog dialog classes.  These are the methods that are common to all windows, whether they are
  dialog windows or dialog control windows.
</para>
<para id="paraDialogControlStyles">
  In the Windows GUI all windows are created with a set of <emphasis role="italic">window
  styles</emphasis>.  Dialog control windows are created using styles that are common to all
  windows, (for example the visible style,) and styles specific to the dialog control itself, (for
  example the multi-line style of the <link linkend="editcontrolc">EditControl</link> class.)  In
  general the styles of a control fall into three categories: Styles that can only be set when the
  control is created and then can not be changed afterwards. Styles that can be changed after
  control creation by sending messages to the control. And, styles that can be changed after the
  control is created by accessing the control window directly.
</para>
<para>
  The ooDialog programmer chooses the window styles for dialog controls when he defines the dialog,
  either by using a resource editor for dialogs defined with resource scripts or binary compiled
  resources, or by using the <link linkend="addmeth">Add... Methods</link> for a user dialog. After
  the dialog control has been created, the individual dialog control classes provide methods to
  change those styles that can be changed, either by sending the proper message to the control or by
  accessing the control window directly.
</para>
<variablelist>
<varlistentry><term>Requires:</term>
<listitem>
<para>
  The DialogControl class requires the class definition file
  <computeroutput>oodwin32.cls</computeroutput>:
<programlisting>
<![CDATA[
::requires oodwin32.cls
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>Attributes:</term>
<listitem><para>Instances of the DialogControl class have the following
attributes:
<variablelist>
<varlistentry><term>FactorX</term>
<listitem><para>The horizontal size of one dialog unit, in pixels.
</para></listitem></varlistentry>
<varlistentry><term>FactorY</term>
<listitem><para>The vertical size of one dialog unit, in pixels.
</para></listitem></varlistentry>
<varlistentry><term>SizeX</term>
<listitem><para>The width of the dialog control, in dialog units, when the
ooRexx object that represents the control is created.</para>
<para><emphasis role="bold">Note: </emphasis>
The <computeroutput>SizeX</computeroutput> attribute is not changed by ooDialog
after the object is instantiated.  If the programmer resizes the dialog control
manually, and requires that the value of the attribute be correct, then the
programmer would need to update the value herself.
</para></listitem></varlistentry>
<varlistentry><term>SizeY</term>
<listitem><para>The height of the dialog control, in dialog units, when the
ooRexx object that represents the control is created.</para>
<para><emphasis role="bold">Note: </emphasis>
The <computeroutput>SizeY</computeroutput> attribute is not changed by ooDialog
after the object is instantiated.  If the programmer resizes the dialog control
manually, the programmer would also need to update the value of this attribute
herself, if she requires that the value remain correct.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>Methods:</term>
<listitem><para>Instances of the DialogControl class implement the methods
listed in the following DialogControl Instance Methods table.
<table id="tdialogclass" frame="all">
<title>DialogControl Instance Methods</title>
<tgroup cols="2">
<thead>
<row>
<entry>Method...</entry>
<entry>...on page</entry>
</row>
</thead>
<tbody>
<row>
<entry>AbsRect2LogRect</entry>
<entry><link linkend="absrect2logrect">AbsRect2LogRect</link></entry>
</row>
<row>
<entry>AssignFocus</entry>
<entry><link linkend="assignfocus">AssignFocus</link></entry>
</row>
<row>
<entry>AssignWindow</entry>
<entry><link linkend="assignwindow">AssignWindow</link></entry>
</row>
<row>
<entry>CaptureMouse</entry>
<entry><link linkend="capturemouse">CaptureMouse</link></entry>
</row>
<row>
<entry>Clear</entry>
<entry><link linkend="clear">Clear</link></entry>
</row>
<row>
<entry>ClearRect</entry>
<entry><link linkend="clearrect">ClearRect</link></entry>
</row>
<row>
<entry>ClientToScreen</entry>
<entry><link linkend="clienttoscreen">ClientToScreen</link></entry>
</row>
<row>
<entry>ConnectFKeyPress</entry>
<entry><link linkend="mthConnectFKeyPressDialogControl">ConnectFKeyPress</link></entry>
</row>
<row>
<entry>ConnectKeyPress</entry>
<entry><link linkend="mthConnectKeyPressDialogControl">ConnectKeyPress</link></entry>
</row>
<row>
<entry>CreateBrush</entry>
<entry><link linkend="h001026">CreateBrush</link></entry>
</row>
<row>
<entry>CreateFont</entry>
<entry><link linkend="createfont">CreateFont</link></entry>
</row>
<row>
<entry>CreatePen</entry>
<entry><link linkend="h001035">CreatePen</link></entry>
</row>
<row>
<entry>Cursor_AppStarting</entry>
<entry><link linkend="cursorappstarting">Cursor_AppStarting</link></entry>
</row>
<row>
<entry>Cursor_Arrow</entry>
<entry><link linkend="cursorarrow">Cursor_Arrow</link></entry>
</row>
<row>
<entry>Cursor_Cross</entry>
<entry><link linkend="cursorcross">Cursor_Cross</link></entry>
</row>
<row>
<entry>Cursor_No</entry>
<entry><link linkend="cursorno">Cursor_No</link></entry>
</row>
<row>
<entry>CursorPos</entry>
<entry><link linkend="cursorpos">CursorPos</link></entry>
</row>
<row>
<entry>Cursor_Wait</entry>
<entry><link linkend="cursorwait">Cursor_Wait</link></entry>
</row>
<row>
<entry>DeleteFont</entry>
<entry><link linkend="deletefont">DeleteFont</link></entry>
</row>
<row>
<entry>DeleteObject</entry>
<entry><link linkend="h001017">DeleteObject</link></entry>
</row>
<row>
<entry>Disable</entry>
<entry><link linkend="disable">Disable</link></entry>
</row>
<row>
<entry>DisconnectKeyPress</entry>
<entry><link linkend="mthDisconnectKeyPressDialogControl">DisconnectKeyPress</link></entry>
</row>
<row>
<entry>Display</entry>
<entry><link linkend="display">Display</link></entry>
</row>
<row>
<entry>Draw</entry>
<entry><link linkend="draw">Draw</link></entry>
</row>
<row>
<entry>DrawAngleArc</entry>
<entry><link linkend="h001215">DrawAngleArc</link></entry>
</row>
<row>
<entry>DrawArc</entry>
<entry><link linkend="h001212">DrawArc</link></entry>
</row>
<row>
<entry>DrawLine</entry>
<entry><link linkend="h001188">DrawLine</link></entry>
</row>
<row>
<entry>DrawPie</entry>
<entry><link linkend="h001216">DrawPie</link></entry>
</row>
<row>
<entry>DrawPixel</entry>
<entry><link linkend="h001200">DrawPixel</link></entry>
</row>
<row>
<entry>Enable</entry>
<entry><link linkend="enable">Enable</link></entry>
</row>
<row>
<entry>FillDrawing</entry>
<entry><link linkend="h001217">FillDrawing</link></entry>
</row>
<row>
<entry>FontColor</entry>
<entry><link linkend="h000997">FontColor</link></entry>
</row>
<row>
<entry>FontToDC</entry>
<entry><link linkend="h000948">FontToDC</link></entry>
</row>
<row>
<entry>ForegroundWindow</entry>
<entry><link linkend="foregroundwindow">ForegroundWindow</link></entry>
</row>
<row>
<entry>FreeDC</entry>
<entry><link linkend="freedc">FreeDC</link></entry>
</row>
<row>
<entry>GetArcDirection</entry>
<entry><link linkend="h001213">GetArcDirection</link></entry>
</row>
<row>
<entry>GetClientRect</entry>
<entry><link linkend="mthGetClientRect">GetClientRect</link></entry>
</row>
<row>
<entry>GetDC</entry>
<entry><link linkend="getdc">GetDC</link></entry>
</row>
<row>
<entry>GetFocus</entry>
<entry><link linkend="getfocus">GetFocus</link></entry>
</row>
<row>
<entry>GetID</entry>
<entry><link linkend="getid">GetID</link></entry>
</row>
<row>
<entry>GetMouseCapture</entry>
<entry><link linkend="getmousecapture">GetMouseCapture</link></entry>
</row>
<row>
<entry>GetPixel</entry>
<entry><link linkend="h001211">GetPixel</link></entry>
</row>
<row>
<entry>GetPos</entry>
<entry><link linkend="getpos">GetPos</link></entry>
</row>
<row>
<entry>GetRect</entry>
<entry><link linkend="getrect">GetRect</link></entry>
</row>
<row>
<entry>GetSize</entry>
<entry><link linkend="getsize">GetSize</link></entry>
</row>
<row>
<entry>GetStyleRaw</entry>
<entry><link linkend="mthGetStyleRaw">GetStyleRaw</link></entry>
</row>
<row>
<entry>GetTextSize</entry>
<entry><link linkend="gettextsize">GetTextSize</link></entry>
</row>
<row>
<entry>Group</entry>
<entry><link linkend="mthGroup">Group</link></entry>
</row>
<row>
<entry>HasKeyPressConnection</entry>
<entry><link linkend="mthHasKeyPressConnectionDialogControl">HasKeyPressConnection</link></entry>
</row>
<row>
<entry>Hide</entry>
<entry><link linkend="hide">Hide</link></entry>
</row>
<row>
<entry>HideFast</entry>
<entry><link linkend="hidefast">HideFast</link></entry>
</row>
<row>
<entry>HScrollPos</entry>
<entry><link linkend="hscrollpos">HScrollPos</link></entry>
</row>
<row>
<entry>IsMouseButtonDown</entry>
<entry><link linkend="ismousebuttondown">IsMouseButtonDown</link></entry>
</row>
<row>
<entry>LoadBitmap</entry>
<entry><link linkend="h000667">LoadBitmap</link></entry>
</row>
<row>
<entry>LogRect2AbsRect</entry>
<entry><link linkend="logrect2absrect">LogRect2AbsRect</link></entry>
</row>
<row>
<entry>Move</entry>
<entry><link linkend="move">Move</link></entry>
</row>
<row>
<entry>ObjectToDC</entry>
<entry><link linkend="h000928">ObjectToDC</link></entry>
</row>
<row>
<entry>OpaqueText</entry>
<entry><link linkend="h000842">OpaqueText</link></entry>
</row>
<row>
<entry>ProcessMessage</entry>
<entry><link linkend="processmessage">ProcessMessage</link></entry>
</row>
<row>
<entry>Rectangle</entry>
<entry><link linkend="h001115">Rectangle</link></entry>
</row>
<row>
<entry>Redraw</entry>
<entry><link linkend="redraw">Redraw</link></entry>
</row>
<row>
<entry>RedrawClient</entry>
<entry><link linkend="redrawclient">RedrawClient</link></entry>
</row>
<row>
<entry>RedrawRect</entry>
<entry><link linkend="redrawrect">RedrawRect</link></entry>
</row>
<row>
<entry>ReleaseMouseCapture</entry>
<entry><link linkend="releasemousecapture">ReleaseMouseCapture</link></entry>
</row>
<row>
<entry>RemoveBitmap</entry>
<entry><link linkend="h000676">RemoveBitmap</link></entry>
</row>
<row>
<entry>Resize</entry>
<entry><link linkend="resize">Resize</link></entry>
</row>
<row>
<entry>RestoreCursorShape</entry>
<entry><link linkend="restorecursorshape">RestoreCursorShape</link></entry>
</row>
<row>
<entry>ScreenToClient</entry>
<entry><link linkend="screentoclient">ScreenToClient</link></entry>
</row>
<row>
<entry>Scroll</entry>
<entry><link linkend="scroll">Scroll</link></entry>
</row>
<row>
<entry>SetArcDirection</entry>
<entry><link linkend="h001214">SetArcDirection</link></entry>
</row>
<row>
<entry>SetColor</entry>
<entry><link linkend="setcolor">SetColor</link></entry>
</row>
<row>
<entry>SetCursorPos</entry>
<entry><link linkend="setcursorpos">SetCursorPos</link></entry>
</row>
<row>
<entry>SetFocus</entry>
<entry><link linkend="setfocus">SetFocus</link></entry>
</row>
<row>
<entry>SetFocusToWindow</entry>
<entry><link linkend="setfocustowindow">SetFocusToWindow</link></entry>
</row>
<row>
<entry>SetFont</entry>
<entry><link linkend="setfont">SetFont</link></entry>
</row>
<row>
<entry>SetForegroundWindow</entry>
<entry><link linkend="setforegroundwindow">SetForegroundWindow</link></entry>
</row>
<row>
<entry>SetHScrollPos</entry>
<entry><link linkend="sethscrollpos">SetHScrollPos</link></entry>
</row>
<row>
<entry>SetVScrollPos</entry>
<entry><link linkend="setvscrollpos">SetVScrollPos</link></entry>
</row>
<row>
<entry>SetRect</entry>
<entry><link linkend="setrect">SetRect</link></entry>
</row>
<row>
<entry>SetTitle</entry>
<entry><link linkend="settitle">SetTitle</link></entry>
</row>
<row>
<entry>Show</entry>
<entry><link linkend="showdc">Show</link></entry>
</row>
<row>
<entry>ShowFast</entry>
<entry><link linkend="showfast">ShowFast</link></entry>
</row>
<row>
<entry>TabStop</entry>
<entry><link linkend="mthTabStop">TabStop</link></entry>
</row>
<row>
<entry>TabToNext</entry>
<entry><link linkend="tabtonext">TabToNext</link></entry>
</row>
<row>
<entry>TabToPrevious</entry>
<entry><link linkend="tabtoprevious">TabToPrevious</link></entry>
</row>
<row>
<entry>Title</entry>
<entry><link linkend="title">Title</link></entry>
</row>
<row>
<entry>Title=</entry>
<entry><link linkend="titlenew">Title=</link></entry>
</row>
<row>
<entry>TransparentText</entry>
<entry><link linkend="h000841">TransparentText</link></entry>
</row>
<row>
<entry>Update</entry>
<entry><link linkend="update">Update</link></entry>
</row>
<row>
<entry>Value</entry>
<entry><link linkend="value">Value</link></entry>
</row>
<row>
<entry>Value=</entry>
<entry><link linkend="valuenew">Value=</link></entry>
</row>
<row>
<entry>VScrollPos</entry>
<entry><link linkend="vscrollpos">VScrollPos</link></entry>
</row>
<row>
<entry>Write</entry>
<entry><link linkend="write">Write</link></entry>
</row>
<row>
<entry>WriteToButton</entry>
<entry><link linkend="h000852">WriteToButton</link></entry>
</row>
<row>
<entry>WriteToWindow</entry>
<entry><link linkend="h000826">WriteToWindow</link></entry>
</row>
</tbody></tgroup>
</table>
</para></listitem></varlistentry>
</variablelist>

<section id="appmodmeth"><title>Appearance and Behavior Methods</title>
<indexterm><primary>enable methods</primary>
<secondary>DialogControl class</secondary></indexterm>
<indexterm><primary>disable methods</primary>
<secondary>DialogControl class</secondary></indexterm>
<indexterm><primary>hide methods</primary>
<secondary>DialogControl class</secondary></indexterm>
<indexterm><primary>show methods</primary>
<secondary>DialogControl class</secondary></indexterm>
<para>The following methods deal with the appearance or the behavior of the
dialog control. The list contains methods to get or change the size, position,
visibility, behavior, etc., of dialog controls.
</para>

<section id="showdc"><title>Show</title>
<indexterm><primary>Show</primary>
<secondary>DialogControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Show-----------------------------------------><


]]>
</programlisting>

<para>The Show method makes a dialog control visible
and activates it.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example makes the edit control NAME visible and activates
it:
<programlisting>
<![CDATA[
MyDialog~GetEditControl("NAME")~Show
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="hide"><title>Hide</title>
<indexterm><primary>Hide</primary>
<secondary>DialogControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Hide-----------------------------------------><


]]>
</programlisting>

<para>The Hide method makes a dialog or dialog control
invisible and activates another dialog or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>

<programlisting>
<![CDATA[
MyDialog~GetEditControl("NAME")~Hide

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="hidefast"><title>HideFast</title>
<indexterm><primary>HideFast</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~HideFast-------------------------------------><


]]>
</programlisting>

<para>The HideFast method marks a dialog or dialog control
as invisible but does not redraw it. Send the Update method (see page <link linkend="update">Update</link>) to the dialog or dialog control to force
a redraw.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
<![CDATA[
MyDialog~GetEditControl("NAME")~HideFast
...
MyDialog~Update
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="showfast"><title>ShowFast</title>
<indexterm><primary>ShowFast</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~ShowFast-------------------------------------><


]]>
</programlisting>

<para>The ShowFast method marks a dialog or dialog control
as visible but does not redraw it.  Send the Update method (see page <link linkend="update">Update</link>) to the dialog or dialog control to force
a redraw.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
<![CDATA[
MyDialog~GetEditControl("NAME")~ShowFast
...
MyDialog~Update
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="display"><title>Display</title>
<indexterm><primary>Display</primary></indexterm>
<programlisting>
<![CDATA[

                               +-NORMAL---+------+--+
                               |          +-FAST-+  |
>>-aDialogControl~Display(--"--+-DEFAULT--+------+--+--"--)----><
                               |          +-FAST-+  |
                               +-HIDE-----+------+--+
                               |          +-FAST-+  |
                               +-INACTIVE-----------+


]]>
</programlisting>

<para>The Display method displays (shows, makes visible, or invisible) a dialog
control as specified.
</para>
<variablelist>
<varlistentry><term>Argument:</term>
<listitem><para>This argument can be one of the following keywords (case is not
significant.)  If no argument is given, the default keyword is <computeroutput>
NORMAL</computeroutput>:
</para>
<variablelist>
<varlistentry><term>NORMAL</term>
<listitem><para>Shows (makes visible) the dialog control. Same as calling the
Show method (see page <link linkend="showdc">Show</link>).
</para></listitem></varlistentry>
<varlistentry><term>DEFAULT</term>
<listitem><para>Default is an alias for <computeroutput>NORMAL</computeroutput>.
The behavior is exactly the same for the two keywords.
</para></listitem></varlistentry>
<varlistentry><term>HIDE</term>
<listitem><para>Hides (makes invisible) the dialog control.  Same as calling the
Hide method (see page <link linkend="hide">Hide</link>).
</para></listitem></varlistentry>
<varlistentry><term>INACTIVE</term>
<listitem><para>Displays (shows, makes visible,) the dialog control in its
current state. The active dialog remains active.  When this method is invoked
with the <computeroutput>NORMAL</computeroutput> keyword the dialog the control
belongs to will be made the active window.  If instead the <computeroutput>
INACTIVE</computeroutput> keyword is used, the active window will not be
changed. (Obviously, if the dialog that the control belongs to is already the
active window, the <computeroutput>INACTIVE</computeroutput> keyword behaves
exactly the same as the <computeroutput>NORMAL</computeroutput> keyword.
</para></listitem></varlistentry>
</variablelist>
<para>To each keyword, except the <computeroutput>INACTIVE</computeroutput>
keyword, you can add <computeroutput>FAST</computeroutput>, separated by a
blank, to suppress the redrawing of the dialog control.
</para>
</listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following statement makes a tree control in the dialog
visible without redrawing it.
<programlisting>
<![CDATA[
MyDialog~GetTreeControl(IDC_TREECONTROL_FILES)~Display("NORMAL FAST")
]]>
</programlisting>

This is usually done when there are a number of controls to make visible at one
time.  The programmer would make them all visible without redrawing. Then use
the <link linkend="update">Update</link> method to repaint everything at once.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="enable"><title>Enable</title>
<indexterm><primary>Enable</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Enable---------------------------------------><


]]>
</programlisting>

<para>The Enable method enables a dialog or dialog control
to accept user interaction.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
<![CDATA[
MyDialog~GetEditControl("Name")~Enable

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="disable"><title>Disable</title>
<indexterm><primary>Disable</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Disable--------------------------------------><


]]>
</programlisting>

<para>The Disable method disables a dialog or dialog
control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>

<programlisting>
<![CDATA[
MyDialog~GetEditControl("Name")~Disable

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthGroup"><title>Group</title>
<indexterm><primary>SetGroup</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Group(--+-----------+--)---------------------><
                          +-wantStyle-+

]]>
</programlisting>

<para>Add or remove the <link linkend="wsgroup">group style</link> for this
control.  The group style controls how the user can navigate through the dialog
using the keyboard.  For most dialogs this does not change while the dialog is
executing.  However, in some dialogs the programmer may want to change
the navigation depending on the options the user selects.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is
<variablelist>
<varlistentry><term>wantStyle</term>
<listitem><para>A boolean (.true or .false) to indicate whether the control
should have or not have the group style.  True (the default) indicates the
control should have the group style and false indicates the control should
not have the style.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>Negative values indicate the function failed, non-negative
values indicate success.
<variablelist>
<varlistentry><term>-4 or less</term>
<listitem><para>The value is the negated Operating System Error code.
The absolute value of the return can be used to look up the error reason in the
Windows documentation.
</para></listitem></varlistentry>
<varlistentry><term>-3</term>
<listitem><para>The optional argument to the method is not a boolean.
</para></listitem></varlistentry>
<varlistentry><term>-2</term>
<listitem><para>There is an (internal) problem with the dialog or the dialog
handle.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>There is an (internal) problem with the resource ID of the
control.
</para></listitem></varlistentry>
<varlistentry><term>0 or greater</term>
<listitem><para>The window style of the dialog control prior to adding or
removing the group style.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthTabStop"><title>TabStop</title>
<indexterm><primary>tabStop</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~TabStop(--+-----------+--)--------------------><
                            +-wantStyle-+

]]>
</programlisting>

<para>Add or remove the <link linkend="wstabstop">tab stop style</link> for the
control.  When  a control has the tabstop style, the user can set the focus to
the control by using the tab key.  When a control does not have this style, the
tab key will skip over the control.  Adding or removing this style during the
execution of a dialog allows the programmer to alter how the user navigates
through the dialog controls.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>wantStyle</term>
<listitem><para>A boolean (.true or .false) to indicate whether the control
should have or not have the tabstop style.  True (the default) indicates the
control should have the tabstop style and false indicates the control should
not have the style.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>Negative values indicate the function failed, non-negative
values indicate success.
<variablelist>
<varlistentry><term>-4 or less</term>
<listitem><para>The value is the negated Operating System Error code.
The absolute value of the return can be used to look up the error reason in the
Windows documentation.
</para></listitem></varlistentry>
<varlistentry><term>-3</term>
<listitem><para>The second argument to the method is not a boolean.
</para></listitem></varlistentry>
<varlistentry><term>-2</term>
<listitem><para>There is an (internal) problem with the dialog or the dialog
handle.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>There is an (internal) problem with the resource ID of the
control.
</para></listitem></varlistentry>
<varlistentry><term>0 or greater</term>
<listitem><para>The window style of the dialog control prior to adding or
removing the tabstop style.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="resize"><title>Resize</title>
<indexterm><primary>Resize</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Resize(--width--,--height--+-----------------------------+--)-><
                                             |       +----------------+    |
                                             |       V                |    |
                                             +-,--"----+-HIDEWINDOW-+-+--"-+
                                                       +-SHOWWINDOW-+
                                                       +-NOREDRAW---+


]]>
</programlisting>

<para>The Resize method resizes a dialog or dialog control. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>width</term>
<listitem><para>The new width of the dialog or dialog control, in dialog units.
</para></listitem></varlistentry>
<varlistentry><term>height</term>
<listitem><para>The new height of the dialog or dialog control, in dialog units.
</para></listitem></varlistentry>
<varlistentry><term>showOptions</term>
<listitem><para>One or more of the following keywords, separated by blanks:
<variablelist>
<varlistentry><term>HIDEWINDOW</term>
<listitem><para>The dialog or dialog control is to be made invisible.
</para></listitem></varlistentry>
<varlistentry><term>SHOWWINDOW</term>
<listitem><para>The dialog or dialog control is to be made visible.
</para></listitem></varlistentry>
<varlistentry><term>NOREDRAW</term>
<listitem><para>The dialog or dialog control is to be repositioned without redrawing
it.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Resizing was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Resizing failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example resizes the tree view control FILES almost to
the size of  the window and displays the new size:
<programlisting>
<![CDATA[
obj = MyDialog~GetTreeControl("FILES")
if obj = .Nil then return
obj~Resize(MyDialog~SizeX -10, MyDialog~SizeY -20)
parse value obj~GetSize with width height
say "New width of window is" width "and new height is" height
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="move"><title>Move</title>
<indexterm><primary>Move</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Move(--xPos--,--yPos--+----------------------------+--)-><
                                        |      +----------------+    |
                                        |      V                |    |
                                        +-,-"----+-HIDEWINDOW-+-+--"-+
                                                 +-SHOWWINDOW-+
                                                 +-NOREDRAW---+


]]>
</programlisting>

<para>The Move method moves the associated dialog or
dialog control to the specified position. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>xPos</term>
<listitem><para>The new horizontal position of the dialog or dialog control, in dialog
units.
</para></listitem></varlistentry>
<varlistentry><term>yPos</term>
<listitem><para>The new vertical position of the dialog or dialog control, in dialog
units.
</para></listitem></varlistentry>
<varlistentry><term>showOptions</term>
<listitem><para>One or more of the following keywords, separated by blanks:
<variablelist>
<varlistentry><term>HIDEWINDOW</term>
<listitem><para>The dialog or dialog control is to be made invisible.
</para></listitem></varlistentry>
<varlistentry><term>SHOWWINDOW</term>
<listitem><para>The dialog or dialog control is to be made visible.
</para></listitem></varlistentry>
<varlistentry><term>NOREDRAW</term>
<listitem><para>The dialog or dialog control is to be repositioned without redrawing
it.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Moving was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Moving failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example repositions the tree view control FILES to the
upper left corner of  the window and displays the new position:
<programlisting>
<![CDATA[
obj = MyDialog~GetTreeControl("FILES")
if obj = .Nil then return
obj~Move(1,1)
parse value obj~GetPos with x y
say "New horizontal position of window is" x "and new vertical position is" y
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="setforegroundwindow"><title>SetForegroundWindow</title>
<indexterm><primary>SetForegroundWindow</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~SetForegroundWindow(--hwnd--)---------------------------><


]]>
</programlisting>

<para>The SetForegroundWindow method changes the foreground window to the window
specified.  The new window must be a top-level window or a dialog window.  You
can not make a dialog control window the foreground window.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to the window that is to become the foreground window.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The handle to the previous foreground window, or 0 if this method
failed.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>This example makes another dialog the foreground window and
returns the window handle of the current foreground window to the caller, or
returns -1 if there was an error:
<programlisting>
<![CDATA[
::method switchToReportDlg
  expose reportDlg
  currentHwnd = self~setForeGroundwindow(reportDlg~dlgHandle)
  if currentHwnd == 0 then return -1  -- Report an error
  return currentHwnd

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="foregroundwindow"><title>ForegroundWindow</title>
<indexterm><primary>ForegroundWindow</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~ForegroundWindow-----------------------------><


]]>
</programlisting>

<para>The ForegroundWindow method returns the handle
to the current foreground window.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The handle to the foreground window, or 0 if this method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="getid"><title>GetID</title>
<indexterm><primary>GetID</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~GetID----------------------------------------><


]]>
</programlisting>

<para>The GetID method retrieves the identification number
of the associated dialog or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The numeric ID.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example displays 1 in most cases:
<programlisting>
<![CDATA[
say MyDialog~GetButtonControl("IDOK")~GetID
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthGetStyleRaw"><title>GetStyleRaw</title>
<indexterm><primary>GetStyleRaw</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~GetStyleRaw----------------------------------><


]]>
</programlisting>

<para>The <computeroutput>GetStyleRaw</computeroutput> method retrieves the
Windows style flags of the dialog control.  The flags are returned in
their numeric format.  This allows the programmer to determine the current style
of any control.  However, the programmer needs to be able to look up the numeric
value of the window style flags to make use of this functionality.  This can be
done using the <link linkend="windowsdoc">Windows documentation</link> and the
<link linkend="platformsdk">Platform SDK</link>.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>A negative return indicates an error.
<variablelist>
<varlistentry><term>-3 or less</term>
<listitem><para>The value of the negated Operating System error code.
The absolute value of the return can be used to look up the error reason in the
Windows documentation.
</para></listitem></varlistentry>
<varlistentry><term>-2</term>
<listitem><para>There is an (internal) problem with the dialog or the dialog
handle.
</para></listitem></varlistentry>
<varlistentry><term>0 or greater</term>
<listitem><para>The numeric value of the window style flags for the control.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example gets the style flags for a tree control
and then checks to see if drag and drop is enabled and if label editing is
enabled.
</para>
<para>The value of the style flags has the potential of being larger than can be
accommodated by the default numeric digits.  Use <computeroutput>numeric digits
11</computeroutput> if the returned value needs to be manipulated, for instance
to use <computeroutput>d2x</computeroutput> on the value.
<note><title>Note</title><para>
It is not necessary to convert the <computeroutput>style</computeroutput> value
in the example to its hexadecimal string representation before using it as an
argument in the <computeroutput>BinaryAnd</computeroutput> function.  That is
just done in the example for display purposes.
</para></note>

<programlisting>
<![CDATA[

  ...

  numeric digits 11
  TVS_DISABLEDRAGDROP = "0x0010"
  TVS_EDITLABELS      = "0x0008"

  treeControl = self~getTreeControl(IDC_TREE)
  style = treeControl~getStyleRaw
  style = "0x" || style~d2x~right(8, '0')

  if BinaryAnd( style, TVS_DISABLEDRAGDROP ) <> 0 then str1 = 'disabled'
  else str1 = 'enabled'

  if BinaryAnd( style, TVS_EDITLABELS ) <> 0 then str2 = 'enabled'
  else str2 = 'disabled'

  say 'Tree-view Control styles'
  say '  Raw style:    ' style
  say '  Drag and drop:' str1
  say '  Edit labels:  ' str2

/* Output coule be: */

Tree-view Control styles
  Raw style:     0x5000002F
  Drag and drop: enabled
  Edit labels:   enabled

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="getrect"><title>GetRect</title>
<indexterm><primary>GetRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~GetRect--------------------------------------><


]]>
</programlisting>

<para>Retrieves the dimensions of the rectangle surrounding the associated
dialog or dialog control. The coordinates are relative to the upper left corner
of the screen and are specified in screen pixels. The order is: left, top,
right, bottom; where &apos;left&apos; and &apos;top&apos; are the x and y coordinates of the upper
left-hand corner of the rectangle, and &apos;right&apos; and &apos;bottom&apos; are the coordinates
of the bottom right-hand corner.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The coordinates of the dialog or dialog control, separated by blanks.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example calculates the width and height of an entry line:
<programlisting>
<![CDATA[
parse value MyDialog~GetEditControl("Name")~GetRect with left top,
right bottom
width = right - left
height = bottom - top
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="setrect"><title>SetRect</title>
<indexterm><primary>SetRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~SetRect(--x--,--y--,--width--,--height-->

>--+-----------------------------+--)--------------------><
   |       +----------------+    |
   |       V                |    |
   +-,--"----+-NOMOVE-----+-+--"-+
             +-NOSIZE-----+
             +-HIDEWINDOW-+
             +-SHOWWINDOW-+
             +-NOREDRAW---+

]]>
</programlisting>

<para>The SetRect method sets new coordinates for the
associated dialog or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>x,y</term>
<listitem><para>The new position of the upper left corner, in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>width</term>
<listitem><para>The new width of the dialog or dialog control, in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>height</term>
<listitem><para>The new height of the dialog or dialog control, in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>showOptions</term>
<listitem><para>One or more of the following keywords, separated by blanks:
<variablelist>
<varlistentry><term>NOMOVE</term>
<listitem><para>The upper left position of the dialog or dialog control is not changed.
</para></listitem></varlistentry>
<varlistentry><term>NOSIZE</term>
<listitem><para>The size of the dialog or dialog control is not changed.
</para></listitem></varlistentry>
<varlistentry><term>HIDEWINDOW</term>
<listitem><para>The dialog or dialog control is to be made invisible.
</para></listitem></varlistentry>
<varlistentry><term>SHOWWINDOW</term>
<listitem><para>The dialog or dialog control is to be made visible.
</para></listitem></varlistentry>
<varlistentry><term>NOREDRAW</term>
<listitem><para>The dialog or dialog control is to be repositioned without redrawing
it.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Repositioning was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Repositioning failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthGetClientRect"><title>GetClientRect</title>
<indexterm><primary>GetClientRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~GetClientRect(--+------+--)------------------><
                                  +-hwnd-+


]]>
</programlisting>

<para>The GetClientRect method returns the client rectangle
of a dialog or dialog control in screen pixels. The client coordinates specify
the upper left and lower right corners of the client area. Because the client
coordinates are relative to the upper left corner of the client area of a
dialog or dialog control, the coordinates of the upper left corner are (0,0).</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to a dialog or dialog control. If this argument is omitted,
the dimensions of the associated dialog or dialog control are returned.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The client rectangle in the format &quot;<emphasis role="italic">left top right bottom</emphasis>&quot;,
separated by blanks.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="getpos"><title>GetPos</title>
<indexterm><primary>GetPos</primary>
<secondary>DialogControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~GetPos---------------------------------------><


]]>
</programlisting>

<para>The GetPos method returns the coordinates of the
upper left corner of the dialog or dialog control, in dialog units.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The horizontal and vertical position, separated by a blank.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>For an example, see <link linkend="move">Move</link>.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="getsize"><title>GetSize</title>
<indexterm><primary>GetSize</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~GetSize--------------------------------------><


]]>
</programlisting>

<para>The GetSize method returns the width and height
of the dialog or dialog control, in dialog units.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The width and height, separated by a blank.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>For an example, see <link linkend="resize">Resize</link>.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="assignfocus"><title>AssignFocus</title>
<indexterm><primary>AssignFocus</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~AssignFocus----------------------------------><


]]>
</programlisting>

<para>The AssignFocus method sets the input focus to
the associated dialog control.</para>
</section>

<section id="getfocus"><title>GetFocus</title>
<indexterm><primary>GetFocus</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~GetFocus-------------------------------------><


]]>
</programlisting>

<para>The GetFocus method returns the handle to the dialog control that currently
has the input focus.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The handle to the dialog control that has the input focus, or 0
if this method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="setfocus"><title>SetFocus</title>
<indexterm><primary>SetFocus</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~SetFocus(--hwnd--)---------------------------><


]]>
</programlisting>

<para>The SetFocus method sets the input focus to a dialog control and returns
the handle of the control that previously had the focus.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to the dialog control that is to receive the input
focus.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>The focus was changed, but the control with the previous focus
could not be determined.
</para></listitem></varlistentry>
<varlistentry><term>Other</term>
<listitem><para>The handle to the control with the previous focus.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="setfocustowindow"><title>SetFocusToWindow</title>
<indexterm><primary>SetFocusToWindow</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~SetFocusToWindow(--hwnd--)-------------------><


]]>
</programlisting>

<para>The SetFocusToWindow method moves the input focus to another top-level
window or dialog.  This has the effect of bringing that window to the
foreground.  This method returns a handle to the dialog
<emphasis role="italic">control</emphasis> that previously had the
input focus.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to the top-level window or dialog that is to
receive the input focus.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>-1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
<varlistentry><term>0</term>
<listitem><para>The focus was changed, but the control with the previous focus
could not be determined.
</para></listitem></varlistentry>
<varlistentry><term>Other</term>
<listitem><para>The handle to the control with the previous focus.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="setcolor"><title>SetColor</title>
<indexterm><primary>SetColor</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~SetColor(--background--,--foreground--)------><


]]>
</programlisting>

<para>The SetColor method sets the background and foreground
colors of the dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>background</term>
<listitem><para>The color number of the background color.
</para></listitem></varlistentry>
<varlistentry><term>foreground</term>
<listitem><para>The color number of the foreground color.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The color has been assigned.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The selected color was already assigned.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example sets the background color of list box FILES to
blue:
<programlisting>
<![CDATA[
MyDialog~GetListBox("FILES")~SetColor(4, 15)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="update"><title>Update</title>
<indexterm><primary>Update</primary>
<secondary>DialogControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Update---------------------------------------><


]]>
</programlisting>

<para>The Update method makes the contents of the dialog
or dialog control invalid and therefore forces it to be updated.</para>
</section>

<section id="title"><title>Title</title>
<indexterm><primary>Title</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Title----------------------------------------><


]]>
</programlisting>

<para>The Title method retrieves the title of the dialog
or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The title was retrieved.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Retrieving the title failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="titlenew"><title>Title=</title>
<indexterm><primary>Title=</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Title=--new_title----------------------------><


]]>
</programlisting>

<para>The Title= method sets the title of the dialog
or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>new_text</term>
<listitem><para>A text string that is to be used as the title or text of the dialog
or dialog control.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The title was set.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Setting the title failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example changes the label of radio button
CHOICE2:
<programlisting>
<![CDATA[
MyDialog~GetRadioControl("CHOICE2")~Title="&Object Rexx (preferred choice)"
MyDialog~Redraw
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="settitle"><title>SetTitle</title>
<indexterm><primary>SetTitle</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~SetTitle(--new_title--)----------------------><


]]>
</programlisting>

<para>The SetTitle method sets the title of the dialog
or dialog control. It is equal to <link linkend="titlenew">Title=</link>.</para>
</section>
</section>

<section id="miscDialogControl"><title>Miscellaneous Dialog Control
Methods</title>
<indexterm><primary>miscellaneous dialog control methods</primary></indexterm>
<para>The following methods are general purpose dialog control methods.
</para>

<section id="processmessage"><title>ProcessMessage</title>
<indexterm><primary>ProcessMessage</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~ProcessMessage(--message--,--firstParam--,--secondParam--)-><


]]>
</programlisting>

<para>The ProcessMessage method sends a Windows message
to a dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>message</term>
<listitem><para>The number of the message to be sent to the dialog control.
</para></listitem></varlistentry>
<varlistentry><term>firstParam,secondParam</term>
<listitem><para>Additional arguments specific to the message.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The return values are message-specific.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example erases the background of the edit control
with the resource ID (symbolic ID) of IDC_EDIT1:
<programlisting>
<![CDATA[
dlgc = MyDialog~GetEditControl("IDC_EDIT1")
WM_ERASEBACKGROUND = "14"~x2d
hdc = dlgc~GetDc
dlgc~ProcessMessage(WM_ERASEBACKGROUND, hdc, 0)
dlgc~FreeDC(hdc)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

<note><title>Note</title><para>
Use the <link linkend="windowsdoc">Windows documentation</link> and <link
linkend="platformsdk">Platform SDK</link> to obtain the Window message numbers.
</para></note>
</section>

<section id="value"><title>Value</title>
<indexterm><primary>Value</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Value----------------------------------------><


]]>
</programlisting>

<para>The Value method retrieves the current value of
a dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The current value set in the dialog control.
</para></listitem></varlistentry>
</variablelist>

<note><title>Note</title><para>
See <link linkend="h000514">GetValue</link> for more information.
</para></note>
</section>

<section id="valuenew"><title>Value=</title>
<indexterm><primary>Value=</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Value=--new_value----------------------------><


]]>
</programlisting>

<para>The Value= method sets a value for a dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>new_value</term>
<listitem><para>The value assigned to the dialog control.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example selects check box RESTART and deselects check
box VERIFY:</para>
<programlisting>
<![CDATA[
MyDialog~GetCheckControl("RESTART")~Value=1
MyDialog~GetCheckControl("VERIFY")~Value=0
]]>
</programlisting>
</listitem></varlistentry>
</variablelist>

<note><title>Note</title><para>
See <link linkend="h000584">SetValue</link> for more information.
</para></note>
</section>

<section id="assignwindow"><title>AssignWindow</title>
<indexterm><primary>AssignWindow</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~AssignWindow(--hwnd--)-----------------------><


]]>
</programlisting>

<para>The AssignWindow method connects a dialog or dialog
control with an existing object of the PlainBaseDialog or DialogControl class.
Note that the connected dialog or dialog control might not support all methods
provided by the DialogControl class.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Note Well:</emphasis></term>
<listitem><para>The <computeroutput>AssignWindow</computeroutput> method is used
internally to connect ooRexx objects (a <computeroutput>DialogControl
</computeroutput> object) to the underlying Windows dialog control.  It is not
recommended that the programmer use this method unless he throughly understands
the ooDialog framework. Otherwise, using this method has the potential for
causing unpredictable behavior.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to the dialog or dialog control that you want to assign to
the DialogControl object.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The handle to the dialog or dialog control that has been assigned, or
0 if the connection failed.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example searches the desktop for a dialog with the title &quot;Monitoring
Applications&quot;, connects it to the object <computeroutput>dlgc</computeroutput> of the DialogControl
class, and then hides the dialog:
<programlisting>
<![CDATA[
dlgc = .DialogControl~new
...
whnd = FindWindow("Monitoring Application")
if whnd \= 0 then do
   dlgc~AssignWindow(whnd)
   dlgc~Display("HIDE")
end
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

</section>

<section id="eventDialogControl"><title>Connect Event Methods</title>
<indexterm><primary>connect event methods</primary>
<secondary>DialogControl class</secondary></indexterm>
<para>The following methods connect dialog control events to methods the
programmer defines in the parent dialog class.
</para>

<section id="mthConnectKeyPressDialogControl"><title>ConnectKeyPress</title>
<indexterm><primary>ConnectKeyPress</primary>
<secondary>DialogControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~ConnectKeyPress(--msgToRaise--,--keys--+-----------+--)----><
                                                         +-,-filter--+

]]>
</programlisting>

<para>The <computeroutput>ConnectKeyPress</computeroutput> method connects a key
down event, when the control has the keyboard focus, with a programmer defined
method in the parent dialog of the control.  The underlying Windows dialog must
exist before this method can be invoked.
</para>
<note><title>Note</title><para>
This method is only available on systems running Windows XP or later.  On
earlier versions of Windows, the method will fail and return -4.
</para></note>
<para>The arguments, return values, and behavior of this method are the same as
those for the <computeroutput>ConnectKeyPress</computeroutput> method of the
<computeroutput>BaseDialog</computeroutput>.  However, the method of the
<computeroutput>BaseDialog</computeroutput> connects any key down event when the
dialog is the active window and this method of the <computeroutput>
DialogControl</computeroutput> only connects the key down events when the
specific control has the focus.  See the <link
linkend="mthConnectKeyPressBaseDialog">ConnectKeyPress</link> method of the
<computeroutput>BaseDialog</computeroutput> for a detailed description of
the arguments, return values, and behavior.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>msgToRaise</term>
<listitem><para>The method to be invoked for the key down event.
</para></listitem></varlistentry>
<varlistentry><term>keys</term>
<listitem><para>The key, or list of keys, whose key down event will invoke the
method specified by <computeroutput>msgToRaise</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>filter</term>
<listitem><para>An optional filter to be applied to the key down event.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The return values are:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Success.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The underlying mechanism in the Windows API failed.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>A problem with one of the arguments.
</para></listitem></varlistentry>
<varlistentry><term>-2</term>
<listitem><para>An (internal) problem with the dialog window.
</para></listitem></varlistentry>
<varlistentry><term>-3</term>
<listitem><para>An (internal) problem with the dialog administration.
</para></listitem></varlistentry>
<varlistentry><term>-4</term>
<listitem><para>This method is not supported by this version of Windows.
Windows XP or later is required.
</para></listitem></varlistentry>
<varlistentry><term>-5</term>
<listitem><para>Memory allocation error in the underlying Windows API.
</para></listitem></varlistentry>
<varlistentry><term>-6</term>
<listitem><para>The maximum number of connections has been reached.
</para></listitem></varlistentry>
<varlistentry><term>-7</term>
<listitem><para>The <computeroutput>msgToRaise</computeroutput> method is
already connected to a key down event for this dialog control.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry id="keyDownEventDialogControl"><term><emphasis role="bold">Event
Method Arguments
</emphasis></term>
<listitem><para>The ooDialog method connected to the key press event will
receive the following five arguments in the order listed:
<variablelist>
<varlistentry><term>keyCode</term>
<listitem><para>The numeric code of the key pressed.
</para></listitem></varlistentry>
<varlistentry><term>shift</term>
<listitem><para>True if a shift key was down at the time of the event and false
if the shift key was not down.
</para></listitem></varlistentry>
<varlistentry><term>control</term>
<listitem><para>True if a control key was down at the time of the key press,
false if it was not.
</para></listitem></varlistentry>
<varlistentry><term>alt</term>
<listitem><para>True if an alt key was down at the time of the key press, false
if it was not.
</para></listitem></varlistentry>
<varlistentry><term>extraInfo</term>
<listitem><para>This argument is a string containing keywords.  It supplies
extra information about the keyboard state at the time of a key press event.
The string will contain some combination of these keywords
<variablelist>
<varlistentry><term>numOn</term>
<listitem><para>Num Lock was on at the time of the key press event.
</para></listitem></varlistentry>
<varlistentry><term>numOff</term>
<listitem><para>Num Lock was off.
</para></listitem></varlistentry>
<varlistentry><term>capsOn</term>
<listitem><para>Caps Lock was on at the time of the key press event.
</para></listitem></varlistentry>
<varlistentry><term>capsOff</term>
<listitem><para>Caps Lock was off.
</para></listitem></varlistentry>
<varlistentry><term>scrollOn</term>
<listitem><para>Scroll Lock was on at the time of the key press event.
</para></listitem></varlistentry>
<varlistentry><term>scrollOff</term>
<listitem><para>Scroll Lock was off.
</para></listitem></varlistentry>
<varlistentry><term>lShift</term>
<listitem><para>The left shift key was down at the time of the key press event.
</para></listitem></varlistentry>
<varlistentry><term>rShift</term>
<listitem><para>The right shift key was down.
</para></listitem></varlistentry>
<varlistentry><term>lControl</term>
<listitem><para>The left control key was down at the time of the key press
event.
</para></listitem></varlistentry>
<varlistentry><term>rControl</term>
<listitem><para>The right control key was down.
</para></listitem></varlistentry>
<varlistentry><term>lAlt</term>
<listitem><para>The left alt key was down at the time of the key press event.
</para></listitem></varlistentry>
<varlistentry><term>rAlt</term>
<listitem><para>The right alt key was down.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example could be from an application that supplies
extended editing abilities for a multi-line edit control.  When the edit
control has the focus the user can use Alt-D to delete the current word, Ctrl-D
to delete the current line, and Shift-Alt-D delete the current paragraph:
<programlisting>
<![CDATA[

::method initDialog
  expose editControl

  editControl = self~getEditControl(IDC_EDTIT)
  ...

  -- Capture the D key press when either the Alt or Control keys are
  -- also pressed.
  editControl~connectKeyPress(onDPress, self~vCode('D'), "ALT CONTROL")
  ...

::method onDPress
  expose editControl
  use arg key, shift, control, alt, info

  -- Determine which of the key press combinations this is and take
  -- appropriate action if it is a combination we are interested in.

  isAltD = \ shift & \ control & alt
  isCtrlD = \ shift & control & \ alt
  isShiftAltD = shift & \ control & alt

  if isAltD then self~deleteWord(editControl)
  if isCtrlD the self~deleteLine(editControl)
  if isShiftAltD then self~deleteParagraph(editControl)

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

</section>

<section id="mthConnectFKeyPressDialogControl"><title>ConnectFKeyPress</title>
<indexterm><primary>ConnectFKeyPress</primary>
<secondary>DialogControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~ConnectFKeyPress(--msgToRaise--)-------------><


]]>
</programlisting>

<para>The <computeroutput>ConnectFKeyPress</computeroutput> method is a
convenience method that connects all F key down events, when the control has the
keyboard focus, with a programmer defined method in the parent dialog of the
control. (This is for the standard function keys, F2 through F24.)  The
underlying Windows dialog must exist before this method can be invoked.
</para>
<note><title>Note</title><para>
This method is only available on systems running Windows XP or later.  On
earlier versions of Windows, the method will fail and return -4.
</para></note>
<para>The arguments, return values, and behavior of this method are the same as
those for the <computeroutput>ConnectFKeyPress</computeroutput> method of the
<computeroutput>BaseDialog</computeroutput>.  However, the method of the
<computeroutput>BaseDialog</computeroutput> class connects any F key down event
when the dialog is the active window and this method of the <computeroutput>
DialogControl</computeroutput> class only connects the F key down events when
the specific control has the focus.  See the <link
linkend="mthConnectFKeyPressBaseDialog">ConnectFKeyPress</link> method of the
<computeroutput>BaseDialog</computeroutput> for a more detailed description of
the arguments, return values, and behavior.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The required argument is:
<variablelist>
<varlistentry><term>msgToRaise</term>
<listitem><para>The method to be invoked for the key down event.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The return values are:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Success.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The underlying mechanism in the Windows API failed.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>A problem with one of the arguments.
</para></listitem></varlistentry>
<varlistentry><term>-2</term>
<listitem><para>An (internal) problem with the dialog window.
</para></listitem></varlistentry>
<varlistentry><term>-3</term>
<listitem><para>An (internal) problem with the dialog administration.
</para></listitem></varlistentry>
<varlistentry><term>-4</term>
<listitem><para>This method is not supported by this version of Windows.
Windows XP or later is required.
</para></listitem></varlistentry>
<varlistentry><term>-5</term>
<listitem><para>Memory allocation error in the underlying Windows API.
</para></listitem></varlistentry>
<varlistentry><term>-6</term>
<listitem><para>The maximum number of connections has been reached.
</para></listitem></varlistentry>
<varlistentry><term>-7</term>
<listitem><para>The <computeroutput>msgToRaise</computeroutput> method is
already connected to a key down event for this dialog control.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Event Method Arguments
</emphasis></term>
<listitem><para>The ooDialog method connected to the F key down event receives
five arguments.  This arguments are described in detail in the <link
linkend="keyDownEventDialogControl">ConnectKeyPress</link> method of the
<computeroutput>DialogControl</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example connects the F key down events for an edit
control. The application determines which F key was pressed and takes
appropriate action.  For this application, the F3 key is the search key.
<programlisting> <![CDATA[

::method initDialog
  expose editControl searchToken

  editControl = self~getEditControl(IDC_EDIT)
  editControl~connectFKeyPress(onFKey)
  ...
  lastSearchToken = ""
  ...

::method onFKey
  expose editControl searchToken
  use arg key

  select
    when self~keyName(key) == 'F2' then do
      ...
    end
    when self~keyName(key) == 'F3' then do
      description = "What word would you like to search for?"
      searchToken = inputBox(description, "Search", searchToken)

      if searchToken <> "" then
        self~findAndHighlight(searchToken, editControl)
    end
    when self~keyName(key) == 'F4' then do
      ...
    end
    ...
  end
  ...

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthDisconnectKeyPressDialogControl"><title>DisconnectKeyPress</title>
<indexterm><primary>DisconnectKeyPress</primary>
<secondary>DialogControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~DisconnectKeyPress(--+--------------+--)-----><
                                       +--methodName--+

]]>
</programlisting>

<para>The <computeroutput>DisconnectKeyPress</computeroutput> method disconnects
a previously connected method with a key down event.  If no method name is
specified than all key down event connections are removed.  Otherwise, only the
key down events connected to the specific method are removed.
</para>
<note><title>Note</title><para>
This method is only available on systems running Windows XP or later.  On
earlier versions of Windows, the method will fail and return -4.
</para></note>
<para>The arguments, return values, and behavior of this method are the same as
those for the <computeroutput>DisonnectKeyPress</computeroutput> method of the
<computeroutput>BaseDialog</computeroutput>.  However, this method only works
for connections made using the <computeroutput>DialogControl's</computeroutput>
<link linkend="mthConnectKeyPressDialogControl"> ConnectKeyPress</link> method.
It can not work with a connection made though the
<computeroutput>BaseDialog's</computeroutput> method. See the
<link linkend="mthDisconnectKeyPressBaseDialog"> DisconnectKeyPress</link>
method of the <computeroutput>BaseDialog</computeroutput> for a more detailed
description of the behavior of this method.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The single optional argument is:
<variablelist>
<varlistentry><term>methodName</term>
<listitem><para>If <computeroutput>methodName</computeroutput> is specified,
only the key down events connected to that method are disconnected.  If the
argument is omitted, then all key down events for the dialog control will be
disconnected.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The return values are:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Success.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The underlying mechanism in the Windows API that captures the
key down events failed to disconnect.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>The specified <computeroutput>methodName</computeroutput> is not
connected to any key down events for this control.
</para></listitem></varlistentry>
<varlistentry><term>-2</term>
<listitem><para>The underlying mechanism in the Windows API that captures the
key down events was never installed.
</para></listitem></varlistentry>
<varlistentry><term>-4</term>
<listitem><para>This method is not supported by this version of Windows.
Windows XP or later is required.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example could come from a dialog where the user
can enable or disable the user of hot keys when she is working within an edit
control.  When the user presses the disable hot keys button, the dialog disables
the hot keys for the edit control by removing the key press connections.
<programlisting>
<![CDATA[

::method defineDialog

  ...
  self~addButton(IDC_PB_DISABLE, 60, 135, 65, 15, "Disable Hot Keys", onDisable)
  ...

method onDisable
  editControl = self~getEditControl(IDC_EDIT)
  editControl~disconnectKeyPress

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

</section>

<section id="mthHasKeyPressConnectionDialogControl"><title>HasKeyPressConnection</title>
<indexterm><primary>HasKeyPressConnection</primary>
<secondary>DialogControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~HasKeyPressConnection(--+--------------+--)-----><
                                          +--methodName--+

]]>
</programlisting>

<para>This method is used to query if a connection to a key down event already
exists.
</para>
<note><title>Note</title><para>
This method is only available on systems running Windows XP or later.  On
earlier versions of Windows, the method will fail and return -4.
</para></note>
<para>The arguments, return values, and behavior of this method are the same as
those for the <computeroutput>HasKeyPressConnection</computeroutput> method of
the <computeroutput>BaseDialog</computeroutput>. However, this method only works
for connections made using the <computeroutput>DialogControl's</computeroutput>
<link linkend="mthConnectKeyPressDialogControl"> ConnectKeyPress</link> method.
It can not work with a connection made though the
<computeroutput>BaseDialog's</computeroutput> method.  The <link
linkend="mthHasKeyPressConnectionBaseDialog"> HasKeyPressConnection</link>
method of the <computeroutput>BaseDialog</computeroutput> may provide some
additional insight into the behavior of this method.
</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The single optional argument is:
<variablelist>
<varlistentry><term>methodName</term>
<listitem><para>When this argument is not used,
<computeroutput>HasKeyPressConnection</computeroutput> queries if any key down
event for the dialog control is connected to a method.  When
<computeroutput>methodName</computeroutput> is specified, the query checks for a
connection to the specified method.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The returned value is always <computeroutput>true
</computeroutput> or <computeroutput>false</computeroutput>.
<variablelist>
<varlistentry><term>true</term>
<listitem><para>A connection exists.
</para></listitem></varlistentry>
<varlistentry><term>false</term>
<listitem><para>No connection exists.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example is from an application where the user can
enable the use of hot keys when an edit control has the focus, or not.  The
reset push button is used in the application to reset the state of the dialog.
One of the things done when the state is reset to check or uncheck a check box
that shows whether hot keys are currently enabled or not.
<programlisting>
<![CDATA[

::method defineDialog

  ...
  self~addCheckBox(IDC_CHECK_FKEYSENABlED, , 30, 60, , , "Hot Keys Enabled")
  ...
  self~addButton(IDC_PB_RESET, 60, 135, 45, 15, "Reset", onReset)
  ...

::method onReset

  ...
  editControl = self~getEditControl(IDC_EDIT)

  if editControl~hasKeyPressConnection then
    self~getCheckControl(IDC_CHECK_FKEYSENABlED)~check
  else
    self~getCheckControl(IDC_CHECK_FKEYSENABlED)~uncheck
  ...

]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>


</section>

</section>

<section id="drawmeth"><title>Draw Methods</title>
<indexterm><primary>draw methods</primary>
<secondary>DialogControl class</secondary></indexterm>
<para>The following methods are used to draw, redraw, and clear a dialog or dialog
control.</para>

<section id="draw"><title>Draw</title>
<indexterm><primary>Draw</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Draw-----------------------------------------><


]]>
</programlisting>

<para>The Draw method draws the dialog or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Drawing was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Drawing failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="clear"><title>Clear</title>
<indexterm><primary>Clear</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Clear----------------------------------------><


]]>
</programlisting>

<para>The Clear method draws the dialog or dialog control
using the background brush.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Clearing was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Clearing failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="clearrect"><title>ClearRect</title>
<indexterm><primary>ClearRect</primary>
<secondary>DialogControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~ClearRect(--left--,--top--,--right--,--bottom--)-><


]]>
</programlisting>

<para>The ClearRect method draws the dialog or dialog
control using the background brush.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>left,top</term>
<listitem><para>The upper left corner of the rectangle, in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>right,bottom</term>
<listitem><para>The lower right corner of the rectangle, in screen pixels.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Drawing was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Drawing failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="redraw"><title>Redraw</title>
<indexterm><primary>Redraw</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Redraw---------------------------------------><


]]>
</programlisting>

<para>The Redraw method redraws the dialog or dialog
control immediately.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Redrawing was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Redrawing failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="redrawrect"><title>RedrawRect</title>
<indexterm><primary>RedrawRect</primary>
<secondary>DialogControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~RedrawRect(--left--,--top--,--right--,--bottom-->

>--+-----------+--)----------------------------------------------><
   +-,erasebkg-+


]]>
</programlisting>

<para>The RedrawRect method immediately redraws the rectangle
of the client area of the associated dialog. You can specify whether the background
of the dialog is to be erased before redrawing.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>left,top</term>
<listitem><para>The upper left corner of the rectangle relative to the client area,
in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>right,bottom</term>
<listitem><para>The lower right corner of the rectangle relative to the client area,
in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>erasebkg</term>
<listitem><para>If this argument is 1 or &quot;Y&quot;, the background of the dialog is
erased before repainting.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Redrawing was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Redrawing failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="redrawclient"><title>RedrawClient</title>
<indexterm><primary>RedrawClient</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~RedrawClient(--erasebkg--)-------------------><


]]>
</programlisting>

<para>The RedrawClient method immediately redraws the
entire client area of the dialog or dialog control. You can specify whether
the background of the dialog or dialog control is to be erased before redrawing.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>erasebkg</term>
<listitem><para>If you specify 1 or &quot;Y&quot;, the background of the dialog is erased
before redrawing.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Redrawing was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Redrawing failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="conversionmeth"><title>Conversion Methods</title>
<indexterm><primary>conversion methods</primary></indexterm>
<para>The following methods are used to convert and map coordinates of a dialog
or dialog control.</para>

<section id="logrect2absrect"><title>LogRect2AbsRect</title>
<indexterm><primary>LogRect2AbsRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~LogRect2AbsRect(--left--,--top--,--right--,--bottom--)-><


]]>
</programlisting>

<para>The LogRect2AbsRect method converts the coordinates
from dialog units to screen pixels.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>left,top</term>
<listitem><para>The position of the upper left corner, in dialog units.
</para></listitem></varlistentry>
<varlistentry><term>right,bottom</term>
<listitem><para>The position of the lower right corner, in dialog units.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>A compound variable that stores the four screen pixel coordinates. The
position of the upper left corner is stored in RetStem.left and RetStem.top.
The position of the lower right corner is stored in RetStem.right and RetStem.bottom.
The tails left, top, right, and bottom must be uninitialized symbols.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
<![CDATA[
absrect. = MyDialog~LogRect2AbsRect(5, 5, 10, 10)
say "Screen pixel rectangle=" absrect.left "," absrect.top ",",
absrect.right "," absrect.bottom
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="absrect2logrect"><title>AbsRect2LogRect</title>
<indexterm><primary>AbsRect2LogRect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~AbsRect2LogRect(--left--,--top--,--right--,--bottom--)-><


]]>
</programlisting>

<para>The AbsRect2LogRect method converts the coordinates
from screen pixels to dialog units.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>left,top</term>
<listitem><para>The position of the upper left corner, in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>right,bottom</term>
<listitem><para>The position of the lower right corner, in screen pixels.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>A compound variable that stores the four screen dialog units. The position
of the upper left corner is stored in RetStem.left and RetStem.top. The position
of the lower right corner is stored in RetStem.right and RetStem.bottom. The
tails left, top, right, and bottom must be uninitialized symbols.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
<![CDATA[
rectdunit. = MyDialog~AbsRect2LogRect(20, 20, 40, 40)
say "Dialog unit rectangle=" rectdunit.left "," rectdunit.top ",",
rectdunit.right "," rectdunit.bottom
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="screentoclient"><title>ScreenToClient</title>
<indexterm><primary>ScreenToClient</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~ScreenToClient(--x--,y--)--------------------><


]]>
</programlisting>

<para>The ScreenToClient method maps the coordinates
relative to the upper left corner of the screen, to a location within the
client area relative to the upper left corner of the dialog's client area.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>x</term>
<listitem><para>The horizontal position, in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>y</term>
<listitem><para>The vertical position, in screen pixels.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The horizontal and vertical positions of the specified location relative
to the upper left corner of the client area, separated by a blank.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="clienttoscreen"><title>ClientToScreen</title>
<indexterm><primary>ClientToScreen</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~ClientToScreen(--x--,y--)--------------------><


]]>
</programlisting>

<para>The ClientToScreen method maps the coordinates
relative to the dialog's client area to the coordinates relative to the
upper left corner of the screen.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>x</term>
<listitem><para>The horizontal position in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>y</term>
<listitem><para>The vertical position in screen pixels.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The horizontal and vertical positions of the specified location relative
to the location (0,0) of the screen, separated by a blank.
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="scrollmeth"><title>Scroll Methods</title>
<indexterm><primary>scroll methods</primary></indexterm>
<para>The following methods are used to scroll a dialog or dialog control and
to set scroll bars.</para>

<section id="scroll"><title>Scroll</title>
<indexterm><primary>Scroll</primary>
<secondary>DialogControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Scroll(--cx--,--cy--)------------------------><


]]>
</programlisting>

<para>The Scroll method scrolls the contents of the associated
dialog or dialog control by the amount specified.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>cx</term>
<listitem><para>The number of screen pixels the content of the dialog or dialog control
is to be scrolled to the right or to the left, if negative.
</para></listitem></varlistentry>
<varlistentry><term>cy</term>
<listitem><para>The number of screen pixels the content of the dialog or dialog control
is to be scrolled downward or upward, if negative.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Scrolling was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Scrolling failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="hscrollpos"><title>HScrollPos</title>
<indexterm><primary>HScrollPos</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~HScrollPos-----------------------------------><


]]>
</programlisting>

<para>The HScrollPos method returns the position of the
horizontal scroll bar in the associated dialog or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The position of the horizontal scroll bar.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="vscrollpos"><title>VScrollPos</title>
<indexterm><primary>VScrollPos</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~VScrollPos-----------------------------------><


]]>
</programlisting>

<para>The VScrollPos method returns the position of the
vertical scroll bar in the associated dialog or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The position of the vertical scroll bar.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="sethscrollpos"><title>SetHScrollPos</title>
<indexterm><primary>SetHScrollPos</primary></indexterm>
<programlisting>
<![CDATA[
                                               +-1------+
>>-aDialogControl~SetHScrollPos(--position--,--+--------+--)---><
                                               +-redraw-+


]]>
</programlisting>

<para>The SetHScrollPos method sets the thumb position
of the horizontal scroll bar contained in the associated dialog or dialog
control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>position</term>
<listitem><para>The new thumb position of the horizontal scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>redraw</term>
<listitem><para>If this argument is 1 (the default), the display of the scroll bar is
updated.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The previous position of the horizontal scroll bar, or 0 if this method
failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="setvscrollpos"><title>SetVScrollPos</title>
<indexterm><primary>SetVScrollPos</primary></indexterm>
<programlisting>
<![CDATA[
                                               +-1------+
>>-aDialogControl~SetVScrollPos(--position--,--+--------+--)---><
                                               +-redraw-+


]]>
</programlisting>

<para>The SetVScrollPos method sets the thumb position
of the vertical scroll bar contained in the associated dialog or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>position</term>
<listitem><para>The new thumb position of the vertical scroll bar.
</para></listitem></varlistentry>
<varlistentry><term>redraw</term>
<listitem><para>If this argument is 1 (the default), the display of the scroll bar is
updated.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The previous position of the vertical scroll bar, or 0 if this method
failed.
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="mousecursormeth"><title>Mouse and Cursor Methods</title>
<indexterm><primary>mouse and cursor methods</primary></indexterm>
<para>The following methods are used to position and shape the mouse cursor and
to capture the mouse.</para>

<section id="cursorpos"><title>CursorPos</title>
<indexterm><primary>CursorPos</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~CursorPos------------------------------------><


]]>
</programlisting>

<para>The CursorPos method returns the current position
of the mouse cursor.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The horizontal and vertical position of the mouse, separated by a blank.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>See <link linkend="setcursorpos">SetCursorPos</link> for an example on how to use this method.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="setcursorpos"><title>SetCursorPos</title>
<indexterm><primary>SetCursorPos</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~SetCursorPos(--x--,y--)----------------------><


]]>
</programlisting>

<para>The SetCursorPos method moves the mouse cursor
to the specified position. This method can be used to force the repainting
of the mouse cursor or to keep the mouse cursor within a specific rectangle.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>x</term>
<listitem><para>The horizontal position of the mouse cursor, in screen pixels.
</para></listitem></varlistentry>
<varlistentry><term>y</term>
<listitem><para>The vertical position of the mouse cursor, in screen pixels.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Moving the mouse cursor was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Moving the mouse cursor failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example shows two methods: one indicating that processing
has started and one indicating that processing has completed. The method IndicateBeginProcessing
changes the shape of the mouse cursor to the WAIT cursor and IndicateEndProcessing
restores the original mouse cursor shape. Both methods retrieve the current
position of the mouse cursor and move it by one screen pixel in each direction
to force the repainting of the mouse cursor.</para>
<programlisting>
<![CDATA[
::method IndicateBeginProcessing
  self~Current_Cursor = self~Cursor_Wait
  parse value self~CursorPos with curx cury
  self~SetCursorPos(curx+1, cury+1)

::method IndicateEndProcessing
  self~RestoreCursorShape(self~Current_Cursor)
  parse value self~CursorPos with curx cury
  self~SetCursorPos(curx-1, cury-1)
]]>
</programlisting>
<para>See <link linkend="deflistdraghandler">DefListDragHandler</link> for
another example on how to use the mouse methods.</para>
</listitem></varlistentry>
</variablelist>
</section>

<section id="restorecursorshape"><title>RestoreCursorShape</title>
<indexterm><primary>RestoreCursorShape</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~RestoreCursorShape(--+--------------+--)-----><
                                       +-CursorHandle-+


]]>
</programlisting>

<para>The RestoreCursorShape method restores the shape
of the mouse cursor.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:</para>
<variablelist>
<varlistentry><term>CursorHandle</term>
<listitem><para>The handle to the mouse cursor shape returned by the Cursor_Arrow,
Cursor_AppStarting, Cursor_Cross, Cursor_No, or Cursor_Wait method.</para>
<para>If you omit this argument, the cursor shape is set to an arrow. Therefore,
it is recommended that you store the original mouse cursor shape by specifying
its handle when you change its shape.</para>
</listitem></varlistentry>
</variablelist>
</listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The handle to the current cursor shape, that is, the shape that was
used before the cursor was restored to the given shape.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>See <link linkend="setcursorpos">SetCursorPos</link> for an example on how to use this method.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="cursorarrow"><title>Cursor_Arrow</title>
<indexterm><primary>Cursor_Arrow</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Cursor_Arrow---------------------------------><


]]>
</programlisting>

<para>The Cursor_Arrow method sets the shape of the
mouse cursor to the standard arrow. The new shape is only used when the mouse
cursor is within the rectangle of the associated dialog or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The handle to the current cursor shape, that is, the shape that was
used before the arrow shape was set.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>See <link linkend="setcursorpos">SetCursorPos</link> for an example on how to use this method.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="cursorappstarting"><title>Cursor_AppStarting</title>
<indexterm><primary>Cursor_AppStarting</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Cursor_AppStarting---------------------------><


]]>
</programlisting>

<para>The Cursor_AppStarting method sets the shape
of the mouse cursor to the standard arrow with a small hourglass. The new
shape is only used when the mouse cursor is within the rectangle of the associated
dialog or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The handle to the current cursor shape, that is, the shape that was
used before the arrow shape with the hourglass was set.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>See <link linkend="setcursorpos">SetCursorPos</link> for an example on how to use this method.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="cursorcross"><title>Cursor_Cross</title>
<indexterm><primary>Cursor_Cross</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Cursor_Cross---------------------------------><


]]>
</programlisting>

<para>The Cursor_Cross method sets the shape of the
mouse cursor to a crosshair. The new shape is only used when the mouse cursor
is within the rectangle of the associated dialog or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The handle to the current shape, that is, the shape that was used before
the crosshair cursor shape was set.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>See <link linkend="setcursorpos">SetCursorPos</link> for an example on how to use this method.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="cursorno"><title>Cursor_No</title>
<indexterm><primary>Cursor_No</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Cursor_No------------------------------------><


]]>
</programlisting>

<para>The Cursor_No method sets the shape of the mouse
cursor to a slashed circle to deny access. The new shape is only used when
the mouse cursor is within the rectangle of the associated dialog or dialog
control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The handle to the current shape, that is, the shape that was used before
the slashed-circle cursor shape was set.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>See <link linkend="setcursorpos">SetCursorPos</link> for an example on how to use this method.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="cursorwait"><title>Cursor_Wait</title>
<indexterm><primary>Cursor_Wait</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Cursor_Wait----------------------------------><


]]>
</programlisting>

<para>The Cursor_Wait method sets the shape of the
mouse cursor to the hourglass. The new shape is only used when the mouse cursor
is within the rectangle of the associated dialog or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The handle to the current shape, that is, the shape that was used before
the hourglass shape was set.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>See <link linkend="setcursorpos">SetCursorPos</link> for an example on how to use this method.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="getmousecapture"><title>GetMouseCapture</title>
<indexterm><primary>GetMouseCapture</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~GetMouseCapture------------------------------><


]]>
</programlisting>

<para>The GetMouseCapture method retrieves the dialog
or dialog control that captured the mouse. This dialog or dialog control receives
the entire mouse input regardless of whether the mouse cursor is within the
borders of the dialog or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The handle to the dialog or dialog control that captures the mouse,
or 0 if the mouse is not captured.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="capturemouse"><title>CaptureMouse</title>
<indexterm><primary>CaptureMouse</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~CaptureMouse---------------------------------><


]]>
</programlisting>

<para>The CaptureMouse method captures the mouse. This
means that the associated dialog or dialog control receives the entire mouse
input regardless of whether the mouse cursor is within the borders of the
dialog or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The handle to the dialog or dialog control that previously captured
the mouse, or 0 if the mouse was not captured before.
</para></listitem></varlistentry>
</variablelist>

<note><title>Note</title><para>
If you change the cursor shape while the mouse is being captured,
this change is ignored.
</para></note>
</section>

<section id="releasemousecapture"><title>ReleaseMouseCapture</title>
<indexterm><primary>ReleaseMouseCapture</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~ReleaseMouseCapture--------------------------><


]]>
</programlisting>

<para>The ReleaseMouseCapture method releases the mouse
capture from a dialog or dialog control and restores normal mouse input processing.
This means that the mouse input is then received by another dialog or dialog
control that captured the mouse.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The mouse capture was released.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Releasing the mouse capture failed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="ismousebuttondown"><title>IsMouseButtonDown</title>
<indexterm><primary>IsMouseButtonDown</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~IsMouseButtonDown(--"--+-LEFT---+--"--)------><
                                         +-MIDDLE-+
                                         +-RIGHT--+


]]>
</programlisting>

<para>The IsMouseButtonDown method retrieves information
on whether a mouse button is pressed.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>button</term>
<listitem><para>The location of the mouse button you are interested in.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The button is not being pressed.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The button is being pressed.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="bitmapmeth"><title>Bitmap Methods</title>
<indexterm><primary>bitmap methods</primary></indexterm>
<para>The following methods load and release bitmaps.</para>

<section id="h000667"><title>LoadBitmap</title>
<indexterm><primary>LoadBitmap</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~LoadBitmap(--bmpFilename--+-------------+--)-><
                                            +-,--"USEPAL"-+


]]>
</programlisting>

<para>The LoadBitmap method loads a bitmap from a file
into memory and returns the handle to the bitmap. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>bmpFilename</term>
<listitem><para>The name of a bitmap file. The name can also include a relative or absolute
path.
</para></listitem></varlistentry>
<varlistentry><term>USEPAL</term>
<listitem><para>Sets the color palette of the bitmap as the system color palette.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example loads into memory the bitmap file, <computeroutput>Walker.bmp</computeroutput>, which is located in the <computeroutput>BMP</computeroutput> subdirectory. hBmp is the handle to this in-memory bitmap.

<programlisting>
<![CDATA[
hBmp = MyDialog~LoadBitmap("bmp\Walker.bmp", "USEPAL")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

<note><title>Note</title><para>
Do not forget to call the <link linkend="h000676">RemoveBitmap</link> method
to free memory when the bitmap is no longer in use. You have to specify the
INMEMORY option when using the <link linkend="h000156">ConnectBitmapButton</link> or <link linkend="h000170">ChangeBitmapButton</link> method.
</para></note>
</section>

<section id="h000676"><title>RemoveBitmap</title>
<indexterm><primary>RemoveBitmap</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~RemoveBitmap(--hBitmap--)--------------------><


]]>
</programlisting>

<para>The RemoveBitmap method frees an in-memory bitmap
that was loaded by <link linkend="h000667">LoadBitmap</link>. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hBitmap</term>
<listitem><para>The bitmap handle.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="dcmeth"><title>Device Context Methods</title>
<indexterm><primary>device context methods</primary>
<secondary>DialogControl class</secondary></indexterm>
<para>The following methods are used to retrieve and release a device context
(DC).</para>
<para>A device context (DC) is associated with a dialog or dialog control, and
is a drawing area managed by a dialog or dialog control. It stores information
about graphic objects (such as bitmaps, lines, and pixels that are displayed)
and the tools (such as pens, brushes, and fonts) that are used to display
them.</para>

<section id="getdc"><title>GetDC</title>
<indexterm><primary>GetDC</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~GetDC----------------------------------------><


]]>
</programlisting>

<para>The GetDC method reserves drawing resources and
returns the handle to the display device context of a dialog or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The handle to the device context, or 0 if this method failed.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example retrieves the device context of button DRAWINGS,
processes the drawing commands, and frees the device context resources:
<programlisting>
<![CDATA[
obj = MyDialog~GetButtonControl("DRAWINGS")
if obj = .Nil then return -1
dc = obj~GetDC
if dc = 0 then return -1
... /* draw something */
obj~FreeDC(dc)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>

<note><title>Note</title><para>
When you have finished with the device context, call <link linkend="freedc">FreeDC</link>.
</para></note>
</section>

<section id="freedc"><title>FreeDC</title>
<indexterm><primary>FreeDC</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~FreeDC(--dc--)-------------------------------><


]]>
</programlisting>

<para>The FreeDC method releases the device context resources
that were reserved for <link linkend="getdc">GetDC</link>.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>The handle to the device context that is to be released.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The device context resources were released.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>Releasing the device context resources failed.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>See <link linkend="getdc">GetDC</link> for an example.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>

<note><title>Note</title><para>
Always call this method when you have finished with the device
context.
</para></note>
</section>
</section>

<section id="textmeth"><title>Text Methods</title>
<indexterm><primary>text methods</primary>
<secondary>DialogControl class</secondary></indexterm>
<para>The following methods are used to display text dynamically in a window
area and to modify the state of a device context. See <link linkend="h001062">GetWindowDC</link>, <link linkend="getdc">GetDC</link>, and <link linkend="h001077">GetButtonDC</link> for information on how to retrieve
a device context.</para>

<section id="write"><title>Write</title>
<indexterm><primary>Write</primary>
<secondary>DialogControl class</secondary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Write(--xPos--,--yPos--,--text---------------->

>--+--------------------------------------+--------------------->
   |    +-"SYSTEM"-+                      |
   +-,--+----------+--+-----------------+-+
        +-fontName-+  |    +-10-------+ |
                      +-,--+----------+-+
                           +-fontSize-+

>--+--------------------------------------------------------------------------+--)-><
   +-+----------------------------------------------------------------------+-+
     +-+------------------------------------------------------------------+-+
       |       +-----------------+                                        |
       |       V +-OPAQUE------+ |                                        |
       +-,--"----+-THIN--------+-+--"--+--------------------------------+-+
                 +-EXTRALIGHT--+       +-,--+---------+--+------------+-+
                 +-LIGHT-------+            +-fgColor-+  +-,--bkColor-+
                 +-MEDIUM------+
                 +-SEMIBOLD----+
                 +-EXTRABOLD---+
                 +-BOLD--------+
                 +-HEAVY-------+
                 +-UNDERLINE---+
                 +-ITALIC------+
                 +-STRIKEOUT---+
                 +-TRANSPARENT-+
                 +-CLIENT------+


]]>
</programlisting>

<para>The Write method writes the specified text to the
device context associated with the dialog or dialog control in the given font,
style, and color at the given position.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>xPos, yPos</term>
<listitem><para>The starting position of the text, in pixels.
</para></listitem></varlistentry>
<varlistentry><term>text</term>
<listitem><para>The string that you want to write to the dialog or dialog control.
</para></listitem></varlistentry>
<varlistentry><term>fontName</term>
<listitem><para>The name of a font. If omitted, the SYSTEM font is used.
</para></listitem></varlistentry>
<varlistentry><term>fontSize</term>
<listitem><para>The size of the font. If omitted, the standard size (10) is used.
</para></listitem></varlistentry>
<varlistentry><term>fontStyle</term>
<listitem><para>One or more of the keywords listed in the syntax diagram, separated
by blanks:
<variablelist>
<varlistentry><term>TRANSPARENT</term>
<listitem><para>This style writes the text without clearing the background.
</para></listitem></varlistentry>
<varlistentry><term>OPAQUE</term>
<listitem><para>This style, which is the default, clears the background with the given
background color, or with white if the background color is omitted, before
writing the text.
</para></listitem></varlistentry>
<varlistentry><term>CLIENT</term>
<listitem><para>The device context of the client area of the dialog or dialog control
is used instead of the device context of the entire dialog or dialog control.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>fgcolor</term>
<listitem><para>The color index of the text color.
</para></listitem></varlistentry>
<varlistentry><term>bkColor</term>
<listitem><para>The color index of the background color. The background color is not
used in transparent mode.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example writes the string &quot;Hello world!&quot; to the
dialog using a blue 24pt Arial font in bold and transparent, italic style:
<programlisting>
<![CDATA[
MyDialog~Write(5, 5, "Hello world!", "Arial", 24, ,
"BOLD ITALIC TRANSPARENT CLIENT", 4)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000840"><title>WriteDirect</title>
<indexterm><primary>WriteDirect</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~WriteDirect(--dc--,--xPos--,--yPos--,--text--)-><


]]>
</programlisting>

<para>The WriteDirect method enables you to write text
to a device context at a given position. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>A device context.
</para></listitem></varlistentry>
<varlistentry><term>xPos, yPos</term>
<listitem><para>The position where the text is placed, in pixels.
</para></listitem></varlistentry>
<varlistentry><term>text</term>
<listitem><para>The string you want to write to the dialog or dialog control.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000841"><title>TransparentText</title>
<indexterm><primary>TransparentText</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~TransparentText(--dc--)---------------------->>


]]>
</programlisting>

<para>The TransparentText method enables you to write
text to a device context using <link linkend="h000840">WriteDirect</link> in transparent
mode, that is, without a white background behind the text. Restore the default
mode using <link linkend="h000842">OpaqueText</link>. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>A device context.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000842"><title>OpaqueText</title>
<indexterm><primary>OpaqueText</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~OpaqueText(--dc--)---------------------------><


]]>
</programlisting>

<para>The OpaqueText method restores the default text
mode, that is, with a white background behind the text, which overlays whatever
is at that position in the dialog or dialog control. Use this method after
transparent mode was set using <link linkend="h000841">TransparentText</link>. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>A device context.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000826"><title>WriteToWindow</title>
<indexterm><primary>WriteToWindow</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~WriteToWindow(--hwnd--,--xPos--,--yPos--,--text-->

>--+--------------------------------------+--------------------->
   |    +-"SYSTEM"-+                      |
   +-,--+----------+--+-----------------+-+
        +-fontName-+  |    +-10-------+ |
                      +-,--+----------+-+
                           +-fontSize-+

>--+--------------------------------------------------------------------------+--)-><
   +-+----------------------------------------------------------------------+-+
     +-+------------------------------------------------------------------+-+
       |       +-----------------+                                        |
       |       V +-OPAQUE------+ |                                        |
       +-,--"----+-THIN--------+-+--"--+--------------------------------+-+
                 +-EXTRALIGHT--+       +-,--+---------+--+------------+-+
                 +-LIGHT-------+            +-fgColor-+  +-,--bkColor-+
                 +-MEDIUM------+
                 +-SEMIBOLD----+
                 +-EXTRABOLD---+
                 +-BOLD--------+
                 +-HEAVY-------+
                 +-UNDERLINE---+
                 +-ITALIC------+
                 +-STRIKEOUT---+
                 +-TRANSPARENT-+
                 +-CLIENT------+


]]>
</programlisting>

<para>The WriteToWindow method enables you to write text
to a dialog or dialog control in the given font and size to the given position. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>hwnd</term>
<listitem><para>The handle of the dialog or dialog control. See <link linkend="h000086">Get</link> for
how to get a valid handle.
</para></listitem></varlistentry>
<varlistentry><term>xPos, yPos</term>
<listitem><para>The starting position of the text, in pixels.
</para></listitem></varlistentry>
<varlistentry><term>text</term>
<listitem><para>The string you want to write to the dialog or dialog control.
</para></listitem></varlistentry>
<varlistentry><term>fontName</term>
<listitem><para>The name of a font. If omitted, the SYSTEM font is used.
</para></listitem></varlistentry>
<varlistentry><term>fontSize</term>
<listitem><para>The size of the font. If omitted, the standard size (10) is used.
</para></listitem></varlistentry>
<varlistentry><term>fontStyle</term>
<listitem><para>One or more of the keywords listed in the syntax diagram, separated
by blanks:
<variablelist>
<varlistentry><term>TRANSPARENT</term>
<listitem><para>This style writes the text without clearing the background.
</para></listitem></varlistentry>
<varlistentry><term>OPAQUE</term>
<listitem><para>This style, which is the default, clears the background with the given
background color, or with white if the background color is omitted, before
writing the text.
</para></listitem></varlistentry>
<varlistentry><term>CLIENT</term>
<listitem><para>The device context of the dialog's client area is used instead of
the device context of the entire dialog.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>This example writes the string "Hello world!" to the dialog window using
a 24pt Arial font in bold and italic style:

<programlisting>
<![CDATA[
hwnd=MyDialog~Get
MyDialog~WriteToWindow(hwnd, 23, 15, "Hello world!", ,
                       "Arial", 24, "BOLD ITALIC")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000852"><title>WriteToButton</title>
<indexterm><primary>WriteToButton</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~WriteToButton(--id--,--xPos--,--yPos--,--text-->

>--+--------------------------------------+--------------------->
   |    +-"SYSTEM"-+                      |
   +-,--+----------+--+-----------------+-+
        +-fontName-+  |    +-10-------+ |
                      +-,--+----------+-+
                           +-fontSize-+

>--+--------------------------------------------------------------------------+--)-><
   +-+----------------------------------------------------------------------+-+
     +-+------------------------------------------------------------------+-+
       |       +-----------------+                                        |
       |       V +-OPAQUE------+ |                                        |
       +-,--"----+-THIN--------+-+--"--+--------------------------------+-+
                 +-EXTRALIGHT--+       +-,--+---------+--+------------+-+
                 +-LIGHT-------+            +-fgColor-+  +-,--bkColor-+
                 +-MEDIUM------+
                 +-SEMIBOLD----+
                 +-EXTRABOLD---+
                 +-BOLD--------+
                 +-HEAVY-------+
                 +-UNDERLINE---+
                 +-ITALIC------+
                 +-STRIKEOUT---+
                 +-TRANSPARENT-+
                 +-CLIENT------+


]]>
</programlisting>

<para>The WriteToButton method enables you to write text
to a button in the given font and size to the given position. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:</para>
<variablelist>
<varlistentry><term>id</term>
<listitem><para>The ID of a button.
</para></listitem></varlistentry>
</variablelist>
<para>See <link linkend="h000826">WriteToWindow</link> for a description
of the other arguments.</para>
</listitem></varlistentry>
</variablelist>
</section>

<section id="gettextsize"><title>GetTextSize</title>
<indexterm><primary>GetTextSize</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~GetTextSize(--text--+------------------------------------->
                                      +--,--fontname--+--------------------->
                                                      +--,--fontsize--+----->

>--------------------+--)--------------------------------------------------><
>-----------------+--+
>--+-----------+--+
   +--,--hwnd--+


]]>
</programlisting>

<para>The GetTextSize method returns the width and height
that the specified text requires in the font and size given.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>text</term>
<listitem><para>The text for which the dimensions are to be returned.
</para></listitem></varlistentry>
<varlistentry><term>fontname</term>
<listitem><para>The name of the font used in the device context (DC).
</para></listitem></varlistentry>
<varlistentry><term>fontsize</term>
<listitem><para>The size of the font used in the device context (DC).
</para></listitem></varlistentry>
<varlistentry><term>hwnd</term>
<listitem><para>The handle to the dialog or dialog control that is the owner of the
device context (DC).
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The width and height of the text, in dialog units, separated by a blank.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example stores the space required by the specified text
in the device context of MyButton, in cx and cy:
<programlisting>
<![CDATA[
parse value MyButton~GetTextSize("This is the output!") with cx cy
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="setfont"><title>SetFont</title>
<indexterm><primary>SetFont</primary></indexterm>
<programlisting>
<![CDATA[
<>>-aDialogControl~SetFont(--fontHandle--+---------+--)---------><
                                         +-,redraw-+


]]>
</programlisting>

<para>The SetFont method assigns another font to the
text in a dialog or dialog control.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>fontHandle</term>
<listitem><para>The handle to the font that is to be used by the dialog or dialog item.
Use <link linkend="createfont">CreateFont</link> to get this handle.
</para></listitem></varlistentry>
<varlistentry><term>redraw</term>
<listitem><para>If you specify 1, the dialog or dialog item is redrawn.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example creates the font Arial with a pitch size of 14
and assigns it to the tree view control FILES, which is forced to be redrawn.
<programlisting>
<![CDATA[
hfnt = Mydialog~CreateFont("Arial", 14)
MyDialog~GetTreeControl("FILES")~SetFont(hfnt, 1)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="createfont"><title>CreateFont</title>
<indexterm><primary>CreateFont</primary></indexterm>
<programlisting>
<![CDATA[
<                              +-"SYSTEM"-+     +-10-------+
>>-aDialogControl~CreateFont(--+----------+--,--+----------+--,-->
                               +-fontName-+     +-fontSize-+

      +----------------+
      V                |
>--"----+-THIN-------+-+--"--+--------------+--)---------------><
        +-EXTRALIGHT-+       +-,--fontWidth-+
        +-LIGHT------+
        +-MEDIUM-----+
        +-SEMIBOLD---+
        +-EXTRABOLD--+
        +-BOLD-------+
        +-HEAVY------+
        +-UNDERLINE--+
        +-ITALIC-----+
        +-STRIKEOUT--+


]]>
</programlisting>

<para>The CreateFont method creates a font. It returns
a handle that you can use in the FontToDC method (see page <link linkend="h000948">FontToDC</link>) to activate the font in a device context or in the SetItemFont
method (see page <link linkend="sifm">SetItemFont</link>) to change the font of
a dialog or dialog item. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>fontName</term>
<listitem><para>The name of a font. You can look for valid fonts in the Fonts folder of your Windows Control Panel. If omitted, the
SYSTEM font is used.
</para></listitem></varlistentry>
<varlistentry><term>fontSize</term>
<listitem><para>The size of the font. If omitted, the standard size (10) is used.
</para></listitem></varlistentry>
<varlistentry><term>fontStyle</term>
<listitem><para>One or more of the keywords listed in the syntax diagram, separated
by blanks.
</para></listitem></varlistentry>
<varlistentry><term>fontWidth</term>
<listitem><para>This argument is optional if it differs from fontSize.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example creates a 16-point italic Arial font:

<programlisting>
<![CDATA[
hfnt = MyDialog~CreateFont("Arial", 16, "ITALIC")
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="deletefont"><title>DeleteFont</title>
<indexterm><primary>DeleteFont</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~DeleteFont(--hFont--)------------------------><


]]>
</programlisting>

<para>The DeleteFont method deletes a font. This method
is to be used to delete a font created with the CreateFont method (see page <link linkend="createfont">CreateFont</link>). </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>hFont</term>
<listitem><para>The handle of a font.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000948"><title>FontToDC</title>
<indexterm><primary>FontToDC</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~FontToDC(--dc--,hFont--)---------------------><


]]>
</programlisting>

<para>The FontToDC method loads a font into a device
context and returns the handle of the previous font. Use the <link linkend="h001062">GetWindowDC</link>, <link linkend="getdc">GetDC</link>, or <link linkend="h001077">GetButtonDC</link> method
to retrieve a device context, and the <link linkend="createfont">CreateFont</link> method
to get a font handle. To reset the font to the original state, use another
FontToDC call with the handle of the previous font. To release the device
context, use the <link linkend="h001086">FreeWindowDC</link>, <link linkend="freedc">FreeDC</link>, or <link linkend="h001105">FreeButtonDC</link> method.</para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>The device context of a dialog or button.
</para></listitem></varlistentry>
<varlistentry><term>hFont</term>
<listitem><para>The handle of a font.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>This example loads an Arial font into the current dialog window:

<programlisting>
<![CDATA[
hfnt = MyDialog~CreateFont("Arial", 16, "ITALIC")
dc   = MyDialog~GetDC
oldf = MyDialog~FontToDC(dc,hfnt)  /* activate font */
...
MyDialog~FontToDC(dc,oldf)         /* restore previous font */
MyDialog~FreeDC(dc)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000997"><title>FontColor</title>
<indexterm><primary>FontColor</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~FontColor(--color--,dc--)--------------------><


]]>
</programlisting>

<para>The FontColor method sets the font color for a
device context. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>color</term>
<listitem><para>The index of a color in the system's color palette.
</para></listitem></varlistentry>
<varlistentry><term>dc</term>
<listitem><para>The device context.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="graphicmeth"><title>Graphic Methods</title>
<indexterm><primary>graphic methods</primary></indexterm>
<para>These methods deal with drawing graphics within the device context of a
window. See <link linkend="h001062">GetWindowDC</link>, <link linkend="getdc">GetDC</link>, and <link linkend="h001077">GetButtonDC</link> for
information on how to retrieve a device context.</para>

<section id="h001026"><title>CreateBrush</title>
<indexterm><primary>CreateBrush</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~CreateBrush(--color--+-----------------+--)--><
                                       +-,brushSpecifier-+


]]>
</programlisting>

<para>The CreateBrush method creates a color brush or
a bitmap brush. It returns the handle to a brush object. To remove the brush,
use <link linkend="h001017">DeleteObject</link>. The brush is used to fill rectangles. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>color</term>
<listitem><para>The color number. For a list of color numbers, refer to <link linkend="termdef">Definition of Terms</link>.
</para></listitem></varlistentry>
<varlistentry><term>brushSpecifier</term>
<listitem><para>The name of a bitmap file or one of the following keywords to create
a hatched brush:</para>
<variablelist>
<varlistentry><term>UPDIAGONAL</term>
<listitem><para>A 45-degree upward, left-to-right hatch
</para></listitem></varlistentry>
<varlistentry><term>CROSS</term>
<listitem><para>A horizontal and vertical crosshatch
</para></listitem></varlistentry>
<varlistentry><term>DIAGCROSS</term>
<listitem><para>A 45-degree crosshatch
</para></listitem></varlistentry>
<varlistentry><term>DOWNDIAGONAL</term>
<listitem><para>A 45-degree downward, left-to-right hatch
</para></listitem></varlistentry>
<varlistentry><term>HORIZONTAL</term>
<listitem><para>A horizontal hatch
</para></listitem></varlistentry>
<varlistentry><term>VERTICAL</term>
<listitem><para>A vertical hatch
</para></listitem></varlistentry>
</variablelist>
<para>If CreateBrush is sent to a dialog object
(subclass of ResDialog), <emphasis role="italic">brushSpecifier</emphasis> can also be an integer resource
ID for a bitmap stored in the DLL that also stores the resource.</para>
<para>If
this argument is omitted, a solid brush with the specified color is created.</para>
</listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001035"><title>CreatePen</title>
<indexterm><primary>CreatePen</primary></indexterm>
<programlisting>
<![CDATA[
                              +-1-----+
>>-aDialogControl~CreatePen(--+-------+--,--+----------------------+--,-->
                              +-width-+     |    +-SOLID------+    |
                                            +-"--+-DASH-------+--"-+
                                                 +-DOT--------+
                                                 +-DASHDOT----+
                                                 +-DASHDOTDOT-+
                                                 +-NULL-------+

   +-0-----+
>--+-------+--)---------------------------------------------------------><
   +-color-+


]]>
</programlisting>

<para>The CreatePen method creates a pen in the specified
color and style. It returns the handle to a pen object. To remove the pen,
use <link linkend="h001017">DeleteObject</link>. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>width</term>
<listitem><para>The width of the lines that the pen will draw. If omitted, 1 is used
as default.
</para></listitem></varlistentry>
<varlistentry><term>style</term>
<listitem><para>One of the keywords listed in the syntax diagram. Values other than
SOLID or NULL have no effect on pens with a width greater than 1. SOLID is
the default.
</para></listitem></varlistentry>
<varlistentry><term>color</term>
<listitem><para>The color number of the pen. If omitted, 0 is used as default. For a
list of color numbers, refer to <link linkend="termdef">Definition of Terms</link>.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example creates a dotted pen object with a width of 1:

<programlisting>
<![CDATA[
hPen = MyDialog~CreatePen(1, "DOT", 13)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h000928"><title>ObjectToDC</title>
<indexterm><primary>ObjectToDC</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~ObjectToDC(--dc--,--obj--)-------------------><


]]>
</programlisting>

<para>The ObjectToDC method loads a graphic object, namely
a pen or a brush, into a device context. Subsequent lines, rectangles, and
arcs are drawn using the pen and brush. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>The device context.
</para></listitem></varlistentry>
<varlistentry><term>obj</term>
<listitem><para>The object: a pen or a brush.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Return value:</emphasis></term>
<listitem><para>The handle of the previous active pen or brush. It can be used to restore
the previous environment.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example activates a pen for drawing:

<programlisting>
<![CDATA[
dc = MyBaseDialog~GetDC
hpen = MyDialog~CreatePen(2, "SOLID", 4)
MyDialog~ObjectToDC(dc,hpen)
... /* do lines, rectangles, ... */
MyDialog~deleteObject(hpen)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001017"><title>DeleteObject</title>
<indexterm><primary>DeleteObject</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~DeleteObject(--obj--)------------------------><


]]>
</programlisting>

<para>The DeleteObject method deletes a graphic object,
namely a pen or a brush. See <link linkend="h001035">CreatePen</link> and <link linkend="h001026">CreateBrush</link> for
information on how to get the handle of a pen or brush. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>obj</term>
<listitem><para>The handle of a pen or brush.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="man0023"><title>Graphic Drawing Methods</title>
<indexterm><primary>graphic drawing methods</primary></indexterm>
<para>The following methods are used to draw rectangles, lines, pixels, and arcs
in a device context. See <link linkend="h001062">GetWindowDC</link>, <link linkend="getdc">GetDC</link>, and <link linkend="h001077">GetButtonDC</link> for how to retrieve a device context. A pen and a brush can
be activated using <link linkend="h000928">ObjectToDC</link> before invoking the
drawing methods.</para>

<note><title>Note</title><para>
Because the pixel values include the title bar in a dialog
it is easier to define a button filling the window, and then draw on the button.
</para></note>

<section id="h001115"><title>Rectangle</title>
<indexterm><primary>Rectangle</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~Rectangle(--dc--,--x--,--y--,--x2--,--y2--+-----------+--)-><
                                                            +-,--"FILL"-+


]]>
</programlisting>

<para>The Rectangle method draws a rectangle to the given
device context. The appearance is determined by the graphics objects currently
active in the device context. The active pen draws the outline and, optionally,
the active brush fills the inside area. The default pen is thin black and
the default brush is white. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>The device context.
</para></listitem></varlistentry>
<varlistentry><term>x, y</term>
<listitem><para>The position of the upper left corner of the rectangle, in pixels.
</para></listitem></varlistentry>
<varlistentry><term>x2, y2</term>
<listitem><para>The position of the lower right corner.
</para></listitem></varlistentry>
<varlistentry><term>&quot;FILL&quot;</term>
<listitem><para>The rectangle is filled with the active brush.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example draws a red rectangle filled with yellow, surrounded
by a black rectangle:

<programlisting>
<![CDATA[
dc = self~getButtonDC(100)
brush = self~createBrush(15)        /* yellow */
pen = self~createPen(10,"solid",13) /* thick red */
oldb = self~objectToDC(dc,brush)
oldp = self~objectToDC(dc,pen)
self~Rectangle(dc, 50, 50, 200, 150, "FILL")
self~objectToDC(dc,oldp); self~deleteObject(pen)
self~objectToDC(dc,oldb); self~deleteObject(brush)
self~Rectangle(dc, 40, 40, 210, 160) /* default */
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001188"><title>DrawLine</title>
<indexterm><primary>DrawLine</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~DrawLine(--dc--,--+-------+--,--+-------+--,--toX--,--toY--)-><
                                    +-fromX-+     +-fromY-+


]]>
</programlisting>

<para>The DrawLine method draws a line within the device
context using the active pen. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>The device context.
</para></listitem></varlistentry>
<varlistentry><term>fromX, fromY</term>
<listitem><para>The starting position, in pixels. If omitted, the previous end point
of a line or arc is used.
</para></listitem></varlistentry>
<varlistentry><term>toX, toY</term>
<listitem><para>The target position.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001200"><title>DrawPixel</title>
<indexterm><primary>DrawPixel</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~DrawPixel(--dc--,--x--,--y--,--color--)------><


]]>
</programlisting>

<para>The DrawPixel method draws a pixel within the device
context. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>The device context.
</para></listitem></varlistentry>
<varlistentry><term>x, y</term>
<listitem><para>The position, in pixels.
</para></listitem></varlistentry>
<varlistentry><term>color</term>
<listitem><para>The color number for the pixel. For a list of color numbers, refer to <link linkend="termdef">Definition of Terms</link>.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001211"><title>GetPixel</title>
<indexterm><primary>GetPixel</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~GetPixel(--dc--,--x--,--y--)-----------------><


]]>
</programlisting>

<para>The GetPixel method returns the color number of a pixel
within the device context. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>The device context.
</para></listitem></varlistentry>
<varlistentry><term>x, y</term>
<listitem><para>The position, in pixels.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001212"><title>DrawArc</title>
<indexterm><primary>DrawArc</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~DrawArc(--dc--,--x--,--Y--,--x2--,--y2-------->

>--+----------------------------------------+--)---------------><
   +-,--startx--,--starty--,--endx--,--endy-+


]]>
</programlisting>

<para>The DrawArc method draws a circle or ellipse on
the given device context using the active pen for the outline. The circle
or ellipse is drawn within the boundaries of an imaginary rectangle whose
coordinates are given. A partial figure can be drawn by giving the end points
of two radials. By default, the figure is drawn counterclockwise, but the
direction can be modified using <link linkend="h001214">SetArcDirection</link>. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>The device context.
</para></listitem></varlistentry>
<varlistentry><term>x, y</term>
<listitem><para>The position of the upper left corner of the imaginary rectangle, in
pixels.
</para></listitem></varlistentry>
<varlistentry><term>x2, y2</term>
<listitem><para>The position of the lower right corner of the imaginary rectangle, in
pixels.
</para></listitem></varlistentry>
<varlistentry><term>startx, starty, endx, endy</term>
<listitem><para>The end points of the starting and ending radials for drawing the figure.
A full circle or ellipse is drawn if no start and end are given. Omitted values
default to 0. Imaginary radials are drawn from the center to the start and
end points. The circle or ellipse is then drawn between the intersections
of these lines with the full circle or ellipse.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>This example draws a full ellipse and a quarter circle:

<programlisting>
<![CDATA[
dc = self~getButtonDC(100)
pen = self~createPen(4,"solid",13)
oldp = self~objectToDC(dc,pen)
self~drawArc(dc,50,50,200,150)                 /* full ellipse */
self~drawArc(dc,100,100,150,150, 200,50,75,75) /* quarter circle */
self~objectToDC(dc,oldp); self~deleteObject(pen)
]]>
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001213"><title>GetArcDirection</title>
<indexterm><primary>GetArcDirection</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~GetArcDirection(--dc--)----------------------><


]]>
</programlisting>

<para>The GetArcDirection method returns the current
drawing direction for the
<link linkend="h001212">DrawArc</link> method. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The only argument is:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>The device context.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001214"><title>SetArcDirection</title>
<indexterm><primary>SetArcDirection</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~SetArcDirection(--dc--,--"--+-COUNTERCLOCKWISE-+--"--)-><
                                              +-CLOCKWISE--------+


]]>
</programlisting>

<para>The SetArcDirection method changes the drawing direction for the
<link linkend="h001212">DrawArc</link> and
<link linkend="h001216">DrawPie</link> methods. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>The device context.
</para></listitem></varlistentry>
<varlistentry><term>direction</term>
<listitem><para>The new drawing direction.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001216"><title>DrawPie</title>
<indexterm><primary>DrawPie</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~DrawPie(--dc--,--x--,--y--,--x2--,--y2-->

>--,--startx--,--starty--,--endx--,--endy--)-------------><


]]>
</programlisting>

<para>The DrawPie method draws a pie of a circle or ellipse
on the given device context using the active pen for the outline and the active
brush to fill the pie. The circle or ellipse is drawn within the boundaries
of an imaginary rectangle whose coordinates are given. The arc is drawn between
start and end radials in the direction specified by <link linkend="h001214">SetArcDirection</link>. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>The device context.
</para></listitem></varlistentry>
<varlistentry><term>x, y</term>
<listitem><para>The position of the upper left corner of the imaginary rectangle, in
pixels.
</para></listitem></varlistentry>
<varlistentry><term>x2, y2</term>
<listitem><para>The position of the lower right corner of the imaginary rectangle.
</para></listitem></varlistentry>
<varlistentry><term>startx, starty, endx, endy</term>
<listitem><para>The end points of the two radials (same as for <link linkend="h001212">DrawArc</link>).
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001217"><title>FillDrawing</title>
<indexterm><primary>FillDrawing</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~FillDrawing(--dc--,--x--,--y--,--color--)----><


]]>
</programlisting>

<para>The FillDrawing method fills an outline figure
in the given device context using the active brush. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>The device context.
</para></listitem></varlistentry>
<varlistentry><term>x, y</term>
<listitem><para>The inside starting position for filling the outline figure with the
color of the brush, in pixels.
</para></listitem></varlistentry>
<varlistentry><term>color</term>
<listitem><para>The color number of the outline figure whose inside will be filled.
For a list of color numbers, refer to <link linkend="termdef">Definition of Terms</link>.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="h001215"><title>DrawAngleArc</title>
<indexterm><primary>DrawAngleArc</primary></indexterm>
<programlisting>
<![CDATA[
>>-aDialogControl~DrawAngleArc(--dc--,--xs--,--ys--,--x--,--y-->

>--,--radius--,--startangle--,--sweepangle--)-----------------><


]]>
</programlisting>

<para>The DrawAngleArc method draws a partial circle
(arc) and a line connecting the start drawing point with the start of the
arc on the given device context using the active pen for the outline. The
circle is drawn counterclockwise with the given radius between the given angles. </para>
<variablelist>
<varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>dc</term>
<listitem><para>The device context.
</para></listitem></varlistentry>
<varlistentry><term>xs, ys</term>
<listitem><para>The start draw position, in pixels.
</para></listitem></varlistentry>
<varlistentry><term>x, y</term>
<listitem><para>The center of the circle, in pixels.
</para></listitem></varlistentry>
<varlistentry><term>radius</term>
<listitem><para>The radius of the circle, in pixels.
</para></listitem></varlistentry>
<varlistentry><term>startangle, sweepangle</term>
<listitem><para>The starting and ending angles for the partial circle in degrees (0
is the x-axis).
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="methodsDialogControlInherited"><title>DialogControl Methods</title>
<indexterm><primary>DialogControl Methods</primary></indexterm>
<para>
  The methods listed in this section are those directly implemented in the DialogControl class.  (As
  opposed to those implemented in the mixin classes that DialogControl inherits from: <link
  linkend="clsWindowBase">WindowBase</link> and <link
  linkend="clsWindowExtensions">WindowExtensions</link>.)  The methods are fully documented in the
  preceding sections.  This section just lists the methods and provides a link to the method's
  documentation.
</para>

&dialogcontrolCommon;

</section>

</chapter>
