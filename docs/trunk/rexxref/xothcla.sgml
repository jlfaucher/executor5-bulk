<!--#########################################################################
    #
    # Description: Open Object Rexx: Reference SGML file.
    #
    # Copyright (c) 2005-2006, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<chapter id="xothcla"><title>Other Classes</title>
<para>This chapter describes the following classes: </para>
<itemizedlist>
<listitem><para>Alarm class</para></listitem>
<listitem><para>Class class</para></listitem>
<listitem><para>Message class</para></listitem>
<listitem><para>Method class</para></listitem>
<listitem><para>Monitor class</para></listitem>
<listitem><para>MutableBuffer class</para></listitem>
<listitem><para>Object class</para></listitem>
<listitem><para>Regular Expression class</para></listitem>
<listitem><para>Stem class</para></listitem>
<listitem><para>Stream class</para></listitem>
<listitem><para>String class</para></listitem>
<listitem><para>Supplier class</para></listitem>
<listitem><para>WindowsProgramManager class</para></listitem>
<listitem><para>WindowsRegistry class</para></listitem>
<listitem><para>WindowsEventLog class</para></listitem>
<listitem><para>WindowsManager class</para></listitem>
<listitem><para>WindowsObject class</para></listitem>
<listitem><para>WindowsMenuObject class</para></listitem>
<listitem><para>WindowsClipboard class</para></listitem>
<listitem><para>Windows OLEObject class</para></listitem></itemizedlist>

<section id="xalcl"><title>The Alarm Class</title>
<indexterm><primary>Alarm class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Alarm class</secondary></indexterm>
<para>An alarm object provides timing and
notification capability by supplying a facility to send any message to any
object at a given time. You can cancel an alarm before it sends its message.
</para>
<para>The Alarm class is a subclass of the Object class.</para>
<para><emphasis role="bold">Methods the Alarm class defines:</emphasis></para>
<simplelist>
<member>CANCEL</member>
<member>INIT (Overrides Object class method)</member>
</simplelist>
<para><emphasis role="bold">Methods inherited from the Object class:</emphasis>
</para>
<simplelist>
<member>NEW (Class Method)</member>
<member>Operator methods:&nbsp;&nbsp;=, ==, \=, >&lt;, &lt;>, \==</member>
<member>CLASS</member>
<member>COPY</member>
<member>DEFAULTNAME</member>
<member>HASMETHOD</member>
<member>OBJECTNAME</member>
<member>OBJECTNAME=</member>
<member>REQUEST</member>
<member>RUN</member>
<member>SETMETHOD</member>
<member>START</member>
<member>STRING</member>
<member>UNSETMETHOD</member>
</simplelist>

<note><title>Note</title>
<para>The Alarm class also has available class methods that its
metaclass, the Class class, defines.</para></note>

<section id="alcan"><title>CANCEL</title>
<indexterm><primary>CANCEL method</primary>
<secondary>of Alarm class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CANCEL method</secondary>
<tertiary>of Alarm class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CANCEL------------------------------------------------------><
]]>
</programlisting>

<para>Cancels the pending alarm request represented by the receiver. This method
takes no action if the specified time has already been reached.</para>
</section>

<section id="alini"><title>INIT</title>
<indexterm><primary>INIT method</primary>
<secondary>of Alarm class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INIT method</secondary>
<tertiary>of Alarm class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-INIT(atime,message)-----------------------------------------><
]]>
</programlisting>

<para>Sets up an alarm for a future time
<emphasis role="italic">atime</emphasis>. At this time, the alarm
object sends the message that <emphasis role="italic">message</emphasis>,
a message object, specifies. (See <link linkend="agent">The Message Class</link>.)
The <emphasis role="italic">atime</emphasis> is a string. You can specify
this in the default format (<computeroutput>&apos;hh:mm:ss&apos;</computeroutput>) or as
a number of seconds
starting at the present time. If you use the default format, you can specify
a date in the default format (<computeroutput>&apos;dd Mmm yyyy&apos;</computeroutput>)
after the time with a single blank separating the time and date. Leading and
trailing blanks are not allowed in the
<emphasis role="italic">atime</emphasis>. If you do not
specify a date, the language processor uses the first future occurrence of the
specified time. You can use the CANCEL method to cancel a pending alarm. See
<link linkend="creo">Initialization</link> for more information.</para>
</section>

<section id="alaex"><title>Examples</title>
<indexterm><primary>examples</primary>
<secondary>of Alarm class</secondary></indexterm>
<para>The following code sets up an alarm at 5:10 p.m. on October 8, 1996.
(Assume today's date is October 5, 1996.)  </para>
<programlisting>
/* Alarm Examples */

PersonalMessage=.MyMessageClass~new("Call the Bank")
msg=.message~new(PersonalMessage,"RemindMe")

a=.alarm~new("17:10:00 8 Oct 1996", msg)
exit
/* <link linkend="clasdi">::CLASS</link>  describes the ::CLASS directive */
/* <link linkend="methd">::METHOD</link>  describes the ::METHOD directive */
::CLASS MyMessageClass public
::Method init
expose inmsg
use arg inmsg
::Method RemindMe
expose inmsg
say "It is now" "TIME"("C")".Please "inmsg
/* On the specified data and time, displays the following message: */
/* "It is now 5:10pm. Please Call the Bank" */
</programlisting>
<para>For the following example, the user uses the same code as in the
preceding example to define <computeroutput>msg</computeroutput>,
a message object to run at the specified time. The following code sets up
an alarm to run the <computeroutput>msg</computeroutput> message
object in 30 seconds from the current time: </para>
<programlisting>
a=.alarm~new(30,msg)
</programlisting>
</section>
</section>

<section id="clss"><title>The Class Class</title>
<indexterm><primary>Class class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Class class</secondary></indexterm>
<para>The Class class is like a factory producing the factories that
produce objects. It is a subclass of the Object class. The instance methods
of the Class class are also the class methods of all classes.</para>
<para><emphasis role="bold">Methods the Class class defines:</emphasis>
(They are all both class and instance methods.) </para>
<simplelist>
<member>BASECLASS</member>
<member>DEFAULTNAME (Overrides Object class method)</member>
<member>DEFINE</member>
<member>DELETE</member>
<member>ENHANCED</member>
<member>ID</member>
<member>INHERIT</member>
<member>INIT (Overrides Object class method)</member>
<member>METACLASS</member>
<member>METHOD</member>
<member>METHODS</member>
<member>MIXINCLASS</member>
<member>NEW (Overrides Object class method)</member>
<member>QUERYMIXINCLASS</member>
<member>SUBCLASS</member>
<member>SUBCLASSES</member>
<member>SUPERCLASSES</member>
<member>UNINHERIT</member>
</simplelist>

<para><emphasis role="bold">Methods inherited from the Object class:</emphasis>
</para>
<simplelist>
<member>Operator methods:&nbsp;&nbsp;=, ==, \=, >&lt;, &lt;>, \==</member>
<member>CLASS</member>
<member>COPY</member>
<member>HASMETHOD</member>
<member>OBJECTNAME</member>
<member>OBJECTNAME=</member>
<member>REQUEST</member>
<member>RUN</member>
<member>SETMETHOD</member>
<member>START</member>
<member>STRING</member>
<member>UNSETMETHOD</member>
</simplelist>

<section id="clbase"><title>BASECLASS</title>
<indexterm><primary>BASECLASS method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>BASECLASS method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-BASECLASS---------------------------------------------------><
]]>
</programlisting>

<para>Returns the base class associated with the class. If the class is a mixin
class, the base class is the first superclass that is not also a mixin class.
If the class is not a mixin class, the base class is the class receiving the
BASECLASS message.</para>
</section>

<section id="cldena"><title>DEFAULTNAME</title>
<indexterm><primary>DEFAULTNAME method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DEFAULTNAME method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-DEFAULTNAME-------------------------------------------------><
]]>
</programlisting>

<para>Returns a short human-readable string representation of the class. The
string returned is of the form </para>
<programlisting>
The id class
</programlisting>
<para> where <emphasis role="italic">id</emphasis> is the identifier assigned
to the class when it was created.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>DEFAULTNAME method</secondary></indexterm>
<programlisting>
say .array~defaultname     /* Displays "The Array class"   */
say .account~defaultname   /* Displays "The ACCOUNT class" */
say .savings~defaultname   /* Displays "The Savings class" */

::class account            /* Name is all upper case       */
::class "Savings"          /* String name is mixed case    */
</programlisting>
</section>

<section id="cldefi"><title>DEFINE</title>
<indexterm><primary>DEFINE method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DEFINE method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-DEFINE(methodname-+---------+-)-----------------------------><
                     +-,method-+
]]>
</programlisting>

<para>Incorporates the method object <emphasis role="italic">method</emphasis>
in the receiver class's collection of instance methods. The language processor
translates the method name <emphasis role="italic">methodname</emphasis>
to uppercase. Using the DEFINE method replaces any existing definition for
<emphasis role="italic">methodname</emphasis> in the receiver class.</para>
<para>If you omit <emphasis role="italic">method</emphasis>, the method name
<emphasis role="italic">methodname</emphasis> is made
unavailable for the receiver class. Sending a message of that name
to an instance of the class causes the UNKNOWN method (if any) to be run.</para>
<para>The <emphasis role="italic">method</emphasis> argument can be a string
containing a method source line instead of a method object. Alternatively, you
can pass an array of strings containing individual method lines. Either way,
DEFINE creates an equivalent method object. </para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>The classes Rexx provides do not permit changes or additions to
their method definitions.</para></listitem>
<listitem><para>The DEFINE method is a protected method.</para></listitem>
</orderedlist>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>DEFINE method</secondary></indexterm>
<programlisting>
bank_account=.object~subclass("Account")
bank_account~define("TYPE",&apos;return "a bank account"&apos;)
</programlisting>
</section>

<section id="cldele"><title>DELETE</title>
<indexterm><primary>DELETE method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DELETE method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-DELETE(methodname)------------------------------------------><
]]>
</programlisting>

<para>Removes the receiver class's definition
for the method name <emphasis role="italic">methodname</emphasis>. If the
receiver class defined <emphasis role="italic">methodname</emphasis> as
unavailable with the DEFINE method, this definition is
nullified. If the receiver class had no definition for
<emphasis role="italic">methodname</emphasis>, no action is taken. </para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>The classes Rexx provides do not permit changes or additions
to their method definitions.</para></listitem>
<listitem><para>DELETE deletes only methods the target class defines. You
cannot delete inherited methods the target's superclasses define.</para>
</listitem>
<listitem><para>The DELETE method is a protected method.</para></listitem>
</orderedlist>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>DELETE method</secondary></indexterm>
<programlisting>
myclass=.object~subclass("Myclass")        /* After creating a class  */
myclass~define("TYPE",&apos;return "my class"&apos;) /* and defining a method   */
myclass~delete("TYPE")                     /* this deletes the method */
</programlisting>
</section>

<section id="obccen"><title>ENHANCED</title>
<indexterm><primary>ENHANCED method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ENHANCED method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-ENHANCED(methods-+---------------+-)------------------------><
                    | +-----------+ |
                    | V           | |
                    +---,argument-+-+
]]>
</programlisting>

<para>Returns an enhanced new instance of the receiver class, with object
methods that are the instance methods of the class, enhanced by the methods in
the collection <emphasis role="italic">methods</emphasis>. The collection
indexes are the names of the enhancing
methods, and the items are the method objects (or strings or arrays of strings
containing method code). (See the description of
<link linkend="cldefi">DEFINE</link>.)
You can use any collection that supports a SUPPLIER method.</para>
<para>ENHANCED sends an INIT message to the created object, passing the
<emphasis role="italic">argument</emphasis>s specified on the ENHANCED method.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>ENHANCED method</secondary></indexterm>
<programlisting>
/* Set up rclass with class method or methods you want in your */
/* remote class */
rclassmeths = .directory~new

rclassmeths["DISPATCH"]=d_source     /* d_source must have code for a  */
                                     /* DISPATCH  method.              */
/* The following sends INIT("Remote Class") to a new instance */
rclass=.class~enhanced(rclassmeths,"Remote Class")
</programlisting>
</section>

<section id="clid"><title>ID</title>
<indexterm><primary>ID method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ID method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-ID----------------------------------------------------------><
]]>
</programlisting>

<para>Returns the class identity (instance) string. (This is the string that
is an argument on the SUBCLASS and MIXINCLASS methods.) The string
representations of the class and its instances contain the class identity.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>ID method</secondary></indexterm>
<programlisting>
myobject=.object~subclass("my object")  /* Creates a subclass    */
say myobject~id                         /* Produces: "my object" */
</programlisting>
</section>

<section id="clinhe"><title>INHERIT</title>
<indexterm><primary>INHERIT method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INHERIT method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-INHERIT(classobj-+-----------+-)----------------------------><
                    +-,classpos-+
]]>
</programlisting>

<para>Causes the receiver class to inherit the instance and class methods of
the class object <emphasis role="italic">classobj</emphasis>. The
<emphasis role="italic">classpos</emphasis> is a class object
that specifies the position of the new superclass in the list of superclasses.
(You can use the SUPERCLASSES method to return the immediate superclasses.)
</para>
<para>The new superclass is inserted in the search order after the specified
class. If the <emphasis role="italic">classpos</emphasis> class is not found in
the set of superclasses, an error is raised. If you do not specify
<emphasis role="italic">classpos</emphasis>, the new superclass
is added to the end of the superclasses list.</para>
<para>Inherited methods can take precedence only over methods defined at or
above the base class of the <emphasis role="italic">classobj</emphasis> in the
class hierarchy. Any subsequent change to the instance methods of
<emphasis role="italic">classobj</emphasis> takes immediate effect
for all the classes that inherit from it.</para>
<para>The new superclass <emphasis role="italic">classobj</emphasis> must be
created with the MIXINCLASS
option of the ::CLASS directive or the MIXINCLASS method and the base class
of the <emphasis role="italic">classobj</emphasis> must be a direct superclass
of the receiver object. The receiver must not already descend from
<emphasis role="italic">classobj</emphasis> in the class
hierarchy and vice versa.</para>
<para>The method search order of the receiver class after INHERIT is the same
as before INHERIT, with the addition of
<emphasis role="italic">classobj</emphasis> and its superclasses
(if not already present). </para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>You cannot change the classes that Rexx provides by sending
INHERIT messages.</para></listitem>
<listitem><para>The INHERIT method is a protected method.</para></listitem>
</orderedlist>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>INHERIT method</secondary></indexterm>
<programlisting>
room~inherit(.location)
</programlisting>
</section>

<section id="clina"><title>INIT</title>
<indexterm><primary>INIT method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INIT method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-INIT(classid)-----------------------------------------------><
]]>
</programlisting>

<para>Sets the receiver class identity to the string
<emphasis role="italic">classid</emphasis>. You can
use the ID method (described previously) to return this string, which is the
class identity. See <link linkend="creo">Initialization</link> for more
information.</para>
</section>

<section id="clmeta"><title>METACLASS</title>
<indexterm><primary>METACLASS method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>METACLASS method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-METACLASS---------------------------------------------------><
]]>
</programlisting>
<para>Returns the receiver class's default metaclass. This is the class used
to create subclasses of this class when you send SUBCLASS or MIXINCLASS messages
(with no metaclass arguments). If the receiver class is an object class (see
<link linkend="objcla">Object Classes</link>), this is also the class used to
create the receiver class.
The instance methods of the default metaclass are the class methods of the
receiver class. For more information about class methods, see
<link linkend="objcla">Object Classes</link>.
See also the description of the SUBCLASS method in
<link linkend="clsubc">SUBCLASS</link>.</para>
</section>

<section id="clmeth"><title>METHOD</title>
<indexterm><primary>METHOD method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>METHOD method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-METHOD(methodname)------------------------------------------><
]]>
</programlisting>

<para>Returns the method object for the receiver class's definition for the
method name <emphasis role="italic">methodname</emphasis>. If the receiver
class defined <emphasis role="italic">methodname</emphasis> as unavailable,
this method returns the NIL object. If the receiver
class did not define <emphasis role="italic">methodname</emphasis>, the
language processor raises an error.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>METHOD method</secondary></indexterm>
<programlisting>
/* Create and retrieve the method definition of a class */
myclass=.object~subclass("My class")   /* Create a class         */
mymethod=.method~new(" ","Say arg(1)") /* Create a method object */
myclass~define("ECHO",mymethod)        /* Define it in the class */
method_source = myclass~method("ECHO")~source     /* Extract it  */
say method_source                 /* Says "an Array"              */
say method_source[1]              /* Shows the method source code */
</programlisting>
</section>

<section id="clmets"><title>METHODS</title>
<indexterm><primary>METHODS method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>METHODS method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-METHODS-+----------------+----------------------------------><
           +-(class_object)-+
]]>
</programlisting>

<para>Returns a supplier object for all the instance methods of the receiver
class and its superclasses, if you specify no argument. If
<emphasis role="italic">class_object</emphasis> is the NIL object, METHODS
returns a supplier object for only the instance
methods of the receiver class. If you specify a
<emphasis role="italic">class_object</emphasis>,
this method returns a supplier object containing only the instance methods
that <emphasis role="italic">class_object</emphasis> defines. If you send
appropriate messages to
a supplier object, the supplier enumerates all the instance methods existing
at the time of the supplier's creation. (See
<link linkend="supp">The Supplier Class</link> for details.)</para>

<note><title>Note</title>
<para>Methods that have been hidden with a SETMETHOD or DEFINE method
are included with the other methods that METHODS returns. The hidden methods
have the NIL object for the associated method.</para></note>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>METHODS method</secondary></indexterm>
<programlisting>
objsupp=.object~methods
do while objsupp~available
say objsupp~index           /* Says all instance methods */
objsupp~next                /* of the Object class       */
end
</programlisting>
</section>

<section id="clmixi"><title>MIXINCLASS</title>
<indexterm><primary>MIXINCLASS method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MIXINCLASS method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MIXINCLASS(classid-+-------------------------+-)------------><
                      +-,metaclass-+----------+-+
                                   +-,methods-+
]]>
</programlisting>

<para>Returns a new mixin subclass of the receiver class. You can use this
method to create a new mixin class that is a subclass of the superclass to
which you send the message. The <emphasis role="italic">classid</emphasis>
is a string that identifies the new mixin subclass. You can use the ID method
to retrieve this string.</para>
<para>The <emphasis role="italic">metaclass</emphasis> is a class object. If
you specify <emphasis role="italic">metaclass</emphasis>, the new subclass is
an instance of <emphasis role="italic">metaclass</emphasis>. (A metaclass is a
class that you can use to create a class, that is, a class
whose instances are classes. The Class class and its subclasses are metaclasses.)
</para>
<para>If you do not specify a <emphasis role="italic">metaclass</emphasis>,
the new mixin subclass is an
instance of the default metaclass of the receiver class. For subclasses of
the Object class, the default metaclass is the Class class.</para>
<para>The <emphasis role="italic">methods</emphasis> is a collection whose
indexes are the names of methods
and whose items are method objects (or strings or arrays of strings containing
method code). If you specify <emphasis role="italic">methods</emphasis>, the new
class is enhanced with class methods from this collection. (The metaclass of
the new class is not affected.)</para>
<para>The METACLASS method returns the metaclass of a class.</para>
<para>The method search order of the new subclass is the same as that of the
receiver class, with the addition of the new subclass at the start of the
order.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>MIXINCLASS method</secondary></indexterm>
<programlisting>
buyable=.object~mixinclass("Buyable")  /* New subclass is buyable    */
                                       /* Superclass is Object class */
</programlisting>
</section>

<section id="coconw"><title>NEW</title>
<indexterm><primary>NEW method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>NEW method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-NEW-+---------------+---------------------------------------><
       |    +-,---+    |
       |    V     |    |
       +-(----arg-+--)-+
]]>
</programlisting>

<para>Returns a new instance of the receiver class, whose object methods are
the instance methods of the class. This method initializes a new instance
by running its INIT methods. (See
<link linkend="creo">Initialization</link>.) NEW also sends an
INIT message. If you specify args, NEW passes these
arguments on the INIT message.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>NEW method</secondary></indexterm>
<programlisting>
<![CDATA[
/* NEW method example */
a = .account~new             /* -> Object variable balance=0           */
y = .account~new(340.78)     /* -> Object variable balance=340.78      */
                             /*    plus free toaster oven              */
::class account subclass object
::method INIT                /* Report time each account created       */
                             /* plus free toaster when more than $100  */
Expose balance
Arg opening_balance
Say "Creating" self~objectname "at time" time()
If datatype(opening_balance, "N") then balance = opening_balance
else balance = 0
If balance > 100 then Say "  You win a free toaster oven"
]]>
</programlisting>
</section>

<section id="clqmc"><title>QUERYMIXINCLASS</title>
<indexterm><primary>QUERYMIXINCLASS method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>QUERYMIXINCLASS method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-QUERYMIXINCLASS---------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the class is a
mixin class, or <computeroutput>0</computeroutput> (false).</para>
</section>

<section id="clsubc"><title>SUBCLASS</title>
<indexterm><primary>SUBCLASS method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SUBCLASS method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SUBCLASS(classid-+-------------------------+-)--------------><
                    +-,metaclass-+----------+-+
                                 +-,methods-+
]]>
</programlisting>

<para>Returns a new subclass of the receiver class. You can use this method to
create a new class that is a subclass of the superclass to which you send
the message. The <emphasis role="italic">classid</emphasis> is a string that
identifies the subclass. (You can use the ID method to retrieve this string.)
</para>
<para>The <emphasis role="italic">metaclass</emphasis> is a class object. If
you specify <emphasis role="italic">metaclass</emphasis>, the new subclass is
an instance of <emphasis role="italic">metaclass</emphasis>. (A metaclass is a
class that you can use to create a class, that is, a class
whose instances are classes. The Class class and its subclasses are metaclasses.)
</para>
<para>If you do not specify a <emphasis role="italic">metaclass</emphasis>,
the new subclass is an instance
of the default metaclass of the receiver class. For subclasses of the Object
class, the default metaclass is the Class class.</para>
<para>The <emphasis role="italic">methods</emphasis> is a collection whose
indexes are the names of methods
and whose items are method objects (or strings or arrays of strings containing
method code). If you specify <emphasis role="italic">methods</emphasis>,
the new class is enhanced with class methods from this collection.
(The metaclass of the new class is not affected.)</para>
<para>The METACLASS method returns the metaclass of a class.</para>
<para>The method search order of the new subclass is the same as that of the
receiver class, with the addition of the new subclass at the start of the
order.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>SUBCLASS method</secondary></indexterm>
<programlisting>
room=.object~subclass("Room")   /* Superclass is .object     */
                                /* Subclass is room          */
                                /* Subclass identity is Room */
</programlisting>
</section>

<section id="clsubs"><title>SUBCLASSES</title>
<indexterm><primary>SUBCLASSES method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SUBCLASSES method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SUBCLASSES--------------------------------------------------><
]]>
</programlisting>

<para>Returns the immediate subclasses of the receiver
class in the form of a single-index array of the required size, in an
unspecified order. (The program should not rely on any order.) The array
indexes range from 1 to the number of subclasses.</para>
</section>

<section id="clsupe"><title>SUPERCLASSES</title>
<indexterm><primary>SUPERCLASSES method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SUPERCLASSES method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SUPERCLASSES------------------------------------------------><
]]>
</programlisting>

<para>Returns the immediate superclasses of the receiver class in the form of
a single-index array of the required size. The immediate superclasses are
the original class used on a SUBCLASS or a MIXINCLASS method, plus any additional
superclasses defined with the INHERIT method. The array is in the order in
which the class has inherited the classes. The original class used on a SUBCLASS
or MIXINCLASS method is the first item of the array. The array indexes range
from <computeroutput>1</computeroutput> to the number of superclasses.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>SUPERCLASSES method</secondary></indexterm>
<programlisting>
z=.class~superclasses
/* To obtain the information this returns, you could use:     */
do i over z
  say i
end
</programlisting>
</section>

<section id="clunin"><title>UNINHERIT</title>
<indexterm><primary>UNINHERIT method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>UNINHERIT method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-UNINHERIT(classobj)-----------------------------------------><
]]>
</programlisting>

<para>Nullifies the effect of any previous INHERIT message
sent to the receiver for the class <emphasis role="italic">classobj</emphasis>.
</para>

<note><title>Note</title>
<para>You
cannot change the classes that Rexx provides by sending UNINHERIT messages.
</para></note>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>UNINHERIT method</secondary></indexterm>
<programlisting>
location=.object~mixinclass("Location")
room=.object~subclass("Room")~~inherit(location) /* Creates subclass */
/* and specifies inheritance */
room~UNINHERIT(location)
</programlisting>
</section>
</section>

<section id="menuobjectcl"><title>The WindowsMenuObject Class</title>
<indexterm><primary>MenuObject class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>MenuObject class</secondary></indexterm>
<para>The MenuObject class provides methods to query, manipulate, and  interact
with the menu or submenu of a window.</para>
<para><emphasis role="bold">Methods the MenuObject Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>FINDITEM</para></listitem>
<listitem><para>FINDSUBMENU</para></listitem>
<listitem><para>IDOF</para></listitem>
<listitem><para>ISMENU</para></listitem>
<listitem><para>ITEMS</para></listitem>
<listitem><para>PROCESSITEM</para></listitem>
<listitem><para>SUBMENU</para></listitem>
<listitem><para>TEXTOF(id)</para></listitem>
<listitem><para>TEXTOF(position)</para></listitem></itemizedlist>

<section id="ismenumo"><title>ISMENU</title>
<indexterm><primary>ISMENU method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ISMENU method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-ISMENU------------------------------------------------------><
]]>
</programlisting>

<para>Returns 1 if the associated window is a menu, otherwise 0.</para>
</section>

<section id="itemsmo"><title>ITEMS</title>
<indexterm><primary>ITEMS method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ITEMS method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-ITEMS-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of menu items contained in the associated menu.</para>
</section>

<section id="idofmo"><title>IDOF</title>
<indexterm><primary>IDOF method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>IDOF method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-IDOF--(--position--)----------------------------------------><
]]>
</programlisting>

<para>Returns the ID of the menu item at the specified
<emphasis role="italic">position</emphasis>, starting with 0.</para>
</section>

<section id="textofpositionmo"><title>TEXTOF(position)</title>
<indexterm><primary>TEXTOF(position) method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>TEXTOF(position) method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-TEXTOF--(--position--)--------------------------------------><
]]>
</programlisting>

<para>Returns the text of the menu item at the specified
<emphasis role="italic">position</emphasis>, starting
with 0. A mnemonic (underscored letter) is represented by a leading ampersand
(&amp;). If the menu item contains an accelerator, it is separated by a tab.
</para>
</section>

<section id="textofidmo"><title>TEXTOF(id)</title>
<indexterm><primary>TEXTOF(id) method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>TEXTOF(id) method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-TEXTOF--(--id--)--------------------------------------------><
]]>
</programlisting>

<para>Returns the text of menu item <emphasis role="italic">id</emphasis>.
A mnemonic is represented by a leading ampersand (&amp;). If the menu item
contains an accelerator, it is separated by a tab.</para>
</section>

<section id="submenumo"><title>SUBMENU</title>
<indexterm><primary>SUBMENU method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SUBMENU method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SUBMENU--(--position--)-------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the MenuObject class that is associated with the
submenu at the specified <emphasis role="italic">position</emphasis>,
starting with 0. If no submenu
exists at this position, the .NIL object is returned.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
sub = menu~Submenu(5)
    if sub \= .Nil then do
         say "Items:" sub~items
    end
</programlisting>
</section>

<section id="findsubmenumo"><title>FINDSUBMENU</title>
<indexterm><primary>FINDSUBMENU method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>FINDSUBMENU method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-FINDSUBMENU--(--label--)------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the MenuObject class that is associated with the
submenu with the specified <emphasis role="italic">label</emphasis>.
If the associated menu does not
contain such a submenu, the .NIL object is returned.</para>
</section>

<section id="finditemmo"><title>FINDITEM</title>
<indexterm><primary>FINDITEM method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>FINDITEM method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-FINDITEM--(--label--)---------------------------------------><
]]>
</programlisting>

<para>Returns the ID of the menu item <emphasis role="italic">label</emphasis>.
If the specified label
does not include an accelerator, the comparison excludes the accelerators
of the menu items. If no menu item is found that matches the specified label,
0 is returned.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
f = menu~FindItem("&amp;Tools" || "9"x || "Ctrl+T")
    if f \= 0 then menu~ProcessItem(f)
</programlisting>
</section>

<section id="processitemmo"><title>PROCESSITEM</title>
<indexterm><primary>PROCESSITEM method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>PROCESSITEM method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-PROCESSITEM--(--id--)---------------------------------------><
]]>
</programlisting>

<para>Selects the menu item <emphasis role="italic">id</emphasis>. This causes
a WM_COMMAND to be sent to the window owning the menu.</para>
</section>
</section>

<section id="agent"><title>The Message Class</title>
<indexterm><primary>Message class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Message class</secondary></indexterm>
<para>A message object provides for the deferred or
asynchronous sending of a message. You can create a message object by using
the NEW or ENHANCED method of the Message class or the START method of the
Object class (see <link linkend="obstar">START</link>). The Message class is
a subclass of the Object class.</para>
<para><emphasis role="bold">Methods the Message class defines:</emphasis>
</para>
<simplelist>
<member>COMPLETED</member>
<member>ERRORCONDITION</member>
<member>HASERROR</member>
<member>INIT (Overrides Object class method)</member>
<member>NOTIFY</member>
<member>RESULT</member>
<member>SEND</member>
<member>START (Overrides Object class method)</member>
</simplelist>

<para><emphasis role="bold">Methods inherited from the Object class:</emphasis>
</para>
<simplelist>
<member>NEW (Class method)</member>
<member>Operator methods:&nbsp;&nbsp;=, ==, \=, >&lt;, &lt;>, \==</member>
<member>CLASS</member>
<member>COPY</member>
<member>DEFAULTNAME</member>
<member>HASMETHOD</member>
<member>OBJECTNAME</member>
<member>OBJECTNAME=</member>
<member>REQUEST</member>
<member>RUN</member>
<member>SETMETHOD</member>
<member>STRING</member>
<member>UNSETMETHOD</member>
</simplelist>

<note><title>Note</title>
<para>The Message class also has available class methods that its
metaclass, the Class class, defines.</para></note>

<section id="mescom"><title>COMPLETED</title>
<indexterm><primary>COMPLETED method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>COMPLETED method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-COMPLETED---------------------------------------------------><
]]>
</programlisting>
<para>Returns <computeroutput>1</computeroutput> if the message object has
completed its message, or <computeroutput>0</computeroutput>. You can use this
method instead of sending RESULT and waiting for
the message to complete.</para>
</section>

<section id="msgerrcond"><title>ERRORCONDITION</title>
<indexterm><primary>ERRORCONDITION method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ERRORCONDITION method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-ERRORCONDITION----------------------------------------------><
]]>
</programlisting>

<para>Returns an error condition object from an execution error in the message
object's message. If the message completed normally, or is still executing,
ERRORCONDITION returns the .nil object.</para>
</section>

<section id="msghaserr"><title>HASERROR</title>
<indexterm><primary>HASERROR method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>HASERROR method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-HASERROR----------------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> if the message object's
message was terminated with an error condition. Returns
<computeroutput>0</computeroutput> if the message has not completed or
completed without error.</para>
</section>

<section id="aginita"><title>INIT</title>
<indexterm><primary>INIT method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INIT method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-INIT(target,messagename-+-------------------------------+-)-><
                           |             +---------------+ |
                           |             V               | |
                           +-,Individual---+-----------+-+-+
                           |               +-,argument-+   |
                           +-,Array,argument---------------+
]]>
</programlisting>

<para>Initializes the message object for sending the message name
<emphasis role="italic">messagename</emphasis> to object
<emphasis role="italic">target</emphasis>.</para>
<para>The <emphasis role="italic">messagename</emphasis> can be a string or an
array. If <emphasis role="italic">messagename</emphasis> is an array object,
its first item is the name of the message and its
second item is a class object to use as the starting point for the method
search. For more information, see
<link linkend="meths">Classes and Inheritance of Methods</link>.</para>
<para>If you specify the Individual or Array option, any remaining arguments
are arguments for the message. (You need to specify only the first letter;
the language processor ignores all characters following it.) </para>
<variablelist>
<varlistentry><term>Individual</term>
<listitem><para>If you specify this option, specifying
<emphasis role="italic">argument</emphasis> is optional.
The language processor passes any <emphasis role="italic">argument</emphasis>s
as message arguments
to <emphasis role="italic">target</emphasis> in the order you specify them.
</para></listitem></varlistentry>
<varlistentry><term>Array</term>
<listitem><para>If you specify this option, you must specify an
<emphasis role="italic">argument</emphasis>, which
is an array object. (See <link linkend="xarray">The Array Class</link>.)
The language processor then passes the member items of the array to
<emphasis role="italic">target</emphasis>. When the language
processor passes the arguments taken from the array, the first argument is
at index 1, the second argument at index 2, and so on. If you omitted any
indexes when creating the array, the language processor omits their
corresponding message arguments when passing the arguments.
</para></listitem></varlistentry>
</variablelist>
<para>If you specify neither Individual nor Array, the message sent has no
arguments. </para>

<note><title>Note</title>
<para>This method does not send the message
<emphasis role="italic">messagename</emphasis> to object
<emphasis role="italic">target</emphasis>. The SEND or START method
(described later) sends the message.
</para></note>
</section>

<section id="agnoti"><title>NOTIFY</title>
<indexterm><primary>NOTIFY method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>NOTIFY method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-NOTIFY(message)---------------------------------------------><
]]>
</programlisting>

<para>Requests notification about the completion of processing of the message
SEND or START. The message object <emphasis role="italic">message</emphasis>
is sent as the notification. You can use NOTIFY to request any number of
notifications. After the notification
message, you can use the RESULT method to obtain any result from the messages
SEND or START.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>NOTIFY method</secondary></indexterm>
<programlisting>
/* Event-driven greetings */

.prompter~new~prompt(.nil)

:class prompter

::method prompt
  expose name
  use arg msg

  if msg \= .nil then do
    name = msg~result
    if name = "quit" then return
    say "Hello," name
  end

  say &apos;Enter your name ("quit" to quit):&apos;

  /* Send the public default object .INPUT a LINEIN message asynchronously */
  msg=.message~new(.input,"LINEIN")~~start

  /* Sends self~prompt(msg) when data available   */
  msg~notify(.message~new(self,"PROMPT","I",msg))

  /* Don&apos;t leave until user has entered "quit"    */
  guard on when name="quit"
  </programlisting>
</section>

<section id="agresu"><title>RESULT</title>
<indexterm><primary>RESULT method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>RESULT method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-RESULT------------------------------------------------------><
]]>
</programlisting>

<para>Returns the result of the message SEND or START.
If message processing is not yet complete, this method waits until it completes.
If the message SEND or START raises an error condition, this method also raises
an error condition.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
/* Example using RESULT method */
string="700"                 /* Create a new string object, string   */
bond=string~start("REVERSE") /* Create a message object, bond, and   */
                             /* start it.  This sends a REVERSE      */
                             /* message to string, giving bond       */
                             /* the result.                          */

/* Ask bond for the result of the message */
say "The result of message was" bond~result     /* Result is 007     */
</programlisting>
</section>

<section id="mssend"><title>SEND</title>
<indexterm><primary>SEND method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SEND method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SEND--+----------+------------------------------------------><
         +-(target)-+
]]>
</programlisting>

<para>Returns the result (if any) of sending the message. If you specify
<emphasis role="italic">target</emphasis>, this method sends the message to
<emphasis role="italic">target</emphasis>. Otherwise,
this method sends the message to the <emphasis role="italic">target</emphasis>
you specified when the message object was created. SEND does
not return until message processing is complete.</para>
<para>You can use the NOTIFY method to request notification that message
processing is complete. You can use the RESULT method to obtain any result
from the message.</para>
</section>

<section id="msstrt"><title>START</title>
<indexterm><primary>START method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>START method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-START--+----------+-----------------------------------------><
          +-(target)-+
]]>
</programlisting>


<para>Sends the message to start processing at a specific target whereas
the sender continues processing. If you specify
<emphasis role="italic">target</emphasis>, this method
sends the message to <emphasis role="italic">target</emphasis>. Otherwise, this
method sends the message to the <emphasis role="italic">target</emphasis>
that you specified when the message object was created.
This method returns as soon as possible and does not wait until
message processing is complete. When message processing is complete, the
message object retains any result and holds it until the sender requests it
by sending a RESULT message. You can use the NOTIFY method to request
notification that message processing is complete.</para>
</section>

<section id="exam"><title>Example</title>
<indexterm><primary>examples</primary>
<secondary>START method</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>of Message class</secondary></indexterm>
<programlisting>
/* Using Message class methods */
/* Note: In the following example, ::METHOD directives define class Testclass */
                                                 /* with method SHOWMSG       */

ez=.testclass~new                  /* Creates a new instance of Testclass     */
mymsg=ez~start("SHOWMSG","Hello, Ollie!",5)      /* Creates and starts        */
                                                 /* message mymsg to send     */
                                                 /* SHOWMSG to ez             */

/* Continue with main processing while SHOWMSG runs concurrently              */
do 5
  say "Hello, Stan!"
end

/* Get final result of the SHOWMSG method from the mymsg message object       */
say mymsg~result
say "Goodbye, Stan..."
exit

::class testclass public             /* Directive defines Testclass           */

::method showmsg                     /* Directive creates new method SHOWMSG  */
use arg text,reps                    /* class Testclass                       */
do reps
  say text
end
reply "Bye Bye, Ollie..."
return
</programlisting>
<para>The following output is possible: </para>
<programlisting>
Hello, Ollie!
Hello, Stan!
Hello, Ollie!
Hello, Stan!
Hello, Ollie!
Hello, Stan!
Hello, Ollie!
Hello, Stan!
Hello, Ollie!
Hello, Stan!
Bye Bye, Ollie...
Goodbye, Stan...
</programlisting>
</section>
</section>

<section id="mcls"><title>The Method Class</title>
<indexterm><primary>Method class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Method class</secondary></indexterm>
<para>The Method class creates method objects from Rexx source code.
It is a subclass of the Object class.</para>
<para><emphasis role="bold">Methods the Method class defines:</emphasis></para>
<simplelist>
<member>NEW (Class method. Overrides Object class method.)</member>
<member>NEWFILE (Class method)</member>
<member>SETGUARDED</member>
<member>SETPRIVATE</member>
<member>SETPROTECTED</member>
<member>SETSECURITYMANAGER</member>
<member>SETUNGUARDED</member>
<member>SOURCE</member>
</simplelist>

<para><emphasis role="bold">Methods inherited from the Object class:</emphasis>
</para>
<simplelist>
<member>Operator methods:&nbsp;&nbsp;=, ==, \=, >&lt;, &lt;>, \==</member>
<member>CLASS</member>
<member>COPY</member>
<member>DEFAULTNAME</member>
<member>HASMETHOD</member>
<member>INIT</member>
<member>OBJECTNAME</member>
<member>OBJECTNAME=</member>
<member>REQUEST</member>
<member>RUN</member>
<member>SETMETHOD</member>
<member>START</member>
<member>STRING</member>
<member>UNSETMETHOD</member>
</simplelist>

<note><title>Note</title>
<para>The Method class also has available class methods that its
metaclass, the Class class, defines.</para></note>

<section id="menew"><title>NEW  (Class Method)</title>
<indexterm><primary>NEW method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>NEW method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-NEW(name,source--+------------------+---)-------------------><
                    +--, methodobject--+
]]>
</programlisting>

<para>Returns a new instance of method class, which is an executable
representation of the code contained in the
<emphasis role="italic">source</emphasis>. The
<emphasis role="italic">name</emphasis> is a string.
The <emphasis role="italic">source</emphasis> can be a single string or an
array of strings containing individual method lines.</para>

<para>The third parameter influences the scope of the method. If none is
given, the program scope is used. If another method object is given,
its scope is used.</para>

</section>

<section id="newfile"><title>NEWFILE (Class Method)</title>
<indexterm><primary>NEWFILE method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>NEWFILE method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-NEWFILE(filename)-------------------------------------------><
]]>
</programlisting>

<para>Returns a new instance of method class, which is an executable
representation of the code contained in the file filename. The filename is a
string.</para>
<para>For an example of the use of this method, see the code example
<link linkend="servex">Server implements Security Manager</link>.</para>
</section>

<section id="setgua"><title>SETGUARDED</title>
<indexterm><primary>SETGUARDED method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SETGUARDED method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<indexterm><primary>concurrency</primary>
<secondary>SETGUARDED method</secondary></indexterm>
<programlisting>
<![CDATA[
>>-SETGUARDED--------------------------------------------------><
]]>
</programlisting>

<para>Reverses any previous SETUNGUARDED messages, restoring the receiver to
the default guarded status. If the receiver is already guarded, a SETGUARDED
message has no effect.</para>
</section>

<section id="mesetp"><title>SETPRIVATE</title>
<indexterm><primary>SETPRIVATE method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SETPRIVATE method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SETPRIVATE--------------------------------------------------><
]]>
</programlisting>

<para>Specifies that a method is a private method. Only
a message that an object sends to itself can run a private method. If a method
object does not receive a SETPRIVATE message, the method is a public method.
(Any object can send a message to run a public method. See
<link linkend="pubpri">Public and Private Methods</link> for
details.)</para>
</section>

<section id="mesetpro"><title>SETPROTECTED</title>
<indexterm><primary>SETPROTECTED method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SETPROTECTED method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SETPROTECTED------------------------------------------------><
]]>
</programlisting>

<para>Specifies thata method is a protected method. If a method
object does not receive a SETPROTECTED message, the method is not protected.
(See <link linkend="secman">The Security Manager</link> for details.)</para>
</section>

<section id="mesetsec"><title>SETSECURITYMANAGER</title>
<indexterm><primary>SETSECURITYMANAGER method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SETSECURITYMANAGER method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SETSECURITYMANAGER--+---------------------------+-----------><
                       +-(security_manager_object)-+
]]>
</programlisting>

<para>Replaces the existing security manager with the specified
<emphasis role="italic">security_manager_object</emphasis>. If
<emphasis role="italic">security_manager_object</emphasis> is omitted, any
existing security manager is removed.</para>
</section>

<section id="setnow"><title>SETUNGUARDED</title>
<indexterm><primary>SETUNGUARDED method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SETUNGUARDED method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<indexterm><primary>concurrency</primary>
<secondary>SETUNGUARDED method</secondary></indexterm>
<programlisting>
<![CDATA[
>>-SETUNGUARDED------------------------------------------------><
]]>
</programlisting>

<para>Lets an object run a method even when
another method is active on the same object. If a method object does not receive
a SETUNGUARDED message, it requires exclusive use of its object variable pool.
A method can be active for an object only when no other method requiring exclusive
access to the object's variable pool is active in the same object. This
restriction does not apply if an object sends itself a message to run a method
and it already has exclusive use of the same object variable pool. In this
case, the method runs immediately and has exclusive use of its object variable
pool, regardless of whether it received a SETUNGUARDED message.</para>
</section>

<section id="mesour"><title>SOURCE</title>
<indexterm><primary>SOURCE method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SOURCE method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SOURCE------------------------------------------------------><
]]>
</programlisting>

<para>Returns the method source code as a single-index array of source
lines. If the source code is not available, SOURCE returns an array of zero
items.</para>
</section>
</section>

<section id="moncla"><title>The Monitor Class</title>
<indexterm><primary>Monitor class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Monitor class</secondary></indexterm>
<para>The Monitor class forwards messages to a destination object. It is a
subclass of the Object class.</para>
<para><emphasis role="bold">Methods the Monitor class defines:</emphasis></para>
<simplelist>
<member>CURRENT</member>
<member>DESTINATION</member>
<member>INIT (Overrides Object class method)</member>
<member>UNKNOWN</member>
</simplelist>

<para><emphasis role="bold">Methods inherited from the Object class:</emphasis>
</para>
<simplelist>
<member>NEW (Class method)</member>
<member>Operator methods:&nbsp;&nbsp;=, ==, \=, >&lt;, &lt;>, \==</member>
<member>CLASS</member>
<member>COPY</member>
<member>DEFAULTNAME</member>
<member>HASMETHOD</member>
<member>OBJECTNAME</member>
<member>OBJECTNAME=</member>
<member>REQUEST</member>
<member>RUN</member>
<member>SETMETHOD</member>
<member>START</member>
<member>STRING</member>
<member>UNSETMETHOD</member>
</simplelist>


<note><title>Note</title>
<para>The Monitor class also has available class methods that its
metaclass, the Class class, defines.</para></note>

<section id="moncur"><title>CURRENT</title>
<indexterm><primary>CURRENT method</primary>
<secondary>of Monitor class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CURRENT method</secondary>
<tertiary>of Monitor class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CURRENT-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the current destination object.</para>
</section>

<section id="mondes"><title>DESTINATION</title>
<indexterm><primary>DESTINATION method</primary>
<secondary>of Monitor class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DESTINATION method</secondary>
<tertiary>of Monitor class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-DESTINATION--+---------------+------------------------------><
                +-(destination)-+
]]>
</programlisting>

<para>Returns a new destination object. If you specify
<emphasis role="italic">destination</emphasis>,
this becomes the new destination for any forwarded messages. If you omit
<emphasis role="italic">destination</emphasis>, the previous destination
object becomes the new destination for any forwarded messages.</para>
</section>

<section id="monini"><title>INIT</title>
<indexterm><primary>INIT method</primary>
<secondary>of Monitor class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INIT method</secondary>
<tertiary>of Monitor class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-INIT--+---------------+-------------------------------------><
         +-(destination)-+
]]>
</programlisting>

<para>Initializes the newly created monitor object.</para>
</section>

<section id="monunk"><title>UNKNOWN</title>
<indexterm><primary>UNKNOWN method</primary>
<secondary>of Monitor class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>UNKNOWN method</secondary>
<tertiary>of Monitor class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-UNKNOWN(messagename,messageargs)----------------------------><
]]>
</programlisting>

<para>Reissues or forwards to the current monitor destination all unknown
messages sent to a monitor object. For additional information, see
<link linkend="unkno">Defining an UNKNOWN Method</link>.</para>
</section>

<section id="monex"><title>Examples</title>
<indexterm><primary>examples</primary>
<secondary>of Monitor class</secondary></indexterm>
<programlisting>
.local~setentry("output",.monitor~new(.stream~new("my.new")~~command("open nobuffer")))

/* The following sets the destination */
previous_destination=.output~destination(.stream~new("my.out")~~command("open write"))
/* The following resets the destination */
.output~destination

.output~destination(.STDOUT)
current_output_destination_stream_object=.output~current
</programlisting>
</section>
</section>

<section id="mutablebuffer"><title>The MutableBuffer Class</title>
<indexterm><primary>MutableBuffer class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>MutableBuffer class</secondary></indexterm>

<para>The MutableBuffer class is a buffer that contains a string on which
certain string operations such as concatenation can be performed very
efficiently. (Frequent concatenation of long strings without using this
class might result in weak performance, large memory allocation, or both.)
</para>

<para><emphasis role="bold">Methods the MutableBuffer class defines:</emphasis></para>
<simplelist>
<member>Init</member>
<member>Append</member>
<member>Delete</member>
<member>GetBufferSize</member>
<member>Insert</member>
<member>Length</member>
<member>Overlay</member>
<member>SetBufferSize</member>
<member>String</member>
<member>Substr</member>
</simplelist>

<para><emphasis role="bold">Methods inherited from the Object class:</emphasis>
</para>
<simplelist>
<member>Operator methods:&nbsp;&nbsp;=, ==, \=, >&lt;, &lt;>, \==</member>
<member>CLASS</member>
<member>COPY</member>
<member>DEFAULTNAME</member>
<member>HASMETHOD</member>
<member>OBJECTNAME</member>
<member>OBJECTNAME=</member>
<member>REQUEST</member>
<member>RUN</member>
<member>SETMETHOD</member>
<member>START</member>
<member>STRING</member>
<member>UNSETMETHOD</member>
</simplelist>

<section><title>INIT</title>
<indexterm><primary>INIT method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INIT method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
                    +-----,-256------+
>>-INIT(-+--------+-+----------------+-)-------------------><
         +-string-+ +-,-buffer size--+
]]>
</programlisting>

<para>Initialize the buffer, optionally assign a buffer content and
a starting <emphasis>buffer size</emphasis>. The default size is 256; the buffer
size increases to the length of the <emphasis>string</emphasis> if the string
does not fit into the buffer.</para>
</section>

<section><title>APPEND</title>
<indexterm><primary>APPEND method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>APPEND method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-APPEND(string)------------------------------------------><
]]>
</programlisting>

<para>Appends string string to the buffer content. The buffer size
is increased if necessary.</para>
</section>

<section><title>DELETE</title>
<indexterm><primary>DELETE method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DELETE method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-DELETE(n---+---------+--)-------------------------------><
              +-,length-+
]]>
</programlisting>

<para>Deletes <emphasis>length</emphasis> characters from the buffer beginning
at the <emphasis>n</emphasis>'th character. If length is omitted, or if length
is greater than the number of characters from <emphasis>n</emphasis> to the end
of the buffer, the method deletes the remaining buffer contents (including
the <emphasis>n</emphasis>'th character). The length must be a positive integer
or zero. The <emphasis>n</emphasis> must be a positive integer. If
<emphasis>n</emphasis> is greater than
the length of the buffer or zero, the method does not modify the
buffer content.</para>
</section>

<section><title>GETBUFFERSIZE</title>
<indexterm><primary>GETBUFFERSIZE method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>GETBUFERSIZE method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-GETBUFFERSIZE-------------------------------------------><
]]>
</programlisting>

<para>Retrieves the current buffer size.</para>
</section>

<section><title>INSERT</title>
<indexterm><primary>INSERT method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INSERT method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-INSERT(new-+-----------------------------------------+--)><
              +-,--+---+--+--------------------------+--+
                   +-n-+  +-,--+--------+--+------+--+
                               +-length-+  +-,pad-+
]]>
</programlisting>

<para>Inserts the string <emphasis>new</emphasis>, padded or truncated to
length <emphasis>length</emphasis>, into the mutable buffer after the
<emphasis>n</emphasis>'th character. The default
value for <emphasis>n</emphasis> is 0, which means insertion at the beginning
of the string. If specified, <emphasis>n</emphasis> and length must be
positive integers or zeros. If <emphasis>n</emphasis> is greater than the
length of the buffer contents,
the string new is padded at the beginning. The default value for
<emphasis>length</emphasis> is the length of <emphasis>new</emphasis>.
If length is less than the length of
string <emphasis>new</emphasis>, INSERT truncates <emphasis>new</emphasis>
to length <emphasis>length</emphasis>. The default
<emphasis>pad</emphasis> character is a blank.</para>
</section>

<section><title>LENGTH</title>
<indexterm><primary>LENGTH method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LENGTH method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-LENGTH--------------------------------------------------><
]]>
</programlisting>

<para>Returns length of data in buffer.</para>
</section>

<section><title>OVERLAY</title>
<indexterm><primary>OVERLAY method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>OVERLAY method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-OVERLAY(new-+-----------------------------------------+--)--><
               +-,--+---+--+--------------------------+--+
                    +-n-+  +-,--+--------+--+------+--+
                                +-length-+  +-,pad-+
]]>
</programlisting>

<para>Modifies the buffer content by overlaying it, starting at the
<emphasis>n</emphasis>'th character, with the string <emphasis>new</emphasis>,
padded or truncated to length <emphasis>length</emphasis>. The overlay can extend
beyond the end of the buffer. In this case the buffer size will be increased.
If you specify <emphasis>length</emphasis>, it must be a positive integer or
zero. The default value for <emphasis>length</emphasis> is the length of
<emphasis>new</emphasis>. If <emphasis>n</emphasis> is
greater than the length of the buffer content, padding is
added before the new string. The default <emphasis>pad</emphasis> character is
a blank, and the default value for <emphasis>n</emphasis> is 1. If you specify
<emphasis>n</emphasis>, it must be a positive integer.</para>
</section>

<section><title>SETBUFFERSIZE</title>
<indexterm><primary>SETBUFFERSIZE method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SETBUFERSIZE method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-SETBUFFERSIZE(n)----------------------------------------><
]]>
</programlisting>

<para>Sets the buffer size. If <emphasis>n</emphasis>
is less than the length of buffer
content, the content is truncated. If <emphasis>n</emphasis> is 0, the entire
contents is erased and the new buffer size is the value given
in the INIT method.</para>
</section>

<section><title>STRING</title>
<indexterm><primary>STRING method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>STRING method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-STRING--------------------------------------------------><
]]>
</programlisting>

<para>Retrieves the content of the buffer (a string).</para>
</section>

<section><title>SUBSTR</title>
<indexterm><primary>SUBSTR method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SUBSTR method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-SUBSTR(n-+--------------------------+--)----------------><
            +-,--+--------+--+------+--+
                 +-length-+  +-,pad-+
]]>
</programlisting>

<para>Returns a substring from the buffer content that begins at the
<emphasis>n</emphasis>'th character and is of length
<emphasis>length</emphasis>, padded with <emphasis>pad</emphasis> if
necessary. The <emphasis>n</emphasis> must be a positive integer. If
<emphasis>n</emphasis> is greater
than receiving_string~LENGTH, only <emphasis>pad</emphasis> characters
are returned. If you omit <emphasis>length</emphasis>, the remaining
buffer content is returned.
The default <emphasis>pad</emphasis> character is a blank.</para>
</section>

</section>


<section id="objc"><title>The Object Class</title>
<indexterm><primary>Object class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Object class</secondary></indexterm>
<para>The Object class is the root of the class hierarchy. The instance methods
of the Object class are, therefore, available on all objects.</para>
<para><emphasis role="bold">Methods the Object class defines:</emphasis></para>
<simplelist>
<member>NEW (Class method)</member>
<member>Operator methods:&nbsp;&nbsp;=, ==, \=, >&lt;, &lt;>, \==</member>
<member>CLASS</member>
<member>COPY</member>
<member>DEFAULTNAME</member>
<member>HASMETHOD</member>
<member>INIT</member>
<member>OBJECTNAME</member>
<member>OBJECTNAME=</member>
<member>REQUEST</member>
<member>RUN</member>
<member>SETMETHOD</member>
<member>START</member>
<member>STRING</member>
<member>UNSETMETHOD</member>
</simplelist>

<note><title>Note</title>
<para>The Object class also has available class methods that its
metaclass, the Class class, defines.</para></note>

<section id="obnew"><title>NEW  (Class Method)</title>
<indexterm><primary>NEW method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>NEW method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-NEW---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a new instance of the receiver class.</para>
</section>

<section id="coo"><title>Operator Methods</title>
<programlisting>
<![CDATA[
>>-comparison_operator(argument)-------------------------------><
]]>
</programlisting>


<note><title>Note</title>
<para>The <emphasis role="italic">argument</emphasis> is optional for
the == operator. </para></note>
<para>Returns <computeroutput>1</computeroutput> (true) or
<computeroutput>0</computeroutput> (false), the result of performing
a specified comparison operation. If you specify the
<computeroutput>==</computeroutput> operator
and omit <emphasis role="italic">argument</emphasis>, a string representation
is returned representing
a hash value for Set, Bag, Table, Relation, and Directory.</para>
<para>For the Object class, the arguments must match the receiver object. If
they do not match the receiver object, you can define subclasses of the Object
class to match the arguments.</para>
<para>The comparison operators you can use in a message are: </para>
<variablelist>
<varlistentry><term>=, ==
<indexterm><primary>= method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>== method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>=</secondary>
<tertiary>of Object class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>==</secondary>
<tertiary>of Object class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are the same object.
</para></listitem></varlistentry>
<varlistentry><term>\=, >&lt;, &lt;>, \==
<indexterm><primary>\= method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>>&lt; method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>&lt;> method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>\== method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>\=</secondary>
<tertiary>of Object class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>>&lt;</secondary>
<tertiary>of Object class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;></secondary>
<tertiary>of Object class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>\==</secondary>
<tertiary>of Object class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are not the same object (inverse of =).
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="obclas"><title>CLASS</title>
<indexterm><primary>CLASS method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CLASS method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CLASS-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the class object that received the message that created the
object.</para>
</section>

<section id="obcopy"><title>COPY</title>
<indexterm><primary>COPY method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>COPY method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-COPY--------------------------------------------------------><
]]>
</programlisting>

<para>Returns a copy of the receiver object. The copied object has
the same methods as the receiver object and an equivalent set of object
variables, with the same values.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>COPY method</secondary></indexterm>
<programlisting>
myarray=.array~of("N","S","E","W")
directions=myarray~copy   /* Copies array myarray to array directions */
</programlisting>
</section>

<section id="obdena"><title>DEFAULTNAME</title>
<indexterm><primary>DEFAULTNAME method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DEFAULTNAME method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-DEFAULTNAME-------------------------------------------------><
]]>
</programlisting>

<para>Returns a short human-readable string representation of the object. The
exact form of this representation depends on the object and might not alone
be sufficient to reconstruct the object. All objects must be able to produce
a short string representation of themselves in this way, even if the object
does not have a string value. See
<link linkend="reqstr">Required String Values</link> for more information.
The DEFAULTNAME method of the Object class returns a string that identifies
the class of the object, for example, an Array or a Directory. See also
<link linkend="obname">OBJECTNAME</link> and
<link linkend="obstri">STRING</link>. See
<link linkend="obqnam">OBJECTNAME=</link> for an
example using DEFAULTNAME.</para>
</section>

<section id="obhasm"><title>HASMETHOD</title>
<indexterm><primary>HASMETHOD method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>HASMETHOD method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-HASMETHOD(methodname)---------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the receiver object
has a method named <emphasis role="italic">methodname</emphasis>
(translated to uppercase) or if the target method is a private method.
Otherwise, it returns <computeroutput>0</computeroutput> (false). </para>

<note><title>Note</title>
<para>If you call the <emphasis role="italic">methodname</emphasis> method
although it is private, you receive error 97
<computeroutput>Object method not found</computeroutput> although HASMETHOD
returns <computeroutput>1</computeroutput> (true).</para></note>
</section>

<section id="obinit"><title>INIT</title>
<indexterm><primary>INIT method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INIT method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-INIT--------------------------------------------------------><
]]>
</programlisting>

<para>Performs any required object initialization. Subclasses of the Object
class can override this method.</para>
</section>

<section id="obname"><title>OBJECTNAME</title>
<indexterm><primary>OBJECTNAME method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>OBJECTNAME method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-OBJECTNAME--------------------------------------------------><
]]>
</programlisting>

<para>Returns the receiver object's name that the OBJECTNAME= method sets. If
the receiver object does not have a name, this method returns the result of
the DEFAULTNAME method. See
<link linkend="reqstr">Required String Values</link> for more information. See
the OBJECTNAME= method for an example using OBJECTNAME.</para>
</section>

<section id="obqnam"><title>OBJECTNAME=</title>
<indexterm><primary>OBJECTNAME= method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>OBJECTNAME= method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-OBJECTNAME=(newname)----------------------------------------><
]]>
</programlisting>

<para>Sets the receiver object's name to the string
<emphasis role="italic">newname</emphasis>.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>OBJECTNAME= method</secondary></indexterm>
<programlisting>
points=.array~of("N","S","E","W")
say points~objectname         /* (no change yet) Says: "an Array"    */
points~objectname=("compass") /* Changes obj name POINTS to "compass"*/
say points~objectname         /* Shows new obj name. Says: "compass" */
say points~defaultname        /* Default is still available.         */
                              /* Says "an Array"                     */
say points                    /* Says string representation of       */
                              /* points "compass"                    */
say points[3]                 /* Says: "E"Points is still an array   */
                              /* of 4 items                          */
</programlisting>
</section>

<section id="obreq"><title>REQUEST</title>
<indexterm><primary>REQUEST method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>REQUEST method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-REQUEST(classid)--------------------------------------------><
]]>
</programlisting>

<para>Returns an object of the <emphasis role="italic">classid</emphasis>
class, or the NIL object if the request cannot be satisfied.</para>
<para>This method first compares the identity of the object's class (see
the ID method of the Class class in <link linkend="clid">ID</link>) to
<emphasis role="italic">classid</emphasis>. If they are the same, the
receiver object is returned as the result.
Otherwise, REQUEST tries to obtain and return an object satisfying
<emphasis role="italic">classid</emphasis> by sending the receiver object the
conversion message <computeroutput>MAKE</computeroutput> with
the string <emphasis role="italic">classid</emphasis> appended (converted to
uppercase). For example,
a <computeroutput>REQUEST("string")</computeroutput> message causes a
MAKESTRING message to be sent.
If the object does not have the required conversion method, REQUEST returns
the NIL object.</para>
<para>The conversion methods cause objects to produce different representations
of themselves. The presence or absence of a conversion method defines an object's
capability to produce the corresponding representations. For example, lists
can represent themselves as arrays, because they have a MAKEARRAY method,
but they cannot represent themselves as directories, because they do not have
a MAKEDIRECTORY method. Any conversion method must return an object of the
requested class. For example, MAKEARRAY must return an array. The language
processor uses the MAKESTRING method to obtain string values in certain contexts;
see <link linkend="reqstr">Required String Values</link>.</para>
</section>

<section id="obrun"><title>RUN</title>
<indexterm><primary>RUN method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>RUN method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-RUN(method-+-------------------------------+-)--------------><
              |             +---------------+ |
              |             V               | |
              +-,Individual---+-----------+-+-+
              |               +-,argument-+   |
              +-,Array,argument---------------+
]]>
</programlisting>

<para>Runs the method object <emphasis role="italic">method</emphasis> (see
<link linkend="mcls">The Method Class</link>). The
<emphasis role="italic">method</emphasis> has access to the object variables
of the receiver object, as
if the receiver object had defined the method by using SETMETHOD.</para>
<para>If you specify the Individual or Array option, any remaining
<emphasis role="italic">argument</emphasis>s are arguments for the method.
(You need to specify only the first letter;
the language processor ignores all characters following it.) </para>
<variablelist>
<varlistentry><term>Individual</term>
<listitem><para>Passes any remaining arguments to the method as arguments in
the order you specify them.
</para></listitem></varlistentry>
<varlistentry><term>Array</term>
<listitem><para>Requires <emphasis role="italic">argument</emphasis>,
which is an array object. (See <link linkend="xarray">The Array Class</link>.)
The language processor passes the member items of the array to the method
as arguments. The first argument is at index 1, the second argument at index
2, and so on. If you omitted any indexes when creating the array, the language
processor omits their corresponding arguments when passing the arguments.
</para></listitem></varlistentry>
</variablelist>
<para>If you specify neither Individual nor Array, the method runs without
arguments.</para>
<para>The <emphasis role="italic">method</emphasis> argument can be a string
containing a method source line instead of a method object.
Alternatively, you can pass an array of strings
containing individual method lines. In either case, RUN creates an equivalent
method object.</para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>The RUN method is a private method. See the SETPRIVATE method
in <link linkend="mesetp">SETPRIVATE</link>  for details.</para></listitem>
<listitem><para>The RUN method is a protected method.</para></listitem>
</orderedlist>
</section>

<section id="obsetm"><title>SETMETHOD</title>
<indexterm><primary>SETMETHOD method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SETMETHOD method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SETMETHOD(methodname-+----------------------+--)-----------------><
                        |         +-,"FLOAT"-+ |
                        +-,method-+----------+-+
                                  +--,scope--+
]]>
</programlisting>

<para>Adds a method to the receiver object's
collection of object methods. The <emphasis role="italic">methodname</emphasis>
is the name of the new
method. (The language processor translates this name to uppercase.) If you
previously defined a method with the same name using SETMETHOD, the new method
replaces the earlier one. If you omit <emphasis role="italic">method</emphasis>,
SETMETHOD makes the
method name <emphasis role="italic">methodname</emphasis> unavailable for the
receiver object. In this
case, sending a message of that name to the receiver object runs the UNKNOWN
method (if any).</para>
<para>The <emphasis role="italic">method</emphasis> can be a string containing
a method source line instead
of a method object. Or it can be an array of strings containing individual
method lines. In either case, SETMETHOD creates an equivalent method object.
</para>

<para>The third parameter describes if the method that is attached to an
object should have object or float scope. "Float" scope means that
it shares the same scope with methods that were defined outside of
a class. "Object" scope means it shares the scope with other,
potentially statically defined, methods of the object it is
attached to.</para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>The SETMETHOD method is a private method. See the SETPRIVATE
method in <link linkend="mesetp">SETPRIVATE</link>  for details.</para>
</listitem>
<listitem><para>The SETMETHOD method is a protected method.</para></listitem>
</orderedlist>
</section>

<section id="obstar"><title>START</title>
<indexterm><primary>START method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>START method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
                     +---------------+
                     V               |
>>-START(messagename---+-----------+-+-)-----------------------><
                       +-,argument-+
]]>
</programlisting>

<para>Returns a message object (see
<link linkend="agent">The Message Class</link>) and sends it a START message
to start concurrent processing. The object receiving the message
<emphasis role="italic">messagename</emphasis> processes this message
concurrently with the sender's continued processing.</para>
<para>The <emphasis role="italic">messagename</emphasis> can be a string or
an array. If <emphasis role="italic">messagename</emphasis> is an array object,
its first item is the name of the message and its
second item is a class object to use as the starting point for the method
search. For more information, see
<link linkend="meths">Classes and Inheritance of Methods</link>.</para>
<para>The language processor passes any
<emphasis role="italic">argument</emphasis>s to the receiver as
arguments for <emphasis role="italic">messagename</emphasis> in the order you
specify them.</para>
<para>When the receiver object has finished processing the message, the message
object retains its result and holds it until the sender requests it by sending
a RESULT message. For further details, see <link linkend="msstrt">START</link>.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
world=.object~new
msg=world~start("HELLO")                /* same as next line     */
msg=.message~new(world,"HELLO")~~start  /* same as previous line */
</programlisting>
</section>

<section id="obstri"><title>STRING</title>
<indexterm><primary>STRING method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>STRING method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-STRING------------------------------------------------------><
]]>
</programlisting>

<para>Returns a human-readable string representation of the object. The exact
form of this representation depends on the object and might not alone be
sufficient to reconstruct the object. All objects must be able to produce a
string representation of themselves in this way.</para>
<para>The object's string representation is obtained from the OBJECTNAME
method (which can in turn use the DEFAULTNAME method). See also the OBJECTNAME
method (<link linkend="obname">OBJECTNAME</link>) and the DEFAULTNAME method
(<link linkend="obdena">DEFAULTNAME</link>).</para>
<para>The distinction between this method, the MAKESTRING method (which obtains
string values--see <link linkend="stmaks">MAKESTRING</link>) and the REQUEST
method (see <link linkend="obreq">REQUEST</link>) is important. All objects
have a STRING method, which returns
a string representation (human-readable form) of the
object. This form is useful in tracing and debugging. Only those objects that
have information with a meaningful string form have a MAKESTRING method to
return this value. For example, directory objects have a readable string
representation (a Directory), but no string value, and, therefore, no
MAKESTRING method.</para>
<para>Of the classes that Rexx provides, only the String class has a MAKESTRING
method. Any subclasses of the String class inherit this method by default,
so these subclasses also have string values. Any other class can also provide
a string value by defining a MAKESTRING method.</para>
</section>

<section id="obunse"><title>UNSETMETHOD</title>
<indexterm><primary>UNSETMETHOD method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>UNSETMRTHOD method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-UNSETMETHOD(methodname)-------------------------------------><
]]>
</programlisting>

<para>Cancels the effect of all previous SETMETHODs for method
<emphasis role="italic">methodname</emphasis>. It also removes any method
<emphasis role="italic">methodname</emphasis> introduced with ENHANCED
when the object was created. If the object has received no SETMETHOD method,
no action is taken. </para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>The UNSETMETHOD method is a private method. See the SETPRIVATE
method in <link linkend="mesetp">SETPRIVATE</link>  for details.</para>
</listitem>
<listitem><para>The UNSETMETHOD method is a protected method.</para></listitem>
</orderedlist>
</section>
</section>

<section id="regecpcls"><title>The RegularExpression Class</title>
<indexterm><primary>RegularExpression class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>RegularExpression class</secondary></indexterm>

<para>This class provides support for regular expressions. A regular
expression is a pattern you can use to match strings.</para>

<para>Here is a description of the syntax:</para>

<variablelist>
<varlistentry><term>|</term>
<listitem><para>OR operator between the left and right expression
</para></listitem></varlistentry>
<varlistentry><term>?</term>
<listitem><para>Matches any single character
</para></listitem></varlistentry>
<varlistentry><term>*</term>
<listitem><para>Matches the previous expression zero or more times
</para></listitem></varlistentry>
<varlistentry><term>+</term>
<listitem><para>Matches the previous expression one or more times
</para></listitem></varlistentry>
<varlistentry><term>\</term>
<listitem><para>"Escape" symbol: use the next character literally
</para></listitem></varlistentry>
<varlistentry><term>()</term>
<listitem><para>Expression in parenthesis (use where needed)
</para></listitem></varlistentry>
<varlistentry><term>{n}</term>
<listitem><para>Matches previous expression n times (n>1)
</para></listitem></varlistentry>
<varlistentry><term>[]</term>
<listitem><para>Set definition: matches any single character out of the defined
set.</para>
<para>A &apos;^&apos; right after the opening bracket means that none of the
following characters should be matched.</para>
<para>A &apos;-&apos; (if not used with &apos;\&apos;) defines a range between the last
specified character and the one following &apos;-&apos;. If it is the
first character in the set definition, it is used literally.
</para></listitem></varlistentry>
</variablelist>

<para>The following symbolic names (they must start and end with &apos;:&apos;) can
be used to abbreviate common sets:</para>

<variablelist>
<varlistentry><term>:ALPHA:</term>
<listitem><para>Characters in the range A-Z and a-z
</para></listitem></varlistentry>
<varlistentry><term>:LOWER:</term>
<listitem><para>Characters in the range a-z
</para></listitem></varlistentry>
<varlistentry><term>:UPPER:</term>
<listitem><para>Characters in the range A-Z
</para></listitem></varlistentry>
<varlistentry><term>:DIGIT:</term>
<listitem><para>Characters in the range 0-9
</para></listitem></varlistentry>
<varlistentry><term>:ALNUM:</term>
<listitem><para>Characters in :DIGIT: and :ALPHA:
</para></listitem></varlistentry>
<varlistentry><term>:XDIGIT:</term>
<listitem><para>Characters in :DIGIT:, A-F and a-f
</para></listitem></varlistentry>
<varlistentry><term>:BLANK:</term>
<listitem><para>Space and tab characters
</para></listitem></varlistentry>
<varlistentry><term>:SPACE:</term>
<listitem><para>Characters "09"x to "0D"x and space
</para></listitem></varlistentry>
<varlistentry><term>:CNTRL:</term>
<listitem><para>Characters "00"x to "1F"x and "7F"x
</para></listitem></varlistentry>
<varlistentry><term>:PRINT:</term>
<listitem><para>Characters in the range "20"x to "7E"x
</para></listitem></varlistentry>
<varlistentry><term>:GRAPH:</term>
<listitem><para>Characters in :PRINT: without space
</para></listitem></varlistentry>
<varlistentry><term>:PUNCT:</term>
<listitem><para>All :PRINT: characters without space and not in :ALNUM:
</para></listitem></varlistentry>
</variablelist>

<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>RegularExpression class</secondary></indexterm>
<programlisting>
<![CDATA[
     "(Hi|Hello) World"      Matches "Hi World" and
                             "Hello World".
     "file.???"              Matches any file with three
                             characters after "."
     "file.?{3}"             Same as above.
     "a *b"                  Matches all strings that begin with
                             "a" and end with "b" and have an
                             arbitrary number of spaces in between
                             both.
     "a +b"                  Same as above, but at least one space
                             must be present.
     "file.[bd]at"           Matches "file.bat" and "file.dat".
     "[A-Za-z]+"             Matches any string containing only
                             letters.
     "[:ALPHA:]+"            Same as above, using symbolic names.
     "[^0-9]*"               Matches any string containing no
                             numbers, including the empty string.
     "[:DIGIT::LOWER:]"      A single character, either a digit or
                             a lower case character.
     "This is (very )+nice." Matches all strings with one or more
                             occurrences of "very " between
                             "This is " and "nice.".
]]>
</programlisting>

<para>The RegularExpression class is not a built-in class. It is defined
in the RXREGEXP.CLS file. This means, you must use a
::requires statement to activate its functionality, as follows:</para>

<programlisting>
<![CDATA[
::requires "RXREGEXP.CLS"
]]>
</programlisting>

<para>Methods available to the RegularExpression class:</para>

<itemizedlist>
<listitem><para>Init</para></listitem>
<listitem><para>Match</para></listitem>
<listitem><para>Parse</para></listitem>
<listitem><para>Pos</para></listitem>
<listitem><para>Position</para></listitem>
</itemizedlist>


<section><title>INIT</title>
<indexterm><primary>INIT method</primary>
<secondary>of RegularExpression class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INIT method</secondary>
<tertiary>of RegularExpression class</tertiary></indexterm>

<programlisting>
<![CDATA[
                     +-,-"MAXIMAL"--+
>>-INIT(-+---------+-+--------------+-)--------------------><
         +-Pattern-+ +-,-"MINIMAL"--+
]]>
</programlisting>

<para>Instantiates a RegularExpression object. Use the optional parameter
<emphasis>Pattern</emphasis> to define a pattern that is used to match
strings. See the introductory text below for a description of the
syntax. If the strings match, you can decide whether you want to
apply "greedy" matching (a maximum-length match) or "non-greedy"
matching (a minimum-length match).</para>

<para><emphasis role="bold">Examples:</emphasis></para>

<programlisting>
<![CDATA[
myRE1 = .RegularExpression~new
myRE2 = .RegularExpression~new("Hello?*")
]]>
</programlisting>
</section>

<section><title>MATCH</title>
<indexterm><primary>MATCH method</primary>
<secondary>of RegularExpression class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MATCH method</secondary>
<tertiary>of RegularExpression class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-MATCH(-String-)-><
]]>
</programlisting>

<para>This method tries to match the given string to the regular
expression that was defined on the "new" invocation or on the
"parse" invocation. It returns 0 on an unsuccessful match and 1
on a successful match. For an example see
<link linkend="regexppars">Parse</link>.
</para>
</section>

<section id="regexppars"><title>PARSE</title>
<indexterm><primary>PARSE method</primary>
<secondary>of RegularExpression class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>PARSE method</secondary>
<tertiary>of RegularExpression class</tertiary></indexterm>

<programlisting>
<![CDATA[
                  +-,-"CURRENT"--+
>>-PARSE(-Pattern-+--------------+-------------------------><
                  +-,-"MAXIMAL"--+
                  +-,-"MINIMAL"--+
]]>
</programlisting>

<para>This method creates the automation used to match a string from the
regular expression specified with
<emphasis>Pattern</emphasis>. The RegularExpression
object uses this regular expression until a new invocation of Parse
takes place. The second (optional) parameter specifies whether to
use minimal or maximal matching. The default is to use the current
matching behavior.</para>

<para><emphasis role="bold">Return values:</emphasis></para>

<variablelist>
<varlistentry><term>0</term>
<listitem><para>Regular expression was parsed successfully.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>An unexpected symbol was met during parsing.
</para></listitem></varlistentry>
<varlistentry><term>2</term>
<listitem><para>A missing &apos;)&apos; was found.
</para></listitem></varlistentry>
<varlistentry><term>3</term>
<listitem><para>An illegal set was defined.
</para></listitem></varlistentry>
<varlistentry><term>4</term>
<listitem><para>The regular expression ended unexpectedly.
</para></listitem></varlistentry>
<varlistentry><term>5</term>
<listitem><para>An illegal number was specified.
</para></listitem></varlistentry>
</variablelist>


<para><emphasis role="bold">Example 1:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>RegularExpression class</secondary></indexterm>
<programlisting>
<![CDATA[
a.0 = "does not match regular expression"
a.1 = "matches regular expression"
b = .array~of("This is a nice flower.",
              "This is a yellow flower.", ,
              "This is a blue flower.",
              "Hi there!")

myRE = .RegularExpression~new
e = myRE~parse("This is a ???? flower.")
if e == 0 then do
  do i over b
    j = myRE~match(i)
    say i~left(24) ">>" a.j
  end
end
else
  say "Error" e "occurred!"
exit

::requires "rxregexp.cls"
]]>
</programlisting>

<para>Output:</para>

<programlisting>
<![CDATA[
This is a nice flower.   >> Does match regular expression
This is a yellow flower. >> Does not match regular expression
This is a blue flower.   >> Does match regular expression
Hi there!                >> Does not match regular expression
]]>
</programlisting>

<para><emphasis role="bold">Example 2:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>RegularExpression class</secondary></indexterm>
<programlisting>
<![CDATA[
a.0 = "an invalid number!"
a.1 = "a valid number."
b = .array~of("1","42","0","5436412","1a","f43g")
myRE = .RegularExpression~new("[1-9][0-9]*")
do i over b
  j = myRE~match(i)
  say i "is" a.j
end
say

/* Now allow "hex" numbers and a single 0 */
if myRE~parse("0|([1-9a-f][0-9a-f]*)") == 0 then do
  do i over b
    j = myRE~match(i)
    say i "is" a.j
  end
end
else
  say "invalid regular expression!"

exit

::requires "rxregexp.cls"
]]>
</programlisting>

<para><emphasis role="bold">Example 3:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>RegularExpression class</secondary></indexterm>
<programlisting>
<![CDATA[
str = "<p>Paragraph 1</p><p>Paragraph 2</p>"
myRE1 = .RegularExpression~new("<p>?*</p>","MINIMAL")
myRE1~match(str)
myRE2 = .RegularExpression~new("<p>?*</p>","MAXIMAL")
myRE2~match(str)

say "myRE1 (minimal) matched" str~substr(1,myRE1~position)
say "myRE2 (maximal) matched" str~substr(1,myRE2~position)

::requires "rxregexp.cls"
]]>
</programlisting>

<para>Output:</para>

<programlisting>
<![CDATA[
myRE1 (minimal) matched <p>Paragraph 1</p>
myRE2 (maximal) matched <p>Paragraph 1</p><p>Paragraph 2</p>
]]>
</programlisting>
</section>


<section><title>POS</title>
<indexterm><primary>POS method</primary>
<secondary>of RegularExpression class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>POS method</secondary>
<tertiary>of RegularExpression class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-POS-(-Haystack-)-><
]]>
</programlisting>

<para>This method tries to locate a string defined by the regular
expression on the "new" invocation or on the "parse" invocation
in the given haystack string.
It returns 0 on an unsuccessful match or the starting position
on a successful match. The end position of the match can be
retrieved with the <link linkend="regexppos">POSITION</link> method.</para>

<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[
str = "It is the year 2002!"
myRE = .RegularExpression~new("[1-9][0-9]*")
begin = myRE~pos(str)
if begin > 0 then do
  year = str~substr(begin, myRE~position - begin + 1)
  say "Found the number" year "in this sentence."
end

::requires "rxregexp.cls"
]]>
</programlisting>

<para>Output:</para>

<programlisting>
<![CDATA[
Found the number 2002 in this sentence.
]]>
</programlisting>
</section>

<section id="regexppos"><title>POSITION</title>
<indexterm><primary>POSITION method</primary>
<secondary>of RegularExpression class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>POSITION method</secondary>
<tertiary>of RegularExpression class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-POSITION------------------------------------------------><
]]>
</programlisting>

<para>Returns the character position at which either Parse, Pos or Match
ended, depending on what was invoked last.</para>

<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[
myRE = .RegularExpression~new
myRE~Parse("[abc")                    -- illegal set definition
say myRE~Position                     -- will be 4

myRE = .RegularExpression~new("[abc]12")
myRE~Match("c12")
say myRE~Position                     -- will be 3

myRE~Match("a13")
say myRE~Position                     -- will be 2 (failure to match)

::requires "rxregexp.cls"
]]>
</programlisting>

</section>
</section>


<section id="stemcl"><title>The Stem Class</title>
<indexterm><primary>Stem class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Stem class</secondary></indexterm>
<para>A stem object is a collection with unique indexes
that are character strings.</para>
<para>Stems are automatically created whenever a Rexx stem variable or Rexx
compound variable is used. For example: </para>
<programlisting>
a.1 = 2
</programlisting>
<para>creates a new stem collection with the name <computeroutput>A.</computeroutput>
and assigns it to the Rexx variable <computeroutput>A.</computeroutput>; it also assigns
the value 2 to entry 1 in the collection.</para>
<para>The value of an uninitialied stem index is the stem object NAME
concatenated with the derived stem index.  For
example</para>
<programlisting>
say a.[1,2]  -- implcitly creates stem object with name "A."
-- displays "A.1.2"

a = .stem~new("B.")
say a[1,2]     -- displays "B.1.2"
</programlisting>
<para>In addition to the items explicitly assigned to the
collection indexes,
a value may be assigned to all possible stem indexes.  The
<computeroutput>[]=</computeroutput> method (with no index argument)
will assign the target value to all possible stem indexes.
Following assignment, a reference to any index will return the new value until
another value is assigned or the index is dropped.</para>
<para>The <computeroutput>[]</computeroutput> method (with no index specified) will retrieve any
globally assigned value.  By default, this
returns the stem NAME value.</para>
<para>In addition to the methods defined in the following, the Stem class removes
the methods =, ==, \=, \==, &lt;>, and >&lt; using the DEFINE method.</para>
<para><emphasis role="bold">Methods the Stem class defines:</emphasis></para>
<simplelist>
<member>NEW (Class method.&nbsp;&nbsp;Overrides Object class method.)</member>
<member>[]</member>
<member>[]=</member>
<member>MAKEARRAY</member>
<member>REQUEST (Overrides Object class method)</member>
<member>UNKNOWN</member>
</simplelist>
<para><emphasis role="bold">Methods inherited from the Object class:</emphasis>
</para>
<simplelist>
<member>Operator methods:&nbsp;&nbsp;=, ==, \=, >&lt;, &lt;>, \==</member>
<member>CLASS</member>
<member>COPY</member>
<member>DEFAULTNAME</member>
<member>HASMETHOD</member>
<member>INIT</member>
<member>OBJECTNAME</member>
<member>OBJECTNAME=</member>
<member>RUN</member>
<member>SETMETHOD</member>
<member>START</member>
<member>STRING</member>
<member>UNSETMETHOD</member>
</simplelist>

<note><title>Note</title>
<para>The Stem class also has available class methods that its metaclass,
the Class class, defines.</para></note>

<section id="newste"><title>NEW  (Class Method)</title>
<indexterm><primary>NEW method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>NEW method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-NEW-+--------+----------------------------------------------><
       +-(name)-+
]]>
</programlisting>

<para>Returns a new stem object. If you specify a string
<emphasis role="italic">name</emphasis>, this
value is used to create the derived name of compound variables. The default
stem name is a null string.</para>
</section>

<section id="stlbrk"><title>[]</title>
<indexterm><primary>[] method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[] method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
     +-,---------+
     V           |
>>-[---+-------+-+-]-------------------------------------------><
       +-index-+
]]>
</programlisting>

<para>Returns the item associated with the specified
<emphasis role="italic">index</emphasis>es. Each
<emphasis role="italic">index</emphasis> is an expression; use commas to
separate the expressions. The language processor concatenates the
<emphasis role="italic">index</emphasis> expression string values, separating
them with a period (.), to create a derived index. A null string (&quot;&quot;)
is used for any omitted expressions. The resulting string references the stem
item. If the stem has no item associated with the specified final
<emphasis role="italic">index</emphasis>, the stem default value is returned.
If a default value has not been
set, the stem name concatenated with the final index string is returned.</para>
<para>If you do not specify <emphasis role="italic">index</emphasis>, the stem
default value is returned.
If no default value has been assigned, the stem name is returned. </para>

<note><title>Note</title>
<para>You cannot use the [] method in a DROP or PROCEDURE instruction
or in a parsing template.</para></note>
</section>

<section id="lreqsm"><title>[]=</title>
<indexterm><primary>[]= method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[]= method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
     +-,---------+
     V           |
>>-[---+-------+-+-]=value-------------------------------------><
       +-index-+
]]>
</programlisting>

<para>Makes the value a member item of the stem collection and associates it
with the specified index. If you specify no
<emphasis role="italic">index</emphasis> expressions, a
new default stem value is assigned. Assigning a new default value will
re-initialize the stem and remove all existing assigned indexes.</para>
</section>

<section id="makasm"><title>MAKEARRAY</title>
<indexterm><primary>MAKEARRAY method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MAKEARRAY method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MAKEARRAY---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all stem indexes that currently have an associated
value. The items appear in the array in an unspecified order.  (The program
should not rely on any order.)</para>
</section>

<section id="reqsm"><title>REQUEST</title>
<indexterm><primary>REQUEST method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>REQUEST method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-REQUEST(classid)--------------------------------------------><
]]>
</programlisting>

<para>Returns the result of the Stem class MAKEARRAY method, if the requested
class is ARRAY. For all other classes, REQUEST forwards the message to the
default value of the stem and returns this result. This method requests
conversion to a specific class. All conversion requests except ARRAY are
forwarded to the current stem default value.</para>
</section>

<section id="unkstm"><title>UNKNOWN</title>
<indexterm><primary>UNKNOWN method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>UNKNOWN method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-UNKNOWN-(messagename,messageargs)---------------------------><
]]>
</programlisting>

<para>Reissues or forwards to the current stem default value all unknown
messages sent to a stem collection. For additional information, see
<link linkend="unkno">Defining an UNKNOWN Method</link>.</para>
</section>
</section>

<section id="strcl"><title>The Stream Class</title>
<indexterm><primary>Stream class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Stream class</secondary></indexterm>
<para>A stream object allows external communication from
Rexx. (See <link linkend="iostrms">Input and Output Streams</link> for a
discussion of Rexx input and output.)</para>
<para>The Stream class is a subclass of the Object class.</para>
<para><emphasis role="bold">Methods the Stream class defines:</emphasis></para>
<simplelist>
<member>ARRAYIN</member>
<member>ARRAYOUT</member>
<member>CHARIN</member>
<member>CHAROUT</member>
<member>CHARS</member>
<member>CLOSE</member>
<member>COMMAND</member>
<member>DESCRIPTION</member>
<member>FLUSH</member>
<member>INIT (Overrides Object class method)</member>
<member>LINEIN</member>
<member>LINEOUT</member>
<member>LINES</member>
<member>MAKEARRAY</member>
<member>OPEN</member>
<member>POSITION</member>
<member>QUALIFY</member>
<member>QUERY</member>
<member>SAY</member>
<member>SEEK</member>
<member>STATE</member>
<member>SUPPLIER</member>
</simplelist>
<para><emphasis role="bold">Methods inherited from the Object class:</emphasis>
</para>
<simplelist>
<member>NEW (Class method)</member>
<member>Operator methods:&nbsp;&nbsp;=, ==, \=, >&lt;, &lt;>, \==</member>
<member>CLASS</member>
<member>COPY</member>
<member>DEFAULTNAME</member>
<member>HASMETHOD</member>
<member>OBJECTNAME</member>
<member>OBJECTNAME=</member>
<member>REQUEST</member>
<member>RUN</member>
<member>SETMETHOD</member>
<member>START</member>
<member>STRING</member>
<member>UNSETMETHOD</member>
</simplelist>

<note><title>Note</title>
<para>The Stream class also has available class methods that its
metaclass, the Class class, defines.</para></note>

<section id="stmari"><title>ARRAYIN</title>
<indexterm><primary>ARRAYIN method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ARRAYIN method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
            +-(LINES)-+
>>-ARRAYIN--+---------+----------------------------------------><
            +-(CHARS)-+
]]>
</programlisting>

<para>Returns a fixed array that contains the data of the stream in line or
character format, starting from the current read position. The line format is
the default.</para>
<para>If you have used the CHARIN method, the first line can be a partial line.
</para>
</section>

<section id="stmaro"><title>ARRAYOUT</title>
<indexterm><primary>ARRAYOUT method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ARRAYOUT method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
                  +-,--LINES-+
>>-ARRAYOUT(array-+----------+-)-------------------------------><
                  +-,--CHARS-+
]]>
</programlisting>

<para>Returns a stream object that contains the data from
<emphasis role="italic">array</emphasis>.</para>
</section>

<section id="charim"><title>CHARIN</title>
<indexterm><primary>CHARIN method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CHARIN method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CHARIN-+----------------------------+-----------------------><
          +-(-+-------+--+---------+-)-+
              +-start-+  +-,length-+
]]>
</programlisting>

<para>Returns a string of up to <emphasis role="italic">length</emphasis>
characters from the character input stream receiving the message. The language
processor advances the read pointer. If you omit
<emphasis role="italic">length</emphasis>, it defaults to
<computeroutput>1</computeroutput>. If you specify
<emphasis role="italic">start</emphasis>, this positions the read pointer
before reading. If the stream is not already open, the language processor tries
to open the stream for reading and writing. If that fails, the language
processor opens the stream for read only. (See
<link linkend="charin">CHARIN (Character Input)</link>  for information
about the CHARIN built-in function.)</para>
</section>

<section id="charom"><title>CHAROUT</title>
<indexterm><primary>CHAROUT method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CHAROUT method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CHAROUT-+----------------------------+----------------------><
           +-(-+--------+--+--------+-)-+
               +-string-+  +-,start-+
]]>
</programlisting>

<para>Returns the count of characters remaining after trying to write
<emphasis role="italic">string</emphasis> to the character output stream
receiving the message. The language processor
advances the write pointer.</para>
<para>The <emphasis role="italic">string</emphasis> can be the null string.
In this case, CHAROUT writes
no characters to the stream and returns <computeroutput>0</computeroutput>.
If you omit <emphasis role="italic">string</emphasis>, CHAROUT writes no
characters to the stream and returns <computeroutput>0</computeroutput>.
The language processor closes the stream.</para>
<para>If you specify <emphasis role="italic">start</emphasis>, this positions
the write pointer before
writing. If the stream is not already open, the language processor tries to
open the stream for reading and writing. If that fails, the language processor
opens the stream for write only. (See <link linkend="charout">CHAROUT
(Character Output)</link>  for information
about the CHAROUT built-in function.)</para>
</section>

<section id="charsm"><title>CHARS</title>
<indexterm><primary>CHARS method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CHARS method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CHARS-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the total number of characters remaining in the
character input stream receiving the message. The default input stream is
STDIN. The count includes any line separator characters, if these are defined
for the stream. In the case of persistent streams, it is the count of characters
from the current read position. (See
<link linkend="iostrms">Input and Output Streams</link> for a discussion
of Rexx input and output.) The total number of characters remaining cannot
be determined for some streams (for example, STDIN). For these streams. the
CHARS method returns <computeroutput>1</computeroutput>
to indicate that data is present, or <computeroutput>0</computeroutput>
if no data is present. For Windows devices,
CHARS always returns <computeroutput>1</computeroutput>. (See
<link linkend="chars">CHARS (Characters Remaining)</link> for information
about the CHARS built-in function.)</para>
</section>

<section id="stclos"><title>CLOSE</title>
<indexterm><primary>CLOSE method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CLOSE method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CLOSE-------------------------------------------------------><
]]>
</programlisting>

<para>Closes the stream that receives the message. CLOSE returns
<computeroutput>READY:</computeroutput> if closing the stream is successful,
or an appropriate error message.
If you have tried to close an unopened file, then the CLOSE method returns
a null string (&quot;&quot;).</para>
</section>

<section id="cmdmet"><title>COMMAND</title>
<indexterm><primary>COMMAND method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>COMMAND method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-COMMAND(stream_command)-------------------------------------><
]]>
</programlisting>

<para>Returns a string after performing the specified
<emphasis role="italic">stream_command</emphasis>. The returned string depends
on the <emphasis role="italic">stream_command</emphasis> performed
and can be the null string. The following
<emphasis role="italic">stream_command</emphasis>s: </para>
<itemizedlist>
<listitem><para>Open a stream for reading, writing, or both</para></listitem>
<listitem><para>Close a stream at the end of an operation</para></listitem>
<listitem><para>Move the line read or write position within a persistent stream
(for example, a file)</para></listitem>
<listitem><para>Get information about a stream</para></listitem></itemizedlist>

<para>If the method is unsuccessful, it returns an error message
string in the same form that the DESCRIPTION method uses.</para>
<para>For most error conditions, the additional information is in the form of
a numeric return code. This return code is the value of
<computeroutput>ERRNO</computeroutput> that
is set whenever one of the file system primitives returns with a
<computeroutput>-1</computeroutput>.</para>

<section id="commstr"><title>Command Strings</title>
<para>The argument <emphasis role="italic">stream_command</emphasis>
can be any expression that the language processor evaluates to a command string
that corresponds to the following diagram:</para>
<programlisting>
<![CDATA[
           +-BOTH--| Write Options |-+
>>-+-OPEN--+-------------------------+--+-------------+-+------><
   |       +-READ--------------------+  +-| Options |-+ |
   |       +-WRITE--+---------+------+                  |
   |                +-APPEND--+                         |
   |                +-REPLACE-+                         |
   +-CLOSE----------------------------------------------+
   +-FLUSH----------------------------------------------+
   |               +- = -+                    +-CHAR-+  |
   +-+-SEEK-----+--+-----+-offset--+-------+--+------+--+
   | +-POSITION-+  +- < -+         +-READ--+  +-LINE-+  |
   |               +- + -+         +-WRITE-+            |
   |               +- - -+                              |
   +-QUERY--+-DATETIME--------------------------+-------+
            +-EXISTS----------------------------+
            +-HANDLE----------------------------+
            |                       +-CHAR-+    |
            +-+-SEEK-----+--+-READ--+------+--+-+
            | +-POSITION-+  |       +-LINE-+  | |
            |               |        +-CHAR-+ | |
            |               +-WRITE--+------+-+ |
            |               |        +-LINE-+ | |
            |               +-SYS-------------+ |
            +-SIZE------------------------------+
            +-STREAMTYPE------------------------+
            +-TIMESTAMP-------------------------+
]]>
</programlisting>

<para><emphasis role="bold">Write Options:</emphasis></para>

<programlisting>
<![CDATA[
|--+---------+--------------------------------------------------|
   +-APPEND--+
   +-REPLACE-+
]]>
</programlisting>

<para><emphasis role="bold">Options:</emphasis></para>

<programlisting>
<![CDATA[
                   +-----------------------------------+
                   V                                   |
|--+------------+----+-NOBUFFER----------------------+-+--------|
   +-SHARED-----+    +-BINARY--+-------------------+-+
   +-SHAREREAD--+              +-RECLENGTH--length-+
   +-SHAREWRITE-+
]]>
</programlisting>

<variablelist>
<varlistentry><term>OPEN</term>
<listitem><para>Opens the stream object receiving the message and returns
<computeroutput>READY:</computeroutput>. (If unsuccessful, the previous
information about return codes applies.)
The default for OPEN is to open the stream for both reading and writing data,
for example: <computeroutput>&apos;OPEN BOTH&apos;</computeroutput>. To specify that the
<emphasis role="italic">stream_name</emphasis> receiving the message can be
only read or written to, add READ or WRITE, to the command string. </para>
<para>The following is a description of the options for
OPEN: </para>
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>Opens the stream only for reading.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>Opens the stream only for writing.
</para></listitem></varlistentry>
<varlistentry><term>BOTH</term>
<listitem><para>Opens the stream for both reading and writing. (This is the
default.) The language processor maintains separate read and write pointers.
</para></listitem></varlistentry>
<varlistentry><term>APPEND</term>
<listitem><para>Positions the write pointer at the end of the stream. The write
pointer cannot be moved anywhere within the extent of the file as it existed
when the file was opened.
</para></listitem></varlistentry>
<varlistentry><term>REPLACE</term>
<listitem><para>Sets the write pointer to the beginning of the stream and
truncates the file. In other words, this option deletes all data that was in
the stream when opened.
</para></listitem></varlistentry>
<varlistentry><term>SHARED</term>
<listitem><para>Enables another process to work with the stream in a shared
mode. This mode must be compatible with the shared mode (SHARED, SHAREREAD, or
SHAREWRITE) used by the process that opened the stream.
</para></listitem></varlistentry>
<varlistentry><term>SHAREREAD</term>
<listitem><para>Enables another process to read the stream in a shared mode.
</para></listitem></varlistentry>
<varlistentry><term>SHAREWRITE</term>
<listitem><para>Enables another process to write the stream in a shared mode.
</para></listitem></varlistentry>
<varlistentry><term>NOBUFFER</term>
<listitem><para>Turns off buffering of the stream.
All data written to the stream is
flushed immediately to the operating system for writing. This option can have
a severe impact on output performance. Use it only when data integrity is
a concern, or to force interleaved output to a stream to appear in the exact
order in which it was written.
</para></listitem></varlistentry>
<varlistentry><term>BINARY</term>
<listitem><para>Opens the stream in binary mode.
This means that line end characters
are ignored; they are treated like any other byte of data. This is intended
to force file operations that are compatible with other
Rexx language processors that run on record-based systems, or to process
binary data using the line operations.</para>

<note><title>Note</title>
<para>Specifying the BINARY option for a stream that
does not exist but is opened for writing also requires the RECLENGTH option
to be specified. Omitting the RECLENGTH option in this case raises an error
condition.</para></note>
</listitem></varlistentry>
<varlistentry><term>RECLENGTH <emphasis role="italic">length</emphasis></term>
<listitem><para>Allows the specification of an exact length
for each line in a stream.
This allows line operations on binary-mode streams to operate on individual
fixed-length records. Without this option, line operations on binary-mode
files operate on the entire file (for example, as if you specified the
<computeroutput>RECLENGTH</computeroutput> option with a length equal to
that of the file). The <emphasis role="italic">length</emphasis> must be
<computeroutput>1</computeroutput> or greater.
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>COMMAND method</secondary>
<tertiary>OPEN option</tertiary></indexterm>
<programlisting>
stream_name~Command("open")
stream_name~Command("open write")
stream_name~Command("open read")
stream_name~Command("open read shared")
</programlisting>
</listitem></varlistentry>
<varlistentry><term>CLOSE</term>
<listitem><para>closes the stream object receiving the message. The COMMAND
method with the CLOSE option returns <computeroutput>READY:</computeroutput>
if the receiving stream object
is successfully closed or an appropriate error message otherwise. If an attempt
to close an unopened file occurs, then the COMMAND method with the CLOSE option
returns a null string (&quot;&quot;).
</para></listitem></varlistentry>
<varlistentry><term>FLUSH</term>
<listitem><para>forces any data currently buffered for writing to be written to
this stream.
</para></listitem></varlistentry>
<varlistentry><term>SEEK <emphasis role="italic">offset</emphasis></term>
<listitem><para>sets the read or write position to a given number
(<emphasis role="italic">offset</emphasis>) within a persistent stream. If the
stream is open for both reading
and writing and you do not specify READ or WRITE, both the read and write
positions are set.</para>

<note><title>Note</title>
<para>See <link linkend="iostrms">Input and Output Streams</link>  for a
discussion of read and write positions in a persistent stream.</para></note>
<para>To
use this command, you must first open the receiving stream object (with the
OPEN stream command described previously or implicitly with an input or output
operation). One of the following characters can precede the
<emphasis role="italic">offset</emphasis> number. </para>
<variablelist>
<varlistentry><term>=</term>
<listitem><para>explicitly specifies the
<emphasis role="italic">offset</emphasis> from the beginning of the stream.
This is the default if you supply no prefix. For example, an
<emphasis role="italic">offset</emphasis> of <computeroutput>1</computeroutput>
with the LINE option means the beginning of the stream.
</para></listitem></varlistentry>
<varlistentry><term>&lt;</term>
<listitem><para>specifies <emphasis role="italic">offset</emphasis> from the
end of the stream.</para></listitem></varlistentry>
<varlistentry><term>+</term>
<listitem><para>specifies <emphasis role="italic">offset</emphasis>
forward from the current read or write position.
</para></listitem></varlistentry>
<varlistentry><term>-</term>
<listitem><para>specifies <emphasis role="italic">offset</emphasis>
backward from the current read or write position.
</para></listitem></varlistentry>
</variablelist>
<para>The COMMAND method with the SEEK option returns the new position
in the stream if the read or write position is successfully located, or an
appropriate error message.</para>
<para>The following is a description of the options
for SEEK: </para>
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>specifies that this command sets the read position.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>specifies that this command sets the write position.
</para></listitem></varlistentry>
<varlistentry><term>CHAR</term>
<listitem><para>specifies the positioning in terms of characters. This is the
default.
</para></listitem></varlistentry>
<varlistentry><term>LINE</term>
<listitem><para>specifies the positioning in terms of lines. For non-binary streams,
this is potentially an operation that can take a long time to complete because,
in most cases, the file must be scanned from the top to count the line-end
characters. However, for binary streams with a specified record length, the
new resulting line number is simply multiplied by the record length before
character positioning. See
<link linkend="positio">Line versus Character Positioning</link>
for a detailed discussion of this issue. </para>

<note><title>Note</title>
<para>If you do line positioning in a file open only
for writing, you receive an error message.</para></note>
</listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>COMMAND method</secondary>
<tertiary>SEEK option</tertiary></indexterm>
<programlisting>
<![CDATA[
stream_name~Command("seek =2 read")
stream_name~Command("seek +15 read")
stream_name~Command("seek -7 write line")
fromend  = 125
stream_name~Command("seek <"fromend read)
]]>
</programlisting>
</listitem></varlistentry>
<varlistentry><term>POSITION</term>
<listitem><para>is a synonym for SEEK.</para>
<para>Used with these <emphasis role="italic">stream_command</emphasis>s, the
COMMAND method returns
specific information about a stream. Except for QUERY HANDLE and QUERY POSITION,
the language processor returns the query information even if the stream is
not open. The language processor returns the null string for nonexistent streams.
</para>
</listitem>
</varlistentry>
<varlistentry><term>QUERY DATETIME</term>
<listitem><para>Returns the date and time stamps of a stream in US format. For
example:
<indexterm><primary>examples</primary>
<secondary>COMMAND method</secondary>
<tertiary>QUERY DATETIME option</tertiary></indexterm>
<programlisting>
stream_name~Command("query datetime")
</programlisting>
</para><para>A sample output might be: </para>
<programlisting>
11-12-95 03:29:12
</programlisting>
</listitem></varlistentry>
<varlistentry><term>QUERY EXISTS</term>
<listitem><para>Returns the full path specification of the stream object
receiving the message, if it exists, or a null string. For example: </para>
<indexterm><primary>examples</primary>
<secondary>COMMAND method</secondary>
<tertiary>QUERY EXISTS option</tertiary></indexterm>
<programlisting>
stream_name~Command("query exists")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
c:\data\file.txt
</programlisting>
</listitem></varlistentry>
<varlistentry><term>QUERY HANDLE</term>
<listitem><para>Returns the handle associated with the open stream that is the
receiving stream object. For example: </para>
<indexterm><primary>examples</primary>
<secondary>COMMAND method</secondary>
<tertiary>QUERY HANDLE option</tertiary></indexterm>
<programlisting>
stream_name~Command("query handle")
</programlisting>
<para>A sample output might be:
<computeroutput>3</computeroutput></para>

</listitem></varlistentry>
<varlistentry><term>QUERY POSITION</term>
<listitem><para>Returns the current read or write position for the receiving
stream object, as qualified by the following options:
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>Returns the current read position.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>Returns the current write position. </para>

<note><title>Note</title>
<para>If the stream is
open for both reading and writing, this returns the read position by default.
Otherwise, this returns the appropriate position by default.</para></note>
</listitem></varlistentry>
<varlistentry><term>CHAR</term>
<listitem><para>Returns the position in terms of characters. This is the
default.
</para></listitem></varlistentry>
<varlistentry><term>LINE</term>
<listitem><para>Returns the position in terms of lines. For non-binary streams,
this operation can take a long time to complete. This is because the language
processor starts tracking the current line number if not
already doing so, and, thus, might require a scan of the stream from
the top to count the line-end characters. See
<link linkend="positio">Line versus Character Positioning</link>
for a detailed discussion of this issue. For example: </para>
<programlisting>
stream_name~Command("query position write")
</programlisting>
<para>A sample
output might be: </para>
<programlisting>
247
</programlisting>
</listitem></varlistentry>
<varlistentry><term>SYS</term>
<listitem><para>Returns the operating system stream position in terms of
characters.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>QUERY SEEK</term>
<listitem><para>Is a synonym for QUERY POSITION.
</para></listitem></varlistentry>
<varlistentry><term>QUERY SIZE</term>
<listitem><para>Returns the size in bytes of a persistent stream that is the
receiving stream object. For example: </para>
<programlisting>
stream_name~Command("query size")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
1305
</programlisting>
</listitem></varlistentry>
<varlistentry><term>QUERY STREAMTYPE</term>
<listitem><para>Returns a string indicating whether the receiving stream object
is <computeroutput>PERSISTENT</computeroutput>,
<computeroutput>TRANSIENT</computeroutput>, or
<computeroutput>UNKNOWN</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>QUERY TIMESTAMP</term>
<listitem><para>Returns the date and time stamps of the receiving stream object
in an international format. This is the preferred method of getting date and
time because it provides the full 4-digit year. For example:</para>
<programlisting>
stream_name~Command("query timestamp")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
1995-11-12 03:29:12
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="desmet"><title>DESCRIPTION</title>
<indexterm><primary>DESCRIPTION method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DESCRIPTION method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-DESCRIPTION-------------------------------------------------><
]]>
</programlisting>

<para>Returns any descriptive string associated with the
current state of the stream or the NIL object if no descriptive string is
available. The DESCRIPTION method is identical with the STATE method except
that the string that DESCRIPTION returns is followed by a colon and, if
available, additional information about ERROR or NOTREADY states. (The
<link linkend="statsm">STATE</link> method describes these states.)</para>
</section>

<section id="stflus"><title>FLUSH</title>
<indexterm><primary>FLUSH method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>FLUSH method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-FLUSH-------------------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>READY:</computeroutput>. It forces any data
currently buffered for writing
to be written to the stream receiving the message.</para>
</section>

<section id="intsmt"><title>INIT</title>
<indexterm><primary>INIT method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INIT method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-INIT(name)--------------------------------------------------><
]]>
</programlisting>

<para>Initializes a stream object for a stream
named <emphasis role="italic">name</emphasis>, but does not open the stream.
See <link linkend="creo">Initialization</link> for
more information.</para>
</section>

<section id="linein1"><title>LINEIN</title>
<indexterm><primary>LINEIN method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LINEIN method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-LINEIN-+-------------------------+--------------------------><
          +-(-+------+-+--------+-)-+
              +-line-+ +-,count-+
]]>
</programlisting>

<para>Returns the next <emphasis role="italic">count</emphasis> lines. The
count must be <computeroutput>0</computeroutput> or
<computeroutput>1</computeroutput>. The language processor advances the read
pointer. If you omit <emphasis role="italic">count</emphasis>, it defaults to
<computeroutput>1</computeroutput>. A <emphasis role="italic">line</emphasis>
number may be given to set the read position to the start of a specified
line. This line number must be positive and within the bounds of the stream,
and must not be specified for a transient stream. A value of 1 for
<emphasis role="italic">line</emphasis> refers to the first line in the stream.
If the stream is not already
open, the language processor tries to open the stream for reading and writing.
If that fails, the language processor opens the stream for read-only. (See
<link linkend="linein">LINEIN (Line Input)</link>  for information about the
LINEIN built-in function.)</para>
</section>

<section id="lineom"><title>LINEOUT</title>
<indexterm><primary>LINEOUT method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LINEOUT method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-LINEOUT-+--------------------------+------------------------><
           +-(-+--------+-+-------+-)-+
               +-string-+ +-,line-+
]]>
</programlisting>

<para>Returns <computeroutput>0</computeroutput> if successful in writing
<emphasis role="italic">string</emphasis> to the character output stream
receiving the message or <computeroutput>1</computeroutput> if
an error occurs while writing the line. The language processor advances the
write pointer. If you omit <emphasis role="italic">string</emphasis>, the
language processor closes the stream. If you specify
<emphasis role="italic">line</emphasis>, this positions the write pointer
before writing. If the stream is not already open, the language processor
tries to open the stream for reading and writing. If that fails, the language
processor opens the stream for write-only. (See
<link linkend="lineout">LINEOUT (Line Output)</link>  for
information about the LINEOUT built-in function.)</para>
</section>

<section id="linesm"><title>LINES</title>
<indexterm><primary>LINES method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LINES method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
           +-Count--+
>>-LINES(--+--------+---)--------------------------------------><
           +-Normal-+
]]>
</programlisting>

<para>Returns the number of completed lines that remain in the character input
stream receiving the message. If the stream has already been read with CHARIN,
this can include an initial partial line. For persistent streams the count
starts at the current read position. In effect, LINES reports whether a read
action of CHARIN (see <link linkend="charim">CHARIN</link>) or LINEIN (see
<link linkend="linein1">LINEIN</link>) will succeed. (For an explanation of
input and output, see
<link linkend="iostrms">Input and Output Streams</link>.)</para>
<para>For QUEUE, LINES returns the actual number of lines. (See
<link linkend="ylines">LINES (Lines Remaining)</link> for
information about the LINES built-in function.)</para>
<para> </para>

<note><title>Note</title>
<para>The CHARS method returns the number of characters in a
persistent stream or the presence of data in a transient stream. The LINES
method determines the actual number of lines by scanning the stream starting
at the current position and counting the lines. For large streams, this can
be a time-consuming operation.  Therefore, avoid the use of the LINES method
in the  condition of a loop reading a stream. It is recommended that you use
the CHARS method (see <link linkend="charsm">CHARS</link>) or the LINES
built-in function for this purpose.</para></note>

<para>The ANSI Standard has extended this function to allow an option: "Count".
If this option is used, LINES returns the actual number of complete
lines remaining in the stream, irrespective of how long this operation takes.
</para>

<para>The option "Normal" returns 1 if there is at least one complete line
remaining in the file or 0 if no lines remain.</para>

<para>The default is "Count".</para>

<para>The defaults of the LINES method and function are different because of
compatibility reasons.</para>

</section>

<section id="stasfa"><title>MAKEARRAY</title>
<indexterm><primary>MAKEARRAY method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MAKEARRAY method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
              +-(LINES)-+
>>-MAKEARRAY--+---------+--------------------------------------><
              +-(CHARS)-+
]]>
</programlisting>

<para>Returns a fixed array that contains
the data of the stream in line or character format, starting from the current
read position. The line format is the default.</para>
<para>If you have used the CHARIN method, the first line can be a partial line.
</para>
</section>

<section id="stopen"><title>OPEN</title>
<indexterm><primary>OPEN method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>OPEN method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
         +-(BOTH-| Write Options |--+  +-SHARED-----+
>>-OPEN--+--------------------------+--+------------+----------->
         +-(READ--------------------+  +-SHAREREAD--+
         +-(WRITE-| Write Options |-+  +-SHAREWRITE-+

   +-----------------------------------+
   V                                   |
>----+-------------------------------+-+--+---+----------------><
     +-NOBUFFER----------------------+    +-)-+
     +-BINARY--+-------------------+-+
               +-RECLENGTH--length-+
]]>
</programlisting>

<para><emphasis role="bold">Write Options:</emphasis></para>

<programlisting>
<![CDATA[
   +-------------+
   V +-APPEND--+ |
|----+---------+-+----------------------------------------------|
     +-REPLACE-+
]]>
</programlisting>

<para>Opens the stream to which you send the message and returns
<computeroutput>READY:</computeroutput>. If the method is unsuccessful, it
returns an error message string
in the same form that the DESCRIPTION method uses.</para>
<para>For most error conditions, the additional information is in the form of
a numeric return code. This return code is the value of
<computeroutput>ERRNO</computeroutput>,
which is set whenever one of the file system primitives returns with a
<computeroutput>-1</computeroutput>.</para>
<para>By default, OPEN opens the stream for both reading and writing data, for
example: <computeroutput>&apos;OPEN BOTH&apos;</computeroutput>. To specify that the
stream receiving
the message can be only read or only written to, specify READ or WRITE.</para>
<para>The options for the OPEN method are: </para>
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>Opens the stream only for reading.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>Opens the stream only for writing.
</para></listitem></varlistentry>
<varlistentry><term>BOTH</term>
<listitem><para>Opens the stream for both reading and writing. (This is the
default.) The language processor maintains separate read and write pointers.
</para></listitem></varlistentry>
<varlistentry><term>APPEND</term>
<listitem><para>Positions the write pointer at the end of the stream.
(This is the default.)
The write pointer cannot be moved anywhere within the extent of the file as
it existed when the file was opened.
</para></listitem></varlistentry>
<varlistentry><term>REPLACE</term>
<listitem><para>Sets the write pointer to the beginning of the stream
and truncates
the file. In other words, this option deletes all data that was in the stream
when opened.
</para></listitem></varlistentry>
<varlistentry><term>SHARED</term>
<listitem><para>Enables another process to work with the stream in a shared mode. (This
is the default.) This mode must be compatible with the shared mode (SHARED,
SHAREREAD, or SHAREWRITE) used by the process that opened the stream.
</para></listitem></varlistentry>
<varlistentry><term>SHAREREAD</term>
<listitem><para>Enables another process to read the stream in a shared mode.
</para></listitem></varlistentry>
<varlistentry><term>SHAREWRITE</term>
<listitem><para>Enables another process to write the stream in a shared mode.
</para></listitem></varlistentry>
<varlistentry><term>NOBUFFER</term>
<listitem><para>Turns off buffering of the stream. All data written to the stream is
flushed immediately to the operating system for writing. This option can have
a severe impact on output performance. Use it only when data integrity is
a concern, or to force interleaved output to a stream to appear in the exact
order in which it was written.
</para></listitem></varlistentry>
<varlistentry><term>BINARY</term>
<listitem><para>Opens the stream in binary mode. This means that line-end
characters are ignored; they are treated like any other byte of data. This is
intended to force file operations that are compatible with
other Rexx language processors
that run on record-based systems, or to process binary data using the line
operations. </para>

<note><title>Note</title>
<para>Specifying the BINARY option for a stream that
does not exist but is opened for writing also requires the RECLENGTH option
to be specified. Omitting the RECLENGTH option in this case raises an error
condition.</para></note>
</listitem></varlistentry>
<varlistentry><term>RECLENGTH <emphasis role="italic">length</emphasis></term>
<listitem><para>Allows the specification of an exact length for each line
in a stream.
This allows line operations on binary-mode streams to operate on individual
fixed-length records. Without this option, line operations on binary-mode
files operate on the entire file (for example, as if you specified the
<computeroutput>RECLENGTH</computeroutput> option with a length equal to that
of the file). The <emphasis role="italic">length</emphasis> must be
<computeroutput>1</computeroutput> or greater.
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>OPEN method</secondary></indexterm>
<programlisting>
stream_name~OPEN
stream_name~OPEN("write")
stream_name~OPEN("read")
</programlisting>
</section>

<section id="stposi"><title>POSITION</title>
<indexterm><primary>POSITION method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>POSITION method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
             +- = -+                  +-CHAR-+
>>-POSITION(-+-----+-offset-+-READ--+-+------+-)---------------><
             +- < -+        +-WRITE-+ +-LINE-+
             +- + -+
             +- - -+
]]>
</programlisting>

<para>POSITION is a synonym for SEEK. (See
<link linkend="stseek">SEEK</link> .)</para>
</section>

<section id="qualm"><title>QUALIFY</title>
<indexterm><primary>QUALIFY method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>QUALIFY method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-QUALIFY-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the stream's fully qualified name. The stream need
not be open.</para>
</section>

<section id="stquer"><title>QUERY</title>
<indexterm><primary>method</primary>
<secondary>QUERY</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<indexterm><primary>QUERY method</primary>
<secondary>of Stream class</secondary></indexterm>

<programlisting>
<![CDATA[
>>-QUERY(--+-DATETIME--------------------------+--)------------><
           +-EXISTS----------------------------+
           +-HANDLE----------------------------+
           |                       +-CHAR-+    |
           +-+-SEEK-----+--+-READ--+------+--+-+
           | +-POSITION-+  |       +-LINE-+  | |
           |               |        +-CHAR-+ | |
           |               +-WRITE--+------+-+ |
           |               |        +-LINE-+ | |
           |               +-SYS-------------+ |
           +-SIZE------------------------------+
           +-STREAMTYPE------------------------+
           +-TIMESTAMP-------------------------+
]]>
</programlisting>

<para>Used with these options, the QUERY method returns specific information
about a stream. Except for QUERY HANDLE and QUERY POSITION, the
language processor
returns the query information even if the stream is not open. The language
processor returns the null string for nonexistent streams. </para>
<variablelist>
<varlistentry><term>DATETIME</term>
<listitem><para>returns the date and time stamps of the receiving stream object
in US format. For example:</para>
<programlisting>
stream_name~query("datetime")
</programlisting>
<para>A sample output might
be: </para>
<programlisting>
11-12-98 03:29:12
</programlisting>
</listitem></varlistentry>
<varlistentry><term>EXISTS</term>
<listitem><para>returns the full path specification of the receiving stream
object, if it exists, or a null string. For example: </para>
<indexterm><primary>examples</primary>
<secondary>QUERY method</secondary></indexterm>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~query("exists")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
c:\data\file.txt
</programlisting>
</listitem></varlistentry>
<varlistentry><term>HANDLE</term>
<listitem><para>returns the handle associated with the open stream that is the
receiving stream object. For example:</para>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~query("handle")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
3
</programlisting>
</listitem></varlistentry>
<varlistentry><term>POSITION</term>
<listitem><para>returns the current read or write position for the receiving
stream object, as qualified by the following options:
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>returns the current read position.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>returns the current write position. </para>

<note><title>Note</title>
<para>If the stream is
open for both reading and writing, this returns the read position by default.
Otherwise, this returns the appropriate position by default.</para></note>
</listitem></varlistentry>
<varlistentry><term>CHAR</term>
<listitem><para>returns the position in terms of characters.
This is the default.
</para></listitem></varlistentry>
<varlistentry><term>LINE</term>
<listitem><para>returns the position in terms of lines. For non-binary streams,
this operation can take a long time to complete. This is because the language
processor starts tracking the current line number if not already doing so, and,
thus, might require a scan of the stream from the top to count the line-end
characters. See
<link linkend="positio">Line versus Character Positioning</link>
for a detailed discussion of this issue. For example: </para>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~query("position write")
</programlisting>
<para>A sample output
might be: </para>
<programlisting>
247
</programlisting>
</listitem></varlistentry>
<varlistentry><term>SYS</term>
<listitem><para>returns the operating system stream position in terms of
characters. </para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>SIZE</term>
<listitem><para>returns the size, in bytes, of a persistent stream that is the
receiving stream object. For example: </para>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~query("size")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
1305
</programlisting>
</listitem></varlistentry>
<varlistentry><term>STREAMTYPE</term>
<listitem><para>returns a string indicating whether the receiving stream
object is <computeroutput>PERSISTENT</computeroutput>,
<computeroutput>TRANSIENT</computeroutput>, or
<computeroutput>UNKNOWN</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>TIMESTAMP</term>
<listitem><para>returns the date and time stamps of the receiving stream object
in an international format. This is the preferred method of getting the date and
time because it provides the full 4-digit year. For example:</para>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~query("timestamp")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
1998-11-12 03:29:12
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>

<section id="strmsay"><title>SAY</title>
<indexterm><primary>SAY method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SAY method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SAY--+----------------+-------------------------------------><
        +-(-+--------+-)-+
            +-string-+
]]>
</programlisting>

<para>Returns <computeroutput>0</computeroutput> if successful in writing
<emphasis role="italic">string</emphasis> to the character output stream
receiving the message or <computeroutput>1</computeroutput> if
an error occurs while writing the line.</para>
</section>

<section id="stseek"><title>SEEK</title>
<indexterm><primary>SEEK method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SEEK method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
         +- = -+                  +-CHAR-+
>>-SEEK(-+-----+-offset-+-------+-+------+-)-------------------><
         +- < -+        +-READ--+ +-LINE-+
         +- + -+        +-WRITE-+
         +- - -+
]]>
</programlisting>

<para>Sets the read or write position to a given number
(<emphasis role="italic">offset</emphasis>) within a persistent stream. If
the stream is open for both reading
and writing and you do not specify READ or WRITE, both the read and write
positions are set. </para>

<note><title>Note</title>
<para>See <link linkend="iostrms">Input and Output Streams</link>
for a discussion
of read and write positions in a persistent stream.</para></note>
<para>To use this method, you must first open the receiving stream object (with
the OPEN method described previously or implicitly with an input or output
operation). One of the following characters can precede the
<emphasis role="italic">offset</emphasis> number:</para>
<variablelist>
<varlistentry><term>=</term>
<listitem><para>Explicitly specifies the
<emphasis role="italic">offset</emphasis> from the beginning of the stream.
This is the default if you supply no prefix. For example, an
<emphasis role="italic">offset</emphasis> of <computeroutput>1</computeroutput>
means the beginning of the stream.
</para></listitem></varlistentry>
<varlistentry><term>&lt;</term>
<listitem><para>Specifies <emphasis role="italic">offset</emphasis>
from the end of the stream.
</para></listitem></varlistentry>
<varlistentry><term>+</term>
<listitem><para>Specifies <emphasis role="italic">offset</emphasis>
forward from the current read or write position.
</para></listitem></varlistentry>
<varlistentry><term>-</term>
<listitem><para>Specifies <emphasis role="italic">offset</emphasis>
backward from the current read or write position.
</para></listitem></varlistentry>
</variablelist>
<para>The SEEK method returns the new position in the stream if the read or
write position is successfully located, or an appropriate error message.</para>
<para>The following is a description of the options for SEEK: </para>
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>specifies that the read position be set.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>specifies that the write position be set.
</para></listitem></varlistentry>
<varlistentry><term>CHAR</term>
<listitem><para>specifies that positioning be done in terms of characters.
This is the default.
</para></listitem></varlistentry>
<varlistentry><term>LINE</term>
<listitem><para>specifies that the positioning be done in terms of lines. For
non-binary streams, this is potentially an operation that can take a long time
to complete because, in most cases, the file must be scanned from the top to
count the line-end characters. However, for binary streams with a specified
record length, the new resulting line number is simply multiplied by the record
length before character positioning. See
<link linkend="positio">Line versus Character Positioning</link>
for a detailed discussion of this issue. </para>

<note><title>Note</title>
<para>If you do line positioning in a file open only
for writing, you receive an error message.</para></note>
</listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>SEEK method</secondary></indexterm>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~seek("=2 read")
<emphasis role="italic">stream_name</emphasis>~seek("+15 read")
<emphasis role="italic">stream_name</emphasis>~seek("-7 write line")
fromend  = 125
<emphasis role="italic">stream_name</emphasis>~seek("&lt;"fromend read)
</programlisting>
</section>

<section id="statsm"><title>STATE</title>
<indexterm><primary>STATE method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>STATE method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-STATE-------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string that indicates the current state of the specified
stream.</para>
<para>The returned strings are as follows: </para>
<variablelist>
<varlistentry><term>ERROR</term>
<listitem><para>The stream has been subject to an erroneous operation
(possibly during input, output, or through the STREAM function). See
<link linkend="stmerr">Errors during Input and Output</link>.
You might be able to obtain additional information about the error with the
DESCRIPTION method or by calling the STREAM function with a request for the
description.
</para></listitem></varlistentry>
<varlistentry><term>NOTREADY</term>
<listitem><para>The stream is known to be in such a state that the usual input
or output operations attempted upon would raise the NOTREADY condition. (See
<link linkend="stmerr">Errors during Input and Output</link>.)
 For example, a simple input stream can have a defined length. An attempt
to read that stream (with CHARIN or LINEIN, perhaps) beyond that limit can
make the stream unavailable until the stream has been closed (for example,
with LINEOUT(<emphasis role="italic">name</emphasis>)) and then reopened.
</para></listitem></varlistentry>
<varlistentry><term>READY</term>
<listitem><para>The stream is known to be in such a state that the usual input
or output operations might be attempted. This is the usual state for a stream,
although it does not guarantee that any particular operation will succeed.
</para></listitem></varlistentry>
<varlistentry><term>UNKNOWN</term>
<listitem><para>The state of the stream is unknown. This generally means that
the stream is closed or has not yet been opened.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="stsup"><title>SUPPLIER</title>
<indexterm><primary>SUPPLIER method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SUPPLIER method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SUPPLIER----------------------------------------------------><
]]>
</programlisting>

<para>Returns a supplier object for the stream. When you send appropriate
messages to the supplier object (see
<link linkend="supp">The Supplier Class</link>), it enumerates all the lines
in the stream object. The supplier enumerates the items in their line order.
</para>
</section>
</section>

<section id="strc"><title>The String Class</title>
<indexterm><primary>String class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>String class</secondary></indexterm>
<para>String objects represent character-string data values. A character
string value can have any length and contain any characters. If you are familiar
with earlier versions of Rexx you might find the notation for functions more
convenient than the notation for methods. See
<link linkend="funct">Functions</link> for function
descriptions.</para>
<para>The String class is a subclass of the Object class.</para>
<para><emphasis role="bold">Methods the String class defines:</emphasis></para>
<simplelist>
<member>NEW (Class method.&nbsp;&nbsp;Overrides Object class method)</member>
<member>Arithmetic methods: +, -, *, /, %, //, **</member>
<member>Comparison methods: =, \=, &lt;>, >&lt;, ==,
\==&nbsp;&nbsp;(Override Object class methods)</member>
<member>Comparison methods:&nbsp;&nbsp;>, &lt;, >=, \&lt;, &lt;=, \>, >>,
&lt;&lt;, >>=, \&lt;&lt;, &lt;&lt;=, \>></member>
<member>Logical methods:&nbsp;&nbsp;&amp;, |, &amp;&amp;, \</member>
<member>Concatenation methods:&nbsp;&nbsp;&quot;&quot; (abuttal),
&quot;&nbsp;&quot; (blank), ||</member>
<member>ABBREV</member>
<member>ABS</member>
<member>BITAND</member>
<member>BITOR</member>
<member>BITXOR</member>
<member>B2X</member>
<member>CENTER (or CENTRE)</member>
<member>CHANGESTR</member>
<member>COMPARE</member>
<member>COPIES</member>
<member>COUNTSTR</member>
<member>C2D</member>
<member>C2X</member>
<member>DATATYPE</member>
<member>DECODEBASE64</member>
<member>DELSTR</member>
<member>DELWORD</member>
<member>D2C</member>
<member>D2X</member>
<member>ENCODEBASE64</member>
<member>FORMAT</member>
<member>INSERT</member>
<member>LASTPOS</member>
<member>LEFT</member>
<member>LENGTH</member>
<member>MAKEARRAY</member>
<member>MAKESTRING</member>
<member>MAX</member>
<member>MIN</member>
<member>OVERLAY</member>
<member>POS</member>
<member>REVERSE</member>
<member>RIGHT</member>
<member>SIGN</member>
<member>SPACE</member>
<member>STRING (Overrides Object class method)</member>
<member>STRIP</member>
<member>SUBSTR</member>
<member>SUBWORD</member>
<member>TRANSLATE</member>
<member>TRUNC</member>
<member>VERIFY</member>
<member>WORD</member>
<member>WORDINDEX</member>
<member>WORDLENGTH</member>
<member>WORDPOS</member>
<member>WORDS</member>
<member>X2B</member>
<member>X2C</member>
<member>X2D</member>
</simplelist>
<para><emphasis role="bold">Methods inherited from the Object class:</emphasis>
</para>
<simplelist>
<member>CLASS</member>
<member>COPY</member>
<member>DEFAULTNAME</member>
<member>HASMETHOD</member>
<member>INIT</member>
<member>OBJECTNAME</member>
<member>OBJECTNAME=</member>
<member>REQUEST</member>
<member>RUN</member>
<member>SETMETHOD</member>
<member>START</member>
<member>UNSETMETHOD</member>
</simplelist>

<note><title>Note</title>
<para>The String class also has available class methods that its
metaclass, the Class class, defines.</para></note>

<section id="stinew"><title>NEW  (Class Method)</title>
<indexterm><primary>NEW method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>NEW method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-NEW(stringvalue)--------------------------------------------><
]]>
</programlisting>

<para>Returns a new string object initialized with the characters in
<emphasis role="italic">stringvalue</emphasis>.</para>
</section>

<section id="aritcso"><title>Arithmetic Methods</title>
<indexterm><primary>method</primary>
<secondary>arithmetic methods</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-arithmetic_operator(argument)-------------------------------><
]]>
</programlisting>


<note><title>Note</title>
<para>For the prefix - and prefix + operators, omit the parentheses
and <emphasis role="italic">argument</emphasis>.</para></note>
<para>Returns the result of performing the specified arithmetic operation on
the receiver object. The receiver object and the
<emphasis role="italic">argument</emphasis> must be
valid numbers (see <link linkend="numbrs">Numbers</link>). The
<emphasis role="italic">arithmetic_operator</emphasis> can be:
</para>
<variablelist>
<varlistentry><term>+
<indexterm><primary>+ method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>+</secondary></indexterm>
</term>
<listitem><para>Addition
</para></listitem></varlistentry>
<varlistentry><term>-
<indexterm><primary>- method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>-</secondary></indexterm>
</term>
<listitem><para>Subtraction
</para></listitem></varlistentry>
<varlistentry><term>*
<indexterm><primary>* method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>*</secondary></indexterm>
</term>
<listitem><para>Multiplication
</para></listitem></varlistentry>
<varlistentry><term>/
<indexterm><primary>/ method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>/</secondary></indexterm>
</term>
<listitem><para>Division
</para></listitem></varlistentry>
<varlistentry><term>%
<indexterm><primary>% method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>%</secondary></indexterm>
</term>
<listitem><para>Integer division (divide and return the integer part of the
result)</para></listitem></varlistentry>
<varlistentry><term>//
<indexterm><primary>// method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>//</secondary></indexterm>
</term>
<listitem><para>Remainder (divide and return the remainder--not modulo, because
the result can be negative)
</para></listitem></varlistentry>
<varlistentry><term>**
<indexterm><primary>** method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>**</secondary></indexterm>
</term>
<listitem><para>Exponentiation (raise a number to a whole-number power)
</para></listitem></varlistentry>
<varlistentry><term>Prefix -
<indexterm><primary>method</primary>
<secondary>prefix -</secondary></indexterm>
</term>
<listitem><para>Same as the subtraction:
<computeroutput>0 - number</computeroutput>
</para></listitem></varlistentry>
<varlistentry><term>Prefix +
<indexterm><primary>method</primary>
<secondary>prefix +</secondary></indexterm>
</term>
<listitem><para>Same as the addition:
<computeroutput>0 + number</computeroutput>
</para></listitem></varlistentry>
</variablelist>
<para>See <link linkend="numarit">Numbers and Arithmetic</link> for details
about precision, the format of valid
numbers, and the operation rules for arithmetic. Note that if an arithmetic
result is shown in exponential notation, it might have been rounded.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>arithmetic methods of String class</secondary></indexterm>
<programlisting>
<![CDATA[
5+5     ->    10
8-5     ->     3
5*2     ->    10
6/2     ->     3
9//4    ->     1
9%4     ->     2
2**3    ->     8
+5      ->     5             /* Prefix +  */
-5      ->    -5             /* Prefix -  */
]]>
</programlisting>
</section>

<section id="commeth"><title>Comparison Methods</title>
<indexterm><primary>method</primary>
<secondary>comparison methods</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-comparison_operator(argument)-------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) or
<computeroutput>0</computeroutput> (false), the result of performing
the specified comparison operation. The receiver object and the
<emphasis role="italic">argument</emphasis> are the terms compared. Both must
be string objects.</para>

<para>The comparison operators you can use in a message are: </para>
<variablelist>
<varlistentry><term>=
<indexterm><primary>= method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>=</secondary>
<tertiary>of String class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are equal (for example, numerically or when
padded)
</para></listitem></varlistentry>
<varlistentry><term>\=, &gt;&lt;, &lt;&gt;
<indexterm><primary>>&lt; method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>&gt;&lt; method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>&lt;&gt; method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>\=</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>>&lt;</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;&gt;</secondary>
<tertiary>of String class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are not equal (inverse of =)
</para></listitem></varlistentry>
<varlistentry><term>&gt;
<indexterm><primary>&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>></secondary></indexterm>
</term>
<listitem><para>Greater than
</para></listitem></varlistentry>
<varlistentry><term>&lt;
<indexterm><primary>&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;</secondary></indexterm>
</term>
<listitem><para>Less than
</para></listitem></varlistentry>
<varlistentry><term>&gt;=
<indexterm><primary>&gt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&gt;=</secondary></indexterm>
</term>
<listitem><para>Greater than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&lt;
<indexterm><primary>\&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&lt;</secondary></indexterm>
</term>
<listitem><para>Not less than
</para></listitem></varlistentry>
<varlistentry><term>&lt;=
<indexterm><primary>&lt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;=</secondary></indexterm>
</term>
<listitem><para>Less than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&gt;
<indexterm><primary>\&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&gt;</secondary></indexterm>
</term>
<listitem><para>Not greater than
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>comparison methods of String class</secondary></indexterm>
<programlisting>
<![CDATA[
5=5        ->     1          /* equal            */

42\=41     ->     1          /* All of these are */
42><41     ->     1          /* "not equal"      */
42<>41     ->     1

13>12      ->     1          /* Variations of    */
12<13      ->     1          /* less than and    */
13>=12     ->     1          /* greater than     */
12\<13     ->     0
12<=13     ->     1
12\>13     ->     1
]]>
</programlisting>
<para>All strict comparison operations have one of the characters doubled that
define the operator. The <computeroutput>==</computeroutput> and
<computeroutput>\==</computeroutput> operators check
whether two strings match exactly. The two strings must be identical (character
by character) and of the same length to be considered strictly equal.</para>
<para>The strict comparison operators such as
<computeroutput>>></computeroutput> or
<computeroutput>&lt;&lt;</computeroutput> carry out a simple
character-by-character comparison. There is no padding
of either of the strings being compared. The comparison of the two strings
is from left to right. If one string is shorter than and a leading substring
of another, then it is smaller than (less than) the other. The strict
comparison operators do not attempt to perform a numeric comparison on the
two operands.</para>
<para>For all the other comparison operators, if both terms
are numeric, the language processor does a numeric comparison (ignoring, for
example, leading zeros--see <link linkend="numcom">Numeric Comparisons</link>).
Otherwise, it treats
both terms as character strings, ignoring leading and trailing blanks and
padding the shorter string on the right with blanks.</para>
<para>Character comparison and strict comparison operations are both
case-sensitive,
and for both the exact collating order can depend on the character set. In
an ASCII environment, the digits are lower than the alphabetic characters,
and lowercase alphabetic characters are higher than uppercase alphabetic
characters.</para>
<para>The strict comparison operators you can use in a message are: </para>
<variablelist>
<varlistentry><term>==
<indexterm><primary>== method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>==</secondary>
<tertiary>of String class</tertiary></indexterm>
</term>
<listitem><para>True if terms are strictly equal (identical)
</para></listitem></varlistentry>
<varlistentry><term>\==
<indexterm><primary>\== method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\==</secondary>
<tertiary>of String class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are NOT strictly equal (inverse of ==)
</para></listitem></varlistentry>
<varlistentry><term>&gt;&gt;
<indexterm><primary>&gt;&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>>></secondary></indexterm>
</term>
<listitem><para>Strictly greater than
</para></listitem></varlistentry>
<varlistentry><term>&lt;&lt;
<indexterm><primary>&lt;&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;&lt;</secondary></indexterm>
</term>
<listitem><para>Strictly less than
</para></listitem></varlistentry>
<varlistentry><term>&gt;&gt;=
<indexterm><primary>&gt;&gt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&gt;&gt;=</secondary></indexterm>
</term>
<listitem><para>Strictly greater than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&lt;&lt;
<indexterm><primary>\&lt;&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&lt;&lt;</secondary></indexterm>
</term>
<listitem><para>Strictly NOT less than
</para></listitem></varlistentry>
<varlistentry><term>&lt;&lt;=
<indexterm><primary>&lt;&lt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;&lt;=</secondary></indexterm>
</term>
<listitem><para>Strictly less than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&gt;&gt;
<indexterm><primary>\&gt;&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&gt;&gt;</secondary></indexterm>
</term>
<listitem><para>Strictly NOT greater than
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
<![CDATA[
"space"=="space"     ->     1         /* Strictly equal     */

"space"\==" space"   ->     1         /* Strictly not equal */

"space">>" space"    ->     1         /* Variations of      */
" space"<<"space"    ->     1         /* strictly greater   */
"space">>=" space"   ->     1         /* than and less than */
"space"\<<" space"   ->     1
" space"<<="space"   ->     1
" space"\>>"space"   ->     1
]]>
</programlisting>
</section>

<section id="logmeth"><title>Logical Methods</title>
<indexterm><primary>method</primary>
<secondary>logical methods</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-logical_operator(argument)----------------------------------><
]]>
</programlisting>


<note><title>Note</title>
<para>For NOT (prefix \),
<indexterm><primary>\ method</primary></indexterm>
omit the parentheses and <emphasis role="italic">argument</emphasis>.</para>
<para>Returns <computeroutput>1</computeroutput> (true) or
<computeroutput>0</computeroutput> (false), the result of performing
the specified logical operation. The receiver object and the
<emphasis role="italic">argument</emphasis> are character strings that
evaluate to <computeroutput>1</computeroutput> or
<computeroutput>0</computeroutput>.</para>
</note>
<para>The <emphasis role="italic">logical_operator</emphasis> can be: </para>

<variablelist>
<varlistentry><term>&amp;
<indexterm><primary>&amp; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&amp;</secondary></indexterm>
</term>
<listitem><para>AND (Returns <computeroutput>1</computeroutput>
if both terms are true.)
</para></listitem></varlistentry>
<varlistentry><term>|
<indexterm><primary>| method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>|</secondary></indexterm>
</term>
<listitem><para>Inclusive OR (Returns <computeroutput>1</computeroutput>
if either term or both terms are
true.)
</para></listitem></varlistentry>
<varlistentry><term>&amp;&amp;
<indexterm><primary>&amp;&amp; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&amp;&amp;</secondary></indexterm>
</term>
<listitem><para>Exclusive OR (Returns <computeroutput>1</computeroutput>
if either term, but not both terms,
is true.)
</para></listitem></varlistentry>
<varlistentry><term>Prefix \
<indexterm><primary>method</primary>
<secondary>\</secondary></indexterm>
</term>
<listitem><para>Logical NOT (Negates; <computeroutput>1</computeroutput>
becomes <computeroutput>0</computeroutput>, and
<computeroutput>0</computeroutput> becomes <computeroutput>1</computeroutput>.)
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>logical methods of String class</secondary></indexterm>
<programlisting>
<![CDATA[
1&0     ->     0
1|0     ->     1
1&&0    ->     1
\1      ->     0
]]>
</programlisting>
</section>

<section id="concmeth"><title>Concatenation Methods</title>
<indexterm><primary>method</primary>
<secondary>concatenation methods</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-concatenation_operator(argument)----------------------------><
]]>
</programlisting>

<para>Concatenates the receiver object with
<emphasis role="italic">argument</emphasis>. (See
<link linkend="strgcon">String Concatenation</link>.)
The <emphasis role="italic">concatenation_operator</emphasis> can be: </para>
<variablelist>
<varlistentry><term>&quot;&quot;</term>
<listitem><para>concatenates without an intervening blank. The abuttal operator
&quot;&quot;
is the null string. The language processor uses the abuttal to concatenate
two terms that another operator does not separate.
</para></listitem></varlistentry>
<varlistentry><term>||
<indexterm><primary>|| method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>||</secondary></indexterm>
</term>
<listitem><para>concatenates without an intervening blank.
</para></listitem></varlistentry>
<varlistentry><term>&quot;&nbsp;&quot;
</term>
<listitem><para>concatenates with one blank between the receiver
object and the <emphasis role="italic">argument</emphasis>.
(The operator &quot;&nbsp;&quot; is a blank.)
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>concatenation methods of String class</secondary></indexterm>
<indexterm><primary>prefix - method</primary></indexterm>
<indexterm><primary>prefix + method</primary></indexterm>
<programlisting>
<![CDATA[
5+5     ->    10
8-5     ->     3
5*2     ->    10
6/2     ->     3
9//4    ->     1
9%4     ->     2
2**3    ->     8
+5      ->     5             /* Prefix +  */
-5      ->    -5             /* Prefix -  */
]]>
</programlisting>
</section>

<section id="stabbr"><title>ABBREV</title>
<indexterm><primary>ABBREV method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ABBREV method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>default</primary>
<secondary>selecting with ABBREV method</secondary></indexterm>
<indexterm><primary>selecting a default with ABBREV method</primary></indexterm>
<indexterm><primary>testing</primary>
<secondary>abbreviations with ABBREV method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-ABBREV(info-+---------+-)-----------------------------------><
               +-,length-+
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> if
<emphasis role="italic">info</emphasis> is equal to the leading characters
of the receiving string and the length of
<emphasis role="italic">info</emphasis> is not less than
<emphasis role="italic">length</emphasis>. Returns
<computeroutput>0</computeroutput> if either of these conditions is not met.
</para>
<para>If you specify <emphasis role="italic">length</emphasis>, it must be a
positive whole number or zero. The default for
<emphasis role="italic">length</emphasis> is the number of characters in
<emphasis role="italic">info</emphasis>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>ABBREV method</secondary></indexterm>
<programlisting>
<![CDATA[
"Print"~ABBREV("Pri")      ->    1
"PRINT"~ABBREV("Pri")      ->    0
"PRINT"~ABBREV("PRI",4)    ->    0
"PRINT"~ABBREV("PRY")      ->    0
"PRINT"~ABBREV("")         ->    1
"PRINT"~ABBREV("",1)       ->    0
]]>
</programlisting>
<note><title>Note</title>
<para>A null string always matches if a length of
<computeroutput>0</computeroutput>, or the
default, is used. This allows a default keyword to be selected automatically
if desired.</para></note>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
say "Enter option:";   pull option .
select  /* keyword1 is to be the default */
  when "keyword1"~abbrev(option) then ...
  when "keyword2"~abbrev(option) then ...
  ...
  otherwise nop;
end;
</programlisting>
<para>(See <link linkend="abbrev">ABBREV (Abbreviation)</link>
for information about the ABBREV built-in function.)</para>
</section>

<section id="stabs"><title>ABS</title>
<indexterm><primary>ABS method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ABS method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>absolute value</primary>
<secondary>finding using the ABS method</secondary></indexterm>
<programlisting>
<![CDATA[
>>-ABS---------------------------------------------------------><
]]>
</programlisting>

<para>Returns the absolute value of the receiving string. The result has no
sign and is formatted according to the current NUMERIC settings.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>ABS method</secondary></indexterm>
<programlisting>
12.3~abs      ->     12.3
"-0.307"~abs  ->     0.307
</programlisting>
<para>(See <link linkend="abs">ABS (Absolute Value)</link>
for information about the ABS built-in function.)</para>
</section>

<section id="stb2x"><title>B2X</title>
<indexterm><primary>B2X method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>B2X method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>binary</primary>
<secondary>to hexadecimal conversion</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>binary to hexadecimal</secondary></indexterm>
<indexterm><primary>unpacking a string</primary>
<secondary>with B2X</secondary></indexterm>

<programlisting>
<![CDATA[
>>-B2X---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string, in character format, that represents the receiving
binary string converted to hexadecimal.</para>
<para>The receiving string is a string of binary
(<computeroutput>0</computeroutput> or <computeroutput>1</computeroutput>)
digits. It can be of any length. It can optionally include blanks (at 4-digit
boundaries only, not leading or trailing). These are to improve readability;
the language processor ignores them.</para>
<para>The returned string uses uppercase alphabetic characters for the values
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput> and does
not include blanks.</para>
<para>If the receiving binary string is a null string, B2X returns a null string.
If the number of binary digits in the receiving string is not a multiple of
four, the language processor adds up to three <computeroutput>0</computeroutput>
digits on the left
before the conversion to make a total that is a multiple of four.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>B2X method</secondary></indexterm>
<programlisting>
<![CDATA[
"11000011"~B2X     ->   "C3"
"10111"~B2X        ->   "17"
"101"~B2X          ->   "5"
"1 1111 0000"~B2X  ->   "1F0"
]]>
</programlisting>
<para>You can combine B2X with the methods X2D and X2C to convert a binary
number into other forms.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>"10111"~B2X~X2D  ->   "23"   /* decimal 23 */</programlisting>
<para>(See <link linkend="b2x">B2X (Binary to Hexadecimal)</link>
for information about the B2X built-in function.)</para>
</section>

<section id="stbita"><title>BITAND</title>
<indexterm><primary>BITAND method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>BITAND method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>ANDing character strings</primary></indexterm>
<indexterm><primary>character</primary>
<secondary>strings, ANDing</secondary></indexterm>
<programlisting>
<![CDATA[
>>-BITAND-+--------------------+-------------------------------><
          +-(string-+------+-)-+
                    +-,pad-+
]]>
</programlisting>

<para>Returns a string composed of the receiver string and the argument
<emphasis role="italic">string</emphasis> logically ANDed together,
bit by bit. (The encodings of the strings
are used in the logical operation.) The length of the result is the length
of the longer of the two strings. If you omit the
<emphasis role="italic">pad</emphasis> character,
the AND operation stops when the shorter of the two strings is exhausted,
and the unprocessed portion of the longer string is appended to the partial
result. If you provide <emphasis role="italic">pad</emphasis>,
it extends the shorter of the two strings
on the right before the logical operation. The default for
<emphasis role="italic">string</emphasis> is
the zero-length (null) string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>BITAND method</secondary></indexterm>
<programlisting>
<![CDATA[
"12"x~BITAND                   ->    "12"x
"73"x~BITAND("27"x)            ->    "23"x
"13"x~BITAND("5555"x)          ->    "1155"x
"13"x~BITAND("5555"x,"74"x)    ->    "1154"x
"pQrS"~BITAND(,"DF"x)          ->    "PQRS"      /* ASCII   */
]]>
</programlisting>
<para>(See <link linkend="bitand">BITAND (Bit by Bit AND)</link>
for information about the BITAND built-in function.)</para>
</section>

<section id="stbito"><title>BITOR</title>
<indexterm><primary>BITOR method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>BITOR method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>character</primary>
<secondary>strings, ORing</secondary></indexterm>
<indexterm><primary>ORing character together</primary></indexterm>

<programlisting>
<![CDATA[
>>-BITOR-+--------------------+--------------------------------><
         +-(string-+------+-)-+
                   +-,pad-+
]]>
</programlisting>

<para>Returns a string composed of the receiver string and the argument
<emphasis role="italic">string</emphasis> logically inclusive-ORed, bit by bit.
The encodings of the strings
are used in the logical operation. The length of the result is the length
of the longer of the two strings. If you omit the
<emphasis role="italic">pad</emphasis> character,
the OR operation stops when the shorter of the two strings is exhausted, and
the unprocessed portion of the longer string is appended to the partial result.
If you provide <emphasis role="italic">pad</emphasis>, it extends the shorter
of the two strings on the right before the logical operation. The default for
<emphasis role="italic">string</emphasis> is
the zero-length (null) string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>BITOR method</secondary></indexterm>
<programlisting>
<![CDATA[
"12"x~BITOR                   ->    "12"x
"15"x~BITOR("24"x)            ->    "35"x
"15"x~BITOR("2456"x)          ->    "3556"x
"15"x~BITOR("2456"x,"F0"x)    ->    "35F6"x
"1111"x~BITOR(,"4D"x)         ->    "5D5D"x
"pQrS"~BITOR(,"20"x)          ->    "pqrs" /* ASCII   */
]]>
</programlisting>
<para>(See <link linkend="bitor">BITOR (Bit by Bit OR)</link>
for information about the BITOR built-in function.)</para>
</section>

<section id="stbitx"><title>BITXOR</title>
<indexterm><primary>BITXOR method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>BITXOR method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>character</primary>
<secondary>strings, exclusive-ORing</secondary></indexterm>
<indexterm><primary>exclusive-ORing character strings together</primary>
</indexterm>
<indexterm><primary>XORing character strings together</primary></indexterm>

<programlisting>
<![CDATA[
>>-BITXOR-+--------------------+-------------------------------><
          +-(string-+------+-)-+
                    +-,pad-+
]]>
</programlisting>

<para>Returns a string composed of the receiver string and the argument
<emphasis role="italic">string</emphasis> logically eXclusive-ORed, bit by bit.
The encodings of the strings
are used in the logical operation. The length of the result is the length
of the longer of the two strings. If you omit the
<emphasis role="italic">pad</emphasis> character,
the XOR operation stops when the shorter of the two strings is exhausted,
and the unprocessed portion of the longer string is appended to the partial
result. If you provide <emphasis role="italic">pad</emphasis>,
it extends the shorter of the two strings
on the right before carrying out the logical operation. The default for
<emphasis role="italic">string</emphasis> is the zero-length (null) string.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>BITXOR method</secondary></indexterm>
<programlisting>
<![CDATA[
"12"x~BITXOR                      ->  "12"x
"12"x~BITXOR("22"x)               ->  "30"x
"1211"x~BITXOR("22"x)             ->  "3011"x
"1111"x~BITXOR("444444"x)         ->  "555544"x
"1111"x~BITXOR("444444"x,"40"x)   ->  "555504"x
"1111"x~BITXOR(,"4D"x)            ->  "5C5C"x
"C711"x~BITXOR("222222"x," ")     ->  "E53302"x  /* ASCII  */
]]>
</programlisting>
<para>(See <link linkend="ybitxor">BITXOR (Bit by Bit Exclusive OR)</link>
for information about the BITXOR built-in
function.)</para>
</section>

<section id="stc2d"><title>C2D</title>
<indexterm><primary>C2D method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>C2D method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>character</primary>
<secondary>to decimal conversion</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>character to decimal</secondary></indexterm>

<programlisting>
<![CDATA[
>>-C2D-+-----+-------------------------------------------------><
       +-(n)-+
]]>
</programlisting>

<para>Returns the decimal value of the binary representation of the receiving
string. If the result cannot be expressed as a whole number, an error results.
That is, the result must not have more digits than the current setting of
NUMERIC DIGITS. If you specify <emphasis role="italic">n</emphasis>, it is the
length of the returned result. If you do not specify
<emphasis role="italic">n</emphasis>, the receiving string is processed
as an unsigned binary number. If the receiving string is null, C2D returns
<computeroutput>0</computeroutput>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>C2D method</secondary></indexterm>
<programlisting>
<![CDATA[
"09"X~C2D       ->        9
"81"X~C2D       ->      129
"FF81"X~C2D     ->    65409
""~C2D          ->        0
"a"~C2D         ->       97     /*  ASCII   */
]]>
</programlisting>
<para>If you specify <emphasis role="italic">n</emphasis>, the receiving string
is taken as a signed number expressed in <emphasis role="italic">n</emphasis>
characters. The number is positive if the leftmost bit is off, and negative
if the leftmost bit is on. In both cases, it is converted
to a whole number, which can therefore be negative. The receiving string is
padded on the left with "00"x characters (not &quot;sign-extended&quot;),
or truncated on the left to <emphasis role="italic">n</emphasis> characters.
This padding or truncation is as though
<computeroutput>receiving_string~RIGHT(n,&apos;00&apos;x)</computeroutput> had
been processed. If <emphasis role="italic">n</emphasis> is
<computeroutput>0</computeroutput>, C2D always returns
<computeroutput>0</computeroutput>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
<![CDATA[
"81"X~C2D(1)      ->     -127
"81"X~C2D(2)      ->      129
"FF81"X~C2D(2)    ->     -127
"FF81"X~C2D(1)    ->     -127
"FF7F"X~C2D(1)    ->      127
"F081"X~C2D(2)    ->    -3967
"F081"X~C2D(1)    ->     -127
"0031"X~C2D(0)    ->        0
]]>
</programlisting>
<para>(See <link linkend="c2d">C2D (Character to Decimal)</link>
for information about the C2D built-in function.)</para>
</section>

<section id="stc2x"><title>C2X</title>
<indexterm><primary>C2X method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>C2X method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>character</primary>
<secondary>to hexadecimal conversion</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>character to hexadecimal</secondary></indexterm>
<indexterm><primary>unpacking a string</primary>
<secondary>with C2X</secondary></indexterm>

<programlisting>
<![CDATA[
>>-C2X---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string, in character format, that represents the receiving
string converted to hexadecimal. The returned string contains twice as many
bytes as the receiving string. On an ASCII system, sending a C2X message to the
receiving string <computeroutput>1</computeroutput> returns
<computeroutput>31</computeroutput> because "31"X
is the ASCII representation of <computeroutput>1</computeroutput>.</para>
<para>The returned string has uppercase alphabetic characters for the values
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput> and does
not include blanks. The receiving string
can be of any length. If the receiving string is null, C2X returns a null
string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>C2X method</secondary></indexterm>
<programlisting>
<![CDATA[
"0123"X~C2X    ->    "0123"   /* "30313233"X     in ASCII */
"ZD8"~C2X      ->    "5A4438" /* "354134343338"X in ASCII */
]]>
</programlisting>
<para>(See <link linkend="c2x">C2X (Character to Hexadecimal)</link>
for information about the C2X built-in function.)</para>
</section>

<section id="stcent"><title>CENTER/CENTRE</title>
<indexterm><primary>CENTER method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CENTER method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>CENTRE method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CENTRE method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text centering</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>centering using CENTER function</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>centering using CENTRE function</secondary></indexterm>

<programlisting>
<![CDATA[
>>-+-CENTER(-+-length-+--------+-)-----------------------------><
   +-CENTRE(-+        +-,--pad-+
]]>
</programlisting>

<para>Returns a string of length <emphasis role="italic">length</emphasis>
with the receiving string centered in it. The language processor adds
<emphasis role="italic">pad</emphasis> characters as necessary to
make up length. The <emphasis role="italic">length</emphasis> must be a
positive whole number or zero. The default
<emphasis role="italic">pad</emphasis> character is blank. If the receiving
string is longer than <emphasis role="italic">length</emphasis>, it is
truncated at both ends to fit. If an odd number
of characters are truncated or added, the right-hand end loses or gains one
more character than the left-hand end. </para>

<note><title>Note</title>
<para>To avoid errors because
of the difference between British and American spellings, this method can
be called either CENTRE or CENTER.</para></note>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>CENTER method</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>CENTRE method</secondary></indexterm>
<programlisting>
<![CDATA[
abc~CENTER(7)               ->    "  ABC  "
abc~CENTER(8,"-")           ->    "--ABC---"
"The blue sky"~CENTRE(8)    ->    "e blue s"
"The blue sky"~CENTRE(7)    ->    "e blue "
]]>
</programlisting>
<para>(See <link linkend="centre">CENTER (or CENTRE)</link>
for information about the CENTER built-in function.)</para>
</section>

<section id="stchst"><title>CHANGESTR</title>
<indexterm><primary>CHANGESTR method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CHANGESTR method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CHANGESTR(needle,newneedle)---------------------------------><
]]>
</programlisting>

<para>Returns a copy of the receiver object in which
<emphasis role="italic">newneedle</emphasis> replaces
all occurrences of <emphasis role="italic">needle</emphasis>.</para>
<para>Here are some examples:</para>
<indexterm><primary>examples</primary>
<secondary>CHANGESTR method</secondary></indexterm>
<programlisting>
<![CDATA[
101100~CHANGESTR("1","")     ->    "000"
101100~CHANGESTR("1","X")    ->    "X0XX00"
]]>
</programlisting>
<para>(See <link linkend="xchgstr">CHANGESTR</link>
for information about the CHANGESTR built-in
function.)</para>
</section>

<section id="stcomp"><title>COMPARE</title>
<indexterm><primary>COMPARE method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>COMPARE method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>comparisons</primary>
<secondary>of strings</secondary></indexterm>
<indexterm><primary>finding</primary>
<secondary>mismatch using COMPARE</secondary></indexterm>

<programlisting>
<![CDATA[
>>-COMPARE(string-+------+-)-----------------------------------><
                  +-,pad-+
]]>
</programlisting>

<para>Returns <computeroutput>0</computeroutput> if the argument
<emphasis role="italic">string</emphasis> is identical to the
receiving string. Otherwise, returns the position of the first character that
does not match. The shorter string is padded on the right with
<emphasis role="italic">pad</emphasis> if
necessary. The default <emphasis role="italic">pad</emphasis> character is a
blank.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>COMPARE method</secondary></indexterm>
<programlisting>
<![CDATA[
"abc"~COMPARE("abc")         ->    0
"abc"~COMPARE("ak")          ->    2
"ab "~COMPARE("ab")          ->    0
"ab "~COMPARE("ab"," ")      ->    0
"ab "~COMPARE("ab","x")      ->    3
"ab-- "~COMPARE("ab","-")    ->    5
]]>
</programlisting>
<para>(See <link linkend="compare">COMPARE</link>  for information about the
COMPARE built-in function.)</para>
</section>

<section id="stcopi"><title>COPIES</title>
<indexterm><primary>COPIES method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>COPIES method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>copying a string using COPIES</primary></indexterm>
<indexterm><primary>repeating s string with COPIES</primary></indexterm>
<indexterm><primary>string</primary>
<secondary>copying using COPIES</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>repeating using COPIES</secondary></indexterm>

<programlisting>
<![CDATA[
>>-COPIES(n)---------------------------------------------------><
]]>
</programlisting>

<para>Returns <emphasis role="italic">n</emphasis> concatenated copies of the
receiving string. The <emphasis role="italic">n</emphasis> must be a positive
whole number or zero.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>COPIES method</secondary></indexterm>
<programlisting>
<![CDATA[
"abc"~COPIES(3)    ->    "abcabcabc"
"abc"~COPIES(0)    ->    ""
]]>
</programlisting>
<para>(See <link linkend="copies">COPIES</link>  for information about the
COPIES built-in function.)</para>
</section>

<section id="stcous"><title>COUNTSTR</title>
<indexterm><primary>COUNTSTR method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>COUNTSTR method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-COUNTSTR(needle)--------------------------------------------><
]]>
</programlisting>

<para>Returns a count of the occurrences of
<emphasis role="italic">needle</emphasis> in the receiving
string that do not overlap.</para>
<para>Here are some examples:</para>
<indexterm><primary>examples</primary>
<secondary>COUNTSTR method</secondary></indexterm>
<programlisting>
<![CDATA[
"101101"~COUNTSTR("1")        ->    4
"J0KKK0"~COUNTSTR("KK")       ->    1
]]>
</programlisting>
<para>(See <link linkend="chgtr">COUNTSTR</link>
for information about the COUNTSTR built-in
function.)</para>
</section>

<section id="std2c"><title>D2C</title>
<indexterm><primary>D2C method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>D2C method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>decimal to character</secondary></indexterm>
<indexterm><primary>decimal</primary>
<secondary>to character conversion</secondary></indexterm>

<programlisting>
<![CDATA[
>>-D2C-+-----+-------------------------------------------------><
       +-(n)-+
]]>
</programlisting>

<para>Returns a string, in character format, that is the ASCII representation
of the receiving string, a decimal number. If you specify
<emphasis role="italic">n</emphasis>, it is
the length of the final result in characters; leading blanks are added to
the returned string. The <emphasis role="italic">n</emphasis> must be a
positive whole number or zero.</para>
<para>The receiving string must not have more digits than the current setting
of NUMERIC DIGITS.</para>
<para>If you omit <emphasis role="italic">n</emphasis>, the receiving string
must be a positive whole number
or zero, and the result length is as needed. Therefore, the returned result
has no leading "00"x characters.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>D2C method</secondary></indexterm>
<programlisting>
"65"~D2C       ->   "A"      /* "41"x is an ASCII "A"    */
"65"~D2C(1)    ->   "A"
"65"~D2C(2)    ->   " A"
"65"~D2C(5)    ->   "    A"
"109"~D2C      ->   "m"      /* "6D"x  is an ASCII "m"   */
"-109"~D2C(1)  ->   "&ocirc;"      /* "93"x  is an ASCII "&ocirc;"   */
"76"~D2C(2)    ->   " L"     /* "4C"x  is an ASCII " L"  */
"-180"~D2C(2)  ->   " L"
</programlisting>
<indexterm><primary>implementation maximum</primary>
<secondary>D2C method</secondary></indexterm>
<para>Implementation maximum: The returned string must not have more than 250
significant
characters, although a longer result is possible if it has additional leading
sign characters ("00"x and "FF"x).</para>
<para>(See <link linkend="d2c">D2C (Decimal to Character)</link>
for information about the D2C built-in function.)</para>
</section>

<section id="std2x"><title>D2X</title>
<indexterm><primary>D2X method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>D2X method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>decimal to hexadecimal</secondary></indexterm>
<indexterm><primary>decimal</primary>
<secondary>to hexadecimal conversion</secondary></indexterm>

<programlisting>
<![CDATA[
>>-D2X-+-----+-------------------------------------------------><
       +-(n)-+
]]>
</programlisting>

<para>Returns a string, in character format, that represents the receiving
string, a decimal number converted to hexadecimal. The returned string uses
uppercase alphabetic characters for the values
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput> and does
not include blanks.</para>
<para>The receiving string must not have more digits than the current setting
of NUMERIC DIGITS.</para>
<para>If you specify <emphasis role="italic">n</emphasis>, it is the length of
the final result in characters.
After conversion the returned string is sign-extended to the required length.
If the number is too big to fit into <emphasis role="italic">n</emphasis>
characters, it is truncated
on the left. If you specify <emphasis role="italic">n</emphasis>, it must be a
positive whole number or zero.</para>
<para>If you omit <emphasis role="italic">n</emphasis>, the receiving string
must be a positive whole number
or zero, and the returned result has no leading zeros.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>D2X method</secondary></indexterm>
<programlisting>
"9"~D2X        ->    "9"
"129"~D2X      ->    "81"
"129"~D2X(1)   ->    "1"
"129"~D2X(2)   ->    "81"
"129"~D2X(4)   ->    "0081"
"257"~D2X(2)   ->    "01"
"-127"~D2X(2)  ->    "81"
"-127"~D2X(4)  ->    "FF81"
"12"~D2X(0)    ->    ""
</programlisting>
<indexterm><primary>implementation maximum</primary>
<secondary>D2X method</secondary></indexterm>
<para>Implementation maximum: The returned string must not have more than 500
significant hexadecimal characters, although a longer result is possible if it
has additional leading sign characters (0 and F).</para>
<para>(See <link linkend="d2x">D2X (Decimal to Hexadecimal)</link>
for information about the D2X built-in function.)</para>
</section>

<section id="stdata"><title>DATATYPE</title>
<indexterm><primary>DATATYPE method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DATATYPE method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>alphabetics</primary>
<secondary>checking with DATATYPE</secondary></indexterm>
<indexterm><primary>alphnumerics</primary>
<secondary>checking with DATATYPE</secondary></indexterm>
<indexterm><primary>bits checked using DATATYPE method</primary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>checking with DATATYPE</secondary></indexterm>
<indexterm><primary>type of data, checking with DATATYPE</primary></indexterm>
<indexterm><primary>whole numbers</primary>
<secondary>checking with DATATYPE</secondary></indexterm>
<indexterm><primary>numbers</primary>
<secondary>checking with DATATYPE</secondary></indexterm>

<programlisting>
<![CDATA[
>>-DATATYPE-+--------+-----------------------------------------><
            +-(type)-+
]]>
</programlisting>

<para>Returns <computeroutput>NUM</computeroutput> if you specify no argument
and the receiving string
is a valid Rexx number that can be added to 0 without error. It returns
<computeroutput>CHAR</computeroutput> if the receiving string is not a
valid number.</para>
<para>If you specify <emphasis role="italic">type</emphasis>, it returns
<computeroutput>1</computeroutput> if the receiving
string matches the type. Otherwise, it returns
<computeroutput>0</computeroutput>. If the receiving
string is null, the method returns <computeroutput>0</computeroutput>
(except when the <emphasis role="italic">type</emphasis> is
<computeroutput>X</computeroutput> or <computeroutput>B</computeroutput>,
for which DATATYPE returns <computeroutput>1</computeroutput> for
a null string). The following are valid
<emphasis role="italic">type</emphasis>s. You need to specify
only the capitalized letter, or the number of the last type listed. The language
processor ignores all characters surrounding it.</para>
<variablelist>
<varlistentry><term>Alphanumeric</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only characters from the ranges
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>,
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>, and
<computeroutput>0</computeroutput>-<computeroutput>9</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Binary</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only the characters <computeroutput>0</computeroutput> or
<computeroutput>1</computeroutput>, or a blank. Blanks can appear only between
groups of 4 binary characters. It also returns 1 if string is
a null string, which is a valid binary string.
</para></listitem></varlistentry>
<varlistentry><term>Lowercase</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only characters from the range
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Mixed case</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only characters from the ranges
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput> and
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Number</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<computeroutput>receiving_string~DATATYPE</computeroutput> returns
<computeroutput>NUM</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>lOgical</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
the receiving string is exactly "0" or "1". Otherwise it returns
<computeroutput>0</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Symbol</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string is a valid symbol, that is, if SYMBOL(string) does not return
<computeroutput>BAD</computeroutput>. (See
<link linkend="xsymbol">Symbols</link>.)
Note that both uppercase and lowercase alphabetic characters are permitted.
</para></listitem></varlistentry>
<varlistentry><term>Uppercase</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only characters from the range
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Variable</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string could appear on the left-hand
side of an assignment without causing a SYNTAX condition.
</para></listitem></varlistentry>
<varlistentry><term>Whole number</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string is a whole number under the current setting of NUMERIC DIGITS.
</para></listitem></varlistentry>
<varlistentry><term>heXadecimal</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only characters from the ranges
<computeroutput>a</computeroutput>-<computeroutput>f</computeroutput>,
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput>,
<computeroutput>0</computeroutput>-<computeroutput>9</computeroutput>,
and blank (as long as blanks appear
only between pairs of hexadecimal characters). Also returns
<computeroutput>1</computeroutput> if
the receiving string is a null string.
</para></listitem></varlistentry>
<varlistentry><term>9 Digits</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<computeroutput>receiving_string~DATATYPE("W")</computeroutput> returns
<computeroutput>1</computeroutput> when NUMERIC DIGITS is set to 9.
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>DATATYPE method</secondary></indexterm>
<programlisting>
<![CDATA[
" 12 "~DATATYPE          ->   "NUM"
""~DATATYPE              ->   "CHAR"
"123*"~DATATYPE          ->   "CHAR"
"12.3"~DATATYPE("N")     ->    1
"12.3"~DATATYPE("W")     ->    0
"Fred"~DATATYPE("M")     ->    1
""~DATATYPE("M")         ->    0
"Fred"~DATATYPE("L")     ->    0
"?20K"~DATATYPE("s")     ->    1
"BCd3"~DATATYPE("X")     ->    1
"BC d3"~DATATYPE("X")    ->    1
"1"~DATATYPE("O")        ->    1
"11"~DATATYPE("O")        ->   0
]]>
</programlisting><para> </para>

<note><title>Note</title>
<para>The DATATYPE method tests the meaning or type of characters in a
string, independent of the encoding of those characters (for example, ASCII
or EBCDIC).</para></note>
<para>(See <link linkend="datatyp">DATATYPE</link> for information about the
DATATYPE built-in function.)</para>
</section>

<section id="decodebase64"><title>DECODEBASE64</title>
<indexterm><primary>DECODEBASE64 method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DECODEBASE64 method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>base64</primary>
<secondary>DECODEBASE64 method</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>DECODEBASE64 method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-DECODEBASE64------------------------------------------------><
]]>
</programlisting>

<para>Returns the decoded version of the base64 encoded recieving string.
If the recieving string is not in base64 format then the
returned result is undefined.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>DECODEBASE64 method</secondary></indexterm>
<programlisting>
<![CDATA[
"YWJjZGVm"~DECODEBASE64       ->    "abcdef"
]]>
</programlisting>
<para>Please note that there is no corresponding DECODEBASE64 builtin function
for this method in ooRexx.</para>
</section>

<section id="stdels"><title>DELSTR</title>
<indexterm><primary>DELSTR method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DELSTR method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>deleting</primary>
<secondary>part of a string</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>deleting part, DELSTR method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-DELSTR(n--+---------+--)------------------------------------><
             +-,length-+
]]>
</programlisting>

<para>Returns a copy of the receiving string after deleting the substring that
begins at the <emphasis role="italic">n</emphasis>th character and is of
<emphasis role="italic">length</emphasis> characters.
If you omit <emphasis role="italic">length</emphasis>, or if
<emphasis role="italic">length</emphasis> is greater than the number
of characters from <emphasis role="italic">n</emphasis> to the end of
<emphasis role="italic">string</emphasis>, the method deletes
the rest of <emphasis role="italic">string</emphasis> (including the
<emphasis role="italic">n</emphasis>th character). The
<emphasis role="italic">length</emphasis> must be a positive whole number or
zero. The <emphasis role="italic">n</emphasis> must be
a positive whole number. If <emphasis role="italic">n</emphasis> is greater
than the length of the receiving
string, the method returns the receiving string unchanged.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>DELSTR method</secondary></indexterm>
<programlisting>
<![CDATA[
"abcd"~DELSTR(3)       ->    "ab"
"abcde"~DELSTR(3,2)    ->    "abe"
"abcde"~DELSTR(6)      ->    "abcde"
]]>
</programlisting>
<para>(See <link linkend="delstr">DELSTR (Delete String)</link>
for information about the DELSTR built-in function.)</para>
</section>

<section id="stdelw"><title>DELWORD</title>
<indexterm><primary>DELWORD method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DELWORD method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>deleting</primary>
<secondary>words from a string</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>deleting from a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-DELWORD(n--+---------+--)-----------------------------------><
              +-,length-+
]]>
</programlisting>

<para>Returns a copy of the receiving string after deleting the substring that
starts at the <emphasis role="italic">n</emphasis>th word and is of
<emphasis role="italic">length</emphasis> blank-delimited
words. If you omit <emphasis role="italic">length</emphasis>, or if
<emphasis role="italic">length</emphasis> is greater than
the number of words from <emphasis role="italic">n</emphasis> to the end of the
receiving string, the
method deletes the remaining words in the receiving string (including the
<emphasis role="italic">n</emphasis>th word). The
<emphasis role="italic">length</emphasis> must be a positive whole number or
zero. The <emphasis role="italic">n</emphasis> must be a positive whole number.
If <emphasis role="italic">n</emphasis> is greater than
the number of words in the receiving string, the method returns the receiving
string unchanged. The string deleted includes any blanks following the final
word involved but none of the blanks preceding the first word involved.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>DELWORD method</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>INSERT method</secondary></indexterm>
<programlisting>
<![CDATA[
"Now is the  time"~DELWORD(2,2)  ->  "Now time"
"Now is the time "~DELWORD(3)    ->  "Now is "
"Now is the  time"~DELWORD(5)    ->  "Now is the  time"
"Now is   the time"~DELWORD(3,1) ->  "Now is   time"
]]>
</programlisting>
<para>(See <link linkend="delword">DELWORD (Delete Word)</link>
for information about the DELWORD built-in function.)</para>
</section>

<section id="encodebase64"><title>ENCODEBASE64</title>
<indexterm><primary>ENCODEBASE64 method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ENCODEBASE64 method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>base64</primary>
<secondary>ENCODEBASE64 method</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>ENCODEBASE64 method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-ENCODEBASE64------------------------------------------------><
]]>
</programlisting>

<para>Returns the base64 encoded version of the recieving string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>ENCODEBASE64 method</secondary></indexterm>
<programlisting>
<![CDATA[
"abcdef"~ENCODEBASE64       ->    "YWJjZGVm"
]]>
</programlisting>
<para>Please note that there is no corresponding ENCODEBASE64 builtin function
for this method in ooRexx.</para>
</section>

<section id="stform"><title>FORMAT</title>
<indexterm><primary>FORMAT method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>FORMAT method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>formating numbers</secondary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>numbers for display</secondary></indexterm>
<indexterm><primary>numbers</primary>
<secondary>formatting for display</secondary></indexterm>
<indexterm><primary>numbers for display</primary></indexterm>

<programlisting>
<![CDATA[
>>-FORMAT-+---------------------------------------------------------+-><
          +-(-before-+------------------------------------------+-)-+
                     +-,--+-------+--+------------------------+-+
                          +-after-+  +-,--+------+--+-------+-+
                                          +-expp-+  +-,expt-+
]]>
</programlisting>

<para>Returns the receiving string, a number, rounded and formatted.</para>
<para>The number is first rounded according to standard Rexx rules, as though
the operation <computeroutput>receiving_string+0</computeroutput> had been
carried out. If you
specify no arguments the result of the method is the same as the result of
this operation. If you specify any options, the number is formatted as
described in the following.</para>
<para>The <emphasis role="italic">before</emphasis> and
<emphasis role="italic">after</emphasis> options describe how many characters
are to be used for the integer and decimal parts of the result. If you omit
either or both of them, the number of characters for that part is as needed.
</para>
<para>If <emphasis role="italic">before</emphasis> is not large enough to
contain the integer part of the
number (plus the sign for a negative number), an error results. If
<emphasis role="italic">before</emphasis> is larger than needed for that part,
the number is padded on the left with blanks. If
<emphasis role="italic">after</emphasis> is not the same size as the decimal
part of the number, the number is rounded (or extended with zeros) to fit.
Specifying <computeroutput>0</computeroutput> causes the number to be rounded
to an integer.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>FORMAT method</secondary></indexterm>
<programlisting>
"3"~FORMAT(4)            ->    "   3"
"1.73"~FORMAT(4,0)       ->    "   2"
"1.73"~FORMAT(4,3)       ->    "   1.730"
"-.76"~FORMAT(4,1)       ->    "  -0.8"
"3.03"~FORMAT(4)         ->    "   3.03"
" - 12.73"~FORMAT(,4)    ->    "-12.7300"
" - 12.73"~FORMAT        ->    "-12.73"
"0.000"~FORMAT           ->    "0"
</programlisting>
<para><emphasis role="italic">expp</emphasis> and
<emphasis role="italic">expt</emphasis> control the exponent part of the result,
which, by default, is formatted according to the current NUMERIC settings
of DIGITS and FORM. <emphasis role="italic">expp</emphasis> sets the number of
places for the exponent part; the default is to use as many as needed
(which can be zero). <emphasis role="italic">expt</emphasis>
specifies when the exponential expression is used. The default is the
current setting of NUMERIC DIGITS.</para>
<para>If <emphasis role="italic">expp</emphasis> is
<computeroutput>0</computeroutput>, the number is not an exponential expression.
If <emphasis role="italic">expp</emphasis> is not large enough to contain the
exponent, an error results.</para>
<para>If the number of places needed for the integer or decimal part exceeds
<emphasis role="italic">expt</emphasis> or twice
<emphasis role="italic">expt</emphasis>, respectively, exponential notation is
used. If <emphasis role="italic">expt</emphasis> is
<computeroutput>0</computeroutput>, exponential notation is always used unless
the exponent would be <computeroutput>0</computeroutput>. (If
<emphasis role="italic">expp</emphasis> is
<computeroutput>0</computeroutput>, this
overrides a <computeroutput>0</computeroutput> value of
<emphasis role="italic">expt</emphasis>.) If the exponent would be
<computeroutput>0</computeroutput> when a nonzero
<emphasis role="italic">expp</emphasis> is specified, then
<emphasis role="italic">expp</emphasis>+2 blanks
are supplied for the exponent part of the result. If the exponent would be
<computeroutput>0</computeroutput> and <emphasis role="italic">expp</emphasis>
is not specified, the number is not an exponential
expression.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
"12345.73"~FORMAT(, ,2,2)   ->    "1.234573E+04"
"12345.73"~FORMAT(,3, ,0)   ->    "1.235E+4"
"1.234573"~FORMAT(,3, ,0)   ->    "1.235"
"12345.73"~FORMAT(, ,3,6)   ->    "12345.73"
"1234567e5"~FORMAT(,3,0)    ->    "123456700000.000"
</programlisting>
<para>(See <link linkend="xformat">FORMAT</link>  for information about the
FORMAT built-in function.)</para>
</section>

<section id="stinse"><title>INSERT</title>
<indexterm><primary>INSERT method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INSERT method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>inserting a string into another</primary></indexterm>

<programlisting>
<![CDATA[
>>-INSERT(new-+---------------------------------------+-)------><
              +-,--+---+--+-------------------------+-+
                   +-n-+  +-,--+--------+--+------+-+
                               +-length-+  +-,pad-+
]]>
</programlisting>

<para>Inserts the string <emphasis role="italic">new</emphasis>, padded or
truncated to length <emphasis role="italic">length</emphasis>, into the
receiving string. after the <emphasis role="italic">n</emphasis>th character.
The default value for <emphasis role="italic">n</emphasis> is
<computeroutput>0</computeroutput>, which means insertion at the beginning
of the string. If specified, <emphasis role="italic">n</emphasis> and
<emphasis role="italic">length</emphasis> must be positive
whole numbers or zero. If <emphasis role="italic">n</emphasis> is greater than
the length of the receiving string, the string
<emphasis role="italic">new</emphasis> is padded at the beginning. The default
value for <emphasis role="italic">length</emphasis> is the length of
<emphasis role="italic">new</emphasis>. If
<emphasis role="italic">length</emphasis> is less
than the length of the string <emphasis role="italic">new</emphasis>,
then INSERT truncates <emphasis role="italic">new</emphasis> to length
<emphasis role="italic">length</emphasis>. The default
<emphasis role="italic">pad</emphasis> character is a blank.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>INSERT method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
"abc"~INSERT("123")            ->    "123abc"
"abcdef"~INSERT(" ",3)         ->    "abc def"
"abc"~INSERT("123",5,6)        ->    "abc  123   "
"abc"~INSERT("123",5,6,"+")    ->    "abc++123+++"
"abc"~INSERT("123", ,5,"-")    ->    "123--abc"
</programlisting>
<para>(See <link linkend="insert">INSERT</link>
for information about the INSERT built-in function.)</para>
</section>

<section id="stlast"><title>LASTPOS</title>
<indexterm><primary>LASTPOS method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LASTPOS method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>position</primary>
<secondary>last occurrence of a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-LASTPOS(needle-+--------+-)---------------------------------><
                  +-,start-+
]]>
</programlisting>

<para>Returns the position of the last occurrence of a string,
<emphasis role="italic">needle</emphasis>,
in the receiving string. (See also <link linkend="stpos">POS</link>.) It
returns <computeroutput>0</computeroutput> if
<emphasis role="italic">needle</emphasis> is the null string or not found.
By default, the search starts at the last character of the receiving string
and scans backward. You can override this by specifying
<emphasis role="italic">start</emphasis>, the point at which the
backward scan starts. The <emphasis role="italic">start</emphasis> must be a
positive whole number and defaults to
<computeroutput>receiving_string~length</computeroutput> if larger than that
value or omitted.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>LASTPOS method</secondary></indexterm>
<programlisting>
"abc def ghi"~LASTPOS(" ")      ->    8
"abcdefghi"~LASTPOS(" ")        ->    0
"efgxyz"~LASTPOS("xy")          ->    4
"abc def ghi"~LASTPOS(" ",7)    ->    4
</programlisting>
<para>(See <link linkend="lastpos">LASTPOS (Last Position)</link>
for information about the LASTPOS built-in function.)</para>
</section>

<section id="stleft"><title>LEFT</title>
<indexterm><primary>LEFT method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LEFT method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text left justification</secondary></indexterm>

<programlisting>
<![CDATA[
>>-LEFT(length-+------+-)--------------------------------------><
               +-,pad-+
]]>
</programlisting>

<para>Returns a string of length <emphasis role="italic">length</emphasis>,
containing the leftmost <emphasis role="italic">length</emphasis> characters
of the receiving string. The string returned is padded
with <emphasis role="italic">pad</emphasis> characters (or truncated) on the
right as needed. The default <emphasis role="italic">pad</emphasis> character
is a blank. The <emphasis role="italic">length</emphasis> must be a positive
whole number or zero. The LEFT method is exactly equivalent to:</para>
<programlisting>
<![CDATA[
>>-SUBSTR(string,1,length-+------+-)---------------------------><
                          +-,pad-+
]]>
</programlisting>

<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>LEFT method</secondary></indexterm>
<programlisting>
"abc d"~LEFT(8)        ->    "abc d   "
"abc d"~LEFT(8,".")    ->    "abc d..."
"abc  def"~LEFT(7)     ->    "abc  de"
</programlisting>
<para>(See <link linkend="left">LEFT</link>
for information about the LEFT built-in function.)</para>
</section>

<section id="stleng"><title>LENGTH</title>
<indexterm><primary>LENGTH method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LENGTH method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>finding</primary>
<secondary>string length</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>finding length of</secondary></indexterm>

<programlisting>
<![CDATA[
>>-LENGTH------------------------------------------------------><
]]>
</programlisting>

<para>Returns the length of the receiving string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>LENGTH method</secondary></indexterm>
<programlisting>
"abcdefgh"~LENGTH     ->    8
"abc defg"~LENGTH     ->    8
""~LENGTH             ->    0
</programlisting>
<para>(See <link linkend="length">LENGTH</link>
for information about the LENGTH built-in function.)</para>
</section>

<section id="stmaka"><title>MAKEARRAY</title>
<indexterm><primary>MAKEARRAY method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MAKEARRAY method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MAKEARRAY(-+-----------+-)----><
              +-Separator-+
]]>
</programlisting>

<para>This method returns an array of strings containing the single
lines that were separated using the separator character. The
default separator is the newline character.</para>

<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[
nl = "0d0a"x
string = "hello"nl"world"nl"this is an array."
array = string~makearray
say "the second line is:" array[2]

string = "hello*world*this is an array."
array = string~makearray("*")
say "the third line is:" array[3]
]]>
</programlisting>
</section>



<section id="stmaks"><title>MAKESTRING</title>
<indexterm><primary>MAKESTRING method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MAKESTRING method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MAKESTRING--------------------------------------------------><
]]>
</programlisting>

<para>Returns a string with the same string value as the receiver object. If
the receiver is an instance of a subclass of the String class, this method
returns an equivalent string object. If the receiver is a string object (not
an instance of a subclass of the String class), this method returns the receiver
object. See <link linkend="reqstr">Required String Values</link>.</para>
</section>

<section id="stmax"><title>MAX</title>
<indexterm><primary>MAX method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MAX method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MAX-+------------------+------------------------------------><
       |    +-,------.    |
       |    V        |    |
       +-(----number-+--)-+
]]>
</programlisting>

<para>Returns the largest number from among the receiver and any arguments. The
number that MAX returns is formatted according to the current NUMERIC settings.
You can specify any number of <emphasis role="italic">number</emphasis>s.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>MAX method</secondary></indexterm>
<programlisting>
12~MAX(6,7,9)                                                ->    12
17.3~MAX(19,17.03)                                           ->    19
"-7"~MAX("-3","-4.3")                                        ->    -3
1~MAX(2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)   ->    21
</programlisting>
<para>(See <link linkend="max">MAX (Maximum)</link>
for information about the MAX built-in function.)</para>
</section>

<section id="stmin"><title>MIN</title>
<indexterm><primary>MIN method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MIN method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MIN-+------------------+------------------------------------><
       |    +-,------.    |
       |    V        |    |
       +-(----number-+--)-+
]]>
</programlisting>

<para>Returns the smallest number from among the receiver and any arguments.
The number that MIN returns is formatted according to the current NUMERIC
settings. You can specify any number of
<emphasis role="italic">number</emphasis>s.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>MIN method</secondary></indexterm>
<programlisting>
12~MIN(6,7,9)                                                ->     6
17.3~MIN(19,17.03)                                           ->    17.03
"-7"~MIN("-3","-4.3")                                        ->    -7
21~MIN(20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1)   ->     1
</programlisting>
<para>(See <link linkend="min">MIN (Minimum)</link>
for information about the MIN built-in function.)</para>
</section>

<section id="stover"><title>OVERLAY</title>
<indexterm><primary>OVERLAY method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>OVERLAY method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>overlaying a string onto another</primary></indexterm>

<programlisting>
<![CDATA[
>>-OVERLAY(new-+---------------------------------------+-)-----><
               +-,--+---+--+-------------------------+-+
                    +-n-+  +-,--+--------+--+------+-+
                                +-length-+  +-,pad-+
]]>
</programlisting>

<para>Returns the receiving string, which, starting at the
<emphasis role="italic">n</emphasis>th character,
is overlaid with the string <emphasis role="italic">new</emphasis>,
padded or truncated to length <emphasis role="italic">length</emphasis>.
The overlay can extend beyond the end of the receiving string.
If you specify <emphasis role="italic">length</emphasis>, it must be a positive
whole number or zero. The default value for
<emphasis role="italic">length</emphasis> is the length of
<emphasis role="italic">new</emphasis>. If <emphasis role="italic">n</emphasis>
is greater than the length of the receiving string, padding is added
before the <emphasis role="italic">new</emphasis> string. The default
<emphasis role="italic">pad</emphasis> character is a blank,
and the default value for <emphasis role="italic">n</emphasis> is
<computeroutput>1</computeroutput>. If you specify
<emphasis role="italic">n</emphasis>, it must be a positive whole number.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>OVERLAY method</secondary></indexterm>
<programlisting>
"abcdef"~OVERLAY(" ",3)         ->    "ab def"
"abcdef"~OVERLAY(".",3,2)       ->    "ab. ef"
"abcd"~OVERLAY("qq")            ->    "qqcd"
"abcd"~OVERLAY("qq",4)          ->    "abcqq"
"abc"~OVERLAY("123",5,6,"+")    ->    "abc+123+++"
</programlisting>
<para>(See <link linkend="overlay">OVERLAY</link>
for information about the OVERLAY built-in function.)</para>
</section>

<section id="stpos"><title>POS</title>
<indexterm><primary>POS method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>POS method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>finding</primary>
<secondary>string in another string</secondary></indexterm>
<indexterm><primary>locating</primary>
<secondary>string in another string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-POS(needle-+--------+-)-------------------------------------><
              +-,start-+
]]>
</programlisting>

<para>Returns the position in the receiving string of another string,
<emphasis role="italic">needle</emphasis>. (See also
<link linkend="stlast">LASTPOS</link>.) It returns
<computeroutput>0</computeroutput> if
<emphasis role="italic">needle</emphasis> is the null string or is not found
or if <emphasis role="italic">start</emphasis> is greater than
the length of the receiving string. By default, the search starts at the first
character of the receiving string (that is, the value of
<emphasis role="italic">start</emphasis> is <computeroutput>1</computeroutput>).
You can override this by specifying <emphasis role="italic">start</emphasis>
(which must be
a positive whole number), the point at which the search starts.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>POS method</secondary></indexterm>
<programlisting>
"Saturday"~POS("day")       ->    6
"abc def ghi"~POS("x")      ->    0
"abc def ghi"~POS(" ")      ->    4
"abc def ghi"~POS(" ",5)    ->    8
</programlisting>
<para>(See <link linkend="pos">POS (Position)</link>
for information about the POS built-in function.)</para>
</section>

<section id="streve"><title>REVERSE</title>
<indexterm><primary>REVERSE method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>REVERSE method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-REVERSE-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the receiving string reversed.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>REVERSE method</secondary></indexterm>
<programlisting>
"ABc."~REVERSE    ->    ".cBA"
"XYZ "~REVERSE    ->    " ZYX"
</programlisting>
<para>(See <link linkend="reverse">REVERSE</link>
for information about the REVERSE built-in function.)</para>
</section>

<section id="strigh"><title>RIGHT</title>
<indexterm><primary>RIGHT method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>RIGHT method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text right justification</secondary></indexterm>
<indexterm><primary>justification, text right, RIGHT method</primary>
</indexterm>
<indexterm><primary>leading</primary>
<secondary>zeros</secondary>
<tertiary>adding with RIGHT method</tertiary></indexterm>
<indexterm><primary>zeros</primary>
<secondary>added on left with RIGHT method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-RIGHT(length-+------+-)-------------------------------------><
                +-,pad-+
]]>
</programlisting>

<para>Returns a string of length <emphasis role="italic">length</emphasis>
containing the rightmost <emphasis role="italic">length</emphasis> characters
of the receiving string. The string returned is padded
with <emphasis role="italic">pad</emphasis> characters, or truncated, on the
left as needed. The default <emphasis role="italic">pad</emphasis> character
is a blank. The <emphasis role="italic">length</emphasis> must be a positive
whole number or zero.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>RIGHT method</secondary></indexterm>
<programlisting>
"abc  d"~RIGHT(8)     ->    "  abc  d"
"abc def"~RIGHT(5)    ->    "c def"
"12"~RIGHT(5,"0")     ->    "00012"
</programlisting>
<para>(See <link linkend="right">RIGHT</link>
for information about the RIGHT built-in function.)</para>
</section>

<section id="stsign"><title>SIGN</title>
<indexterm><primary>SIGN method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SIGN method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SIGN--------------------------------------------------------><
]]>
</programlisting>

<para>Returns a number that indicates the sign of the receiving string, which
is a number. The receiving string is first rounded according to standard Rexx
rules, as though the operation
<computeroutput>receiving_string+0</computeroutput> had been carried
out. It returns <computeroutput>-1</computeroutput> if the receiving string is
less than <computeroutput>0</computeroutput>,
<computeroutput>0</computeroutput> if it is
<computeroutput>0</computeroutput>, and <computeroutput>1</computeroutput>
if it is greater than <computeroutput>0</computeroutput>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>SIGN method</secondary></indexterm>
<programlisting>
"12.3"~SIGN       ->     1
" -0.307"~SIGN    ->    -1
0.0~SIGN          ->     0
</programlisting>
<para>(See <link linkend="sign">SIGN</link>
for information about the SIGN built-in function.)</para>
</section>

<section id="stspac"><title>SPACE</title>
<indexterm><primary>SPACE method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SPACE method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text spacing</secondary></indexterm>
<indexterm><primary>spacing, formatting, SPACE method</primary></indexterm>

<programlisting>
<![CDATA[
>>-SPACE-+---------------+-------------------------------------><
         +-(n-+------+-)-+
              +-,pad-+
]]>
</programlisting>

<para>Returns the blank-delimited words in the receiving string, with
<emphasis role="italic">n</emphasis>&nbsp;<emphasis role="italic">pad</emphasis>
characters between each word. If you specify
<emphasis role="italic">n</emphasis>, it must
be a positive whole number or zero. If it is
<computeroutput>0</computeroutput>, all blanks are
removed. Leading and trailing blanks are always removed. The default for
<emphasis role="italic">n</emphasis> is <computeroutput>1</computeroutput>,
and the default <emphasis role="italic">pad</emphasis> character is a blank.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>SPACE method</secondary></indexterm>
<programlisting>
"abc  def  "~SPACE           ->    "abc def"
"  abc def"~SPACE(3)         ->    "abc   def"
"abc  def  "~SPACE(1)        ->    "abc def"
"abc  def  "~SPACE(0)        ->    "abcdef"
"abc  def  "~SPACE(2,"+")    ->    "abc++def"
</programlisting>
<para>(See <link linkend="space">SPACE</link>
for information about the SPACE built-in function.)</para>
</section>

<section id="ststrn"><title>STRING</title>
<indexterm><primary>STRING method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>STRING method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-STRING------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string with the same string value as the receiver object. If
the receiver is an instance of a subclass of the String class, this method
returns a string having an equivalent value. If the receiver is a string (but
is not an instance of a subclass of the String class), this method returns
the receiver object. See also the STRING method of the Object class in
<link linkend="obstri">STRING</link> .</para>
</section>

<section id="stripm"><title>STRIP</title>
<indexterm><primary>STRIP method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>STRIP method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>blanks</primary>
<secondary>removal with STRIP method</secondary></indexterm>
<indexterm><primary>character</primary>
<secondary>removal with STRIP method</secondary></indexterm>
<indexterm><primary>leading</primary>
<secondary>zeros</secondary>
<tertiary>removing with STRIP method</tertiary></indexterm>
<indexterm><primary>leading</primary>
<secondary>blank removal with STRIP method</secondary></indexterm>
<indexterm><primary>trailing</primary>
<secondary>blank removed using STRIP method</secondary></indexterm>
<indexterm><primary>zeros</primary>
<secondary>removal with STRIP method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-STRIP-+---------------------+-------------------------------><
         +-(option-+-------+-)-+
                   +-,char-+
]]>
</programlisting>

<para>Returns the receiving string with leading characters, trailing characters,
or both, removed, based on the <emphasis role="italic">option</emphasis> you
specify. The following are valid <emphasis role="italic">option</emphasis>s.
(You need to specify only the first capitalized
letter; the language processor ignores all characters following it.) </para>
<variablelist>
<varlistentry><term>Both</term>
<listitem><para>Removes both leading and trailing characters. This is the
default.
</para></listitem></varlistentry>
<varlistentry><term>Leading</term>
<listitem><para>Removes leading characters.
</para></listitem></varlistentry>
<varlistentry><term>Trailing</term>
<listitem><para>Removes trailing characters.
</para></listitem></varlistentry>
</variablelist>
<para>The <emphasis role="italic">char</emphasis> specifies the character to be
removed, and the default is a blank. If you specify
<emphasis role="italic">char</emphasis>, it must be exactly one character
long.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>STRIP method</secondary></indexterm>
<programlisting>
"  ab c  "~STRIP         ->    "ab c"
"  ab c  "~STRIP("L")    ->    "ab c  "
"  ab c  "~STRIP("t")    ->    "  ab c"
"12.7000"~STRIP(,0)      ->    "12.7"
"0012.700"~STRIP(,0)     ->    "12.7"
</programlisting>
<para>(See <link linkend="strip">STRIP</link>
for information about the STRIP built-in function.)</para>
</section>

<section id="stsubs"><title>SUBSTR</title>
<indexterm><primary>SUBSTR method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SUBSTR method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>extracting</primary>
<secondary>substring</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>extracting using SUBSTR method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-SUBSTR(n-+-------------------------+-)----------------------><
            +-,--+--------+--+------+-+
                 +-length-+  +-,pad-+
]]>
</programlisting>

<para>Returns the substring of the receiving string that begins at the
<emphasis role="italic">n</emphasis>th character and is of length
<emphasis role="italic">length</emphasis>, padded with
<emphasis role="italic">pad</emphasis> if
necessary. The <emphasis role="italic">n</emphasis> must be a positive whole
number. If <emphasis role="italic">n</emphasis> is
greater than <computeroutput>receiving_string~LENGTH</computeroutput>,
only pad characters are returned.</para>
<para>If you omit <emphasis role="italic">length</emphasis>, the rest of the
string is returned. The default <emphasis role="italic">pad</emphasis>
character is a blank.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>SUBSTR method</secondary></indexterm>
<programlisting>
"abc"~SUBSTR(2)          ->    "bc"
"abc"~SUBSTR(2,4)        ->    "bc  "
"abc"~SUBSTR(2,6,".")    ->    "bc...."
</programlisting>

<note><title>Note</title>
<para>In some situations the positional (numeric) patterns
of parsing templates are more convenient for selecting substrings, in particular
if you need to extract more than one substring from a string. See also
<link linkend="stleft">LEFT</link> and <link linkend="strigh">RIGHT</link>.
</para></note>
<para>(See <link linkend="substr">SUBSTR (Substring)</link>
for information about the SUBSTR built-in function.)</para>
</section>

<section id="stsubw"><title>SUBWORD</title>
<indexterm><primary>SUBWORD method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SUBWORD method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>extracting words with SUBWORD</primary></indexterm>
<indexterm><primary>word</primary>
<secondary>extracting from a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-SUBWORD(n-+---------+-)-------------------------------------><
             +-,length-+
]]>
</programlisting>

<para>Returns the substring of the receiving string that starts at the
<emphasis role="italic">n</emphasis>th word and is up to
<emphasis role="italic">length</emphasis> blank-delimited words. The
<emphasis role="italic">n</emphasis> must be a positive whole number.
If you omit <emphasis role="italic">length</emphasis>, it defaults
to the number of remaining words in the receiving string. The returned string
never has leading or trailing blanks, but includes all blanks between the
selected words.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>SUBWORD method</secondary></indexterm>
<programlisting>
"Now is the  time"~SUBWORD(2,2)    ->    "is the"
"Now is the  time"~SUBWORD(3)      ->    "the  time"
"Now is the  time"~SUBWORD(5)      ->    ""
</programlisting>
<para>(See <link linkend="subword">SUBWORD</link>
for information about the SUBWORD built-in
function.)</para>
</section>

<section id="sttran"><title>TRANSLATE</title>
<indexterm><primary>TRANSLATE method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>TRANSLATE method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>reordering data</primary></indexterm>
<indexterm><primary>translation</primary>
<secondary>with TRANSLATE method</secondary></indexterm>
<indexterm><primary>uppercase translation</primary>
<secondary>with TRANSLATE method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-TRANSLATE-+-----------------------------------------------+-><
             +-(--+-------------------------------------+--)-+
                  +-tableo--+-------------------------+-+
                            +-,--+--------+--+------+-+
                                 +-tablei-+  +-,pad-+
]]>
</programlisting>

<para>Returns the receiving string with each character translated to another
character or unchanged. You can also use this method to reorder the characters
in the receiving string.</para>
<para>The output table is <emphasis role="italic">tableo</emphasis>
and the input translation table is <emphasis role="italic">tablei</emphasis>.
TRANSLATE searches <emphasis role="italic">tablei</emphasis> for each character
in the receiving string. If the character is found, the corresponding character
in <emphasis role="italic">tableo</emphasis> is used in the result string. If
there are duplicates in <emphasis role="italic">tablei</emphasis>, the first
(leftmost) occurrence is used. If the character is
not found, the original character in the receiving string is used. The result
string is always of the same length as the receiving string.</para>
<para>The tables can be of any length. If you specify translation table and
omit <emphasis role="italic">pad</emphasis>, the receiving string is
translated to uppercase (that is, lowercase
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>
to uppercase
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>),
but if you include <emphasis role="italic">pad</emphasis>
the language processor translates the entire
string to <emphasis role="italic">pad</emphasis> characters.
<emphasis role="italic">tablei</emphasis> defaults to
<computeroutput>XRANGE("00"x,"FF"x)</computeroutput>, and
<emphasis role="italic">tableo</emphasis> defaults to the null string and
is padded with <emphasis role="italic">pad</emphasis> or truncated as necessary.
The default <emphasis role="italic">pad</emphasis> is a blank.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>TRANSLATE method</secondary></indexterm>
<programlisting>
"abcdef"~TRANSLATE                     ->    "ABCDEF"
"abcdef"~TRANSLATE("12","ec")          ->    "ab2d1f"
"abcdef"~TRANSLATE("12","abcd",".")    ->    "12..ef"
"APQRV"~TRANSLATE(,"PR")               ->    "A Q V"
"APQRV"~TRANSLATE(XRANGE("00"X,"Q"))   ->    "APQ  "
"4123"~TRANSLATE("abcd","1234")        ->    "dabc"
</programlisting>

<note><title>Note</title>
<para>The last example shows how to use the TRANSLATE method
to reorder the characters in a string. In the example, the last character
of any 4-character string specified as the first argument would be moved to
the beginning of the string.</para></note>
<para>(See <link linkend="transl">TRANSLATE</link>
for information about the TRANSLATE built-in
function.)</para>
</section>

<section id="sttrun"><title>TRUNC</title>
<indexterm><primary>TRUNC method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>TRUNC method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>numbers with TRUNC</secondary></indexterm>
<indexterm><primary>trincating numbers</primary></indexterm>
<indexterm><primary>numbers</primary>
<secondary>truncating</secondary></indexterm>


<programlisting>
<![CDATA[
>>-TRUNC-+-----+-----------------------------------------------><
         +-(n)-+
]]>
</programlisting>

<para>Returns the integer part the receiving string, which is a number, and
<emphasis role="italic">n</emphasis> decimal places. The default
<emphasis role="italic">n</emphasis> is <computeroutput>0</computeroutput>
and returns an integer with no decimal point. If you specify
<emphasis role="italic">n</emphasis>, it must be a
positive whole number or zero. The receiving string is first rounded according
to standard Rexx rules, as though the operation
<computeroutput>receiving_string+0</computeroutput> had been carried out.
This number is then truncated to <emphasis role="italic">n</emphasis> decimal
places or trailing zeros are added if needed to reach the specified length.
The result is never in exponential form. If there are no nonzero digits in
the result, any minus sign is removed.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>TRUNC method</secondary></indexterm>
<programlisting>
12.3~TRUNC            ->    12
127.09782~TRUNC(3)    ->    127.097
127.1~TRUNC(3)        ->    127.100
127~TRUNC(2)          ->    127.00
</programlisting>

<note><title>Note</title>
<para>The <emphasis role="italic">number</emphasis> is rounded according to the
current setting of NUMERIC DIGITS if necessary, before the method processes it.
</para></note>
<para>(See <link linkend="trunc">TRUNC (Truncate)</link>
for information about the TRUNC built-in function.)</para>
</section>

<section id="stveri"><title>VERIFY</title>
<indexterm><primary>VERIFY method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>VERIFY method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>string</primary>
<secondary>verifying contents of</secondary></indexterm>
<indexterm><primary>verifying contents of a string</primary></indexterm>

<programlisting>
<![CDATA[
>>-VERIFY(reference-+---------------------------+-)------------><
                    +-,--+--------+--+--------+-+
                         +-option-+  +-,start-+
]]>
</programlisting>

<para>Returns a number that, by default, indicates whether the receiving string
is composed only of characters from
<emphasis role="italic">reference</emphasis>. It returns
<computeroutput>0</computeroutput> if all characters in the receiving string
are in <emphasis role="italic">reference</emphasis> or
returns the position of the first character in the receiving string not in
<emphasis role="italic">reference</emphasis>.</para>
<para>The <emphasis role="italic">option</emphasis> can be either
<computeroutput>Nomatch</computeroutput> (the
default) or <computeroutput>Match</computeroutput>. (You need to specify only
the first capitalized and highlighted letter; the language processor ignores
all characters following the first character, which can be in uppercase or
lowercase.)</para>
<para>If you specify <computeroutput>Match</computeroutput>, the method returns
the position of the first character in the receiving string that is in
<emphasis role="italic">reference</emphasis>, or returns
<computeroutput>0</computeroutput> if none of the characters
are found.</para>
<para>The default for <emphasis role="italic">start</emphasis> is
<computeroutput>1</computeroutput>. Thus, the search starts
at the first character of the receiving string. You can override this by
specifying a different <emphasis role="italic">start</emphasis> point,
which must be a positive whole number.</para>
<para>If the receiving string is null, the method returns
<computeroutput>0</computeroutput>, regardless
of the value of the <emphasis role="italic">option</emphasis>. Similarly, if
<emphasis role="italic">start</emphasis> is greater
than <computeroutput>receiving_string~LENGTH</computeroutput>, the method
returns <computeroutput>0</computeroutput>. If
<emphasis role="italic">reference</emphasis> is null, the method returns
<computeroutput>0</computeroutput> if
you specify <computeroutput>Match</computeroutput>. Otherwise, the method
returns the <emphasis role="italic">start</emphasis> value.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>VERIFY method</secondary></indexterm>
<programlisting>
"123"~VERIFY("1234567890")             ->    0
"1Z3"~VERIFY("1234567890")             ->    2
"AB4T"~VERIFY("1234567890")            ->    1
"AB4T"~VERIFY("1234567890","M")        ->    3
"AB4T"~VERIFY("1234567890","N")        ->    1
"1P3Q4"~VERIFY("1234567890", ,3)       ->    4
"123"~VERIFY("",N,2)                   ->    2
"ABCDE"~VERIFY("", ,3)                 ->    3
"AB3CD5"~VERIFY("1234567890","M",4)    ->    6
</programlisting>
<para>(See <link linkend="verify">VERIFY</link>
for information about the VERIFY built-in function.)</para>
</section>

<section id="stword"><title>WORD</title>
<indexterm><primary>WORD method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>WORD method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>extracting</primary>
<secondary>word from a string</secondary></indexterm>
<indexterm><primary>locating</primary>
<secondary>word in another string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-WORD(n)-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the <emphasis role="italic">n</emphasis>th blank-delimited word
in the receiving string or the null string if the receiving string has
fewer than <emphasis role="italic">n</emphasis> words. The
<emphasis role="italic">n</emphasis> must be a positive whole number. This
method is exactly equivalent
to <computeroutput>receiving_string~SUBWORD(n,1)</computeroutput>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>WORD method</secondary></indexterm>
<programlisting>
"Now is the time"~WORD(3)    ->    "the"
"Now is the time"~WORD(5)    ->    ""
</programlisting>
<para>(See <link linkend="xword">WORD</link>
for information about the WORD built-in function.)</para>
</section>

<section id="stwori"><title>WORDINDEX</title>
<indexterm><primary>WORDINDEX method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>WORDINDEX method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-WORDINDEX(n)------------------------------------------------><
]]>
</programlisting>

<para>Returns the position of the first character in the
<emphasis role="italic">n</emphasis>th blank-delimited
word in the receiving string. It returns <computeroutput>0</computeroutput>
if the receiving string has fewer than <emphasis role="italic">n</emphasis>
words. The <emphasis role="italic">n</emphasis> must be a positive whole number.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>WORDINDEX method</secondary></indexterm>
<programlisting>
"Now is the time"~WORDINDEX(3)    ->    8
"Now is the time"~WORDINDEX(6)    ->    0
</programlisting>
<para>(See <link linkend="xwordind">WORDINDEX</link>
for information about the WORDINDEX built-in
function.)</para>
</section>

<section id="stworl"><title>WORDLENGTH</title>
<indexterm><primary>WORDLENGTH method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>WORDLENGTH method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>finding</primary>
<secondary>word length</secondary></indexterm>

<programlisting>
<![CDATA[
>>-WORDLENGTH(n)-----------------------------------------------><
]]>
</programlisting>

<para>Returns the length of the <emphasis role="italic">n</emphasis>th
blank-delimited word in the receiving
string or <computeroutput>0</computeroutput> if the receiving string has fewer
than <emphasis role="italic">n</emphasis> words.
The <emphasis role="italic">n</emphasis> must be a positive whole number.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>WORDLENGTH method</secondary></indexterm>
<programlisting>
"Now is the time"~WORDLENGTH(2)       ->    2
"Now comes the time"~WORDLENGTH(2)    ->    5
"Now is the time"~WORDLENGTH(6)       ->    0
</programlisting>
<para>(See <link linkend="xwordlen">WORDLENGTH</link>
for information about the WORDLENGTH built-in
function.)</para>
</section>

<section id="stworp"><title>WORDPOS</title>
<indexterm><primary>WORDPOS method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>WORDPOS method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>word</primary>
<secondary>locating in a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-WORDPOS(phrase-+--------+-)---------------------------------><
                  +-,start-+
]]>
</programlisting>

<para>Returns the word number of the first word of
<emphasis role="italic">phrase</emphasis> found in the
receiving string, or <computeroutput>0</computeroutput> if
<emphasis role="italic">phrase</emphasis> contains no words or
if <emphasis role="italic">phrase</emphasis> is not found. Several blanks
between words in either <emphasis role="italic">phrase</emphasis> or the
receiving string are treated as a single blank for the
comparison, but, otherwise, the words must match exactly.</para>
<para>By default the search starts at the first word in the receiving string.
You can override this by specifying <emphasis role="italic">start</emphasis>
(which must be positive),
the word at which the search is to be started.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>WORDPOS method</secondary></indexterm>
<programlisting>
"now is the time"~WORDPOS("the")              ->  3
"now is the time"~WORDPOS("The")              ->  0
"now is the time"~WORDPOS("is the")           ->  2
"now is the time"~WORDPOS("is   the")         ->  2
"now is   the time"~WORDPOS("is   time ")     ->  0
"To be or not to be"~WORDPOS("be")            ->  2
"To be or not to be"~WORDPOS("be",3)          ->  6
</programlisting>
<para>(See <link linkend="wordpos">WORDPOS (Word Position)</link>
for information about the WORDPOS built-in
function.)</para>
</section>

<section id="stwors"><title>WORDS</title>
<indexterm><primary>WORDS method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>WORDS method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>counting</primary>
<secondary>words in a string</secondary></indexterm>
<indexterm><primary>extracting</primary>
<secondary>words from a string</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>counting in a string</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>extracting from a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-WORDS-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of blank-delimited words in the receiving string.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>WORDS method</secondary></indexterm>
<programlisting>
"Now is the time"~WORDS      ->    4
" "~WORDS                    ->    0
</programlisting>
<para>(See <link linkend="words">WORDS</link>
for information about the WORDS built-in function.)</para>
</section>

<section id="stx2b"><title>X2B</title>
<indexterm><primary>X2B method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>X2B method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>hexadecimal to binary</secondary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>to binary, converting with X2B</secondary></indexterm>

<programlisting>
<![CDATA[
>>-X2B---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string, in character format, that represents the receiving
string, which is a string of hexadecimal characters converted to binary. The
receiving string can be of any length. Each hexadecimal character is converted
to a string of 4 binary digits. The receiving string can optionally include
blanks (at byte boundaries only, not leading or trailing) to improve
readability; they are ignored.</para>
<para>The returned string has a length that is a multiple of four, and does not
include any blanks.</para>
<para>If the receiving string is null, the method returns a null string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>X2B method</secondary></indexterm>
<programlisting>
"C3"~X2B        ->  "11000011"
"7"~X2B         ->  "0111"
"1 C1"~X2B      ->  "000111000001"
</programlisting>
<para>You can combine X2B with the methods D2X and C2X to convert numbers or
character strings into binary form.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
"C3"x~C2X~X2B  ->  "11000011"
"129"~D2X~X2B  ->  "10000001"
"12"~D2X~X2B   ->  "1100"
</programlisting>
<para>(See <link linkend="x2b">X2B (Hexadecimal to Binary)</link>
for information about the X2B built-in function.)</para>
</section>

<section id="stx2c"><title>X2C</title>
<indexterm><primary>X2C method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>X2C method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>hexadecimal to character</secondary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>to character, converting with X2C</secondary></indexterm>
<indexterm><primary>packing a string with X2C</primary></indexterm>

<programlisting>
<![CDATA[
>>-X2C---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string, in character format, that represents the receiving
string, which is a hexadecimal string converted to character. The returned string
is half as many bytes as the receiving string. The receiving string can be
any length. If necessary, it is padded with a leading 0 to make an even number
of hexadecimal digits.</para>
<para>You can optionally include blanks in the receiving string (at byte boundaries
only, not leading or trailing) to improve readability; they are ignored.</para>
<para>If the receiving string is null, the method returns a null string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>X2C method</secondary></indexterm>
<programlisting>
"4865 6c6c 6f"~X2C ->  "Hello"     /*  ASCII             */
"3732 73"~X2C      ->  "72s"       /*  ASCII             */
</programlisting>
<para>(See <link linkend="x2c">X2C (Hexadecimal to Character)</link>
for information about the X2C built-in function.)</para>
</section>

<section id="stx2d"><title>X2D</title>
<indexterm><primary>X2D method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>X2D method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>hexadecimal to deciaml</secondary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>to decimal, converting with X2D</secondary></indexterm>

<programlisting>
<![CDATA[
>>-X2D-+-----+-------------------------------------------------><
       +-(n)-+
]]>
</programlisting>

<para>Returns the decimal representation of the receiving string, which is a
string of hexadecimal characters. If the result cannot be expressed as a whole
number, an error results. That is, the result must not have more digits than
the current setting of NUMERIC DIGITS.</para>
<para>You can optionally include blanks in the receiving string (at byte
boundaries only, not leading or trailing) to improve readability; they are
ignored.</para>
<para>If the receiving string is null, the method returns
<computeroutput>0</computeroutput>.</para>
<para>If you do not specify <emphasis role="italic">n</emphasis>,
the receiving string is processed as
an unsigned binary number.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>X2D method</secondary></indexterm>
<programlisting>
"0E"~X2D        ->    14
"81"~X2D        ->    129
"F81"~X2D       ->    3969
"FF81"~X2D      ->    65409
"46 30"X~X2D    ->    240          /*  ASCII   */
"66 30"X~X2D    ->    240          /*  ASCII   */
</programlisting>
<para>If you specify <emphasis role="italic">n</emphasis>, the receiving string
is taken as a signed number expressed in <emphasis role="italic">n</emphasis>
hexadecimal digits. If the leftmost bit is off, then
the number is positive; otherwise, it is a negative number. In both cases
it is converted to a whole number, which can be negative. If
<emphasis role="italic">n</emphasis> is <computeroutput>0</computeroutput>,
the method returns <computeroutput>0</computeroutput>.</para>
<para>If necessary, the receiving string is padded on the left with
<computeroutput>0</computeroutput> characters
(note, not &quot;sign-extended&quot;), or truncated on the left to
<emphasis role="italic">n</emphasis> characters.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
"81"~X2D(2)      ->    -127
"81"~X2D(4)      ->    129
"F081"~X2D(4)    ->    -3967
"F081"~X2D(3)    ->    129
"F081"~X2D(2)    ->    -127
"F081"~X2D(1)    ->    1
"0031"~X2D(0)    ->    0
</programlisting>
<para>(See <link linkend="x2d">X2D (Hexadecimal to Decimal)</link>
for information about the X2D built-in function.)</para>
</section>
</section>

<section id="supp"><title>The Supplier Class</title>
<indexterm><primary>Supplier class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Supplier class</secondary></indexterm>
<para>You can use a supplier object to enumerate the items a collection
contained at the time of the supplier's creation. The following methods
return a supplier object: </para>
<itemizedlist>
<listitem><para>The SUPPLIER methods of the Array, Bag, Directory, List, Queue,
Relation, Set, Table, and Stream classes</para></listitem>
<listitem><para>The METHODS method of the Class class</para></listitem>
</itemizedlist>
<para>The Supplier class is a subclass of the Object class.</para>
<para><emphasis role="bold">Methods the Supplier class defines:</emphasis>
</para>
<simplelist>
<member>NEW (Class method.&nbsp;&nbsp;Overrides Object class method.)</member>
<member>AVAILABLE</member>
<member>INDEX</member>
<member>ITEM</member>
<member>NEXT</member>
</simplelist>
<para><emphasis role="bold">Methods inherited from the Object class:</emphasis>
</para>
<simplelist>
<member>Operator methods:&nbsp;&nbsp;=, ==, \=, >&lt;, &lt;>, \==</member>
<member>CLASS</member>
<member>COPY</member>
<member>DEFAULTNAME</member>
<member>HASMETHOD</member>
<member>INIT</member>
<member>OBJECTNAME</member>
<member>OBJECTNAME=</member>
<member>REQUEST</member>
<member>RUN</member>
<member>SETMETHOD</member>
<member>START</member>
<member>STRING</member>
<member>UNSETMETHOD</member>
</simplelist>

<note><title>Note</title>
<para>The Supplier class also has available class methods that its
metaclass, the Class class, defines.</para></note>

<section id="sunew"><title>NEW  (Class Method)</title>
<indexterm><primary>NEW method</primary>
<secondary>of Supplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>NEW method</secondary>
<tertiary>of Supplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-NEW(values,indexes)-----------------------------------------><
]]>
</programlisting>

<para>Returns a new supplier object. The
<emphasis role="italic">values</emphasis> argument must be an
array of values over which the supplier iterates. The
<emphasis role="italic">indexes</emphasis> argument
is an array of index values with a one-to-one correspondence to the objects
contained in the values array. The created supplier iterates over the arrays,
returning elements of the values array in response to  ITEM messages, and
elements of the indexes array in response to INDEX messages. The supplier
iterates for the number of items contained in the values array, returning
the NIL object for any nonexistent items in either array.</para>
</section>

<section id="suavai"><title>AVAILABLE</title>
<indexterm><primary>AVAILABLE method</primary>
<secondary>of Supplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>AVAILABLE method</secondary>
<tertiary>of Supplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-AVAILABLE---------------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if an item is available
from the supplier (that is, if the ITEM method would return a value). It returns
<computeroutput>0</computeroutput> (false) if the collection is empty or the
supplier has already enumerated the entire collection.</para>
</section>

<section id="suinde"><title>INDEX</title>
<indexterm><primary>INDEX method</primary>
<secondary>of Supplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INDEX method</secondary>
<tertiary>of Supplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-INDEX-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the current
item in the collection. If no item is available, that is, if AVAILABLE would
return false, the language processor raises an error.</para>
</section>

<section id="supitm"><title>ITEM</title>
<indexterm><primary>ITEM method</primary>
<secondary>of Supplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ITEM method</secondary>
<tertiary>of Supplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-ITEM--------------------------------------------------------><
]]>
</programlisting>

<para>Returns the current item in the collection. If no item is available, that
is, if AVAILABLE would return false, the language processor raises an error.
</para>
</section>

<section id="sunext"><title>NEXT</title>
<indexterm><primary>NEXT method</primary>
<secondary>of Supplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>NEXT method</secondary>
<tertiary>of Supplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-NEXT--------------------------------------------------------><
]]>
</programlisting>

<para>Moves to the next item in the collection.
By repeatedly sending NEXT to the supplier (as long as AVAILABLE returns true),
you can enumerate all items in the collection. If no item is available, that
is, if AVAILABLE would return false, the language processor raises an error.
</para>
</section>

<section id="supex"><title>Examples</title>
<indexterm><primary>examples</primary>
<secondary>of Supplier class</secondary></indexterm>
<programlisting>
desserts=.array~of(apples, peaches, pumpkins, 3.14159) /* Creates array */
say "The desserts we have are:"
baker=desserts~supplier             /* Creates supplier object named BAKER */
do while baker~available            /* Array suppliers are sequenced       */
  if baker~index=4
  then say baker~item "is pi, not pie!!!"
  else say baker~item
  baker~next
end

/* Produces: */
/* The desserts we have are: */
/* APPLES                    */
/* PEACHES                   */
/* PUMPKINS                  */
/* 3.14159 is pi, not pie!!! */
</programlisting>

<para>This method is used by INIT to set the attribute USERS to HKEY_USERS. Do
not modify this attribute.</para>
</section>
</section>

<section id="windowsclipboardcl"><title>The WindowsClipboard Class</title>
<indexterm><primary>WindowsClipboard class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsClipboard class</secondary></indexterm>
<para>The WindowsClipboard class provides methods to access the data in the
Windows clipboard.</para>
<para>The WindowsClipboard class is not a built-in class. It is defined
in the WINSYSTM.CLS file. This means, you must use a
::requires statement to activate its functionality, as follows:</para>
<programlisting>
<![CDATA[
::requires "WINSYSTM.CLS"
]]>
</programlisting>
<para><emphasis role="bold">Methods the WindowsClipboard Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>COPY</para></listitem>
<listitem><para>MAKEARRAY</para></listitem>
<listitem><para>PASTE</para></listitem>
<listitem><para>EMPTY</para></listitem>
<listitem><para>ISDATAAVAILABLE</para></listitem></itemizedlist>

<section id="copywc"><title>COPY</title>
<indexterm><primary>COPY method</primary>
<secondary>of WindowsClipboard class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>COPY method</secondary>
<tertiary>of WindowsClipboard class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-COPY--(--text--)--------------------------------------------><
]]>
</programlisting>

<para>Empties the clipboard and copies the specified text to it.</para>
</section>

<section id="mkarwc"><title>MAKEARRAY</title>
<indexterm><primary>MAKEARRAY method</primary>
<secondary>of WindowsClipboard class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MAKEARRAY method</secondary>
<tertiary>of WindowsClipboard class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MAKEARRAY------><
]]>
</programlisting>

<para>If the content of the clipboard is a string with newline characters
in it, MAKEARRAY can be used to split up the string into individual
lines. An array is returned containing those lines.</para>
</section>

<section id="pastewc"><title>PASTE</title>
<indexterm><primary>PASTE method</primary>
<secondary>of WindowsClipboard class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>PASTE method</secondary>
<tertiary>of WindowsClipboard class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-PASTE-------------------------------------------------------><
]]>
</programlisting>

<para>Retrieves the text data stored on the clipboard.</para>
</section>

<section id="emptywc"><title>EMPTY</title>
<indexterm><primary>EMPTY method</primary>
<secondary>of WindowsClipboard class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>EMPTY method</secondary>
<tertiary>of WindowsClipboard class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-EMPTY-------------------------------------------------------><
]]>
</programlisting>

<para>Empties the clipboard.</para>
</section>

<section id="isdataavailablewc"><title>ISDATAAVAILABLE</title>
<indexterm><primary>ISDATAAVAILABLE method</primary>
<secondary>of WindowsClipboard class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ISDATAAVAILABLE method</secondary>
<tertiary>of WindowsClipboard class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-ISDATAAVAILABLE---------------------------------------------><
]]>
</programlisting>

<para>Returns 1 if the text data is available on the clipboard. If no data is
available, 0 is returned.</para>
</section>
</section>

<section id="windowseventlogcl"><title>The WindowsEventLog Class</title>
<indexterm><primary>WindowsEventLog class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsEventLog class</secondary></indexterm>
<para>Object Rexx provides a class for interaction with the Windows NT event
log. You can use this class to read, write, and clear event-log
records. This class is specifically for Windows NT systems and might not be
available on other systems.</para>
<para>The WindowsEventLog class is not a built-in class; it is defined in the
file <computeroutput>WINSYSTM.CLS</computeroutput>. Use a
<computeroutput>::requires</computeroutput> statement to activate
its function: </para>
<programlisting>
::requires "winsystm.cls"
</programlisting>
<para>A sample program <computeroutput>EventLog.REX</computeroutput>
is provided in the <computeroutput>ooRexx\SAMPLES</computeroutput> directory.
</para>
<para><emphasis role="bold">Methods the WindowsEventLog Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>INIT</para></listitem>
<listitem><para>OPEN</para></listitem>
<listitem><para>CLOSE</para></listitem>
<listitem><para>READ</para></listitem>
<listitem><para>WRITE</para></listitem>
<listitem><para>CLEAR</para></listitem>
<listitem><para>GETNUMBER</para></listitem></itemizedlist>

<section id="initwel"><title>INIT</title>
<indexterm><primary>INIT method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INIT method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-INIT--------------------------------------------------------><
]]>
</programlisting>

<para>Creates an instance of the WindowsEventLog class and loads the required
function package.</para>
</section>

<section id="openwel"><title>OPEN</title>
<indexterm><primary>OPEN method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>OPEN method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-OPEN-+---------------------------------+--------------------><
        +-(--+-----------------------+--)-+
             +-server--+-----------+-+
                       +-,--source-+
]]>
</programlisting>

<para>Opens the specified event log.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>server</term>
<listitem><para>The UNC (universal naming convention) name of the server on which
the event log is to be opened. If this argument is not specified, the log is
opened at the local machine.
</para></listitem></varlistentry>
<varlistentry><term>source</term>
<listitem><para>The name of the source of the event log. It must be a subkey of
a log file entry under the EventLog key in the registry. If, for example, the
registry looks as follows:
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
      EventLog
        Application
          WinApp1
        Security
          WinApp2
        System
</programlisting>
&quot;Application&quot;, &quot;Security&quot;, &quot;System&quot;,
&quot;WinApp1&quot;, and &quot;WinApp2&quot; are valid sources.
If the source is not found, the &quot;Application
Log&quot; is used.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example opens the Application log on the local
machine:</para>
<programlisting>
rc = event_log1~OPEN
rc = event_log~OPEN(,"Application")
</programlisting>
<para>The following example
opens the System log on SERVER01:</para>
<programlisting>
rc = event_log~OPEN("\\SERVER01","System")
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>

<section id="closewel"><title>CLOSE</title>
<indexterm><primary>CLOSE method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CLOSE method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CLOSE-------------------------------------------------------><
]]>
</programlisting>

<para>Closes an open event log.</para>
</section>

<section id="readwel"><title>READ</title>
<indexterm><primary>READ method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>READ method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-READ--+---------------------------------------------------+-->
         |    +-FORWARDS--+                                  |
         +-(--+-----------+--,--+--------+--,--+--------+--,-+
              +-BACKWARDS-+     +-server-+     +-source-+

>--+--------------------------+--------------------------------><
   +-+-------+--,--+-----+--)-+
     +-start-+     +-num-+
]]>
</programlisting>

<para>Reads event log records. If the event log was not opened with the OPEN
method, the event log specified by the <emphasis role="italic">server</emphasis>
and <emphasis role="italic">source</emphasis> is
opened and closed after processing.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>server</term>
<listitem><para>The UNC (universal naming convention) name of the server on which
the event log is to be opened. If this argument is not specified, the log is
opened at the local machine.</para>
<para>This argument is only used if the event log was not
opened before.</para>
</listitem></varlistentry>
<varlistentry><term>source</term>
<listitem><para>The name of the source of the event log. It must be a subkey of
a log file entry under the EventLog key in the registry. If, for example, the
registry looks as follows:
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
      EventLog
        Application
          WinApp1
        Security
          WinApp2
        System
</programlisting>
&quot;Application&quot;, &quot;Security&quot;, &quot;System&quot;,
&quot;WinApp1&quot;, and &quot;WinApp2&quot; are valid sources. If the source is
not found, the &quot;Application Log&quot; is used.</para>
<para>This argument is only used if the event log was not opened
before.</para>
</listitem></varlistentry>
<varlistentry><term>start</term>
<listitem><para>The record number of the event log record to be started.
The oldest record is always the first record regardless of the direction
specified.
</para></listitem></varlistentry>
<varlistentry><term>num</term>
<listitem><para>The number of the event log record to be read.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
evl = .WindowsEventLog~new

if evl~InitCode \= 0 then exit

say " reading complete System log forwards without opening it before "

events = evl~Read("FORWARDS", ,"System")

if events \= .nil then
  call DisplayRecords
else
  say "==> Error reading complete System event log"

evl~deinstall

exit 0   /* leave program */

DisplayRecords:

say evl~Events~items "records read"

do i=1 to evl~Events~items
  say "============================================================="
  temp = evl~Events[i]
  parse var temp type date time "&apos;" sourcename"&apos;" id,
  userid computer "&apos;" string "&apos;" "&apos;" data "&apos;"
  say "Type	: "type
  say "Date	: "date
  say "Time	: "time
  say "Source	: "sourcename
  say "ID	: "id
  say "UserId	: "userid
  say "Computer : "computer
  say "Detail	: "string
  say "Data 	: "data
end
return

::requires "winsystm.cls"
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="writewel"><title>WRITE</title>
<indexterm><primary>WRITE method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>WRITE method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-WRITE--+-------------------------------------------------------------+-->
          |                                  +-1--+     +-0--------+    |
          +-(--+--------+--,--+--------+--,--+----+--,--+----------+--,-+
               +-server-+     +-source-+     +-0--+     +-category-+
                                             +-2--+
                                             +-4--+
                                             +-8--+
                                             +-10-+

>--+---------------------------------------+-------------------><
   | +-0--.                                |
   +-+----+--,--+------+--,--+--------+--)-+
     +-id-+     +-data-+     +-string-+
]]>
</programlisting>

<para>Reads event log records. If the event log was not opened with the Open
method, the event log specified by the <emphasis role="italic">server</emphasis>
and <emphasis role="italic">source</emphasis> is
opened and closed after processing.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>server</term>
<listitem><para>The UNC (universal naming convention) name of the server on
which the event log is to be opened. If this argument is not specified, the
log is opened at the local machine.
</para></listitem></varlistentry>
<varlistentry><term>source</term>
<listitem><para>The name of the source of the event log. It must be a subkey of
a log file entry under the EventLog key in the registry. If, for example, the
registry looks as follows:
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
      EventLog
        Application
          WinApp1
        Security
          WinApp2
        System
</programlisting>
&quot;Application&quot;, &quot;Security&quot;, &quot;System&quot;,
&quot;WinApp1&quot;, and &quot;WinApp2&quot; are valid sources. If the source
is not found, the &quot;Application Log&quot; is used.
</para></listitem></varlistentry>
<varlistentry><term>type</term>
<listitem><para>The type of the events to be logged. It can be one of the
numbers listed in the syntax diagram:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>SUCCESS
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>ERROR, which is the default
</para></listitem></varlistentry>
<varlistentry><term>2</term>
<listitem><para>WARNING
</para></listitem></varlistentry>
<varlistentry><term>4</term>
<listitem><para>INFORMATION
</para></listitem></varlistentry>
<varlistentry><term>8</term>
<listitem><para>AUDIT SUCCESS
</para></listitem></varlistentry>
<varlistentry><term>10</term>
<listitem><para>AUDIT FAILURE
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>category</term>
<listitem><para>The event category. This is source-specific information that
can have any value. The default is 0.
</para></listitem></varlistentry>
<varlistentry><term>id</term>
<listitem><para>The event identifier specifying the message that, together with
the event, is an entry in the message file associated with the event source.
The default is 0.
</para></listitem></varlistentry>
<varlistentry><term>data</term>
<listitem><para>The binary data. This is source-specific information and can
be omitted.
</para></listitem></varlistentry>
<varlistentry><term>string</term>
<listitem><para>The strings merged into the message.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example writes the strings and the data to the
system log. &quot;MyApplication&quot; must be a subkey of a log file entry
under the EventLog key in the registry. If the source name cannot be found,
event logging uses the Application log file.</para>
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
        EventLog
        Application
        Security
          System
            MyApplication
	    </programlisting>
<programlisting>
evl~Write(,"MyApplication", , , ,"1A 1B 1C 0000 00"x, ,
"First String", "Second String")
</programlisting>
<para>See the <computeroutput>EventLog.REX</computeroutput> for
more examples.</para>
</listitem></varlistentry>
</variablelist>
</section>

<section id="clearwel"><title>CLEAR</title>
<indexterm><primary>CLEAR method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CLEAR method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CLEAR-+------------------------------------------------------------+-><
         +-(--+--------------------------------------------------+--)-+
              +-server--+--------------------------------------+-+
                        +-,--+--------+--+-------------------+-+
                             +-source-+  +-,--backupFileName-+
]]>
</programlisting>

<para>Clears the specified event log and, optionally, saves a copy of the
current log file as a backup file. If the event log was not opened with the
Open method, the event log specified by the
<emphasis role="italic">server</emphasis> and
<emphasis role="italic">source</emphasis> is opened.
The event log is closed after it is cleared.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>server</term>
<listitem><para>The UNC (universal naming convention) name of the server on
which the event log is to be opened. If this argument is not specified, the
log is opened at the local machine.</para>
<para>This argument is only used if the event log was not
opened before.</para>
</listitem></varlistentry>
<varlistentry><term>source</term>
<listitem><para>The name of the source of the event log. It must be a subkey
of a log file entry under the EventLog key in the registry. If, for example,
the registry looks as follows:
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
      EventLog
        Application
          WinApp1
        Security
          WinApp2
        System
</programlisting>
&quot;Application&quot;, &quot;Security&quot;, &quot;System&quot;,
&quot;WinApp1&quot;, and &quot;WinApp2&quot; are valid sources. If the source
is not found, the &quot;Application Log&quot; is used.</para>
<para>This argument is only used if the event log was not opened
before.</para>
</listitem></varlistentry>
<varlistentry><term>backupFileName</term>
<listitem><para>The name of a file to which the copy of the current event log
file is to be written. If this file already exists, the function fails.
The file can reside on a remote server. </para>
<para>If you omit this argument, the current event
log file is not backed up but cleared.</para>
</listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example creates a backup of the Application event log
of the local machine and clears it:</para>
<programlisting>
event_log~CLEAR(, ,"e:\evlbackup\application.evt")
</programlisting>
<para>The following example creates a backup of the System event log on
the server \\SERVER01 and clears it:</para>
<programlisting>
event_log~CLEAR("\\SERVER01","System","e:\evlbackup\system_server01.evt")
</programlisting>
<para>The following example clears the Application log on the local
machine without a backup:</para>
<programlisting>
event_log~CLEAR
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>

<section id="getnumberwel"><title>GETNUMBER</title>
<indexterm><primary>GETNUMBER method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>GETNUMBER method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-GETNUMBER-+---------------------------------+---------------><
             +-(--+-----------------------+--)-+
                  +-server--+-----------+-+
                            +-,--source-+
]]>
</programlisting>

<para>Retrieves the number of records in the specified event log. If the event
log was not opened with the Open method, the event log specified by the
<emphasis role="italic">server</emphasis> and
<emphasis role="italic">source</emphasis> is opened and closed after processing.
</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>server</term>
<listitem><para>The UNC (universal naming convention) name of the server on
which the event log is to be opened. If this argument is not specified, the log
is opened at the local machine.</para>
<para>This argument is only used if the event log was not
opened before.</para>
</listitem></varlistentry>
<varlistentry><term>source</term>
<listitem><para>The name of the source of the event log. It must be a subkey of
a log file entry under the EventLog key in the registry. If, for example, the
registry looks as follows:
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
      EventLog
        Application
          WinApp1
        Security
          WinApp2
        System
</programlisting>
&quot;Application&quot;, &quot;Security&quot;, &quot;System&quot;,
&quot;WinApp1&quot;, and &quot;WinApp2&quot; are valid sources. If the source
is not found, the &quot;Application Log&quot; is used.</para>
<para>This argument is only used if the event log was not opened
before.</para>
</listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example returns the number of event log records
in the Application log of the local machine:
<programlisting>
num = event_log~GETNUMBER
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="windowsmanagercl"><title>The WindowsManager Class</title>
<indexterm><primary>WindowsManager class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsManager class</secondary></indexterm>
<para>The WindowsManager class provides methods to query, manipulate, and
interact with windows on your desktop. This class is specifically for
Windows NT and Windows 2000 systems and might not be available on
other systems.</para>
<para>The WindowsManager class is not a built-in class; it is defined in the
file <computeroutput>WINSYSTM.CLS</computeroutput>. Use a
<computeroutput>::requires</computeroutput> statement to activate
its function: </para>
<programlisting>
::requires "winsystm.cls"
</programlisting>
<para><emphasis role="bold">Methods the WindowsManager Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>FIND</para></listitem>
<listitem><para>FOREGROUNDWINDOW</para></listitem>
<listitem><para>WINDOWATPOSITION</para></listitem>
<listitem><para>CONSOLETITLE</para></listitem>
<listitem><para>CONSOLETITLE=</para></listitem>
<listitem><para>SENDTEXTTOWINDOW</para></listitem>
<listitem><para>PUSHBUTTONINWINDOW</para></listitem>
<listitem><para>PROCESSWINDOWCOMMAND</para></listitem></itemizedlist>

<section id="findwm"><title>FIND</title>
<indexterm><primary>FIND method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>GETNUMBER method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-FIND--(--title--)-------------------------------------------><
]]>
</programlisting>

<para>Searches for a top-level window (not a child window) on your desktop with
the specified <emphasis role="italic">title</emphasis>.</para>
<para>If this window already exists, an instance of the WindowObject class is
returned. Otherwise, .NIL is returned.</para>
</section>

<section id="foregroundwindowwm"><title>FOREGROUNDWINDOW</title>
<indexterm><primary>FOREGROUNDWINDOW method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>FOREGROUNDWINDOW method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-FOREGROUNDWINDOW--------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class that is associated with the
current foreground window.</para>
</section>

<section id="windowatpositionwm"><title>WINDOWATPOSITION</title>
<indexterm><primary>WINDOWATPOSITION method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>WINDOWATPOSITION method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-WINDOWATPOSITION--(--x--,--y--)-----------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class that is associated with the
window at the specified position (<emphasis role="italic">x,y</emphasis>). The
coordinates are specified
in screen pixels. This method does not retrieve hidden or disabled windows.
If you are interested in a particular child window, use method
<link linkend="childatpositionwo">CHILDATPOSITION</link>.</para>
</section>

<section id="consoletitlewm"><title>CONSOLETITLE</title>
<indexterm><primary>CONSOLETITLE method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CONSOLETITLE method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CONSOLETITLE------------------------------------------------><
]]>
</programlisting>

<para>Returns the title of the current console.</para>
</section>

<section id="consoletitlenewwm"><title>CONSOLETITLE=</title>
<indexterm><primary>CONSOLETITLE= method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CONSOLETITLE= method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CONSOLETITLE=--title----------------------------------------><
]]>
</programlisting>

<para>Sets the title of the current console.</para>
</section>

<section id="sendtexttowindowwm"><title>SENDTEXTTOWINDOW</title>
<indexterm><primary>SENDTEXTTOWINDOW method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SENDTEXTTOWINDOW method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SENDTEXTTOWINDOW--(--title--,--text--)----------------------><
]]>
</programlisting>

<para>Sends a case-sensitive <emphasis role="italic">text</emphasis> to the
window with the specified <emphasis role="italic">title.</emphasis>.</para>
</section>

<section id="pushbuttoninwindowwm"><title>PUSHBUTTONINWINDOW</title>
<indexterm><primary>PUSHBUTTONINWINDOW method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>PUSHBUTTONINWINDOW method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-PUSHBUTTONINWINDOW--(--title--,--text--)--------------------><
]]>
</programlisting>

<para>Selects the button with label <emphasis role="italic">text</emphasis>
in the window with the specified <emphasis role="italic">title</emphasis>.
If the button's label contains a mnemonic (underscored letter),
you must specify an ampersand (&amp;) in front of it. You can also use this
method to select radio buttons and to check or uncheck check boxes.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
winmgr~PushButtonInWindow("Testwindow","List &amp;Employees")
</programlisting>
</section>

<section id="processmenucommandwm"><title>PROCESSMENUCOMMAND</title>
<indexterm><primary>PROCESSMENUCOMMAND method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>PROCESSMENUCOMMAND method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-PROCESSMENUCOMMAND--(--+-------+--,--+-------+--,------------>
                          +-title-+     +-popup-+

   +-,-------+
   V         |
>----submenu-+--,--menuItem--)---------------------------------><
]]>
</programlisting>

<para>Selects an item of the menu or submenu of the specified window
<emphasis role="italic">title</emphasis>. You can specify as many submenus as
necessary to get to the required item.</para>
</section>
</section>

<section id="windowobjectcl"><title>The WindowObject Class</title>
<indexterm><primary>WindowsObject class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsObject class</secondary></indexterm>
<para>The WindowObject class provides methods to query, manipulate, and
interact with a particular window or one of its child windows.</para>
<para><emphasis role="bold">Methods the WindowObject Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>ASSOCWINDOW</para></listitem>
<listitem><para>CHILDATPOSITION</para></listitem>
<listitem><para>COORDINATES</para></listitem>
<listitem><para>DISABLE</para></listitem>
<listitem><para>ENABLE</para></listitem>
<listitem><para>ENUMERATECHILDREN</para></listitem>
<listitem><para>FINDCHILD</para></listitem>
<listitem><para>FIRST</para></listitem>
<listitem><para>FIRSTCHILD</para></listitem>
<listitem><para>FOCUSITEM</para></listitem>
<listitem><para>FOCUSNEXTITEM</para></listitem>
<listitem><para>FOCUSPREVIOUSITEM</para></listitem>
<listitem><para>HANDLE</para></listitem>
<listitem><para>HIDE</para></listitem>
<listitem><para>ID</para></listitem>
<listitem><para>ISMENU</para></listitem>
<listitem><para>LAST</para></listitem>
<listitem><para>MAXIMIZE</para></listitem>
<listitem><para>MENU</para></listitem>
<listitem><para>MINIMIZE</para></listitem>
<listitem><para>MOVETO</para></listitem>
<listitem><para>NEXT</para></listitem>
<listitem><para>OWNER</para></listitem>
<listitem><para>PREVIOUS</para></listitem>
<listitem><para>PROCESSMENUCOMMAND</para></listitem>
<listitem><para>PUSHBUTTON</para></listitem>
<listitem><para>RESIZE</para></listitem>
<listitem><para>RESTORE</para></listitem>
<listitem><para>SENDCHAR</para></listitem>
<listitem><para>SENDCOMMAND</para></listitem>
<listitem><para>SENDKEY</para></listitem>
<listitem><para>SENDKEYDOWN</para></listitem>
<listitem><para>SENDKEYUP</para></listitem>
<listitem><para>SENDMENUCOMMAND</para></listitem>
<listitem><para>SENDMESSAGE</para></listitem>
<listitem><para>SENDMOUSECLICK</para></listitem>
<listitem><para>SENDSYSCOMMAND</para></listitem>
<listitem><para>SENDTEXT</para></listitem>
<listitem><para>STATE</para></listitem>
<listitem><para>SYSTEMMENU</para></listitem>
<listitem><para>TITLE</para></listitem>
<listitem><para>TITLE=</para></listitem>
<listitem><para>TOFOREGROUND</para></listitem>
<listitem><para>WCLASS</para></listitem></itemizedlist>

<section id="assocwindowwo"><title>ASSOCWINDOW</title>
<indexterm><primary>ASSOCWINDOW method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ASSOCWINDOW method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-ASSOCWINDOW--(--handle--)-----------------------------------><
]]>
</programlisting>

<para>Assigns a new window <emphasis role="italic">handle</emphasis> to the
WindowObject instance.</para>
</section>

<section id="handlewo"><title>HANDLE</title>
<indexterm><primary>HANDLE method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>HANDLE method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-HANDLE------------------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the associated window.</para>
</section>

<section id="titlewo"><title>TITLE</title>
<indexterm><primary>TITLE method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>TITLE method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-TITLE-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the title of the window.</para>
</section>

<section id="titlenewwo"><title>TITLE=</title>
<indexterm><primary>TITLE= method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>TITLE= method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-TITLE=--newTitle--------------------------------------------><
]]>
</programlisting>

<para>Sets a new title for the window.</para>
</section>

<section id="wclasswo"><title>WCLASS</title>
<indexterm><primary>WCLASS method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>WCLASS method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-WCLASS------------------------------------------------------><
]]>
</programlisting>

<para>Returns the class of the window associated with the WindowObject instance.
</para>
</section>

<section id="idwo"><title>ID</title>
<indexterm><primary>ID method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ID method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-ID----------------------------------------------------------><
]]>
</programlisting>

<para>Returns the numeric ID of the window.</para>
</section>

<section id="coordinateswo"><title>COORDINATES</title>
<indexterm><primary>COORDINATES method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>COORDINATES method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-COORDINATES-------------------------------------------------><
]]>
</programlisting>

<para>Returns the upper left and the lower right corner positions of the window
in the format &quot;left,top,right,bottom&quot;.</para>
</section>

<section id="statewo"><title>STATE</title>
<indexterm><primary>STATE method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>STATE method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-STATE-------------------------------------------------------><
]]>
</programlisting>

<para>Returns information about the window state. The returned state can contain
one or more of the following constants:</para>
<itemizedlist>
<listitem><para>&quot;Enables&quot; or &quot;Disabled&quot;</para></listitem>
<listitem><para>&quot;Visible&quot; or &quot;Invisible&quot;</para></listitem>
<listitem><para>&quot;Zoomed&quot; or &quot;Minimized&quot;</para></listitem>
<listitem><para>&quot;Foreground&quot;</para></listitem></itemizedlist>
</section>

<section id="restorewo"><title>RESTORE</title>
<indexterm><primary>RESTORE method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>RESTORE method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-RESTORE-----------------------------------------------------><
]]>
</programlisting>

<para>Activates and displays the associated window. If the window is minimized
or maximized, it is restored to its original size and position.</para>
</section>

<section id="hidewo"><title>HIDE</title>
<indexterm><primary>HIDE method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>HIDE method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-HIDE--------------------------------------------------------><
]]>
</programlisting>

<para>Hides the associated window and activates another window.</para>
</section>

<section id="minimizewo"><title>MINIMIZE</title>
<indexterm><primary>MINIMIZE method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MINIMIZE method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MINIMIZE----------------------------------------------------><
]]>
</programlisting>

<para>Minimizes the associated window and activates the next higher-level
window.</para>
</section>

<section id="maximizewo"><title>MAXIMIZE</title>
<indexterm><primary>MAXIMIZE method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MAXIMIZE method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MAXIMIZE----------------------------------------------------><
]]>
</programlisting>

<para>Maximizes the associated window.</para>
</section>

<section id="resizewo"><title>RESIZE</title>
<indexterm><primary>RESIZE method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>RESIZE method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-RESIZE--(--width--,--height--)------------------------------><
]]>
</programlisting>

<para>Resizes the associated window to the specified width and height. The width
and height are specified in screen coordinates.</para>
</section>

<section id="enablewo"><title>ENABLE</title>
<indexterm><primary>ENABLE method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ENABLE method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-ENABLE------------------------------------------------------><
]]>
</programlisting>

<para>Enables the associated window if it was disabled.</para>
</section>

<section id="disablewo"><title>DISABLE</title>
<indexterm><primary>DISABLE method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DISABLE method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-DISABLE-----------------------------------------------------><
]]>
</programlisting>

<para>Disables the associated window.</para>
</section>

<section id="movetowo"><title>MOVETO</title>
<indexterm><primary>MOVETO method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MOVETO method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MOVETO--(--x--,--y--)---------------------------------------><
]]>
</programlisting>

<para>Moves the associated window to the specified position
(<emphasis role="italic">x,y</emphasis>). Specify
the new position in screen pixels.</para>
</section>

<section id="toforegroundwo"><title>TOFOREGROUND</title>
<indexterm><primary>TOFOREGROUND method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>TOFOREGROUND method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-TOFOREGROUND------------------------------------------------><
]]>
</programlisting>

<para>Makes the associated window the foreground window.</para>
</section>

<section id="focusnextitemwo"><title>FOCUSNEXTITEM</title>
<indexterm><primary>FOCUSNEXTITEM method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>FOCUSNEXTITEM method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-FOCUSNEXTITEM-----------------------------------------------><
]]>
</programlisting>

<para>Sets the input focus to the next child window of the associated window.
</para>
</section>

<section id="focuspreviousitemwo"><title>FOCUSPREVIOUSITEM</title>
<indexterm><primary>FOCUSPREVIOUSITEM method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>FOCUSPREVIOUSITEM method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-FOCUSPREVIOUSITEM-------------------------------------------><
]]>
</programlisting>

<para>Sets the input focus to the previous child window of the associated
window.</para>
</section>

<section id="focusitemwo"><title>FOCUSITEM</title>
<indexterm><primary>FOCUSITEM method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>FOCUSITEM method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-FOCUSITEM--(--wndObject--)----------------------------------><
]]>
</programlisting>

<para>Sets the input focus to the child window associated with the specified
WindowObject instance <emphasis role="italic">wndObject</emphasis>.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<para>The following example sets the input focus to the last child window:
</para>
<programlisting>
 dlg = wndmgr~Find("TestDialog")
    if dlg \= .Nil then do
        fChild = dlg~FirstChild
        lChild = fChild~Last
        dlg~FocusItem(lChild)
    end
</programlisting>
</section>

<section id="findchildwo"><title>FINDCHILD</title>
<indexterm><primary>FINDCHILD method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>FINDCHILD method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-FINDCHILD--(--label--)--------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the child
window with the specified <emphasis role="italic">label</emphasis>. If the
associated window does not
own such a window, the .NIL object is returned.</para>
</section>

<section id="childatpositionwo"><title>CHILDATPOSITION</title>
<indexterm><primary>CHILDATPOSITION method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CHILDATPOSITION method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CHILDATPOSITION--(--x--,--y--)------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the child
window at the specified client position (<emphasis role="italic">x,y</emphasis>).
The coordinates that are relative to the upper left corner of the associated
window must be specified
in screen pixels. To retrieve top-level windows,
use method <link linkend="windowatpositionwm">WINDOWATPOSITION</link>.</para>
</section>

<section id="nextwo"><title>NEXT</title>
<indexterm><primary>NEXT method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>NEXT method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-NEXT--------------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the next
window of the same level as the associated window. If the associated window
is the last window of a level, the .NIL object is returned.</para>
</section>

<section id="previouswo"><title>PREVIOUS</title>
<indexterm><primary>PREVIOUS method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>PREVIOUS method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-PREVIOUS----------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the previous
window of the same level as the associated window. If the associated window
is the first window of a level, the .NIL object is returned.</para>
</section>

<section id="firstwo"><title>FIRST</title>
<indexterm><primary>FIRST method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>FIRST method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-FIRST-------------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the first
window of the same level as the associated window.</para>
</section>

<section id="lastwo"><title>LAST</title>
<indexterm><primary>LAST method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LAST method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-LAST--------------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the last
window of the same level as the associated window.</para>
</section>

<section id="ownerwo"><title>OWNER</title>
<indexterm><primary>OWNER method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>OWNER method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-OWNER-------------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the window
that owns the associated window (parent). If the associated window is a
top-level window, the .NIL object is returned.</para>
</section>

<section id="firstchildwo"><title>FIRSTCHILD</title>
<indexterm><primary>FIRSTCHILD method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>FIRSTCHILD method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-FIRSTCHILD--------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the first
child window of the associated window. If no child window exists, the .NIL
object is returned.</para>
</section>

<section id="enumeratechildrenwo"><title>ENUMERATECHILDREN</title>
<indexterm><primary>ENUMERATECHILDREN method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ENUMERATECHILDREN method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-ENUMERATECHILDREN-------------------------------------------><
]]>
</programlisting>

<para>Returns a stem that stores information about the
child windows of the associated
window. &quot;Stem.0&quot; contains the number of child windows. The returned
stem contains as many records as child windows. The first record is stored
at &quot;Stem.1&quot; continued by increments of 1. Each record contains the
following entries, where each entry starts with an exclamation mark (!):</para>
<variablelist>
<varlistentry><term>!Handle</term>
<listitem><para>The handle of the window.
</para></listitem></varlistentry>
<varlistentry><term>!Title</term>
<listitem><para>
</para></listitem></varlistentry>
<varlistentry><term>!Class</term>
<listitem><para>The window class.
</para></listitem></varlistentry>
<varlistentry><term>!State</term>
<listitem><para>
</para></listitem></varlistentry>
<varlistentry><term>!Coordinates</term>
<listitem><para>
</para></listitem></varlistentry>
<varlistentry><term>!Children</term>
<listitem><para>1 if the window has child windows, 0 if is has none.
</para></listitem></varlistentry>
<varlistentry><term>!Id</term>
<listitem><para>
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
      wo = winmgr~Find("TestDialog")
        enum. = wo~EnumerateChildren
        do i = 1 to enum.0   /* number of children */
           say "---"
           say "Handle:" enum.i.!Handle
           say "Title:" enum.i.!Title
           say "Class:" enum.i.!Class
           say "Id:" enum.i.!Id
           say "Children:" enum.i.!Children
           say "State:" enum.i.!State
           say "Rect:" enum.i.!Coordinates
        end
</programlisting>
</section>

<section id="sendmessagewo"><title>SENDMESSAGE</title>
<indexterm><primary>SENDMESSAGE method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SENDMESSAGE method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SENDMESSAGE--(--message--,--wParam--,--lParam--)------------><
]]>
</programlisting>

<para>Sends a message to the associated window.</para>
</section>

<section id="sendcommandwo"><title>SENDCOMMAND</title>
<indexterm><primary>SENDCOMMAND method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SENDCOMMAND method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SENDCOMMAND--(--command--)----------------------------------><
]]>
</programlisting>

<para>Sends a WM_COMMAND message to the associated window. WM_COMMAND is
sent, for example, when a button is pressed, where
<emphasis role="italic">command</emphasis> is the button ID.</para>
</section>

<section id="sendmenucommandwo"><title>SENDMENUCOMMAND</title>
<indexterm><primary>SENDMENUCOMMAND method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SENDMENUCOMMAND method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SENDMENUCOMMAND--(--id--)-----------------------------------><
]]>
</programlisting>

<para>Selects the menu item <emphasis role="italic">id</emphasis> of the
associated window. Method <link linkend="idofmo">IDOF</link> returns the
ID of a menu item.</para>
</section>

<section id="sendmouseclickwo"><title>SENDMOUSECLICK</title>
<indexterm><primary>SENDMOUSECLICK method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SENDMOUSECLICK method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
                      +-"LEFT"---+     +-"DBLCLK"-+
>>-SENDMOUSECLICK--(--+-"RIGHT"--+--,--+-"UP"-----+----,--x--,--y-->
                      +-"MIDDLE"-+     +-"DOWN"---+

>--+-----------------------------+--)--------------------------><
   |       +----------------+    |
   |       V                |    |
   +-,--"----+-LEFTDOWN---+-+--"-+
             +-RIGHTDOWN--+
             +-MIDDLEDOWN-+
             +-SHIFT------+
             +-CONTROL----+
]]>
</programlisting>

<para>Simulates a mouse click event in the associated window.</para>
<para>Arguments:</para>
<para>The arguments are:</para>
<variablelist>
<varlistentry><term><emphasis role="italic">which</emphasis></term>
<listitem><para>Specifies which mouse button is simulated. LEFT is the default.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="italic">kind</emphasis></term>
<listitem><para>Selects the simulated mouse action. DBLCLK is the default.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="italic">x,y</emphasis></term>
<listitem><para>Specifies the coordinates of the mouse click event, in screen
coordinates, relative to the upper left corner of the window.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="italic">ext</emphasis></term>
<listitem><para>Can be one or more of the following strings:
<variablelist>
<varlistentry><term>LEFTDOWN</term>
<listitem><para>Simulates the pressed left mouse button.
</para></listitem></varlistentry>
<varlistentry><term>RIGHTDOWN</term>
<listitem><para>Simulates the pressed right mouse button.
</para></listitem></varlistentry>
<varlistentry><term>MIDDLEDOWN</term>
<listitem><para>Simulates the pressed middle mouse button.
</para></listitem></varlistentry>
<varlistentry><term>SHIFT</term>
<listitem><para>Simulates the pressed Shift key.
</para></listitem></varlistentry>
<varlistentry><term>CONTROL</term>
<listitem><para>Simulates the pressed Control key.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="sendsyscommandwo"><title>SENDSYSCOMMAND</title>
<indexterm><primary>SENDSYSCOMMAND method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SENDSYSCOMMAND method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SENDSYSCOMMAND--(--"--+-SIZE--------+--"--)-----------------><
                         +-MOVE--------+
                         +-MINIMIZE----+
                         +-MAXIMIZE----+
                         +-NEXTWINDOW--+
                         +-PREVWINDOW--+
                         +-CLOSE-------+
                         +-VSCROLL-----+
                         +-HSCROLL-----+
                         +-ARRANGE-----+
                         +-RESTORE-----+
                         +-TASKLIST----+
                         +-SCREENSAVE--+
                         +-CONTEXTHELP-+
]]>
</programlisting>

<para>Sends a WM_SYSCOMMAND message to the associated window. These messages
are normally sent when the user selects a command in the Window menu.</para>
<para>Argument:</para>
<para>The only argument is:</para>
<variablelist>
<varlistentry><term><emphasis role="italic">command</emphasis></term>
<listitem><para>One of the commands listed in the syntax diagram:
<variablelist>
<varlistentry><term>SIZE</term>
<listitem><para>Puts the window in size mode.
</para></listitem></varlistentry>
<varlistentry><term>MOVE</term>
<listitem><para>Puts the window in move mode.
</para></listitem></varlistentry>
<varlistentry><term>MINIMIZE</term>
<listitem><para>Minimizes the window.
</para></listitem></varlistentry>
<varlistentry><term>MAXIMIZE</term>
<listitem><para>Maximizes the window.
</para></listitem></varlistentry>
<varlistentry><term>NEXTWINDOW</term>
<listitem><para>Moves to the next window.
</para></listitem></varlistentry>
<varlistentry><term>PREVWINDOW</term>
<listitem><para>Moves to the previous window.
</para></listitem></varlistentry>
<varlistentry><term>CLOSE</term>
<listitem><para>Closes the window.
</para></listitem></varlistentry>
<varlistentry><term>VSCROLL</term>
<listitem><para>Scrolls vertically.
</para></listitem></varlistentry>
<varlistentry><term>HSCROLL</term>
<listitem><para>Scrolls horizontally.
</para></listitem></varlistentry>
<varlistentry><term>ARRANGE</term>
<listitem><para>Arranges the window.
</para></listitem></varlistentry>
<varlistentry><term>RESTORE</term>
<listitem><para>Restores the window to its normal position and size.
</para></listitem></varlistentry>
<varlistentry><term>TASKLIST</term>
<listitem><para>Activates the Start menu.
</para></listitem></varlistentry>
<varlistentry><term>SCREENSAVE</term>
<listitem><para>Executes the screen-saver application specified in the [boot]
section of the SYSTEM.INI file.
</para></listitem></varlistentry>
<varlistentry><term>CONTEXTHELP</term>
<listitem><para>Changes the cursor to a question mark with a pointer. If the
user then clicks on a control in the dialog box, the control receives a
WM_HELP message.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="pushbuttonwo"><title>PUSHBUTTON</title>
<indexterm><primary>PUSHBUTTON method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>PUSHBUTTON method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-PUSHBUTTON--(--label--)-------------------------------------><
]]>
</programlisting>

<para>Selects the button with the specified
<emphasis role="italic">label</emphasis> within the associated
window and sends the corresponding WM_COMMAND message. If the button's
label contains a mnemonic (underscored letter), you must specify an ampersand
(&amp;) in front of it. You can also use this method to select radio buttons
and check or uncheck check boxes.</para>
</section>

<section id="sendkeywo"><title>SENDKEY</title>
<indexterm><primary>SENDKEY method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SENDKEY method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SENDKEY--(--keyName--+------------------------+--)----------><
                        +-,--+-----+--+--------+-+
                             +-alt-+  +-,--ext-+
]]>
</programlisting>

<para>Sends all messages (CHAR, KEYDOWN, and KEYUP) that would be sent by
pressing a specific key on the keyboard. Character keys (a to z) are not
case-sensitive.</para>
<para>If the <emphasis role="italic">alt</emphasis> argument is 1, the Alt key
flag is set, which is equal
to pressing the specified key together with the Alt key.</para>
<para>The <emphasis role="italic">Ext</emphasis> argument must be 1 if the key
is an extended key, such as a right Ctrl or a right Shift.</para>
<para>For a list of key names, refer to
<link linkend="virtualkeys">Symbolic Names for Virtual Keys</link>.</para>
</section>

<section id="sendcharwo"><title>SENDCHAR</title>
<indexterm><primary>SENDCHAR method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SENDCHAR method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SENDCHAR--(--character--+--------+--)-----------------------><
                           +-,--alt-+
]]>
</programlisting>

<para>Sends a WM_CHAR message to the associated window. If the
<emphasis role="italic">alt</emphasis> argument
is 1, a pressed Alt key is simulated.</para>
</section>

<section id="sendkeydownwo"><title>SENDKEYDOWN</title>
<indexterm><primary>SENDKEYDOWN method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SENDKEYDOWN method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SENDKEYDOWN--(--keyName--+--------+--)----------------------><
                            +-,--ext-+
]]>
</programlisting>

<para>Sends a WM_KEYDOWN message to the associated window. The
<emphasis role="italic">ext</emphasis> argument
must be 1 if the key is an extended key, such as a right Ctrl or a right Shift.
</para>
<para>For a list of key names, refer to
<link linkend="virtualkeys">Symbolic Names for Virtual Keys</link>.</para>
</section>

<section id="sendkeyupwo"><title>SENDKEYUP</title>
<indexterm><primary>SENDKEYUP method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SENDKEYUP method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SENDKEYUP--(--keyName--+--------+--)------------------------><
                          +-,--ext-+
]]>
</programlisting>

<para>Sends a WM_KEYUP message to the associated window. The
<emphasis role="italic">ext</emphasis> argument
must be 1 if the key is an extended key, such as a right Ctrl or a right Shift.
</para>
<para>For a list of key names, refer to
<link linkend="virtualkeys">Symbolic Names for Virtual Keys</link>.</para>
</section>

<section id="sendtextwo"><title>SENDTEXT</title>
<indexterm><primary>SENDTEXT method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SENDTEXT method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SENDTEXT--(--text--)----------------------------------------><
]]>
</programlisting>

<para>Sends a (case-sensitive) text to the associated window by sending a
sequence of WM_CHAR, WM_KEYDOWN, and WM_KEYUP messages.</para>
</section>

<section id="menuwo"><title>MENU</title>
<indexterm><primary>MENU method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MENU method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MENU--------------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the MenuObject class that refers to the menu of
the associated window.</para>
</section>

<section id="systemmenuwo"><title>SYSTEMMENU</title>
<indexterm><primary>SYSTEMMENU method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SYSTEMMENU method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SYSTEMMENU--------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the MenuObject class that refers to the system
menu of the associated window.</para>
</section>

<section id="ismenuwo"><title>ISMENU</title>
<indexterm><primary>ISMENU method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ISMENU method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-ISMENU------------------------------------------------------><
]]>
</programlisting>

<para>Returns 1 if the associated window is a menu, otherwise 0.</para>
</section>

<section id="processmenucommandwo"><title>PROCESSMENUCOMMAND</title>
<indexterm><primary>PROCESSMENUCOMMAND method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>PROCESSMENUCOMMAND method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
                                       +-,-------+
                                       V         |
>>-PROCESSMENUCOMMAND--(--+------+--,----submenu-+--,--menuItem--)-><
                          +-menu-+
]]>
</programlisting>

<para>Selects an item of the menu or submenu of the associated window. You can
specify as many submenus as necessary to get to the required item.</para>
</section>
</section>

<section id="winpm"><title>The WindowsProgramManager Class</title>
<indexterm><primary>WindowsProgramManager class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsProgramManager class</secondary></indexterm>
<para>Object Rexx provides a class for interaction with the Windows Program
Manager. You can use this class to create program groups and shortcuts to
access your programs. This class is specifically for Windows systems
and may not be available on other systems.</para>
<para>The WindowsProgramManager class is defined in the file WINSYSTM.CLS. Use
a <computeroutput>::requires</computeroutput> statement to activate its
function: </para>
<programlisting>
::requires "winsystm.cls"
</programlisting>
<para>A sample program <computeroutput>DESKTOP.REX</computeroutput> is provided
in the <computeroutput>ooRexx\SAMPLES</computeroutput> directory.</para>
<para>Methods of the WindowsProgramManager class are:</para>

<table frame="all">
<title>Methods Available to the WindowsProgramManager Class</title>
<tgroup cols="2">
<thead>
<row>
<entry>Method...</entry>
<entry>...on page</entry>
</row>
</thead>
<tbody>
<row>
<entry>AddDeskTopIcon</entry>
<entry><link linkend="adddesktopicon">AddDesktopIcon</link></entry>
</row>
<row>
<entry>AddGroup</entry>
<entry><link linkend="wpadgr">AddGroup</link></entry>
</row>
<row>
<entry>AddItem</entry>
<entry><link linkend="wpadit">AddItem</link></entry>
</row>
<row>
<entry>AddShortCut</entry>
<entry><link linkend="addshortcut">AddShortCut</link></entry>
</row>
<row>
<entry>DeleteDesktopIcon</entry>
<entry><link linkend="deldskic">DeleteDesktopIcon</link></entry>
</row>
<row>
<entry>DeleteGroup</entry>
<entry><link linkend="wpdegr">DeleteGroup</link></entry>
</row>
<row>
<entry>DeleteItem</entry>
<entry><link linkend="wpdeit">DeleteItem</link></entry>
</row>
<row>
<entry>Init</entry>
<entry><link linkend="wpinit">Init</link></entry>
</row>
<row>
<entry>ShowGroup</entry>
<entry><link linkend="wpshgr">ShowGroup</link></entry>
</row>
</tbody>
</tgroup>
</table>

<section id="adddesktopicon"><title>ADDDESKTOPICON</title>
<indexterm><primary>ADDDESKTOPICON method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ADDDESKTOPICON method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-AddDesktopIcon--(--name--,--program--+--------------------------------+-->
                                        |                     +-0------+ |
                                        +-,--+----------+--,--+--------+-+
                                             +-iconfile-+     +-iconnr-+

>--+--------------------------------------------------------------------------+-)-><
   |                 +-"PERSONAL"-+                           +-"NORMAL"----+ |
   +-,-+---------+-,-+------------+-,-+------+-,-+--------+-,-+-------------+-+
       +-workdir-+   +-"COMMON"---+   +-args-+   +-hotkey-+   +-"MAXIMIZED"-+
                                                              +-"MINIMIZED"-+
]]>
</programlisting>

<para>Adds a shortcut to the Windows desktop. A sample program
<computeroutput>DESKICON.REX</computeroutput> is provided in the
<computeroutput>ooRexx\SAMPLES</computeroutput> directory.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>name</term>
<listitem><para>The name of the shortcut, displayed below the icon.
</para></listitem></varlistentry>
<varlistentry><term>program</term>
<listitem><para>The program file launched by the shortcut.
</para></listitem></varlistentry>
<varlistentry><term>iconfile</term>
<listitem><para>The name of the icon used for the shortcut. If not specified,
the icon of <emphasis role="italic">program</emphasis> is used.
</para></listitem></varlistentry>
<varlistentry><term>iconnr</term>
<listitem><para>The number of the icon within the
<emphasis role="italic">iconfile</emphasis>. The default is 0.
</para></listitem></varlistentry>
<varlistentry><term>workdir</term>
<listitem><para>The working directory of the shortcut.
</para></listitem></varlistentry>
<varlistentry><term>location</term>
<listitem><para>Either of the following locations:
<variablelist>
<varlistentry><term>&quot;PERSONAL&quot;</term>
<listitem><para>The shortcut is personal and displayed only on the desktop of
the user.</para></listitem></varlistentry>
<varlistentry><term>&quot;COMMON&quot;</term>
<listitem><para>The shortcut is common to all users and displayed on the
desktop of all users.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>args</term>
<listitem><para>The arguments passed to the program that the shortcut refers to.
</para></listitem></varlistentry>
<varlistentry><term>hotkey</term>
<listitem><para>The virtual key to be used as a hotkey to open the shortcut.
For a list of the key names, see
<link linkend="virtualkeys">Symbolic Names for Virtual Keys</link>.
</para></listitem></varlistentry>
<varlistentry><term>run</term>
<listitem><para>Specifies one of the options listed in the syntax diagram. The
default is &quot;NORMAL&quot;.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="addshortcut"><title>ADDSHORTCUT</title>
<indexterm><primary>ADDSHORTCUT method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ADDSHORTCUT method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-AddShortCut--(--name--,--program--------------------------------------->

>--+---------------------------------------------------------------------->
   |                  +-0------+
   +-,-+----------+-,-+--------+-,-+---------+-,-+------+-,-+--------+-,-->
       +-iconfile-+   +-iconnr-+   +-workdir-+   +-args-+   +-hotkey-+

>-------------------+--)-------------------------------------------------><
    +-"NORMAL"----+ |
>---+-------------+-+
    +-"MAXIMIZED"-+
    +-"MINIMIZED"-+
]]>
</programlisting>

<para>Creates a shortcut within the specified folder.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>name</term>
<listitem><para>The full name of the shortcut.
</para></listitem></varlistentry>
<varlistentry><term>program</term>
<listitem><para>The program file launched by the shortcut.
</para></listitem></varlistentry>
<varlistentry><term>iconfile</term>
<listitem><para>The name of the icon used for the shortcut. If not specified,
the icon of <emphasis role="italic">program</emphasis> is used.
</para></listitem></varlistentry>
<varlistentry><term>iconnr</term>
<listitem><para>The number of the icon within the
<emphasis role="italic">iconfile</emphasis>. The default is
0.
</para></listitem></varlistentry>
<varlistentry><term>workdir</term>
<listitem><para>The working directory of the shortcut.
</para></listitem></varlistentry>
<varlistentry><term>args</term>
<listitem><para>The arguments passed to the program that the shortcut refers to.
</para></listitem></varlistentry>
<varlistentry><term>hotkey</term>
<listitem><para>The virtual key to be used as a hotkey to open the shortcut.
For a list of the key names, see
<link linkend="virtualkeys">Symbolic Names for Virtual Keys</link>.
</para></listitem></varlistentry>
<varlistentry><term>run</term>
<listitem><para>Specifies one of the options listed in the syntax diagram.
The default is &quot;NORMAL&quot;.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>Example:</term>
<listitem><para>The following example creates a shortcut named
&quot;My NotePad&quot;
to the Notepad editor wihin the directory c:\temp:
<programlisting>
pm = .WindowsProgramManager~new
	if pm~InitCode \= 0 then exit
	pm~AddShortCut("c:\temp\My Notepad","%SystemRoot%\system32\notepad.exe")
	::requires "winsystm.cls"
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="wpadgr"><title>ADDGROUP</title>
<indexterm><primary>ADDGROUP method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ADDGROUP method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-AddGroup(-group-)-------------------------------------------><
]]>
</programlisting>

<para>Adds a program group to the Programs group of the desktop. If the group
already exists, it is opened. The <emphasis role="italic">group</emphasis>
argument specifies the name of the program group to be added. Example:</para>
<programlisting>
AddGroup("Object Rexx Redbook")
</programlisting>

<note><title>Note</title>
<para>The name that you specify for the
<emphasis role="italic">group</emphasis> argument
must not contain any brackets or parenthesis. Otherwise, this method fails.
</para></note>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The method was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="wpadit"><title>ADDITEM</title>
<indexterm><primary>ADDITEM method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ADDITEM method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-AddItem--(--shortcut,program--------------------------------->

>--+------------------------------------------------------+----->
   +-,--+----------+--+---------------------------------+-+
        +-iconfile-+  +-,--+------------+--+----------+-+
                           +-iconnumber-+  +-,workdir-+

>--)-----------------------------------------------------------><
]]>
</programlisting>

<para>Adds a shortcut to a program group. The shortcut is placed into the last
group used with either AddGroup or ShowGroup. Example: </para>
<programlisting>
AddItem("OODialog Samples", ,
"rexx oodialog\samples\sample.rex", ,
"oodialog\samples\oodialog.ico")
</programlisting>

<note><title>Note</title>
<para>The name that you specify for the <emphasis role="italic">group</emphasis>
argument must not contain characters that are not valid, such as brackets or
parenthesis. Otherwise, this method fails. Some characters are changed,
for example / to _.</para></note>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The method was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="deldskic"><title>DELETEDESKTOPICON</title>
<indexterm><primary>DELETEDESKTOPICON method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DELETEDESKTOPICON method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>

<programlisting>
<![CDATA[
                                +-"PERSONAL"-+
DeleteDesktopIcon--(--name--,---+------------+-)
                                +-"COMMON"---+
]]>
</programlisting>

<para>Deletes a shortcut from the Windows desktop that was previously
created with AddDesktopIcon.</para>

<para>The arguments are:</para>

<variablelist>
<varlistentry><term><emphasis>name</emphasis></term>
<listitem><para>The name of the shortcut to be deleted.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>location</emphasis></term>
<listitem><para>Either of the following locations:</para>
<variablelist>
<varlistentry><term><emphasis>"PERSONAL"</emphasis></term>
<listitem><para>The shortcut was previously created with AddDektopIcon
and the location option "PERSONAL". This is the default.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>"COMMON"</emphasis></term>
<listitem><para>The shortcut was previously created with AddDektopIcon
and the location option "COMMON".
</para></listitem></varlistentry>
</variablelist>
</listitem></varlistentry>
</variablelist>

<para><emphasis role="bold">Return codes:</emphasis></para>

<variablelist>
<varlistentry><term><emphasis>0</emphasis></term>
<listitem><para>Shortcut deleted successfully.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>2</emphasis></term>
<listitem><para>Shortcut not found.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>3</emphasis></term>
<listitem><para>Path to shortcut not found.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>5</emphasis></term>
<listitem><para>Access denied or busy.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>26</emphasis></term>
<listitem><para>Not a DOS disk.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>32</emphasis></term>
<listitem><para>Sharing violation.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>36</emphasis></term>
<listitem><para>Sharing buffer exceeded.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>87</emphasis></term>
<listitem><para>Does not exist.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>206</emphasis></term>
<listitem><para>Shortcut name exceeds range error.
</para></listitem></varlistentry>
</variablelist>

<note><title>Note:</title>
<para>Return code 2 is also returned when a "PERSONAL" should be
deleted that was previously created with "COMMON" and vice
versa.</para></note>

<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[
pm = .WindowsProgramManager~new
if pm~InitCode \= 0 then exit

rc = pm~DeleteDesktopIcon("MyNotepad1", ,
     "%SystemRoot%\system32\notepad.exe")
if rc \= 0 then do
  say "Error deleting shortcut: My Notepad 1"
  exit
end

exit

::requires "winsystm.cls"
]]>
</programlisting>

</section>

<section id="wpdegr"><title>DELETEGROUP</title>
<indexterm><primary>DELETEGROUP method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DELETEGROUP method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-DeleteGroup(-group-)----------------------------------------><
]]>
</programlisting>

<para>Deletes a program group from the desktop. The
<emphasis role="italic">group</emphasis> argument specifies
the name of the program group to be deleted.</para>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The method was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="wpdeit"><title>DELETEITEM</title>
<indexterm><primary>DELETEITEM method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DELETEITEM method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-DeleteItem(shortcut)----------------------------------------><
]]>
</programlisting>

<para>Deletes a shortcut from a program group.</para>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The method was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="wpinit"><title>INIT</title>
<indexterm><primary>INIT method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INIT method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-Init--------------------------------------------------------><
]]>
</programlisting>

<para>Creates an instance of the WindowsProgramManager class and loads the
required function package.</para>
</section>

<section id="wpshgr"><title>SHOWGROUP</title>
<indexterm><primary>SHOWGROUP method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SHOWGROUP method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-ShowGroup(-group,-+-----+-)---------------------------------><
                     +-MIN-+
                     +-MAX-+
]]>
</programlisting>

<para>Opens a program group. The
<emphasis role="italic">group</emphasis> argument specifies the name of
the program group to be opened. If MIN or MAX is specified, the program group
is opened minimized or maximized.</para>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The method was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="virtualkeys"><title>Symbolic Names for Virtual Keys</title>
<indexterm><primary>virtual keys</primary></indexterm>
<para><link linkend="t000033">Table 3</link> shows the symbolic names and the
keyboard equivalents for the virtual keys used by Object Rexx.</para>

<table id="t000033" frame="all">
<title>Symbolic Names for Virtual Keys</title>
<tgroup cols="2">
<thead>
<row>
<entry>Symbolic Name</entry>
<entry>Mouse or Keyboard Equivalent</entry>
</row>
</thead>
<tbody>
<row>
<entry>LBUTTON</entry>
<entry>Left mouse button</entry>
</row>
<row>
<entry>RBUTTON</entry>
<entry>Right mouse button</entry>
</row>
<row>
<entry>CANCEL</entry>
<entry>Control-break processing</entry>
</row>
<row>
<entry>MBUTTON</entry>
<entry>Middle mouse button (three-button mouse)</entry>
</row>
<row>
<entry>BACK</entry>
<entry>BACKSPACE key</entry>
</row>
<row>
<entry>TAB</entry>
<entry>TAB key</entry>
</row>
<row>
<entry>CLEAR</entry>
<entry>CLEAR key</entry>
</row>
<row>
<entry>RETURN</entry>
<entry>ENTER key</entry>
</row>
<row>
<entry>SHIFT</entry>
<entry>SHIFT key</entry>
</row>
<row>
<entry>CONTROL</entry>
<entry>CRTL key</entry>
</row>
<row>
<entry>MENU</entry>
<entry>ALT key</entry>
</row>
<row>
<entry>PAUSE</entry>
<entry>PAUSE key</entry>
</row>
<row>
<entry>CAPITAL</entry>
<entry>CAPS LOCK key</entry>
</row>
<row>
<entry>ESCAPE</entry>
<entry>ESC key</entry>
</row>
<row>
<entry>SPACE</entry>
<entry>SPACEBAR</entry>
</row>
<row>
<entry>PRIOR</entry>
<entry>PAGE UP key</entry>
</row>
<row>
<entry>NEXT</entry>
<entry>PAGE DOWN key</entry>
</row>
<row>
<entry>END</entry>
<entry>END key</entry>
</row>
<row>
<entry>HOME</entry>
<entry>HOME key</entry>
</row>
<row>
<entry>LEFT</entry>
<entry>LEFT ARROW key</entry>
</row>
<row>
<entry>UP</entry>
<entry>UP ARROW key</entry>
</row>
<row>
<entry>RIGHT</entry>
<entry>RIGHT ARROW key</entry>
</row>
<row>
<entry>DOWN</entry>
<entry>DOWN ARROW key</entry>
</row>
<row>
<entry>SELECT</entry>
<entry>SELECT key</entry>
</row>
<row>
<entry>EXECUTE</entry>
<entry>EXECUTE key</entry>
</row>
<row>
<entry>SNAPSHOT</entry>
<entry>PRINT SCREEN key</entry>
</row>
<row>
<entry>INSERT</entry>
<entry>INS key</entry>
</row>
<row>
<entry>DELETE</entry>
<entry>DEL key</entry>
</row>
<row>
<entry>HELP</entry>
<entry>HELP key</entry>
</row>
<row>
<entry>0</entry>
<entry>0 key</entry>
</row>
<row>
<entry>1</entry>
<entry>1 key</entry>
</row>
<row>
<entry>2</entry>
<entry>2 key</entry>
</row>
<row>
<entry>3</entry>
<entry>3 key</entry>
</row>
<row>
<entry>4</entry>
<entry>4 key</entry>
</row>
<row>
<entry>5</entry>
<entry>5 key</entry>
</row>
<row>
<entry>6</entry>
<entry>6 key</entry>
</row>
<row>
<entry>7</entry>
<entry>7 key</entry>
</row>
<row>
<entry>8</entry>
<entry>8 key</entry>
</row>
<row>
<entry>9</entry>
<entry>9 key</entry>
</row>
<row>
<entry>A</entry>
<entry>A key</entry>
</row>
<row>
<entry>B</entry>
<entry>B key</entry>
</row>
<row>
<entry>C</entry>
<entry>C key</entry>
</row>
<row>
<entry>D</entry>
<entry>D key</entry>
</row>
<row>
<entry>E</entry>
<entry>E key</entry>
</row>
<row>
<entry>F</entry>
<entry>F key</entry>
</row>
<row>
<entry>G</entry>
<entry>G key</entry>
</row>
<row>
<entry>H</entry>
<entry>H key</entry>
</row>
<row>
<entry>I</entry>
<entry>I key</entry>
</row>
<row>
<entry>J</entry>
<entry>J key</entry>
</row>
<row>
<entry>K</entry>
<entry>K key</entry>
</row>
<row>
<entry>L</entry>
<entry>L key</entry>
</row>
<row>
<entry>M</entry>
<entry>M key</entry>
</row>
<row>
<entry>N</entry>
<entry>N key</entry>
</row>
<row>
<entry>O</entry>
<entry>O key</entry>
</row>
<row>
<entry>Q</entry>
<entry>Q key</entry>
</row>
<row>
<entry>R</entry>
<entry>R key</entry>
</row>
<row>
<entry>S</entry>
<entry>S key</entry>
</row>
<row>
<entry>T</entry>
<entry>T key</entry>
</row>
<row>
<entry>U</entry>
<entry>U key</entry>
</row>
<row>
<entry>V</entry>
<entry>V key</entry>
</row>
<row>
<entry>W</entry>
<entry>W key</entry>
</row>
<row>
<entry>X</entry>
<entry>X key</entry>
</row>
<row>
<entry>Y</entry>
<entry>Y key</entry>
</row>
<row>
<entry>Z</entry>
<entry>Z key</entry>
</row>
<row>
<entry>NUMPAD0</entry>
<entry>Numeric keypad 0 key</entry>
</row>
<row>
<entry>NUMPAD1</entry>
<entry>Numeric keypad 1 key</entry>
</row>
<row>
<entry>NUMPAD2</entry>
<entry>Numeric keypad 2 key</entry>
</row>
<row>
<entry>NUMPAD3</entry>
<entry>Numeric keypad 3 key</entry>
</row>
<row>
<entry>NUMPAD4</entry>
<entry>Numeric keypad 4 key</entry>
</row>
<row>
<entry>NUMPAD5</entry>
<entry>Numeric keypad 5 key</entry>
</row>
<row>
<entry>NUMPAD6</entry>
<entry>Numeric keypad 6 key</entry>
</row>
<row>
<entry>NUMPAD7</entry>
<entry>Numeric keypad 7 key</entry>
</row>
<row>
<entry>NUMPAD8</entry>
<entry>Numeric keypad 8 key</entry>
</row>
<row>
<entry>NUMPAD9</entry>
<entry>Numeric keypad 9 key</entry>
</row>
<row>
<entry>MULTIPLY</entry>
<entry>Multiply key</entry>
</row>
<row>
<entry>ADD</entry>
<entry>Add key</entry>
</row>
<row>
<entry>SEPARATOR</entry>
<entry>Separator key</entry>
</row>
<row>
<entry>SUBTRACT</entry>
<entry>Subtract key</entry>
</row>
<row>
<entry>DECIMAL</entry>
<entry>Decimal key</entry>
</row>
<row>
<entry>DIVIDE</entry>
<entry>Divide key</entry>
</row>
<row>
<entry>F1</entry>
<entry>F1 key</entry>
</row>
<row>
<entry>F2</entry>
<entry>F2 key</entry>
</row>
<row>
<entry>F3</entry>
<entry>F3 key</entry>
</row>
<row>
<entry>F4</entry>
<entry>F4 key</entry>
</row>
<row>
<entry>F5</entry>
<entry>F5 key</entry>
</row>
<row>
<entry>F6</entry>
<entry>F6 key</entry>
</row>
<row>
<entry>F7</entry>
<entry>F7 key</entry>
</row>
<row>
<entry>F8</entry>
<entry>F8 key</entry>
</row>
<row>
<entry>F9</entry>
<entry>F9 key</entry>
</row>
<row>
<entry>F10</entry>
<entry>F10 key</entry>
</row>
<row>
<entry>F11</entry>
<entry>F11 key</entry>
</row>
<row>
<entry>F12</entry>
<entry>F12 key</entry>
</row>
<row>
<entry>F13</entry>
<entry>F13 key</entry>
</row>
<row>
<entry>F14</entry>
<entry>F14 key</entry>
</row>
<row>
<entry>F15</entry>
<entry>F15 key</entry>
</row>
<row>
<entry>F16</entry>
<entry>F16 key</entry>
</row>
<row>
<entry>F17</entry>
<entry>F17 key</entry>
</row>
<row>
<entry>F18</entry>
<entry>F18 key</entry>
</row>
<row>
<entry>F19</entry>
<entry>F19 key</entry>
</row>
<row>
<entry>F20</entry>
<entry>F20 key</entry>
</row>
<row>
<entry>F21</entry>
<entry>F21 key</entry>
</row>
<row>
<entry>F22</entry>
<entry>F22 key</entry>
</row>
<row>
<entry>F23</entry>
<entry>F23 key</entry>
</row>
<row>
<entry>F24</entry>
<entry>F24 key</entry>
</row>
<row>
<entry>NUMLOCK</entry>
<entry>NUM LOCK key</entry>
</row>
<row>
<entry>SCROLL</entry>
<entry>SCROLL LOCK key</entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>

<section id="wreg"><title>The WindowsRegistry Class</title>
<indexterm><primary>WindowsRegistry class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsProgramManager class</secondary></indexterm>
<para>Object Rexx provides a class for interaction with the WindowsRegistry.
You can use this class to query the registry and modify, add, and delete entries.
This class is specifically for Windows systems and may not be available
on other systems.</para>
<para>The WindowsRegistry class is not a built-in class; it is defined in the
file WINSYSTM.CLS.</para>
<para>Use a <computeroutput>::requires</computeroutput> statement to activate
its function: </para>
<programlisting>
::requires "winsystm.cls"
</programlisting>
<para>A sample program, <computeroutput>REGISTRY.REX</computeroutput>, is
provided in the <computeroutput>ooRexx\SAMPLES</computeroutput> directory
</para>
<para><emphasis role="bold">Methods the WindowsRegistry Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>CLASSES_ROOT</para></listitem>
<listitem><para>CLASSES_ROOT=</para></listitem>
<listitem><para>CLOSE</para></listitem>
<listitem><para>CREATE</para></listitem>
<listitem><para>CURRENT_KEY</para></listitem>
<listitem><para>CURRENT_KEY=</para></listitem>
<listitem><para>CURRENT_USER</para></listitem>
<listitem><para>CURRENT_USER=</para></listitem>
<listitem><para>DELETE</para></listitem>
<listitem><para>DELETEVALUE</para></listitem>
<listitem><para>FLUSH</para></listitem>
<listitem><para>GETVALUE</para></listitem>
<listitem><para>INIT</para></listitem>
<listitem><para>LIST</para></listitem>
<listitem><para>LISTVALUES</para></listitem>
<listitem><para>LOAD</para></listitem>
<listitem><para>LOCAL_MACHINE</para></listitem>
<listitem><para>LOCAL_MACHINE=</para></listitem>
<listitem><para>OPEN</para></listitem>
<listitem><para>QUERY</para></listitem>
<listitem><para>REPLACE</para></listitem>
<listitem><para>RESTORE</para></listitem>
<listitem><para>SAVE</para></listitem>
<listitem><para>SETVALUE</para></listitem>
<listitem><para>UNLOAD</para></listitem>
<listitem><para>USERS</para></listitem>
<listitem><para>USERS=</para></listitem></itemizedlist>

<section id="wrclro"><title>CLASSES_ROOT</title>
<indexterm><primary>CLASSES_ROOT method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CLASSES_ROOT method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CLASSES_ROOT------------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the root key HKEY_CLASSES_ROOT.</para>
</section>

<section id="wrclroe"><title>CLASSES_ROOT=</title>
<indexterm><primary>CLASSES_ROOT= method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CLASSES_ROOT= method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CLASSES_ROOT=-----------------------------------------------><
]]>
</programlisting>

<para>This method is used by INIT to set the attribute CLASSES_ROOT to
HKEY_CLASSES_ROOT. Do not modify this attribute.</para>
</section>

<section id="wrclse"><title>CLOSE</title>
<indexterm><primary>CLOSE method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CLOSE method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CLOSE(-+------------+-)-------------------------------------><
          +-key_handle-+
]]>
</programlisting>

<para>Closes a previously opened key specified by its handle. Example:</para>
<programlisting>
rg~close(objectrexxkey)
</programlisting>
<para>It can take several seconds before all data is written to disk. You can
use FLUSH to empty the cache.</para>
<para>If <emphasis role="italic">key_handle</emphasis> is omitted,
CURRENT_KEY is closed.</para>
</section>

<section id="wrconn"><title>CONNECT</title>
<indexterm><primary>CONNECT method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CONNECT method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CONNECT(-key,computer-)-------------------------------------><
]]>
</programlisting>

<para>Opens a key on a remote computer. This is supported only for
HKEY_LOCAL_MACHINE and HKEY_USERS.</para>
</section>

<section id="wrcrt"><title>CREATE</title>
<indexterm><primary>CREATE method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CREATE method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CREATE(-+--------+-,subkey)---------------------------------><
           +-parent-+
]]>
</programlisting>

<para>Adds a new named subkey to the registry and returns its handle. The
parent key handle <emphasis role="italic">parent</emphasis> can be a root key
or a key retrieved using OPEN. If the <emphasis role="italic">parent</emphasis>
key is omitted, CURRENT_KEY is used. Example:</para>
<programlisting>
newkey = rg~create(rg~local_machine,"MyOwnKey")
</programlisting>
</section>

<section id="wrcuky"><title>CURRENT_KEY</title>
<indexterm><primary>CURRENT_KEY method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CURRENT_KEY method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CURRENT_KEY-------------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the current key. The current key is set by INIT,
CREATE, and OPEN. It is used as a default value if the key is omitted in other
methods.</para>
</section>

<section id="wrcukye"><title>CURRENT_KEY=</title>
<indexterm><primary>CURRENT_KEY= method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CURRENT_KEY= method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CURRENT_KEY=------------------------------------------------><
]]>
</programlisting>

<para>Sets the handle of the current key.</para>
</section>

<section id="wrcuus"><title>CURRENT_USER</title>
<indexterm><primary>CURRENT_USER method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CURRENT_USER method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CURRENT_USER------------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the root key HKEY_CURRENT_USER.</para>
</section>

<section id="wrcuuse"><title>CURRENT_USER=</title>
<indexterm><primary>CURRENT_USER= method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CURRENT_USER= method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CURRENT_USER=-----------------------------------------------><
]]>
</programlisting>

<para>This method is used by INIT to set the attribute CURRENT_USER to
HKEY_CURRENT_USER. Do not modify this attribute.</para>
</section>

<section id="wrdele"><title>DELETE</title>
<indexterm><primary>DELETE method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DELETE method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-DELETE(-+------------+-,subkeyname)-------------------------><
           +-key_handle-+
]]>
</programlisting>

<para>Deletes a given named subkey of an open key specified by its handle and
all its subkeys and values. If <emphasis role="italic">key_handle</emphasis>
is omitted, CURRENT_KEY is used.</para>
</section>

<section id="wrdeva"><title>DELETEVALUE</title>
<indexterm><primary>DELETEVALUE method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DELETEVALUE method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-DELETEVALUE(-+------------+-+--------+-)--------------------><
                +-key_handle-+ +-,value-+
]]>
</programlisting>

<para>Deletes the named value for a given key. If
<emphasis role="italic">key_handle</emphasis> is omitted,
CURRENT_KEY is used. If <emphasis role="italic">value</emphasis>
is blank or omitted, the default value is deleted.</para>
</section>

<section id="wrflus"><title>FLUSH</title>
<indexterm><primary>FLUSH method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>FLUSH method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-FLUSH(-+------------+-)-------------------------------------><
          +-key_handle-+
]]>
</programlisting>

<para>Forces the system to write the cache buffer of a given key to disk. If
<emphasis role="italic">key_handle</emphasis> is omitted, CURRENT_KEY is
flushed.</para>
</section>

<section id="wrgtva"><title>GETVALUE</title>
<indexterm><primary>GETVALUE method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>GETVALUE method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-GETVALUE(-+------------+-+--------+-)-----------------------><
             +-key_handle-+ +-,value-+
]]>
</programlisting>

<para>Retrieves the data and type for a named value of a given key. The result
is a compound variable with suffixes data and type. If
<emphasis role="italic">key_handle</emphasis> is
omitted, CURRENT_KEY is used. If named <emphasis role="italic">value</emphasis>
is blank or omitted, the default value is retrieved. Example: </para>
<programlisting>
myval. = rg~GETVALUE(,"filesystem")        /* current key */
say "Type is" myval.type
if myval.type = "NORMAL" then say "Value is" myval.data
myval. = rg~GETVALUE(mykey)
say "my default value is:" myval.data
myval. = rg~GETVALUE(mykey,"")
say "my default value is:" myval.data
</programlisting>
<para>Possible types: NORMAL, EXPAND, MULTI, NUMBER, BINARY, NONE,
OTHER.</para>
</section>

<section id="wrinit"><title>INIT</title>
<indexterm><primary>INIT method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INIT method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-INIT--------------------------------------------------------><
]]>
</programlisting>

<para>Creates an instance of the WindowsRegistry class and loads the required
external function package. The current key is set to HKEY_LOCAL_MACHINE.</para>
</section>

<section id="wrlist"><title>LIST</title>
<indexterm><primary>LIST method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LIST method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-LIST(-+------------+-,stem.)--------------------------------><
         +-key_handle-+
]]>
</programlisting>

<para>Retrieves the list of subkeys for a given key in a stem variable. The name
of the stem variable must include the period. The keys are returned as stem.1,
stem.2, and so on. Example: </para>
<programlisting>
rg~LIST(objectrexxkey,orexxkeys.)
do i over orexxkeys.
say orexxkeys.i
end
</programlisting>
</section>

<section id="wrliva"><title>LISTVALUES</title>
<indexterm><primary>LISTVALUES method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LISTVALUES method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-LISTVALUES(-+------------+-,variable.)----------------------><
               +-key_handle-+
]]>
</programlisting>

<para>Retrieves all value entries of a given key into a compound variable. The
name of the variable must include the period. The suffixes of the compound
variable are numbered starting with 1, and for each number the three values
are the name (var.i.name), the data (var.i.data), and the type (var.i.type).
The type is NORMAL for alphabetic values, EXPAND for expandable strings such
as a path, NONE for no specified type, MULTI for multiple strings, NUMBER
for a 4-byte value, and BINARY for any data format.</para>
<para>If <emphasis role="italic">key_handle</emphasis> is omitted, the values
of CURRENT_KEY are listed.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
qstem. = rg~QUERY(objectrexxkey)
rg~LISTVALUES(objectrexxkey,lv.)
do i=1 to qstem.values
say "name of value:" lv.i.name "(type="lv.i.type")"
if lv.i.type = "NORMAL" then
say "data of value:" lv.i.data
end
</programlisting>
</section>

<section id="wrload"><title>LOAD</title>
<indexterm><primary>LOAD method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LOAD method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-LOAD(-+------------+-,subkeyname, filename)-----------------><
         +-key_handle-+
]]>
</programlisting>

<para>Load creates a named subkey under the open key key_handle and loads
registry data from the file filename (created by
<link linkend="wrsave">SAVE</link>) and stores the
data under the newly created subkey.</para>
<para>key_handle can only be HKEY_USERS or HKEY_LOCAL_MACHINE.
Registry information is stored in the form of a hive - a discrete body
of keys, subkeys, and values that is rooted at the top of the registry
hierarchy. A hive is backed by a single file.</para>
<para>If <emphasis role="italic">key_handle</emphasis> is omitted, the subkey
is created under HKEY_LOCAL_MACHINE.</para>
<para>Use <link linkend="wrunld">UNLOAD</link> to delete the subkey and to
unlock the registry data file filename.</para>
</section>

<section id="wrloma"><title>LOCAL_MACHINE</title>
<indexterm><primary>LOCAL_MACHINE method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LOCAL_MACHINE method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-LOCAL_MACHINE-----------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the root key HKEY_LOCAL_MACHINE.</para>
</section>

<section id="wrlomae"><title>LOCAL_MACHINE=</title>
<indexterm><primary>LOCAL_MACHINE= method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LOCAL_MACHINE= method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-LOCAL_MACHINE=----------------------------------------------><
]]>
</programlisting>

<para>This method is used by INIT to set the attribute LOCAL_MACHINE to
HKEY_LOCAL_MACHINE. Do not modify this attribute.</para>
</section>

<section id="wropen"><title>OPEN</title>
<indexterm><primary>OPEN method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>OPEN method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-OPEN(-+---------------+-,subkey-+--------------+-)----------><
         +-parent_handle-+         +-,-| access |-+

access:

   +-ALL-+
|--+-----+------------------------------------------------------>

   +--------------------------------------------------------------+
   V                                                              |
>----+-------+-+------+-+-------+-+---------+-+--------+-+------+-+--|
     +-WRITE-+ +-READ-+ +-QUERY-+ +-EXECUTE-+ +-NOTIFY-+ +-LINK-+
]]>
</programlisting>

<para>Opens a named subkey and return its handle. See
<link linkend="wrcrt">CREATE</link> for
more information about <emphasis role="italic">parent_handle</emphasis>.
Possible values for <emphasis role="italic">access</emphasis> are:</para>
<variablelist>
<varlistentry><term>ALL</term>
<listitem><para>Default
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>Create subkeys, set values
</para></listitem></varlistentry>
<varlistentry><term>READ</term>
<listitem><para>Query subkeys and values
</para></listitem></varlistentry>
<varlistentry><term>QUERY</term>
<listitem><para>Values
</para></listitem></varlistentry>
<varlistentry><term>EXECUTE</term>
<listitem><para>Key access, no subkey access
</para></listitem></varlistentry>
<varlistentry><term>NOTIFY</term>
<listitem><para>Change notification
</para></listitem></varlistentry>
<varlistentry><term>LINK</term>
<listitem><para>Create symbolic links
</para></listitem></varlistentry>
</variablelist><para> More than one value can be specified separated by blanks.
</para>
<para>Notice that on Windows NT some keys require certain access
rights and do not allow to open the key with all but only with certain access
values.</para>
</section>

<section id="wrquer"><title>QUERY</title>
<indexterm><primary>QUERY method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>QUERY method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-QUERY--(--+------------+--)---------------------------------><
             +-key_handle-+
]]>
</programlisting>

<para>Retrieves information about a given key in a compound variable. The
values returned are <emphasis role="italic">class</emphasis> (class name),
<emphasis role="italic">subkeys</emphasis> (number of subkeys)
<emphasis role="italic">values</emphasis> (number of value entries),
<emphasis role="italic">date</emphasis> and
<emphasis role="italic">time</emphasis> of
last modification. If <emphasis role="italic">key_handle</emphasis> is omitted,
CURRENT_KEY is queried. Example:</para>
<programlisting>
myquery. = rg~QUERY(objectrexxkey)
say "class="myquery.class "at" myquery.date
say "subkeys="myquery.subkeys "values="myquery.values
</programlisting>
</section>

<section id="wrrepl"><title>REPLACE</title>
<indexterm><primary>REPLACE method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>REPLACE method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-REPLACE(-+------------+-,-+------------+-,newfilename,oldfilename-)-><
            +-key_handle-+   +-subkeyname-+
]]>
</programlisting>

<para>Replaces the backup file of a key or subkey with a new file. Key must be
an immediate descendant of HKEY_LOCAL_MACHINE or HKEY_USERS. If
<emphasis role="italic">key_handle</emphasis> is omitted, the backup file of
CURRENT_KEY is replaced. The values in the new file become active when the
system is restarted. If <emphasis role="italic">subkeyname</emphasis> is
omitted, the key and all its subkeys will be replaced.</para>
</section>

<section id="wrrest"><title>RESTORE</title>
<indexterm><primary>RESTORE method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>RESTORE method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-RESTORE(-+------------+-,filename-+-------------+-)---------><
            +-key_handle-+           +-,"VOLATILE"-+
]]>
</programlisting>

<para>Restores a key from a file. If
<emphasis role="italic">key_handle</emphasis> is omitted, CURRENT_KEY
is restored. Example:</para>
<programlisting>
rg~RESTORE(objectrexxkey,"\objrexx\orexx")
</programlisting>
<para>The VOLATILE keyword creates a new memory-only set of registry
information that is valid only until the system is restarted.</para>
</section>

<section id="wrsave"><title>SAVE</title>
<indexterm><primary>SAVE method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SAVE method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SAVE(-+------------+-,filename)-----------------------------><
         +-key_handle-+
]]>
</programlisting>

<para>Saves the entries of a given key into a file. If
<emphasis role="italic">key_handle</emphasis> is
omitted, CURRENT_KEY is saved. Example: </para>
<programlisting>
rg~SAVE(objectrexxkey,"\objrexx\orexx")
</programlisting>
<para>On a FAT system, do not use a file extension in
<emphasis role="italic">filename</emphasis>.</para>
</section>

<section id="wrstva"><title>SETVALUE</title>
<indexterm><primary>SETVALUE method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SETVALUE method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SETVALUE(-+------------+-,-+------+-,value-+---------+-)----><
             +-key_handle-+   +-name-+        +-,NORMAL-+
                                              +-,EXPAND-+
                                              +-,MULTI--+
                                              +-,NUMBER-+
                                              +-,BINARY-+
                                              +-,NONE---+
]]>
</programlisting>

<para>Sets a named value of a given key. If
<emphasis role="italic">name</emphasis> is blank or omitted,
the default value is set. Examples: </para>
<programlisting>
rg~SETVALUE(objectrexxkey, ,"My default","NORMAL")
rg~SETVALUE(objectrexxkey,"Product_Name","Object Rexx")
rg~SETVALUE(objectrexxkey,"VERSION","1.0")
</programlisting>
</section>

<section id="wrunld"><title>UNLOAD</title>
<indexterm><primary>UNLOAD method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>UNLOAD method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-UNLOAD(-+------------+-,subkey)-----------------------------><
           +-key_handle-+
]]>
</programlisting>

<para>Removes a named subkey (created with <link linkend="wrload">LOAD</link>)
and its dependents from the registry, but does not modify the file containing
the registry information. If <emphasis role="italic">key_handle</emphasis>
is omitted, the subkey under CURRENT_KEY is unloaded. Unload also unlocks the
registry information file.</para>
</section>

<section id="wruse"><title>USERS</title>
<indexterm><primary>USERS method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>USERS method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-USERS-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the root key HKEY_USERS.</para>
</section>

<section id="wrusee"><title>USERS=</title>
<indexterm><primary>USERS= method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>USERS= method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-USERS=------------------------------------------------------><
]]>
</programlisting>
</section>
</section>

<section id="oleobjc"><title>The Windows OLEObject Class</title>
<indexterm><primary>OLEObject class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>OLEObject class</secondary></indexterm>
<para>This class provides support for OLE automation. OLE (Object Linking and
Embedding) is an implementation of COM (Component Object Model). OLE automation
makes it possible for one application to manipulate objects implemented in
another application, or to expose objects so they can be manipulated.</para>
<para>An automation client is an application that can manipulate exposed objects
belonging to another application. An automation server is an application that
exposes the objects. The OLEObject class enables Rexx to be an OLE automation
client. Note that the OLE acronym has now been replaced by ActiveX.</para>
<para>Applications can provide OLE objects, and OLE objects that support
automation can be used by a Rexx script to remotely control the object through
the supplied methods. This lets you write a Rexx script that, for example,
starts a Web browser, navigates to a certain page, and changes the display mode
of the browser.</para>
<para>Every application that supports OLE places a unique identifier in the
registry. This identifier is called the class ID (CLSID) of the OLE object. It
consists of several hexadecimal numbers separated by the minus symbol.</para>
<para><emphasis role="bold">Example:</emphasis> CLSID of
<trademark class="registered">Microsoft</trademark> Internet Explorer
(Version 5.00.2014.0216):</para>
<programlisting>
"{0002DF01-0000-0000-C000-000000000046}"
</programlisting>
<para>The CLSID number can prove inconvenient when you want to create or access
a certain object, so a corresponding easy-to-remember entry is provided in
the registry, and this entry is mapped to the CLSID. This entry is called
the ProgID (the program ID), and is a string containing words separated by
periods.</para>
<para><emphasis role="bold">Example:</emphasis> ProgID of Microsoft Internet
Explorer: <computeroutput>"InternetExplorer.Application"</computeroutput></para>
<para>To find the ProgID of an application, you can use the sample
script <computeroutput>OLEINFO.REX</computeroutput> or the Microsoft OLEViewer,
or you can consult
the documentation of the application or search the registry manually.</para>
<para>The OLEObject class is a built-in class.</para>
<para>Several sample programs are provided in the Object
Rexx installation directory under Samples\OLE.</para>
<itemizedlist>
<listitem><para>The APPS directory contains 13 examples of how to use Rexx to
remote-control other applications.</para></listitem>
<listitem><para>The OLEINFO directory is a sample Rexx application that can be
used to browse through the information an OLE object provides.</para></listitem>
<listitem><para>In the ADSI directory there are eight examples of how to use
the Active Directory Services Interface with the Rexx OLE interface.</para>
</listitem>
<listitem><para>The METHINFO directory contains a very basic example of how to
access the information an OLE object provides.</para></listitem>
<listitem><para>Finally, the WMI directory contains five examples of how to
work with the Windows Management Instrumentation.</para></listitem>
</itemizedlist>
<para><emphasis role="bold">Methods available to the OLEObject class:</emphasis>
</para>
<simplelist>
<member>DISPATCH</member>
<member>INIT</member>
<member>GETCONSTANT</member>
<member>GETKNOWNEVENTS</member>
<member>GETKNOWNMETHODS</member>
<member>GETOBJECT(Class method)</member>
<member>GETOUTPARAMETERS</member>
<member>UNKNOWN</member>
</simplelist>

<note><title>Note</title>
<para>The Rexx OLE object acts as a proxy to the
real OLE object. The OLE object has its own methods, depending on its individual
implementation; its methods are accessed transparently through the method
mechanism <link linkend="oleobunk">UNKNOWN</link>.</para></note>

<section id="oledispatch"><title>DISPATCH</title>
<indexterm><primary>DISPATCH method</primary>
<secondary>of OLEObject class</secondary>
</indexterm>
<indexterm><primary>method</primary>
<secondary>DISPATCH method</secondary>
<tertiary>of OLEObject class</tertiary>
</indexterm>

<programlisting>
<![CDATA[
>>-DISPATCH(methodname--+------------+--)----------------------><
                        |  +------+  |
                        |  V      |  |
                        +----,arg-+--+
]]>
</programlisting>

<para>
Dispatches a method with the optionally supplied arguments.
</para>
</section>

<section id="oleobjinit"><title>INIT</title>
<indexterm><primary>INIT method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INIT method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
                    +-, "NOEVENTS"---+
>>-INIT(-+-ProgID-+-+----------------+-)-----------------------><
         +-CLSID--+ +-, "WITHEVENTS"-+
]]>
</programlisting>

<para>Instantiates an OLE object of the given ProgID or CLSID. If the creation
fails, an error will be raised (see list of OLE specific errors on page
<link linkend="ERR92">***</link>).</para>
<para>The optional parameter "events" defines whether events are to be used or
not. Allowed values for events are <computeroutput>&apos;NOEVENTS&apos;</computeroutput>
(the default) and <computeroutput>&apos;WITHEVENTS&apos;</computeroutput>.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
myOLEObject = .OLEObject~new("InternetExplorer.Application")
</programlisting>
</section>

<section id="oleobgetcon"><title>GETCONSTANT</title>
<indexterm><primary>GETCONSTANT method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>GETCONSTANT</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-GETCONSTANT(-+--------------+-)-----------------------------><
                +-ConstantName-+
]]>
</programlisting>

<para>Retrieves the value of a constant that is associated with this
OLE object. If no constant of that name exists, the .NIL object will be returned.
You can also omit the name of the constant; this returns a stem with all known
constants and their values. In this case the constant names will be prefixed
with a "!" symbol.</para>
<para><emphasis role="bold">Example 1:</emphasis></para>
<programlisting>
myExcel = .OLEObject~new("Excel.Application")
say "xlCenter has the value" myExcel~GetConstant("xlCenter")
myExcel~quit
exit
</programlisting>
<para>Possible output:</para>
<programlisting>
xlCenter has the value -4108
</programlisting>
<para><emphasis role="bold">Example 2:</emphasis></para>
<programlisting>
myExcel = .OLEObject~new("Excel.Application")
constants. = myExcel~GetConstant
myExcel~quit

do i over constants.
  say i"="constants.i
end
</programlisting>
<para>Possible output:</para>
<programlisting>
!XLFORMULA=5
!XLMOVE=2
!XLTEXTMAC=19
...
</programlisting>
</section>

<section id="oleobgetknev"><title>GETKNOWNEVENTS</title>
<indexterm><primary>GETKNOWNEVENTS method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>GETKNOWNEVENTS method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-GETKNOWNEVENTS----------------------------------------------><
]]>
</programlisting>

<para>Returns a stem with information on the events that the OLE object can
create. It collects this information from the type library of the object. A
type library provides the names, types, and arguments of the provided methods.
</para>
<para>The stem provides the following information:</para>

<table frame="all">
<title>Stem Information</title>
<tgroup cols="2">
<tbody>
<row>
<entry>stem.0</entry>
<entry>The number of events.</entry>
</row>
<row>
<entry>stem.n.!NAME</entry>
<entry>Name of n-th event.</entry>
</row>
<row>
<entry>stem.n.!DOC</entry>
<entry>Description of n-th event (if available).</entry>
</row>
<row>
<entry>stem.n.!PARAMS.0</entry>
<entry>Number of parameters for n-th event.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!NAME</entry>
<entry>Name of i-th parameter of n-th event.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!TYPE</entry>
<entry>Type of i-th parameter of n-th event.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!FLAGS</entry>
<entry>Flags of i-th parameter of n-th event; can be "in",
"out", "opt", or any combination of these.</entry>
</row>
</tbody>
</tgroup>
</table>
<para>If no information is available, the .NIL object is returned and this OLE
object does not have any events.</para>
<para><emphasis role="bold">Example script:</emphasis></para>
<programlisting>
myIE = .OLEObject~new("InternetExplorer.Application","NOEVENTS")
events. = myIE~GetKnownEvents

if events. == .nil then
  say "Sorry, this object does not have any events."
else do
  say "The following events may occur:"
  do i = 1 to events.0
    say events.i.!NAME
  end
end

exit
</programlisting>
<para><emphasis role="bold">Sample output:</emphasis></para>
<programlisting>
The following events may occur:
ONTHEATERMODE
ONFULLSCREEN
ONSTATUSBAR
...
</programlisting>
<para>For an example of how to use events, see examples OLE\APPS\SAMP12.REX
and OLE\APPS\SAMP13.REX in the SAMPLES directory.</para>
</section>

<section id="oleobgetknme"><title>GETKNOWNMETHODS</title>
<indexterm><primary>GETKNOWNMETHODS method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>GETKNOWNMETHODS method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-GETKNOWNMETHODS---------------------------------------------><
]]>
</programlisting>

<para>Returns a stem with information on the methods that the OLE object
supplies. It collects this information from the type library of the object. A
type library provides the names, types, and arguments of the provided methods.
Parts of the supplied information have only informational character as you
cannot use them directly.</para>
<para>The stem provides the following information:</para>

<table frame="all">
<title>Stem Information</title>
<tgroup cols="2">
<tbody>
<row>
<entry>stem.0</entry>
<entry>The number of methods.</entry>
</row>
<row>
<entry>stem.!LIBNAME</entry>
<entry>Name of the type library that describes this object.</entry>
</row>
<row>
<entry>stem.!LIBDOC</entry>
<entry>A help string describing the type library. Only set
when the string is available.</entry>
</row>
<row>
<entry>stem.!COCLASSNAME</entry>
<entry>COM class name of this object.</entry>
</row>
<row>
<entry>stem.!COCLASSDOC</entry>
<entry>A string describing the COM class. Only set
when the string is supplied by the type library.</entry>
</row>
<row>
<entry>stem.n.!NAME</entry>
<entry>The name of the n-th method.</entry>
</row>
<row>
<entry>stem.n.!DOC</entry>
<entry>A help string for the n-th method. If this information
is not supplied in the type library this value will not be set.</entry>
</row>
<row>
<entry>stem.n.!INVKIND</entry>
<entry>A number that represents the invocation kind of the
method: 1 = normal method call, 2 =
<computeroutput>property get</computeroutput>, 4 = <computeroutput>property
put</computeroutput>. A normal method call is used with brackets; for a
<computeroutput>property
get</computeroutput> only the name is to be specified; and a
<computeroutput>property set</computeroutput> uses
the "=" symbol, as in these examples:
<computeroutput>object~methodCall(a,b,c)</computeroutput>
<computeroutput>object~propertyPut="Hello"</computeroutput>
<computeroutput>say object~propertyGet</computeroutput></entry>
</row>
<row>
<entry>stem.n.!RETTYPE</entry>
<entry>The return type of the n-th method. The return type
will be automatically converted to a Rexx object (see
<link linkend="oleobtypconv">Type Conversion</link> in
the description of the UNKNOWN method of the OLEObject class).</entry>
</row>
<row>
<entry>stem.n.!MEMID</entry>
<entry>The MemberID of the n-th method. This is only used internally
to call the method.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.0</entry>
<entry>The number of parameters of the n-th method.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!NAME</entry>
<entry>The name of the i-th parameter of the n-th method.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!TYPE</entry>
<entry>The type of the i-th parameter of the n-th method.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!FLAGS</entry>
<entry>The flags of the i-th parameter of the n-th method;
can be "in", "out", "opt", or any combination of these (for example: "[in,
opt]").</entry>
</row>
</tbody>
</tgroup>
</table>
<para>If no information is available, the .NIL object is returned.</para>

<note><title>Note</title>
<para>An object might provide additional methods that cannot be
retrieved for display but that can be invoked. In these cases, consult the
documentation of those objects.</para></note>
<para>There are mechanisms to 'hide' methods from the user, because these methods
can only be used internally. It might happen that these are not hidden properly
and will get displayed. Be careful with methods like:</para>
<simplelist>
<member>AddRef</member>
<member>GetTypeInfoCount</member>
<member>GetTypeInfo</member>
<member>GetIDsOfNames</member>
<member>QueryInterface</member>
<member>Release</member>
</simplelist>
<para><emphasis role="bold">Example script:</emphasis></para>
<programlisting>
myOLEObject = .OLEObject~new("InternetExplorer.Application")
methods. = myOLEObject~GetKnownMethods

if methods. == .nil then
  say "Sorry, no information on the methods available!"
else do
  say "The following methods are available to this OLE object:"
  do i = 1 to methods.0
    say methods.i.!NAME
  end
end

exit
</programlisting>
<para><emphasis role="bold">Sample output:</emphasis></para>
<programlisting>
The following methods are available to this OLE object:
GoBack
GoForward
GoHome
...
</programlisting>
</section>

<section id="oleobgetob"><title>GETOBJECT</title>
<indexterm><primary>GETOBJECT method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>GETOBJECT method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-GETOBJECT(Moniker-+--------+-)------------------------------><
                     +-,class-+
]]>
</programlisting>

<para>This is a class method that allows you to obtain an OLE object through
the use of a so-called moniker or nickname (a string). A moniker is used to
find out which object has to be created or, if it is already running, addressed.
The moniker itself tells OLE which type of object is required. The optional
parameter class can be used to specify a subclass of OLEObject, and can be
used to obtain an OLE object that supports events (the
<computeroutput>&apos;WITHEVENTS&apos;</computeroutput> option
will be used in this case).  This method is similar to the
<computeroutput>Init</computeroutput> method
where you have to specify a ProgID or CLSID.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
/* create a Word.Document by opening a certain file */
myOLEObject = .OLEObject~GetObject("C:\DOCS\HELLOWORLD.DOC")
</programlisting>
</section>

<section id="oleobgetoutpar"><title>GETOUTPARAMETERS</title>
<indexterm><primary>GETOUTPARAMETERS method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>GETOUTPARAMETERS method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-GETOUTPARAMETERS--------------------------------------------><
]]>
</programlisting>

<para>Returns an array containing the results of the single
<computeroutput>out</computeroutput> parameters
of the OLE object, or the .NIL object if it does not have any.
<computeroutput>Out</computeroutput> parameters
are arguments to the OLE object that are filled in by the OLE object. As this
is not possible in Rexx due to data encapsulation, the results are placed
in the array mentioned above.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<para>Consider an OLE object method with the following signature:</para>
<programlisting>
aMethod([in] A, [in] B, [out] sumAB)
</programlisting>
<para>The resulting <computeroutput>out</computeroutput> parameter of the
method invocation will be placed in the <computeroutput>out</computeroutput>
array at position one; the "normal" return
value gets processed as usual. In this case the method will return the .NIL
object:</para>
<programlisting>
resultTest = myOLEObject~aMethod(1, 2, .NIL)
say "Invocation result  :" resultTest
say "Result in out array:" myOLEObject~GetOutParameters~at(1)
</programlisting>
<para>The output of this sample script will be:</para>
<programlisting>
The NIL object
3
</programlisting>
<para><computeroutput>Out</computeroutput> parameters are placed in the
<computeroutput>out</computeroutput> array in order
from left to right. If the above OLE method looked like this:</para>
<programlisting>
aMethod([in] A, [in] B, [out] sumAB, [out] productAB),
</programlisting>
<para>then the <computeroutput>out</computeroutput> array would contain the sum
of A and B at position one, and the product at position two.</para>
</section>

<section id="oleobunk"><title>UNKNOWN</title>
<indexterm><primary>UNKNOWN method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>UNKNOWN method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-UNKNOWN(messagename--+----------------+--)------------------><
                        +--,messageargs--+
]]>
</programlisting>

<para>The <computeroutput>UNKNOWN</computeroutput> message is the central
mechanism through which methods of the OLE object are called.</para>
<para>For further information, see
<link linkend="unkno">Defining an UNKNOWN Method</link>.</para>
<para>You can invoke the methods of the real OLE object by simply stating their
names to the Rexx (proxy) OLE object like this:</para>
<programlisting>
myOLEObject~OLEMethodName
</programlisting>
<para>This calls the method <computeroutput>"OLEMethodName"</computeroutput>
of the real OLE object
for any message that does not exist for the Rexx OLE object by dispatching
the call to the real OLE object.</para>
<para>If an OLE object offers a method with a name that is identical to one
that is defined for <computeroutput>OLEObject</computeroutput>, you must call
<computeroutput>UNKNOWN</computeroutput> directly, like this:</para>
<programlisting>
msgs = .array~of("Hello","World")
val = myOLEObject~Unknown("Unknown",msgs)
</programlisting>
<para>This invokes the method <computeroutput>"UNKNOWN"</computeroutput>
of the OLE object with two arguments, <computeroutput>"Hello"</computeroutput>
and <computeroutput>"World"</computeroutput>.</para>
<para>Parameters for the OLE object are used in the usual way, with the
exception of so-called <computeroutput>"out"</computeroutput> parameters.
<computeroutput>Out</computeroutput> parameters will be
filled in by the OLE object itself. As this is not possible in Rexx due to
data encapsulation, a special method,
<link linkend="oleobgetoutpar">GETOUTPARAMETERS</link>,
has to be used. Specify the .NIL object for any
<computeroutput>Out</computeroutput> parameters
when invoking this method.</para>
</section>

<section id="oleobtypconv"><title>Type Conversion</title>
<indexterm><primary>Type conversion</primary></indexterm>
<para>Unlike Rexx, OLE uses strict typing of data. Conversion to and from these
types is done automatically, if conversion is possible. OLE types are called
variants, because they are stored in one structure that
gets flagged with the type it represents. The following is a list of common
types that OLE uses and the Rexx objects that they are converted into.</para>

<table frame="all">
<title>OLE/Rexx Types</title>
<tgroup cols="2">
<thead>
<row>
<entry>VARIANT type</entry>
<entry>Rexx object</entry>
</row>
</thead>
<tbody>
<row>
<entry>VT_EMPTY</entry>
<entry>.NIL</entry>
</row>
<row>
<entry>VT_NULL</entry>
<entry>.NIL</entry>
</row>
<row>
<entry>VT_VOID</entry>
<entry>.NIL</entry>
</row>
<row>
<entry>VT_I1</entry>
<entry>Rexx string (a whole number)</entry>
</row>
<row>
<entry>VT_I2</entry>
<entry>Rexx string (a whole number)</entry>
</row>
<row>
<entry>VT_I4</entry>
<entry>Rexx string (a whole number)</entry>
</row>
<row>
<entry>VT_I8</entry>
<entry>Rexx string (a whole number)</entry>
</row>
<row>
<entry>VT_UI1</entry>
<entry>Rexx string (a whole, positive number)</entry>
</row>
<row>
<entry>VT_UI2</entry>
<entry>Rexx string (a whole, positive number)</entry>
</row>
<row>
<entry>VT_UI4</entry>
<entry>Rexx string (a whole, positive number)</entry>
</row>
<row>
<entry>VT_UI8</entry>
<entry>Rexx string (a whole, positive number)</entry>
</row>
<row>
<entry>VT_R4</entry>
<entry>Rexx string (a real number)</entry>
</row>
<row>
<entry>VT_R8</entry>
<entry>Rexx string (a real number)</entry>
</row>
<row>
<entry>VT_CY</entry>
<entry>Rexx string (a fixed-point number with 15 digits to
the left of the decimal point and 4 digits to the right)</entry>
</row>
<row>
<entry>VT_DATE</entry>
<entry>Rexx string</entry>
</row>
<row>
<entry>VT_BSTR</entry>
<entry>Rexx string</entry>
</row>
<row>
<entry>VT_DISPATCH Rexx</entry>
<entry>OLEObject</entry>
</row>
<row>
<entry>VT_BOOL</entry>
<entry>.TRUE or .FALSE *</entry>
</row>
<row>
<entry>VT_VARIANT</entry>
<entry>Any Rexx object that can be represented as a VARIANT</entry>
</row>
<row>
<entry>VT_PTR</entry>
<entry>see VT_VARIANT</entry>
</row>
<row>
<entry>VT_SAFEARRAY</entry>
<entry>Rexx Array</entry>
</row>
</tbody>
</tgroup>
</table>
<para>* When you pass .TRUE or .FALSE to an OLE object, these get passed as 1
or 0, respectively.</para>
</section>
</section>
</chapter>
