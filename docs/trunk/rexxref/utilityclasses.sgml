<!--#########################################################################
    #
    # Description: Open Object Rexx: Reference SGML file.
    #
    # Copyright (c) 2005-2007, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<section id="miscclasses"><title>The Utility Classes</title>
<para>This section describes the miscellaneous classes supplied by ooRexx.</para>

<section id="clsDateTime"><title>The DateTime Class</title>
<indexterm><primary>DateTime class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>DateTime class</secondary></indexterm>

<para>A DateTime object represents a point in between 1 January 0001 at 00:00.000000
and 31 December 9999 at 23:59:59.999999.  A DateTime object has methods to allow
formatting a date or time in various formats, as well as allowing arithmetic operations between
dates.
</para>
<figure><title>The DateTime class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxDateTimeClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The DateTime class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;

<para>Methods inherited from the
<link linkend="clsComparable">Comparable class</link>.</para>
<itemizedlist>
<listitem><para><link linkend="mthComparableCompareTo">compareTo</link></para></listitem>
</itemizedlist>
</section>

<section id="mthDateTimeMinDate"><title>minDate (Class Method)</title>
<indexterm><primary>minDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>minDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-minDate-----------------------------------------------------><
]]>
</programlisting>

<para>Returns a DateTime instance representing the minimum supported Rexx date,
1 January 0001 at 00:00:00.000000.
</para>
</section>

<section id="mthDateTimeMaxDate"><title>maxDate (Class Method)</title>
<indexterm><primary>maxDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>maxDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-maxDate-----------------------------------------------------><
]]>
</programlisting>

<para>Returns a DateTime instance representing the maximum supported Rexx date,
31 December 9999 at 23:59:59.999999.
</para>
</section>

<section id="mthDateTimeToday"><title>today (Class Method)</title>
<indexterm><primary>today method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>today method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-today-------------------------------------------------------><
]]>
</programlisting>

<para>Returns a DateTime instance for the current day, with a time value of 00:00:00.000000.
</para>
</section>

<section id="mthDateTimeFromNormalDate"><title>fromNormalDate (Class Method)</title>
<indexterm><primary>fromNormalDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromNormalDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromNormalDate(-date-+------------+-)-----------------------------><
                        +-,separator-+
]]>
</programlisting>

<para>Creates a DateTime object from a string returned by the Normal option
of the <link linkend="bifDate">Date()</link> built-in function.
The time component will be set to the beginning of the input day (00:00:00.000000).</para>
<para>
If specified, <emphasis role="italic">separator</emphasis>
identifies the field separator character used in the string.  The separator must be a single character
or the null string ("").  A space (" ") is the default separator.</para>
</section>

<section id="mthDateTimeFromEuropeanDate"><title>fromEuropeanDate (Class Method)</title>
<indexterm><primary>fromEuropeanDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromEuropeanDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromEuropeanDate(-date-+------------+-)-----------------------------><
                          +-,separator-+
]]>
</programlisting>

<para>Creates a DateTime object from a string returned by the European option
of the <link linkend="bifDate">Date()</link> built-in function.
The time component will be set to the beginning of the input day (00:00:00.000000).</para>
<para>
If specified, <emphasis role="italic">separator</emphasis>
identifies the field separator character used in the string.  The separator must be a single character
or the null string ("").  A slash ("/") is the default separator.
The time component will be set to the beginning of the input day (00:00:00.000000).
</para>
</section>

<section id="mthDateTimeFromOrderedDate"><title>fromOrderedDate (Class Method)</title>
<indexterm><primary>fromOrderedDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromOrderedDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromOrderedDate(-date-+------------+-)-----------------------------><
                         +-,separator-+
]]>
</programlisting>

<para>Creates a DateTime object from a string returned by the Ordered option
of the <link linkend="bifDate">Date()</link> built-in function.
The time component will be set to the beginning of the input day (00:00:00.000000).</para>
<para>
If specified, <emphasis role="italic">separator</emphasis>
identifies the field separator character used in the string.  The separator must be a single character
or the null string ("").  A slash ("/") is the default separator.
The time component will be set to the beginning of the input day (00:00:00.000000).</para>
</section>

<section id="mthDateTimeFromStandardDate"><title>fromStandardDate (Class Method)</title>
<indexterm><primary>fromStandardDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromStandardDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromStandardDate(-date-+------------+-)-----------------------------><
                          +-,separator-+
]]>
</programlisting>

<para>Creates a DateTime object from a string returned by the Standard option
of the <link linkend="bifDate">Date()</link> built-in function.
The time component will be set to the beginning of the input day (00:00:00.000000).</para>
<para>
If specified, <emphasis role="italic">separator</emphasis>
identifies the field separator character used in the string.  The separator must be a single character
or the null string ("").  A null string ("") is the default separator.</para>
</section>

<section id="mthDateTimeFromUsaDate"><title>fromUsaDate (Class Method)</title>
<indexterm><primary>fromUsaDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromUsaDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromUsaDate(-date-+------------+-)-----------------------------><
                     +-,separator-+
]]>
</programlisting>

<para>Creates a DateTime object from a string returned by the Usa option
of the <link linkend="bifDate">Date()</link> built-in function.
The time component will be set to the beginning of the input day (00:00:00.000000).</para>
<para>
If specified, <emphasis role="italic">separator</emphasis>
identifies the field separator character used in the string.  The separator must be a single character
or the null string ("").  A slash ("/") is the default separator.</para>
</section>

<section id="mthDateTimeFromNormalTime"><title>fromNormalTime (Class Method)</title>
<indexterm><primary>fromNormalTime method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromNormalTime method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromNormalTime(time)--------------------------------------><
]]>
</programlisting>

<para>Creates a DateTime object from a string returned by the Normal option
of the <link linkend="bifTime">Time()</link> built-in function.
The date component will be set to 1 January 0001.</para>
</section>

<section id="mthDateTimeFromCivilTime"><title>fromCivilTime (Class Method)</title>
<indexterm><primary>fromCivilTime method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromCivilTime method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromCivilTime(time)--------------------------------------><
]]>
</programlisting>

<para>Creates a DateTime object from a string returned by the Civil option
of the <link linkend="bifTime">Time()</link> built-in function.
The date component will be set to 1 January 0001.</para>
</section>

<section id="mthDateTimeFromLongTime"><title>fromLongTime (Class Method)</title>
<indexterm><primary>fromLongTime method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromLongTime method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromLongTime(time)--------------------------------------><
]]>
</programlisting>

<para>Creates a DateTime object from a string returned by the Long option
of the <link linkend="bifTime">Time()</link> built-in function.
The date component will be set to 1 January 0001.</para>
</section>

<section id="mthDateTimeFromBaseDate"><title>fromBaseDate (Class Method)</title>
<indexterm><primary>fromBaseDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromBaseDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromBaseDate(date)---------------------------------------------><
]]>
</programlisting>

<para>Creates a DateTime object from a string returned by the Basedate option
of the <link linkend="bifDate">Date()</link> built-in function.
The time component will be set to the beginning of the input day (00:00:00.000000).</para>
</section>

<section id="mthDateTimeFromTicks"><title>fromTicks (Class Method)</title>
<indexterm><primary>fromTicks method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromTicks method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromTicks(time)----------------------------------------><
]]>
</programlisting>

<para>Creates a DateTime object from a string returned by the Ticks option
of the <link linkend="bifDate">Date()</link> or
<link linkend="bifTime">Time()</link> built-in functions.
</para>
</section>

<section id="mthDateTimeFromIsoDate"><title>fromIsoDate (Class Method)</title>
<indexterm><primary>fromIsoDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromIsoDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromIsoDate(date)--------------------------------------><
]]>
</programlisting>

<para>Creates a DateTime object from a string in ISO date format
(yyyy-mm-ddThh:mm:ss.uuuuuu).  The DateTime string method returns
the ISO format as the string form of a DateTime object.
</para>
</section>

<section id="mthDateTimeInit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-init--------------------------------------------------------><

>>-init(fullDate)---------------------------------------------><

>>-init(year,month,day-+------------------------------------------+----><
                       +-,hours,minutes,seconds-+---------------+-+
                                                +-,microseconds-+
]]>
</programlisting>

<para>Initializes a new DateTime instance.  If no arguments are specified,
the DateTime instance is set to the current date and time.  If the single
<emphasis role="italic">fullDate</emphasis> argument is used, the DateTime
argument is initialized to the date and time calculated by adding
<emphasis role="italic">fullDate</emphasis> microseconds to 0001-01-01T00:00:00.000000.
Otherwise, the DateTime instance is initialized to the <emphasis role="italic">year</emphasis>,
<emphasis role="italic">month</emphasis>, <emphasis role="italic">day</emphasis>,
<emphasis role="italic">hours</emphasis>, <emphasis role="italic">minutes</emphasis>,
<emphasis role="italic">seconds</emphasis>, and <emphasis role="italic">microseconds</emphasis>
components.  Each of these components must be a valid whole number within the acceptable range for the given
component.  For example, <emphasis role="italic">year</emphasis> must be in the range 1-9999, while
<emphasis role="italic">minutes</emphasis> must be in the range 0-59.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
<![CDATA[
today = .DateTime~new    -- initializes to current date and time
                         -- initializes to 9 Sep 2007 at 00:00:00.000000
day = .DateTime~new(date('F', "20070930", "S"))
                         -- also initializes to 9 Sep 2007 at 00:00:00.000000
day = .DateTime~new(2007, 9, 30)
                         -- initializes to 9 Sep 2007 at 10:33:00.000000
day = .DateTime~new(2007, 9, 30, 10, 33, 00)
]]>
</programlisting>
</section>

<section id="mthDateTimeComparisonMethods"><title>Comparison Methods</title>
<indexterm><primary>method</primary>
<secondary>comparison methods</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-comparison_operator(argument)-------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) or
<computeroutput>0</computeroutput> (false), the result of performing
the specified comparison operation. The receiver object and the
<emphasis role="italic">argument</emphasis> are the terms compared. Both must
be DateTime objects.
If <emphasis role="italic">argument</emphasis> is not a DateTime object, a SYNTAX
error condition is raised.
</para>

<para>The comparison operators you can use in a message are: </para>
<variablelist>
<varlistentry><term>=
<indexterm><primary>= method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>=</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are equal
</para></listitem></varlistentry>
<varlistentry><term>\=, &gt;&lt;, &lt;&gt;
<indexterm><primary>>&lt; method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>&gt;&lt; method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>&lt;&gt; method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>\=</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>>&lt;</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;&gt;</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are not equal (inverse of =)
</para></listitem></varlistentry>
<varlistentry><term>&gt;
<indexterm><primary>&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>></secondary></indexterm>
</term>
<listitem><para>Greater than
</para></listitem></varlistentry>
<varlistentry><term>&lt;
<indexterm><primary>&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;</secondary></indexterm>
</term>
<listitem><para>Less than
</para></listitem></varlistentry>
<varlistentry><term>&gt;=
<indexterm><primary>&gt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&gt;=</secondary></indexterm>
</term>
<listitem><para>Greater than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&lt;
<indexterm><primary>\&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&lt;</secondary></indexterm>
</term>
<listitem><para>Not less than
</para></listitem></varlistentry>
<varlistentry><term>&lt;=
<indexterm><primary>&lt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;=</secondary></indexterm>
</term>
<listitem><para>Less than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&gt;
<indexterm><primary>\&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&gt;</secondary></indexterm>
</term>
<listitem><para>Not greater than
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>comparison methods of DateTime class</secondary></indexterm>
<programlisting>
<![CDATA[
d = .DateTime~new       -- get the current time
midnight = d~date       -- get the start of the day
startTime = midnight~addHours(10)  -- time the bank opens
endTime = startTime~addHours(7)    -- bank closing time

if startTime <= d & d <= endTime then do
    say "The bank is open"
end
]]>
</programlisting>
<para>All strict comparison operations have one of the characters doubled that
define the operator. The DateTime strict comparison operators produce the same
results as the non-strict comparisons.
</para>
<para>The strict comparison operators you can use in a message are: </para>
<variablelist>
<varlistentry><term>==
<indexterm><primary>== method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>==</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
</term>
<listitem><para>True if terms are strictly equal
</para></listitem></varlistentry>
<varlistentry><term>\==
<indexterm><primary>\== method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\==</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are NOT strictly equal (inverse of ==)
</para></listitem></varlistentry>
<varlistentry><term>&gt;&gt;
<indexterm><primary>&gt;&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>>></secondary></indexterm>
</term>
<listitem><para>Strictly greater than
</para></listitem></varlistentry>
<varlistentry><term>&lt;&lt;
<indexterm><primary>&lt;&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;&lt;</secondary></indexterm>
</term>
<listitem><para>Strictly less than
</para></listitem></varlistentry>
<varlistentry><term>&gt;&gt;=
<indexterm><primary>&gt;&gt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&gt;&gt;=</secondary></indexterm>
</term>
<listitem><para>Strictly greater than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&lt;&lt;
<indexterm><primary>\&lt;&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&lt;&lt;</secondary></indexterm>
</term>
<listitem><para>Strictly NOT less than
</para></listitem></varlistentry>
<varlistentry><term>&lt;&lt;=
<indexterm><primary>&lt;&lt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;&lt;=</secondary></indexterm>
</term>
<listitem><para>Strictly less than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&gt;&gt;
<indexterm><primary>\&gt;&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&gt;&gt;</secondary></indexterm>
</term>
<listitem><para>Strictly NOT greater than
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthDateTimeArithmeticMethods"><title>Arithmetic Methods</title>
<indexterm><primary>method</primary>
<secondary>arithmetic methods</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-arithmetic_operator(argument)-------------------------------><
]]>
</programlisting>

<note><title>Note</title>
<para>For the prefix + operators, omit the parentheses
and <emphasis role="italic">argument</emphasis>.</para></note>
<para>Returns the result of performing the specified arithmetic operation on
the receiver DateTime object. Depending on the operation, the
<emphasis role="italic">argument</emphasis> be either a TimeSpan object or a DateTime
object.  See the description of the individual operations for details.
The
<emphasis role="italic">arithmetic_operator</emphasis> can be:
</para>
<variablelist>
<varlistentry><term>+
<indexterm><primary>+ method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>+</secondary></indexterm>
</term>
<listitem><para>Addition.  Adds a TimeSpan to the DateTime object, returning a new DateTime
instance.  The receiver DateTime object is not changed.  The TimeSpan may be either positive or negative.
</para></listitem></varlistentry>
<varlistentry><term>-
<indexterm><primary>- method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>-</secondary></indexterm>
</term>
<listitem><para>Subtraction.  If <emphasis role="italic">argument</emphasis> is a DateTime
object, the two times are subtracted, and a TimeSpan object representing the interval between the
two times is returned.  If the receiver DateTime is less than the <emphasis role="italic">argument</emphasis>
argument DateTime, a negative TimeSpan interval is returned.  The receiver DateTime object is not changed.</para>
<para>If <emphasis role="italic">argument</emphasis> is a TimeSpan object, subtracts the TimeSpan
from the DateTime object, returning a new DateTime
instance.  The receiver DateTime object is not changed.  The TimeSpan may be either positive or negative.
</para></listitem></varlistentry>
<varlistentry><term>Prefix -
<indexterm><primary>method</primary>
<secondary>prefix -</secondary></indexterm>
</term>
<listitem><para>A prefix - operation on a DateTime object will raise a SYNTAX error condition.
</para></listitem></varlistentry>
<varlistentry><term>Prefix +
<indexterm><primary>method</primary>
<secondary>prefix +</secondary></indexterm>
</term>
<listitem><para>Returns a new instance of the DateTime object with the same time value.
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>arithmetic methods of DateTime class</secondary></indexterm>
<programlisting>
<![CDATA[
t = .dateTime~new~timeOfDay  -- returns TimeSpan for current time.
say t                        -- displays "11:27:12.437000", perhaps
d = .dateTime~new(2010, 4, 11)  -- creates new date

future = d + t               -- adds timespan to d
say future                   -- displays "2010-04-11T11:27:12.437000"
                             -- "real" start of next century
nextCentury = .dateTime~new(2101, 1, 1)
                             -- displays "34060.12:25:49.922000", perhaps
say "The next century starts in" (nextCentury - .dateTime~new)
]]>
</programlisting>
</section>

<section id="mthDateTimeCompareTo"><title>compareTo</title>
<indexterm><primary>compareTo method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>compareTo method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-compareTo(other)------------------------------------------------><
]]>
</programlisting>

<para>This method returns "-1" if the <emphasis role="italic">other</emphasis> is larger than the receiving
object, "0" if the two objects are equal, and "1" if <emphasis role="italic">other</emphasis> is
smaller than the receiving object.</para>
</section>

<section id="mthDateTimeYear"><title>year</title>
<indexterm><primary>year method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>year method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-year------------------------------------------------><
]]>
</programlisting>

<para>
Returns the year represented by this DateTime instance.
</para>
</section>

<section id="mthDateTimeMonth"><title>month</title>
<indexterm><primary>month method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>month method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-month------------------------------------------------><
]]>
</programlisting>

<para>
Returns the month represented by this DateTime instance.
</para>
</section>

<section id="mthDateTimeDay"><title>day</title>
<indexterm><primary>day method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>day method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-day------------------------------------------------><
]]>
</programlisting>

<para>
Returns the day represented by this DateTime instance.
</para>
</section>

<section id="mthDateTimeHours"><title>hours</title>
<indexterm><primary>hours method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hours method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hours----------------------------------------------><
]]>
</programlisting>

<para>
Returns number of whole hours since midnight.
</para>
</section>

<section id="mthDateTimeMinutes"><title>minutes</title>
<indexterm><primary>minutes method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>minutes method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-minutes--------------------------------------------><
]]>
</programlisting>

<para>
Returns minutes portion of the timestamp time-of-day.
</para>
</section>

<section id="mthDateTimeSeconds"><title>seconds</title>
<indexterm><primary>seconds method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>seconds method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-seconds--------------------------------------------><
]]>
</programlisting>

<para>
Returns seconds portion of the timestamp time-of-day.
</para>
</section>

<section id="mthDateTimeMicroseconds"><title>microseconds</title>
<indexterm><primary>microseconds method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>microseconds method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-microseconds-----------------------------------------><
]]>
</programlisting>

<para>
Returns microseconds portion of the timestamp time-of-day.
</para>
</section>

<section id="mthDateTimeDayMinutes"><title>dayMinutes</title>
<indexterm><primary>dayMinutes method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>dayMinutes method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-dayMinutes-------------------------------------------><
]]>
</programlisting>

<para>
Returns the number of minutes since midnight in the time-of-day.
</para>
</section>

<section id="mthDateTimeDaySeconds"><title>daySeconds</title>
<indexterm><primary>daySeconds method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>daySeconds method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-daySeconds-------------------------------------------><
]]>
</programlisting>

<para>
Returns the number of seconds since midnight in the time-of-day.
</para>
</section>

<section id="mthDateTimeDayMicroseconds"><title>dayMicroseconds</title>
<indexterm><primary>dayMicroseconds method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>dayMicroseconds method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-dayMicroseconds-------------------------------------------><
]]>
</programlisting>

<para>
Returns the number of microseconds since midnight in the time-of-day.
</para>
</section>

<section id="mthDateTimeHashCode"><title>hashCode</title>
<indexterm><primary>hashCode method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hashCode method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hashCode---------------------------------------------------><
]]>
</programlisting>

<para>Returns a string value that is used as a hash value for a MapCollection
such as Table, Relation, Set, Bag, and Directory.
</para>
</section>

<section id="mthDateTimeAddYears"><title>addYears</title>
<indexterm><primary>addYears method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addYears method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addYears(years)--------------------------------------------><
]]>
</programlisting>

<para>Add a number of years to the DateTime object, returning a new DateTime instance.
The receiver DateTime object is unchanged.
The <emphasis role="italic">years</emphasis> value must be a valid whole number.  Negative values
result in years being subtracted from the DateTime value.
</para>
<para>The addYears method will take leap years into account.  If the addition result would fall on February 29th of
a non-leap year, the day will be rolled back to the 28th.
</para>
<programlisting>
<![CDATA[
date = .DateTime~new(2008, 2, 29)
say date              -- Displays "2008-02-29T00:00:00.000000"
say date~addYears(1)  -- Displays "2009-02-29T00:00:00.000000"
]]>
</programlisting>
</section>

<section id="mthDateTimeAddWeeks"<title>addWeeks</title>
<indexterm><primary>addWeeks method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addWeeks method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addWeeks(weeks)------------------------------------------><
]]>
</programlisting>

<para>Adds weeks to the DateTime object, returning a new DateTime instance.
The receiver DateTime object is unchanged.
The <emphasis role="italic">weeks</emphasis> value must be a valid number, including
fractional values.
Negative values
result in week being subtracted from the DateTime value.
</para>
</section>

<section id="mthDateTimeAddDays"<title>addDays</title>
<indexterm><primary>addDays method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addDays method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addDays(days)--------------------------------------------><
]]>
</programlisting>

<para>Adds days to the DateTime object, returning a new DateTime instance.
The receiver DateTime object is unchanged.
The <emphasis role="italic">days</emphasis> value must be a valid number, including
fractional values.
Negative values
result in days being subtracted from the DateTime value.
</para>
<programlisting>
<![CDATA[
date = .DateTime~new(2008, 2, 29)
say date              -- Displays "2008-02-29T00:00:00.000000"
say date~addDays(1.5) -- Displays "2008-03-01T12:00:00.000000"
]]>
</programlisting>
</section>

<section id="mthDateTimeAddHours"<title>addHours</title>
<indexterm><primary>addHours method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addHours method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addHours(hours)------------------------------------------><
]]>
</programlisting>

<para>Adds hours to the DateTime object, returning a new DateTime instance.
The receiver DateTime object is unchanged.
The <emphasis role="italic">hours</emphasis> value must be a valid number, including
fractional values.
Negative values
result in hours being subtracted from the DateTime value.
</para>
</section>

<section id="mthDateTimeAddMinutes"<title>addMinutes</title>
<indexterm><primary>addMinutes method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addMinutes method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addMinutes(minutes)--------------------------------------><
]]>
</programlisting>

<para>Adds minutes to the DateTime object, returning a new DateTime instance.
The receiver DateTime object is unchanged.
The <emphasis role="italic">minutes</emphasis> value must be a valid number, including
fractional values.
Negative values
result in minutes being subtracted from the DateTime value.
</para>
</section>

<section id="mthDateTimeAddSeconds"<title>addSeconds</title>
<indexterm><primary>addSeconds method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addSeconds method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addSeconds(seconds)--------------------------------------><
]]>
</programlisting>

<para>Adds seconds to the DateTime object, returning a new DateTime instance.
The receiver DateTime object is unchanged.
The <emphasis role="italic">seconds</emphasis> value must be a valid number, including
fractional values.
Negative values
result in seconds being subtracted from the DateTime value.
</para>
</section>

<section id="mthDateTimeAddMicroseconds"<title>addMicroseconds</title>
<indexterm><primary>addMicroseconds method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addMicroseconds method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addMicroseconds(microseconds)----------------------------><
]]>
</programlisting>

<para>Adds microseconds to the DateTime object, returning a new DateTime instance.
The receiver DateTime object is unchanged.
The <emphasis role="italic">microseconds</emphasis> value must be a valid whole number.
Negative values
result in microseconds being subtracted from the DateTime value.
</para>
</section>

<section id="mthDateTimeIsoDate"<title>isoDate</title>
<indexterm><primary>isoDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isoDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isoDate--------------------------------------------------><
]]>
</programlisting>

<para>Returns a String formatted into ISO date format, yyyy-dd-mmThh:mm:ss.uuuuuu.
</para>
</section>

<section id="mthDateTimeBaseDate"<title>baseDate</title>
<indexterm><primary>baseDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>baseDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-baseDate-------------------------------------------------><
]]>
</programlisting>

<para>
Returns the number of complete days (that is, not including the
current day) since and including the base date, 1 January 0001, in the format:
<emphasis role="italic">dddddd</emphasis> (no leading zeros or blanks).
</para>
<para>The base date of 1 January 1970 is determined
by extending the current Gregorian calendar backward (365 days each year,
with an extra day every year that is divisible by 4 except century years that
are not divisible by 400. It does not take into account any errors in the calendar
system that created the Gregorian calendar originally.</para>
</section>

<section id="mthDateTimeYearDay"<title>yearDay</title>
<indexterm><primary>yearDay method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>yearDay method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-yearDay--------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of days, including the current day, that have passed
in the DateTime year in the format <emphasis role="italic">ddd</emphasis>
(no leading zeros or blanks).
</para>
</section>

<section id="mthDateTimeWeekDay"<title>weekDay</title>
<indexterm><primary>weekDay method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>weekDay method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-weekDay--------------------------------------------------><
]]>
</programlisting>

<para>Returns the day of the week, as an integer.  The values returned use the
ISO convention for day numbering.  Monday is "1", Tuesday is "2", running
through "7" for Sunday.
</para>
</section>

<section id="mthDateTimeEuropeanDate"<title>europeanDate</title>
<indexterm><primary>europeanDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>europeanDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-europeanDate(-+-----------+-)-------------------------------><
                 +-separator-+
]]>
</programlisting>

<para>Returns the date in the format <emphasis role="italic">dd/mm/yy</emphasis>.
If specified, <emphasis role="italic">separator</emphasis>
identifies the field separator character used in the returned date.
The separator must be a single character
or the null string ("").  A slash ("/") is the default separator.
</para>
</section>

<section id="mthDateTimeLanguageDate"<title>languageDate</title>
<indexterm><primary>languageDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>languageDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-languageDate---------------------------------------------><
]]>
</programlisting>

<para>Returns the date in an implementation- and language-dependent, or local,
date format. The format is <emphasis role="italic">dd month yyyy</emphasis>.
The name of the month is according to the national language installed on the
system. If no local date format is available, the default format is returned.

<note><title>Note</title>
<para>This
format is intended to be used as a whole; Rexx programs must not make any
assumptions about the form or content of the returned string.</para></note>
</para>
</section>

<section id="mthDateTimeMonthName"<title>monthName</title>
<indexterm><primary>monthName method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>monthName method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-monthName------------------------------------------------><
]]>
</programlisting>

<para>
Returns the name of the DateTime month, in English.
</para>
</section>

<section id="mthDateTimeDayName"<title>dayName</title>
<indexterm><primary>dayName method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>dayName method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-dayName------------------------------------------------><
]]>
</programlisting>

<para>
Returns the name of the DateTime day, in English.
</para>
</section>

<section id="mthDateTimeNormalDate"<title>normalDate</title>
<indexterm><primary>normalDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>normalDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-normalDate(-+-----------+-)-------------------------------><
               +-separator-+
]]>
</programlisting>

<para>Returns the date in the format <emphasis role="italic">dd mon yyyy</emphasis>.
If specified, <emphasis role="italic">separator</emphasis>
identifies the field separator character used in the returned date.
The separator must be a single character
or the null string ("").  A space (" ") is the default separator.
</para>
</section>

<section id="mthDateTimeOrderedDate"<title>orderedDate</title>
<indexterm><primary>orderedDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>orderedDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-orderedDate(-+-----------+-)-------------------------------><
                +-separator-+
]]>
</programlisting>

<para>Returns the date in the format <emphasis role="italic">yy/mm/dd</emphasis>.
If specified, <emphasis role="italic">separator</emphasis>
identifies the field separator character used in the returned date.
The separator must be a single character
or the null string ("").  A slash ("/") is the default separator.
</para>
</section>

<section id="mthDateTimeStandardDate"<title>standardDate</title>
<indexterm><primary>standardDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>standardDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-standardDate(-+-----------+-)-------------------------------><
                 +-separator-+
]]>
</programlisting>

<para>Returns the date in the format <emphasis role="italic">yyyymmdd</emphasis>.
If specified, <emphasis role="italic">separator</emphasis>
identifies the field separator character used in the returned date.
The separator must be a single character
or the null string ("").  A null string ("") is the default separator.
</para>
</section>

<section id="mthDateTimeUsaDate"<title>usaDate</title>
<indexterm><primary>usaDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>usaDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-usaDate(-+-----------+-)-------------------------------><
            +-separator-+
]]>
</programlisting>

<para>Returns the date in the format <emphasis role="italic">mm/dd/yy</emphasis>.
If specified, <emphasis role="italic">separator</emphasis>
identifies the field separator character used in the returned date.
The separator must be a single character
or the null string ("").  A slash ("/") is the default separator.
</para>
</section>

<section id="mthDateTimeCivilTime"<title>civilTime</title>
<indexterm><primary>civilTime method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>civilTime method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-civilTime-----------------------------------------------><
]]>
</programlisting>

<para>Returns the time in Civil format <emphasis role="italic">hh:mmxx</emphasis>.
The hours can take
the values <computeroutput>1</computeroutput> through
<computeroutput>12</computeroutput>, and the minutes the values
<computeroutput>00</computeroutput> through <computeroutput>59</computeroutput>.
The minutes are followed immediately by the letters
<computeroutput>am</computeroutput> or <computeroutput>pm</computeroutput>.
This distinguishes times in the morning (12 midnight through 11:59
a.m.--appearing as <computeroutput>12:00am</computeroutput> through
<computeroutput>11:59am</computeroutput>) from noon and afternoon (12 noon
through 11:59 p.m.--appearing as <computeroutput>12:00pm</computeroutput>
through <computeroutput>11:59pm</computeroutput>). The hour has no leading
zero.  The minute field shows the current minute (rather than the nearest
minute) for consistency with other TIME results.
</para>
</section>

<section id="mthDateTimeNormalTime"<title>normalTime</title>
<indexterm><primary>normalTime method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>normalTime method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-normalTime-----------------------------------------------><
]]>
</programlisting>

<para>Returns the time in the default format <emphasis role="italic">hh:mm:ss</emphasis>.
The hours
can have the values <computeroutput>00</computeroutput> through
<computeroutput>23</computeroutput>, and minutes and seconds,
<computeroutput>00</computeroutput> through <computeroutput>59</computeroutput>.
There are always two digits. Any fractions
of seconds are ignored (times are never rounded). This is the default.
</para>
</section>

<section id="mthDateTimeLongTime"<title>longTime</title>
<indexterm><primary>longTime method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>longTime method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-longTime-----------------------------------------------><
]]>
</programlisting>

<para>Returns time in the format <emphasis role="italic">hh:mm:ss.uuuuuu</emphasis>
(where <emphasis role="italic">uuuuuu</emphasis> are microseconds).
</para>
</section>

<section id="mthDateTimeFullDate"<title>fullDate</title>
<indexterm><primary>fullDate method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fullDate method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fullDate-----------------------------------------------><
]]>
</programlisting>

<para>Returns the number of microseconds
since 00:00:00.000000 on 1 January 0001, in the format:
<emphasis role="italic">dddddddddddddddddd</emphasis> (no leading zeros or blanks).
</para>
</section>

<section id="mthDateTimeTicks"<title>ticks</title>
<indexterm><primary>ticks method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ticks method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-ticks--------------------------------------------------><
]]>
</programlisting>

<para>returns the number of seconds
since 00:00:00.000000 on 1 January 1970, in the format:
<emphasis role="italic">dddddddddddd</emphasis> (no leading zeros or blanks).
Times prior to 1 January 1970 are returned as a negative value.
</para>
</section>

<section id="mthDateTimeDate"<title>date</title>
<indexterm><primary>date method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>date method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-date---------------------------------------------------><
]]>
</programlisting>

<para>Returns a new DateTime object instance for the current date, with
the time component set to 00:00:00.000000.
</para>
</section>

<section id="mthDateTimeTimeOfDay"<title>timeOfDay</title>
<indexterm><primary>timeOfDay method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>timeOfDay method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-timeOfDay-----------------------------------------------><
]]>
</programlisting>

<para>Returns the interval since 00:00:00.000000 of the current day
as a TimeSpan object.
</para>
</section>

<section id="mthDateTimeElapsed"<title>elapsed</title>
<indexterm><primary>elapsed method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>elapsed method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-elapsed-------------------------------------------------><
]]>
</programlisting>

<para>Returns the difference between current time and the receiver DateTime
as a TimeSpan object.  The TimeSpan will be negative if the receiver DateTime
represents a time in the future.
</para>
</section>

<section id="mthDateTimeIsLeapyear"<title>isLeapyear</title>
<indexterm><primary>isLeapyear method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isLeapyear method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isLeapyear---------------------------------------------><
]]>
</programlisting>

<para>Returns true ("1") if the current year is leap year.  Returns false
("0") if the current year is not a leap year.
</para>
</section>

<section id="mthDateTimeDaysInMonth"<title>daysInMonth</title>
<indexterm><primary>daysInMonth method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>daysInMonth method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-daysInMonth--------------------------------------------><
]]>
</programlisting>

<para>Returns the number of days in the current month.  For example, for dates in
January, 31 is returned.  The daysInMonth method takes leap years into account, returning
28 days for February in non-leap years, and 29 days for leap years.
</para>
</section>

<section id="mthDateTimeDaysInYear"<title>daysInYear</title>
<indexterm><primary>daysInYear method</primary>
<secondary>of DateTime class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>daysInYear method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-daysInYear---------------------------------------------><
]]>
</programlisting>

<para>Returns the number of days in the current year.  For leap years, 366 is returned.
For non-leap years, this returns 365.
</para>
</section>

<section id="mthDateTimeString"<title>string</title>
<indexterm><primary>string method</primary>
<secondary>of daysInMonth class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>string method</secondary>
<tertiary>of DateTime class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-string-------------------------------------------------><
]]>
</programlisting>

<para>Returns DateTime formatted as a string.  The string value is returned in ISO format.
</para>
</section>

</section>

<section id="clsAlarm"><title>The Alarm Class</title>
<indexterm><primary>Alarm class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Alarm class</secondary></indexterm>

<para>An alarm object provides timing and
notification capability by supplying a facility to send any message to any
object at a given time. You can cancel an alarm before it sends its message.
</para>
<figure><title>The Alarm class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxAlarmClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Alarm class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;

</section>

<section id="mthAlarmCancel"><title>cancel</title>
<indexterm><primary>cancel method</primary>
<secondary>of Alarm class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>cancel method</secondary>
<tertiary>of Alarm class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-cancel------------------------------------------------------><
]]>
</programlisting>

<para>Cancels the pending alarm request represented by the receiver. This method
takes no action if the specified time has already been reached.</para>
</section>

<section id="mthAlarmInit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of Alarm class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of Alarm class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-init(atime,message)-----------------------------------------><
]]>
</programlisting>

<para>Sets up an alarm for a future time
<emphasis role="italic">atime</emphasis>. At this time, the alarm
object sends the message that <emphasis role="italic">message</emphasis>,
a message object, specifies. (See <link linkend="clsMessage">The Message Class</link>.)
The <emphasis role="italic">atime</emphasis> can a String, DateTime object, or TimeSpan object.
</para>
<para>If <emphasis role="italic">atime</emphasis> is a DateTime object, the DateTime specifies a
time when the alarm will be triggered.  The DateTime must be greater than the current time.</para>
<para>If <emphasis role="italic">atime</emphasis> is a TimeSpan, the Alarm will be set to the current
time plus the TimeSpan.  The TimeSpan must not be a negative interval.</para>
<para>If <emphasis role="italic">atime</emphasis> is a String,
you can specify
this as a date and time (<computeroutput>&apos;hh:mm:ss&apos;</computeroutput>) or as
a number of seconds
starting at the present time. If you use the date and time format, you can specify
a date in the default format (<computeroutput>&apos;dd Mmm yyyy&apos;</computeroutput>)
after the time with a single blank separating the time and date. Leading and
trailing blanks are not allowed in the
<emphasis role="italic">atime</emphasis>. If you do not
specify a date, the language processor uses the first future occurrence of the
specified time. You can use the <emphasis role="bold">cancel</emphasis>
method to cancel a pending alarm. See
<link linkend="creo">Initialization</link> for more information.</para>
</section>

<section id="alaex"><title>Examples</title>
<indexterm><primary>examples</primary>
<secondary>of Alarm class</secondary></indexterm>
<para>The following code sets up an alarm at 5:10 p.m. on December 15, 2007.
(Assume today's date/time is prior to December 15, 2007.)  </para>
<programlisting>
/* Alarm Examples */

PersonalMessage=.MyMessageClass~new("Call the Bank")
msg=.message~new(PersonalMessage,"RemindMe")

time = .DateTime~fromIsoDate("2007-12-15T17:10:00.000000")

a=.alarm~new(time, msg)
exit
/* <link linkend="clasdi">::Class</link>  describes the ::CLASS directive */
/* <link linkend="methd">::Method</link>  describes the ::METHOD directive */
::class MyMessageClass public
::method init
expose inmsg
use arg inmsg
::method RemindMe
expose inmsg
say "It is now" "TIME"("C")".Please "inmsg
/* On the specified data and time, displays the following message: */
/* "It is now 5:10pm. Please Call the Bank" */
</programlisting>
<para>For the following example, the user uses the same code as in the
preceding example to define <computeroutput>msg</computeroutput>,
a message object to run at the specified time. The following code sets up
an alarm to run the <computeroutput>msg</computeroutput> message
object in 30 seconds from the current time: </para>
<programlisting>
a=.alarm~new(30,msg)
</programlisting>
</section>
</section>

<section id="clsTimeSpan"><title>The TimeSpan Class</title>
<indexterm><primary>TimeSpan class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>TimeSpan class</secondary></indexterm>

<para>A TimeSpan object represents a point in between 1 January 0001 at 00:00.000000
and 31 December 9999 at 23:59:59.999999.  A TimeSpan object has methods to allow
formatting a date or time in various formats, as well as allowing arithmetic operations between
dates.
</para>
<figure><title>The TimeSpan class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxTimeSpanClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The TimeSpan class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;

<para>Methods inherited from the
<link linkend="clsComparable">Comparable class</link>.</para>
<itemizedlist>
<listitem><para><link linkend="mthComparableCompareTo">compareTo</link></para></listitem>
</itemizedlist>
</section>

<section id="mthTimeSpanFromDays"><title>fromDays (Class Method)</title>
<indexterm><primary>fromDays method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromDays method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromDays(days)--------------------------------------------><
]]>
</programlisting>

<para>Creates a TimeSpan object from a number of days.
The <emphasis role="italic">days</emphasis> argument must be a valid Rexx number.
</para>
</section>

<section id="mthTimeSpanFromHours"><title>fromHours (Class Method)</title>
<indexterm><primary>fromHours method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromHours method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromHours(hours)------------------------------------------><
]]>
</programlisting>

<para>Creates a TimeSpan object from a number of hours.
The <emphasis role="italic">hours</emphasis> argument must be a valid Rexx number.
</para>
</section>

<section id="mthTimeSpanFromMinutes"><title>fromMinutes (Class Method)</title>
<indexterm><primary>fromMinutes method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromMinutes method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromMinutes(minutes)--------------------------------------><
]]>
</programlisting>

<para>Creates a TimeSpan object from a number of minutes.
The <emphasis role="italic">minutes</emphasis> argument must be a valid Rexx number.
</para>
</section>

<section id="mthTimeSpanFromSeconds"><title>fromSeconds (Class Method)</title>
<indexterm><primary>fromSeconds method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromSeconds method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromSeconds(seconds)--------------------------------------><
]]>
</programlisting>

<para>Creates a TimeSpan object from a number of seconds.
The <emphasis role="italic">seconds</emphasis> argument must be a valid Rexx number.
</para>
</section>

<section id="mthTimeSpanFromMicroseconds"><title>fromMicroseconds (Class Method)</title>
<indexterm><primary>fromMicroseconds method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromMicroseconds method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromMicroseconds(microseconds)---------------------------------><
]]>
</programlisting>

<para>Creates a TimeSpan object from a number of microseconds.
The <emphasis role="italic">microseconds</emphasis> argument must be a valid Rexx number.
</para>
</section>

<section id="mthTimeSpanFromNormalTime"><title>fromNormalTime (Class Method)</title>
<indexterm><primary>fromNormalTime method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromNormalTime method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromNormalTime(time)----------------------------------------------><
]]>
</programlisting>

<para>Creates a TimeSpan object from a string returned by the Normal option
of the <link linkend="bifTime">Time()</link> built-in function.
The TimeSpan will contain an interval equal to the time of day represented by the string.
</para>
</section>

<section id="mthTimeSpanFromCivilTime"><title>fromCivilTime (Class Method)</title>
<indexterm><primary>fromCivilTime method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromCivilTime method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromCivilTime(time)----------------------------------------><
]]>
</programlisting>

<para>Creates a TimeSpan object from a string returned by the Civil option
of the <link linkend="bifTime">Time()</link> built-in function.
The TimeSpan will contain an interval equal to the time of day represented by the string.
</para>
</section>

<section id="mthTimeSpanFromLongTime"><title>fromLongTime (Class Method)</title>
<indexterm><primary>fromLongTime method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromLongTime method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromLongTime(time)----------------------------------------><
]]>
</programlisting>

<para>Creates a TimeSpan object from a string returned by the Long option
of the <link linkend="bifTime">Time()</link> built-in function.
The TimeSpan will contain an interval equal to the time of day represented by the string.
</para>
</section>

<section id="mthTimeSpanFromStringFormat"><title>fromStringFormat (Class Method)</title>
<indexterm><primary>fromStringFormat method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>fromStringFormat method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-fromStringFormat(time)------------------------------------><
]]>
</programlisting>

<para>Creates a TimeSpan object from a string in the format returned by the TimeSpan string method.
</para>
</section>

<section id="mthTimeSpanInit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-init(fullDate)---------------------------------------------><

>>-init(hours, minutes, seconds)------------------------------><

>>-init(day, hours, minutes, second, microseconds)------------><
]]>
</programlisting>

<para>Initializes a new TimeSpan instance.
If the single
<emphasis role="italic">fullDate</emphasis> argument is used, the TimeSpan
argument is initialized to the time span
<emphasis role="italic">fullDate</emphasis> microseconds.
Otherwise, the TimeSpan instance is initialized to either the <emphasis role="italic">hours</emphasis>,
<emphasis role="italic">minutes</emphasis>, and <emphasis role="italic">seconds</emphasis> or the
<emphasis role="italic">days</emphasis>, <emphasis role="italic">hours</emphasis>,
<emphasis role="italic">minutes</emphasis>,
<emphasis role="italic">seconds</emphasis>, and <emphasis role="italic">microseconds</emphasis>
components.  Each of these components must be a valid whole number within the acceptable range for the given
component.  For example, <emphasis role="italic">hours</emphasis> must be in the range 0-23, while
<emphasis role="italic">minutes</emphasis> must be in the range 0-59.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
<![CDATA[
                         -- initializes to 15 hours, 37 minutes and 30 seconds
                         -- (15:37:30.000000)
span = .TimeSpan~new(time('F', "15:37:30", "N))
                         -- also initializes to 15:37:30.000000
span = .TimeSpan~new(15, 37, 30)
                         -- initializes to 6.04:33:15.000100
span = .TimeSpan~new(6, 4, 33, 15, 100)
]]>
</programlisting>
</section>

<section id="mthTimeSpanComparisonMethods"><title>Comparison Methods</title>
<indexterm><primary>method</primary>
<secondary>comparison methods</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-comparison_operator(argument)-------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) or
<computeroutput>0</computeroutput> (false), the result of performing
the specified comparison operation. The receiver object and the
<emphasis role="italic">argument</emphasis> are the terms compared. Both must
be TimeSpan objects.
If <emphasis role="italic">argument</emphasis> is not a TimeSpan object, a SYNTAX
error condition is raised.
</para>

<para>The comparison operators you can use in a message are: </para>
<variablelist>
<varlistentry><term>=
<indexterm><primary>= method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>=</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are equal
</para></listitem></varlistentry>
<varlistentry><term>\=, &gt;&lt;, &lt;&gt;
<indexterm><primary>>&lt; method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>&gt;&lt; method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>&lt;&gt; method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>\=</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>>&lt;</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;&gt;</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are not equal (inverse of =)
</para></listitem></varlistentry>
<varlistentry><term>&gt;
<indexterm><primary>&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>></secondary></indexterm>
</term>
<listitem><para>Greater than
</para></listitem></varlistentry>
<varlistentry><term>&lt;
<indexterm><primary>&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;</secondary></indexterm>
</term>
<listitem><para>Less than
</para></listitem></varlistentry>
<varlistentry><term>&gt;=
<indexterm><primary>&gt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&gt;=</secondary></indexterm>
</term>
<listitem><para>Greater than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&lt;
<indexterm><primary>\&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&lt;</secondary></indexterm>
</term>
<listitem><para>Not less than
</para></listitem></varlistentry>
<varlistentry><term>&lt;=
<indexterm><primary>&lt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;=</secondary></indexterm>
</term>
<listitem><para>Less than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&gt;
<indexterm><primary>\&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&gt;</secondary></indexterm>
</term>
<listitem><para>Not greater than
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>comparison methods of TimeSpan class</secondary></indexterm>
<programlisting>
<![CDATA[


                                   -- get the current time
currentTime = .DateTime~new~timeOfDay
startTime = .timespan~new(10)
endTime = startTime~addHours(7)    -- bank closing time

if startTime <= currentTime & currentTime <= endTime then do
    say "The bank is open"
end
]]>
</programlisting>
<para>All strict comparison operations have one of the characters doubled that
define the operator. The TimeSpan strict comparison operators produce the same
results as the non-strict comparisons.
</para>
<para>The strict comparison operators you can use in a message are: </para>
<variablelist>
<varlistentry><term>==
<indexterm><primary>== method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>==</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
</term>
<listitem><para>True if terms are strictly equal
</para></listitem></varlistentry>
<varlistentry><term>\==
<indexterm><primary>\== method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\==</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are NOT strictly equal (inverse of ==)
</para></listitem></varlistentry>
<varlistentry><term>&gt;&gt;
<indexterm><primary>&gt;&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>>></secondary></indexterm>
</term>
<listitem><para>Strictly greater than
</para></listitem></varlistentry>
<varlistentry><term>&lt;&lt;
<indexterm><primary>&lt;&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;&lt;</secondary></indexterm>
</term>
<listitem><para>Strictly less than
</para></listitem></varlistentry>
<varlistentry><term>&gt;&gt;=
<indexterm><primary>&gt;&gt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&gt;&gt;=</secondary></indexterm>
</term>
<listitem><para>Strictly greater than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&lt;&lt;
<indexterm><primary>\&lt;&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&lt;&lt;</secondary></indexterm>
</term>
<listitem><para>Strictly NOT less than
</para></listitem></varlistentry>
<varlistentry><term>&lt;&lt;=
<indexterm><primary>&lt;&lt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;&lt;=</secondary></indexterm>
</term>
<listitem><para>Strictly less than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&gt;&gt;
<indexterm><primary>\&gt;&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&gt;&gt;</secondary></indexterm>
</term>
<listitem><para>Strictly NOT greater than
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthTimeSpanArithmeticMethods"><title>Arithmetic Methods</title>
<indexterm><primary>method</primary>
<secondary>arithmetic methods</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-arithmetic_operator(argument)-------------------------------><
]]>
</programlisting>

<note><title>Note</title>
<para>For the prefix + operators, omit the parentheses
and <emphasis role="italic">argument</emphasis>.</para></note>
<para>Returns the result of performing the specified arithmetic operation on
the receiver TimeSpan object. Depending on the operation, the
<emphasis role="italic">argument</emphasis> be either a TimeSpan object, a DateTime
object, or a number.  See the description of the individual operations for details.
The
<emphasis role="italic">arithmetic_operator</emphasis> can be:
</para>
<variablelist>
<varlistentry><term>+
<indexterm><primary>+ method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>+</secondary></indexterm>
</term>
<listitem><para>Addition.
If <emphasis role="italic">argument</emphasis> is a DateTime object, the TimeSpan
is added to the DateTime object, returning a new DateTime
instance.
Neither the receiver TimeSpan or the argument DateTime object is altered
by this operation.
The TimeSpan may be either positive or negative.</para>
<para>If <emphasis role="italic">argument</emphasis> is a TimeSpan object, the
two TimeSpans are added together, and a new TimeSpan instance is returned.
Neither the TimeSpan object is altered
by this operation.
</para></listitem></varlistentry>
<varlistentry><term>-
<indexterm><primary>- method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>-</secondary></indexterm>
</term>
<listitem><para>Subtraction.
The <emphasis role="italic">argument</emphasis> must be a TimeSpan object.  The
<emphasis role="italic">argument</emphasis> TimeSpan is subtracted from the receiver
TimeSpan and a new TimeSpan instance is returned.
Neither the TimeSpan object is altered
by this operation.
</para></listitem></varlistentry>
<varlistentry><term>*
<indexterm><primary>* method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>*</secondary></indexterm>
</term>
<listitem><para>Multiplication.
The <emphasis role="italic">argument</emphasis> must be a valid Rexx number.  The
TimeSpan is multiplied by the
<emphasis role="italic">argument</emphasis> value,
and a new TimeSpan instance is returned.
The receiver TimeSpan object is not altered
by this operation.
</para></listitem></varlistentry>
<varlistentry><term>/
<indexterm><primary>/ method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>/</secondary></indexterm>
</term>
<listitem><para>Division.
The <emphasis role="italic">argument</emphasis> must be a valid Rexx number.  The
TimeSpan is divided by the
<emphasis role="italic">argument</emphasis> value,
and a new TimeSpan instance is returned.
The receiver TimeSpan object is not altered
by this operation.  The / operator and % produce the same result.
</para></listitem></varlistentry>
<varlistentry><term>%
<indexterm><primary>% method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>%</secondary></indexterm>
</term>
<listitem><para>Integer Division.
The <emphasis role="italic">argument</emphasis> must be a valid Rexx number.  The
TimeSpan is divided by the
<emphasis role="italic">argument</emphasis> value,
and a new TimeSpan instance is returned.
The receiver TimeSpan object is not altered
by this operation.  The / operator and % produce the same result.
</para></listitem></varlistentry>
<varlistentry><term>//
<indexterm><primary>// method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>//</secondary></indexterm>
</term>
<listitem><para>Remainder Division.
The <emphasis role="italic">argument</emphasis> must be a valid Rexx number.  The
TimeSpan is divided by the
<emphasis role="italic">argument</emphasis> value and the division remainder is
returned as a new TimeSpan instance.
The receiver TimeSpan object is not altered
by this operation.
</para></listitem></varlistentry>
<varlistentry><term>Prefix -
<indexterm><primary>method</primary>
<secondary>prefix -</secondary></indexterm>
</term>
<listitem><para>The TimeSpan is negated, returning a new TimeSpan instance.  The receiver TimeSpan
is not altered by this operation.
</para></listitem></varlistentry>
<varlistentry><term>Prefix +
<indexterm><primary>method</primary>
<secondary>prefix +</secondary></indexterm>
</term>
<listitem><para>Returns a new instance of the TimeSpan object with the same time value.
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>arithmetic methods of DateTime class</secondary></indexterm>
<programlisting>
<![CDATA[
t1 = .timespan~fromHours(1)
t2 = t1 * 2
-- displays "01:00:00.000000 01:30:00.000000 02:30:00.000000"
say t1 t2 (t1 + t2)
]]>
</programlisting>
</section>

<section id="mthTimeSpanCompareTo"><title>compareTo</title>
<indexterm><primary>compareTo method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>compareTo method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-compareTo(other)------------------------------------------------><
]]>
</programlisting>

<para>This method returns "-1" if the <emphasis role="italic">other</emphasis> is larger than the receiving
object, "0" if the two objects are equal, and "1" if <emphasis role="italic">other</emphasis> is
smaller than the receiving object.</para>
</section>

<section id="mthTimeSpanDuration"><title>duration</title>
<indexterm><primary>duration method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>duration method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-duration--------------------------------------------------------><
]]>
</programlisting>

<para>Returns a new TimeSpan object containing the absolute value of the receiver TimeSpan object.
</para>
</section>

<section id="mthTimeSpanDays"><title>days</title>
<indexterm><primary>days method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>days method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-days------------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of whole days in the TimeSpan, as a positive number.
</para>
</section>

<section id="mthTimeSpanHours"<title>hours</title>
<indexterm><primary>hours method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hours method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hours-----------------------------------------------------------><
]]>
</programlisting>

<para>Returns the hours component of the TimeSpan, as a positive number.
</para>
</section>

<section id="mthTimeSpanMinutes"<title>minutes</title>
<indexterm><primary>minutes method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>minutes method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-minutes---------------------------------------------------------><
]]>
</programlisting>

<para>Returns the minutes component of the TimeSpan, as a positive number.
</para>
</section>

<section id="mthTimeSpanSeconds"<title>seconds</title>
<indexterm><primary>seconds method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>seconds method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-seconds---------------------------------------------------------><
]]>
</programlisting>

<para>Returns the seconds component of the TimeSpan, as a positive number.
</para>
</section>

<section id="mthTimeSpanMicroseconds"<title>microseconds</title>
<indexterm><primary>microseconds method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>microseconds method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-microseconds--------------------------------------------------><
]]>
</programlisting>

<para>Returns the microseconds component of the TimeSpan, as a positive number.
</para>
</section>

<section id="mthTimeSpanTotalDays"><title>totalDays</title>
<indexterm><primary>totalDays method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>totalDays method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-totalDays-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the time span expressed as a number of days.  The result includes any
fractional part and retains the sign of the receiver TimeSpan.
</para>
</section>

<section id="mthTimeSpanTotalHours"><title>totalHours</title>
<indexterm><primary>totalHours method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>totalHours method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-totalHours------------------------------------------------------><
]]>
</programlisting>

<para>Returns the time span expressed as a number of hours.  The result includes any
fractional part and retains the sign of the receiver TimeSpan.
</para>
</section>

<section id="mthTimeSpanTotalMinutes"><title>totalMinutes</title>
<indexterm><primary>totalMinutes method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>totalMinutes method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-totalMinutes----------------------------------------------------><
]]>
</programlisting>

<para>Returns the time span expressed as a number of minutes.  The result includes any
fractional part and retains the sign of the receiver TimeSpan.
</para>
</section>

<section id="mthTimeSpanTotalSeconds"><title>totalSeconds</title>
<indexterm><primary>totalSeconds method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>totalSeconds method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-totalSeconds----------------------------------------------------><
]]>
</programlisting>

<para>Returns the time span expressed as a number of seconds.  The result includes any
fractional part and retains the sign of the receiver TimeSpan.
</para>
</section>

<section id="mthTimeSpanTotalMicroseconds"><title>totalMicroseconds</title>
<indexterm><primary>totalMicroseconds method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>totalMicroseconds method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-totalMicroseconds-----------------------------------------------><
]]>
</programlisting>

<para>Returns the time span expressed as a number of microseconds.  The result
retains the sign of the receiver TimeSpan.
</para>
</section>

<section id="mthTimeSpanHashCode"><title>hashCode</title>
<indexterm><primary>hashCode method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hashCode method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hashCode---------------------------------------------------><
]]>
</programlisting>

<para>Returns a string value that is used as a hash value for MapCollection
such as Table, Relation, Set, Bag, and Directory.
</para>
</section>

<section id="mthTimeSpanAddWeeks"<title>addWeeks</title>
<indexterm><primary>addWeeks method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addWeeks method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addWeeks(weeks)------------------------------------------><
]]>
</programlisting>

<para>Adds weeks to the TimeSpan object, returning a new TimeSpan instance.
The receiver TimeSpan object is unchanged.
The <emphasis role="italic">weeks</emphasis> value must be a valid number, including
fractional values.
Negative values
result in week being subtracted from the TimeSpan value.
</para>
</section>

<section id="mthTimeSpanAddDays"<title>addDays</title>
<indexterm><primary>addDays method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addDays method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addDays(days)--------------------------------------------><
]]>
</programlisting>

<para>Adds days to the TimeSpan object, returning a new TimeSpan instance.
The receiver TimeSpan object is unchanged.
The <emphasis role="italic">days</emphasis> value must be a valid number, including
fractional values.
Negative values
result in days being subtracted from the TimeSpan value.
</para>
</section>

<section id="mthTimeSpanAddHours"<title>addHours</title>
<indexterm><primary>addHours method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addHours method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addHours(hours)------------------------------------------><
]]>
</programlisting>

<para>Adds hours to the TimeSpan object, returning a new TimeSpan instance.
The receiver TimeSpan object is unchanged.
The <emphasis role="italic">hours</emphasis> value must be a valid number, including
fractional values.
Negative values
result in hours being subtracted from the TimeSpan value.
</para>
</section>

<section id="mthTimeSpanAddMinutes"<title>addMinutes</title>
<indexterm><primary>addMinutes method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addMinutes method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addMinutes(minutes)--------------------------------------><
]]>
</programlisting>

<para>Adds minutes to the TimeSpan object, returning a new TimeSpan instance.
The receiver TimeSpan object is unchanged.
The <emphasis role="italic">minutes</emphasis> value must be a valid number, including
fractional values.
Negative values
result in minutes being subtracted from the TimeSpan value.
</para>
</section>

<section id="mthTimeSpanAddSeconds"<title>addSeconds</title>
<indexterm><primary>addSeconds method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addSeconds method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addSeconds(seconds)--------------------------------------><
]]>
</programlisting>

<para>Adds seconds to the TimeSpan object, returning a new TimeSpan instance.
The receiver TimeSpan object is unchanged.
The <emphasis role="italic">seconds</emphasis> value must be a valid number, including
fractional values.
Negative values
result in seconds being subtracted from the TimeSpan value.
</para>
</section>

<section id="mthTimeSpanAddMicroseconds"<title>addMicroseconds</title>
<indexterm><primary>addMicroseconds method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addMicroseconds method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addMicroseconds(microseconds)----------------------------><
]]>
</programlisting>

<para>Adds microseconds to the TimeSpan object, returning a new TimeSpan instance.
The receiver TimeSpan object is unchanged.
The <emphasis role="italic">microseconds</emphasis> value must be a valid whole number.
Negative values
result in microseconds being subtracted from the TimeSpan value.
</para>
</section>

<section id="mthTimeSpanSign"<title>sign</title>
<indexterm><primary>sign method</primary>
<secondary>of TimeSpan class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sign method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sign-----------------------------------------------------><
]]>
</programlisting>

<para>Returns "-1" if the TimeSpan is negative, "1" if the TimeSpan is positive, and "0" if the
TimeSpan duration is zero.
</para>
</section>

<section id="mthTimeSpanString"<title>string</title>
<indexterm><primary>string method</primary>
<secondary>of daysInMonth class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>string method</secondary>
<tertiary>of TimeSpan class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-string-------------------------------------------------><
]]>
</programlisting>

<para>Returns TimeSpan formatted as a string.  The string value is in the format
"-dddddddd.hh:mm:ss.uuuuuu".  If the TimeSpan is positive or zero, the sign is omitted.
The days field will be formatted without leading zeros or blanks.  If the TimeSpan duration
is less than a day, the days field and the period separator will be omitted.
</para>
</section>

</section>

<section id="clsComparable"><title>The Comparable Class</title>
<indexterm><primary>Comparable class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Comparable class</secondary></indexterm>

<para>This class is defined as a mixin class.</para>

<figure><title>The Comparable class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxComparableClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Comparable class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;

</section>

<section id="mthComparableCompareTo"><title>compareTo</title>
<indexterm><primary>compareTo method</primary>
<secondary>of Comparable class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>compareTo method</secondary>
<tertiary>of Comparable class</tertiary></indexterm>

<para>This method compares the receiving object to the object supplied in the
<emphasis role="itakic">comparable</emphasis> argument.</para>
<programlisting>
<![CDATA[
>>-compareTo(other)---------------------------------------><
]]>
</programlisting>
<para>This method returns "-1" if the <emphasis role="italic">other</emphasis> is larger than the receiving
object, "0" if the two objects are equal, and "1" if <emphasis role="italic">other</emphasis> is
smaller than the receiving object.</para>
</section>
</section>

<section id="clsComparator"><title>The Comparator Class</title>
<indexterm><primary>Comparator class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Comparator class</secondary></indexterm>
<figure><title>The Comparator class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxComparatorClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Comparator class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<para>This class is defined as a mixin class.</para>

<section><title>Inherited Methods</title>

&objclsmthods;

</section>

<section id="mthComparatorCompare"><title>compare</title>
<indexterm><primary>compare method</primary>
<secondary>of Comparator class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>compare method</secondary>
<tertiary>of Comparator class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-compare(first,second)--------------------------------><
]]>
</programlisting>
<para>This method returns "-1" if the <emphasis role="italic">second</emphasis> is larger than
<emphasis role="italic">first</emphasis>
object, "0" if the two objects are equal, and "1" <emphasis role="italic">second</emphasis> is
smaller than <emphasis role="italic">first</emphasis> .</para>
<para>This method is defined as an abstract method.  Inheriting classes are expected to define
an implementation specific to the comparison being performed.
</para>
</section>
</section>

<section id="clsCaselessColumnComparator"><title>The CaselessColumnComparator Class</title>
<indexterm><primary>CaselessColumnComparator class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>CaselessColumnComparator class</secondary></indexterm>

<figure><title>The CaselessColumnComparator class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxCaselessColumnComparatorClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The CaselessColumnComparator class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<para>This class is defined as a mixin class.</para>

<section><title>Inherited Methods</title>

&objclsmthods;

<para>Methods inherited from the
<link linkend="clsComparator">Comparator class</link>.</para>
<simplelist type="vert" columns="3">
<member><link linkend="mthComparatorCompare">compare</link></member>
</simplelist>

</section>

<section id="mthCaselessColumnComparatorCompare"><title>compare</title>
<indexterm><primary>compare method</primary>
<secondary>of CaselessColumnComparator class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>compare method</secondary>
<tertiary>of CaselessColumnComparator class</tertiary></indexterm>
<para>This method overrides the
<link linkend="mthComparatorCompare">compare method</link> from the
<link linkend="clsComparator">Comparator class</link>.</para>

<programlisting>
<![CDATA[
>>-compare(first,second)--------------------------------><
]]>
</programlisting>
<para>This method returns "-1" if the <emphasis role="italic">second</emphasis> is larger than
<emphasis role="italic">first</emphasis>
object, "0" if the two objects are equal, and "1" <emphasis role="italic">second</emphasis> is
smaller than <emphasis role="italic">first</emphasis>.  Only the defined columns of the strings are compared,
using a caseless comparison.</para>
</section>

<section id="mthCaselessColumnComparatorInit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of CaselessColumnComparator class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of CaselessColumnComparator class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-init(start, length)----------------------------------><
]]>
</programlisting>
<para>Initializes a comparator to sort strings starting at position <emphasis role="italic">start</emphasis> for
<emphasis role="italic">length</emphasis> characters.
</para>
</section>
</section>

<section id="clsCaselessComparator"><title>The CaselessComparator Class</title>
<indexterm><primary>CaselessComparator class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>CaselessComparator class</secondary></indexterm>

<figure><title>The CaselessComparator class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxCaselessComparatorClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The CaselessComparator class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<para>This class is defined as a mixin class.</para>

<section><title>Inherited Methods</title>

&objclsmthods;

<para>Methods inherited from the
<link linkend="clsComparator">Comparator class</link>.</para>
<simplelist type="vert" columns="3">
<member><link linkend="mthComparatorCompare">compare</link></member>
</simplelist>

</section>

<section id="mthCaselessComparatorCompare"><title>compare</title>
<indexterm><primary>compare method</primary>
<secondary>of CaselessComparator class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>compare method</secondary>
<tertiary>of CaselessComparator class</tertiary></indexterm>
<para>This method overrides the
<link linkend="mthComparatorCompare">compare method</link> from the
<link linkend="clsComparator">Comparator class</link>.</para>

<programlisting>
<![CDATA[
>>-compare(first,second)--------------------------------><
]]>
</programlisting>
<para>This method returns "-1" if the <emphasis role="italic">second</emphasis> is larger than
<emphasis role="italic">first</emphasis>
object, "0" if the two objects are equal, and "1" <emphasis role="italic">second</emphasis> is
smaller than <emphasis role="italic">first</emphasis>.  The two strings are compared using a caseless comparison.
</para>
</section>
</section>

<section id="clsColumnComparator"><title>The ColumnComparator Class</title>
<indexterm><primary>ColumnComparator class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>ColumnComparator class</secondary></indexterm>

<figure><title>The ColumnComparator class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxColumnComparatorClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The ColumnComparator class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<para>This class is defined as a mixin class.</para>

<section><title>Inherited Methods</title>

&objclsmthods;

<para>Methods inherited from the
<link linkend="clsComparator">Comparator class</link>.</para>
<simplelist type="vert" columns="3">
<member><link linkend="mthComparatorCompare">compare</link></member>
</simplelist>

</section>

<section id="mthColumnComparatorCompare"><title>compare</title>
<indexterm><primary>compare method</primary>
<secondary>of ColumnComparator class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>compare method</secondary>
<tertiary>of ColumnComparator class</tertiary></indexterm>
<para>This method overrides the
<link linkend="mthComparatorCompare">compare method</link> from the
<link linkend="clsComparator">Comparator class</link>.</para>

<programlisting>
<![CDATA[
>>-compare(first,second)--------------------------------><
]]>
</programlisting>
<para>This method returns "-1" if the <emphasis role="italic">second</emphasis> is larger than
<emphasis role="italic">first</emphasis>
object, "0" if the two objects are equal, and "1" <emphasis role="italic">second</emphasis> is
smaller than <emphasis role="italic">first</emphasis>.  Only the defined columns of the strings are compared.
</para>
</section>

<section id="mthColumnComparatorInit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of ColumnComparator class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of ColumnComparator class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-init(start, length)----------------------------------><
]]>
</programlisting>
<para>Initializes a comparator to sort strings starting at position <emphasis role="italic">start</emphasis> for
<emphasis role="italic">length</emphasis> characters.
</para>
</section>
</section>

<section id="clsCaselessDescendingComparator"><title>The CaselessDescendingComparator Class</title>
<indexterm><primary>CaselessDescendingComparator class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>CaselessDescendingComparator class</secondary></indexterm>
<figure><title>The CaselessDescendingComparator class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxCaselessDescendingComparatorClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The CaselessDescendingComparator class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<para>This class is defined as a mixin class.</para>

<section><title>Inherited Methods</title>

&objclsmthods;

<para>Methods inherited from the
<link linkend="clsComparator">Comparator class</link>.</para>
<simplelist type="vert" columns="3">
<member><link linkend="mthComparatorCompare">compare</link></member>
</simplelist>

</section>

<section id="mthCaselessDescendingComparatorCompare"><title>compare</title>
<indexterm><primary>compare method</primary>
<secondary>of CaselessDescendingComparator class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>compare method</secondary>
<tertiary>of CaselessDescendingComparator class</tertiary></indexterm>
<para>This method overrides the
<link linkend="mthComparatorCompare">compare method</link> from the
<link linkend="clsComparator">Comparator class</link>.</para>

<programlisting>
<![CDATA[
>>-compare(first,second)--------------------------------><
]]>
</programlisting>
<para>This method returns "1" if the <emphasis role="italic">second</emphasis> is larger than
<emphasis role="italic">first</emphasis>
object, "0" if the two objects are equal, and "-1" <emphasis role="italic">second</emphasis> is
smaller than <emphasis role="italic">first</emphasis>.  The two strings are compared using a caseless comparison.
</para>
</section>
</section>

<section id="clsDescendingComparator"><title>The DescendingComparator Class</title>
<indexterm><primary>DescendingComparator class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>DescendingComparator class</secondary></indexterm>

<para>This class is defined as a mixin class. It must be used
by inheriting from it as a mixin.</para>
<figure><title>The DescendingComparator class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxDescendingComparatorClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The DescendingComparator class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<para>This class is defined as a mixin class.</para>

<section><title>Inherited Methods</title>

&objclsmthods;

<para>Methods inherited from the
<link linkend="clsComparator">Comparator class</link>.</para>
<simplelist type="vert" columns="3">
<member><link linkend="mthComparatorCompare">compare</link></member>
</simplelist>

</section>

<section id="mthDescendingComparatorCompare"><title>compare</title>
<indexterm><primary>compare method</primary>
<secondary>of DescendingComparator class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>compare method</secondary>
<tertiary>of DescendingComparator class</tertiary></indexterm>
<para>This method overrides the
<link linkend="mthComparatorCompare">compare method</link> from the
<link linkend="clsComparator">Comparator class</link>.</para>

<programlisting>
<![CDATA[
>>-compare(first,second)--------------------------------><
]]>
</programlisting>
<para>This method returns "1" if the <emphasis role="italic">second</emphasis> is larger than
<emphasis role="italic">first</emphasis>
object, "0" if the two objects are equal, and "-1" <emphasis role="italic">second</emphasis> is
smaller than <emphasis role="italic">first</emphasis>, resulting in a descending sort sequence.
</para>
</section>
</section>

<section id="clsInvertingComparator"><title>The InvertingComparator Class</title>
<indexterm><primary>InvertingComparator class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>InvertingComparator class</secondary></indexterm>

<para>This class is defined as a mixin class. It must be used
by inheriting from it as a mixin.</para>
<figure><title>The InvertingComparator class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxInvertingComparatorClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The InvertingComparator class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<para>This class is defined as a mixin class.</para>

<section><title>Inherited Methods</title>

&objclsmthods;

<para>Methods inherited from the
<link linkend="clsComparator">Comparator class</link>.</para>
<simplelist type="vert" columns="3">
<member><link linkend="mthComparatorCompare">compare</link></member>
</simplelist>

</section>

<section id="mthInvertingComparatorCompare"><title>compare</title>
<indexterm><primary>compare method</primary>
<secondary>of InvertingComparator class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>compare method</secondary>
<tertiary>of InvertingComparator class</tertiary></indexterm>
<para>This method overrides the
<link linkend="mthComparatorCompare">compare method</link> from the
<link linkend="clsComparator">Comparator class</link>.</para>

<programlisting>
<![CDATA[
>>-compare(first,second)--------------------------------><
]]>
</programlisting>
<para>This method returns "1" if the <emphasis role="italic">second</emphasis> is larger than
<emphasis role="italic">first</emphasis>
object, "0" if the two objects are equal, and "-1" <emphasis role="italic">second</emphasis> is
smaller than <emphasis role="italic">first</emphasis>, resulting in a descending sort sequence.
The InvertingComparator will invert the ordering returned by the provided Comparator.
</para>
</section>

<section id="mthInvertingComparatorInit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of InvertingComparator class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of InvertingComparator class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-init(comparator)----------------------------------><
]]>
</programlisting>
<para>Initializes an inverting comparator to sort strings using an inversion of the result from the
<emphasis role="italic">comparator</emphasis> <emphasis role="bold">compare</emphasis> method.
</para>
</section>
</section>

<section id="clsMonitor"><title>The Monitor Class</title>
<indexterm><primary>Monitor class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Monitor class</secondary></indexterm>

<para>The Monitor class forwards messages to a destination object. It is a
subclass of the Object class.</para>

<figure><title>The Monitor class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxMonitorClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Monitor class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;

</section>

<section id="mthMonitorCurrent"><title>current</title>
<indexterm><primary>current method</primary>
<secondary>of Monitor class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>current method</secondary>
<tertiary>of Monitor class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-current-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the current destination object.</para>
</section>

<section id="mthMonitorDestination"><title>destination</title>
<indexterm><primary>destination method</primary>
<secondary>of Monitor class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>destination method</secondary>
<tertiary>of Monitor class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-destination--+---------------+------------------------------><
                +-(destination)-+
]]>
</programlisting>

<para>Returns a new destination object. If you specify
<emphasis role="italic">destination</emphasis>,
this becomes the new destination for any forwarded messages. If you omit
<emphasis role="italic">destination</emphasis>, the previous destination
object becomes the new destination for any forwarded messages.</para>
</section>

<section id="mthMonitorInit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of Monitor class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of Monitor class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-init--+---------------+-------------------------------------><
         +-(destination)-+
]]>
</programlisting>

<para>Initializes the newly created monitor object.</para>
</section>

<section id="mthMonitorUnknown"><title>unknown</title>
<indexterm><primary>unknown method</primary>
<secondary>of Monitor class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>unknown method</secondary>
<tertiary>of Monitor class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-unknown(messagename,messageargs)----------------------------><
]]>
</programlisting>

<para>Reissues or forwards to the current monitor destination all unknown
messages sent to a monitor object. For additional information, see
<link linkend="unkno">Defining an unknown Method</link>.</para>
</section>

<section id="monex"><title>Examples</title>
<indexterm><primary>examples</primary>
<secondary>of Monitor class</secondary></indexterm>
<programlisting>
.local~setentry("output",.monitor~new(.stream~new("my.new")~~command("open nobuffer")))

/* The following sets the destination */
previous_destination=.output~destination(.stream~new("my.out")~~command("open write"))
/* The following resets the destination */
.output~destination

.output~destination(.Stdout)
current_output_destination_stream_object=.output~current
</programlisting>
</section>
</section>

<section id="clsMutableBuffer"><title>The MutableBuffer Class</title>
<indexterm><primary>MutableBuffer class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>MutableBuffer class</secondary></indexterm>

<para>The MutableBuffer class is a buffer that contains a string on which
certain string operations such as concatenation can be performed very
efficiently. (Frequent concatenation of long strings without using this
class might result in weak performance, large memory allocation, or both.)
</para>
<figure><title>The MutableBuffer class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxMutableBufferClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The MutableBuffer class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;

</section>

<section id="mthMutableBufferNew"><title>new</title>
<indexterm><primary>new method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
                   +-----,-256------+
>>-new(-+--------+-+----------------+-)--------------------><
        +-string-+ +-,-buffer size--+
]]>
</programlisting>

<para>This method overrides the
<link linkend="mthObjectNew">new method</link> from the
<link linkend="clsObject">Object class</link>.</para>
<para>Initialize the buffer, optionally assign a buffer content and
a starting <emphasis>buffer size</emphasis>. The default size is 256; the buffer
size increases to the length of the <emphasis>string</emphasis> if the string
does not fit into the buffer.</para>
</section>

<section id="mthMutableBufferAppend"><title>append</title>
<indexterm><primary>append method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>append method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-append(string)------------------------------------------><
]]>
</programlisting>

<para>Appends string to the buffer content. The buffer size
is increased if necessary.</para>
</section>


<section id="mthMutableBufferCaselessChangeStr"><title>caselessChangeStr</title>
<indexterm><primary>caselessChangeStr method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessChangeStr method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-caselessChangeStr(needle,newneedle--+--------+--)---------------------------------><
                                       +-,count-+
]]>
</programlisting>

<para>Returns the receiver object with
<emphasis role="italic">newneedle</emphasis> replacing occurrences of <emphasis
role="italic">needle</emphasis>. If <emphasis role="italic">count</emphasis> is
not specified, all occurrences of
<emphasis role="italic">needle</emphasis> are replaced.  If <emphasis role="italic">count</emphasis>
is specified, it must be a positive, whole number that gives the maximum number of
occurrences to be replaced.
The <emphasis role="italic">needle</emphasis> searches are performed
using caseless comparisons.
</para>
</section>

<section id="mthMutableBufferCaselessCountStr"><title>caselessCountStr</title>
<indexterm><primary>caselessCountStr method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessCountStr method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>caselessCountStr method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessCountStr method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-caselessCountStr(needle)--------------------------------------------><
]]>
</programlisting>

<para>Returns a count of the occurrences of
<emphasis role="italic">needle</emphasis> in the receiving mutable buffer that
do not overlap. All matches are made using caseless comparisons.
</para>
</section>


<section id="mthMutableBufferCaselessLastPos"><title>caselessLastPos</title>
<indexterm><primary>caselessLastPos method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessLastPos method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>caselessLastPos method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessLastPos method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-caselessLastPos(needle-+---------------------------+-)---><
                          +-,--+-------+--+---------+-+
                               +-start-+  +-,length-+
]]>
</programlisting>

<para>Returns the position of the last occurrence of a string,
<emphasis role="italic">needle</emphasis>,
in the receiving buffer. (See also <link linkend="mthMutableBufferPos">POS</link>.)
It returns <computeroutput>0</computeroutput> if
<emphasis role="italic">needle</emphasis> is the null string or not found.
By default, the search starts at the last character of the receiving buffer and
scans backward to the beginning of the string. You can override this by
specifying
<emphasis role="italic">start</emphasis>, the point at which the backward scan
starts and <emphasis role="italic">length</emphasis>, the range of characters to
scan.  The
<emphasis role="italic">start</emphasis> must be a positive whole number and
defaults to <computeroutput>receiving_buffer~length</computeroutput> if larger
than that value or omitted. The <emphasis role="italic">length</emphasis> must be a
non-negative whole number and defaults to <emphasis
role="italic">start</emphasis>.  The search is performed using caseless
comparisons.
</para>
</section>


<section id="mthMutableBufferCaselessMatch"><title>caselessMatch</title>
<indexterm><primary>caselessMatch method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessMatch method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>caselessMatch method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessMatch method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-caselessMatch(start,other-+----------------------------+-)-------------------><
                             +-,--+---+--+---------+-+
                                  +-n-+  +-,length-+
]]>
</programlisting>

<para>Returns .true ("1") if the characters of the <emphasis role="italic">other</emphasis> match the
characters of the target buffer beginning at position <emphasis role="italic">start</emphasis>.  Return .false
("0") if the characters are not a match.  The matching is performed using caseless comparisons.
<emphasis role="italic">start</emphasis> must be a positive whole number less than or equal to the length of
the target buffer.
</para>
<para>If <emphasis role="italic">n</emphasis> is specified, the match will be performed starting with character
<emphasis role="italic">n</emphasis> of <emphasis role="italic">other</emphasis>.  The default value for
<emphasis role="italic">n</emphasis> is "1".  <emphasis role="italic">n</emphasis> must be a positive whole number
less than or equal to the length of <emphasis role="italic">other</emphasis>.
</para>
<para>If <emphasis role="italic">length</emphasis> is specified, it defines a substring of
<emphasis role="italic">other</emphasis> that is used for the match.  <emphasis role="italic">length</emphasis>
must be a positive whole number and the combination of <emphasis role="italic">n</emphasis> and
<emphasis role="italic">length</emphasis> must be a valid substring within the bounds of
<emphasis role="italic">other</emphasis>.</para>
<para>The caselessMatch method is useful for efficient string parsing as it does
not require new string objects be extracted from the target string.
</para>
</section>

<section id="mthMutableBufferCaselessMatchChar"><title>caselessMatchChar</title>
<indexterm><primary>caselessMatchChar method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessMatchChar method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>caselessMatchChar method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessMatchChar method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-caselessMatchChar(n,chars)-------------------------><
]]>
</programlisting>

<para>Returns .true ("1") if the character at position <emphasis role="italic">n</emphasis> matches any
character of the string <emphasis role="italic">chars</emphasis>.  Returns .false ("0") if the character does not
match any of the characters in the reference set.  The match is made using caseless comparisons.
The argument <emphasis role="italic">n</emphasis> must be
a positive whole number less than or equal to the length of the target string.</para>
</section>

<section id="mthMutableBufferCaselessPos"><title>caselessPos</title>
<indexterm><primary>caselessPos method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessPos method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>caselessPos method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessPos method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-caselessPos(needle-+---------------------------+-)---><
                      +-,--+-------+--+---------+-+
                           +-start-+  +-,length-+
]]>
</programlisting>

<para>Returns the position in the receiving buffer of a
<emphasis role="italic">needle</emphasis> string. (See also
<link linkend="mthMutableBufferLastPos">caselessLastPos</link>.) It returns
<computeroutput>0</computeroutput> if
<emphasis role="italic">needle</emphasis> is the null string or is not found
or if <emphasis role="italic">start</emphasis> is greater than
the length of the receiving buffer.  The search is performed using caseless
comparisons.
By default, the search starts at the first
character of the receiving buffer (that is, the value of
<emphasis role="italic">start</emphasis> is <computeroutput>1</computeroutput>),
and continues to the end of the buffer.  You can override this by specifying
<emphasis role="italic">start
</emphasis>, the point at which the search starts, and
<emphasis role="italic">length</emphasis>, the bounding limit for the search.
If specified, <emphasis role="italic">start</emphasis> must be a positive
whole number and <emphasis role="italic">length</emphasis> must be
a non-negative whole number.
</para>
</section>

<section id="mthMutableBufferCaselessWordPos"><title>caselessWordPos</title>
<indexterm><primary>caselessWordPos method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>wordPos method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>word</primary>
<secondary>locating in a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-caselessWordPos(phrase-+--------+-)---------------------------------><
                          +-,start-+
]]>
</programlisting>

<para>Returns the word number of the first word of
<emphasis role="italic">phrase</emphasis> found in the receiving buffer, or
<computeroutput>0</computeroutput> if
<emphasis role="italic">phrase</emphasis> contains no words or
if <emphasis role="italic">phrase</emphasis> is not found.
Word matches are made independent of case.
Several blanks
between words in either <emphasis role="italic">phrase</emphasis> or the
receiving buffer are treated as a single blank for the
comparison, but, otherwise, the words must match exactly.</para>
<para>By default the search starts at the first word in the receiving
string.
You can override this by specifying <emphasis
role="italic">start</emphasis>
(which must be positive),
the word at which the search is to be started.</para>
</section>

<section id="mthMutableBufferChangeStr"><title>changeStr</title>
<indexterm><primary>changeStr method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>changeStr method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-changeStr(needle,newneedle--+--------+--)---------------------------------><
                               +-,count-+
]]>
</programlisting>

<para>Returns the receiver object with
<emphasis role="italic">newneedle</emphasis> replacing occurrences of <emphasis
role="italic">needle</emphasis>.</para>
<para>If <emphasis role="italic">count</emphasis> is not specified, all occurrences of
<emphasis role="italic">needle</emphasis> are replaced.  If <emphasis role="italic">count</emphasis>
is specified, it must be a positive, whole number that gives the maximum number of
occurrences to be replaced.</para>
</section>

<section id="mthMutableBufferCountStr"><title>countStr</title>
<indexterm><primary>countStr method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>countStr method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-countStr(needle)--------------------------------------------><
]]>
</programlisting>

<para>Returns a count of the occurrences of
<emphasis role="italic">needle</emphasis> in the receiving buffer that do not
overlap.</para>
</section>

<section id="mthMutableBufferDelete"><title>delete</title>
<indexterm><primary>delete method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>delete method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-delete(n---+---------+--)-------------------------------><
              +-,length-+
]]>
</programlisting>

<para>Deletes <emphasis>length</emphasis> characters from the buffer beginning
at the <emphasis>n</emphasis>'th character. If length is omitted, or if length
is greater than the number of characters from <emphasis>n</emphasis> to the end
of the buffer, the method deletes the remaining buffer contents (including
the <emphasis>n</emphasis>'th character). The length must be a positive integer
or zero. The <emphasis>n</emphasis> must be a positive integer. If
<emphasis>n</emphasis> is greater than
the length of the buffer or zero, the method does not modify the
buffer content.</para>
</section>


<section id="mthMutableBufferDelWord"><title>delWord</title>
<indexterm><primary>delWord method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>delWord method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>deleting</primary>
<secondary>words from a mutablebuffer</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>deleting from a mutablebuffer</secondary></indexterm>

<programlisting>
<![CDATA[
>>-delWord(n--+---------+--)-----------------------------------><
              +-,length-+
]]>
</programlisting>

<para>Deletes a substring from the mutable buffer substring that starts at the
<emphasis role="italic">n</emphasis>th word and is of
<emphasis role="italic">length</emphasis> blank-delimited
words. If you omit <emphasis role="italic">length</emphasis>, or if
<emphasis role="italic">length</emphasis> is greater than
the number of words from <emphasis role="italic">n</emphasis> to the end of the
receiving bufffer, the
method deletes the remaining words in the receiving buffer (including the
<emphasis role="italic">n</emphasis>th word). The
<emphasis role="italic">length</emphasis> must be a positive whole number or
zero. The <emphasis role="italic">n</emphasis> must be a positive whole number.
If <emphasis role="italic">n</emphasis> is greater than
the number of words in the receiving buffer, the method returns the receiving
buffer unchanged. The portion deleted includes any blanks following the final
word involved but none of the blanks preceding the first word involved.
</para>
</section>

<section id="mthMutableBufferGetBufferSize"><title>getBufferSize</title>
<indexterm><primary>getBufferSize method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getBufferSizemethod</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-getBufferSize-------------------------------------------><
]]>
</programlisting>

<para>Retrieves the current buffer size.</para>
</section>

<section id="mthMutableBufferInsert"><title>insert</title>
<indexterm><primary>insert method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>insert method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-insert(new-+-----------------------------------------+--)><
              +-,--+---+--+--------------------------+--+
                   +-n-+  +-,--+--------+--+------+--+
                               +-length-+  +-,pad-+
]]>
</programlisting>

<para>Inserts the string <emphasis>new</emphasis>, padded or truncated to
length <emphasis>length</emphasis>, into the mutable buffer after the
<emphasis>n</emphasis>'th character. The default
value for <emphasis>n</emphasis> is 0, which means insertion at the beginning
of the string. If specified, <emphasis>n</emphasis> and length must be
positive integers or zeros. If <emphasis>n</emphasis> is greater than the
length of the buffer contents,
the string new is padded at the beginning. The default value for
<emphasis>length</emphasis> is the length of <emphasis>new</emphasis>.
If length is less than the length of
string <emphasis>new</emphasis>,
<emphasis role="bold">insert</emphasis> truncates <emphasis>new</emphasis>
to length <emphasis>length</emphasis>. The default
<emphasis>pad</emphasis> character is a blank.</para>
</section>

<section id="mthMutableBufferLastPos"><title>lastPos</title>
<indexterm><primary>lastPos method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lastPos method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>position</primary>
<secondary>last occurrence of a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-lastPos(needle-+--------+-)---------------------------------><
                  +-,start-+
]]>
</programlisting>

<para>Returns the position of the last occurrence of a string,
<emphasis role="italic">needle</emphasis>,
in the receiving buffer. (See also <link linkend="mthMutableBufferPos">POS</link>.) It
returns <computeroutput>0</computeroutput> if
<emphasis role="italic">needle</emphasis> is the null string or not found.
By default, the search starts at the last character of the receiving buffer
and scans backward. You can override this by specifying
<emphasis role="italic">start</emphasis>, the point at which the
backward scan starts. The <emphasis role="italic">start</emphasis> must be a
positive whole number and defaults to
<computeroutput>receiving_buffer~length</computeroutput> if larger than that
value or omitted.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>lastPos method</secondary></indexterm>
<programlisting>
x1 - .mutablebuffer~new("abc def ghi")
x1~lastPos(" ")      ->    8
x1 - .mutablebuffer~new("abcdefghi")
x1~lastPos(" ") -> 0
x1 - .mutablebuffer~new("efgxyz")
x1~lastPos("xy")     ->    4
x1 - .mutablebuffer~new("abc def ghi")
x1~lastPos(" ",7) -> 4
</programlisting>
</section>

<section id="mthMutableBufferLength"><title>length</title>
<indexterm><primary>length method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>length method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-length--------------------------------------------------><
]]>
</programlisting>

<para>Returns length of data in buffer.</para>
</section>

<section id="mthMutableBufferLower"><title>lower</title>
<indexterm><primary>lower method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lower method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-lower(+---+--+---------+---)----------------------><
         +-n-+  +-,length-+
]]>
</programlisting>

<para>Returns the receiving buffer with the characters of the target string
beginning with character
<emphasis role="italic">n</emphasis> for <emphasis role="italic">length</emphasis>
characters converted to lowercase.  If <emphasis role="italic">n</emphasis> is specified, it must
be a positive whole number.  If <emphasis role="italic">n</emphasis> is not specified, the case
conversion will start with the first character.  If <emphasis role="italic">length</emphasis>
is specified, it must be a non-negative whole number.  If <emphasis role="italic">length</emphasis>
the default is to convert the remainder of the buffer.</para>
</section>

<section id="mthMutableBufferMatch"><title>match</title>
<indexterm><primary>match method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>match method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-match(start,other-+----------------------------+-)-------------------><
                     +-,--+---+--+---------+-+
                          +-n-+  +-,length-+
]]>
</programlisting>

<para>Returns .true ("1") if the characters of the <emphasis role="italic">other</emphasis> match the
characters of the target buffer beginning at position <emphasis role="italic">start</emphasis>.  Return .false
("0") if the characters are not a match.
<emphasis role="italic">start</emphasis> must be a positive whole number less than or equal to the length of
the target buffer.
</para>
<para>If <emphasis role="italic">n</emphasis> is specified, the match will be performed starting with character
<emphasis role="italic">n</emphasis> of <emphasis role="italic">other</emphasis>.  The default value for
<emphasis role="italic">n</emphasis> is "1".  <emphasis role="italic">n</emphasis> must be a positive whole number
less than or equal to the length of <emphasis role="italic">other</emphasis>.
</para>
<para>If <emphasis role="italic">length</emphasis> is specified, it defines a substring of
<emphasis role="italic">other</emphasis> that is used for the match.  <emphasis role="italic">length</emphasis>
must be a positive whole number and the combination of <emphasis role="italic">n</emphasis> and
<emphasis role="italic">length</emphasis> must be a valid substring within the bounds of
<emphasis role="italic">other</emphasis>.</para>
<para>The match method is useful fort efficient string parsing as it does not
require new string objects be extracted from the target string.
</para>
</section>

<section id="mthMutableBufferMatchChar"><title>matchChar</title>
<indexterm><primary>matchChar method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>matchChar method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-matchChar(n,chars)-------------------------><
]]>
</programlisting>

<para>Returns .true ("1") if the character at position <emphasis role="italic">n</emphasis> matches any
character of the string <emphasis role="italic">chars</emphasis>.  Returns .false ("0") if the character does not
match any of the characters in the reference set.  The argument <emphasis role="italic">n</emphasis> must be
a positive whole number less than or equal to the length of the target
buffer.</para>
</section>

<section id="mthMutableBufferOverlay"><title>overlay</title>
<indexterm><primary>overlay method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>overlay method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-overlay(new-+-----------------------------------------+--)--><
               +-,--+---+--+--------------------------+--+
                    +-n-+  +-,--+--------+--+------+--+
                                +-length-+  +-,pad-+
]]>
</programlisting>

<para>Modifies the buffer content by overlaying it, starting at the
<emphasis>n</emphasis>'th character, with the string <emphasis>new</emphasis>,
padded or truncated to length <emphasis>length</emphasis>. The overlay can extend
beyond the end of the buffer. In this case the buffer size will be increased.
If you specify <emphasis>length</emphasis>, it must be a positive integer or
zero. The default value for <emphasis>length</emphasis> is the length of
<emphasis>new</emphasis>. If <emphasis>n</emphasis> is
greater than the length of the buffer content, padding is
added before the new string. The default <emphasis>pad</emphasis> character is
a blank, and the default value for <emphasis>n</emphasis> is 1. If you specify
<emphasis>n</emphasis>, it must be a positive integer.</para>
</section>

<section id="mthMutableBufferPos"><title>pos</title>
<indexterm><primary>pos method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>pos method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>finding</primary>
<secondary>string in a MutableBuffer</secondary></indexterm>
<indexterm><primary>locating</primary>
<secondary>string in a MutableBuffer</secondary></indexterm>

<programlisting>
<![CDATA[
>>-pos(needle-+--------+-)-------------------------------------><
              +-,start-+
]]>
</programlisting>

<para>Returns the position in the receiving buffer of another string,
<emphasis role="italic">needle</emphasis>. (See also
<link linkend="mthMutableBufferLastPos">lastPos</link>.) It returns
<computeroutput>0</computeroutput> if
<emphasis role="italic">needle</emphasis> is the null string or is not found
or if <emphasis role="italic">start</emphasis> is greater than
the length of the receiving buffer. By default, the search starts at the first
character of the receiving buffer (that is, the value of
<emphasis role="italic">start</emphasis> is <computeroutput>1</computeroutput>).
You can override this by specifying <emphasis role="italic">start</emphasis>
(which must be
a positive whole number), the point at which the search starts.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>pos method</secondary></indexterm>
<programlisting>
x1 = .mutablebuffer~new("Saturday")
x1~pos("day")       ->    6
x1 = .mutablebuffer~new("abc def ghi")
x1~pos("x")         ->    0
x1~pos(" ")         ->    4
x1~pos(" ",5)       ->    8
</programlisting>
</section>

<section id="mthMutableBufferReplaceAt"><title>replaceAt</title>
<indexterm><primary>replaceAt method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>replaceAt method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>replacing characters within a string</primary></indexterm>

<programlisting>
<![CDATA[
>>-replaceAt(new,n,length-+------+-)-----><
                          +-,pad-+
]]>
</programlisting>

<para>Returns the receiving buffer with the characters from the
<emphasis role="italic">n</emphasis>th character for <emphasis role="italic">length</emphasis>
characters replaced with
<emphasis role="italic">new</emphasis>. The replacement position and length can
extend beyond the end of the receiving string.
The starting
position,
<emphasis role="italic">n</emphasis>, must be a positive whole number, and
the
<emphasis role="italic">length</emphasis> must be a positive whole number or
zero.  If <emphasis
role="italic">n</emphasis> is greater than the length of the receiving string,
padding is added before the <emphasis role="italic">new</emphasis> string. The
default
<emphasis role="italic">pad</emphasis> character is a blank.
</para>
</section>

<section id="mthMutableBufferRequest"<title>request</title>
<indexterm><primary>request method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>request method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-request(classid)--------------------------------------------><
]]>
</programlisting>

<para>Returns an object of the <emphasis role="italic">classid</emphasis>
class, or the Nil object if the request cannot be satisfied.  The MutableBuffer
class supports converting to "STRING" and "ARRAY".  The "ARRAY" conversion returns
the buffer contents as lines split at line end boundaries.
</para>
</section>

<section id="mthMutableBufferSetBufferSize"><title>setBufferSize</title>
<indexterm><primary>setBufferSize method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>setBufferSizemethod</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-setBufferSize(n)----------------------------------------><
]]>
</programlisting>

<para>Sets the buffer size. If <emphasis>n</emphasis>
is less than the length of buffer
content, the content is truncated. If <emphasis>n</emphasis> is 0, the entire
contents is erased and the new buffer size is the value given
in the <emphasis role="bold">init</emphasis> method.</para>
</section>

<section id="mthMutableBufferString"><title>string</title>
<indexterm><primary>string method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>string method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-string--------------------------------------------------><
]]>
</programlisting>

<para>Retrieves the content of the buffer (a string).</para>
</section>

<section id="mthMutableBufferSubchar"><title>subchar</title>
<indexterm><primary>subcharmethod</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>subchar method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-subchar(n)----------------------------------------------><
]]>
</programlisting>

<para>Returns the <emphasis>n</emphasis>'th character of the receiving
string. <emphasis>n</emphasis> must be a positive whole number. If
<emphasis>n</emphasis> is greater that the length of the receiving string
then a zero-length string is returned.</para>
</section>

<section id="mthMutableBufferSubstr"><title>substr</title>
<indexterm><primary>substr method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>substr method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-substr(n-+--------------------------+--)----------------><
            +-,--+--------+--+------+--+
                 +-length-+  +-,pad-+
]]>
</programlisting>

<para>Returns a substring from the buffer content that begins at the
<emphasis>n</emphasis>'th character and is of length
<emphasis>length</emphasis>, padded with <emphasis>pad</emphasis> if
necessary. The <emphasis>n</emphasis> must be a positive integer. If
<emphasis>n</emphasis> is greater
than receiving_string~length, only <emphasis>pad</emphasis> characters
are returned. If you omit <emphasis>length</emphasis>, the remaining
buffer content is returned.
The default <emphasis>pad</emphasis> character is a blank.</para>
</section>

<section id="mthMutableBufferSubWord"><title>subWord</title>
<indexterm><primary>subWord method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>subWord method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>extracting words with subWord</primary></indexterm>
<indexterm><primary>word</primary>
<secondary>extracting from a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-subWord(n-+---------+-)-------------------------------------><
             +-,length-+
]]>
</programlisting>

<para>Returns the substring of the receiving buffer that starts at the
<emphasis role="italic">n</emphasis>th word and is up to
<emphasis role="italic">length</emphasis> blank-delimited words. The
<emphasis role="italic">n</emphasis> must be a positive whole number.
If you omit <emphasis role="italic">length</emphasis>, it defaults
to the number of remaining words in the receiving buffer. The returned string
never has leading or trailing blanks, but includes all blanks between the
selected words.
</para>
</section>

<section id="mthMutableBufferTranslate"><title>translate</title>
<indexterm><primary>translate method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>translate method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>reordering data</primary></indexterm>
<indexterm><primary>translation</primary>
<secondary>with translate method</secondary></indexterm>
<indexterm><primary>uppercase translation</primary>
<secondary>with translate method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-translate-+--------------------------------------------------------------------------+-><
             +-(--+-------------------------------------+-+-----------------------+-)-+
                  +-tableo--+-------------------------+-+ +-,--+---+--+---------+-+
                            +-,--+--------+--+------+-+        +-n-+  +-,length-+
                                 +-tablei-+  +-,pad-+
]]>
</programlisting>

<para>Returns the receiving buffer with each character translated to another
character or unchanged. You can also use this method to reorder the characters
in the output table.</para>
<para>The output table is <emphasis role="italic">tableo</emphasis>
and the input translation table is <emphasis role="italic">tablei</emphasis>.
<emphasis role="bold">translate</emphasis> searches
<emphasis role="italic">tablei</emphasis> for each character
in the receiving buffer.  If the character is found, the corresponding character
in
<emphasis role="italic">tableo</emphasis> is replaces the character in the
buffer. If there are duplicates in
<emphasis role="italic">tablei</emphasis>, the first (leftmost) occurrence is
used. If the character is not found, the original character in the receiving
buffer is unchanged. </para>
<para>The tables can be of any length. If you specify neither translation table and
omit <emphasis role="italic">pad</emphasis>, the receiving string is
translated to uppercase (that is, lowercase
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>
to uppercase
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>),
but if you include <emphasis role="italic">pad</emphasis>
the language processor translates the entire
string to <emphasis role="italic">pad</emphasis> characters.
<emphasis role="italic">tablei</emphasis> defaults to
<computeroutput>XRANGE("00"x,"FF"x)</computeroutput>, and
<emphasis role="italic">tableo</emphasis> defaults to the null string and
is padded with <emphasis role="italic">pad</emphasis> or truncated as necessary.
The default <emphasis role="italic">pad</emphasis> is a blank.</para>
<para><emphasis role="italic">n</emphasis> is the position of the first
character of the translated range.  The default starting position is 1.
<emphasis role="italic">length</emphasis> is the range of characters to be
translated.  If omitted, <emphasis role="italic">length</emphasis> remainder of
the buffer from the starting position to the end is used. </para>
</section>

<section id="mthMutableBufferUpper"><title>upper</title>
<indexterm><primary>upper method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>upper method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-upper(+---+--+---------+---)----------------------><
         +-n-+  +-,length-+
]]>
</programlisting>

<para>Returns teh receiving buffer with the characters of the target string
beginning with character <emphasis role="italic">n</emphasis> for <emphasis role="italic">length</emphasis>
characters converted to uppercase.  If <emphasis role="italic">n</emphasis> is specified, it must
be a positive whole number.  If <emphasis role="italic">n</emphasis> is not specified, the case
conversion will start with the first character.  If <emphasis role="italic">length</emphasis>
is specified, it must be a non-negative whole number.  If <emphasis role="italic">length</emphasis>
the default is to convert the remainder of the buffer.</para>
</section>

<section id="mthMutableBufferVerify"><title>verify</title>
<indexterm><primary>verify method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>verify method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>string</primary>
<secondary>verifying contents of</secondary></indexterm>
<indexterm><primary>verifying contents of a buffer</primary></indexterm>

<programlisting>
<![CDATA[
>>-verify(reference-+----------------------------------------------+-)--><
                    +-,--+--------+--+---------------------------+-+
                         +-option-+  +-,--+-------+--+---------+-+
                                          +-start-+  +-,length-+
]]>
</programlisting>

<para>Returns a number that, by default, indicates whether the receiving string
is composed only of characters from
<emphasis role="italic">reference</emphasis>. It returns
<computeroutput>0</computeroutput> if all characters in the receiving buffer are
in
<emphasis role="italic">reference</emphasis> or returns the position of the
first character in the receiving buffer not in
<emphasis role="italic">reference</emphasis>.</para>
<para>The <emphasis role="italic">option</emphasis> can be either
<computeroutput>Nomatch</computeroutput> (the
default) or <computeroutput>Match</computeroutput>. (You need to specify only
the first capitalized and highlighted letter; the language processor ignores
all characters following the first character, which can be in uppercase or
lowercase.)</para>
<para>If you specify <computeroutput>Match</computeroutput>, the method returns
the position of the first character in the receiving buffer that is in
<emphasis role="italic">reference</emphasis>, or returns
<computeroutput>0</computeroutput> if none of the characters
are found.</para>
<para>The default for <emphasis role="italic">start</emphasis> is
<computeroutput>1</computeroutput>. Thus, the search starts
at the first character of the receiving buffer. You can override this by
specifying a different
<emphasis role="italic">start</emphasis> point, which must be a positive whole
number.</para>
<para>The default for <emphasis role="italic">length</emphasis> the length of
the buffer from <emphasis role="italic">start</emphasis> to the end of the
buffer. Thus, the search proceeds to the end of the receiving buffer. You can
override this by specifying a different
<emphasis role="italic">length</emphasis>, which must be a non-negative whole
number.
</para>
<para>If the receiving string is null, the method returns
<computeroutput>0</computeroutput>, regardless
of the value of the <emphasis role="italic">option</emphasis>. Similarly, if
<emphasis role="italic">start</emphasis> is greater
than <computeroutput>receiving_buffer~length</computeroutput>, the method
returns
<computeroutput>0</computeroutput>. If
<emphasis role="italic">reference</emphasis> is null, the method returns
<computeroutput>0</computeroutput> if
you specify <computeroutput>Match</computeroutput>. Otherwise, the method
returns the <emphasis role="italic">start</emphasis> value.</para>
</section>

<section id="mthMutableBufferWord"><title>word</title>
<indexterm><primary>word method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>word method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>extracting</primary>
<secondary>word from a mutable buffer</secondary></indexterm>
<indexterm><primary>locating</primary>
<secondary>word in another mutable buffer</secondary></indexterm>

<programlisting>
<![CDATA[
>>-word(n)-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the <emphasis role="italic">n</emphasis>th blank-delimited word
in the receiving buffer or the null string if the receiving buffer has fewer
than
<emphasis role="italic">n</emphasis> words. The
<emphasis role="italic">n</emphasis> must be a positive whole number. This
method is exactly equivalent
to <computeroutput>receiving_buffer~subWord(n,1)</computeroutput>.</para>
</section>

<section id="mthMutableBufferWordIndex"><title>wordIndex</title>
<indexterm><primary>wordIndex method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>wordIndex method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-wordIndex(n)------------------------------------------------><
]]>
</programlisting>

<para>Returns the position of the first character in the
<emphasis role="italic">n</emphasis>th blank-delimited
word in the receiving buffer. It returns <computeroutput>0</computeroutput> if
the receiving buffer has fewer than
<emphasis role="italic">n</emphasis> words. The
<emphasis role="italic">n</emphasis> must be a positive whole number.
</para>
</section>

<section id="mthMutableBufferWordLength"><title>wordLength</title>
<indexterm><primary>wordLength method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>wordLength method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>finding</primary>
<secondary>word length</secondary></indexterm>

<programlisting>
<![CDATA[
>>-wordLength(n)-----------------------------------------------><
]]>
</programlisting>

<para>Returns the length of the <emphasis role="italic">n</emphasis>th
blank-delimited word in the receiving buffer or
<computeroutput>0</computeroutput> if the receiving buffer has fewer than
<emphasis role="italic">n</emphasis> words. The <emphasis
role="italic">n</emphasis> must be a positive whole number.</para>
</section>

<section id="mthMutableBufferWordPos"><title>wordPos</title>
<indexterm><primary>wordPos method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>wordPos method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>word</primary>
<secondary>locating in a mutable buffer</secondary></indexterm>

<programlisting>
<![CDATA[
>>-wordPos(phrase-+--------+-)---------------------------------><
                  +-,start-+
]]>
</programlisting>

<para>Returns the word number of the first word of
<emphasis role="italic">phrase</emphasis> found in the receiving buffer, or
<computeroutput>0</computeroutput> if
<emphasis role="italic">phrase</emphasis> contains no words or
if <emphasis role="italic">phrase</emphasis> is not found. Several blanks
between words in either <emphasis role="italic">phrase</emphasis> or the
receiving buffer are treated as a single blank for the
comparison, but, otherwise, the words must match exactly.</para>
<para>By default the search starts at the first word in the receiving buffer.
You can override this by specifying
<emphasis role="italic">start</emphasis> (which must be positive), the word at
which the search is to be started.</para>
</section>

<section id="mthMutableBufferWords"><title>words</title>
<indexterm><primary>words method</primary>
<secondary>of MutableBuffer class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>words method</secondary>
<tertiary>of MutableBuffer class</tertiary></indexterm>
<indexterm><primary>counting</primary>
<secondary>words in a mutable buffer</secondary></indexterm>
<indexterm><primary>extracting</primary>
<secondary>words from a mutable buffer</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>counting in a mutable buffer</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>extracting from a mutable buffer</secondary></indexterm>

<programlisting>
<![CDATA[
>>-words-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of blank-delimited words in the receiving buffer.
</para>
</section>
</section>

<section id="clsRegularExpression"><title>The RegularExpression Class</title>
<indexterm><primary>RegularExpression class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>RegularExpression class</secondary></indexterm>

<para>This class provides support for regular expressions. A regular
expression is a pattern you can use to match strings.</para>

<note><para>The RegularExpression class is not a built-in class
and is NOT preloaded. It is defined
in the <computeroutput>rxregexp.cls</computeroutput>
file. This means, you must either explicitly call the program file or
use a <computeroutput>::requires </computeroutput>
statement to activate its functionality, as follows:</para></note>
<programlisting>
<![CDATA[
call "rxregexp.cls"
      or
::requires "rxregexp.cls"
]]>
</programlisting>

<figure><title>The RegularExpression class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxRegularExpressionClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The RegularExpression class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<para>Here is a description of the syntax:</para>

<variablelist>
<varlistentry><term>|</term>
<listitem><para>OR operator between the left and right expression
</para></listitem></varlistentry>
<varlistentry><term>?</term>
<listitem><para>Matches any single character
</para></listitem></varlistentry>
<varlistentry><term>*</term>
<listitem><para>Matches the previous expression zero or more times
</para></listitem></varlistentry>
<varlistentry><term>+</term>
<listitem><para>Matches the previous expression one or more times
</para></listitem></varlistentry>
<varlistentry><term>\</term>
<listitem><para>"Escape" symbol: use the next character literally
</para></listitem></varlistentry>
<varlistentry><term>()</term>
<listitem><para>Expression in parenthesis (use where needed)
</para></listitem></varlistentry>
<varlistentry><term>{n}</term>
<listitem><para>Matches previous expression n times (n>1)
</para></listitem></varlistentry>
<varlistentry><term>[]</term>
<listitem><para>Set definition: matches any single character out of the defined
set.</para>
<para>A &apos;^&apos; right after the opening bracket means that none of the
following characters should be matched.</para>
<para>A &apos;-&apos; (if not used with &apos;\&apos;) defines a range between the last
specified character and the one following &apos;-&apos;. If it is the
first character in the set definition, it is used literally.
</para></listitem></varlistentry>
</variablelist>

<para>The following symbolic names (they must start and end with &apos;:&apos;) can
be used to abbreviate common sets:</para>

<variablelist>
<varlistentry><term>:ALPHA:</term>
<listitem><para>Characters in the range A-Z and a-z
</para></listitem></varlistentry>
<varlistentry><term>:LOWER:</term>
<listitem><para>Characters in the range a-z
</para></listitem></varlistentry>
<varlistentry><term>:UPPER:</term>
<listitem><para>Characters in the range A-Z
</para></listitem></varlistentry>
<varlistentry><term>:DIGIT:</term>
<listitem><para>Characters in the range 0-9
</para></listitem></varlistentry>
<varlistentry><term>:ALNUM:</term>
<listitem><para>Characters in :DIGIT: and :ALPHA:
</para></listitem></varlistentry>
<varlistentry><term>:XDIGIT:</term>
<listitem><para>Characters in :DIGIT:, A-F and a-f
</para></listitem></varlistentry>
<varlistentry><term>:BLANK:</term>
<listitem><para>Space and tab characters
</para></listitem></varlistentry>
<varlistentry><term>:SPACE:</term>
<listitem><para>Characters "09"x to "0D"x and space
</para></listitem></varlistentry>
<varlistentry><term>:CNTRL:</term>
<listitem><para>Characters "00"x to "1F"x and "7F"x
</para></listitem></varlistentry>
<varlistentry><term>:PRINT:</term>
<listitem><para>Characters in the range "20"x to "7E"x
</para></listitem></varlistentry>
<varlistentry><term>:GRAPH:</term>
<listitem><para>Characters in :PRINT: without space
</para></listitem></varlistentry>
<varlistentry><term>:PUNCT:</term>
<listitem><para>All :PRINT: characters without space and not in :ALNUM:
</para></listitem></varlistentry>
</variablelist>

<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>RegularExpression class</secondary></indexterm>
<programlisting>
<![CDATA[
::requires "rxregexp.cls"

     "(Hi|Hello) World"      Matches "Hi World" and
                             "Hello World".
     "file.???"              Matches any file with three
                             characters after "."
     "file.?{3}"             Same as above.
     "a *b"                  Matches all strings that begin with
                             "a" and end with "b" and have an
                             arbitrary number of spaces in between
                             both.
     "a +b"                  Same as above, but at least one space
                             must be present.
     "file.[bd]at"           Matches "file.bat" and "file.dat".
     "[A-Za-z]+"             Matches any string containing only
                             letters.
     "[:ALPHA:]+"            Same as above, using symbolic names.
     "[^0-9]*"               Matches any string containing no
                             numbers, including the empty string.
     "[:DIGIT::LOWER:]"      A single character, either a digit or
                             a lower case character.
     "This is (very )+nice." Matches all strings with one or more
                             occurrences of "very " between
                             "This is " and "nice.".
]]>
</programlisting>

<section><title>Inherited Methods</title>

&objclsmthods;

</section>


<section id="mthRegularExpressionInit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of RegularExpression class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of RegularExpression class</tertiary></indexterm>

<programlisting>
<![CDATA[
                     +-,-"MAXIMAL"--+
>>-init(-+---------+-+--------------+-)--------------------><
         +-Pattern-+ +-,-"MINIMAL"--+
]]>
</programlisting>

<para>Instantiates a RegularExpression object. Use the optional parameter
<emphasis>Pattern</emphasis> to define a pattern that is used to match
strings. See the introductory text below for a description of the
syntax. If the strings match, you can decide whether you want to
apply "greedy" matching (a maximum-length match) or "non-greedy"
matching (a minimum-length match).</para>

<para><emphasis role="bold">Examples:</emphasis></para>

<programlisting>
<![CDATA[
myRE1 = .RegularExpression~new
myRE2 = .RegularExpression~new("Hello?*")
]]>
</programlisting>
</section>

<section id="mthRegularExpressionMatch"><title>match</title>
<indexterm><primary>match method</primary>
<secondary>of RegularExpression class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>match method</secondary>
<tertiary>of RegularExpression class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-match(-String-)-----------------------------------------><
]]>
</programlisting>

<para>This method tries to match the given string to the regular
expression that was defined on the "new" invocation or on the
"parse" invocation. It returns 0 on an unsuccessful match and 1
on a successful match. For an example see
<link linkend="mthRegularExpressionParse">Parse</link>.
</para>
</section>

<section id="mthRegularExpressionParse"><title>parse</title>
<indexterm><primary>parse method</primary>
<secondary>of RegularExpression class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>parse method</secondary>
<tertiary>of RegularExpression class</tertiary></indexterm>

<programlisting>
<![CDATA[
                  +-,-"CURRENT"--+
>>-parse(-Pattern-+--------------+-------------------------><
                  +-,-"MAXIMAL"--+
                  +-,-"MINIMAL"--+
]]>
</programlisting>

<para>This method creates the automation used to match a string from the
regular expression specified with
<emphasis>Pattern</emphasis>. The RegularExpression
object uses this regular expression until a new invocation of Parse
takes place. The second (optional) parameter specifies whether to
use minimal or maximal matching. The default is to use the current
matching behavior.</para>

<para><emphasis role="bold">Return values:</emphasis></para>

<variablelist>
<varlistentry><term>0</term>
<listitem><para>Regular expression was parsed successfully.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>An unexpected symbol was met during parsing.
</para></listitem></varlistentry>
<varlistentry><term>2</term>
<listitem><para>A missing &apos;)&apos; was found.
</para></listitem></varlistentry>
<varlistentry><term>3</term>
<listitem><para>An illegal set was defined.
</para></listitem></varlistentry>
<varlistentry><term>4</term>
<listitem><para>The regular expression ended unexpectedly.
</para></listitem></varlistentry>
<varlistentry><term>5</term>
<listitem><para>An illegal number was specified.
</para></listitem></varlistentry>
</variablelist>


<para><emphasis role="bold">Example 1:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>RegularExpression class</secondary></indexterm>
<programlisting>
<![CDATA[
a.0 = "does not match regular expression"
a.1 = "matches regular expression"
b = .array~of("This is a nice flower.",
              "This is a yellow flower.", ,
              "This is a blue flower.",
              "Hi there!")

myRE = .RegularExpression~new
e = myRE~parse("This is a ???? flower.")
if e == 0 then do
  do i over b
    j = myRE~match(i)
    say i~left(24) ">>" a.j
  end
end
else
  say "Error" e "occurred!"
exit

::requires "rxregexp.cls"
]]>
</programlisting>

<para>Output:</para>

<programlisting>
<![CDATA[
This is a nice flower.   >> Does match regular expression
This is a yellow flower. >> Does not match regular expression
This is a blue flower.   >> Does match regular expression
Hi there!                >> Does not match regular expression
]]>
</programlisting>

<para><emphasis role="bold">Example 2:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>RegularExpression class</secondary></indexterm>
<programlisting>
<![CDATA[
a.0 = "an invalid number!"
a.1 = "a valid number."
b = .array~of("1","42","0","5436412","1a","f43g")
myRE = .RegularExpression~new("[1-9][0-9]*")
do i over b
  j = myRE~match(i)
  say i "is" a.j
end
say

/* Now allow "hex" numbers and a single 0 */
if myRE~parse("0|([1-9a-f][0-9a-f]*)") == 0 then do
  do i over b
    j = myRE~match(i)
    say i "is" a.j
  end
end
else
  say "invalid regular expression!"

exit

::requires "rxregexp.cls"
]]>
</programlisting>

<para><emphasis role="bold">Example 3:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>RegularExpression class</secondary></indexterm>
<programlisting>
<![CDATA[
str = "<p>Paragraph 1</p><p>Paragraph 2</p>"
myRE1 = .RegularExpression~new("<p>?*</p>","MINIMAL")
myRE1~match(str)
myRE2 = .RegularExpression~new("<p>?*</p>","MAXIMAL")
myRE2~match(str)

say "myRE1 (minimal) matched" str~substr(1,myRE1~position)
say "myRE2 (maximal) matched" str~substr(1,myRE2~position)

::requires "rxregexp.cls"
]]>
</programlisting>

<para>Output:</para>

<programlisting>
<![CDATA[
myRE1 (minimal) matched <p>Paragraph 1</p>
myRE2 (maximal) matched <p>Paragraph 1</p><p>Paragraph 2</p>
]]>
</programlisting>
</section>

<section id="mthRegularExpressionPos"><title>pos</title>
<indexterm><primary>pos method</primary>
<secondary>of RegularExpression class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>pos method</secondary>
<tertiary>of RegularExpression class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-pos-(-Haystack-)----------------------------------------><
]]>
</programlisting>

<para>This method tries to locate a string defined by the regular
expression on the "new" invocation or on the "parse" invocation
in the given haystack string.
It returns 0 on an unsuccessful match or the starting position
on a successful match. The end position of the match can be
retrieved with the <link linkend="mthRegularExpressionPosition">position</link> method.</para>

<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[
str = "It is the year 2002!"
myRE = .RegularExpression~new("[1-9][0-9]*")
begin = myRE~pos(str)
if begin > 0 then do
  year = str~substr(begin, myRE~position - begin + 1)
  say "Found the number" year "in this sentence."
end

::requires "rxregexp.cls"
]]>
</programlisting>

<para>Output:</para>

<programlisting>
<![CDATA[
Found the number 2002 in this sentence.
]]>
</programlisting>
</section>

<section id="mthRegularExpressionPosition"><title>position</title>
<indexterm><primary>position method</primary>
<secondary>of RegularExpression class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>position method</secondary>
<tertiary>of RegularExpression class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-position------------------------------------------------><
]]>
</programlisting>

<para>Returns the character position at which either Parse, Pos or Match
ended, depending on what was invoked last.</para>

<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[
myRE = .RegularExpression~new
myRE~parse("[abc")                    -- illegal set definition
say myRE~position                     -- will be 4

myRE = .RegularExpression~new("[abc]12")
myRE~match("c12")
say myRE~position                     -- will be 3

myRE~match("a13")
say myRE~position                     -- will be 2 (failure to match)

::requires "rxregexp.cls"
]]>
</programlisting>
</section>
</section>

<section id="clsRexxQueue"><title>The RexxQueue Class</title>
<indexterm><primary>RexxQueue class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>RexxQueue class</secondary></indexterm>

<figure><title>The RexxQueue class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxRexxQueueClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The RexxQueue class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;

</section>

<section id="mthRexxQueueCreate"><title>create (Class Method)</title>
<indexterm><primary>create method</primary>
<secondary>of RexxQueue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>create method</secondary>
<tertiary>of RexxQueue class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-create(name)--------------------------------------------><
]]>
</programlisting>
<para>Attempts to create an external Rexx named queue using <emphasis role="italic">name</emphasis>.  If
a <emphasis role="italic">name</emphasis> queue already exists, a new queue with a Rexx-generated name will be
created.  This method returns the name of the created queue, which will be either
<emphasis role="italic">name</emphasis>, or a generated name if there is a conflict.
</para>
</section>

<section id="mthRexxQueueDeleteClsMethod"><title>delete (Class Method)</title>
<indexterm><primary>delete class method</primary>
<secondary>of RexxQueue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>delete class method</secondary>
<tertiary>of RexxQueue class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-delete(name)--------------------------------------------><
]]>
</programlisting>

<para>Attempts to delete an external Rexx named queue named <emphasis role="italic">name</emphasis>.  This method
returns "0" if the queue was successfully deleted.  Non-zero results are the error codes from the RexxDeleteQueue()
programming interface.
</para>
</section>

<section id="mthRexxQueueDelete"><title>delete</title>
<indexterm><primary>delete method</primary>
<secondary>of RexxQueue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>delete method</secondary>
<tertiary>of RexxQueue class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-delete------------------------------------------------><
]]>
</programlisting>

<para>Deletes the Rexx external queue associated with this RexxQueue instance.
</para>
</section>

<section id="mthRexxQueueGet"><title>get</title>
<indexterm><primary>get method</primary>
<secondary>of RexxQueue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>get method</secondary>
<tertiary>of RexxQueue class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-get------------------------------------------------><
]]>
</programlisting>

<para>Returns the name of the Rexx external queue associated with this instance.
</para>
</section>

<section id="mthRexxQueueInit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of RexxQueue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of RexxQueue class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-init(-+------+-)----------------------------------><
         +-name-+
]]>
</programlisting>

<para>Initializes a new RexxQueue instance associated with the named Rexx external queue.  If
<emphasis role="italic">name</emphasis> is not specified, the SESSION queue is used.  If the named
queue does not exist, one will be created.
</para>
</section>

<section id="mthRexxQueueLineIn"><title>lineIn</title>
<indexterm><primary>lineIn method</primary>
<secondary>of RexxQueue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lineIn method</secondary>
<tertiary>of RexxQueue class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-lineIn--------------------------------------------------><
]]>
</programlisting>

<para>Reads a single line from the Rexx external queue.  If the queue is empty,
<emphasis role="bold">lineIn</emphasis> will wait until a line is added to the queue.
</para>
</section>

<section id="mthRexxQueueLineOut"><title>lineOut</title>
<indexterm><primary>lineOut method</primary>
<secondary>of RexxQueue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lineOut method</secondary>
<tertiary>of RexxQueue class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-lineOut(-+------+-)----------------------------------><
            +-line-+
]]>
</programlisting>

<para>Adds a line to the Rexx external queue in first-in-first-out (FIFO) order.  If
<emphasis role="italic">line</emphasis> is not specified, a null string ("") is added.
</para>
</section>

<section id="mthRexxQueuePull"><title>pull</title>
<indexterm><primary>pull method</primary>
<secondary>of RexxQueue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>pull method</secondary>
<tertiary>of RexxQueue class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-pull--------------------------------------------------><
]]>
</programlisting>

<para>Reads a line from the Rexx external queue.  If the queue is currently empty,
this method will immediately return .nil without waiting for lines to be added to the queue.
</para>
</section>

<section id="mthRexxQueuePush"><title>push</title>
<indexterm><primary>push method</primary>
<secondary>of RexxQueue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>push method</secondary>
<tertiary>of RexxQueue class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-push(-+------+-)----------------------------------><
         +-line-+
]]>
</programlisting>

<para>Adds a line to the Rexx external queue in last-in-last-out (LIFO) order.  If
<emphasis role="italic">line</emphasis> is not specified, a null string ("") is added.
</para>
</section>

<section id="mthRexxQueueQueue"><title>queue</title>
<indexterm><primary>queue method</primary>
<secondary>of RexxQueue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>queue method</secondary>
<tertiary>of RexxQueue class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-queue(-+------+-)----------------------------------><
          +-line-+
]]>
</programlisting>

<para>Adds a line to the Rexx external queue in first-in-first-out (FIFO) order.  If
<emphasis role="italic">line</emphasis> is not specified, a null string ("") is added.
</para>
</section>

<section id="mthRexxQueueQueued"><title>queued</title>
<indexterm><primary>queued method</primary>
<secondary>of RexxQueue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>queued method</secondary>
<tertiary>of RexxQueue class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-queued---------------------------------------------><
]]>
</programlisting>

<para>Returns the count of lines currently in the Rexx external queue.
</para>
</section>

<section id="mthRexxQueueSay"><title>say</title>
<indexterm><primary>say method</primary>
<secondary>of RexxQueue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>say method</secondary>
<tertiary>of RexxQueue class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-say(-+------+-)----------------------------------><
        +-line-+
]]>
</programlisting>

<para>Adds a line to the Rexx external queue in first-in-first-out (FIFO) order.  If
<emphasis role="italic">line</emphasis> is not specified, a null string ("") is added.
</para>
</section>

<section id="mthRexxQueueSet"><title>set</title>
<indexterm><primary>set method</primary>
<secondary>of RexxQueue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>set method</secondary>
<tertiary>of RexxQueue class</tertiary></indexterm>


<programlisting>
<![CDATA[
>>-set(name)----------------------------------><
]]>
</programlisting>

<para>Switches the Rexx external queue associated with RexxQueue instance.  The new queue must have
been previously created.  The method return value is the name of current queue being used by the instance.
</para>
</section>
</section>

<section id="clsStreamSupplier"><title>The StreamSupplier Class</title>
<indexterm><primary>StreamSupplier class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>StreamSupplier class</secondary></indexterm>

<para>A supplier object that will provided stream lines using supplier semantics.</para>
<figure><title>The StreamSupplier class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxStreamSupplierClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The StreamSupplier class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;

<para>Methods inherited from the
<link linkend="clsSupplier">Supplier class</link>.</para>
<simplelist type="vert" columns="3">
<member><link linkend="mthSupplierNew">new (class method)</link></member>
<member><link linkend="mthSupplierAllIndexes">allIndexes</link></member>
<member><link linkend="mthSupplierAllItems">allItems</link></member>
<member><link linkend="mthSupplierAvailable">available</link></member>
<member><link linkend="mthSupplierIndex">index</link></member>
<member><link linkend="mthSupplierInit">init</link></member>
<member><link linkend="mthSupplierItem">item</link></member>
<member><link linkend="mthSupplierNext">next</link></member>
<member><link linkend="mthSupplierSupplier">supplier</link></member>
</simplelist>

</section>

<section id="mthStreamSupplierAvailable"><title>available</title>
<indexterm><primary>available method</primary>
<secondary>of StreamSupplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>available method</secondary>
<tertiary>of StreamSupplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-available---------------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if an item is available
from the supplier (that is, if the
<emphasis role="bold">item</emphasis> method would return a value). It returns
<computeroutput>0</computeroutput> (false) if the collection is empty or the
supplier has already enumerated the entire collection.</para>
</section>

<section id="mthStreanSupplierIndex"><title>index</title>
<indexterm><primary>index method</primary>
<secondary>of StreamSupplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>index method</secondary>
<tertiary>of StreamSupplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-index-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the current
item in the collection. If no item is available, that is, if
<emphasis role="bold">available</emphasis> would
return false, the language processor raises an error.</para>
</section>

<section id="mthStreamSupplierInit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of StreamSupplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of StreamSupplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-init--------------------------------------------------------><
]]>
</programlisting>

<para>Initializes the object instance.</para>
</section>

<section id="mthStreamSupplierItem"><title>item</title>
<indexterm><primary>item method</primary>
<secondary>of StreamSupplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>item method</secondary>
<tertiary>of StreamSupplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-item--------------------------------------------------------><
]]>
</programlisting>

<para>Returns the current item in the collection. If no item is available, that
is, if <emphasis role="bold">available</emphasis>
would return false, the language processor raises an error.
</para>
</section>

<section id="mthStreamSupplierNext"><title>next</title>
<indexterm><primary>next method</primary>
<secondary>of StreamSupplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>next method</secondary>
<tertiary>of StreamSupplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-next--------------------------------------------------------><
]]>
</programlisting>

<para>Moves to the next item in the collection.
By repeatedly sending <emphasis role="bold">next</emphasis>
to the supplier (as long as <emphasis role="bold">available</emphasis>
 returns true),
you can enumerate all items in the collection. If no item is available, that
is, if <emphasis role="bold">available</emphasis>
would return false, the language processor raises an error.
</para>
</section>
</section>

<section id="clsSupplier"><title>The Supplier Class</title>
<indexterm><primary>Supplier class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Supplier class</secondary></indexterm>

<para>You can use a supplier object to enumerate the items a collection
contained at the time of the supplier's creation.</para>
<figure><title>The Supplier class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxSupplierClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Supplier class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>
<para>The following methods return a supplier object: </para>
<itemizedlist>
<listitem><para>The <emphasis role="bold">supplier</emphasis>
methods of the Array, Bag, Directory, List, Queue,
Relation, Set, Table, and Stream classes</para></listitem>
<listitem><para>The <emphasis role="bold">methods</emphasis>
method of the Class class</para></listitem>
</itemizedlist>

<section><title>Inherited Methods</title>

&objclsmthods;

</section>

<section id="mthSupplierNew"><title>new (Class Method)</title>
<indexterm><primary>new method</primary>
<secondary>of Supplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of Supplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new(values,indexes)-----------------------------------------><
]]>
</programlisting>

<para>Returns a new supplier object. The
<emphasis role="italic">values</emphasis> argument must be an
array of values over which the supplier iterates. The
<emphasis role="italic">indexes</emphasis> argument
is an array of index values with a one-to-one correspondence to the objects
contained in the values array. The created supplier iterates over the arrays,
returning elements of the values array in response to
<emphasis role="bold">items</emphasis> messages, and
elements of the indexes array in response to
<emphasis role="bold">index</emphasis> messages. The supplier
iterates for the number of items contained in the values array, returning
the Nil object for any nonexistent items in either array.</para>
</section>

<section id="mthSupplierAllIndexes"<title>allIndexes</title>
<indexterm><primary>allIndexes method</primary>
<secondary>of Supplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allIndexes method</secondary>
<tertiary>of Supplier class</tertiary></indexterm>


<programlisting>
<![CDATA[
>>-allItems--------------------------------------------------------><
]]>
</programlisting>
<para>Returns an array of all index values from the current supplier position to the end of the
supplier.  Once <emphasis role="bold">allIndexes</emphasis> is called, no
additional items can be retrieved from the supplier.  Calls to <emphasis role="bold">available</emphasis>
will return "0" (false).</para>
</section>

<section id="mthSupplierAllItems"<title>allItems</title>
<indexterm><primary>allItems method</primary>
<secondary>of Supplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allItems method</secondary>
<tertiary>of Supplier class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-allItems--------------------------------------------------------><
]]>
</programlisting>
<para>Returns an array of all items from the current supplier position to the end of the
supplier.  Once <emphasis role="bold">allItems</emphasis> is called, no
additional items can be retrieved from the supplier.  Calls to <emphasis role="bold">available</emphasis>
will return "0" (false).</para>
</section>

<section id="mthSupplierAvailable"><title>available</title>
<indexterm><primary>available method</primary>
<secondary>of Supplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>available method</secondary>
<tertiary>of Supplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-available---------------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if an item is available
from the supplier (that is, if the
<emphasis role="bold">item</emphasis> method would return a value). It returns
<computeroutput>0</computeroutput> (false) if the collection is empty or the
supplier has already enumerated the entire collection.</para>
</section>

<section id="mthSupplierIndex"><title>index</title>
<indexterm><primary>index method</primary>
<secondary>of Supplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>index method</secondary>
<tertiary>of Supplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-index-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the current
item in the collection. If no item is available, that is, if
<emphasis role="bold">available</emphasis> would
return false, the language processor raises an error.</para>
</section>

<section id="mthSupplierInit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of Supplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of Supplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-init--------------------------------------------------------><
]]>
</programlisting>

<para>Initializes the object instance.</para>
</section>

<section id="mthSupplierItem"><title>item</title>
<indexterm><primary>item method</primary>
<secondary>of Supplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>item method</secondary>
<tertiary>of Supplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-item--------------------------------------------------------><
]]>
</programlisting>

<para>Returns the current item in the collection. If no item is available, that
is, if <emphasis role="bold">available</emphasis>
would return false, the language processor raises an error.
</para>
</section>

<section id="mthSupplierNext"><title>next</title>
<indexterm><primary>next method</primary>
<secondary>of Supplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>next method</secondary>
<tertiary>of Supplier class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-next--------------------------------------------------------><
]]>
</programlisting>

<para>Moves to the next item in the collection.
By repeatedly sending <emphasis role="bold">next</emphasis>
to the supplier (as long as <emphasis role="bold">available</emphasis>
 returns true),
you can enumerate all items in the collection. If no item is available, that
is, if <emphasis role="bold">available</emphasis>
would return false, the language processor raises an error.
</para>
</section>

<section id="supex"><title>Examples</title>
<indexterm><primary>examples</primary>
<secondary>of Supplier class</secondary></indexterm>
<programlisting>
desserts=.array~of(apples, peaches, pumpkins, 3.14159) /* Creates array */
say "The desserts we have are:"
baker=desserts~supplier             /* Creates supplier object named BAKER */
do while baker~available            /* Array suppliers are sequenced       */
  if baker~index=4
  then say baker~item "is pi, not pie!!!"
  else say baker~item
  baker~next
end

/* Produces: */
/* The desserts we have are: */
/* APPLES                    */
/* PEACHES                   */
/* PUMPKINS                  */
/* 3.14159 is pi, not pie!!! */
</programlisting>
</section>

<section id="mthSupplierSupplier"><title>supplier</title>
<indexterm><primary>supplier method</primary>
<secondary>of Supplier class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>supplier method</secondary>
<tertiary>of Supplier class</tertiary></indexterm>

<programlisting>
<![CDATA[
-supplier------------------------------------------------------><
]]>
</programlisting>
<para>Returns the target supplier as a result.  This method allows an existing
supplier to be passed to methods that expect an object that implements a
<emphasis role="bold">supplier</emphasis> method as an argument.
</para>
</section>
</section>

</section>

