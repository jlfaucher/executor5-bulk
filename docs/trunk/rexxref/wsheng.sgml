<!--#########################################################################
    #
    # Description: Open Object Rexx: Reference SGML file.
    #
    # Copyright (c) 2005-2007, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<chapter id="wsheng"><title>Windows Scripting Host Engine</title>
<indexterm><primary>WSH engine</primary></indexterm>
<indexterm><primary>Windows Scripting engine</primary></indexterm>
<para>This chapter describes the use of Object Rexx as a Windows Scripting
Host (WSH) engine.</para>

<section id="oraswsheng">
<title>Object Rexx as a Windows Scripting Host Engine</title>
<para>Object Rexx is automatically enabled as an engine for Windows Scripting
Host at installation. This chapter gives a brief description of WSH and how
Object Rexx interacts with it, and shows you how you can best use this feature.
</para>
<para>The easiest part of this feature to understand and to become immediately
productive with is its ability to use Object Rexx as a scripting language
for Microsoft's Web browser, Internet Explorer. To go quickly to using this
technique, see <link linkend="invbybro">Invocation by the Browser</link>.</para>

<section id="wshoview"><title>Windows Scripting Host Overview</title>
<para>Windows Scripting Host (WSH) is a unified scripting environment for all
Microsoft products. It is usable by any macro language that follows its
specification. WSH is the mechanism that allows users to customize and
dynamically control the products that support its hosting standard.</para>
<para>The Windows Scripting Host engine for Object Rexx enables
users to drive Microsoft's products, notably Internet Explorer. Other products
that can be driven include the components of the Office suite, like Word,
Excel, and so on.</para>
<para>The difference between WSH and the OLE support that Object Rexx provides
is the context in which the script resides. OLE scripts are exterior to the
product, and WSH scripts can be embedded in the files that the product uses.
The advantage of embedding the script is that the user has fewer files to
manage. The Object Rexx engine for WSH enables users to accomplish this in
a seamless fashion.</para>
<para>There are two components to WSH. The first is the host - the product
that can be scripted. The second is the engine - the product that interprets
the script.</para>
<para>Object Rexx supplies the engine component of WSH.</para>

<section id="gestwsh"><title>The Gestation of WSH</title>
<para>As with many new technologies today, WSH introduces several new concepts
and terms. The best way to describe these is to start with an overview of
the problem that WSH addresses, and its history.</para>
<para>Until recently, Microsoft provided users simply with a
COM (Common Object Model) interface to their office products. COM is a binary,
as opposed to text, command input system. These commands drove the product -
by, for example, telling Microsoft Word to print the current document -
and did not contain any logic or decision-making capabilities. Users who wanted
such capabilities developed them in programs external to the COM object.
Accessing the interface required the user to develop the logic to drive the COM
object at first in C++, then later in Visual Basic. The investment for the user,
in development time, was quite significant.</para>
<para>In order to satisfy customer demand, a particular version of a scripting
language (based on Visual Basic) was developed for each Microsoft product.
In addition, the emergence of scripting languages such as
<trademark class="trade">JavaScript</trademark>, with their ability to
dynamically control Web browsers, led Microsoft to
develop two more scripting languages, VBScript and JScript.</para>
<para>WSH is a consolidation of the scripting language proliferation. Borrowing
heavily from the browser paradigm, the host interprets a language-independent
XML file that contains one or more scripts where each script is encapsulated
in a script (script tag) that denotes the language of the script, and any
other necessary environmental parameters. The host extracts the script from
the file, and passes it to the appropriate interpreter.</para>
</section>

<section id="hprovmic"><title>Hosts Provided by Microsoft</title>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>and Microsoft Internet Explorer</secondary></indexterm>
<para>Microsoft provides three fully-implemented scripting
hosts. They are Microsoft Internet Explorer, CScript,
and WScript. As an expansion on the concept of using a scripting language
to drive external products, CScript and WScript were developed to control
the Windows operating system. The two modules are so similar that they are
sometimes referred to as C/WScript.
<indexterm><primary>WScript</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>WScript</secondary></indexterm>
CScript
<indexterm><primary>CScript</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>CScript</secondary></indexterm>
is intended to be used from the
command line, and WScript is best used in the Windows environment. Both provide
their services to the script through the WScript object. Using the default
method for output <computeroutput>WScript~Echo()</computeroutput>,
CScript sends the output to
a console screen in the same manner as the Object Rexx command
<computeroutput>Say</computeroutput>, whereas
<computeroutput>WScript~Echo()</computeroutput> in a script controlled by
WScript will create a pop-up box in which the user must click the OK button
to make it disappear.</para>
</section>
</section>
</section>

<section id="scrwnsty"><title>Scripting in the Windows Style</title>
<para>Each flavor of WSH has an associated file type. This section gives a brief
example of scripting for each file type, and suggestions that are appropriate
in each case. If you need to, see the appropriate documentation for the exact
syntax of WSH's XML format, and the syntax of an HTML file.</para>

<section id="invbybro"><title>Invocation by the Browser</title>
<indexterm><primary>Microsoft Internet Explorer</primary></indexterm>
<indexterm><primary>invocation by browser (WSH engine)</primary></indexterm>
<indexterm><primary>browser, invocation by (WSH engine)</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>invocation by browser</secondary></indexterm>
<para>Invocation by the Web browser is probably the easiest scripting technique
to illustrate, and the most familiar use of WSH. The following is a small
HTML file that shows Object Rexx as the scripting language. There are three
paragraphs that have the animating power of Object Rexx behind them. Each
uses an Internet Explorer pop-up window to denote a particular mouse action.
The appropriate activity takes place when the mouse is rolled over the first
paragraph, when it leaves the second, and when it is used to click the third.
</para>
<programlisting>
&lt;HTML>
&lt;!--
/******************************************************************/
/* DISCLAIMER OF WARRANTIES. The following [enclosed]             */
/* code is sample code created by Rexx Language Association. This */
/* sample code is not part of any standard or RexxLA              */
/* product and is provided to you solely for the                  */
/* purpose of assisting you in the development of your            */
/* applications.  The code is provided "AS IS", without           */
/* warranty of any kind.  RexxLA shall not be liable for          */
/* any damages arising out of your use of the sample              */
/* code, even if they have been advised of the                    */
/* possibility of such damages.                                   */
/******************************************************************/
 !-->

&lt;HEAD>
  &lt;TITLE>A simple event&lt;/TITLE>
  &lt;script language="Object Rexx" >
::Routine Display Public
   Window~Alert(Arg(1))
   Return   "something to keep the mouseover function call happy"
   &lt;/script>
&lt;/HEAD>

&lt;BODY BGCOLOR="#ffffff">
  &lt;FONT FACE="Arial, Helvetica" COLOR="#f00000">
  &lt;H1>How to use events&lt;/H1>

  &lt;FONT COLOR="#000000">
  &lt;P>Moving the cursor over the following paragraphs will cause two
  events, respectively: one when you move onto the text, and one when
  you leave it. At both times a pop-up message will inform you about this.&lt;/P>

  &lt;!-- in both cases the "alert" function of the object "window" is called !-->
  &lt;FONT COLOR="#0000ff">
  &lt;P onmouseout="alert("Cursor left paragraph")" LANGUAGE="Object Rexx">
  Event takes place when cursor leaves this paragraph.&lt;/P>

  &lt;P onmouseover="a = Display(&apos;Cursor is over paragraph&apos;)"
LANGUAGE="Object Rexx">
Event takes place when cursor moves over this paragraph.&lt;/P>

  &lt;FONT COLOR="#000000">
  &lt;P>The following paragraph reacts when you click it:&lt;/P>

  &lt;FONT COLOR="#0000ff">
  &lt;P onclick="call Display "Thank you! The current time is" time()"," date()"
  LANGUAGE="Object Rexx">Click me!&lt;/P>
  &lt;/FONT>

&lt;/BODY>

&lt;/HTML>
</programlisting>
<para>The important things to note in this example are:</para>
<itemizedlist>
<listitem><para>The <computeroutput>LANGUAGE="Object Rexx"</computeroutput>
attribute on each tag that contains code.</para></listitem>
<listitem><para>The &lt;<computeroutput>script></computeroutput>
tag in the &lt;<computeroutput>HEAD></computeroutput> section defines
a function that can be called from any other code section in this HTML file.
<itemizedlist>
<listitem><para>The Object Rexx keyword
<computeroutput>PUBLIC</computeroutput> must be on the
<computeroutput>::ROUTINE</computeroutput> statement, or Object Rexx will not
be able to make that name accessible
outside of that script block.</para></listitem>
<listitem><para>The <computeroutput>Window</computeroutput> object is
accessible, even though it was not declared and the
<computeroutput>::ROUTINE</computeroutput> statements have the variable scope
of an external routine.</para></listitem>
<listitem><para>Some text was put on the
<computeroutput>RETURN</computeroutput> statement simply as a precaution.
Those familiar with Object Rexx know that routines called as functions demand
a return value.</para></listitem>
</itemizedlist>
</para></listitem>
<listitem><para>All of the code for the
<computeroutput>mouseout=</computeroutput> is completely contained within
the &lt;<computeroutput>p></computeroutput>
and &lt;<computeroutput>/p></computeroutput> tags.
<itemizedlist>
<listitem><para>Also note the lack of the leading
<computeroutput>"Window~"</computeroutput> on the
Alert(). See <link linkend="chorwsh">Changes in Object Rexx due to WSH</link>.
</para></listitem>
</itemizedlist>
</para></listitem>
<listitem><para>The second event references the routine that was defined earlier
as a function. The return value is assigned to the variable "a", and discarded
as soon as the event finishes processing. Unlike the situation in JScript,
function return values in WSH must be used in an expression, or assigned to
a variable.</para></listitem>
<listitem><para>The third event also references the routine that was defined
earlier, but this time as a procedure and not as a function. The
<computeroutput>CALL</computeroutput> statement forces this kind of access.
<itemizedlist>
<listitem><para><computeroutput>CALL</computeroutput> statements do not produce
an error if no value is returned. If a value is returned, and
<computeroutput>CALL</computeroutput> was used to activate the routine,
the value can be obtained from the special variable
<computeroutput>RESULT</computeroutput>.</para></listitem>
</itemizedlist>
</para></listitem>
</itemizedlist>
<para>Additional examples can be found in the Samples\WSH subdirectory of your
Object Rexx for Windows installation directory.</para>
</section>

<section id="wshfifor"><title>WSH File Types and Formats</title>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>file types</secondary></indexterm>
<para>Two main file types are used by WSH. Both follow an XML format that wraps
the script code. The XML tags are interpreted by C/WScript, and direct it
to the correct scripting engine to process the code inside. The file type
<computeroutput>.wsf</computeroutput> is used to define scripts that are
executed as commands. This is similar to the conventional way of
invoking Object Rexx in the Windows environment. The file type
<computeroutput>.wsc</computeroutput> is used to define scripts that are
treated as COM objects. The XML tags here denote the properties, methods,
and events of the COM object, as well as the correct engine to invoke for
scripts.</para>
<para>Note that these XML files are well formed, but not valid. There is no
associated Document Type Definition (DTD).</para>

<section id="wshwsf"><title>.wsf</title>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>.wsf file type</secondary></indexterm>
<para>The <computeroutput>.wsf</computeroutput> file type is as easy to invoke
as HTML, and is very similar in appearance, with only minor differences.
The <computeroutput>.wsf</computeroutput> file
is used to drive the operating system in the same way that an HTML file is
used to drive the browser. The file is an Object Rexx script file with an
XML wrapper.</para>
<para> The following sample prints the version of the JScript engine and the
version of the scripting host. If this file had the name
<computeroutput>"SimpleORexx.wsf</computeroutput>", the command to invoke it
would be <computeroutput>"CScript //nologo SimpleORexx.wsf"</computeroutput>,
or <computeroutput>"WScript //nologo SimpleORexx.wsf"</computeroutput>.</para>
<programlisting>
&lt;?xml version="1.0"?>
&lt;?job error="true" debug="true" ?>

&lt;package id="wstest">

&lt;!--
/******************************************************************/
/* DISCLAIMER OF WARRANTIES. The following [enclosed]             */
/* code is sample code created by Rexx Language Association. This */
/* sample code is not part of any standard or RexxLA              */
/* product and is provided to you solely for the                  */
/* purpose of assisting you in the development of your            */
/* applications.  The code is provided "AS IS", without           */
/* warranty of any kind.  RexxLA shall not be liable for          */
/* any damages arising out of your use of the sample              */
/* code, even if they have been advised of the                    */
/* possibility of such damages.                                   */
/******************************************************************/
 !-->

&lt;!--  Just a small file to demonstrate the *.wsf file format, and
    ---  what Windows provides by default.
    -->
&lt;job idid="RunByDefault">

&lt;!---
  ---   These functions are provided by WSH.
  -->
 &lt;script language="JScript">&lt;![CDATA[


function GetScriptEngineInfo(){
   var s;
   s = ""; // Build string with necessary info.
   s += ScriptEngine() + " Version ";  //  Except this function.  It can
                                       // only be accessed from JScript
                                       // or VBscript.
   s += ScriptEngineMajorVersion() + ".";
   s += ScriptEngineMinorVersion() + ".";
   s += ScriptEngineBuildVersion();
   return(s);
   }


]]&gt;&lt;/script>
&lt;!---
  ---  Not all of the script needs to be within one tag, or use the
  ---  same language.
  -->
 &lt;script language="Object Rexx">&lt;![CDATA[

Say "This is "GetScriptEngineInfo()
Ver = "Accessing the version info from Object Rexx yields"
Ver = Ver ScriptEngineMajorVersion()"."
Ver = Ver||ScriptEngineMinorVersion()"."ScriptEngineBuildVersion()
Say Ver

WScript~Echo("Done!")

]]&gt;&lt;/script>
&lt;/job>

&lt;/package>

</programlisting>
<para>The important things to note in this example are:</para>
<itemizedlist>
<listitem><para>Accept the two XML tags
(<computeroutput>&lt;? ... ?></computeroutput>) at the beginning
as boilerplate, although the <computeroutput>debug="true"</computeroutput>
can also be <computeroutput>debug="false"</computeroutput> without any
detrimental effect.</para></listitem>
<listitem><para>All XML tag names and attributes are in lower case.</para>
</listitem>
<listitem><para>All XML tags have a beginning and an end tag. The beginning
tag looks like &lt;<computeroutput>tag></computeroutput>, and the end
tag &lt;<computeroutput>/tag></computeroutput>. Where the
tag contains only attributes, and there is no content between the beginning
and the end tag, it is acceptable to abbreviate
&lt;<computeroutput>tag attribute="">&lt;/tag></computeroutput> to
&lt;<computeroutput>tag attribute=""/></computeroutput>.</para></listitem>
<listitem><para>Comments are the same as in HTML.</para></listitem>
<listitem><para>Following the &lt;<computeroutput>script></computeroutput>
tag is the tag &lt;<computeroutput>![CDATA[</computeroutput>, and preceding
the &lt;<computeroutput>script/></computeroutput> tag is ]]&gt;.
This tells the XML parser to ignore this text. If this is not done, many of
the operators and special characters in the script will confuse the XML parser,
and it will abort the script.</para></listitem>
<listitem><para>There are several &lt;<computeroutput>script></computeroutput>
tags; here Object Rexx is invoking a JScript function.</para></listitem>
<listitem><para>The functions that begin with
<computeroutput>ScriptEngine...</computeroutput> and the
WScript object are not declared, yet Object Rexx finds them. They are implicit,
and their scope is global.</para></listitem>
</itemizedlist>
<para>Additional examples can be found in the Samples\WSH subdirectory of your
Object Rexx for Windows installation directory.</para>
</section>

<section id="wshwsc"><title>.wsc</title>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>.wsc file type</secondary></indexterm>
<para>The <computeroutput>.wsc</computeroutput> file type is much more
elaborate than the <computeroutput>.wsf</computeroutput> type. Since a
<computeroutput>.wsc</computeroutput> file is used as a COM object, the XML
must describe the object in a way that is independent of the script language.
Consider the following example.</para>
<programlisting>
&lt;?xml version="1.0"?>
&lt;?component error="true" debug="true" ?>

&lt;package id="SimpleObjectRexxCOMScriptTest">

&lt;!--
/******************************************************************/
/* DISCLAIMER OF WARRANTIES. The following [enclosed]             */
/* code is sample code created by Rexx Language Association. This */
/* sample code is not part of any standard or RexxLA              */
/* product and is provided to you solely for the                  */
/* purpose of assisting you in the development of your            */
/* applications.  The code is provided "AS IS", without           */
/* warranty of any kind.  RexxLA shall not be liable for          */
/* any damages arising out of your use of the sample              */
/* code, even if they have been advised of the                    */
/* possibility of such damages.                                   */
/******************************************************************/
!-->


&lt;!---
  ---  An example script to demonstrate the features provided by the
  ---  COM structure.  Register our own typelib, create methods,
  ---  and create a property.
  !-->


&lt;!---

  ---    This section registers the script as a COM
  ---  object when Register is chosen from the list of commands
  ---  that appear when this file is right-clicked.
  ---
  ---    The value of progid= is how the world will find us.
  ---  Two GUID&apos;s are needed, one for the COM object, and one
  ---  for the Typelib that will be generated. The routine&apos;s
  ---  Register and Unregister mimic those required in a COM
  ---  *.dll.  Even within these routines, there is full
  ---  Object Rexx capability.
  !-->
&lt;component id="SimpleORexxCOM">
  &lt;registration
     progid="SimpleObjectRexx.Com"
     description="Test of the COM scriptlet interface as seen by Object
     Rexx."
     version="1.0"
     clsid="{6550bac9-b31d-11d4-9306-b9d506515f14}">
   &lt;script language="Object Rexx">&lt;![CDATA[
::Routine Register Public
  Shell = .OLEObject~New("WScript.Shell")
  Typelib = .OLEObject~New("Scriptlet.TypeLib")
  Shell~Popup("We are registering, n o w . . . .")
     /*
      *  Please note that the name that follows must match
      * our file name exactly, or this fails when registering
      * with an "OLE exception", Code 800C0005 or Code 800C0009.
      */
     Typelib~AddURL("SimpleORexxCOM.wsc")
     Typelib~Path= "SimpleORexxCOM.tlb"
     Typelib~Doc = "Test component typelib for Simple Object Rexx.Com"
     Typelib~Name = "Test component typelib for Simple Object Rexx.Com"
     Typelib~MajorVersion = 1
     Typelib~MinorVersion = 0
     Typelib~GUID = "{6550bac5-b31d-11d4-9306-b9d506515f14}"
     Typelib~Write()
     Typelib~Reset()
     Shell~Popup("We&apos;ve really done it n o w . . . .")

   ::Routine Unregister Public
     Shell = .OLEObject~New("WScript.Shell")
     Shell~Popup("We are outa here!")

     ]]&gt;&lt;/script>
    &lt;/registration>

&lt;!---
  ---    This section is what describes this COM object to the outside
  ---  world. There is one property, and there are two methods named.
  ---  One of the methods is the default, since its dispid is 0.
  ---  Object Rexx does not support calling the default in a shorthand
  ---  manner. All calls are as follows:
  ---
  ---  Obj = .OLEObject~New("SimpleObjectRexx.Com")
  ---  Obj~DefaultMethod("Some Parm")
  ---
!-->
&lt;public>
  &lt;property name="ExternalPropertyName"
internalName="InternalPropertyName" dispid="3">
     &lt;/property>
  &lt;method name="NamedRoutine">
     &lt;parameter name="NamedParameter"/>
     &lt;/method>
  &lt;method name="DefaultMethod" dispid="0">
     &lt;parameter name="ReallyForTheOutsideWorld" />
     &lt;/method>
  &lt;/public>


&lt;!---
  ---    This is the actual script code. Note that the property
  ---  is declared at the highest scope. If this is not done,
  ---  then the property will not be found, and the script
  ---  will not abend when the property is referenced.
!-->
  &lt;script language="Object Rexx" >&lt;![CDATA[
InternalPropertyName = "Sample Property"

::Routine NamedRoutine Public
say "There are "Arg()" args."
a = RxMessageBox("Is executing, now.","NamedRoutine","OK",)
  Return

::Routine DefaultMethod Public
say "There are "Arg()" args."
a = RxMessageBox("Is executing, now.","DefaultMethod","OK",)
WShell = .OLEObject~New("WScript.Shell")
a = WShell~Popup("A message via an implicit COM object.");
  Return  "a value"

  ]]&gt;&lt;/script>

&lt;/component>

&lt;/package>

</programlisting>
<para>The important things to note are:</para>
<itemizedlist>
<listitem><para>There are three distinct sections in this file, and two of them
contain Object Rexx code.
<itemizedlist>
<listitem><para>The first section identifies this as a COM object. The
<computeroutput>progid=</computeroutput>,
<computeroutput>version</computeroutput>=, and
<computeroutput>clsid=</computeroutput> attributes of the
<computeroutput>&lt;registration&gt;</computeroutput> tag are given so that
this file can be entered into the Windows Registry
as a COM object. This is one of the sections that has code. The code here
generates the Typelib when the script is registered as a COM object.
</para></listitem>
<listitem><para>The second section lists all of the entry points to this object,
their parameters, and any data that is being externalized. When the Typelib is
generated, this information is used to create its contents. This is more of a
designer's wish list than something that is enforced. The designer states what
he or she believes to be the minimal number of parameters. The designer must
then enforce this within the subroutine. However, be aware that other routines
calling these listed here may pass more, or fewer, parameters than this section
suggests. This is especially true for procedures named with
<computeroutput>&lt;method&gt;</computeroutput> tags. WSH passes the named
parameter <computeroutput>THIS</computeroutput>, which Object
Rexx passes on to the routine.</para></listitem>
<listitem><para>The third section is the actual code.</para></listitem>
</itemizedlist></para></listitem>
<listitem><para>Read the comments before each section; they contain important
information about that particular section.</para></listitem>
<listitem><para>Any code that is put in the same scope as the property being
assigned its value is called immediate code. Immediate code
is executed when the COM object is loaded, before any of its pieces (methods,
properties, or events) are accessed. It executes even if none of the external
pieces are accessed.</para></listitem></itemizedlist>
<para>Additional examples can be found in the Samples\WSH subdirectory of your
Object Rexx for Windows installation directory.</para>
</section>
</section>

<section id="invcompr"><title>Invocation from a Command Prompt</title>
<indexterm><primary>invocation from a command prompt (WSH engine)</primary>
</indexterm>
<indexterm><primary>command prompt, invocation from (WSH engine)</primary>
</indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>invocation from a command prompt</secondary></indexterm>
<para>Invocation from a command prompt covers many possible means: </para>
<itemizedlist>
<listitem><para>Opening a DOS window to type the command into;</para></listitem>
<listitem><para>Selecting Start-&gt;Run from the Windows taskbar;</para>
</listitem>
<listitem><para>Starting from a file association made in Windows Explorer.
</para></listitem></itemizedlist>
<para>A conventional Object Rexx file is one in which every line is valid Object
Rexx syntax, and makes no assumptions about global objects. It contains no
XML wrapper as described in the section on
<computeroutput>.wsf</computeroutput> files.</para>
<para>Consider what happens when a file named
<computeroutput>WSH.rex</computeroutput> contains the single line:
<computeroutput>&apos;WScript~Echo("WSH is available.")&apos;</computeroutput>; another
file named <computeroutput>WSH.wsf</computeroutput>
contains the same line of code in the .wsf wrapper
described above; and another file, <computeroutput>Safe.rex</computeroutput>,
contains the line
<computeroutput>"Say &apos;Conventional Rexx file&apos; Arg(1)"</computeroutput>.</para>

<section id="asconorf"><title>As a Conventional Object Rexx File</title>
<para>From a command prompt, <computeroutput>"Rexx WSH.rex"</computeroutput>,
will stop with an error 97:
<computeroutput>Object "WScript" does not understand message "Echo</computeroutput>".
</para>
<para>From a command prompt, <computeroutput>"Rexx WSH.wsf"</computeroutput>,
will stop with an error 35:
<computeroutput>Invalid expression detected at "&lt;"</computeroutput>.</para>
<para>From a command prompt,
<computeroutput>"Rexx Safe.rex GREAT!"</computeroutput>, produces one
line of output,
<computeroutput>"Conventional Rexx File GREAT!"</computeroutput>.</para>
</section>

<section id="aswinshf"><title>As a Windows Scripting Host File</title>
<para>Both CScript and WScript will invoke a file from the command line. All
of their parameters begin with a double slash. Two useful parameters are:
<computeroutput>//nologo</computeroutput> and
<computeroutput>//e:</computeroutput>. The
<computeroutput>//nologo</computeroutput> parameter prevents
the banner from being displayed, and <computeroutput>//e:</computeroutput>
tells WSH not to interpret this file, and to pass the complete contents to the
named engine. Enter <computeroutput>CScript</computeroutput> or
<computeroutput>WScript</computeroutput> with no parameters or file names to
see a complete list of parameters.</para>
<para>WScript converts all WScript~Echo() output into pop-up text boxes,
whereas with CScript they are displayed as output lines in a DOS window. If
CScript is executed from outside a DOS window (either from Start-&gt;Run,
or from the use of Windows Explorer), a DOS window will be
created for the output. Note, however, that it is removed when the script
is complete. Usually, this means that the lifetime of the DOS window is long
enough for a person to detect it, but not to actually read it.</para>
<para>From a command prompt,
<computeroutput>"cscript //e:"Object Rexx" WSH.rex"</computeroutput> produces
one line of output, <computeroutput>"WSH is available."</computeroutput>
From a command prompt,
<computeroutput>"wscript //e:"Object Rexx" WSH.rex"</computeroutput>,
produces a pop-up box that contains the title
<computeroutput>"Windows Script Host</computeroutput>", an OK button,
and the text <computeroutput>"WSH is available."</computeroutput></para>
<para>From a command prompt,
<computeroutput>"cscript //e:"Object Rexx" WSH.wsf"</computeroutput> will
stop with an error 35:
<computeroutput>Invalid expression detected at "&lt;"</computeroutput>. From
a command prompt,
<computeroutput>"wscript //e:"Object Rexx" WSH.wsf"</computeroutput>, will seem
as if it produced no output at all. Though Object Rexx is still generating
the error message, WScript does not detect the output to STDOUT, and no DOS
window is created.</para>
<para>From a command prompt,
<computeroutput>"cscript //e:"Object Rexx" Safe.rex GREAT!"</computeroutput>
produces one line of output,
<computeroutput>"Conventional Rexx File"</computeroutput>. Note
the lack of the word GREAT!. WSH does not pass the command line
<computeroutput>args</computeroutput> to Object Rexx. The
<computeroutput>WScript~Arguments</computeroutput> method/object
must be used, as in the following code:</para>
<programlisting>
/*    Note that the WScript object is not declared. It just appears
 * courtesy of CScript and WScript
 */
Say  "The arguments as WSH sees them."
If WScript~Arguments~length &gt; 0 Then Do I = 0 To (WScript~Arguments~length - 1)
  Say i WScript~Arguments(i)
  End
Else Say "No arguments were sent."
</programlisting>
<para>From a command prompt,
<computeroutput>"wscript //e:"Object Rexx" Safe.rex GREAT!"</computeroutput>,
will seem as if it produced no output at all. As when
<computeroutput>WSH.wsf</computeroutput> is run by WScript with a known engine
(see the relevant paragraph earlier), Object Rexx is still executing the
<computeroutput>SAY</computeroutput> instruction, WScript does
not detect the output to STDOUT, and no DOS window is created.</para>
</section>
</section>

<section id="invcomob"><title>Invocation as a COM Object</title>
<indexterm><primary>invocation as a COM object (WSH engine)</primary>
</indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>invocation as a COM object</secondary></indexterm>
<para>This is the most intricate of the script files to execute. Multiple steps
are involved, and there is no command that directly invokes the script.
C/WScript cannot be used to directly invoke a
<computeroutput>.wsc</computeroutput> file. It must be processed
by other means first. Once created, the file must be registered.</para>
<para>Once registered, this can be invoked by any program that can call COM
objects. It does not have to be another script; that program could be Visual
Basic or C++. If the COM object is to be invoked by Visual Basic, it is a
good idea to generate a Typelib. This helps Visual Basic to form its parameter
list.</para>

<section id="regcomob"><title>Registering the COM Object</title>
<indexterm><primary>COM object registration (WSH engine)</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>COM object registration</secondary></indexterm>
<para>Use either of two methods to register a
<computeroutput>.wsc</computeroutput> file. The first
is to right-click it in Windows Explorer, and choose
<computeroutput>Register</computeroutput> from the list of commands that
appears. The second is from the command line. For example, to register
<computeroutput>WSH.wsc</computeroutput>, at a command prompt, enter
the command, <computeroutput>"regsvr32 /c WSH.wsf"</computeroutput>.</para>
<para>The GUID in the <computeroutput>clsid=</computeroutput> attribute must
be unique for the machine
the COM object is being registered on. In other words, no other COM object
may use the GUID. Once it is registered, the script cannot be moved. The path
to a COM object is stored in the Registry as a complete path. If the script
is moved, then Windows will not know how to find it.</para>
</section>

<section id="gntyplb"><title>Generating a Typelib</title>
<indexterm><primary>Typelib generation (WSH engine)</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>Typelib generation</secondary></indexterm>
<para>Use either of two methods to generate the Typelib. One is using code in
the Register method of the
<computeroutput>&lt;registration&gt;</computeroutput> section. See the sample
<computeroutput>.wsc</computeroutput> code above for an example of this. The
other is to choose <computeroutput>Generate Type Library</computeroutput>
from the list of commands that appear
when the file name is right-clicked in Windows Explorer.</para>
</section>

<section id="wshnvkg"><title>Invoking</title>
<indexterm><primary>invoking a script (WSH engine)</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>invoking a script</secondary></indexterm>
<para>The easiest method of invoking the script, once it is a COM object, is
to use an OLE-enabled application, such as Object Rexx. The following Object
Rexx code shows how to define the object in Object Rexx, and invoke its methods.
</para>
<programlisting>
&lt;?xml version="1.0"?&gt;
&lt;?job error="true" debug="true" ?&gt;

&lt;package id="wstest"&gt;

&lt;!--
/******************************************************************/
/* DISCLAIMER OF WARRANTIES.  The following [enclosed]            */
/* code is sample code created by Rexx Language Association. This */
/* sample code is not part of any standard or RexxLA              */
/* product and is provided to you solely for the                  */
/* purpose of assisting you in the development of your            */
/* applications.  The code is provided "AS IS", without           */
/* warranty of any kind.  RexxLA shall not be liable for          */
/* any damages arising out of your use of the sample              */
/* code, even if they have been advised of the                    */
/* possibility of such damages.                                   */
/******************************************************************/
 !--&gt;

&lt;!---
  ---     This example shows how easy it is to
  ---  invoke a COM object that is a script by means of
  ---  Object Rexx.
  --&gt;
&lt;job id="RunByDefault"&gt;
  &lt;script language="Object Rexx"&gt;&lt;![CDATA[

Say "Creating the ObjectRexx.Com object. "
Sample = .OLEObject~new("SimpleObjectRexx.Com")
Say "Just before the default method "
ReturnValue = Sample~DefaultMethod("A parm");
ReturnValue = Sample~NamedRoutine("A parm");
  ]]&gt;&lt;/script&gt;
  &lt;/job&gt;
&lt;/package&gt;
</programlisting>
<para>Object Rexx is not the only way to invoke the script. Any application that
can call COM objects can invoke it. For further information, see the relevant
documentation.</para>
</section>

<section id="wshevnts"><title>Events</title>
<indexterm><primary>events (WSH engine)</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>events</secondary></indexterm>
<para>When scripts are turned into COM objects they can initiate events. Several
types of events are supported: the default COM events, HTML or Behavior events,
and ASP events. The type of event that the COM object supports is denoted
by the <computeroutput>type=</computeroutput> attribute of the
<computeroutput>&lt;implements&gt;</computeroutput> tag.
An in-depth discussion of events and how to create, code, and handle them
is beyond the scope of this documentation. However, there are a few concepts
that should be mentioned.</para>

<section id="wshcmevs"><title>COM Events</title>
<indexterm><primary>COM events (WSH engine)</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>COM events</secondary></indexterm>
<para>In the <computeroutput>&lt;public&gt;</computeroutput>
section, where the external attributes of the COM object are disclosed,
<computeroutput>&lt;event&gt;</computeroutput> tags can be added.
They name the events that the script could possibly activate. When the script
that calls the COM object instantiates it by using the method provided by
WScript, rather than the Object Rexx method, it can inform the COM object
that it will handle the events that the COM object fires. Note that when a
script agrees to handle the events of an object, it must handle all of the
events of that object.</para>
<para>For example, suppose the public section looked as follows:</para>
<programlisting>
&lt;public&gt;
  &lt;event name="Event1" /&gt;
  &lt;event name="Event2" /&gt;
&lt;/public&gt;
</programlisting>
<para>and the script that instantiated the COM objects code looked as follows:
</para>
<programlisting>
RexxObject = WScript~CreateObject("ObjectRexx.Com","Event_");
</programlisting>
<para>In that case, the instantiating script would be required to define the
two routines below.</para>
<programlisting>
::Routine Event_Event1 Public
::Routine Event_Event2 Public
</programlisting>
<para>It is not acceptable if only one of the events is supported. Also, note
the naming convention. The second parameter of CreateObject() names the prefix
of the routine name that will support the event. The remainder of the routine
name is composed of the event name from the
<computeroutput>&lt;event&gt;</computeroutput> tag of
the <computeroutput>&lt;public&gt;</computeroutput>
section. Neither the prefix nor the empty string
can be elided. In other words, neither
<computeroutput>CreateObject("object",)</computeroutput> nor
<computeroutput>CreateObject("object","")</computeroutput> is allowed.
The script host will generate an error.</para>
</section>

<section id="wshieevs"><title>Internet Explorer Events</title>
<indexterm><primary>Internet Explorer events (WSH engine)</primary></indexterm>
<indexterm><primary>Microdoft Internet Explorer events (WSH engine)</primary>
</indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>Internet Explorer events</secondary></indexterm>
<para>When coding Internet Explorer events, the user should be aware of the
following. The section of code between the quotes on an HTML tag has to be
complete, with correct syntax. The <computeroutput>THIS</computeroutput>
object is implicity defined for the
scope of the section. If the section calls a function, and the function needs
access to <computeroutput>THIS</computeroutput>, then the section must pass
<computeroutput>THIS</computeroutput> as a
variable to the function. <computeroutput>THIS</computeroutput> is the
browser's object that represents
the tag that the event was fired from. For all of the exact properties and
methods associated with <computeroutput>THIS</computeroutput>,
see the documentation for the corresponding tag.</para>
<para>To illustrate, consider the following code extract:</para>
<programlisting>
&lt;p onmouseover="Call RxMouseOver This" id="SomeTag"&gt;
"HOT" text, get your "HOT" text right here
&lt;/p&gt;

&lt;script language="Object Rexx"&gt;
::Routine RxMouseOver Public
Use Arg This
Text = "This is a &lt;"This~tagName"&gt; tag named &apos;"THIS~id"&apos;"
a = RxMessageBox(Text,"RxMouseOver","OK",)
Return "OK"
&lt;/script&gt;
</programlisting>
<para>The code for the
<computeroutput>onmouseover= "Call RxMouseOver This"</computeroutput>
is complete and correct. If a function call had been used instead, the code
would be something similar to
<computeroutput>"a = RxMouseOver(This)"</computeroutput>. Do not forget to
assign the results of a function call to something. If
<computeroutput>THIS</computeroutput> is not passed
as an argument to RxMouseOver, it will have the default value of a string
whose content is <computeroutput>THIS</computeroutput>.</para>
<indexterm><primary>cancelling Internet Explorer events (WSH engine)</primary>
</indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>cancelling Internet Explorer events</secondary></indexterm>
<para>To cancel Internet Explorer events, the Object Rexx Boolean value
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>boolean values</secondary></indexterm>
<indexterm><primary>boolean values</primary></indexterm>
<computeroutput>.false</computeroutput> must be returned. The integer values
<computeroutput>0</computeroutput> and <computeroutput>1</computeroutput>
are not appropriate alternatives. For example:</para>
<programlisting>
&lt;a onmouseover="call SomeFunction; return .false" href="someURL"&gt;
</programlisting>
</section>
</section>
</section>

<section id="wshsmpls"><title>WSH Samples</title>
<indexterm><primary>samples (WSH engine</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>samples</secondary></indexterm>
<para>There are more features to WSH than are listed here. The Samples\WSH
subdirectory of your Object Rexx for Windows installation directory contains
some appropriate samples and an explanation of the relevant features. Before
running any samples, make sure that the latest version of Windows Scripting
Host is installed on the machine.</para>
<para>Several sample files are stand-alone; these are all of the file types
<computeroutput>.htm</computeroutput>, <computeroutput>.wsf</computeroutput>
or <computeroutput>.rex</computeroutput>. However, all of the samples
covering the aspects of using Object Rexx scripts as COM objects are in pairs
or, in one case, a group of three. One file is the COM object, and the other
is the script that instantiates it. All of the COM objects are of the file
type <computeroutput>.wsc</computeroutput>. The files that instantiate them
are either <computeroutput>.wsf</computeroutput> or
<computeroutput>.rex</computeroutput>. The sample that uses three files
illustrates the <computeroutput>include=</computeroutput> attribute of the
<computeroutput>&lt;script&gt;</computeroutput> tag. All of the
<computeroutput>.wsc</computeroutput> files must be registered before they
can be used (see <link linkend="regcomob">Registering the COM Object</link>).
</para>
<para>To view the <computeroutput>.htm</computeroutput> samples, use Windows
Explorer to view the sample directory.
Right-click the desired sample file, and choose Open With-&gt;Internet Explorer
from the menu that appears.</para>
<para>To view the <computeroutput>.wsf</computeroutput> or
<computeroutput>.rex</computeroutput> samples, use either a DOS
window or Windows Explorer. From Windows Explorer, double-click the desired
file. It will execute automatically. From the DOS window, make the sample
directory the current directory, and use either CScript or WScript to execute
the sample. The file <computeroutput>Print.rex</computeroutput>
is an include file. It is not intended for direct execution.</para>
<para>Samples whose names begin with "w" use only Window pop-up boxes for
output. Samples without the leading "w" are best viewed from the DOS window.
They produce output that will not display in a Windows-only environment. Samples
whose name begins with "call" are used to instantiate the COM objects once
they are installed. If they are not installed, the error message
<computeroutput>"Error 98.909: Class "......" not found"</computeroutput>
will be issued.</para>
</section>
</section>

<section id="wshindev">
<title>Interpretation of and Deviation from the WSH Specification</title>
<indexterm><primary>specification (WSH engine></primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>specification, interpretation of and deviation from</secondary>
</indexterm>
<para>This section deals with a number of issues to do with interpreting the
WSH specification and with deviations from it.</para>

<section id="wadoview">
<title>Windows Scripting Host (WSH) Advanced Overview</title>
<para>Accommodating to WSH has necessitated some deviations from the Object Rexx
standard. To best understand what these deviations are, you need to be aware
of the components of WSH. In addition to the products that are hosts, there are
special COM objects and different mechanisms for initiating
the engine.</para>

<section id="hprovmc2"><title>Hosts Provided by Microsoft</title>
<indexterm><primary>VBScript</primary></indexterm>
<para>Microsoft provides three fully-implemented scripting
hosts. They are Microsoft Internet Explorer,
<indexterm><primary>Microsoft Internet Explorer</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>and Microsoft Internet Explorer</secondary></indexterm>
CScript,
<indexterm><primary>CScript</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>CScript</secondary></indexterm>
and WScript.
<indexterm><primary>WScript</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>WScript</secondary></indexterm>
As an expansion on the concept of using a scripting language
to drive external products, CScript and WScript were developed to control
the Windows operating system. The two modules are so similar that they are
sometimes referred to as C/WScript. CScript is intended to be used from the
command line, and WScript is best used in the Windows environment. Both provide
their services to the script through the WScript object. Using the default
method for output <computeroutput>WScript~Echo()</computeroutput>,
CScript sends the output to
a console screen in the same manner as the Object Rexx command
<computeroutput>Say</computeroutput>, whereas
<computeroutput>WScript~Echo()</computeroutput> in a script controlled by
WScript will create a pop-up box in which the user must click the OK button
to make it disappear.</para>
<para>These are not the only Microsoft products that have WSH capabilities.
The core of C/Wscript is <computeroutput>scrobj.dll</computeroutput>. Several
Microsoft products implement various parts of the scripting host architecture
by using <computeroutput>scrobj.dll</computeroutput>.</para>
</section>

<section id="addcomob"><title>Additional COM Objects</title>
<indexterm><primary>JScript</primary></indexterm>
<para>Since JScript and
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>VBScript</secondary></indexterm>
VBScript were developed primarily to manipulate the Web
browser DOM (Domain Object Model),
<indexterm><primary>Domain Object Model (DOM)</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>Domain Object Model (DOM)</secondary></indexterm>
they lack many of the features associated
with a language that drives an operating system. They have no native facilities
for I/O (Input and Output), or for controlling the file system. These powers
are granted through several additional COM objects.</para>
<para>Most of the literature on WSH describes these objects. Most of the
features in these additional COM objects are native to Object Rexx; for further
information, see <link linkend="oleobjc">The OLEObject Class</link>.
Further documentation on the additional COM objects
is readily available from other sources.</para>
<para>Object Rexx, since it is OLE-enabled, has access to all of these objects.
OLE (Object Linking and Embedding) is an advanced protocol based on COM. Be
aware that the automatic object WScript is only available when Object Rexx
is activated by C/Wscript. Access cannot be obtained if Object Rexx is initiated
by Internet Explorer, or when it is initiated in the classical method
<computeroutput>"Rexx someFile.rex"</computeroutput>, either from the
command line or from a command
issued by the file explorer as an association with a file type. This is not
a limitation of Object Rexx. It is a consequence of the manner in which this
object is loaded.</para>
<para>The WScript object is not registered in the Windows Registry. It exists
only when C/WScript dynamically creates it and then passes the pointer to
Object Rexx. All scripting languages, including
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>JScript</secondary></indexterm>
JScript and VBScript, have this limitation.</para>
</section>

<section id="wshaddoc"><title>Where to Find Additional Documentation</title>
<para>The best source of up-to-date information on WSH is the World Wide Web.
The keyword to use when searching the help facilities provided by Microsoft is
"scripting". If you are using a search engine (available when you click "Search"
on your browser's menu bar), insert "activescript" as the keyword.</para>
<para>In addition, there are several books on the subject. When browsing online
bookstores, use the keyword, "activescript". The MSDN (Microsoft Developers
Network) is a good reference source for the syntax of the XML used to define
the WSH files.</para>
<para>Note that the correct file type to use for the XML file that C/WScript
processes is <computeroutput>.wsf</computeroutput>.
Existing documentation often states misleadingly
that the file type to use is <computeroutput>.ws</computeroutput>.
C/WScript requires the full file
name, including file type, and it processes the file correctly only when the
file type is <computeroutput>.wsf</computeroutput>. This seems to be hard coded
into C/WScript, and no workaround is available.</para>
</section>
</section>

<section id="orwshenv"><title>Object Rexx in the WSH Environment</title>
<para>Object Rexx is fully compatible with the WSH environment. Interaction with
JScript and VBScript is transparent. Legacy applications developed with these
languages will not have to be discarded.</para>

<section id="wshfeav"><title>Object Rexx Features Available</title>
<para>All of the features normally associated with Object Rexx are available
when Object Rexx is loaded by WSH. In addition, OLE support is loaded automatically.
Scripts do not need to include
<computeroutput>&apos;::requires "ORexxOLE.CLS"&apos;</computeroutput>. However,
when Object Rexx is invoked by Internet Explorer, it honors the "sandbox"
settings that the user has set in the browser's security panel. Access to
I/O, the file system, external commands, and COM objects may not be granted.
</para>
</section>

<section id="chorwsh"><title>Changes in Object Rexx due to WSH</title>
<para>To comply with the WSH definition, some of the scoping rules and default
behavior of Object Rexx have been modified. The default behavior has been
altered to allow some objects to be implicitly defined. The normal scoping
rules now allow "global" objects to appear at any procedure depth, without
requiring the use of EXPOSE, or the passing of the object as a parameter.
Second-level objects can now be accessed without specifying the first level.
These changes only apply to objects that WSH provides to Object Rexx. All
other objects and variables behave in the standard ways.</para>
<para>Normally, access to objects requires explicit declaration through one of
the OLE methods, as in:</para>
<programlisting>
"Window = .OLEObject~new("window")"
</programlisting><para>Some,
like WScript, can only be passed in; others -
<computeroutput>window</computeroutput>, for
example - have a history of being implicitly available. Full documentation
is not yet available as to what objects have these features, and therefore
only a few will be mentioned.</para>
<para>As previously mentioned, the WScript object is implicitly available when
Object Rexx is started by C/WScript. The "window" object is implicitly available
when Object Rexx is initiated by Internet Explorer. For events associated
with an HTML tag - <computeroutput>ONMOUSEOVER</computeroutput>, for example -
the scriptlet in the HTML tag has <computeroutput>THIS</computeroutput>
implicitly defined. Unlike <computeroutput>"WINDOW"</computeroutput>,
<computeroutput>THIS</computeroutput> is not global. Typically, this scriptlet
calls a procedure, and <computeroutput>THIS</computeroutput> must be passed
to the procedure if the procedure needs to reference
<computeroutput>THIS</computeroutput>.</para>
<para> Normally, you reference an object by naming the top level object,
followed by the objects at second and subsequent levels, separated by the
tilde symbol (~). However, in order to emulate the current behavior of Internet
Explorer, the engine must resolve object names starting at the second level to
the appropriate top level that owns them. The shorthand
<computeroutput>"Document~WriteLn()"</computeroutput> or
<computeroutput>"Alert()"</computeroutput> is just as acceptable
as <computeroutput>"Window~Document~WriteLn()"</computeroutput> or
<computeroutput>"Window~Alert()"</computeroutput>. It is preferable, as good
coding practice, to explicitly state this relationship. Stating
<computeroutput>"Doc = Window~Document"</computeroutput> removes all
doubt as to which global object WriteLn() is associated with when the statement
<computeroutput>"Doc~WriteLn()"</computeroutput> is encountered.</para>

<note><title>Note</title>
<para>This applies only to global objects supplied by WSH. Objects
created in or supplied by Object Rexx must be named in the normal fashion.
</para>
</note>
</section>

<section id="wshpars"><title>Parameters</title>
<para>A called routine may receive more parameters than expected. This is not
necessarily an error on the caller's part; WSH adds extra parameters on occasion.
When WSH does this, Object Rexx adds the parameters at the end. There is an
exception to this. The documentation is ambiguous in certain sections about
defining properties for scripts that are used as COM objects. If the XML that
defines the script states that a name should be a property, but Object Rexx
finds it defined as a function, then Object Rexx will prepend the parameter
list with <computeroutput>GET</computeroutput> or
<computeroutput>PUT</computeroutput>, depending on the direction of
the property access. For more information, see the sample file
<computeroutput>Call_ExtraParms.wsf</computeroutput> in the Samples\WSH
subdirectory of your Object Rexx for Windows installation directory.</para>
</section>
</section>

<section id="wshprpts"><title>Properties</title>
<indexterm><primary>properties (WSH engine)</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>properties</secondary></indexterm>
<para>WSH defines properties as variable values that a COM script exposes to
outside routines, or strings and numbers extracted from a Typelib. Properties
are to be treated as global variables within the accessing script. Properties
can be implemented as variables or as functions.</para>
<para>Object Rexx supports declaring and defining properties in the intent of
the specification (see the section on
<link linkend="wshwsc"><computeroutput>.wsc</computeroutput> files</link>).
That means that the variables at the highest scope, the closest to
what could be considered as global, may have their values exposed as properties
for other programs to use.</para>
<para>For another program to reference these properties, it must instantiate
the COM object, and the object name must precede the property name. For example:
</para>
<programlisting>
Object = .OLEObject~New("SimpleObjectRexx.Com")
/*  The next line is a property GET */
Say "The value for ExternalPropertyName is:" Object~ExternalPropertyName
Object~ExternalPropertyName = "New Value"  -- This is a PUT
</programlisting>
<para>If you experiment, you will find that there is also a shorthand method,
as follows:</para>
<programlisting>
Object = .OLEObject~New("SimpleObjectRexx.Com")
/*  The next line is a property GET */
Say "The ExternalPropertyName value is:" Object~ExternalPropertyName()
Say Object~ExternalPropertyName("New Value")
</programlisting>
<para>In the case of the second reference, the method is both a PROPERTYGET and
a PROPERTYPUT. It gets the old value, replacing the current one with the
parameter inside the parenthesis. If more than one parameter is passed, the
additional parameters are ignored.</para>

<note><title>Note</title>
<para>This does not always work, and is supported only by Object
Rexx. The cases in which it does not work are where the properties are defined
as functions and not as simple variables. These calls are, in fact, methods
and not property references. When Object Rexx
receives method calls for properties,
it converts them to the appropriate action. In the case of properties defined
as functions, WSH translates the property action into a function action. However,
when the action is initiated as a function and not as a property, WSH does
not always make the appropriate or correct translation.</para>
</note>
<para>Object Rexx does not support the concept of global variables. For a COM
script to reference its own properties, and to react to outside scripts changing
them, then the properties have to be global. To meet the requirement that
properties are global in scope within the defining script, the Built-In Function
(BIF) Value() has been expanded to accept "WSHPROPERTY" as a selector when
referencing properties. As with variables accessed with the "ENVIRONMENT"
selector, these variables persist only during the life of the COM object that
supplies the properties. The next time that the COM is run, the values will
be at initial coded state.</para>
<para>The WSH supports various syntax combinations in the case of implementing
a property as a function. In all combinations, the function is named in the
<computeroutput>&lt;property&gt;</computeroutput> section or tag. It assumes that, when no function is
named, the property is a variable; however, it does not enforce this assumption.
It is possible to name a property and define it as a function. Object Rexx
defines this to mean that the function must be invoked whenever a property
access is attempted. Object Rexx notifies the function of the intended access
direction by inserting <computeroutput>GET</computeroutput> or
<computeroutput>PUT</computeroutput> as the first argument,
and shifting all original arguments accordingly; that is, the original first
argument is the second, the second is the third, and so on. For a demonstration
of this behavior, see the
<computeroutput>Call_PropertyORexx.wsf</computeroutput> sample in the
Samples\WSH subdirectory of your Object Rexx for Windows installation directory.
</para>
<para>The WSH also establishes that Type Library variables may be made accessible
to the script. This violates the default value and scope mechanisms of Object
Rexx. To meet the requirement that properties are global in scope within the
defining script, the Built-In Function (BIF) Value() has been expanded to
accept "WSHTYPELIB" as a selector when referencing elements in a Type Library.
As with variables accessed with the "ENVIRONMENT" selector, these variables
(because they are external to Object Rexx) are global and persist only during
the life of the COM object that supplies the properties. In addition, they
are read only. They are immutable; they cannot be
changed.</para>
</section>

<section id="orsndbx"><title>The Object Rexx "Sandbox"</title>
<indexterm><primary>Object Rexx Sandbox</primary></indexterm>
<indexterm><primary>Sandbox, Object Rexx</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>Object Rexx Sandbox</secondary></indexterm>
<para>Object Rexx contains a feature known as the Security Manager. When this
is enabled it can restrict and audit the other native abilities of Object
Rexx. When used with WSH, Object Rexx honors the IObjectSafety interface and
its methods GetInterfaceSafetyOptions() and SetInterfaceSafetyOptions() by
translating their calls into Security Manager settings. This means that when
Object Rexx is in the Internet Explorer's sandbox, it will restrict itself
to the user's settings. The most secure situation is one where Object Rexx
does not interact with the user's desktop (no reads or writes to the hard
disk, no external commands, and so on).</para>

<section id="implbrow">
<title>Implications of Browser Applications That Run Outside the "Sandbox"</title>
<para>The most useful aspect of this feature is that the user may select the
most secure settings for the Internet, but allow desktop interaction for pages
delivered by the local intranet server. In keeping with the current trend
in IT, Object Rexx allows users to leverage their investment in desktop software.
This facility is intended for clients who use the intranet to lighten the
client, or put a Web interface on legacy applications. A lighter client desktop
means less software on the user desktop to maintain.</para>
</section>
</section>

<section id="duporwsh"><title>Features Duplicated in Object Rexx and WSH</title>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>features duplicated inObject Rexx</secondary></indexterm>
<indexterm><primary>duplicated features in Object Rexx and WSH</primary>
</indexterm>
<indexterm><primary>features duplicated in Object Rexx and WSH</primary>
</indexterm>
<para>Several features are available from both WSH and Object Rexx. However,
the overlap is not exact, and knowing the differences can aid the user in
deciding which is more appropriate to use.</para>

<section id="dclobjs"><title>Declaring Objects with Object Rexx or WScript</title>
<indexterm><primary>objects, declaring (WSH engine)</primary></indexterm>
<indexterm><primary>declaring objects (WSH engine)</primary></indexterm>
<para>When instantiating COM or OLE objects as Rexx objects, either the native
Rexx .OLEObject~new() method, or the WScript~CreateObject()
method can be used. The WSH method has the advantage of allowing the script
to support the events that the object might fire. This is part of its definition,
and no scripting language will have access to this ability in its native object
enabler. The disadvantage is that it is a COM object performing a function
that can be done internally.</para>
<para>Another disadvantage of using the WSH method becomes evident if the script
is executed outside of the context of WSH. The WScript object will not exist.
Therefore, unless the ability to sink events is necessary, it is suggested
that the native Object Rexx method be used.</para>
</section>

<section id="sbcmvhin"><title>Subcom versus the Host Interface</title>
<indexterm><primary>Subcom vs the host interface (WSH engine)</primary>
</indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>Subcom vs the host interface</secondary></indexterm>
<para>With the advent of WSH, there are two ways to use Object Rexx to drive
a product. The first is through the Object Rexx Subcom interface. The second
is for the product to become a Windows Scripting Host. The advantage
of the WSH interface to the product is that it is a COM interface. This positions
the product to take advantage of DCOM. This interface also allows the package
developed by the user to pass objects to Object Rexx.</para>
<para>The disadvantage is the loss of richness contained in the Subcom interface,
and the loss of the close integration that a
<computeroutput>.dll</computeroutput> connection has
over a COM connection. The Subcom interface allows the package to tailor Object
Rexx in ways that are not possible through the COM interface, especially when
the Object Rexx Exit Handlers are implemented.</para>
<para>When writing a product that will be a WSH to Object Rexx, refer to the
sections "Concurrency" and "COM Interfaces" in
"Windows Scripting Host Interface", in
the Object Rexx for Windows: Programming Guide.</para>
</section>

<section id="dllvcom"><title>.dll vs COM</title>
<indexterm><primary>.dll vs COM (WSH engine)</primary></indexterm>
<indexterm><primary>Windows Scripting Host engine</primary>
<secondary>dll vs COM</secondary></indexterm>
<para>There are several issues that should be considered when a choice needs
to be made between a COM or a <computeroutput>.dll</computeroutput> interface.
These issues stem from the intended purposes of each interface.</para>
<para>The <computeroutput>.dll</computeroutput> interface was developed to
extend code reuse by allowing
global scope subroutines and functions to be externalized into a module that
is separate from the executable. When more than one executable wanted these
functions, they all shared the same code that was loaded into memory. The
code that was in the <computeroutput>.dll</computeroutput> executed in the
frame of the <computeroutput>.exe</computeroutput> module. It had the same
address space and other environmental parameters.
Multiple copies of a <computeroutput>*.dll</computeroutput> code exist on a
machine at one time.
The first one that was found in the search path was loaded.</para>
<para>COM was developed to embody a flat model world; only one copy per machine.
It was developed to solve two problems with the
<computeroutput>*.dll</computeroutput> interface.
The first was entry point resolution, and the other was using the wrong
<computeroutput>*.dll</computeroutput> because the search path was not correct.
COM does this by using
RPC, a mechanism that was designed to communicate between different machines.
For conceptual purposes, COM modules then function in a different address
space from that of the invoking
<computeroutput>*.exe</computeroutput>. Therefore, there is overhead
in making any data that is to be passed back and forth opaque on the sender's
side, and converting it into usable data on the receiver's side.</para>
</section>
</section>
</section>

</chapter>
