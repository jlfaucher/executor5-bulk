<!--#########################################################################
    #
    # Description: Open Object Rexx: Reference SGML file.
    #
    # Copyright (c) 2005-2007, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<section id="fundclasses"><title>The Fundamental Classes</title>
<para>This section describes the fundamental classes supplied by ooRexx.</para>

<section id="clsObject"><title>The Object Class</title>
<indexterm><primary>Object class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Object class</secondary></indexterm>

<para>The Object class is the root of the class hierarchy. The instance methods
of the Object class are, therefore, available on all objects.</para>
<figure><title>The Object class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxObjectClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Object class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<section id="mthObjectNew"><title>new (Class Method)</title>
<indexterm><primary>new method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a new instance of the receiver class.</para>
</section>

<section id="mthObjectOperators"><title>Operator Methods</title>
<programlisting>
<![CDATA[
>>-comparison_operator(argument)-------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) or
<computeroutput>0</computeroutput> (false), the result of performing
a specified comparison operation.
</para>
<para>For the Object class, the arguments must match the receiver object. If
they do not match the receiver object, you can define subclasses of the Object
class which override == to match the arguments.</para>
<note><title>Note</title>
<para>The MapCollection classes such as Table and Relation use the == operator
combined with the hashCode method to determine index equivalence.  It is generally necessary
for a class to override the hashCode method whenever the == operator is overridden to maintain
the contract for the hashCode method.
See <link linkend="mthObjectHashCode">hashCode Method</link> for details.
</para></note>
<para>The comparison operators you can use in a message are: </para>
<variablelist>
<varlistentry><term>=, ==
<indexterm><primary>= method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>== method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>=</secondary>
<tertiary>of Object class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>==</secondary>
<tertiary>of Object class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are the same object.
</para></listitem></varlistentry>
<varlistentry><term>\=, >&lt;, &lt;>, \==
<indexterm><primary>\= method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>>&lt; method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>&lt;> method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>\== method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>\=</secondary>
<tertiary>of Object class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>>&lt;</secondary>
<tertiary>of Object class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;></secondary>
<tertiary>of Object class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>\==</secondary>
<tertiary>of Object class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are not the same object (inverse of =).
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthObjectClass"><title>class</title>
<indexterm><primary>class method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>class method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-class-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the class object that received the message that created the
object.</para>
</section>

<section id="mthObjectCopy"><title>copy</title>
<indexterm><primary>copy method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>copy method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-copy--------------------------------------------------------><
]]>
</programlisting>

<para>Returns a copy of the receiver object. The copied object has
the same methods as the receiver object and an equivalent set of object
variables, with the same values.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary><emphasis role="bold">copy</emphasis> method</secondary></indexterm>
<programlisting>
myarray=.array~of("N","S","E","W")
directions=myarray~copy   /* Copies array myarray to array directions */
</programlisting>
</section>

<section id="mthObjectDefaultName"><title>defaultName</title>
<indexterm><primary>defaultName method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>defaultName method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-defaultName-------------------------------------------------><
]]>
</programlisting>

<para>Returns a short human-readable string representation of the object. The
exact form of this representation depends on the object and might not alone
be sufficient to reconstruct the object. All objects must be able to produce
a short string representation of themselves in this way, even if the object
does not have a string value. See
<link linkend="reqstr">Required String Values</link> for more information.
The <emphasis role="bold">defaultName</emphasis>
method of the Object class returns a string that identifies
the class of the object, for example, an Array or a Directory. See also
<link linkend="mthObjectObjectName">objectName</link> and
<link linkend="mthObjectString">string</link>. See
<link linkend="mthObjectObjectNameEquals">objectName=</link> for an
example using <emphasis role="bold">defaultName</emphasis>.</para>
</section>

<section id="mthObjectHashCode"><title>hashCode</title>
<indexterm><primary>hashCode method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hashCode method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hashCode---------------------------------------------------><
]]>
</programlisting>

<para>Returns a string value that is used as a hash value for MapCollection
such as Table, Relation, Set, Bag, and Directory.  This string value
is used by map collections to hash an object for hash table-based searches.</para>
<para>Object implementations are expected to abide by a general contract for hash code usage:</para>
<itemizedlist>
<listitem>
<para>
Whenever hashCode is invoked on the same object more than once, hashCode must return the
same hashcode value, provided than none of the internal information the object uses for an "==" comparision has changed.
</para>
</listitem>
<listitem>
<para>
If two object instances compare equal using the "==" operator, the hashCode methods for both object instances must return
the same value.
</para>
</listitem>
<listitem>
<para>
It is not required that two object instances that compare unequal using "==" need return different hash code
values.
</para>
</listitem>
<listitem>
<para>
Returning a wide range of hash values will produce better performance when an object is used as an index for a
MapCollection.  A return value of 4 string characters is recommended.  The characters in the hash value may be any
characters from '00'x to 'ff'x, inclusive.
</para>
</listitem>
</itemizedlist>
</section>

<section id="mthObjectHasMethod"><title>hasMethod</title>
<indexterm><primary>hasMethod method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasMethod method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasMethod(methodname)---------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the receiver object
has a method named <emphasis role="italic">methodname</emphasis>
(translated to uppercase) or if the target method is a private method.
Otherwise, it returns <computeroutput>0</computeroutput> (false). </para>

<note><title>Note</title>
<para>If you call the <emphasis role="italic">methodname</emphasis> method
although it is private, you receive error 97
<computeroutput>Object method not found</computeroutput> although
<emphasis role="bold">hasMethod</emphasis>
returns <computeroutput>1</computeroutput> (true).</para></note>
</section>

<section id="mthObjectIdentityHash"><title>identityHash</title>
<indexterm><primary>identityHash method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>identityHash method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-identityHash------------------------------------------------><
]]>
</programlisting>

<para>Returns an identity number for the object. This number is guaranteed
to be unique during the run of a program.</para>
</section>

<section id="mthObjectInit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-init--------------------------------------------------------><
]]>
</programlisting>

<para>Performs any required object initialization. Subclasses of the Object
class can override this method.</para>
</section>

<section id="mthObjectInstanceMethod"><title>instanceMethod</title>
<indexterm><primary>instanceMethod method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>instanceMethod method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-instanceMethod(methodname)----------------------------------><
]]>
</programlisting>

<para>Returns an instance of the Method class if the
<emphasis role="italic">methodname</emphasis> is a valid method of the class.
Otherwise it returns the Nil object.</para>
</section>

<section id="mthObjectInstanceMethods"><title>instanceMethods</title>
<indexterm><primary>instanceMethods method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>instanceMethods method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-instanceMethods(classname)----------------------------------><
]]>
</programlisting>

<para>Returns an instance of the Supplier class if the
<emphasis role="italic">classname</emphasis> is the current class or a
parent class. Otherwise it returns the Nil object.
parent class. The returned Supplier object is a list of the methods
available to the <emphasis role="italic">classname</emphasis>.</para>
</section>

<section id="mthObjectInstanceOf"><title>instanceOf</title>
<indexterm><primary>instanceOf method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>instanceOf method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-instanceOf(classname)---------------------------------------><
]]>
</programlisting>

<para>Returns an .True if the recieving object is an instance of the
<emphasis role="italic">classname</emphasis>. Otherwise it
returns .False.</para>
</section>

<section id="mthObjectIsA"><title>isA</title>
<indexterm><primary>isA method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isA method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isA(methodname)---------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the Method class if the
<emphasis role="italic">methodname</emphasis> is a valid method of the class.
Otherwise it returns the Nil object.</para>
<note><para>This method is an alias of the
<link linkend="mthObjectIsInstanceOf">isinstanceOf</link> method.</para>
</note>
</section>

<section id="mthObjectIsInstanceOf"><title>isInstanceOf</title>
<indexterm><primary>isInstanceOf method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isInstanceOf method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isInstanceOf(class)-----------------------------------------><
]]>
</programlisting>

<para>Returns .true ("1") if the object is an instance of the specified
<emphasis role="italic">class</emphasis>.
Returns .false ("0") if the object is not an instance of the specified
<emphasis role="italic">class</emphasis>.
An object is an instance of a class if the object is directly an instance of the
specified <emphasis role="italic">class</emphasis> or if the
<emphasis role="italic">class</emphasis> is in the object's direct or mixin
class inheritance chain. For example:
<programlisting>
<![CDATA[
"abc"~isInstanceOf(.string)             ->  1
"abc"~isInstanceOf(.object)             ->  1
"abc"~isInstanceOf(.mutablebuffer)      ->  0
]]>
</programlisting>
</para>
</section>

<section id="mthObjectObjectName"><title>objectName</title>
<indexterm><primary>objectName method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>objectName method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-objectName--------------------------------------------------><
]]>
</programlisting>

<para>Returns the receiver object's name that the
<emphasis role="bold">objectName=</emphasis> method sets. If
the receiver object does not have a name, this method returns the result of
the <emphasis role="bold">defaultName</emphasis> method. See
<link linkend="reqstr">Required String Values</link> for more information. See
the <emphasis role="bold">objectName=</emphasis>
method for an example using <emphasis role="bold">objectName</emphasis>.</para>
</section>

<section id="mthObjectObjectNameEquals"><title>objectName=</title>
<indexterm><primary>objectName= method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>objectName= method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-objectName=(newname)----------------------------------------><
]]>
</programlisting>

<para>Sets the receiver object's name to the string
<emphasis role="italic">newname</emphasis>.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary><emphasis role="bold">objectName=</emphasis> method</secondary></indexterm>
<programlisting>
points=.array~of("N","S","E","W")
say points~objectName         /* (no change yet) Says: "an Array"    */
points~objectName=("compass") /* Changes obj name POINTS to "compass"*/
say points~objectName         /* Shows new obj name. Says: "compass" */
say points~defaultName        /* Default is still available.         */
                              /* Says "an Array"                     */
say points                    /* Says string representation of       */
                              /* points "compass"                    */
say points[3]                 /* Says: "E"Points is still an array   */
                              /* of 4 items                          */
</programlisting>
</section>

<section id="mthObjectRequest"><title>request</title>
<indexterm><primary>request method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>request method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-request(classid)--------------------------------------------><
]]>
</programlisting>

<para>Returns an object of the <emphasis role="italic">classid</emphasis>
class, or the Nil object if the request cannot be satisfied.</para>
<para>This method first compares the identity of the object's class (see
the <emphasis role="italic">id</emphasis>
method of the Class class in <link linkend="mthClassId">id</link>) to
<emphasis role="italic">classid</emphasis>. If they are the same, the
receiver object is returned as the result.
Otherwise, <emphasis role="bold">request</emphasis>
tries to obtain and return an object satisfying
<emphasis role="italic">classid</emphasis> by sending the receiver object the
conversion message <computeroutput>make</computeroutput> with
the string <emphasis role="italic">classid</emphasis> appended (converted to
uppercase). For example,
a <computeroutput>request("string")</computeroutput> message causes a
<emphasis role="bold">makeString</emphasis> message to be sent.
If the object does not have the required conversion method,
<emphasis role="bold">request</emphasis> returns
the Nil object.</para>
<para>The conversion methods cause objects to produce different representations
of themselves. The presence or absence of a conversion method defines an object's
capability to produce the corresponding representations. For example, lists
can represent themselves as arrays, because they have a
<emphasis role="bold">makeArray</emphasis> method,
but they cannot represent themselves as directories, because they do not have
a <emphasis role="bold">makeDirectory</emphasis>
method. Any conversion method must return an object of the
requested class. For example, <emphasis role="bold">makeArray</emphasis>
must return an array. The language
processor uses the <emphasis role="bold">makeString</emphasis>
method to obtain string values in certain contexts;
see <link linkend="reqstr">Required String Values</link>.</para>
</section>

<section id="mthObjectRun"><title>run</title>
<indexterm><primary>run method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>run method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-run(method-+-------------------------------+-)--------------><
              |             +---------------+ |
              |             V               | |
              +-,Individual---+-----------+-+-+
              |               +-,argument-+   |
              +-,Array,argument---------------+
]]>
</programlisting>

<para>Runs the method object <emphasis role="italic">method</emphasis> (see
<link linkend="clsMethod">The Method Class</link>). The
<emphasis role="italic">method</emphasis> has access to the object variables
of the receiver object, as
if the receiver object had defined the method by using
<emphasis role="bold">setMethod</emphasis>.</para>
<para>If you specify the Individual or Array option, any remaining
<emphasis role="italic">argument</emphasis>s are arguments for the method.
(You need to specify only the first letter;
the language processor ignores all characters following it.) </para>
<variablelist>
<varlistentry><term>Individual</term>
<listitem><para>Passes any remaining arguments to the method as arguments in
the order you specify them.
</para></listitem></varlistentry>
<varlistentry><term>Array</term>
<listitem><para>Requires <emphasis role="italic">argument</emphasis>,
which is an array object. (See <link linkend="clsArray">The Array Class</link>.)
The language processor passes the member items of the array to the method
as arguments. The first argument is at index 1, the second argument at index
2, and so on. If you omitted any indexes when creating the array, the language
processor omits their corresponding arguments when passing the arguments.
</para></listitem></varlistentry>
</variablelist>
<para>If you specify neither Individual nor Array, the method runs without
arguments.</para>
<para>The <emphasis role="italic">method</emphasis> argument can be a string
containing a method source line instead of a method object.
Alternatively, you can pass an array of strings
containing individual method lines. In either case,
<emphasis role="bold">run</emphasis> creates an equivalent
method object.</para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>The <emphasis role="bold">run</emphasis> method is a
private method. See the <emphasis role="bold">setPrivate</emphasis> method
in <link linkend="mthMethodSetPrivate">setPrivate</link>  for details.</para></listitem>
<listitem><para>The RUN method is a protected method.</para></listitem>
</orderedlist>
</section>

<section id="mthObjectSetMethod"><title>setMethod</title>
<indexterm><primary>setMethod method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>setMethod method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-setMethod(methodname-+----------------------+--)-----------------><
                        |         +-,"FLOAT"-+ |
                        +-,method-+----------+-+
                                  +--,scope--+
]]>
</programlisting>

<para>Adds a method to the receiver object's
collection of object methods. The <emphasis role="italic">methodname</emphasis>
is the name of the new
method. (The language processor translates this name to uppercase.) If you
previously defined a method with the same name using
<emphasis role="bold">setMethod</emphasis>, the new method
replaces the earlier one. If you omit <emphasis role="italic">method</emphasis>,
<emphasis role="bold">setMethod</emphasis> makes the
method name <emphasis role="italic">methodname</emphasis> unavailable for the
receiver object. In this
case, sending a message of that name to the receiver object runs the
<emphasis role="bold">unknown</emphasis>
method (if any).</para>
<para>The <emphasis role="italic">method</emphasis> can be a string containing
a method source line instead
of a method object. Or it can be an array of strings containing individual
method lines. In either case, <emphasis role="bold">setMethod</emphasis>
creates an equivalent method object.
</para>

<para>The third parameter describes if the method that is attached to an
object should have object or float scope. "Float" scope means that
it shares the same scope with methods that were defined outside of
a class. "Object" scope means it shares the scope with other,
potentially statically defined, methods of the object it is
attached to.</para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>The <emphasis role="bold">setMethod</emphasis>
method is a private method. See the <emphasis role="bold">setPrivate</emphasis>
method in <link linkend="mthMethodSetPrivate">setPrivate</link>  for details.</para>
</listitem>
<listitem><para>The <emphasis role="bold">setMethod</emphasis>
method is a protected method.</para></listitem>
</orderedlist>
</section>

<section id="mthObjectStart"><title>start</title>
<indexterm><primary>start method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>start method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
                     +---------------+
                     V               |
>>-start(messagename---+-----------+-+-)-----------------------><
                       +-,argument-+
]]>
</programlisting>

<para>Returns a message object (see
<link linkend="clsMessage">The Message Class</link>) and sends it a
<emphasis role="bold">start</emphasis> message
to start concurrent processing. The object receiving the message
<emphasis role="italic">messagename</emphasis> processes this message
concurrently with the sender's continued processing.</para>
<para>The <emphasis role="italic">messagename</emphasis> can be a string or
an array. If <emphasis role="italic">messagename</emphasis> is an array object,
its first item is the name of the message and its
second item is a class object to use as the starting point for the method
search. For more information, see
<link linkend="meths1">Classes and Inheritance</link>.</para>
<para>The language processor passes any
<emphasis role="italic">argument</emphasis>s to the receiver as
arguments for <emphasis role="italic">messagename</emphasis> in the order you
specify them.</para>
<para>When the receiver object has finished processing the message, the message
object retains its result and holds it until the sender requests it by sending
a <emphasis role="bold">result</emphasis> message. For further details,
see <link linkend="mthMessageStart">start</link>.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
world=.WorldObject~new
msg1=world~start("HELLO")                /* same as next line     */
msg2=.message~new(world,"HELLO")~~start  /* same as previous line */

say msg1~result           /* Produces Hello world 21:04:25.065000 */
                          /* for example                          */
say msg2~result           /* Produces Hello world 21:04:25.081000 */
                          /* for example                          */

::class 'WorldObject' public
::method hello
  return "Hello world" time('L')
</programlisting>
</section>

<section id="mthObjectString"><title>string</title>
<indexterm><primary>string method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>string method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-string------------------------------------------------------><
]]>
</programlisting>

<para>Returns a human-readable string representation of the object. The exact
form of this representation depends on the object and might not alone be
sufficient to reconstruct the object. All objects must be able to produce a
string representation of themselves in this way.</para>
<para>The object's string representation is obtained from the
<emphasis role="bold">objectName</emphasis>
method (which can in turn use the
<emphasis role="bold">defaultName</emphasis> method). See also the
<emphasis role="bold">objectName</emphasis>
method (<link linkend="mthObjectObjectName">OBJECTNAME</link>) and the
<emphasis role="bold">defaultName</emphasis> method
(<link linkend="mthObjectDefaultName">defaultName</link>).</para>
<para>The distinction between this method, the
<emphasis role="bold">makeString</emphasis> method (which obtains
string values--see <link linkend="mthStringMakeString">makeString</link>) and the
<emphasis role="bold">request</emphasis>
method (see <link linkend="mthObjectRequest">request</link>) is important. All objects
have a <emphasis role="bold">string</emphasis> method, which returns
a string representation (human-readable form) of the
object. This form is useful in tracing and debugging. Only those objects that
have information with a meaningful string form have a
<emphasis role="bold">makeString</emphasis> method to
return this value. For example, directory objects have a readable string
representation (a Directory), but no string value, and, therefore, no
<emphasis role="bold">makeString</emphasis> method.</para>
<para>Of the classes that Rexx provides, only the String class has a
<emphasis role="bold">makeString</emphasis>
method. Any subclasses of the String class inherit this method by default,
so these subclasses also have string values. Any other class can also provide
a string value by defining a <emphasis role="bold">makeString</emphasis> method.</para>
</section>

<section id="mthObjectUnsetMethod"><title>unsetMethod</title>
<indexterm><primary>unsetMethod method</primary>
<secondary>of Object class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>unsetMethod method</secondary>
<tertiary>of Object class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-unsetMethod(methodname)-------------------------------------><
]]>
</programlisting>

<para>Cancels the effect of all previous
<emphasis role="bold">setMethod</emphasis>s for method
<emphasis role="italic">methodname</emphasis>. It also removes any method
<emphasis role="italic">methodname</emphasis> introduced with
<emphasis role="italic">enhanced</emphasis>
when the object was created. If the object has received no
<emphasis role="bold">setMethod</emphasis> method,
no action is taken. </para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>The <emphasis role="bold">unsetMethod</emphasis>
method is a private method. See the <emphasis role="bold">setPrivate</emphasis>
method in <link linkend="mthMethodSetPrivate">setPrivate</link>  for details.</para>
</listitem>
<listitem><para>The <emphasis role="bold">unsetMethod</emphasis>
method is a protected method.</para></listitem>
</orderedlist>
</section>
</section>

<section id="clsClass"><title>The Class Class</title>
<indexterm><primary>Class class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Class class</secondary></indexterm>

<para>The Class class is like a factory producing the factories that
produce objects. It is a subclass of the
<link linkend="clsObject">Object class</link>. The instance methods of the
Class class are also the class methods of all classes.</para>
<figure><title>The Class class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxClassClass.png" align="left">
</imageobject>
</mediaobject>
</figure>

<section><title>Inherited Methods</title>

&objclsmthods;

</section>

<section id="mthClassBaseClass"><title>baseClass</title>
<indexterm><primary>baseClass method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>baseClass method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-baseClass---------------------------------------------------><
]]>
</programlisting>

<para>Returns the base class associated with the class. If the class is a mixin
class, the base class is the first superclass that is not also a mixin class.
If the class is not a mixin class, the base class is the class receiving the
<emphasis role="bold">baseClass</emphasis> message.</para>
</section>

<section id="mthClassDefaultName"><title>defaultName</title>
<indexterm><primary>defaultName method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>defaultName method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-defaultName-------------------------------------------------><
]]>
</programlisting>

<para>Returns a short human-readable string representation of the class. The
string returned is of the form </para>
<programlisting>
The id class
</programlisting>
<para> where <emphasis role="italic">id</emphasis> is the identifier assigned
to the class when it was created.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>defaultName method</secondary></indexterm>
<programlisting>
say .array~defaultName     /* Displays "The Array class"   */
say .account~defaultName   /* Displays "The ACCOUNT class" */
say .savings~defaultName   /* Displays "The Savings class" */

::class account            /* Name is all upper case       */
::class "Savings"          /* String name is mixed case    */
</programlisting>
</section>

<section id="mthClassDefine"><title>define</title>
<indexterm><primary>define method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>define method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-define(methodname-+---------+-)-----------------------------><
                     +-,method-+
]]>
</programlisting>

<para>Incorporates the method object <emphasis role="italic">method</emphasis>
in the receiver class's collection of instance methods. The language processor
translates the method name <emphasis role="italic">methodname</emphasis>
to uppercase. Using the <emphasis role="bold">define</emphasis>
method replaces any existing definition for
<emphasis role="italic">methodname</emphasis> in the receiver class.</para>
<para>If you omit <emphasis role="italic">method</emphasis>, the method name
<emphasis role="italic">methodname</emphasis> is made
unavailable for the receiver class. Sending a message of that name
to an instance of the class causes the
<emphasis role="bold">unknown</emphasis> method (if any) to be run.</para>
<para>The <emphasis role="italic">method</emphasis> argument can be a string
containing a method source line instead of a method object. Alternatively, you
can pass an array of strings containing individual method lines. Either way,
<emphasis role="bold">define</emphasis> creates an equivalent method object.
</para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>The classes Rexx provides do not permit changes or additions to
their method definitions.</para></listitem>
<listitem><para>The <emphasis role="bold">define</emphasis>
method is a protected method.</para></listitem>
</orderedlist>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>define method</secondary></indexterm>
<programlisting>
bank_account=.object~subclass("Account")
bank_account~define("TYPE",&apos;return "a bank account"&apos;)
</programlisting>
</section>

<section id="mthClassDelete"><title>delete</title>
<indexterm><primary>delete method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>delete method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-delete(methodname)------------------------------------------><
]]>
</programlisting>

<para>Removes the receiver class's definition
for the method name <emphasis role="italic">methodname</emphasis>. If the
receiver class defined <emphasis role="italic">methodname</emphasis> as
unavailable with the <emphasis role="bold">define</emphasis>
method, this definition is
nullified. If the receiver class had no definition for
<emphasis role="italic">methodname</emphasis>, no action is taken. </para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>The classes Rexx provides do not permit changes or additions
to their method definitions.</para></listitem>
<listitem><para><emphasis role="bold">delete</emphasis>
deletes only methods the target class defines. You
cannot delete inherited methods the target's superclasses define.</para>
</listitem>
<listitem><para>The <emphasis role="bold">delete</emphasis>
method is a protected method.</para></listitem>
</orderedlist>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>delete method</secondary></indexterm>
<programlisting>
myclass=.object~subclass("Myclass")        /* After creating a class  */
myclass~define("TYPE",&apos;return "my class"&apos;) /* and defining a method   */
myclass~delete("TYPE")                     /* this deletes the method */
</programlisting>
</section>

<section id="mthClassEnhanced"><title>enhanced</title>
<indexterm><primary>enhanced method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>enhanced method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-enhanced(methods-+---------------+-)------------------------><
                    | +-----------+ |
                    | V           | |
                    +---,argument-+-+
]]>
</programlisting>

<para>Returns an enhanced new instance of the receiver class, with object
methods that are the instance methods of the class, enhanced by the methods in
the collection <emphasis role="italic">methods</emphasis>. The collection
indexes are the names of the enhancing
methods, and the items are the method objects (or strings or arrays of strings
containing method code). (See the description of
<link linkend="mthClassDefine">define</link>.)
You can use any collection that supports a
<emphasis role="bold">supplier</emphasis> method.</para>
<para><emphasis role="bold">enhanced</emphasis> sends an
<emphasis role="bold">init</emphasis> message to the created object, passing the
<emphasis role="italic">argument</emphasis>s specified on the
<emphasis role="bold">enhanced</emphasis> method.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>enhanced method</secondary></indexterm>
<programlisting>
/* Set up rclass with class method or methods you want in your */
/* remote class */
rclassmeths = .directory~new

rclassmeths["DISPATCH"]=d_source     /* d_source must have code for a  */
                                     /* DISPATCH  method.              */
/* The following sends init("Remote Class") to a new instance */
rclass=.class~enhanced(rclassmeths,"Remote Class")
</programlisting>
</section>

<section id="mthClassId"><title>id</title>
<indexterm><primary>id method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>id method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-id----------------------------------------------------------><
]]>
</programlisting>

<para>Returns the class identity (instance) string. (This is the string that
is an argument on the <emphasis role="bold">subClass</emphasis> and
<emphasis role="bold">mixinClass</emphasis> methods.) The string
representations of the class and its instances contain the class identity.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>id method</secondary></indexterm>
<programlisting>
myobject=.object~subClass("my object")  /* Creates a subclass    */
say myobject~id                         /* Produces: "my object" */
</programlisting>
</section>

<section id="mthClassInherit"><title>inherit</title>
<indexterm><primary>inherit method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>inherit method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-inherit(classobj-+-----------+-)----------------------------><
                    +-,classpos-+
]]>
</programlisting>

<para>Causes the receiver class to inherit the instance and class methods of
the class object <emphasis role="italic">classobj</emphasis>. The
<emphasis role="italic">classpos</emphasis> is a class object
that specifies the position of the new superclass in the list of superclasses.
(You can use the <emphasis role="bold">superClasses</emphasis>
method to return the immediate superclasses.)
</para>
<para>The new superclass is inserted in the search order after the specified
class. If the <emphasis role="italic">classpos</emphasis> class is not found in
the set of superclasses, an error is raised. If you do not specify
<emphasis role="italic">classpos</emphasis>, the new superclass
is added to the end of the superclasses list.</para>
<para>Inherited methods can take precedence only over methods defined at or
above the base class of the <emphasis role="italic">classobj</emphasis> in the
class hierarchy. Any subsequent change to the instance methods of
<emphasis role="italic">classobj</emphasis> takes immediate effect
for all the classes that inherit from it.</para>
<para>The new superclass <emphasis role="italic">classobj</emphasis> must be
created with the <emphasis role="bold">mixinClass</emphasis>
option of the ::CLASS directive or the
<emphasis role="bold">mixinClass</emphasis> method and the base class
of the <emphasis role="italic">classobj</emphasis> must be a direct superclass
of the receiver object. The receiver must not already descend from
<emphasis role="italic">classobj</emphasis> in the class
hierarchy and vice versa.</para>
<para>The method search order of the receiver class after
<emphasis role="bold">inherit</emphasis> is the same
as before <emphasis role="bold">inherit</emphasis>, with the addition of
<emphasis role="italic">classobj</emphasis> and its superclasses
(if not already present). </para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>You cannot change the classes that Rexx provides by sending
<emphasis role="bold">inherit</emphasis> messages.</para></listitem>
<listitem><para>The <emphasis role="bold">inherit</emphasis>
method is a protected method.</para></listitem>
</orderedlist>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>inherit method</secondary></indexterm>
<programlisting>
room~inherit(.location)
</programlisting>
</section>

<section id="mthClassIsSubclassOf"><title>isSubClassOf</title>
<indexterm><primary>isSubclassOf method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isSubclassOf method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isSubclassOf(classname)-------------------------------------><
]]>
</programlisting>
<para>Returns .true ("1") if the object is a subclass of the specified
<emphasis role="italic">classname</emphasis>.
Returns .false ("0") if the object is not a a subclass of the specified
<emphasis role="italic">classname</emphasis>.
An object is a subclass of a class if the object is a child of the
specified <emphasis role="italic">classname</emphasis> or if the
<emphasis role="italic">classname</emphasis> is in the object's direct or mixin
class inheritance chain. For example:
<programlisting>
<![CDATA[
"abc"~isSubclassOf(.object)             ->  1
"abc"~isSubclassOf(.mutablebuffer)      ->  0
]]>
</programlisting>
</para>
</section>

<section id="mthClassMetaclass"><title>metaClass</title>
<indexterm><primary>metaClass method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>metaClass method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-metaClass---------------------------------------------------><
]]>
</programlisting>
<para>Returns the receiver class's default metaclass. This is the class used
to create subclasses of this class when you send
<emphasis role="bold">subClass</emphasis> or
<emphasis role="bold">mixinClass</emphasis> messages
(with no metaclass arguments). If the receiver class is an object class (see
<link linkend="objcla">Object Classes</link>), this is also the class used to
create the receiver class.
The instance methods of the default metaclass are the class methods of the
receiver class. For more information about class methods, see
<link linkend="objcla">Object Classes</link>.
See also the description of the <emphasis role="bold">subClass</emphasis>
method in <link linkend="mthClassSubclass">subClass</link>.</para>
</section>

<section id="mthClassMethod"><title>method</title>
<indexterm><primary>method method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>method method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-method(methodname)------------------------------------------><
]]>
</programlisting>

<para>Returns the method object for the receiver class's definition for the
method name <emphasis role="italic">methodname</emphasis>. If the receiver
class defined <emphasis role="italic">methodname</emphasis> as unavailable,
this method returns the NIL object. If the receiver
class did not define <emphasis role="italic">methodname</emphasis>, the
language processor raises an error.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>method method</secondary></indexterm>
<programlisting>
/* Create and retrieve the method definition of a class */
myclass=.object~subClass("My class")   /* Create a class         */
mymethod=.method~new(" ","Say arg(1)") /* Create a method object */
myclass~define("ECHO",mymethod)        /* Define it in the class */
method_source = myclass~method("ECHO")~source     /* Extract it  */
say method_source                 /* Says "an Array"              */
say method_source[1]              /* Shows the method source code */
</programlisting>
</section>

<section id="mthClassMethods"><title>methods</title>
<indexterm><primary>methods method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>methods method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-methods-+----------------+----------------------------------><
           +-(class_object)-+
]]>
</programlisting>

<para>Returns a supplier object for all the instance methods of the receiver
class and its superclasses, if you specify no argument. If
<emphasis role="italic">class_object</emphasis> is the Nil object,
<emphasis role="bold">methods</emphasis>
returns a supplier object for only the instance
methods of the receiver class. If you specify a
<emphasis role="italic">class_object</emphasis>,
this method returns a supplier object containing only the instance methods
that <emphasis role="italic">class_object</emphasis> defines. If you send
appropriate messages to
a supplier object, the supplier enumerates all the instance methods existing
at the time of the supplier's creation. (See
<link linkend="clsSupplier">The Supplier Class</link> for details.)</para>

<note><title>Note</title>
<para>Methods that have been hidden with a
<emphasis role="bold">setMethod</emphasis> or
<emphasis role="bold">define</emphasis> method
are included with the other methods that
<emphasis role="bold">methods</emphasis> returns. The hidden methods
have the Nil object for the associated method.</para></note>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>methods method</secondary></indexterm>
<programlisting>
objsupp=.object~methods
do while objsupp~available
say objsupp~index           /* Says all instance methods */
objsupp~next                /* of the Object class       */
end
</programlisting>
</section>

<section id="mthClassMixinClass"><title>mixinClass</title>
<indexterm><primary>mixinClass method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>mixinClass method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-mixinClass(classid-+-------------------------+-)------------><
                      +-,metaclass-+----------+-+
                                   +-,methods-+
]]>
</programlisting>

<para>Returns a new mixin subclass of the receiver class. You can use this
method to create a new mixin class that is a subclass of the superclass to
which you send the message. The <emphasis role="italic">classid</emphasis>
is a string that identifies the new mixin subclass. You can use the
<emphasis role="bold">id</emphasis> method
to retrieve this string.</para>
<para>The <emphasis role="italic">metaclass</emphasis> is a class object. If
you specify <emphasis role="italic">metaclass</emphasis>, the new subclass is
an instance of <emphasis role="italic">metaclass</emphasis>. (A metaclass is a
class that you can use to create a class, that is, a class
whose instances are classes. The Class class and its subclasses are metaclasses.)
</para>
<para>If you do not specify a <emphasis role="italic">metaclass</emphasis>,
the new mixin subclass is an
instance of the default metaclass of the receiver class. For subclasses of
the Object class, the default metaclass is the Class class.</para>
<para>The <emphasis role="italic">methods</emphasis> is a collection whose
indexes are the names of methods
and whose items are method objects (or strings or arrays of strings containing
method code). If you specify <emphasis role="italic">methods</emphasis>, the new
class is enhanced with class methods from this collection. (The metaclass of
the new class is not affected.)</para>
<para>The <emphasis role="bold">metaClass</emphasis>
method returns the metaclass of a class.</para>
<para>The method search order of the new subclass is the same as that of the
receiver class, with the addition of the new subclass at the start of the
order.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>mixinClass method</secondary></indexterm>
<programlisting>
buyable=.object~mixinClass("Buyable")  /* New subclass is buyable    */
                                       /* Superclass is Object class */
</programlisting>
</section>

<section id="mthClassNew"><title>new</title>
<indexterm><primary>new method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new-+---------------+---------------------------------------><
       |    +-,---+    |
       |    V     |    |
       +-(----arg-+--)-+
]]>
</programlisting>

<para>Returns a new instance of the receiver class, whose object methods are
the instance methods of the class. This method initializes a new instance
by running its <emphasis role="bold">init</emphasis> methods. (See
<link linkend="creo">Initialization</link>.)
<emphasis role="bold">new</emphasis> also sends an
<emphasis role="bold">init</emphasis> message. If you specify args,
<emphasis role="bold">new</emphasis> passes these
arguments on the <emphasis role="bold">init</emphasis> message.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>new method</secondary></indexterm>
<programlisting>
<![CDATA[
/* new method example */
a = .account~new             /* -> Object variable balance=0           */
y = .account~new(340.78)     /* -> Object variable balance=340.78      */
                             /*    plus free toaster oven              */
::class account subclass object
::method init                /* Report time each account created       */
                             /* plus free toaster when more than $100  */
Expose balance
Arg opening_balance
Say "Creating" self~objectName "at time" time()
If datatype(opening_balance, "N") then balance = opening_balance
else balance = 0
If balance > 100 then Say "  You win a free toaster oven"
]]>
</programlisting>
</section>

<section id="mthClassQueryMixinClass"><title>queryMixinClass</title>
<indexterm><primary>queryMixinClass method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>queryMixinClass method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-queryMixinClass---------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the class is a
mixin class, or <computeroutput>0</computeroutput> (false).</para>
</section>

<section id="mthClassSubclass"><title>subclass</title>
<indexterm><primary>subclass method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>subclass method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-subclass(classid-+-------------------------+-)--------------><
                    +-,metaclass-+----------+-+
                                 +-,methods-+
]]>
</programlisting>

<para>Returns a new subclass of the receiver class. You can use this method to
create a new class that is a subclass of the superclass to which you send
the message. The <emphasis role="italic">classid</emphasis> is a string that
identifies the subclass. (You can use the
<emphasis role="bold">id</emphasis> method to retrieve this string.)
</para>
<para>The <emphasis role="italic">metaclass</emphasis> is a class object. If
you specify <emphasis role="italic">metaclass</emphasis>, the new subclass is
an instance of <emphasis role="italic">metaclass</emphasis>. (A metaclass is a
class that you can use to create a class, that is, a class
whose instances are classes. The Class class and its subclasses are metaclasses.)
</para>
<para>If you do not specify a <emphasis role="italic">metaclass</emphasis>,
the new subclass is an instance
of the default metaclass of the receiver class. For subclasses of the Object
class, the default metaclass is the Class class.</para>
<para>The <emphasis role="italic">methods</emphasis> is a collection whose
indexes are the names of methods
and whose items are method objects (or strings or arrays of strings containing
method code). If you specify <emphasis role="italic">methods</emphasis>,
the new class is enhanced with class methods from this collection.
(The metaclass of the new class is not affected.)</para>
<para>The <emphasis role="bold">metaclass</emphasis> method returns the
metaclass of a class.</para>
<para>The method search order of the new subclass is the same as that of the
receiver class, with the addition of the new subclass at the start of the
order.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>subClass method</secondary></indexterm>
<programlisting>
room=.object~subclass("Room")   /* Superclass is .object     */
                                /* Subclass is room          */
                                /* Subclass identity is Room */
</programlisting>
</section>

<section id="mthClassSubclasses"><title>subclasses</title>
<indexterm><primary>subclasses method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>subclasses method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-subclasses--------------------------------------------------><
]]>
</programlisting>

<para>Returns the immediate subclasses of the receiver
class in the form of a single-index array of the required size, in an
unspecified order. (The program should not rely on any order.) The array
indexes range from 1 to the number of subclasses.</para>
</section>

<section id="mthClassSuperClass"><title>superClass</title>
<indexterm><primary>superClass method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>superClass method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-superClass------------------------------------------------><
]]>
</programlisting>

<para>Returns the immediate superclass of the receiver class. The
immediate superclass is
the original class used on a <emphasis role="bold">subClass</emphasis> or a
<emphasis role="bold">mixinClass</emphasis> method. For the Object Class,
<emphasis role="bold">superClass</emphasis> returns .Nil.</para>

<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>superClass method</secondary></indexterm>
<programlisting>
say .object~superclass    -- displays "The NIL object"
say .class~superclass     -- displays "The Object class"
say .set~superclass       -- displays "The Table class"
</programlisting>
</section>

<section id="mthClassSuperClasses"><title>superClasses</title>
<indexterm><primary>superClasses method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>superClasses method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-superClasses------------------------------------------------><
]]>
</programlisting>

<para>Returns the immediate superclasses of the receiver class in the form of
a single-index array of the required size. The immediate superclasses are
the original class used on a <emphasis role="bold">subClass</emphasis> or a
<emphasis role="bold">mixinClass</emphasis> method, plus any additional
superclasses defined with the <emphasis role="bold">inherit</emphasis>
method. The array is in the order in
which the class has inherited the classes. The original class used on a
<emphasis role="bold">subClass</emphasis> or
<emphasis role="bold">mixinClass</emphasis> method is the first item of the
array. The array indexes range
from <computeroutput>1</computeroutput> to the number of superclasses.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>superClasses method</secondary></indexterm>
<programlisting>
z=.class~superClasses
/* To obtain the information this returns, you could use:     */
do i over z
  say i
end
</programlisting>
</section>

<section id="mthClassUninherit"><title>uninherit</title>
<indexterm><primary>uninherit method</primary>
<secondary>of Class class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>uninherit method</secondary>
<tertiary>of Class class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-uninherit(classobj)-----------------------------------------><
]]>
</programlisting>

<para>Nullifies the effect of any previous
<emphasis role="bold">inherit</emphasis> message
sent to the receiver for the class <emphasis role="italic">classobj</emphasis>.
</para>

<note><title>Note</title>
<para>You cannot change the classes that Rexx provides by sending
<emphasis role="bold">uninherit</emphasis> messages.
</para></note>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>uninherit method</secondary></indexterm>
<programlisting>
location=.object~mixinClass("Location")
room=.object~subclass("Room")~~inherit(location) /* Creates subclass */
/* and specifies inheritance */
room~uninherit(location)
</programlisting>
</section>
</section>

<section id="clsString"><title>The String Class</title>
<indexterm><primary>String class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>String class</secondary></indexterm>

<para>String objects represent character-string data values. A character
string value can have any length and contain any characters. If you are familiar
with earlier versions of Rexx you might find the notation for functions more
convenient than the notation for methods. See
<link linkend="funct">Functions</link> for function descriptions.</para>
<figure><title>The String class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxStringClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The String class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.
</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;

<para>Methods inherited from the
<link linkend="clsComparable">Comparable class</link>.</para>
<itemizedlist>
<listitem><para><link linkend="mthComparableCompareTo">compareTo</link></para></listitem>
</itemizedlist>

</section>

<section id="mthStringNew"><title>new (Class Method)</title>
<indexterm><primary>new method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new(stringvalue)--------------------------------------------><
]]>
</programlisting>

<para>Returns a new string object initialized with the characters in
<emphasis role="italic">stringvalue</emphasis>.</para>
</section>

<section id="mthStringArithmeticMethods"><title>Arithmetic Methods</title>
<indexterm><primary>method</primary>
<secondary>arithmetic methods</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-arithmetic_operator(argument)-------------------------------><
]]>
</programlisting>


<note><title>Note</title>
<para>For the prefix - and prefix + operators, omit the parentheses
and <emphasis role="italic">argument</emphasis>.</para></note>
<para>Returns the result of performing the specified arithmetic operation on
the receiver object. The receiver object and the
<emphasis role="italic">argument</emphasis> must be
valid numbers (see <link linkend="numbrs">Numbers</link>). The
<emphasis role="italic">arithmetic_operator</emphasis> can be:
</para>
<variablelist>
<varlistentry><term>+
<indexterm><primary>+ method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>+</secondary></indexterm>
</term>
<listitem><para>Addition
</para></listitem></varlistentry>
<varlistentry><term>-
<indexterm><primary>- method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>-</secondary></indexterm>
</term>
<listitem><para>Subtraction
</para></listitem></varlistentry>
<varlistentry><term>*
<indexterm><primary>* method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>*</secondary></indexterm>
</term>
<listitem><para>Multiplication
</para></listitem></varlistentry>
<varlistentry><term>/
<indexterm><primary>/ method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>/</secondary></indexterm>
</term>
<listitem><para>Division
</para></listitem></varlistentry>
<varlistentry><term>%
<indexterm><primary>% method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>%</secondary></indexterm>
</term>
<listitem><para>Integer division (divide and return the integer part of the
result)</para></listitem></varlistentry>
<varlistentry><term>//
<indexterm><primary>// method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>//</secondary></indexterm>
</term>
<listitem><para>Remainder (divide and return the remainder--not modulo, because
the result can be negative)
</para></listitem></varlistentry>
<varlistentry><term>**
<indexterm><primary>** method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>**</secondary></indexterm>
</term>
<listitem><para>Exponentiation (raise a number to a whole-number power)
</para></listitem></varlistentry>
<varlistentry><term>Prefix -
<indexterm><primary>method</primary>
<secondary>prefix -</secondary></indexterm>
</term>
<listitem><para>Same as the subtraction:
<computeroutput>0 - number</computeroutput>
</para></listitem></varlistentry>
<varlistentry><term>Prefix +
<indexterm><primary>method</primary>
<secondary>prefix +</secondary></indexterm>
</term>
<listitem><para>Same as the addition:
<computeroutput>0 + number</computeroutput>
</para></listitem></varlistentry>
</variablelist>
<para>See <link linkend="numarit">Numbers and Arithmetic</link> for details
about precision, the format of valid
numbers, and the operation rules for arithmetic. Note that if an arithmetic
result is shown in exponential notation, it might have been rounded.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>arithmetic methods of String class</secondary></indexterm>
<programlisting>
<![CDATA[
5+5     ->    10
8-5     ->     3
5*2     ->    10
6/2     ->     3
9//4    ->     1
9%4     ->     2
2**3    ->     8
+5      ->     5             /* Prefix +  */
-5      ->    -5             /* Prefix -  */
]]>
</programlisting>
</section>

<section id="mthStringComparisonMethods"><title>Comparison Methods</title>
<indexterm><primary>method</primary>
<secondary>comparison methods</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-comparison_operator(argument)-------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) or
<computeroutput>0</computeroutput> (false), the result of performing
the specified comparison operation. The receiver object and the
<emphasis role="italic">argument</emphasis> are the terms compared. Both must
be string objects.</para>

<para>The comparison operators you can use in a message are: </para>
<variablelist>
<varlistentry><term>=
<indexterm><primary>= method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>=</secondary>
<tertiary>of String class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are equal (for example, numerically or when
padded)
</para></listitem></varlistentry>
<varlistentry><term>\=, &gt;&lt;, &lt;&gt;
<indexterm><primary>>&lt; method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>&gt;&lt; method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>&lt;&gt; method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>\=</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>>&lt;</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;&gt;</secondary>
<tertiary>of String class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are not equal (inverse of =)
</para></listitem></varlistentry>
<varlistentry><term>&gt;
<indexterm><primary>&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>></secondary></indexterm>
</term>
<listitem><para>Greater than
</para></listitem></varlistentry>
<varlistentry><term>&lt;
<indexterm><primary>&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;</secondary></indexterm>
</term>
<listitem><para>Less than
</para></listitem></varlistentry>
<varlistentry><term>&gt;=
<indexterm><primary>&gt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&gt;=</secondary></indexterm>
</term>
<listitem><para>Greater than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&lt;
<indexterm><primary>\&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&lt;</secondary></indexterm>
</term>
<listitem><para>Not less than
</para></listitem></varlistentry>
<varlistentry><term>&lt;=
<indexterm><primary>&lt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;=</secondary></indexterm>
</term>
<listitem><para>Less than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&gt;
<indexterm><primary>\&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&gt;</secondary></indexterm>
</term>
<listitem><para>Not greater than
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>comparison methods of String class</secondary></indexterm>
<programlisting>
<![CDATA[
5=5        ->     1          /* equal            */

42\=41     ->     1          /* All of these are */
42><41     ->     1          /* "not equal"      */
42<>41     ->     1

13>12      ->     1          /* Variations of    */
12<13      ->     1          /* less than and    */
13>=12     ->     1          /* greater than     */
12\<13     ->     0
12<=13     ->     1
12\>13     ->     1
]]>
</programlisting>
<para>All strict comparison operations have one of the characters doubled that
define the operator. The <computeroutput>==</computeroutput> and
<computeroutput>\==</computeroutput> operators check
whether two strings match exactly. The two strings must be identical (character
by character) and of the same length to be considered strictly equal.</para>
<para>The strict comparison operators such as
<computeroutput>>></computeroutput> or
<computeroutput>&lt;&lt;</computeroutput> carry out a simple
character-by-character comparison. There is no padding
of either of the strings being compared. The comparison of the two strings
is from left to right. If one string is shorter than and a leading substring
of another, then it is smaller than (less than) the other. The strict
comparison operators do not attempt to perform a numeric comparison on the
two operands.</para>
<para>For all the other comparison operators, if both terms
are numeric, the language processor does a numeric comparison (ignoring, for
example, leading zeros--see <link linkend="numcom">Numeric Comparisons</link>).
Otherwise, it treats
both terms as character strings, ignoring leading and trailing blanks and
padding the shorter string on the right with blanks.</para>
<para>Character comparison and strict comparison operations are both
case-sensitive,
and for both the exact collating order can depend on the character set. In
an ASCII environment, the digits are lower than the alphabetic characters,
and lowercase alphabetic characters are higher than uppercase alphabetic
characters.</para>
<para>The strict comparison operators you can use in a message are: </para>
<variablelist>
<varlistentry><term>==
<indexterm><primary>== method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>==</secondary>
<tertiary>of String class</tertiary></indexterm>
</term>
<listitem><para>True if terms are strictly equal (identical)
</para></listitem></varlistentry>
<varlistentry><term>\==
<indexterm><primary>\== method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\==</secondary>
<tertiary>of String class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are NOT strictly equal (inverse of ==)
</para></listitem></varlistentry>
<varlistentry><term>&gt;&gt;
<indexterm><primary>&gt;&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>>></secondary></indexterm>
</term>
<listitem><para>Strictly greater than
</para></listitem></varlistentry>
<varlistentry><term>&lt;&lt;
<indexterm><primary>&lt;&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;&lt;</secondary></indexterm>
</term>
<listitem><para>Strictly less than
</para></listitem></varlistentry>
<varlistentry><term>&gt;&gt;=
<indexterm><primary>&gt;&gt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&gt;&gt;=</secondary></indexterm>
</term>
<listitem><para>Strictly greater than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&lt;&lt;
<indexterm><primary>\&lt;&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&lt;&lt;</secondary></indexterm>
</term>
<listitem><para>Strictly NOT less than
</para></listitem></varlistentry>
<varlistentry><term>&lt;&lt;=
<indexterm><primary>&lt;&lt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;&lt;=</secondary></indexterm>
</term>
<listitem><para>Strictly less than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&gt;&gt;
<indexterm><primary>\&gt;&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&gt;&gt;</secondary></indexterm>
</term>
<listitem><para>Strictly NOT greater than
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
<![CDATA[
"space"=="space"     ->     1         /* Strictly equal     */

"space"\==" space"   ->     1         /* Strictly not equal */

"space">>" space"    ->     1         /* Variations of      */
" space"<<"space"    ->     1         /* strictly greater   */
"space">>=" space"   ->     1         /* than and less than */
"space"\<<" space"   ->     1
" space"<<="space"   ->     1
" space"\>>"space"   ->     1
]]>
</programlisting>
</section>

<section id="mthStringLogicalMethods"><title>Logical Methods</title>
<indexterm><primary>method</primary>
<secondary>logical methods</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-logical_operator(argument)----------------------------------><
]]>
</programlisting>


<note><title>Note</title>
<para>For NOT (prefix \),
<indexterm><primary>\ method</primary></indexterm>
omit the parentheses and <emphasis role="italic">argument</emphasis>.</para>
<para>Returns <computeroutput>1</computeroutput> (true) or
<computeroutput>0</computeroutput> (false), the result of performing
the specified logical operation. The receiver object and the
<emphasis role="italic">argument</emphasis> are character strings that
evaluate to <computeroutput>1</computeroutput> or
<computeroutput>0</computeroutput>.</para>
</note>
<para>The <emphasis role="italic">logical_operator</emphasis> can be: </para>

<variablelist>
<varlistentry><term>&amp;
<indexterm><primary>&amp; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&amp;</secondary></indexterm>
</term>
<listitem><para>AND (Returns <computeroutput>1</computeroutput>
if both terms are true.)
</para></listitem></varlistentry>
<varlistentry><term>|
<indexterm><primary>| method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>|</secondary></indexterm>
</term>
<listitem><para>Inclusive OR (Returns <computeroutput>1</computeroutput>
if either term or both terms are
true.)
</para></listitem></varlistentry>
<varlistentry><term>&amp;&amp;
<indexterm><primary>&amp;&amp; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&amp;&amp;</secondary></indexterm>
</term>
<listitem><para>Exclusive OR (Returns <computeroutput>1</computeroutput>
if either term, but not both terms,
is true.)
</para></listitem></varlistentry>
<varlistentry><term>Prefix \
<indexterm><primary>method</primary>
<secondary>\</secondary></indexterm>
</term>
<listitem><para>Logical NOT (Negates; <computeroutput>1</computeroutput>
becomes <computeroutput>0</computeroutput>, and
<computeroutput>0</computeroutput> becomes <computeroutput>1</computeroutput>.)
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>logical methods of String class</secondary></indexterm>
<programlisting>
<![CDATA[
1&0     ->     0
1|0     ->     1
1&&0    ->     1
\1      ->     0
]]>
</programlisting>
</section>

<section id="mthStringConcatenationMethods"><title>Concatenation Methods</title>
<indexterm><primary>method</primary>
<secondary>concatenation methods</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-concatenation_operator(argument)----------------------------><
]]>
</programlisting>

<para>Concatenates the receiver object with
<emphasis role="italic">argument</emphasis>. (See
<link linkend="strgcon">String Concatenation</link>.)
The <emphasis role="italic">concatenation_operator</emphasis> can be: </para>
<variablelist>
<varlistentry><term>&quot;&quot;</term>
<listitem><para>concatenates without an intervening blank. The abuttal operator
&quot;&quot;
is the null string. The language processor uses the abuttal to concatenate
two terms that another operator does not separate.
</para></listitem></varlistentry>
<varlistentry><term>||
<indexterm><primary>|| method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>||</secondary></indexterm>
</term>
<listitem><para>concatenates without an intervening blank.
</para></listitem></varlistentry>
<varlistentry><term>&quot;&nbsp;&quot;
</term>
<listitem><para>concatenates with one blank between the receiver
object and the <emphasis role="italic">argument</emphasis>.
(The operator &quot;&nbsp;&quot; is a blank.)
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>concatenation methods of String class</secondary></indexterm>
<indexterm><primary>prefix - method</primary></indexterm>
<indexterm><primary>prefix + method</primary></indexterm>
<programlisting>
<![CDATA[
5+5     ->    10
8-5     ->     3
5*2     ->    10
6/2     ->     3
9//4    ->     1
9%4     ->     2
2**3    ->     8
+5      ->     5             /* Prefix +  */
-5      ->    -5             /* Prefix -  */
]]>
</programlisting>
</section>

<section id="mthStringAbbrev"><title>abbrev</title>
<indexterm><primary>abbrev method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>abbrev method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>default</primary>
<secondary>selecting with abbrev method</secondary></indexterm>
<indexterm><primary>selecting a default with abbrev method</primary></indexterm>
<indexterm><primary>testing</primary>
<secondary>abbreviations with abbrev method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-abbrev(info-+---------+-)-----------------------------------><
               +-,length-+
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> if
<emphasis role="italic">info</emphasis> is equal to the leading characters
of the receiving string and the length of
<emphasis role="italic">info</emphasis> is not less than
<emphasis role="italic">length</emphasis>. Returns
<computeroutput>0</computeroutput> if either of these conditions is not met.
</para>
<para>If you specify <emphasis role="italic">length</emphasis>, it must be a
positive whole number or zero. The default for
<emphasis role="italic">length</emphasis> is the number of characters in
<emphasis role="italic">info</emphasis>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>abbrev method</secondary></indexterm>
<programlisting>
<![CDATA[
"Print"~abbrev("Pri")      ->    1
"PRINT"~abbrev("Pri")      ->    0
"PRINT"~abbrev("PRI",4)    ->    0
"PRINT"~abbrev("PRY")      ->    0
"PRINT"~abbrev("")         ->    1
"PRINT"~abbrev("",1)       ->    0
]]>
</programlisting>
<note><title>Note</title>
<para>A null string always matches if a length of
<computeroutput>0</computeroutput>, or the
default, is used. This allows a default keyword to be selected automatically
if desired.</para></note>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
say "Enter option:";   pull option .
select  /* keyword1 is to be the default */
  when "keyword1"~abbrev(option) then ...
  when "keyword2"~abbrev(option) then ...
  ...
  otherwise nop;
end;
</programlisting>
<para>(See <link linkend="bifAbbrev">ABBREV (Abbreviation)</link>
for information about the ABBREV built-in function.)</para>
</section>

<section id="mthStringAbs"><title>abs</title>
<indexterm><primary>abs method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>abs method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>absolute value</primary>
<secondary>finding using the abs method</secondary></indexterm>
<programlisting>
<![CDATA[
>>-abs---------------------------------------------------------><
]]>
</programlisting>

<para>Returns the absolute value of the receiving string. The result has no
sign and is formatted according to the current NUMERIC settings.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>abs method</secondary></indexterm>
<programlisting>
12.3~abs      ->     12.3
"-0.307"~abs  ->     0.307
</programlisting>
<para>(See <link linkend="bifAbs">ABS (Absolute Value)</link>
for information about the ABS built-in function.)</para>
</section>

<section id="mthStringB2x"><title>b2x</title>
<indexterm><primary>b2x method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>b2x method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>binary</primary>
<secondary>to hexadecimal conversion</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>binary to hexadecimal</secondary></indexterm>
<indexterm><primary>unpacking a string</primary>
<secondary>with b2x</secondary></indexterm>

<programlisting>
<![CDATA[
>>-b2x---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string, in character format, that represents the receiving
binary string converted to hexadecimal.</para>
<para>The receiving string is a string of binary
(<computeroutput>0</computeroutput> or <computeroutput>1</computeroutput>)
digits. It can be of any length. It can optionally include blanks (at 4-digit
boundaries only, not leading or trailing). These are to improve readability;
the language processor ignores them.</para>
<para>The returned string uses uppercase alphabetic characters for the values
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput> and does
not include blanks.</para>
<para>If the receiving binary string is a null string,
<emphasis role="bold">b2x</emphasis> returns a null string.
If the number of binary digits in the receiving string is not a multiple of
four, the language processor adds up to three <computeroutput>0</computeroutput>
digits on the left
before the conversion to make a total that is a multiple of four.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>b2x method</secondary></indexterm>
<programlisting>
<![CDATA[
"11000011"~b2x     ->   "C3"
"10111"~b2x        ->   "17"
"101"~b2x          ->   "5"
"1 1111 0000"~b2x  ->   "1F0"
]]>
</programlisting>
<para>You can combine <emphasis role="bold">b2x</emphasis>
with the methods <emphasis role="bold">x2d</emphasis> and
<emphasis role="bold">x2c</emphasis> to convert a binary
number into other forms.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>"10111"~b2x~x2d  ->   "23"   /* decimal 23 */</programlisting>
<para>(See <link linkend="bifB2x">B2X (Binary to Hexadecimal)</link>
for information about the B2X built-in function.)</para>
</section>

<section id="mthStringBitAnd"><title>bitAnd</title>
<indexterm><primary>bitAnd method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>bitAnd method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>ANDing character strings</primary></indexterm>
<indexterm><primary>character</primary>
<secondary>strings, ANDing</secondary></indexterm>
<programlisting>
<![CDATA[
>>-bitAnd-+--------------------+-------------------------------><
          +-(string-+------+-)-+
                    +-,pad-+
]]>
</programlisting>

<para>Returns a string composed of the receiver string and the argument
<emphasis role="italic">string</emphasis> logically ANDed together,
bit by bit. (The encodings of the strings
are used in the logical operation.) The length of the result is the length
of the longer of the two strings. If you omit the
<emphasis role="italic">pad</emphasis> character,
the AND operation stops when the shorter of the two strings is exhausted,
and the unprocessed portion of the longer string is appended to the partial
result. If you provide <emphasis role="italic">pad</emphasis>,
it extends the shorter of the two strings
on the right before the logical operation. The default for
<emphasis role="italic">string</emphasis> is
the zero-length (null) string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>bitAnd method</secondary></indexterm>
<programlisting>
<![CDATA[
"12"x~bitAnd                   ->    "12"x
"73"x~bitAnd("27"x)            ->    "23"x
"13"x~bitAnd("5555"x)          ->    "1155"x
"13"x~bitAnd("5555"x,"74"x)    ->    "1154"x
"pQrS"~bitAnd(,"DF"x)          ->    "PQRS"      /* ASCII   */
]]>
</programlisting>
<para>(See <link linkend="bifBitand">BITAND (Bit by Bit AND)</link>
for information about the BITAND built-in function.)</para>
</section>

<section id="mthStringBitOr"><title>bitOr</title>
<indexterm><primary>bitOr method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>bitOr method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>character</primary>
<secondary>strings, ORing</secondary></indexterm>
<indexterm><primary>ORing character together</primary></indexterm>

<programlisting>
<![CDATA[
>>-bitOr-+--------------------+--------------------------------><
         +-(string-+------+-)-+
                   +-,pad-+
]]>
</programlisting>

<para>Returns a string composed of the receiver string and the argument
<emphasis role="italic">string</emphasis> logically inclusive-ORed, bit by bit.
The encodings of the strings
are used in the logical operation. The length of the result is the length
of the longer of the two strings. If you omit the
<emphasis role="italic">pad</emphasis> character,
the OR operation stops when the shorter of the two strings is exhausted, and
the unprocessed portion of the longer string is appended to the partial result.
If you provide <emphasis role="italic">pad</emphasis>, it extends the shorter
of the two strings on the right before the logical operation. The default for
<emphasis role="italic">string</emphasis> is
the zero-length (null) string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>bitOr method</secondary></indexterm>
<programlisting>
<![CDATA[
"12"x~bitOr                   ->    "12"x
"15"x~bitOr("24"x)            ->    "35"x
"15"x~bitOr("2456"x)          ->    "3556"x
"15"x~bitOr("2456"x,"F0"x)    ->    "35F6"x
"1111"x~bitOr(,"4D"x)         ->    "5D5D"x
"pQrS"~bitOr(,"20"x)          ->    "pqrs" /* ASCII   */
]]>
</programlisting>
<para>(See <link linkend="bifBitor">BITOR (Bit by Bit OR)</link>
for information about the BITOR built-in function.)</para>
</section>

<section id="mthStringBitXor"><title>bitXor</title>
<indexterm><primary>bitXor method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>bitXor method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>character</primary>
<secondary>strings, exclusive-ORing</secondary></indexterm>
<indexterm><primary>exclusive-ORing character strings together</primary>
</indexterm>
<indexterm><primary>XORing character strings together</primary></indexterm>

<programlisting>
<![CDATA[
>>-bitXor-+--------------------+-------------------------------><
          +-(string-+------+-)-+
                    +-,pad-+
]]>
</programlisting>

<para>Returns a string composed of the receiver string and the argument
<emphasis role="italic">string</emphasis> logically eXclusive-ORed, bit by bit.
The encodings of the strings
are used in the logical operation. The length of the result is the length
of the longer of the two strings. If you omit the
<emphasis role="italic">pad</emphasis> character,
the XOR operation stops when the shorter of the two strings is exhausted,
and the unprocessed portion of the longer string is appended to the partial
result. If you provide <emphasis role="italic">pad</emphasis>,
it extends the shorter of the two strings
on the right before carrying out the logical operation. The default for
<emphasis role="italic">string</emphasis> is the zero-length (null) string.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>bitXor method</secondary></indexterm>
<programlisting>
<![CDATA[
"12"x~bitXor                      ->  "12"x
"12"x~bitXor("22"x)               ->  "30"x
"1211"x~bitXor("22"x)             ->  "3011"x
"1111"x~bitXor("444444"x)         ->  "555544"x
"1111"x~bitXor("444444"x,"40"x)   ->  "555504"x
"1111"x~bitXor(,"4D"x)            ->  "5C5C"x
"C711"x~bitXor("222222"x," ")     ->  "E53302"x  /* ASCII  */
]]>
</programlisting>
<para>(See <link linkend="bifBitxor">BITXOR (Bit by Bit Exclusive OR)</link>
for information about the BITXOR built-in
function.)</para>
</section>

<section id="mthStringC2d"><title>c2d</title>
<indexterm><primary>c2d method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>c2d method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>character</primary>
<secondary>to decimal conversion</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>character to decimal</secondary></indexterm>

<programlisting>
<![CDATA[
>>-c2d-+-----+-------------------------------------------------><
       +-(n)-+
]]>
</programlisting>

<para>Returns the decimal value of the binary representation of the receiving
string. If the result cannot be expressed as a whole number, an error results.
That is, the result must not have more digits than the current setting of
NUMERIC DIGITS. If you specify <emphasis role="italic">n</emphasis>, it is the
length of the returned result. If you do not specify
<emphasis role="italic">n</emphasis>, the receiving string is processed
as an unsigned binary number. If the receiving string is null, C2D returns
<computeroutput>0</computeroutput>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>c2d method</secondary></indexterm>
<programlisting>
<![CDATA[
"09"X~c2d       ->        9
"81"X~c2d       ->      129
"FF81"X~c2d     ->    65409
""~c2d          ->        0
"a"~c2d         ->       97     /*  ASCII   */
]]>
</programlisting>
<para>If you specify <emphasis role="italic">n</emphasis>, the receiving string
is taken as a signed number expressed in <emphasis role="italic">n</emphasis>
characters. The number is positive if the leftmost bit is off, and negative
if the leftmost bit is on. In both cases, it is converted
to a whole number, which can therefore be negative. The receiving string is
padded on the left with "00"x characters (not &quot;sign-extended&quot;),
or truncated on the left to <emphasis role="italic">n</emphasis> characters.
This padding or truncation is as though
<computeroutput>receiving_string~right(n,&apos;00&apos;x)</computeroutput> had
been processed. If <emphasis role="italic">n</emphasis> is
<computeroutput>0</computeroutput>,
<emphasis role="bold">c2d</emphasis> always returns
<computeroutput>0</computeroutput>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
<![CDATA[
"81"X~c2d(1)      ->     -127
"81"X~c2d(2)      ->      129
"FF81"X~c2d(2)    ->     -127
"FF81"X~c2d(1)    ->     -127
"FF7F"X~c2d(1)    ->      127
"F081"X~c2d(2)    ->    -3967
"F081"X~c2d(1)    ->     -127
"0031"X~c2d(0)    ->        0
]]>
</programlisting>
<para>(See <link linkend="bifC2d">C2D (Character to Decimal)</link>
for information about the C2D built-in function.)</para>
</section>

<section id="mthStringC2x"><title>c2x</title>
<indexterm><primary>c2x method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>c2x method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>character</primary>
<secondary>to hexadecimal conversion</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>character to hexadecimal</secondary></indexterm>
<indexterm><primary>unpacking a string</primary>
<secondary>with c2x</secondary></indexterm>

<programlisting>
<![CDATA[
>>-c2x---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string, in character format, that represents the receiving
string converted to hexadecimal. The returned string contains twice as many
bytes as the receiving string. On an ASCII system, sending a
<emphasis role="bold">c2x</emphasis> message to the
receiving string <computeroutput>1</computeroutput> returns
<computeroutput>31</computeroutput> because "31"X
is the ASCII representation of <computeroutput>1</computeroutput>.</para>
<para>The returned string has uppercase alphabetic characters for the values
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput> and does
not include blanks. The receiving string
can be of any length. If the receiving string is null,
<emphasis role="bold">c2x</emphasis> returns a null string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>c2x method</secondary></indexterm>
<programlisting>
<![CDATA[
"0123"X~c2x    ->    "0123"   /* "30313233"X     in ASCII */
"ZD8"~c2x      ->    "5A4438" /* "354134343338"X in ASCII */
]]>
</programlisting>
<para>(See <link linkend="bifC2x">C2X (Character to Hexadecimal)</link>
for information about the C2X built-in function.)</para>
</section>

<section id="mthStringCaselessAbbrev"><title>caselessAbbrev</title>
<indexterm><primary>caselessAbbrev method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessAbbrev method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>default</primary>
<secondary>selecting with caselessAbbrev method</secondary></indexterm>
<indexterm><primary>selecting a default with caselessAbbrev
method</primary></indexterm>
<indexterm><primary>testing</primary>
<secondary>abbreviations with caselessAbbrev
method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-caselessAbbrev(info-+---------+-)-----------------------------------><
                       +-,length-+
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> if
<emphasis role="italic">info</emphasis> is equal to the leading
characters
of the receiving string and the length of
<emphasis role="italic">info</emphasis> is not less than
<emphasis role="italic">length</emphasis>. Returns
<computeroutput>0</computeroutput> if either of these conditions is not
met.
The characters are tested using a caseless comparison.
</para>
<para>If you specify <emphasis role="italic">length</emphasis>, it must be
a
positive whole number or zero. The default for
<emphasis role="italic">length</emphasis> is the number of characters in
<emphasis role="italic">info</emphasis>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>abbrev method</secondary></indexterm>
<programlisting>
<![CDATA[
"Print"~caselessAbbrev("Pri")      ->    1
"PRINT"~caselessAbbrev("Pri")      ->    1
"PRINT"~caselessAbbrev("PRI",4)    ->    0
"PRINT"~caselessAbbrev("PRY")      ->    0
"PRINT"~caselessAbbrev("")         ->    1
"PRINT"~caselessAbbrev("",1)       ->    0
]]>
</programlisting>
<note><title>Note</title>
<para>A null string always matches if a length of
<computeroutput>0</computeroutput>, or the
default, is used. This allows a default keyword to be selected
automatically
if desired.</para></note>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
say "Enter option:";   parse pull option .
select  /* keyword1 is to be the default */
  when "keyword1"~caselessAbbrev(option) then ...
  when "keyword2"~caselessAbbrev(option) then ...
  ...
  otherwise nop;
end;
</programlisting>
</section>

<section id="mthStringCaselessChangeStr"><title>caselessChangeStr</title>
<indexterm><primary>caselessChangeStr method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessChangeStr method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-caselessChangeStr(needle,newneedle--+--------+--)---------------------------------><
                                       +-,count-+
]]>
</programlisting>

<para>Returns a copy of the receiver object in which
<emphasis role="italic">newneedle</emphasis> replaces
occurrences of <emphasis role="italic">needle</emphasis>.
If <emphasis role="italic">count</emphasis> is not specified, all occurrences of
<emphasis role="italic">needle</emphasis> are replaced.  If <emphasis role="italic">count</emphasis>
is specified, it must be a positive, whole number that gives the maximum number of
occurrences to be replaced.
The <emphasis role="italic">needle</emphasis> searches are performed
using caseless comparisons.
</para>
<para>Here are some examples:</para>
<indexterm><primary>examples</primary>
<secondary>caselessChangeStr method</secondary></indexterm>
<programlisting>
<![CDATA[
"AbaAbb"~caselessChangeStr("A","")     ->    "bbb"
AbaBabAB~changeStr("ab","xy")          ->    "xyxyxyxy"
AbaBabAB~changeStr("ab","xy",1)        ->    "xyaBabAB"
]]>
</programlisting>
</section>

<section id="mthStringCaselessCompare"><title>caselessCompare</title>
<indexterm><primary>caselessCompare method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>compare method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>comparisons</primary>
<secondary>of strings</secondary></indexterm>
<indexterm><primary>finding</primary>
<secondary>mismatch using caselessCompare</secondary></indexterm>

<programlisting>
<![CDATA[
>>-caselessCompare(string-+------+-)-----------------------------------><
                          +-,pad-+
]]>
</programlisting>

<para>Returns <computeroutput>0</computeroutput> if the argument
<emphasis role="italic">string</emphasis> is identical to the
receiving string using a caseless comparison.
Otherwise, returns the position of the first character that
does not match. The shorter string is padded on the right with
<emphasis role="italic">pad</emphasis> if
necessary. The default <emphasis role="italic">pad</emphasis> character is
a
blank.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>compare method</secondary></indexterm>
<programlisting>
<![CDATA[
"abc"~caselessCompare("ABC")         ->    0
"abc"~caselessCompare("Ak")          ->    2
"ab "~caselessCompare("AB")          ->    0
"AB "~caselessCompare("ab"," ")      ->    0
"ab "~caselesscompare("ab","x")      ->    3
"abXX "~caselesscompare("ab","x")    ->    5
]]>
</programlisting>
</section>

<section id="mthStringCaselessCompareTo"><title>caselessCompareTo</title>
<indexterm><primary>caselessCompareTo method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessCompareTo method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>caselessCompareTo method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessCompareTo method</secondary>
<tertiary>of String class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-caselessCompareTo(string-+-----------------------+-)----------------------><
                            +-,--+-- +--+---------+-+
                                 +-n-+  +-,length-+
]]>
</programlisting>


<para>Performs a caseless sort comparison of the target string to the
<emphasis role="italic">string</emphasis> argument.  If the
two strings are equal, <computeroutput>0</computeroutput> is returned.  If
the target string is larger, <computeroutput>1</computeroutput> is returned.
<computeroutput>-1</computeroutput> if the <emphasis role="italic">string</emphasis>
argument is the larger string.

The comparison is performed starting at character <emphasis role="italic">n</emphasis>
for <emphasis role="italic">length</emphasis> characters in both strings.
<emphasis role="italic">n</emphasis> must be a positive whole number.  If <emphasis role="italic">n</emphasis>
is omitted, the comparison starts at the first character.
<emphasis role="italic">n</emphasis> must be a positive whole number.  If ommitted, the comparison will take
place to the end of the target string.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>caselessCompareTo method</secondary></indexterm>
<programlisting>
<![CDATA[

"abc"~caselessCompareTo("abc")         ->    0
"b"~caselessCompareTo("a")             ->    1
"a"~caselessCompareTo("b")             ->   -1
"abc"~caselessCompareTo("aBc")         ->    0
"aBc"~caselessCompareTo("abc")         ->    0
"000abc000"~caselessCompareTo(111abc111", 4, 3)  -> 0
]]>
</programlisting>
</section>

<section id="mthStringCaselessCountStr"><title>caselessCountStr</title>
<indexterm><primary>caselessCountStr method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessCountStr method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>caselessCountStr method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessCountStr method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-caselessCountStr(needle)--------------------------------------------><
]]>
</programlisting>

<para>Returns a count of the occurrences of
<emphasis role="italic">needle</emphasis> in the receiving
string that do not overlap.  All matches are made using caseless comparisons.</para>
<para>Here are some examples:</para>
<indexterm><primary>examples</primary>
<secondary>countStr method</secondary></indexterm>
<programlisting>
<![CDATA[
"a0Aa0A"~countStr("a")        ->    4
"J0kKk0"~CountStr("KK")       ->    1
]]>
</programlisting>
</section>

<section id="mthStringCaselessEquals"><title>caselessEquals</title>
<indexterm><primary>caselessEquals method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessEquals method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>caselessEquals method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessEquals method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-equals(other)-------------------------------------------------------><
]]>
</programlisting>

<para>Returns .true ("1") if the target string is strictly equal to the
<emphasis role="italic">other</emphasis> string, using a caseless comparison.
Returns .false ("0") if the two strings are not strictly equal.
<emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>equals method</secondary></indexterm>
<programlisting>
"a"~equals("A")          ->    1
"aa"~equals("A")         ->    0
"4"~equals("3")          ->    0
</programlisting>
</section>

<section id="mthStringCaselessLastPos"><title>caselessLastPos</title>
<indexterm><primary>caselessLastPos method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessLastPos method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>caselessLastPos method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessLastPos method</secondary>
<tertiary>of String class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-caselessLastPos(needle-+--------+-)---------------------------------><
                          +-,start-+
]]>
</programlisting>

<para>Returns the position of the last occurrence of a string,
<emphasis role="italic">needle</emphasis>,
in the receiving string. (See also <link linkend="mthStringPos">POS</link>.) It
returns <computeroutput>0</computeroutput> if
<emphasis role="italic">needle</emphasis> is the null string or not found.
By default, the search starts at the last character of the receiving string
and scans backward. You can override this by specifying
<emphasis role="italic">start</emphasis>, the point at which the
backward scan starts. The <emphasis role="italic">start</emphasis> must be a
positive whole number and defaults to
<computeroutput>receiving_string~length</computeroutput> if larger than that
value or omitted.  The search is performed using caseless comparisons.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>caselessLastPos method</secondary></indexterm>
<programlisting>
"abc def ghi"~caselessLastPos(" ")      ->    8
"abcdefghi"~caselessLastPos(" ")        ->    0
"efgxyz"~caselessLastPos("XY")          ->    4
"abc def ghi"~caselessLastPos(" ",7)    ->    4
</programlisting>
<para>(See <link linkend="bifLastpos">LASTPOS (Last Position)</link>
for information about the LASTPOS built-in function.)</para>
</section>

<section id="mthStringCaselessMatch"><title>caselessMatch</title>
<indexterm><primary>caselessMatch method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessMatch method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>caselessMatch method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessMatch method</secondary>
<tertiary>of String class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-caselessMatch(start,other-+----------------------------+-)-------------------><
                             +-,--+---+--+---------+-+
                                  +-n-+  +-,length-+
]]>
</programlisting>

<para>Returns .true ("1") if the the characters of the <emphasis role="italic">other</emphasis> match the
characters of the target string beginning at position <emphasis role="italic">start</emphasis>.  Return .false
("0") if the characters are not a match.  The matching is performed using caseless comparisons.
<emphasis role="italic">start</emphasis> must be a positive whole number less than or equal to the length of
the target string.
</para>
<para>If <emphasis role="italic">n</emphasis> is specified, the match will be performed starting with character
<emphasis role="italic">n</emphasis> of <emphasis role="italic">other</emphasis>.  The default value for
<emphasis role="italic">n</emphasis> is "1".  <emphasis role="italic">n</emphasis> must be a positive whole number
less than or equal to the length of <emphasis role="italic">other</emphasis>.
</para>
<para>If <emphasis role="italic">length</emphasis> is specified, it defines a substring of
<emphasis role="italic">other</emphasis> that is used for the match.  <emphasis role="italic">length</emphasis>
must be a positive whole number and the combination of <emphasis role="italic">n</emphasis> and
<emphasis role="italic">length</emphasis> must be a valid substring within the bounds of
<emphasis role="italic">other</emphasis>.</para>
<para>The caselessMatch method is useful efficient string parsing as it does not require new string objects be extracted from
the target string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>caselessMatch method</secondary></indexterm>
<programlisting>
"Saturday"~caselessMatch("day", 6)           ->    1
"Saturday"~caselessMatch("DAY", 6)           ->    1
"Saturday"~caselessMatch("SUNDAY", 6, 4, 3)  ->    1
"Saturday"~caselessMatch("daytime", 6, 3)    ->    1
</programlisting>
</section>

<section id="mthStringCaselessMatchChar"><title>caselessMatchChar</title>
<indexterm><primary>caselessMatchChar method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessMatchChar method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>caselessMatchChar method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessMatchChar method</secondary>
<tertiary>of String class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-caselessMatchChar(n,chars)-------------------------><
]]>
</programlisting>

<para>Returns .true ("1") if the character at position <emphasis role="italic">n</emphasis> matches any
character of the string <emphasis role="italic">chars</emphasis>.  Returns .false ("0") if the character does not
match any of the characters in the reference set.  The match is made using caseless comparisons.
The argmuent <emphasis role="italic">n</emphasis> must be
a positive whole number less than or equal to the length of the target string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>caselessMatchChar method</secondary></indexterm>
<programlisting>
"a+b"~caselessMatchChar(2, "+-*/")           ->    1
"a+b"~caselessMatchChar(1, "+-*/")           ->    0
"Friday"~caselessMatchChar(3, "aeiou")       ->    1
"FRIDAY"~caselessMatchChar(3, "aeiou")       ->    1
</programlisting>
</section>

<section id="mthStringCaselessPos"><title>caselessPos</title>
<indexterm><primary>caselessPos method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessPos method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>caselessPos method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>caselessPos method</secondary>
<tertiary>of String class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-caselessPos(needle-+--------+-)-------------------------------------><
                      +-,start-+
]]>
</programlisting>

<para>Returns the position in the receiving string of another string,
<emphasis role="italic">needle</emphasis>. (See also
<link linkend="mthStringLastPos">lastPos</link>.) It returns
<computeroutput>0</computeroutput> if
<emphasis role="italic">needle</emphasis> is the null string or is not found
or if <emphasis role="italic">start</emphasis> is greater than
the length of the receiving string.  The search is performed using caseless
comparisons.
By default, the search starts at the first
character of the receiving string (that is, the value of
<emphasis role="italic">start</emphasis> is <computeroutput>1</computeroutput>).
You can override this by specifying <emphasis role="italic">start</emphasis>
(which must be
a positive whole number), the point at which the search starts.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>pos method</secondary></indexterm>
<programlisting>
"Saturday"~pos("DAY")       ->    6
"abc def ghi"~pos("x")      ->    0
"abc def ghi"~pos(" ")      ->    4
"abc def ghi"~pos(" ",5)    ->    8
</programlisting>
</section>

<section id="mthStringCaselessWordPos"><title>caselessWordPos</title>
<indexterm><primary>caselessWordPos method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>wordPos method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>word</primary>
<secondary>locating in a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-caselessWordPos(phrase-+--------+-)---------------------------------><
                          +-,start-+
]]>
</programlisting>

<para>Returns the word number of the first word of
<emphasis role="italic">phrase</emphasis> found in the
receiving string, or <computeroutput>0</computeroutput> if
<emphasis role="italic">phrase</emphasis> contains no words or
if <emphasis role="italic">phrase</emphasis> is not found.
Word matches are made independent of case.
Several blanks
between words in either <emphasis role="italic">phrase</emphasis> or the
receiving string are treated as a single blank for the
comparison, but, otherwise, the words must match exactly.</para>
<para>By default the search starts at the first word in the receiving
string.
You can override this by specifying <emphasis
role="italic">start</emphasis>
(which must be positive),
the word at which the search is to be started.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>wordPos method</secondary></indexterm>
<programlisting>
"now is the time"~caselessWordPos("the")              ->  3
"now is the time"~caselessWordPos("The")              ->  3
"now is the time"~caselessWordPos("IS THE")           ->  2
"now is the time"~caselessWordPos("is   the")         ->  2
"now is   the time"~caselessWordPos("is   time ")     ->  0
"To be or not to be"~caselessWordPos("BE")            ->  2
"To be or not to be"~caselessWordPos("BE",3)          ->  6
</programlisting>
</section>

<section id="mthStringCenter"><title>center/centre</title>
<indexterm><primary>center method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>center method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>centre method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>centre method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text centering</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>centering using center function</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>centering using centre function</secondary></indexterm>

<programlisting>
<![CDATA[
>>-+-center(-+-length-+--------+-)-----------------------------><
   +-centre(-+        +-,--pad-+
]]>
</programlisting>

<para>Returns a string of length <emphasis role="italic">length</emphasis>
with the receiving string centered in it. The language processor adds
<emphasis role="italic">pad</emphasis> characters as necessary to
make up length. The <emphasis role="italic">length</emphasis> must be a
positive whole number or zero. The default
<emphasis role="italic">pad</emphasis> character is blank. If the receiving
string is longer than <emphasis role="italic">length</emphasis>, it is
truncated at both ends to fit. If an odd number
of characters are truncated or added, the right-hand end loses or gains one
more character than the left-hand end. </para>

<note><title>Note</title>
<para>To avoid errors because
of the difference between British and American spellings, this method can
be called either <emphasis role="bold">center</emphasis> or
<emphasis role="bold">centre</emphasis>.</para></note>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>center method</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>centre method</secondary></indexterm>
<programlisting>
<![CDATA[
abc~center(7)               ->    "  ABC  "
abc~CENTER(8,"-")           ->    "--ABC---"
"The blue sky"~centre(8)    ->    "e blue s"
"The blue sky"~centre(7)    ->    "e blue "
]]>
</programlisting>
<para>(See <link linkend="bifCenter">CENTER (or CENTRE)</link>
for information about the CENTER built-in function.)</para>
</section>

<section id="mthStringChangeStr"><title>changeStr</title>
<indexterm><primary>changeStr method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>changeStr method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-changeStr(needle,newneedle--+--------+--)---------------------------------><
                               +-,count-+
]]>
</programlisting>

<para>Returns a copy of the receiver object in which
<emphasis role="italic">newneedle</emphasis> replaces
occurrences of <emphasis role="italic">needle</emphasis>.</para>
<para>If <emphasis role="italic">count</emphasis> is not specified, all occurrences of
<emphasis role="italic">needle</emphasis> are replaced.  If <emphasis role="italic">count</emphasis>
is specified, it must be a positive, whole number that gives the maximum number of
occurrences to be replaced.</para>
<para>Here are some examples:</para>
<indexterm><primary>examples</primary>
<secondary>changeStr method</secondary></indexterm>
<programlisting>
<![CDATA[
101100~changeStr("1","")     ->    "000"
101100~changeStr("1","X")    ->    "X0XX00"
101100~changeStr("1","X",1)  ->    "X01100"
]]>
</programlisting>
<para>(See <link linkend="bifChangestr">CHANGESTR</link>
for information about the CHANGESTR built-in
function.)</para>
</section>

<section id="mthStringCompare"><title>compare</title>
<indexterm><primary>compare method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>compare method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>comparisons</primary>
<secondary>of strings</secondary></indexterm>
<indexterm><primary>finding</primary>
<secondary>mismatch using compare</secondary></indexterm>

<programlisting>
<![CDATA[
>>-compare(string-+------+-)-----------------------------------><
                  +-,pad-+
]]>
</programlisting>

<para>Returns <computeroutput>0</computeroutput> if the argument
<emphasis role="italic">string</emphasis> is identical to the
receiving string. Otherwise, returns the position of the first character that
does not match. The shorter string is padded on the right with
<emphasis role="italic">pad</emphasis> if
necessary. The default <emphasis role="italic">pad</emphasis> character is a
blank.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>compare method</secondary></indexterm>
<programlisting>
<![CDATA[
"abc"~compare("abc")         ->    0
"abc"~compare("ak")          ->    2
"ab "~compare("ab")          ->    0
"ab "~compare("ab"," ")      ->    0
"ab "~compare("ab","x")      ->    3
"ab-- "~compare("ab","-")    ->    5
]]>
</programlisting>
<para>(See <link linkend="bifCompare">COMPARE</link>  for information about the
COMPARE built-in function.)</para>
</section>

<section id="mthStringCompareTo"><title>compareTo</title>
<indexterm><primary>compareTo method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>compareTo method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>comparisons</primary>
<secondary>of strings</secondary></indexterm>
<indexterm><primary>finding</primary>
<secondary>mismatch using compareTo</secondary></indexterm>

<programlisting>
<![CDATA[
>>-compareTo(string-+-----------------------+-)----------------------><
                    +-,--+-- +--+---------+-+
                         +-n-+  +-,length-+
]]>
</programlisting>


<para>Performs a sort comparison of the target string to the
<emphasis role="italic">string</emphasis> argument.  If the
two strings are equal, <computeroutput>0</computeroutput> is returned.  If
the target string is larger, <computeroutput>1</computeroutput> is returned.
<computeroutput>-1</computeroutput> if the <emphasis role="italic">string</emphasis>
argument is the larger string.

The comparison is performed starting at character <emphasis role="italic">n</emphasis>
for <emphasis role="italic">length</emphasis> characters in both strings.
<emphasis role="italic">n</emphasis> must be a positive whole number.  If <emphasis role="italic">n</emphasis>
is omitted, the comparison starts at the first character.
<emphasis role="italic">n</emphasis> must be a positive whole number.  If ommitted, the comparison will take
place to the end of the target string.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>compareTo method</secondary></indexterm>
<programlisting>
<![CDATA[

"abc"~compareTo("abc")         ->    0
"b"~compareTo("a")             ->    1
"a"~compareTo("b")             ->   -1
"abc"~compareTo("aBc")         ->    1
"aBc"~compareTo("abc")         ->   -1
"000abc000"~compareTo(111abc111", 4, 3)  -> 0
]]>
</programlisting>
</section>

<section id="mthStringCopies"><title>copies</title>
<indexterm><primary>copies method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>copies method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>copying a string using copies</primary></indexterm>
<indexterm><primary>repeating s string with copies</primary></indexterm>
<indexterm><primary>string</primary>
<secondary>copying using copies</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>repeating using copies</secondary></indexterm>

<programlisting>
<![CDATA[
>>-copies(n)---------------------------------------------------><
]]>
</programlisting>

<para>Returns <emphasis role="italic">n</emphasis> concatenated copies of the
receiving string. The <emphasis role="italic">n</emphasis> must be a positive
whole number or zero.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>copies method</secondary></indexterm>
<programlisting>
<![CDATA[
"abc"~copies(3)    ->    "abcabcabc"
"abc"~copies(0)    ->    ""
]]>
</programlisting>
<para>(See <link linkend="bifCopies">COPIES</link>  for information about the
COPIES built-in function.)</para>
</section>

<section id="mthStringCountStr"><title>countStr</title>
<indexterm><primary>countStr method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>countStr method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-countStr(needle)--------------------------------------------><
]]>
</programlisting>

<para>Returns a count of the occurrences of
<emphasis role="italic">needle</emphasis> in the receiving
string that do not overlap.</para>
<para>Here are some examples:</para>
<indexterm><primary>examples</primary>
<secondary>countStr method</secondary></indexterm>
<programlisting>
<![CDATA[
"101101"~countStr("1")        ->    4
"J0KKK0"~CountStr("KK")       ->    1
]]>
</programlisting>
<para>(See <link linkend="bifCountstr">COUNTSTR</link>
for information about the COUNTSTR built-in
function.)</para>
</section>

<section id="mthStringD2c"><title>d2c</title>
<indexterm><primary>d2c method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>d2c method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>decimal to character</secondary></indexterm>
<indexterm><primary>decimal</primary>
<secondary>to character conversion</secondary></indexterm>

<programlisting>
<![CDATA[
>>-d2c-+-----+-------------------------------------------------><
       +-(n)-+
]]>
</programlisting>

<para>Returns a string, in character format, that is the ASCII representation
of the receiving string, a decimal number. If you specify
<emphasis role="italic">n</emphasis>, it is
the length of the final result in characters; leading blanks are added to
the returned string. The <emphasis role="italic">n</emphasis> must be a
positive whole number or zero.</para>
<para>The receiving string must not have more digits than the current setting
of NUMERIC DIGITS.</para>
<para>If you omit <emphasis role="italic">n</emphasis>, the receiving string
must be a positive whole number
or zero, and the result length is as needed. Therefore, the returned result
has no leading "00"x characters.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>d2c method</secondary></indexterm>
<programlisting>
"65"~d2c       ->   "A"      /* "41"x is an ASCII "A"    */
"65"~d2c(1)    ->   "A"
"65"~d2c(2)    ->   " A"
"65"~d2c(5)    ->   "    A"
"109"~d2c      ->   "m"      /* "6D"x  is an ASCII "m"   */
"-109"~d2c(1)  ->   "&ocirc;"      /* "93"x  is an ASCII "&ocirc;"   */
"76"~d2c(2)    ->   " L"     /* "4C"x  is an ASCII " L"  */
"-180"~d2c(2)  ->   " L"
</programlisting>
<indexterm><primary>implementation maximum</primary>
<secondary>d2c method</secondary></indexterm>
<para>Implementation maximum: The returned string must not have more than 250
significant
characters, although a longer result is possible if it has additional leading
sign characters ("00"x and "FF"x).</para>
<para>(See <link linkend="bifD2c">D2C (Decimal to Character)</link>
for information about the D2C built-in function.)</para>
</section>

<section id="mthStringD2x"><title>d2x</title>
<indexterm><primary>d2x method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>d2x method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>decimal to hexadecimal</secondary></indexterm>
<indexterm><primary>decimal</primary>
<secondary>to hexadecimal conversion</secondary></indexterm>

<programlisting>
<![CDATA[
>>-d2x-+-----+-------------------------------------------------><
       +-(n)-+
]]>
</programlisting>

<para>Returns a string, in character format, that represents the receiving
string, a decimal number converted to hexadecimal. The returned string uses
uppercase alphabetic characters for the values
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput> and does
not include blanks.</para>
<para>The receiving string must not have more digits than the current setting
of NUMERIC DIGITS.</para>
<para>If you specify <emphasis role="italic">n</emphasis>, it is the length of
the final result in characters.
After conversion the returned string is sign-extended to the required length.
If the number is too big to fit into <emphasis role="italic">n</emphasis>
characters, it is truncated
on the left. If you specify <emphasis role="italic">n</emphasis>, it must be a
positive whole number or zero.</para>
<para>If you omit <emphasis role="italic">n</emphasis>, the receiving string
must be a positive whole number
or zero, and the returned result has no leading zeros.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>d2x method</secondary></indexterm>
<programlisting>
"9"~d2x        ->    "9"
"129"~d2x      ->    "81"
"129"~d2x(1)   ->    "1"
"129"~d2x(2)   ->    "81"
"129"~d2x(4)   ->    "0081"
"257"~d2x(2)   ->    "01"
"-127"~d2x(2)  ->    "81"
"-127"~d2x(4)  ->    "FF81"
"12"~d2x(0)    ->    ""
</programlisting>
<indexterm><primary>implementation maximum</primary>
<secondary>d2x method</secondary></indexterm>
<para>Implementation maximum: The returned string must not have more than 500
significant hexadecimal characters, although a longer result is possible if it
has additional leading sign characters (0 and F).</para>
<para>(See <link linkend="bifD2x">D2X (Decimal to Hexadecimal)</link>
for information about the D2X built-in function.)</para>
</section>

<section id="mthStringDataType"><title>dataType</title>
<indexterm><primary>dataType method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>dataType method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>alphabetics</primary>
<secondary>checking with dataType</secondary></indexterm>
<indexterm><primary>alphnumerics</primary>
<secondary>checking with dataType</secondary></indexterm>
<indexterm><primary>bits checked using dataType method</primary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>checking with dataType</secondary></indexterm>
<indexterm><primary>type of data, checking with DataType</primary></indexterm>
<indexterm><primary>whole numbers</primary>
<secondary>checking with dataType</secondary></indexterm>
<indexterm><primary>numbers</primary>
<secondary>checking with dataType</secondary></indexterm>

<programlisting>
<![CDATA[
>>-dataType-+--------+-----------------------------------------><
            +-(type)-+
]]>
</programlisting>

<para>Returns <computeroutput>NUM</computeroutput> if you specify no argument
and the receiving string
is a valid Rexx number that can be added to 0 without error. It returns
<computeroutput>CHAR</computeroutput> if the receiving string is not a
valid number.</para>
<para>If you specify <emphasis role="italic">type</emphasis>, it returns
<computeroutput>1</computeroutput> if the receiving
string matches the type. Otherwise, it returns
<computeroutput>0</computeroutput>. If the receiving
string is null, the method returns <computeroutput>0</computeroutput>
(except when the <emphasis role="italic">type</emphasis> is
<computeroutput>X</computeroutput> or <computeroutput>B</computeroutput>,
for which <emphasis role="bold">dataType</emphasis>
returns <computeroutput>1</computeroutput> for
a null string). The following are valid
<emphasis role="italic">type</emphasis>s. You need to specify
only the capitalized letter, or the number of the last type listed. The language
processor ignores all characters surrounding it.</para>
<variablelist>
<varlistentry><term>Alphanumeric</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only characters from the ranges
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>,
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>, and
<computeroutput>0</computeroutput>-<computeroutput>9</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Binary</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only the characters <computeroutput>0</computeroutput> or
<computeroutput>1</computeroutput>, or a blank. Blanks can appear only between
groups of 4 binary characters. It also returns 1 if string is
a null string, which is a valid binary string.
</para></listitem></varlistentry>
<varlistentry><term>Lowercase</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only characters from the range
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Mixed case</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only characters from the ranges
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput> and
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Number</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<computeroutput>receiving_string~dataType</computeroutput> returns
<computeroutput>NUM</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>lOgical</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
the receiving string is exactly "0" or "1". Otherwise it returns
<computeroutput>0</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Symbol</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string is a valid symbol, that is, if SYMBOL(string) does not return
<computeroutput>BAD</computeroutput>. (See
<link linkend="xsymbol">Symbols</link>.)
Note that both uppercase and lowercase alphabetic characters are permitted.
</para></listitem></varlistentry>
<varlistentry><term>Uppercase</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only characters from the range
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Variable</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string could appear on the left-hand
side of an assignment without causing a SYNTAX condition.
</para></listitem></varlistentry>
<varlistentry><term>Whole number</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string is a whole number under the current setting of NUMERIC DIGITS.
</para></listitem></varlistentry>
<varlistentry><term>heXadecimal</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only characters from the ranges
<computeroutput>a</computeroutput>-<computeroutput>f</computeroutput>,
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput>,
<computeroutput>0</computeroutput>-<computeroutput>9</computeroutput>,
and blank (as long as blanks appear
only between pairs of hexadecimal characters). Also returns
<computeroutput>1</computeroutput> if
the receiving string is a null string.
</para></listitem></varlistentry>
<varlistentry><term>9 Digits</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<computeroutput>receiving_string~dataType("W")</computeroutput> returns
<computeroutput>1</computeroutput> when NUMERIC DIGITS is set to 9.
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>dataType method</secondary></indexterm>
<programlisting>
<![CDATA[
" 12 "~dataType          ->   "NUM"
""~dataType              ->   "CHAR"
"123*"~dataType          ->   "CHAR"
"12.3"~dataType("N")     ->    1
"12.3"~dataType("W")     ->    0
"Fred"~dataType("M")     ->    1
""~dataType("M")         ->    0
"Fred"~dataType("L")     ->    0
"?20K"~dataType("s")     ->    1
"BCd3"~dataType("X")     ->    1
"BC d3"~dataType("X")    ->    1
"1"~dataType("O")        ->    1
"11"~dataType("O")        ->   0
]]>
</programlisting><para> </para>

<note><title>Note</title>
<para>The <emphasis role="bold">dataType</emphasis>
method tests the meaning or type of characters in a
string, independent of the encoding of those characters (for example, ASCII
or EBCDIC).</para></note>
<para>(See <link linkend="bifDatatype">DATATYPE</link> for information about the
DATATYPE built-in function.)</para>
</section>

<section id="mthStringDecodeBase64"><title>decodeBase64</title>
<indexterm><primary>decodeBase64 method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>decodeBase64 method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>base64</primary>
<secondary>decodeBase64 method</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>decodeBase64 method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-decodeBase64------------------------------------------------><
]]>
</programlisting>

<para>Returns the decoded version of the base64 encoded recieving string.
If the recieving string is not in base64 format then the
returned result is undefined.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>decodeBase64 method</secondary></indexterm>
<programlisting>
<![CDATA[
"YWJjZGVm"~decodeBase64       ->    "abcdef"
]]>
</programlisting>
<para>Please note that there is no corresponding DECODEBASE64 builtin function
for this method in ooRexx.</para>
</section>

<section id="mthStringDelStr"><title>delStr</title>
<indexterm><primary>delStr method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>delStr method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>deleting</primary>
<secondary>part of a string</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>deleting part, delStr method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-delStr(n--+---------+--)------------------------------------><
             +-,length-+
]]>
</programlisting>

<para>Returns a copy of the receiving string after deleting the substring that
begins at the <emphasis role="italic">n</emphasis>th character and is of
<emphasis role="italic">length</emphasis> characters.
If you omit <emphasis role="italic">length</emphasis>, or if
<emphasis role="italic">length</emphasis> is greater than the number
of characters from <emphasis role="italic">n</emphasis> to the end of
<emphasis role="italic">string</emphasis>, the method deletes
the rest of <emphasis role="italic">string</emphasis> (including the
<emphasis role="italic">n</emphasis>th character). The
<emphasis role="italic">length</emphasis> must be a positive whole number or
zero. The <emphasis role="italic">n</emphasis> must be
a positive whole number. If <emphasis role="italic">n</emphasis> is greater
than the length of the receiving
string, the method returns the receiving string unchanged.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>delStr method</secondary></indexterm>
<programlisting>
<![CDATA[
"abcd"~delStr(3)       ->    "ab"
"abcde"~delStr(3,2)    ->    "abe"
"abcde"~delStr(6)      ->    "abcde"
]]>
</programlisting>
<para>(See <link linkend="bifDelstr">DELSTR (Delete String)</link>
for information about the DELSTR built-in function.)</para>
</section>

<section id="mthStringDelWord"><title>delWord</title>
<indexterm><primary>delWord method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>delWord method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>deleting</primary>
<secondary>words from a string</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>deleting from a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-delWord(n--+---------+--)-----------------------------------><
              +-,length-+
]]>
</programlisting>

<para>Returns a copy of the receiving string after deleting the substring that
starts at the <emphasis role="italic">n</emphasis>th word and is of
<emphasis role="italic">length</emphasis> blank-delimited
words. If you omit <emphasis role="italic">length</emphasis>, or if
<emphasis role="italic">length</emphasis> is greater than
the number of words from <emphasis role="italic">n</emphasis> to the end of the
receiving string, the
method deletes the remaining words in the receiving string (including the
<emphasis role="italic">n</emphasis>th word). The
<emphasis role="italic">length</emphasis> must be a positive whole number or
zero. The <emphasis role="italic">n</emphasis> must be a positive whole number.
If <emphasis role="italic">n</emphasis> is greater than
the number of words in the receiving string, the method returns the receiving
string unchanged. The string deleted includes any blanks following the final
word involved but none of the blanks preceding the first word involved.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>delWord method</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>delWord method</secondary></indexterm>
<programlisting>
<![CDATA[
"Now is the  time"~delWord(2,2)  ->  "Now time"
"Now is the time "~delWord(3)    ->  "Now is "
"Now is the  time"~delWord(5)    ->  "Now is the  time"
"Now is   the time"~delWord(3,1) ->  "Now is   time"
]]>
</programlisting>
<para>(See <link linkend="bifDelword">DELWORD (Delete Word)</link>
for information about the DELWORD built-in function.)</para>
</section>

<section id="mthStringEncodeBase64"><title>encodeBase64</title>
<indexterm><primary>encodeBase64 method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>encodeBase64 method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>base64</primary>
<secondary>encodeBase64 method</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>encodeBase64 method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-encodeBase64------------------------------------------------><
]]>
</programlisting>

<para>Returns the base64 encoded version of the recieving string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>encodeBase64 method</secondary></indexterm>
<programlisting>
<![CDATA[
"abcdef"~encodeBase64       ->    "YWJjZGVm"
]]>
</programlisting>
<para>Please note that there is no corresponding ENCODEBASE64 builtin function
for this method in ooRexx.</para>
</section>

<section id="mthStringEquals"><title>equals</title>
<indexterm><primary>equals method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>equals method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-equals(other)-------------------------------------------------------><
]]>
</programlisting>

<para>Returns .true ("1") if the target string is strictly equal to the
<emphasis role="italic">other</emphasis> string.
Returns .false ("0") if the two strings are not strictly equal.  This is
the same comparison performed by the "==" comparison method.
<emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>equals method</secondary></indexterm>
<programlisting>
"3"~equals("3")          ->    1
"33"~equals("3")         ->    0
"4"~equals("3")          ->    0
</programlisting>
</section>

<section id="mthStringFormat"><title>format</title>
<indexterm><primary>format method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>format method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>formating numbers</secondary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>numbers for display</secondary></indexterm>
<indexterm><primary>numbers</primary>
<secondary>formatting for display</secondary></indexterm>
<indexterm><primary>numbers for display</primary></indexterm>

<programlisting>
<![CDATA[
>>-format-+---------------------------------------------------------+-><
          +-(-before-+------------------------------------------+-)-+
                     +-,--+-------+--+------------------------+-+
                          +-after-+  +-,--+------+--+-------+-+
                                          +-expp-+  +-,expt-+
]]>
</programlisting>

<para>Returns the receiving string, a number, rounded and formatted.</para>
<para>The number is first rounded according to standard Rexx rules, as though
the operation <computeroutput>receiving_string+0</computeroutput> had been
carried out. If you
specify no arguments the result of the method is the same as the result of
this operation. If you specify any options, the number is formatted as
described in the following.</para>
<para>The <emphasis role="italic">before</emphasis> and
<emphasis role="italic">after</emphasis> options describe how many characters
are to be used for the integer and decimal parts of the result. If you omit
either or both of them, the number of characters for that part is as needed.
</para>
<para>If <emphasis role="italic">before</emphasis> is not large enough to
contain the integer part of the
number (plus the sign for a negative number), an error results. If
<emphasis role="italic">before</emphasis> is larger than needed for that part,
the number is padded on the left with blanks. If
<emphasis role="italic">after</emphasis> is not the same size as the decimal
part of the number, the number is rounded (or extended with zeros) to fit.
Specifying <computeroutput>0</computeroutput> causes the number to be rounded
to an integer.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>format method</secondary></indexterm>
<programlisting>
"3"~format(4)            ->    "   3"
"1.73"~format(4,0)       ->    "   2"
"1.73"~format(4,3)       ->    "   1.730"
"-.76"~format(4,1)       ->    "  -0.8"
"3.03"~format(4)         ->    "   3.03"
" - 12.73"~format(,4)    ->    "-12.7300"
" - 12.73"~format        ->    "-12.73"
"0.000"~format           ->    "0"
</programlisting>
<para><emphasis role="italic">expp</emphasis> and
<emphasis role="italic">expt</emphasis> control the exponent part of the result,
which, by default, is formatted according to the current NUMERIC settings
of DIGITS and FORM. <emphasis role="italic">expp</emphasis> sets the number of
places for the exponent part; the default is to use as many as needed
(which can be zero). <emphasis role="italic">expt</emphasis>
specifies when the exponential expression is used. The default is the
current setting of NUMERIC DIGITS.</para>
<para>If <emphasis role="italic">expp</emphasis> is
<computeroutput>0</computeroutput>, the number is not an exponential expression.
If <emphasis role="italic">expp</emphasis> is not large enough to contain the
exponent, an error results.</para>
<para>If the number of places needed for the integer or decimal part exceeds
<emphasis role="italic">expt</emphasis> or twice
<emphasis role="italic">expt</emphasis>, respectively, exponential notation is
used. If <emphasis role="italic">expt</emphasis> is
<computeroutput>0</computeroutput>, exponential notation is always used unless
the exponent would be <computeroutput>0</computeroutput>. (If
<emphasis role="italic">expp</emphasis> is
<computeroutput>0</computeroutput>, this
overrides a <computeroutput>0</computeroutput> value of
<emphasis role="italic">expt</emphasis>.) If the exponent would be
<computeroutput>0</computeroutput> when a nonzero
<emphasis role="italic">expp</emphasis> is specified, then
<emphasis role="italic">expp</emphasis>+2 blanks
are supplied for the exponent part of the result. If the exponent would be
<computeroutput>0</computeroutput> and <emphasis role="italic">expp</emphasis>
is not specified, the number is not an exponential
expression.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
"12345.73"~format(, ,2,2)   ->    "1.234573E+04"
"12345.73"~format(,3, ,0)   ->    "1.235E+4"
"1.234573"~format(,3, ,0)   ->    "1.235"
"12345.73"~format(, ,3,6)   ->    "12345.73"
"1234567e5"~format(,3,0)    ->    "123456700000.000"
</programlisting>
<para>(See <link linkend="bifFormat">FORMAT</link>  for information about the
FORMAT built-in function.)</para>
</section>

<section id="mthStringHashCode"><title>hashCode</title>
<indexterm><primary>hashCode method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hashCode method</secondary>
<tertiary>of Strings class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hashCode---------------------------------------------------><
]]>
</programlisting>

<para>Returns a string value that is used as a hash value for MapCollection
such as Table, Relation, Set, Bag, and Directory.  The String hash code method will return
the same hash value for all pairs of string instances for which the == operator is true.
See <link linkend="mthObjectHashCode">hashCode Method</link> for details.
</para>
</section>

<section id="mthStringInsert"><title>insert</title>
<indexterm><primary>insert method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>insert method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>inserting a string into another</primary></indexterm>

<programlisting>
<![CDATA[
>>-insert(new-+---------------------------------------+-)------><
              +-,--+---+--+-------------------------+-+
                   +-n-+  +-,--+--------+--+------+-+
                               +-length-+  +-,pad-+
]]>
</programlisting>

<para>Inserts the string <emphasis role="italic">new</emphasis>, padded or
truncated to length <emphasis role="italic">length</emphasis>, into the
receiving string. after the <emphasis role="italic">n</emphasis>th character.
The default value for <emphasis role="italic">n</emphasis> is
<computeroutput>0</computeroutput>, which means insertion at the beginning
of the string. If specified, <emphasis role="italic">n</emphasis> and
<emphasis role="italic">length</emphasis> must be positive
whole numbers or zero. If <emphasis role="italic">n</emphasis> is greater than
the length of the receiving string, the string
<emphasis role="italic">new</emphasis> is padded at the beginning. The default
value for <emphasis role="italic">length</emphasis> is the length of
<emphasis role="italic">new</emphasis>. If
<emphasis role="italic">length</emphasis> is less
than the length of the string <emphasis role="italic">new</emphasis>,
then <emphasis role="bold">insert</emphasis>
truncates <emphasis role="italic">new</emphasis> to length
<emphasis role="italic">length</emphasis>. The default
<emphasis role="italic">pad</emphasis> character is a blank.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>insert method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
"abc"~insert("123")            ->    "123abc"
"abcdef"~insert(" ",3)         ->    "abc def"
"abc"~insert("123",5,6)        ->    "abc  123   "
"abc"~insert("123",5,6,"+")    ->    "abc++123+++"
"abc"~insert("123", ,5,"-")    ->    "123--abc"
</programlisting>
<para>(See <link linkend="bifInsert">INSERT</link>
for information about the INSERT built-in function.)</para>
</section>

<section id="mthStringLastPos"><title>lastPos</title>
<indexterm><primary>lastPos method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lastPos method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>position</primary>
<secondary>last occurrence of a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-lastPos(needle-+--------+-)---------------------------------><
                  +-,start-+
]]>
</programlisting>

<para>Returns the position of the last occurrence of a string,
<emphasis role="italic">needle</emphasis>,
in the receiving string. (See also <link linkend="mthStringPos">POS</link>.) It
returns <computeroutput>0</computeroutput> if
<emphasis role="italic">needle</emphasis> is the null string or not found.
By default, the search starts at the last character of the receiving string
and scans backward. You can override this by specifying
<emphasis role="italic">start</emphasis>, the point at which the
backward scan starts. The <emphasis role="italic">start</emphasis> must be a
positive whole number and defaults to
<computeroutput>receiving_string~length</computeroutput> if larger than that
value or omitted.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>lastPos method</secondary></indexterm>
<programlisting>
"abc def ghi"~lastPos(" ")      ->    8
"abcdefghi"~lastPos(" ")        ->    0
"efgxyz"~lastPos("xy")          ->    4
"abc def ghi"~lastPos(" ",7)    ->    4
</programlisting>
<para>(See <link linkend="bifLastpos">LASTPOS (Last Position)</link>
for information about the LASTPOS built-in function.)</para>
</section>

<section id="mthStringLeft"><title>left</title>
<indexterm><primary>left method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>left method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text left justification</secondary></indexterm>

<programlisting>
<![CDATA[
>>-left(length-+------+-)--------------------------------------><
               +-,pad-+
]]>
</programlisting>

<para>Returns a string of length <emphasis role="italic">length</emphasis>,
containing the leftmost <emphasis role="italic">length</emphasis> characters
of the receiving string. The string returned is padded
with <emphasis role="italic">pad</emphasis> characters (or truncated) on the
right as needed. The default <emphasis role="italic">pad</emphasis> character
is a blank. The <emphasis role="italic">length</emphasis> must be a positive
whole number or zero. The <emphasis role="bold">left</emphasis>
method is exactly equivalent to:</para>
<programlisting>
<![CDATA[
>>-SUBSTR(string,1,length-+------+-)---------------------------><
                          +-,pad-+
]]>
</programlisting>

<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>left method</secondary></indexterm>
<programlisting>
"abc d"~left(8)        ->    "abc d   "
"abc d"~left(8,".")    ->    "abc d..."
"abc  def"~left(7)     ->    "abc  de"
</programlisting>
<para>(See <link linkend="bifLeft">LEFT</link>
for information about the LEFT built-in function.)</para>
</section>

<section id="mthStringLength"><title>length</title>
<indexterm><primary>length method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>length method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>finding</primary>
<secondary>string length</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>finding length of</secondary></indexterm>

<programlisting>
<![CDATA[
>>-length------------------------------------------------------><
]]>
</programlisting>

<para>Returns the length of the receiving string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>length method</secondary></indexterm>
<programlisting>
"abcdefgh"~length     ->    8
"abc defg"~length     ->    8
""~length             ->    0
</programlisting>
<para>(See <link linkend="bifLength">LENGTH</link>
for information about the LENGTH built-in function.)</para>
</section>

<section id="mthStringLower"><title>lower</title>
<indexterm><primary>lower method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lorer method</secondary>
<tertiary>of String class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-lower(+---+--+---------+---)----------------------><
         +-n-+  +-,length-+
]]>
</programlisting>

<para>Returns a new string with the characters of the target string beginning with
character <emphasis role="italic">n</emphasis> for <emphasis role="italic">length</emphasis>
characters converted to lowercase.  If <emphasis role="italic">n</emphasis> is specified, it must
be a positive whole number.  If <emphasis role="italic">n</emphasis> is not specified, the case
conversion will start with the first character.  If <emphasis role="italic">length</emphasis>
is specified, it must be a non-negative whole number.  If <emphasis role="italic">length</emphasis>
the default is to convert the remainder of the string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>lower method</secondary></indexterm>
<programlisting>
"Albert Einstein"~lower      ->    "albert einstein"
"ABCDEF"~lower(4)            ->    "ABCdef"
"ABCDEF"~lower(3,2)          ->    "ABcdEF"
</programlisting>
<para>(See <link linkend="bifLower">LOWER</link>
for information about the LOWER built-in function.)</para>
</section>

<section id="mthStringMakeArray"><title>makeArray</title>
<indexterm><primary>makeArray method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>makeArray method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-makeArray(-+-----------+-)----><
              +-Separator-+
]]>
</programlisting>

<para>This method returns an array of strings containing the single
lines that were separated using the separator character. The
default separator is the newline character.</para>

<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[
nl = "0d0a"x
string = "hello"nl"world"nl"this is an array."
array = string~makeArray
say "the second line is:" array[2]

string = "hello*world*this is an array."
array = string~makeArray("*")
say "the third line is:" array[3]
]]>
</programlisting>
</section>

<section id="mthStringmakeString"><title>makeString</title>
<indexterm><primary>makeString method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>makeString method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-makeString--------------------------------------------------><
]]>
</programlisting>

<para>Returns a string with the same string value as the receiver object. If
the receiver is an instance of a subclass of the String class, this method
returns an equivalent string object. If the receiver is a string object (not
an instance of a subclass of the String class), this method returns the receiver
object. See <link linkend="reqstr">Required String Values</link>.</para>
</section>

<section id="mthStringMatch"><title>match</title>
<indexterm><primary>match method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>match method</secondary>
<tertiary>of String class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-match(start,other-+----------------------------+-)-------------------><
                     +-,--+---+--+---------+-+
                          +-n-+  +-,length-+
]]>
</programlisting>

<para>Returns .true ("1") if the characters of the <emphasis role="italic">other</emphasis> match the
characters of the target string beginning at position <emphasis role="italic">start</emphasis>.  Return .false
("0") if the characters are not a match.
<emphasis role="italic">start</emphasis> must be a positive whole number less than or equal to the length of
the target string.
</para>
<para>If <emphasis role="italic">n</emphasis> is specified, the match will be performed starting with character
<emphasis role="italic">n</emphasis> of <emphasis role="italic">other</emphasis>.  The default value for
<emphasis role="italic">n</emphasis> is "1".  <emphasis role="italic">n</emphasis> must be a positive whole number
less than or equal to the length of <emphasis role="italic">other</emphasis>.
</para>
<para>If <emphasis role="italic">length</emphasis> is specified, it defines a substring of
<emphasis role="italic">other</emphasis> that is used for the match.  <emphasis role="italic">length</emphasis>
must be a positive whole number and the combination of <emphasis role="italic">n</emphasis> and
<emphasis role="italic">length</emphasis> must be a valid substring within the bounds of
<emphasis role="italic">other</emphasis>.</para>
<para>The match method is useful efficient string parsing as it does not require new string objects be extracted from
the target string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>match method</secondary></indexterm>
<programlisting>
"Saturday"~match("day", 6)           ->    1
"Saturday"~match("DAY", 6)           ->    0
"Saturday"~match("Sunday", 6, 4, 3)  ->    1
"Saturday"~match("daytime", 6, 3)    ->    1
</programlisting>
</section>

<section id="mthStringMatchChar"><title>matchChar</title>
<indexterm><primary>matchChar method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>matchChar method</secondary>
<tertiary>of String class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-matchChar(n,chars)-------------------------><
]]>
</programlisting>

<para>Returns .true ("1") if the character at position <emphasis role="italic">n</emphasis> matches any
character of the string <emphasis role="italic">chars</emphasis>.  Returns .false ("0") if the character does not
match any of the characters in the reference set.  The argmuent <emphasis role="italic">n</emphasis> must be
a positive whole number less than or equal to the length of the target string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>matchChar method</secondary></indexterm>
<programlisting>
"a+b"~matchChar(2, "+-*/")           ->    1
"a+b"~matchChar(1, "+-*/")           ->    0
"Friday"~matchChar(3, "aeiou")       ->    1
"FRIDAY"~matchChar(3, "aeiou")       ->    0
</programlisting>
</section>

<section id="mthStringMax"><title>max</title>
<indexterm><primary>max method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>max method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-max-+------------------+------------------------------------><
       |    +-,------.    |
       |    V        |    |
       +-(----number-+--)-+
]]>
</programlisting>

<para>Returns the largest number from among the receiver and any arguments. The
number that <emphasis role="bold">max</emphasis>
returns is formatted according to the current NUMERIC settings.
You can specify any number of <emphasis role="italic">number</emphasis>s.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>max method</secondary></indexterm>
<programlisting>
12~max(6,7,9)                                                ->    12
17.3~max(19,17.03)                                           ->    19
"-7"~max("-3","-4.3")                                        ->    -3
1~max(2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)   ->    21
</programlisting>
<para>(See <link linkend="bifMax">MAX (Maximum)</link>
for information about the MAX built-in function.)</para>
</section>

<section id="mthStringMin"><title>min</title>
<indexterm><primary>min method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>min method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-min-+------------------+------------------------------------><
       |    +-,------.    |
       |    V        |    |
       +-(----number-+--)-+
]]>
</programlisting>

<para>Returns the smallest number from among the receiver and any arguments.
The number that <emphasis role="bold">min</emphasis>
returns is formatted according to the current NUMERIC
settings. You can specify any number of
<emphasis role="italic">number</emphasis>s.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>min method</secondary></indexterm>
<programlisting>
12~min(6,7,9)                                                ->     6
17.3~min(19,17.03)                                           ->    17.03
"-7"~MIN("-3","-4.3")                                        ->    -7
21~min(20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1)   ->     1
</programlisting>
<para>(See <link linkend="bifMin">MIN (Minimum)</link>
for information about the MIN built-in function.)</para>
</section>

<section id="mthStringOverlay"><title>overlay</title>
<indexterm><primary>overlay method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>overlay method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>overlaying a string onto another</primary></indexterm>

<programlisting>
<![CDATA[
>>-overlay(new-+---------------------------------------+-)-----><
               +-,--+---+--+-------------------------+-+
                    +-n-+  +-,--+--------+--+------+-+
                                +-length-+  +-,pad-+
]]>
</programlisting>

<para>Returns the receiving string, which, starting at the
<emphasis role="italic">n</emphasis>th character,
is overlaid with the string <emphasis role="italic">new</emphasis>,
padded or truncated to length <emphasis role="italic">length</emphasis>.
The overlay can extend beyond the end of the receiving string.
If you specify <emphasis role="italic">length</emphasis>, it must be a positive
whole number or zero. The default value for
<emphasis role="italic">length</emphasis> is the length of
<emphasis role="italic">new</emphasis>. If <emphasis role="italic">n</emphasis>
is greater than the length of the receiving string, padding is added
before the <emphasis role="italic">new</emphasis> string. The default
<emphasis role="italic">pad</emphasis> character is a blank,
and the default value for <emphasis role="italic">n</emphasis> is
<computeroutput>1</computeroutput>. If you specify
<emphasis role="italic">n</emphasis>, it must be a positive whole number.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>overlay method</secondary></indexterm>
<programlisting>
"abcdef"~overlay(" ",3)         ->    "ab def"
"abcdef"~overlay(".",3,2)       ->    "ab. ef"
"abcd"~overlay("qq")            ->    "qqcd"
"abcd"~overlay("qq",4)          ->    "abcqq"
"abc"~overlay("123",5,6,"+")    ->    "abc+123+++"
</programlisting>
<para>(See <link linkend="bifOverlay">OVERLAY</link>
for information about the OVERLAY built-in function.)</para>
</section>

<section id="mthStringPos"><title>pos</title>
<indexterm><primary>pos method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>pos method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>finding</primary>
<secondary>string in another string</secondary></indexterm>
<indexterm><primary>locating</primary>
<secondary>string in another string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-pos(needle-+--------+-)-------------------------------------><
              +-,start-+
]]>
</programlisting>

<para>Returns the position in the receiving string of another string,
<emphasis role="italic">needle</emphasis>. (See also
<link linkend="mthStringLastPos">lastPos</link>.) It returns
<computeroutput>0</computeroutput> if
<emphasis role="italic">needle</emphasis> is the null string or is not found
or if <emphasis role="italic">start</emphasis> is greater than
the length of the receiving string. By default, the search starts at the first
character of the receiving string (that is, the value of
<emphasis role="italic">start</emphasis> is <computeroutput>1</computeroutput>).
You can override this by specifying <emphasis role="italic">start</emphasis>
(which must be
a positive whole number), the point at which the search starts.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>pos method</secondary></indexterm>
<programlisting>
"Saturday"~pos("day")       ->    6
"abc def ghi"~pos("x")      ->    0
"abc def ghi"~pos(" ")      ->    4
"abc def ghi"~pos(" ",5)    ->    8
</programlisting>
<para>(See <link linkend="bifPos">POS (Position)</link>
for information about the POS built-in function.)</para>
</section>

<section id="mthStringReverse"><title>reverse</title>
<indexterm><primary>reverse method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>reverse method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-reverse-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the receiving string reversed.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>reverse method</secondary></indexterm>
<programlisting>
"ABc."~reverse    ->    ".cBA"
"XYZ "~reverse    ->    " ZYX"
</programlisting>
<para>(See <link linkend="bifReverse">REVERSE</link>
for information about the REVERSE built-in function.)</para>
</section>

<section id="mthStringRight"><title>right</title>
<indexterm><primary>right method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>right method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text right justification</secondary></indexterm>
<indexterm><primary>justification, text right, RIGHT method</primary>
</indexterm>
<indexterm><primary>leading</primary>
<secondary>zeros</secondary>
<tertiary>adding with right method</tertiary></indexterm>
<indexterm><primary>zeros</primary>
<secondary>added on left with right method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-right(length-+------+-)-------------------------------------><
                +-,pad-+
]]>
</programlisting>

<para>Returns a string of length <emphasis role="italic">length</emphasis>
containing the rightmost <emphasis role="italic">length</emphasis> characters
of the receiving string. The string returned is padded
with <emphasis role="italic">pad</emphasis> characters, or truncated, on the
left as needed. The default <emphasis role="italic">pad</emphasis> character
is a blank. The <emphasis role="italic">length</emphasis> must be a positive
whole number or zero.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>right method</secondary></indexterm>
<programlisting>
"abc  d"~right(8)     ->    "  abc  d"
"abc def"~right(5)    ->    "c def"
"12"~right(5,"0")     ->    "00012"
</programlisting>
<para>(See <link linkend="bifRight">RIGHT</link>
for information about the RIGHT built-in function.)</para>
</section>

<section id="mthStringSign"><title>sign</title>
<indexterm><primary>sign method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sign method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sign--------------------------------------------------------><
]]>
</programlisting>

<para>Returns a number that indicates the sign of the receiving string, which
is a number. The receiving string is first rounded according to standard Rexx
rules, as though the operation
<computeroutput>receiving_string+0</computeroutput> had been carried
out. It returns <computeroutput>-1</computeroutput> if the receiving string is
less than <computeroutput>0</computeroutput>,
<computeroutput>0</computeroutput> if it is
<computeroutput>0</computeroutput>, and <computeroutput>1</computeroutput>
if it is greater than <computeroutput>0</computeroutput>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>sign method</secondary></indexterm>
<programlisting>
"12.3"~sign       ->     1
" -0.307"~sign    ->    -1
0.0~sign          ->     0
</programlisting>
<para>(See <link linkend="bifSign">SIGN</link>
for information about the SIGN built-in function.)</para>
</section>

<section id="mthStringSpace"><title>space</title>
<indexterm><primary>space method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>space method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text spacing</secondary></indexterm>
<indexterm><primary>spacing, formatting, space method</primary></indexterm>

<programlisting>
<![CDATA[
>>-space-+---------------+-------------------------------------><
         +-(n-+------+-)-+
              +-,pad-+
]]>
</programlisting>

<para>Returns the blank-delimited words in the receiving string, with
<emphasis role="italic">n</emphasis>&nbsp;<emphasis role="italic">pad</emphasis>
characters between each word. If you specify
<emphasis role="italic">n</emphasis>, it must
be a positive whole number or zero. If it is
<computeroutput>0</computeroutput>, all blanks are
removed. Leading and trailing blanks are always removed. The default for
<emphasis role="italic">n</emphasis> is <computeroutput>1</computeroutput>,
and the default <emphasis role="italic">pad</emphasis> character is a blank.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>space method</secondary></indexterm>
<programlisting>
"abc  def  "~space           ->    "abc def"
"  abc def"~space(3)         ->    "abc   def"
"abc  def  "~space(1)        ->    "abc def"
"abc  def  "~space(0)        ->    "abcdef"
"abc  def  "~space(2,"+")    ->    "abc++def"
</programlisting>
<para>(See <link linkend="bifSpace">SPACE</link>
for information about the SPACE built-in function.)</para>
</section>

<section id="mthStringStrip"><title>strip</title>
<indexterm><primary>strip method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>strip method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>blanks</primary>
<secondary>removal with strip method</secondary></indexterm>
<indexterm><primary>character</primary>
<secondary>removal with strip method</secondary></indexterm>
<indexterm><primary>leading</primary>
<secondary>zeros</secondary>
<tertiary>removing with strip method</tertiary></indexterm>
<indexterm><primary>leading</primary>
<secondary>blank removal with strip method</secondary></indexterm>
<indexterm><primary>trailing</primary>
<secondary>blank removed using strip method</secondary></indexterm>
<indexterm><primary>zeros</primary>
<secondary>removal with strip method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-strip-+---------------------+-------------------------------><
         +-(option-+-------+-)-+
                   +-,char-+
]]>
</programlisting>

<para>Returns the receiving string with leading characters, trailing characters,
or both, removed, based on the <emphasis role="italic">option</emphasis> you
specify. The following are valid <emphasis role="italic">option</emphasis>s.
(You need to specify only the first capitalized
letter; the language processor ignores all characters following it.) </para>
<variablelist>
<varlistentry><term>Both</term>
<listitem><para>Removes both leading and trailing characters. This is the
default.
</para></listitem></varlistentry>
<varlistentry><term>Leading</term>
<listitem><para>Removes leading characters.
</para></listitem></varlistentry>
<varlistentry><term>Trailing</term>
<listitem><para>Removes trailing characters.
</para></listitem></varlistentry>
</variablelist>
<para>The <emphasis role="italic">char</emphasis> specifies the character to be
removed, and the default is a blank. If you specify
<emphasis role="italic">char</emphasis>, it must be exactly one character
long.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>strip method</secondary></indexterm>
<programlisting>
"  ab c  "~strip         ->    "ab c"
"  ab c  "~strip("L")    ->    "ab c  "
"  ab c  "~strip("t")    ->    "  ab c"
"12.7000"~strip(,0)      ->    "12.7"
"0012.700"~strip(,0)     ->    "12.7"
</programlisting>
<para>(See <link linkend="bifStrip">STRIP</link>
for information about the STRIP built-in function.)</para>
</section>

<section id="mthStringsubchar"><title>subchar</title>
<indexterm><primary>subchar method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>subchar method</secondary>
<tertiary>of String</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-subchar(n)----------------------------------------------><
]]>
</programlisting>

<para>Returns the <emphasis>n</emphasis>'th character of the receiving
string. <emphasis>n</emphasis> must be a positive whole number. If
<emphasis>n</emphasis> is greater that the length of the receiving string
then a zero-length string is returned.</para>
</section>

<section id="mthStringSubstr"><title>substr</title>
<indexterm><primary>substr method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>substr method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>extracting</primary>
<secondary>substring</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>extracting using substr method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-substr(n-+-------------------------+-)----------------------><
            +-,--+--------+--+------+-+
                 +-length-+  +-,pad-+
]]>
</programlisting>

<para>Returns the substring of the receiving string that begins at the
<emphasis role="italic">n</emphasis>th character and is of length
<emphasis role="italic">length</emphasis>, padded with
<emphasis role="italic">pad</emphasis> if
necessary. The <emphasis role="italic">n</emphasis> must be a positive whole
number. If <emphasis role="italic">n</emphasis> is
greater than <computeroutput>receiving_string~length</computeroutput>,
only pad characters are returned.</para>
<para>If you omit <emphasis role="italic">length</emphasis>, the rest of the
string is returned. The default <emphasis role="italic">pad</emphasis>
character is a blank.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>subStr method</secondary></indexterm>
<programlisting>
"abc"~substr(2)          ->    "bc"
"abc"~substr(2,4)        ->    "bc  "
"abc"~substr(2,6,".")    ->    "bc...."
</programlisting>

<note><title>Note</title>
<para>In some situations the positional (numeric) patterns
of parsing templates are more convenient for selecting substrings, in particular
if you need to extract more than one substring from a string. See also
<link linkend="mthStringLeft">left</link> and <link linkend="mthStringRight">right</link>.
</para></note>
<para>(See <link linkend="bifSubstr">SUBSTR (Substring)</link>
for information about the SUBSTR built-in function.)</para>
</section>

<section id="mthStringSubWord"><title>subWord</title>
<indexterm><primary>subWord method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>subWord method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>extracting words with subWord</primary></indexterm>
<indexterm><primary>word</primary>
<secondary>extracting from a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-subWord(n-+---------+-)-------------------------------------><
             +-,length-+
]]>
</programlisting>

<para>Returns the substring of the receiving string that starts at the
<emphasis role="italic">n</emphasis>th word and is up to
<emphasis role="italic">length</emphasis> blank-delimited words. The
<emphasis role="italic">n</emphasis> must be a positive whole number.
If you omit <emphasis role="italic">length</emphasis>, it defaults
to the number of remaining words in the receiving string. The returned string
never has leading or trailing blanks, but includes all blanks between the
selected words.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>subWord method</secondary></indexterm>
<programlisting>
"Now is the  time"~subWord(2,2)    ->    "is the"
"Now is the  time"~subWord(3)      ->    "the  time"
"Now is the  time"~subWord(5)      ->    ""
</programlisting>
<para>(See <link linkend="bifSubword">SUBWORD</link>
for information about the SUBWORD built-in
function.)</para>
</section>

<section id="mthStringTranslate"><title>translate</title>
<indexterm><primary>translate method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>translate method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>reordering data</primary></indexterm>
<indexterm><primary>translation</primary>
<secondary>with translate method</secondary></indexterm>
<indexterm><primary>uppercase translation</primary>
<secondary>with translate method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-translate-+-----------------------------------------------+-><
             +-(--+-------------------------------------+--)-+
                  +-tableo--+-------------------------+-+
                            +-,--+--------+--+------+-+
                                 +-tablei-+  +-,pad-+
]]>
</programlisting>

<para>Returns the receiving string with each character translated to another
character or unchanged. You can also use this method to reorder the characters
in the receiving string.</para>
<para>The output table is <emphasis role="italic">tableo</emphasis>
and the input translation table is <emphasis role="italic">tablei</emphasis>.
<emphasis role="bold">translate</emphasis> searches
<emphasis role="italic">tablei</emphasis> for each character
in the receiving string. If the character is found, the corresponding character
in <emphasis role="italic">tableo</emphasis> is used in the result string. If
there are duplicates in <emphasis role="italic">tablei</emphasis>, the first
(leftmost) occurrence is used. If the character is
not found, the original character in the receiving string is used. The result
string is always of the same length as the receiving string.</para>
<para>The tables can be of any length. If you specify neither translation table and
omit <emphasis role="italic">pad</emphasis>, the receiving string is
translated to uppercase (that is, lowercase
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>
to uppercase
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>),
but if you include <emphasis role="italic">pad</emphasis>
the language processor translates the entire
string to <emphasis role="italic">pad</emphasis> characters.
<emphasis role="italic">tablei</emphasis> defaults to
<computeroutput>XRANGE("00"x,"FF"x)</computeroutput>, and
<emphasis role="italic">tableo</emphasis> defaults to the null string and
is padded with <emphasis role="italic">pad</emphasis> or truncated as necessary.
The default <emphasis role="italic">pad</emphasis> is a blank.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>translate method</secondary></indexterm>
<programlisting>
"abcdef"~translate                     ->    "ABCDEF"
"abcdef"~translate("12","ec")          ->    "ab2d1f"
"abcdef"~translate("12","abcd",".")    ->    "12..ef"
"APQRV"~translate(,"PR")               ->    "A Q V"
"APQRV"~translate(XRANGE("00"X,"Q"))   ->    "APQ  "
"4123"~translate("abcd","1234")        ->    "dabc"
</programlisting>

<note><title>Note</title>
<para>The last example shows how to use the
<emphasis role="bold">translate</emphasis> method
to reorder the characters in a string. In the example, the last character
of any 4-character string specified as the first argument would be moved to
the beginning of the string.</para></note>
<para>(See <link linkend="bifTranslate">TRANSLATE</link>
for information about the TRANSLATE built-in
function.)</para>
</section>

<section id="mthStringTrunc"><title>trunc</title>
<indexterm><primary>trunc method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>trunc method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>numbers with trunc</secondary></indexterm>
<indexterm><primary>trincating numbers</primary></indexterm>
<indexterm><primary>numbers</primary>
<secondary>truncating</secondary></indexterm>


<programlisting>
<![CDATA[
>>-trunc-+-----+-----------------------------------------------><
         +-(n)-+
]]>
</programlisting>

<para>Returns the integer part the receiving string, which is a number, and
<emphasis role="italic">n</emphasis> decimal places. The default
<emphasis role="italic">n</emphasis> is <computeroutput>0</computeroutput>
and returns an integer with no decimal point. If you specify
<emphasis role="italic">n</emphasis>, it must be a
positive whole number or zero. The receiving string is first rounded according
to standard Rexx rules, as though the operation
<computeroutput>receiving_string+0</computeroutput> had been carried out.
This number is then truncated to <emphasis role="italic">n</emphasis> decimal
places or trailing zeros are added if needed to reach the specified length.
The result is never in exponential form. If there are no nonzero digits in
the result, any minus sign is removed.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>trunc method</secondary></indexterm>
<programlisting>
12.3~trunc            ->    12
127.09782~trunc(3)    ->    127.097
127.1~trunc(3)        ->    127.100
127~trunc(2)          ->    127.00
</programlisting>

<note><title>Note</title>
<para>The <emphasis role="italic">number</emphasis> is rounded according to the
current setting of NUMERIC DIGITS if necessary, before the method processes it.
</para></note>
<para>(See <link linkend="bifTrunc">TRUNC (Truncate)</link>
for information about the TRUNC built-in function.)</para>
</section>

<section id="mthStringUpper"><title>upper</title>
<indexterm><primary>upper method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>upper method</secondary>
<tertiary>of String class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-upper(+---+--+---------+---)----------------------><
         +-n-+  +-,length-+
]]>
</programlisting>

<para>Returns a new string with the characters of the target string beginning with
character <emphasis role="italic">n</emphasis> for <emphasis role="italic">length</emphasis>
characters converted to uppercase.  If <emphasis role="italic">n</emphasis> is specified, it must
be a positive whole number.  If <emphasis role="italic">n</emphasis> is not specified, the case
conversion will start with the first character.  If <emphasis role="italic">length</emphasis>
is specified, it must be a non-negative whole number.  If <emphasis role="italic">length</emphasis>
the default is to convert the remainder of the string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>upper method</secondary></indexterm>
<programlisting>
"Albert Einstein"~upper      ->    "ALBERT EINSTEIN"
"abcdef"~upper(4)            ->    "abcDEF"
"abcdef"~upper(3,2)          ->    "abCDef"
</programlisting>
<para>(See <link linkend="bifUpper">UPPER</link>
for information about the UPPER built-in function.)</para>
</section>

<section id="mthStringVerify"><title>verify</title>
<indexterm><primary>verify method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>verify method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>string</primary>
<secondary>verifying contents of</secondary></indexterm>
<indexterm><primary>verifying contents of a string</primary></indexterm>

<programlisting>
<![CDATA[
>>-verify(reference-+---------------------------+-)------------><
                    +-,--+--------+--+--------+-+
                         +-option-+  +-,start-+
]]>
</programlisting>

<para>Returns a number that, by default, indicates whether the receiving string
is composed only of characters from
<emphasis role="italic">reference</emphasis>. It returns
<computeroutput>0</computeroutput> if all characters in the receiving string
are in <emphasis role="italic">reference</emphasis> or
returns the position of the first character in the receiving string not in
<emphasis role="italic">reference</emphasis>.</para>
<para>The <emphasis role="italic">option</emphasis> can be either
<computeroutput>Nomatch</computeroutput> (the
default) or <computeroutput>Match</computeroutput>. (You need to specify only
the first capitalized and highlighted letter; the language processor ignores
all characters following the first character, which can be in uppercase or
lowercase.)</para>
<para>If you specify <computeroutput>Match</computeroutput>, the method returns
the position of the first character in the receiving string that is in
<emphasis role="italic">reference</emphasis>, or returns
<computeroutput>0</computeroutput> if none of the characters
are found.</para>
<para>The default for <emphasis role="italic">start</emphasis> is
<computeroutput>1</computeroutput>. Thus, the search starts
at the first character of the receiving string. You can override this by
specifying a different <emphasis role="italic">start</emphasis> point,
which must be a positive whole number.</para>
<para>If the receiving string is null, the method returns
<computeroutput>0</computeroutput>, regardless
of the value of the <emphasis role="italic">option</emphasis>. Similarly, if
<emphasis role="italic">start</emphasis> is greater
than <computeroutput>receiving_string~length</computeroutput>, the method
returns <computeroutput>0</computeroutput>. If
<emphasis role="italic">reference</emphasis> is null, the method returns
<computeroutput>0</computeroutput> if
you specify <computeroutput>Match</computeroutput>. Otherwise, the method
returns the <emphasis role="italic">start</emphasis> value.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>verify method</secondary></indexterm>
<programlisting>
"123"~verify("1234567890")             ->    0
"1Z3"~verify("1234567890")             ->    2
"AB4T"~verify("1234567890")            ->    1
"AB4T"~verify("1234567890","M")        ->    3
"AB4T"~verify("1234567890","N")        ->    1
"1P3Q4"~verify("1234567890", ,3)       ->    4
"123"~verify("",N,2)                   ->    2
"ABCDE"~verify("", ,3)                 ->    3
"AB3CD5"~verify("1234567890","M",4)    ->    6
</programlisting>
<para>(See <link linkend="bifVerify">VERIFY</link>
for information about the VERIFY built-in function.)</para>
</section>

<section id="mthStringWord"><title>word</title>
<indexterm><primary>word method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>word method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>extracting</primary>
<secondary>word from a string</secondary></indexterm>
<indexterm><primary>locating</primary>
<secondary>word in another string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-word(n)-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the <emphasis role="italic">n</emphasis>th blank-delimited word
in the receiving string or the null string if the receiving string has
fewer than <emphasis role="italic">n</emphasis> words. The
<emphasis role="italic">n</emphasis> must be a positive whole number. This
method is exactly equivalent
to <computeroutput>receiving_string~subWord(n,1)</computeroutput>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>word method</secondary></indexterm>
<programlisting>
"Now is the time"~word(3)    ->    "the"
"Now is the time"~word(5)    ->    ""
</programlisting>
<para>(See <link linkend="bifWord">WORD</link>
for information about the WORD built-in function.)</para>
</section>

<section id="mthStringWordIndex"><title>wordIndex</title>
<indexterm><primary>wordIndex method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>wordIndex method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-wordIndex(n)------------------------------------------------><
]]>
</programlisting>

<para>Returns the position of the first character in the
<emphasis role="italic">n</emphasis>th blank-delimited
word in the receiving string. It returns <computeroutput>0</computeroutput>
if the receiving string has fewer than <emphasis role="italic">n</emphasis>
words. The <emphasis role="italic">n</emphasis> must be a positive whole number.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>wordIndex method</secondary></indexterm>
<programlisting>
"Now is the time"~wordIndex(3)    ->    8
"Now is the time"~wordIndex(6)    ->    0
</programlisting>
<para>(See <link linkend="bifWordindex">WORDINDEX</link>
for information about the WORDINDEX built-in
function.)</para>
</section>

<section id="mthStringWordLength"><title>wordLength</title>
<indexterm><primary>wordLength method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>wordLength method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>finding</primary>
<secondary>word length</secondary></indexterm>

<programlisting>
<![CDATA[
>>-wordLength(n)-----------------------------------------------><
]]>
</programlisting>

<para>Returns the length of the <emphasis role="italic">n</emphasis>th
blank-delimited word in the receiving
string or <computeroutput>0</computeroutput> if the receiving string has fewer
than <emphasis role="italic">n</emphasis> words.
The <emphasis role="italic">n</emphasis> must be a positive whole number.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>wordLength method</secondary></indexterm>
<programlisting>
"Now is the time"~wordLength(2)       ->    2
"Now comes the time"~wordLength(2)    ->    5
"Now is the time"~wordLength(6)       ->    0
</programlisting>
<para>(See <link linkend="bifWordlength">WORDLENGTH</link>
for information about the WORDLENGTH built-in
function.)</para>
</section>

<section id="mthStringWordPos"><title>wordPos</title>
<indexterm><primary>wordPos method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>wordPos method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>word</primary>
<secondary>locating in a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-wordPos(phrase-+--------+-)---------------------------------><
                  +-,start-+
]]>
</programlisting>

<para>Returns the word number of the first word of
<emphasis role="italic">phrase</emphasis> found in the
receiving string, or <computeroutput>0</computeroutput> if
<emphasis role="italic">phrase</emphasis> contains no words or
if <emphasis role="italic">phrase</emphasis> is not found. Several blanks
between words in either <emphasis role="italic">phrase</emphasis> or the
receiving string are treated as a single blank for the
comparison, but, otherwise, the words must match exactly.</para>
<para>By default the search starts at the first word in the receiving string.
You can override this by specifying <emphasis role="italic">start</emphasis>
(which must be positive),
the word at which the search is to be started.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>wordPos method</secondary></indexterm>
<programlisting>
"now is the time"~wordPos("the")              ->  3
"now is the time"~wordPos("The")              ->  0
"now is the time"~wordPos("is the")           ->  2
"now is the time"~wordPos("is   the")         ->  2
"now is   the time"~wordPos("is   time ")     ->  0
"To be or not to be"~wordPos("be")            ->  2
"To be or not to be"~wordPos("be",3)          ->  6
</programlisting>
<para>(See <link linkend="bifWordpos">WORDPOS (Word Position)</link>
for information about the WORDPOS built-in
function.)</para>
</section>

<section id="mthStringWords"><title>words</title>
<indexterm><primary>words method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>words method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>counting</primary>
<secondary>words in a string</secondary></indexterm>
<indexterm><primary>extracting</primary>
<secondary>words from a string</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>counting in a string</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>extracting from a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-words-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of blank-delimited words in the receiving string.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>words method</secondary></indexterm>
<programlisting>
"Now is the time"~words      ->    4
" "~words                    ->    0
</programlisting>
<para>(See <link linkend="bifWords">WORDS</link>
for information about the WORDS built-in function.)</para>
</section>

<section id="mthStringX2b"><title>x2b</title>
<indexterm><primary>x2b method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>x2b method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>hexadecimal to binary</secondary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>to binary, converting with X2B</secondary></indexterm>

<programlisting>
<![CDATA[
>>-x2b---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string, in character format, that represents the receiving
string, which is a string of hexadecimal characters converted to binary. The
receiving string can be of any length. Each hexadecimal character is converted
to a string of 4 binary digits. The receiving string can optionally include
blanks (at byte boundaries only, not leading or trailing) to improve
readability; they are ignored.</para>
<para>The returned string has a length that is a multiple of four, and does not
include any blanks.</para>
<para>If the receiving string is null, the method returns a null string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>x2b method</secondary></indexterm>
<programlisting>
"C3"~x2b        ->  "11000011"
"7"~x2b         ->  "0111"
"1 C1"~x2b      ->  "000111000001"
</programlisting>
<para>You can combine <emphasis role="bold">x2b</emphasis>
with the methods <emphasis role="bold">d2x</emphasis> and
<emphasis role="bold">c2x</emphasis> to convert numbers or
character strings into binary form.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
"C3"x~c2x~x2b  ->  "11000011"
"129"~d2x~x2b  ->  "10000001"
"12"~d2x~x2b   ->  "1100"
</programlisting>
<para>(See <link linkend="bifX2b">X2B (Hexadecimal to Binary)</link>
for information about the X2B built-in function.)</para>
</section>

<section id="mthStringX2c"><title>x2c</title>
<indexterm><primary>x2c method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>x2c method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>hexadecimal to character</secondary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>to character, converting with X2C</secondary></indexterm>
<indexterm><primary>packing a string with X2C</primary></indexterm>

<programlisting>
<![CDATA[
>>-x2c---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string, in character format, that represents the receiving
string, which is a hexadecimal string converted to character. The returned string
is half as many bytes as the receiving string. The receiving string can be
any length. If necessary, it is padded with a leading 0 to make an even number
of hexadecimal digits.</para>
<para>You can optionally include blanks in the receiving string (at byte boundaries
only, not leading or trailing) to improve readability; they are ignored.</para>
<para>If the receiving string is null, the method returns a null string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>x2c method</secondary></indexterm>
<programlisting>
"4865 6c6c 6f"~x2c ->  "Hello"     /*  ASCII             */
"3732 73"~x2c      ->  "72s"       /*  ASCII             */
</programlisting>
<para>(See <link linkend="bifX2c">X2C (Hexadecimal to Character)</link>
for information about the X2C built-in function.)</para>
</section>

<section id="mthStringX2d"><title>x2d</title>
<indexterm><primary>x2d method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>x2d method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>hexadecimal to deciaml</secondary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>to decimal, converting with X2D</secondary></indexterm>

<programlisting>
<![CDATA[
>>-x2d-+-----+-------------------------------------------------><
       +-(n)-+
]]>
</programlisting>

<para>Returns the decimal representation of the receiving string, which is a
string of hexadecimal characters. If the result cannot be expressed as a whole
number, an error results. That is, the result must not have more digits than
the current setting of NUMERIC DIGITS.</para>
<para>You can optionally include blanks in the receiving string (at byte
boundaries only, not leading or trailing) to improve readability; they are
ignored.</para>
<para>If the receiving string is null, the method returns
<computeroutput>0</computeroutput>.</para>
<para>If you do not specify <emphasis role="italic">n</emphasis>,
the receiving string is processed as
an unsigned binary number.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>x2d method</secondary></indexterm>
<programlisting>
"0E"~x2d        ->    14
"81"~x2d        ->    129
"F81"~x2d       ->    3969
"FF81"~x2d      ->    65409
"46 30"X~x2d    ->    240          /*  ASCII   */
"66 30"X~x2d    ->    240          /*  ASCII   */
</programlisting>
<para>If you specify <emphasis role="italic">n</emphasis>, the receiving string
is taken as a signed number expressed in <emphasis role="italic">n</emphasis>
hexadecimal digits. If the leftmost bit is off, then
the number is positive; otherwise, it is a negative number. In both cases
it is converted to a whole number, which can be negative. If
<emphasis role="italic">n</emphasis> is <computeroutput>0</computeroutput>,
the method returns <computeroutput>0</computeroutput>.</para>
<para>If necessary, the receiving string is padded on the left with
<computeroutput>0</computeroutput> characters
(note, not &quot;sign-extended&quot;), or truncated on the left to
<emphasis role="italic">n</emphasis> characters.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
"81"~x2d(2)      ->    -127
"81"~x2d(4)      ->    129
"F081"~x2d(4)    ->    -3967
"F081"~x2d(3)    ->    129
"F081"~x2d(2)    ->    -127
"F081"~x2d(1)    ->    1
"0031"~x2d(0)    ->    0
</programlisting>
<para>(See <link linkend="bifX2d">X2D (Hexadecimal to Decimal)</link>
for information about the X2D built-in function.)</para>
</section>
</section>

<section id="clsMethod"><title>The Method Class</title>
<indexterm><primary>Method class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Method class</secondary></indexterm>

<para>The Method class creates method objects from Rexx source code.
It is a subclass of the <link linkend="clsObject">Object class</link>.</para>
<figure><title>The Method class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxMethodClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Method class also has available class methods that its
metaclass, the Class class, defines.</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;

</section>

<section id="mthMethodNew"><title>new (Class Method)</title>
<indexterm><primary>new method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new(name,source--+------------------+---)-------------------><
                    +--, methodobject--+
]]>
</programlisting>

<para>Returns a new instance of method class, which is an executable
representation of the code contained in the
<emphasis role="italic">source</emphasis>. The
<emphasis role="italic">name</emphasis> is a string.
The <emphasis role="italic">source</emphasis> can be a single string or an
array of strings containing individual method lines.</para>

<para>The third parameter influences the scope of the method. If none is
given, the program scope is used. If another method object is given,
its scope is used.</para>

</section>

<section id="mthMethodNewFile"><title>newFile (Class Method)</title>
<indexterm><primary>newFile method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>newFile method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-newFile(filename)-------------------------------------------><
]]>
</programlisting>

<para>Returns a new instance of method class, which is an executable
representation of the code contained in the file filename. The filename is a
string.</para>
<para>For an example of the use of this method, see the code example
<link linkend="servex">Server implements Security Manager</link>.</para>
</section>

<section id="mthMethodSetGuarded"><title>setGuarded</title>
<indexterm><primary>setGuarded method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>setGuarded method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<indexterm><primary>concurrency</primary>
<secondary>setGuarded method</secondary></indexterm>
<programlisting>
<![CDATA[
>>-setGuarded--------------------------------------------------><
]]>
</programlisting>

<para>Reverses any previous
<emphasis role="bold">setUnguarded</emphasis> messages, restoring the receiver to
the default guarded status. If the receiver is already guarded, a
<emphasis role="bold">setGuarded</emphasis> message has no effect.</para>
</section>

<section id="mthMethodSetPrivate"><title>setPrivate</title>
<indexterm><primary>setPrivate method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>setPrivate method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-setPrivate--------------------------------------------------><
]]>
</programlisting>

<para>Specifies that a method is a private method. Only
a message that an object sends to itself can run a private method. If a method
object does not receive a <emphasis role="bold">setPrivate</emphasis>
message, the method is a public method.
(Any object can send a message to run a public method. See
<link linkend="pubpri">Public and Private Methods</link> for
details.)</para>
</section>

<section id="mthMethodSetProtected"><title>setProtected</title>
<indexterm><primary>setProtected method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>setProtected method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-setProtected------------------------------------------------><
]]>
</programlisting>

<para>Specifies thata method is a protected method. If a method
object does not receive a <emphasis role="bold">setProtected</emphasis>
message, the method is not protected.
(See <link linkend="secman">The Security Manager</link> for details.)</para>
</section>

<section id="mthMethodSetSecurityManager"><title>setSecurityManager</title>
<indexterm><primary>setSecurityManager method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>setSecurityManager method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-setSecurityManager--+---------------------------+-----------><
                       +-(security_manager_object)-+
]]>
</programlisting>

<para>Replaces the existing security manager with the specified
<emphasis role="italic">security_manager_object</emphasis>. If
<emphasis role="italic">security_manager_object</emphasis> is omitted, any
existing security manager is removed.</para>
</section>

<section id="mthMethodSetUnguarded"><title>setUnguarded</title>
<indexterm><primary>setUnguarded method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>setUnguarded method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<indexterm><primary>concurrency</primary>
<secondary>setUnguarded method</secondary></indexterm>
<programlisting>
<![CDATA[
>>-setUnguarded------------------------------------------------><
]]>
</programlisting>

<para>Lets an object run a method even when
another method is active on the same object. If a method object does not receive
a <emphasis role="bold">setUnguarded</emphasis>
message, it requires exclusive use of its object variable pool.
A method can be active for an object only when no other method requiring exclusive
access to the object's variable pool is active in the same object. This
restriction does not apply if an object sends itself a message to run a method
and it already has exclusive use of the same object variable pool. In this
case, the method runs immediately and has exclusive use of its object variable
pool, regardless of whether it received a
<emphasis role="bold">setUnguarded</emphasis> message.</para>
</section>

<section id="mthMethodSource"><title>source</title>
<indexterm><primary>source method</primary>
<secondary>of Method class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>source method</secondary>
<tertiary>of Method class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-source------------------------------------------------------><
]]>
</programlisting>
<para>Returns the method source code as a single-index array of source
lines. If the source code is not available,
<emphasis role="bold">source</emphasis> returns an array of zero
items.</para>
</section>
</section>

<section id="clsMessage"><title>The Message Class</title>
<indexterm><primary>Message class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Message class</secondary></indexterm>

<para>A message object provides for the deferred or
asynchronous sending of a message. You can create a message object by using
the <emphasis role="bold">new</emphasis> or
<emphasis role="bold">enhanced</emphasis> method of the Message class or the
<emphasis role="bold">start</emphasis> method of the
Object class (see <link linkend="mthObjectStart">start</link>). The Message class is
a subclass of the Object class.</para>
<figure><title>The Message class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxMessageClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Message class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;

</section>

<section id="mthMessageNew"><title>new (Class Method)</title>
<indexterm><primary>new method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new(target,messagename-+-------------------------------+-)--><
                          |             +---------------+ |
                          |             V               | |
                          +-,Individual---+-----------+-+-+
                          |               +-,argument-+   |
                          +-,Array,argument---------------+
]]>
</programlisting>

<para>Initializes the message object for sending the message name
<emphasis role="italic">messagename</emphasis> to object
<emphasis role="italic">target</emphasis>.</para>
<para>The <emphasis role="italic">messagename</emphasis> can be a string or an
array. If <emphasis role="italic">messagename</emphasis> is an array object,
its first item is the name of the message and its
second item is a class object to use as the starting point for the method
search. For more information, see
<link linkend="meths1">Classes and Inheritance</link>.</para>
<para>If you specify the Individual or Array option, any remaining arguments
are arguments for the message. (You need to specify only the first letter;
the language processor ignores all characters following it.) </para>
<variablelist>
<varlistentry><term>Individual</term>
<listitem><para>If you specify this option, specifying
<emphasis role="italic">argument</emphasis> is optional.
The language processor passes any <emphasis role="italic">argument</emphasis>s
as message arguments
to <emphasis role="italic">target</emphasis> in the order you specify them.
</para></listitem></varlistentry>
<varlistentry><term>Array</term>
<listitem><para>If you specify this option, you must specify an
<emphasis role="italic">argument</emphasis>, which
is an array object. (See <link linkend="clsArray">The Array Class</link>.)
The language processor then passes the member items of the array to
<emphasis role="italic">target</emphasis>. When the language
processor passes the arguments taken from the array, the first argument is
at index 1, the second argument at index 2, and so on. If you omitted any
indexes when creating the array, the language processor omits their
corresponding message arguments when passing the arguments.
</para></listitem></varlistentry>
</variablelist>
<para>If you specify neither Individual nor Array, the message sent has no
arguments. </para>

<note><title>Note</title>
<para>This method does not send the message
<emphasis role="italic">messagename</emphasis> to object
<emphasis role="italic">target</emphasis>. The SEND or START method
(described later) sends the message.
</para></note>
</section>

<section id="mthMessageArguments"><title>arguments</title>
<indexterm><primary>arguments method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>arguments method</secondary>
<tertiary>of Message class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-arguments----------------------------------------------><
]]>
</programlisting>

<para>Returns an array of argument objects used to invoke the message.</para>
</section>

<section id="mthMessageCompleted"><title>completed</title>
<indexterm><primary>completed method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>completed method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-completed---------------------------------------------------><
]]>
</programlisting>
<para>Returns <computeroutput>1</computeroutput> if the message object has
completed its message, or <computeroutput>0</computeroutput>. You can use this
method instead of sending
<emphasis role="bold">result</emphasis> and waiting for
the message to complete.</para>
</section>

<section id="mthMessageErrorCondition"><title>errorCondition</title>
<indexterm><primary>errorCondition method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>errorCondition method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-errorCondition----------------------------------------------><
]]>
</programlisting>

<para>Returns an error condition object from an execution error in the message
object's message. If the message completed normally, or is still executing,
<emphasis role="bold">errorCondition</emphasis> returns the .nil object.</para>
</section>

<section id="mthMessageHasError"><title>hasError</title>
<indexterm><primary>hasError method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasError method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasError----------------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> if the message object's
message was terminated with an error condition. Returns
<computeroutput>0</computeroutput> if the message has not completed or
completed without error.</para>
</section>

<section id="mthMessageMessageName"><title>messageName</title>
<indexterm><primary>messageName method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>messageName method</secondary>
<tertiary>of Message class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-messageName----------------------------------------------><
]]>
</programlisting>

<para>Returns the string message name used to invoke a method.</para>
</section>

<section id="mthMessageNotify"><title>notify</title>
<indexterm><primary>notify method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>notify method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-notify(message)---------------------------------------------><
]]>
</programlisting>

<para>Requests notification about the completion of processing of the message
<emphasis role="bold">send</emphasis> or <emphasis role="bold">start</emphasis>.
The message object <emphasis role="italic">message</emphasis>
is sent as the notification. You can use
<emphasis role="bold">notify</emphasis> to request any number of
notifications. After the notification
message, you can use the <emphasis role="bold">result</emphasis>
method to obtain any result from the messages
<emphasis role="bold">send</emphasis> or
<emphasis role="bold">start</emphasis>.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>notify method</secondary></indexterm>
<programlisting>
/* Event-driven greetings */

.prompter~new~prompt(.nil)

:class prompter

::method prompt
  expose name
  use arg msg

  if msg \= .nil then do
    name = msg~result
    if name = "quit" then return
    say "Hello," name
  end

  say &apos;Enter your name ("quit" to quit):&apos;

  /* Send the public default object .INPUT a LINEIN message asynchronously */
  msg=.message~new(.input,"LINEIN")~~start

  /* Sends self~prompt(msg) when data available   */
  msg~notify(.message~new(self,"PROMPT","I",msg))

  /* Don&apos;t leave until user has entered "quit"    */
  guard on when name="quit"
  </programlisting>
</section>

<section id="mthMessageResult"><title>result</title>
<indexterm><primary>result method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>result method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-result------------------------------------------------------><
]]>
</programlisting>

<para>Returns the result of the message <emphasis role="bold">send</emphasis> or
<emphasis role="bold">start</emphasis>.
If message processing is not yet complete, this method waits until it completes.
If the message <emphasis role="bold">send</emphasis> or
<emphasis role="bold">start</emphasis> raises an error condition, this method
also raises an error condition.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
/* Example using result method */
string="700"                 /* Create a new string object, string   */
bond=string~start("reverse") /* Create a message object, bond, and   */
                             /* start it.  This sends a REVERSE      */
                             /* message to string, giving bond       */
                             /* the result.                          */

/* Ask bond for the result of the message */
say "The result of message was" bond~result     /* Result is 007     */
</programlisting>
</section>

<section id="mthMessageSend"><title>send</title>
<indexterm><primary>send method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>send method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-send--+----------+------------------------------------------><
         +-(target)-+
]]>
</programlisting>

<para>Returns the result (if any) of sending the message. If you specify
<emphasis role="italic">target</emphasis>, this method sends the message to
<emphasis role="italic">target</emphasis>. Otherwise,
this method sends the message to the <emphasis role="italic">target</emphasis>
you specified when the message object was created.
<emphasis role="bold">send</emphasis> does
not return until message processing is complete.</para>
<para>You can use the <emphasis role="bold">notify</emphasis>
method to request notification that message
processing is complete. You can use the
<emphasis role="bold">result</emphasis> method to obtain any result
from the message.</para>
</section>

<section id="mthMessageStart"><title>start</title>
<indexterm><primary>start method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>start method</secondary>
<tertiary>of Message class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-start--+----------+-----------------------------------------><
          +-(target)-+
]]>
</programlisting>


<para>Sends the message to start processing at a specific target whereas
the sender continues processing. If you specify
<emphasis role="italic">target</emphasis>, this method
sends the message to <emphasis role="italic">target</emphasis>. Otherwise, this
method sends the message to the <emphasis role="italic">target</emphasis>
that you specified when the message object was created.
This method returns as soon as possible and does not wait until
message processing is complete. When message processing is complete, the
message object retains any result and holds it until the sender requests it
by sending a <emphasis role="bold">result</emphasis>
message. You can use the <emphasis role="bold">notify</emphasis> method to request
notification that message processing is complete.</para>
</section>

<section id="exam"><title>Example</title>
<indexterm><primary>examples</primary>
<secondary>start method</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>of Message class</secondary></indexterm>
<programlisting>
/* Using Message class methods */
/* Note: In the following example, ::METHOD directives define class Testclass */
                                                 /* with method SHOWMSG       */

ez=.testclass~new                  /* Creates a new instance of Testclass     */
mymsg=ez~start("SHOWMSG","Hello, Ollie!",5)      /* Creates and starts        */
                                                 /* message mymsg to send     */
                                                 /* SHOWMSG to ez             */

/* Continue with main processing while SHOWMSG runs concurrently              */
do 5
  say "Hello, Stan!"
end

/* Get final result of the SHOWMSG method from the mymsg message object       */
say mymsg~result
say "Goodbye, Stan..."
exit

::class testclass public             /* Directive defines Testclass           */

::method showmsg                     /* Directive creates new method SHOWMSG  */
use arg text,reps                    /* class Testclass                       */
do reps
  say text
end
reply "Bye Bye, Ollie..."
return
</programlisting>
<para>The following output is possible: </para>
<programlisting>
Hello, Ollie!
Hello, Stan!
Hello, Ollie!
Hello, Stan!
Hello, Ollie!
Hello, Stan!
Hello, Ollie!
Hello, Stan!
Hello, Ollie!
Hello, Stan!
Bye Bye, Ollie...
Goodbye, Stan...
</programlisting>
</section>

<section id="mthMessageTarget"><title>target</title>
<indexterm><primary>target method</primary>
<secondary>of Message class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>target method</secondary>
<tertiary>of Message class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-target---------------------------------------------------><
]]>
</programlisting>

<para>Returns the object that is the target of the invoked method.</para>
</section>
</section>

</section>

