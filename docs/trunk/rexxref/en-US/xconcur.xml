<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "rexxref.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: Reference XML File
    #
    # Copyright (c) 2005-2017, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<chapter id="xconcur"><title>Concurrency</title>
<indexterm><primary>concurrency</primary>
<secondary>object based</secondary></indexterm>
<indexterm><primary>object-based concurrency</primary></indexterm>
<para>Conceptually, each Rexx object is like
a small computer with its own processor to run its methods, its memory for
object and method variables, and its communication links to other objects
for sending and receiving messages. This is object-based
concurrency. It lets more than one method run at the same time. Any number
of objects can be active (running) at the same time, exchanging messages to
communicate with, and synchronize, each other.</para>

<section id="earlyrep"><title>Early Reply</title>
<indexterm><primary>early reply</primary></indexterm>
<indexterm><primary>concurrency</primary>
<secondary>early reply</secondary></indexterm>
<para>Early
reply provides concurrent processing. A running method returns control, and
possibly a result, to the point from which it was called; meanwhile it continues
running. The following figure illustrates this concept.</para>

<figure id="earlyr"><title>Early Reply</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/EarlyReply.png" scale="60" />
</imageobject>
</mediaobject>
</figure>

<para>Method A includes a call to Method B. Method B contains a REPLY instruction.
This returns control and a result to method A, which continues processing
with the line after the call to Method B. Meanwhile, Method B also continues
running.</para>
<para>The chains of execution represented by method A and method B
are called activities.
<indexterm><primary>activity</primary></indexterm>
<indexterm><primary>thread</primary></indexterm>
An activity is a thread of execution that can run methods
concurrently with methods on other activities.</para>
<para>An activity contains a stack of invocations that
represent the Rexx programs running on the activity.  An invocation can be
a main program invocation, an internal function or subroutine call, an external
function or subroutine call, an INTERPRET instruction, or a message invocation.
An invocation is activated when an executable unit is invoked and removed
(popped) when execution completes. In
<xref linkend="earlyr" />, the programs
begins with a single activity.  The activity contains a single invocation,
method A. When method A invokes method B, a second invocation is added to
the activity.</para>
<para>When method B issues a REPLY, a new activity is created (activity 2). Method
B's invocation is removed from activity 1, and pushed on to activity 2.
Because activities can execute concurrently, both method A and method B continue
processing. The following figures illustrate this concept.</para>

<figure><title>Before REPLY</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/BeforeReply.png" scale="70" />
</imageobject>
</mediaobject>
</figure>

<figure><title>After REPLY</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/AfterReply.png" scale="70" />
</imageobject>
</mediaobject>
</figure>
<para>Here is an example of using early reply to run methods concurrently.</para>
<example>
<title>REPLY instruction</title>
<programlisting>
/* Example of early reply */

object1 = .example~new
object2 = .example~new

say object1~repeat(10, "Object 1 running")
say object2~repeat(10, "Object 2 running")
say "Main ended."
exit

::class example
::method repeat
use arg reps,msg
reply "Repeating" msg"," reps "times."
do reps
  say msg
end
</programlisting>
</example>
</section>

<section id="mesobj"><title>Message Objects</title>
<indexterm><primary>concurrency</primary>
<secondary>message objects</secondary></indexterm>
<para>A <xref linkend="clsMessage" xrefstyle="template:Message"/> object
is an intermediary between two objects that enables
concurrent processing. All objects inherit the
<xref linkend="mthObjectStart" xrefstyle="select:title"/> method
from the <classname>Object</classname> class.
To obtain a message object, an object sends a <methodname>start</methodname>
message to the object to which the message object will convey a message. The
message is an argument to the <methodname>start</methodname> message as in the following example:
<programlisting>
a=p~start("REVERSE")
</programlisting>
</para>
<para>This line of code creates a message object,
<computeroutput>A</computeroutput>, and sends it
a start message. The message object then sends the REVERSE message to object
<computeroutput>P</computeroutput>. Object <computeroutput>P</computeroutput>
receives the message, performs any needed processing,
and returns a result to message object <computeroutput>A</computeroutput>.
Meanwhile the object that obtained message object
<computeroutput>A</computeroutput> continues its processing. When message object
<computeroutput>A</computeroutput> returns, it does
not interrupt the object that obtained it. It waits until this object requests
the information. Here is an example of using a message object to run methods
concurrently. </para>
<example>
<title>Message object usage</title>
<programlisting>
/* Example of using a message object */

object1 = .example~new
object2 = .example~new

a = object1~start("REPEAT",10,"Object 1 running")
b = object2~start("REPEAT",10,"Object 2 running")

say a~result
say b~result
say "Main ended."
exit

::class example
::method repeat
use arg reps,msg
do reps
  say msg
end
return "Repeated" msg"," reps "times."
</programlisting>
</example>
</section>

<section id="defco"><title>Default Concurrency</title>
<indexterm><primary>concurrency</primary>
<secondary>default</secondary></indexterm>
<indexterm><primary>default</primary>
<secondary>concurrency</secondary></indexterm>
<para>The instance methods of
a class use the EXPOSE instruction to define a set of object variables. This
collection of variables belonging to an object is called its object variable
pool. The methods a class defines and the variables these methods can access
is called a scope. Rexx's default concurrency exploits the idea of scope.
<indexterm><primary>object variable pool</primary></indexterm>
The object variable pool is a set of object subpools, each representing the
set of variables at each scope of the inheritance chain of the class from
which the object was created. Only methods at the same scope can access object
variables at any particular scope. This prevents any name conflicts between
classes and subclasses, because the object variables for each class are in
different scopes.</para>
<para>If you do not change the defaults, only one method of a given scope can
run on a single object at a time. Once a method is running on an object, the
language processor blocks other methods on other activities from running in
the same object at the same scope until the method that is running completes.
Thus, if different activities send several messages within a single scope
to an object the methods run sequentially.</para>
<para>The next example shows how the default concurrency works. </para>
<example>
<title>Default concurrency for methods</title>
<programlisting>
/* Example of default concurrency for methods of different scopes */

object1 = .subexample~new

say object1~repeat(8, "Object 1 running call 1")   /* These calls run */
say object1~repeater(8, "Object 1 running call 2") /*   concurrently  */
say "Main ended."
exit

::class example
::method repeat
use arg reps,msg
reply "Repeating" msg"," reps "times."
do reps
  say msg
end

::class subexample subclass example
::method repeater
use arg reps,msg
reply "Repeating" msg"," reps "times."
do reps
  say msg
end
</programlisting>
</example>
<para>The preceding example produces output such as the following: </para>
<programlisting>
Repeating Object 1 running call 1, 8 times.
Object 1 running call 1
Repeating Object 1 running call 2, 8 times.
Object 1 running call 1
Object 1 running call 2
Main ended.

Object 1 running call 1
Object 1 running call 2
Object 1 running call 1
Object 1 running call 2
Object 1 running call 1
Object 1 running call 2
Object 1 running call 1
Object 1 running call 2
Object 1 running call 1
Object 1 running call 2
Object 1 running call 1
Object 1 running call 2
Object 1 running call 2
</programlisting>
<para>The following example shows that methods of the same scope do not run
concurrently by default.</para>
<example>
<title>Default concurrency for methods</title>
<programlisting>
/* Example of methods with the same scope not running concurrently*/

object1 = .example~new

say object1~repeat(10,"Object 1 running call 1") /* These calls   */
say object1~repeat(10,"Object 1 running call 2") /* cannot run    */
say "Main ended."                                /* concurrently. */
exit

::class example
::method repeat
use arg reps,msg
reply "Repeating" msg"," reps "times."
do reps
  say msg
end
</programlisting>
</example>
<para>The REPEAT method includes a REPLY instruction, but the methods for the
two REPEAT messages in the example cannot run concurrently. This is because
REPEAT is called twice at the same scope and requires exclusive access to
the object variable pool. The REPLY instruction causes the first REPEAT message
to transfer its exclusive access to the object variable pool to a new activity
and continue execution. The second REPLY message also requires exclusive access
and waits until the first method completes.</para>
<para>If the original activity has more than one method active (nested method
calls) with exclusive variable access, the first REPLY instruction is unable
to transfer its exclusive access to the new activity and must wait until the
exclusive access is again available. This may allow another method on the
same object to run while the first method waits for exclusive access.</para>

<section id="sendmess"><title>Sending Messages within an Activity</title>
<para>Whenever a message is invoked on an object, the activity acquires exclusive
access (a lock) for the object's scope. Other activities that send messages
to the same object that required the locked scope waits until the first activity
releases the lock.</para>
<para>Suppose object A is running method Y, which includes: </para>
<programlisting>
self~z
</programlisting>
<para>Sequential processing does not allow method Z to begin until method Y has
completed. However, method Y cannot complete until method Z runs. A similar
situation occurs when a subclass's overriding method does some processing
and passes a message to its superclasses' overriding method. Both cases
require a special provision: If an invocation running on an activity sends
another message to the same object, this method is allowed to run because
the activity has already acquired the lock for the scope. This allows nested,
nonconcurrent method invocations on a single activity without causing a deadlock
situation. The language processor regards these additional messages as subroutine
calls.</para>
<para>Here is an example showing the special treatment of single activity messages.
The REPEATER and REPEAT methods have the same scope. REPEAT runs on the same
object at the same time as the REPEATER method because a message to SELF runs
the REPEAT method. The language processor treats this as a subroutine call
rather than as concurrently running two methods. </para>
<example>
<title>Sending a message to SELF</title>
<programlisting>
/* Example of sending message to SELF */

object1 = .example~new
object2 = .example~new

say object1~repeater(10, "Object 1 running")
say object2~repeater(10, "Object 2 running")

say "Main ended."
exit

::class example
::method repeater
use arg reps,msg
reply "Entered repeater."
say self~repeat(reps,msg)
::method repeat
use arg reps,msg
do reps
  say msg
end
return "Repeated" msg"," reps "times."
</programlisting>
</example>
<para>The activity locking rules also allow indirect object recursion. The following
figure illustrates indirect object recursion.</para>

<figure><title>Indirect Object Recursion</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/IndirectRecursion.png" scale="70" />
</imageobject>
</mediaobject>
</figure>

<para>Method M in object A sends object B a message to run method N. Method N
sends a message to object A, asking it to run method O. Meanwhile, method
M is still running in object A and waiting for a result from method N.  A
deadlock would result. Because the methods are all running on the same activity,
no deadlock occurs.</para>
</section>
</section>

<section id="adc"><title>Using Additional Concurrency Mechanisms</title>
<para>Rexx has additional concurrency mechanisms that can add full concurrency
so that more than one method of a given scope can run in an object at a time:
</para>
<itemizedlist>
<listitem><para>The SETUNGUARDED method of the Method class and the UNGUARDED
option of the METHOD directive provide unconditional concurrency</para>
</listitem>
<listitem><para>GUARD OFF and GUARD ON control a method's exclusive access to
an object's scope</para></listitem></itemizedlist>

<section id="setmeth"><title>SETUNGUARDED Method and UNGUARDED Option</title>
<indexterm><primary>SETUNGUARDED method</primary></indexterm>
<indexterm><primary>UNGUARDED option of ::METHOD</primary></indexterm>
<para>The SETUNGUARDED method of the Method class and the UNGUARDED option of
the ::METHOD directive control locking of an object's scope when a method is
invoked. Both let a method run even if another method is active on the same
object.</para>
<para>Use the SETUNGUARDED method or UNGUARDED option only for methods that do
not need exclusive use of their object variable pool, that is, methods whose
execution can interleave with another method's execution without affecting
the object's integrity. Otherwise, concurrent methods can produce unexpected
results.</para>
<para>To use the SETUNGUARDED method for a method you have created with the NEW
method of the Method class, you specify: </para>
<programlisting>
<emphasis role="italic">methodname</emphasis>~SETUNGUARDED
</programlisting>
<para>(See <xref linkend="mthMethodSetUnguarded" /> for details about
SETUNGUARDED.)</para>
<para>Alternately,
you can define a method with the ::METHOD directive, specifying the UNGUARDED
option: </para>
<programlisting>
::METHOD <emphasis role="italic">methodname</emphasis> UNGUARDED
</programlisting>
</section>

<section id="guardonoff"><title>GUARD ON and GUARD OFF</title>
<indexterm><primary>concurrency</primary>
<secondary>alternating exclusive scope access</secondary></indexterm>
<indexterm><primary>concurrency</primary>
<secondary>SETUNGUARDED method</secondary></indexterm>
<indexterm><primary>concurrency</primary>
<secondary>GUARD instruction</secondary></indexterm>
<indexterm><primary>conditional concurrency</primary></indexterm>
<indexterm><primary>alternating exclusive scope access</primary></indexterm>
<indexterm><primary>instructions</primary>
<secondary>GUARD</secondary></indexterm>
<indexterm><primary>scope</primary>
<secondary>alternating exclusive access</secondary></indexterm>
<para>You might not be able to use the SETUNGUARDED method or UNGUARDED option
in all cases. A method might need exclusive use of its object variables, then
allow methods on other activities to run, and perhaps later need exclusive
use again. You can use GUARD ON and GUARD OFF to alternate between exclusive
use of an object's scope and allowing other activities to use the scope.</para>
<para>By default, a method must wait until a currently running method is finished
before it begins. GUARD OFF lets another method (running on a different activity)
that needs exclusive use of the same object variables become active on the
same object. See <xref linkend="keyGuard" /> for more information.</para>
</section>

<section id="guamet"><title>Guarded Methods</title>
<indexterm><primary>concurrency</primary>
<secondary>guarded methods</secondary></indexterm>
<indexterm><primary>guarded methods</primary></indexterm>
<para>Concurrency requires the activities of concurrently running methods to
be synchronized. Critical data must be safeguarded so diverse methods on other
activities do not perform concurrent updates. Guarded methods satisfy both
these needs.</para>
<para>A guarded method combines
<indexterm><primary>concurrency</primary>
<secondary>UNGUARDED option</secondary></indexterm>
the UNGUARDED option of the ::METHOD directive or the SETUNGUARDED method
of the Method class with the GUARD instruction.</para>
<indexterm><primary>concurrency</primary>
<secondary>conditional</secondary></indexterm>
<para>The UNGUARDED option and the SETUNGUARDED method both provide
unconditional concurrency. Including a GUARD instruction in a method makes
concurrency conditional:</para>
<programlisting>
GUARD ON WHEN <emphasis role="italic">expression</emphasis>
</programlisting>
<para>If the <emphasis role="italic">expression</emphasis> on the GUARD
instruction evaluates to &true;, the
method continues to run. If the <emphasis role="italic">expression</emphasis>
on the GUARD instruction evaluates to
&false;, the method does not
continue running. GUARD reevaluates the
<emphasis role="italic">expression</emphasis> whenever the value
of an exposed object variable changes. When the expression evaluates to
<computeroutput>1</computeroutput>, the method resumes running. You can use
GUARD to block running any method when proceeding is not safe.
(See <xref linkend="keyGuard" /> for details about GUARD.) </para>
<note><title>Note</title>
<para>It is important to ensure that you use an expression
that can be fulfilled. If the condition expression cannot be met, GUARD ON
WHEN puts the program in a continuous wait condition. This can occur in
particular when several activities run concurrently. In this case, a second
activity can make the condition expression invalid before GUARD ON WHEN can
use it.</para></note>
<para>To avoid this, ensure that the GUARD ON WHEN statement is executed before
the condition is set to true. Keep in mind that the sequence of running activities
is not determined by the calling sequence, so it is important to use a logic
that is independent of the activity sequence.</para>
</section>

<section id="addex"><title>Additional Examples</title>
<para>The following example uses REPLY in a method for a write-back cache.
</para>
<example>
<title>Method Write_Back</title>
<programlisting>
/* Method Write_Back                                 */
use arg data           /* Save data to be written    */
reply 0                /* Tell the sender all was OK */
self~disk_write(data)  /* Now write the data         */
</programlisting>
</example>
<para>The REPLY instruction returns control to the point at which method
Write_Back was called, returning the result
<computeroutput>0</computeroutput>. The caller of method Write_Back
continues processing from this point; meanwhile, method Write_Back also
continues processing.</para>
<para>The following example uses a message object. It reads a line asynchronously
into the variable <computeroutput>nextline</computeroutput>:</para>
<example>
<title>Message to INFILE</title>
<programlisting>
mymsg = infile~start("READLINE") /* Gets message object to carry    */
/* message to INFILE                                                */
/* do other work */
nextline=mymsg~result            /* Gets result from message object */
</programlisting>
</example>
<para>This creates a message object that waits for the read to finish while the
sender continues with other work. When the line is read, the
<computeroutput>mymsg</computeroutput>
message object obtains the result and holds it until the sender requests it.
</para>
<para>Semaphores and monitors (bounded buffers) synchronize concurrency processes.
Giving readers and writers concurrent access is a typical concurrency problem.
The following sections show how to use guarded methods to code semaphore and
monitor mechanisms and to provide concurrency for readers and writers.</para>

<section id="semaphores"><title>Semaphores</title>
<indexterm><primary>semaphore</primary></indexterm>
<para>A semaphore is a mechanism that controls
access to resources, for example, preventing simultaneous access.
Synchronization often uses semaphores. Here is an example of a semaphore class:
</para>

<example>
<title>Example of a Rexx Semaphore Class</title>
<programlisting>
/*******************************************************************************/
/*  A Rexx Semaphore Class.                                                    */
/*                                                                             */
/* This file implements a semaphore class in Rexx.  The class is defined to    */
/* the Global Rexx Environment.  The following methods are defined for         */
/* this class:                                                                 */
/*   init - Initializes a new semaphore.  Accepts the following positional     */
/*          parameters:                                                        */
/*                             &apos;name&apos; - global name for this semaphore         */
/*                                if named default to set name in              */
/*                                the class semDirectory                       */
/*                             noshare -  do not define named semaphore        */
/*                                in class semDirectory                        */
/*                             Initial state (0 or 1)                          */
/*   setInitialState - Allow for subclass to have some post-initialization,    */
/*     and do setup based on initial state of semaphore                        */
/*   Waiting  - Is the number of objects waiting on this semaphore.            */
/*   Shared   - Is this semaphore shared (Global).                             */
/*   Named    - Is this semaphore named.                                       */
/*   Name     - Is the name of a named semaphore.                              */
/*   setSem   - Sets the semaphore and returns previous state.                 */
/*   resetSem - Sets state to unSet.                                           */
/*   querySem - Returns current state of semaphore.                            */
/*                                                                             */
/* SemaphoreMeta - Is the metaclass for the semaphore classes.  This class is  */
/*   set up so that when a namedSemaphore is shared, it maintains these        */
/*   named/shared semaphores as part of its state.  These semaphores are       */
/*   maintained in a directory, and an UNKNOWN method is installed on the      */
/*   class to forward unknown messages to the directory.  In this way the      */
/*   class can function as a class and "like" a directory, so [] syntax can    */
/*   be used to retrieve a semaphore from the class.                           */
/*                                                                             */
/*                                                                             */
/* The following are in the subclass EventSemaphore.                           */
/*                                                                             */
/*   Post  - Posts this semaphore.                                             */
/*   Query - Queries the number of posts since the last reset.                 */
/*   Reset - Resets the semaphore.                                             */
/*   Wait  - Waits on this semaphore.                                          */
/*                                                                             */
/*                                                                             */
/* The following are in the subclass MutexSemaphore                            */
/*                                                                             */
/*   requestMutex - Gets exclusive use of semaphore.                           */
/*   releaseMutex - Releases to allow someone else to use semaphore.           */
/*        NOTE: Currently anyone can issue a release (need not be the owner).  */
/*******************************************************************************/
/* ============================================================================ */
/* ===         Start of Semaphore class.                                  ===== */
/* ============================================================================ */
::class SemaphoreMeta subclass class
::method init
  expose semDict
                                            /* Be sure to initialize parent     */
  .message~new(self, .array~of("INIT", super), "a", arg(1,"a"))~send
  semDict = .directory~new

::method unknown
  expose semDict
  use arg msgName, args
                                            /* Forward all unknown messages     */
                                            /* to the semaphore dictionary      */
  .message~new(semDict, msgName, "a", args)~send
  if var("RESULT") then
    return result
  else
    return


::class Semaphore subclass object metaclass SemaphoreMeta

::method init
  expose sem waits shared name
  use arg semname, shr, state

  waits = 0                                 /* No one waiting                   */
  name = ""                                 /* Assume unnamed                   */
  shared = 0                                /* Assume not shared                */
  sem = 0                                   /* Default to not posted            */

  if state = 1 Then                         /* Should initial state be set?     */
    sem = 1
                                            /* Was a name specified?            */
  if VAR("SEMNAME") &amp; semname \= "" Then Do
    name = semname                          /* Yes, so set the name             */


    if shr \= "NOSHARE" Then Do             /* Do we want to share this sem?    */
      shared = 1                            /* Yes, mark it shared              */
                                            /* Shared add to semDict            */
      self~class[name] = self
    End

  End
  self~setInitialState(sem)                 /* Initialize initial state         */

::method setInitialState
                                            /* This method intended to be       */
nop                                         /* overridden by subclasses         */
::method setSem
expose sem
oldState = sem
sem = 1                                     /* Set new state to 1               */
return oldState

::method resetSem
expose sem
sem = 0
return 0

::method querySem
expose sem
return sem


::method shared
expose shared
return shared                               /* Return .true or .false           */

::method named
expose name
                                            /* Does semaphore have a name?      */
if name = "" Then return 0                  /* No, not named                    */
Else return 1                               /* Yes, it is named                 */

::method name
expose name
return name                                 /* Return name or ""                */

::method incWaits
expose waits
waits = waits + 1                           /* One more object waiting          */

::method decWaits
expose Waits
waits = waits - 1                           /* One object less waiting          */

::method Waiting
expose Waits
return waits                                /* Return number of objects waiting */
/* ========================================================================== */
/* ===         Start of EventSemaphore class.                             === */
/* ========================================================================== */

::class EventSemaphore subclass Semaphore public
::method setInitialState
  expose posted posts
  use arg posted

  if posted  then posts = 1
  else posts = 0
::method post
  expose posts posted

  self~setSem                        /* Set semaphore state            */
  posted = 1                         /* Mark as posted                 */
  reply
  posts = posts + 1                  /* Increase the number of posts   */

::method wait
  expose posted

  self~incWaits                      /* Increment number waiting       */
  guard off
  guard on when posted               /* Now wait until posted          */
  reply                              /* Return to caller               */
  self~decWaits                      /* Cleanup, 1 less waiting        */

::method reset
  expose posts posted

  posted = self~resetSem             /* Reset semaphore                */
  reply                              /* Do an early reply              */
  posts = 0                          /* Reset number of posts          */

::method query
  expose posts
                                     /* Return number of times         */
  return posts                       /* Semaphore has been posted      */
/* ========================================================================== */
/* ===         Start of MutexSemaphore class.                             === */
/* ========================================================================== */

::class MutexSemaphore subclass Semaphore public

::method setInitialState
  expose owned
  use arg owned


::method requestMutex
  expose Owned

  Do forever                                /* Do until we get the semaphore  */
    owned = self~setSem
    if Owned = 0                            /* Was semaphore already set?     */
      Then leave                            /* Wasn&apos;t owned; we now have it   */
    else Do
      self~incWaits
      guard off                             /* Turn off guard status to let   */
                                            /* others come in                 */
      guard on when \Owned                  /* Wait until not owned and get   */
                                            /* guard                          */
      self~decWaits                         /* One less waiting for MUTEX     */
    End
                                            /* Go up and see if we can get it */
  End


::method releaseMutex
  expose owned
  owned = self~resetSem                     /* Reset semaphore                */
</programlisting>
</example>
<note><title>Note</title>
<para>ooRexx 5.0 introduced two semaphore classes, see <xref linkend="clsEventSemaphore" />
and  <xref linkend="clsMutexSemaphore" />.
</para>
<para>There are also functions available that use system semaphores.
See <xref linkend="utlSyscreateeventsem" />, and
<xref linkend="utlSyscreatemutexsem" />.
</para>
</note>

</section>

<section id="monbuff"><title>Monitors (Bounded Buffer)</title>
<indexterm><primary>bounded buffer</primary></indexterm>
<indexterm><primary>monitor</primary></indexterm>
<para>A monitor object consists of a number of client methods, WAIT
and SIGNAL methods for client methods to use, and one or more condition variables.
Guarded methods provide the functionality of monitors. Do not confuse this
with the Monitor class (see <xref linkend="clsMonitor" />).
</para>
<example>
<title>Example of a Rexx Monitor Class</title>
<programlisting>
::method init
/* Initialize the bounded buffer */
expose size in out n
use arg size
in = 1
out = 1
n = 0

::method append unguarded
/* Add to the bounded buffer if not full */
expose n size b. in
guard on when n &lt; size
use arg b.in
in = in//size+1
n = n+1

::method take
/* Remove from the bounded buffer if not empty */
expose n b. out size
guard on when n > 0
reply b.out
out = out//size+1
n = n-1
</programlisting>
</example>
</section>

<section id="readwrit"><title>Readers and Writers</title>
<para>The concurrency
problem of the readers and writers requires that writers exclude writers and
readers, whereas readers exclude only writers. The UNGUARDED option is required
to allow several concurrent readers. </para>
<example>
<title>Example of a Rexx Readers and Writers</title>
<programlisting>
::method init
expose readers writers
readers = 0
writers = 0

::method read unguarded
/* Read if no one is writing */
expose writers readers
guard on when writers = 0
readers = readers + 1
guard off

/* Read the data */
say "Reading (writers:" writers", readers:" readers")."
guard on
readers = readers - 1

::method write unguarded
/* Write if no-one is writing or reading */
expose writers readers
guard on when writers + readers = 0
writers = writers + 1

/* Write the data */
say "Writing (writers:" writers", readers:" readers")."
writers = writers - 1
</programlisting>
</example>
</section>
</section>
</section>
</chapter>
