<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "rexxref.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: Reference XML File
    #
    # Copyright (c) 2005-2014, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<chapter id="funct"><title>Functions</title>
<indexterm><primary>functions</primary></indexterm>
<indexterm><primary>functions</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>definition</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>call, definition</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>calling</secondary></indexterm>
<para>A function is an
internal, built-in, or external routine that returns a single result object.
(A subroutine is a function that is an internal, built-in,
or external routine that might return a result and is called with the CALL
instruction.)
<indexterm><primary>subroutines</primary>
<secondary>definition</secondary></indexterm>
</para>

<section id="syntx"><title>Syntax</title>
<para>A function call is a term in an expression calling a routine that carries
out some procedures and returns an object. This object replaces the function
call in the continuing evaluation of the expression. You can include function
calls to internal and external routines in an expression anywhere that a data
term (such as a string) would be valid, using the following notation:</para>
<para></para>
<mediaobject>
<imageobject>
<imagedata fileref="images/bif/funct_xmp.svg" scale="50" />
</imageobject>
</mediaobject>

<indexterm><primary>names</primary>
<secondary>of functions</secondary></indexterm>
<para>The <emphasis role="italic">function_name</emphasis> is a literal string
or a single symbol, which is taken to be a constant.</para>
<para>There can be any number of expressions, separated by commas,
<indexterm><primary>, (comma)</primary>
<secondary>separator of arguments</secondary></indexterm>
<indexterm><primary>, (comma)</primary>
<secondary>in function calls</secondary></indexterm>
<indexterm><primary>comma</primary>
<secondary>in function calls</secondary></indexterm>
<indexterm><primary>comma</primary>
<secondary>separator of arguments</secondary></indexterm>
between the
<indexterm><primary>parentheses</primary>
<secondary>in function calls</secondary></indexterm>
parentheses. These expressions are called the arguments to the function. Each
argument expression can include further function calls.</para>
<para>Note that the left parenthesis must be adjacent to the name of the function,
with no whitespace characters in between. (A blank operator would be assumed at
this point instead.) Only a comment can appear between the name and the left
parenthesis.
</para>
<para>The arguments
<indexterm><primary>arguments</primary>
<secondary>passing to functions</secondary></indexterm>
<indexterm><primary>arguments</primary>
<secondary>of functions</secondary></indexterm>
are evaluated in turn from left to right and the resulting
objects are then all passed to the function. This function then runs some
operation (usually dependent on the argument objects passed, though arguments
are not mandatory) and eventually returns a single object. This object is
then included in the original expression as though the entire function reference
had been replaced by the name of a variable whose value is the returned object.</para>
<para>For example, the function SUBSTR is built into the language processor and
could be used as: </para>
<programlisting>
N1="abcdefghijk"
Z1="Part of N1 is: "substr(N1,2,7)
/* Sets Z1 to "Part of N1 is: bcdefgh" */
</programlisting>
<para>A function can have a variable number of arguments. You need to specify only those
required. For example, <computeroutput>SUBSTR("ABCDEF",4)</computeroutput>
would return <computeroutput>DEF</computeroutput>.</para>
</section>

<section id="callsfu"><title>Functions and Subroutines</title>
<para>Functions and subroutines
are called in the same way. The only difference between functions and subroutines
is that functions must return data, whereas subroutines need not.</para>
<para>The following types of routines can be called as functions: </para>
<variablelist>
<varlistentry><term>Internal
<indexterm><primary>external functions</primary>
<secondary>functions</secondary>
<tertiary>description</tertiary></indexterm>
<indexterm><primary>functions</primary>
<secondary>internal</secondary></indexterm>
</term>
<listitem><para>If the routine name exists as a label in the program,
the current processing status is saved for a later return to the point of
invocation to resume execution.
Control is then passed to the first label in the program that matches the
name. As with a routine called by the CALL instruction, status information,
such as TRACE and NUMERIC settings, is saved too. See the CALL instruction
(<xref linkend="keyCall" />) for details. </para>
<para>If you call an internal routine as a
function, you must specify an expression in any RETURN
instruction so that the routine can return.  This is not necessary if it is
called as a subroutine.</para>
<example>
<title>Recursive internal function execution</title>
<programlisting>
arg x
say x"! =" factorial(x)
exit
factorial: procedure   /* Calculate factorial by    */
  arg n                /*   recursive invocation.   */
  if n=0 then return 1
  return  factorial(n-1) * n
</programlisting>
</example>
<para>FACTORIAL is unusual in that it calls
<indexterm><primary>recursive call</primary></indexterm>
itself (this is recursive invocation).  The PROCEDURE instruction ensures
that a new variable <computeroutput>n</computeroutput> is created for each
invocation.</para>
</listitem></varlistentry>
<varlistentry><term>Built-in</term>
<listitem><para>These functions are always available and are defined in
<xref linkend="xbuiltin" />.
</para></listitem></varlistentry>
<varlistentry><term>External
<indexterm><primary>external functions</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>external subroutines</primary></indexterm>
<indexterm><primary>functions</primary>
<secondary>external</secondary></indexterm>
</term>
<listitem><para>You can write or use functions that are external to your program and
to the language processor. An external routine can be written in any language,
including Rexx, that supports the system-dependent interfaces the language
processor uses to call it. You can call a Rexx program as a function and,
in this case, pass more than one argument string. The ARG, PARSE ARG, or USE
ARG instruction or the ARG built-in function can retrieve these argument strings.
When called as a function, a program must return data to the caller.
<indexterm><primary>arguments</primary>
<secondary>passing to functions</secondary></indexterm>
</para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>Calling an external Rexx program as a function is similar to calling an
internal routine. For an external routine, however, the caller's variables
are hidden. To leave the called Rexx program, you can use either EXIT or RETURN.
In either case, you must specify an expression.</para></listitem>
<listitem><para>You can use the INTERPRET instruction to process a function with a variable
function name. However, avoid this if possible because it reduces the clarity
of the program.</para></listitem>
</orderedlist>
</listitem></varlistentry>
</variablelist>

<section id="xsearcho"><title>Search Order</title>
<indexterm><primary>external functions</primary>
<secondary>search order</secondary></indexterm>
<indexterm><primary>search order</primary>
<secondary>for functions</secondary></indexterm>
<indexterm><primary>search order</primary>
<secondary>external functions</secondary></indexterm>
<para>Functions are
searched in the following sequence:  internal routines, built-in functions,
external functions.</para>
<indexterm><primary>functions</primary>
<secondary>forcing built-in or external reference</secondary></indexterm>
<para>Function calls or subroutines may use a name that is specified as a symbol or a literal
string.  For example, these calls are equivalent:</para>
<programlisting>
    call MyProcedure
    call 'MYPROCEDURE'
</programlisting>
<para>Note that the name value when specified as a symbol is the symbol name translated
to upper case.  Both of the calls above will search for a routine named "MYPROCEDURE".  When
the name is specified as a literal string, then the literal string value is used as-is.  Thus
the following two calls are not equivalent:</para>
<programlisting>
    call MyProcedure    -- calls "MYPROCEDURE"
    call 'MyProcedure'  -- calls "MyProcedure"
</programlisting>
<para>Some steps of the function and subroutine search order are case sensitive, so
some care may need to be exercised that the correct name form is used:</para>
<itemizedlist>
<listitem>
<para>Internal routines.  Normally, labels are specified as a symbol followed by a ":".
These labels have a name value that's all uppercase.  Since unquoted (symbol) names also have
uppercase values, these will match easily.  It is also possible to use literal strings for
label names.  If these labels contain lowercase characters, they will not be located using
normal call mechanisms</para>
</listitem>
<listitem>
<para>Built-in functions.  The built-in function names are all uppercase, so using a mixed-case
literal string built-in function name will fail to locate the function.</para>
<programlisting>
    x = wordPos(needle, haystack)     -- calls "WORDPOS", which works
    x = "wordPos"(needle, haystack)   -- calls "wordPos", which will fail
</programlisting>
</listitem>
<listitem>
<para>External routines.  Some steps of the external function search order may be case sensitive,
depending on the system.  This may occasionally require a function or subroutine name to be
specified as a mixed case literal string to be located.</para>
</listitem>
</itemizedlist>
<para>
If the call or function invocation uses a literal string, then the search for internal
label is bypassed.
This bypass mechanism allows you
to extend the capabilities of an existing internal function, for example,
and call it as a built-in function or external routine under the same name
as the existing internal function.  To call the target built-in or external routine
from inside your internal routine, you must use a literal string for the function name.
</para>
<example>
<title>DATE function - overriding</title>
<programlisting>
/* This internal DATE function modifies the          */
/* default for the DATE function to standard date.   */
date: procedure
  arg in
  if in="" then in="Standard"
  -- This calls the DATE built-in function rather than recursively
  -- calling the DATE: internal routine.  Note that the name needs to
  -- be all uppercase because built-in functions have uppercase names.
  return "DATE"(in)
</programlisting>
</example>
<para>Since built-in functions have uppercase names the literal
string must also be in uppercase for the search to succeed.
</para>
<para>External functions and subroutines have a system-defined search order.</para>
<para>The search order for external functions is as follows: </para>
<orderedlist>
<listitem><para>Functions defined on ::ROUTINE directives within the program.
</para></listitem>
<listitem><para>Public functions defined on ::ROUTINE directives of programs referenced
with ::REQUIRES.</para></listitem>
<listitem><para>Functions that have been loaded into the macrospace for preorder execution.
(See the <citetitle pubwork="book">Open Object Rexx: Programming Guide</citetitle>
for details.)</para></listitem>
<listitem><para>Functions that are part of a function package or library package. (See the
<citetitle pubwork="book">Open Object Rexx: Programming Guide</citetitle>
for details.)</para></listitem>
<listitem><para>Rexx functions located in an external file.  See below for
how these external files are located.
</para></listitem>
<listitem><para>Functions that have been loaded into the macrospace for
postorder execution.</para></listitem>
</orderedlist>

<section id="filesearch"><title>Locating External Rexx Files</title>
<para>Rexx uses an extensive search procedure for locating program files.  The first
element of the search procedure is the locations that will be checked for files.  The
locations, in order of checking, are:</para>
<orderedlist>
<listitem><para>
The same directory the program invoking the external routine is located.  If this is
an initial program execution or the calling program was loaded from the macrospace, this
location is skipped.  Checking in this directory allows related program files to be called
without requiring the directory be added to the search path.
</para></listitem>
<listitem><para>
The current filesystem directory.
</para></listitem>
<listitem><para>
Some applications using Rexx as a scripting language may define an extension
path used to locate called programs.  If the Rexx program was invoked directly
from the system command line, then no extension path is defined.
</para></listitem>
<listitem><para>
Any directories specified via the REXX_PATH environment variable.
</para></listitem>
<listitem><para>
Any directories specified via the PATH environment variable.
</para></listitem>
</orderedlist>
<para>The second element of the search process is the file extension.  If the
routine name contains at least one period, then this routine is extension
qualified.  The search locations above will be checked for the target file unchanged, and
no additional steps will be taken.  If the routine name is not extension qualified, then
additional searches will be performed by adding file extensions to the name.  The following
extensions may be used:</para>
<orderedlist>
<listitem><para>
If the calling program has a file extension, then the interpreter will attempt to locate
a file using the same extension as the caller.  All directory locations will be checked for
a given extension before moving to the next potential extension.
</para></listitem>
<listitem><para>
Some applications using Rexx as a scripting language may define additional extension types.
For example, an editor might define a preferred extension that should be
used for editor macros.  This extension would be searched next.
</para></listitem>
<listitem><para>
The default system extension (.REX).
</para></listitem>
<listitem><para>
If the target file has not been located using any of the above extensions, the file name
is tried without an added extension.
</para></listitem>
</orderedlist>
<para>There are some system file system considerations involved when search for files.
The Windows file system is case insensitive, so files can be located regardless of how
the call is specified.  Unix-based systems have a case sensitive file system, so files must
be exact case matches in order to be located.  For these systems, each time a file name
probe is attempted, the name will be tried in the case specified and also as a lower case
name.  The check is not performed on the very last step that uses the file name without an extension to
avoid unintentional conflicts with other executable files.
</para>
<para>Note that for function or subroutine calls using an unquoted name, the target name is the
string value of the name symbol, which will be an uppercase value.  Thus calls to myfunc(), MyFunc(),
and myFUNC() all trigger a search for a function named "MYFUNC".  Calls specified as a quoted string
will maintain the original string case.  Thus 'myfunc'() and 'MyFunc'() would search for different names.
</para>


<figure id="os2exf"><title>Function and Routine Resolution and Execution</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/externalFunction.png" scale="70" />
</imageobject>
</mediaobject>
</figure>

<figure id="os2exfile"><title>Function and Routine External File Resolution</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/externalFileSearch.png" scale="70" />
</imageobject>
</mediaobject>
</figure>
</section>
</section>

<section id="errors"><title>Errors during Execution</title>
<indexterm><primary>error</primary>
<secondary>during execution of functions</secondary></indexterm>
<para>If an external or built-in function detects an error, the language processor
is informed, and a syntax error results.
Syntax errors can be trapped in the caller using SIGNAL ON SYNTAX and recovery
might be possible.  If the error is not trapped, the program is ended.
</para>
</section>
</section>

<section id="rtrnval"><title>Return Values</title>
<para>A function usually returns a value that is substituted for the function
call when the expression is evaluated.</para>
<para>How the value returned by a function (or any Rexx routine) is handled depends
on whether it is called by a function call or as a subroutine with the CALL
instruction. </para>
<itemizedlist>
<listitem><para>A routine called as a subroutine: If the routine returns a value, that
value is stored in the special variable named RESULT. Otherwise, the RESULT
<indexterm><primary>special</primary>
<secondary>variable</secondary>
<tertiary>RESULT</tertiary></indexterm>
<indexterm><primary>special</primary>
<secondary>variables</secondary>
<tertiary>RESULT</tertiary></indexterm>
<indexterm><primary>RESULT special variable</primary>
<secondary>return value from a routine</secondary></indexterm>
variable is dropped, and its value is the string
<computeroutput>RESULT</computeroutput>.</para></listitem>
<listitem><para>A routine called as a function: If the function returns a value, that
value is substituted in the expression at the position where the function
was called. Otherwise, the language processor stops with an error message.
</para></listitem>
</itemizedlist>
<para>Here are some examples of how to call a Rexx procedure: </para>
<example>
<title>How to call Rexx procedures</title>
<programlisting>
call Beep 500, 100         /* Example 1: a subroutine call */
</programlisting>
<para>The built-in function BEEP is called as a Rexx subroutine.  The return
value from BEEP is placed in the Rexx special variable
<computeroutput>RESULT</computeroutput>.</para>
<programlisting>
bc = Beep(500, 100)        /* Example 2: a function call   */
</programlisting>
<para>BEEP is called as a Rexx function.  The return value from the function
is substituted for the function call.  The clause itself is an assignment
instruction; the return value from the BEEP function is placed in the variable
<computeroutput>bc</computeroutput>.</para>
<programlisting>
Beep(500, 100)             /* Example 3: result passed as  */
                           /*            a command         */
</programlisting>
<para>The BEEP function is processed and its return value is substituted in
the expression for the function call, like in the preceding example.  In this
case, however, the clause as a whole evaluates to a single expression. Therefore,
the evaluated expression is passed to the current default environment as a
command. </para>
</example>

<note><title>Note</title>
<para>Many other languages, such as C, throw away the return
value of a function if it is not assigned to a variable. In Rexx, however,
a value returned like in the third example is passed on to the current environment
or subcommand handler. If that environment is the default, the operating system
performs a disk search for what seems to be a command.</para></note>
</section>

<section id="xbuiltin"><title>Built-in Functions</title>
<indexterm><primary>functions</primary>
<secondary>built-in</secondary></indexterm>
<para>Rexx provides a set of built-in
functions, including character manipulation, conversion,
<indexterm><primary>conversion</primary>
<secondary>conversion functions</secondary></indexterm>
and information functions.
The following are general notes on the built-in functions: </para>
<itemizedlist>
<listitem><para>The parentheses in a function are always needed, even if no arguments
are required. The first parenthesis must follow the name of the function with
no whitespace in between.</para></listitem>
<listitem><para>The built-in functions internally work with NUMERIC DIGITS 9 for
32-bit systems or NUMERIC DIGITS 18 for 64-bit systems, and NUMERIC
FUZZ 0 and are unaffected by changes to the NUMERIC settings, except where
stated. Any argument named as a <emphasis role="italic">number</emphasis>
is rounded, if necessary, according to the current setting of NUMERIC DIGITS
(as though the number had been added to 0) and checked for validity before use.
This occurs in the following functions: ABS, FORMAT, MAX, MIN, SIGN, and TRUNC,
and for certain options of DATATYPE.</para></listitem>
<listitem><para>Any argument named as a
<emphasis role="italic">string</emphasis> can be a null string.</para></listitem>
<listitem><para>If an argument specifies a
<emphasis role="italic">length</emphasis>, it must be a positive whole
number or zero. If it specifies a
<emphasis role="italic">start</emphasis> character or word in a string,
it must be a positive whole number, unless otherwise stated.</para></listitem>
<listitem><para>If the last argument is optional, you can always include a comma to indicate
that you have omitted it. For example,
<computeroutput>DATATYPE(1,)</computeroutput>, like
<computeroutput>DATATYPE(1)</computeroutput>, would return
<computeroutput>NUM</computeroutput>. You can include any number
of trailing commas; they are ignored. If there are actual parameters, the
default values apply.</para></listitem>
<listitem><para>If you specify a <emphasis role="italic">pad</emphasis>
<indexterm><primary>pad character, definition</primary></indexterm>
character, it must be exactly one character long. A pad character
extends a string, usually on the right. For an example, see the LEFT built-in
function LEFT (<xref linkend="bifLeft" />).</para></listitem>
<listitem><para>If a function has an
<emphasis role="italic">option</emphasis> that you can select by specifying
the first character of a string, that character can be in uppercase or
lowercase.</para></listitem>
<listitem><para>Many of the built-in functions invoke methods of the
String (<xref linkend="clsString" /> class.
For the functions ABBREV, ABS, BITAND, BITOR, BITXOR,
B2X, CENTER, CENTRE, CHANGESTR, COMPARE, COPIES, COUNTSTR, C2D, C2X, DATATYPE,
DELSTR, DELWORD, D2C, D2X, FORMAT, LEFT, LENGTH, LOWER, MAX, MIN, REVERSE, RIGHT,
SIGN, SPACE, STRIP, SUBSTR, SUBWORD, TRANSLATE, TRUNC, UPPER, VERIFY, WORD, WORDINDEX,
WORDLENGTH, WORDS, X2B, X2C, and X2D, the first argument to the built-in function
is used as the receiver object for the message sent, and the remaining arguments
are used in the same order as the message arguments. For example,
SUBSTR("abcde",3,2) is equivalent to "abcde"~SUBSTR(3,2).</para>
<para>For the functions INSERT, LASTPOS, OVERLAY, POS, and WORDPOS, the
second argument to the built-in functions is used as the receiver object for
the message sent, and the other arguments are used in the same order as the
message arguments. For example,
<computeroutput>POS("a","Haystack",3)</computeroutput> is equivalent
to <computeroutput>"Haystack"~POS("a",3)</computeroutput>.</para></listitem>
<listitem><para>The language processor evaluates all built-in function
arguments to produce character strings.</para></listitem>
</itemizedlist>

<indexterm><primary>functions</primary>
<secondary>built-in, description</secondary></indexterm>

<section id="bifAbbrev"><title>ABBREV (Abbreviation)</title>
<indexterm><primary>ABBREV function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>ABBREV</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>ABBREV</secondary></indexterm>
<indexterm><primary>default</primary>
<secondary>selecting with ABBREV function</secondary></indexterm>
<indexterm><primary>selecting a default with ABBREV function</primary></indexterm>
<indexterm><primary>testing</primary></indexterm>
<indexterm><primary>abbreviations with ABBREV function</primary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/abbrev.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns <computeroutput>1</computeroutput> if
<emphasis role="italic">info</emphasis> is equal to the leading characters
of <emphasis role="italic">information</emphasis> and the length of
<emphasis role="italic">info</emphasis> is not less than
<emphasis role="italic">length</emphasis>. It returns
<computeroutput>0</computeroutput> if either of these conditions is not
met.</para>
<para>If you specify <emphasis role="italic">length</emphasis>,
it must be a positive whole number or zero. The default for
<emphasis role="italic">length</emphasis> is the number of characters in
<emphasis role="italic">info</emphasis>.</para>
<para>Here are some examples:</para>
<indexterm><primary>ABBREV function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>ABBREV function</secondary></indexterm>
<example id="ex.bif-abbrev">
<title>Builtin function ABBREV examples</title>
<programlisting>
ABBREV("Print","Pri")      ->    1
ABBREV("PRINT","Pri")      ->    0
ABBREV("PRINT","PRI",4)    ->    0
ABBREV("PRINT","PRY")      ->    0
ABBREV("PRINT","")         ->    1
ABBREV("PRINT","",1)       ->    0
</programlisting>
</example>

<note><title>Note</title>
<indexterm><primary>ABBREV function</primary>
<secondary>using to select a default</secondary></indexterm>
<para>A null string always matches if a length of
<computeroutput>0</computeroutput>, or the default,
is used. This allows a default keyword to be selected automatically if desired;
for example: </para>
<example id="ex.bif-abbrev-ex">
<title>Builtin function ABBREV example</title>
<programlisting>
say "Enter option:";   pull option .
select  /* keyword1 is to be the default */
  when abbrev("keyword1",option) then ...
  when abbrev("keyword2",option) then ...
  ...
  otherwise nop;
end;
</programlisting>
</example>
</note>
</section>


<section id="bifAbs"><title>ABS (Absolute Value)</title>
<indexterm><primary>ABS function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>ABS</secondary></indexterm>
<indexterm><primary>absolute value</primary>
<secondary>finding using the ABS function</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>ABS</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/abs.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the absolute value of <emphasis role="italic">number</emphasis>.
The result has no sign and
is formatted according to the current NUMERIC settings.</para>
<para>Here are some examples:</para>
<indexterm><primary>ABS function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>ABS function</secondary></indexterm>
<example id="ex.bif-abs">
<title>Builtin function ABS</title>
<programlisting>
ABS("12.3")       ->    12.3
ABS(" -0.307")    ->    0.307
</programlisting>
</example>
</section>


<section id="bifAddress"><title>ADDRESS</title>
<indexterm><primary>ADDRESS function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>ADDRESS</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>ADDRESS</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/address.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the name of the environment
<indexterm><primary>ADDRESS function</primary>
<secondary>determining current environment</secondary></indexterm>
<indexterm><primary>environment</primary>
<secondary>determining current using ADDRESS function</secondary></indexterm>
to which commands are currently submitted. Trailing whitespace characters are
removed from the result.
</para>
<para>Here is an example:</para>
<indexterm><primary>ADDRESS function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>ADDRESS function</secondary></indexterm>
<example id="ex.bif-address">
<title>Builtin function ADDRESS</title>
<programlisting>
ADDRESS()    ->    "CMD"        /* default under Windows */

ADDRESS()    ->    "bash"       /* default under Linux   */
</programlisting>
</example>
</section>


<section id="bifArg"><title>ARG (Argument)</title>
<indexterm><primary>ARG function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>ARG</secondary></indexterm>
<indexterm><primary>arguments</primary>
<secondary>checking with ARG function</secondary></indexterm>
<indexterm><primary>arguments</primary>
<secondary>retrieving with ARG function</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>ARG</secondary></indexterm>
<indexterm><primary>checking arguments with ARG function</primary></indexterm>
<indexterm><primary>retrieving</primary>
<secondary>arguments with ARG function</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/arg.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns one or more arguments, or information about the arguments to a
program, internal routine, or method.</para>
<para>If you do not specify <emphasis role="italic">n</emphasis>, the number
of arguments passed to the program or internal routine is returned.</para>
<para>If you specify only <emphasis role="italic">n</emphasis>, the
<emphasis role="italic">n</emphasis>th argument object is returned.
If the argument object does not exist, the null string is returned.
<emphasis role="italic">n</emphasis> must be a positive whole number.</para>
<para>If you specify <emphasis role="italic">option</emphasis>, the value
returned depends on the value of <emphasis role="italic">option</emphasis>.
The following are valid <emphasis role="italic">option</emphasis>s. (Only the
capitalized letter is needed; all characters following it are ignored.)</para>
<variablelist>
<varlistentry><term>Array</term>
<listitem><para>returns a single-index array containing the arguments, starting
with the <emphasis role="italic">n</emphasis>th argument. The array indexes
correspond to the argument positions, so that the
<emphasis role="italic">n</emphasis>th argument is at index 1, the following
argument at index 2, and so on. If any arguments are omitted, their
corresponding indexes are absent.
</para></listitem></varlistentry>
<varlistentry><term>Exists</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the
<emphasis role="italic">n</emphasis>th argument exists; that is, if
it was explicitly specified when the routine was called. Otherwise, it returns
<computeroutput>0</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Normal</term>
<listitem><para>returns the <emphasis role="italic">n</emphasis>th argument,
if it exists, or a null string.
</para></listitem></varlistentry>
<varlistentry><term>Omitted</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the
<emphasis role="italic">n</emphasis>th argument was omitted; that
is, if it was not explicitly specified when the routine
was called. Otherwise, it returns <computeroutput>0</computeroutput>.
</para></listitem></varlistentry>
</variablelist>
<para>Here are some examples:</para>
<indexterm><primary>ARG function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>ARG function</secondary></indexterm>
<example id="ex.bif-arg">
<title>Builtin function ARG</title>
<programlisting>
/*  following "Call name;" (no arguments) */
ARG()         ->    0
ARG(1)        ->    ""
ARG(2)        ->    ""
ARG(1,"e")    ->    0
ARG(1,"O")    ->    1
ARG(1,"a")    ->    .array~of()

/*  following "Call name &apos;a&apos;, ,&apos;b&apos;;" */
ARG()         ->    3
ARG(1)        ->    "a"
ARG(2)        ->    ""
ARG(3)        ->    "b"
ARG(n)        ->    ""    /* for n>=4 */
ARG(1,"e")    ->    1
ARG(2,"E")    ->    0
ARG(2,"O")    ->    1
ARG(3,"o")    ->    0
ARG(4,"o")    ->    1
ARG(1,"A")    ->    .array~of(a, ,b)
ARG(3,"a")    ->    .array~of(b)
</programlisting>
</example>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>The number of argument strings is the largest number
<emphasis role="italic">n</emphasis> for which
<computeroutput>ARG(n,"e")</computeroutput> returns
<computeroutput>1</computeroutput> or <computeroutput>0</computeroutput>
if there are no explicit argument strings. That is, it is the position of the
last explicitly specified argument string.</para></listitem>
<listitem><para>Programs called as commands can have only 0 or 1 argument strings. The
program has 0 argument strings if it is called with the name only and has
1 argument string if anything else (including whitespace characters) is included
in the command.</para></listitem>
<listitem><para>Programs called by the RexxStart entry point can have several argument
strings. (See the
<citetitle pubwork="book">Open Object Rexx: Programming Guide</citetitle>
for information about RexxStart.)</para></listitem>
<listitem><para>You can access the argument objects of a program with the USE instruction.
See <xref linkend="keyUse" /> for more information.</para></listitem>
<listitem><para>You can retrieve and directly parse the argument strings of a program
or internal routine with the ARG or PARSE ARG instructions.</para></listitem>
</orderedlist>
</section>


<section id="bifB2x"><title>B2X (Binary to Hexadecimal)</title>
<indexterm><primary>B2X function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>B2X</secondary></indexterm>
<indexterm><primary>binary</primary>
<secondary>to hexadecimal conversion</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>B2X</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>binary to hexadecimal</secondary></indexterm>
<indexterm><primary>unpacking a string</primary>
<secondary>with B2X</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/b2x.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a string, in character format, that represents
<emphasis role="italic">binary_string</emphasis> converted to hexadecimal.</para>
<para>The <emphasis role="italic">binary_string</emphasis> is a string of
binary (<computeroutput>0</computeroutput> or
<computeroutput>1</computeroutput>) digits. It can be of any length. You can
optionally include whitespace characters in <emphasis role="italic">binary_string</emphasis>
(at 4-digit boundaries only, not leading or trailing) to improve readability;
they are ignored.
</para>
<para>The returned string uses uppercase alphabetical characters for the
values <computeroutput>A</computeroutput>-<computeroutput>F</computeroutput>,
and does not include blanks or horizontal tabs.</para>
<para>If <emphasis role="italic">binary_string</emphasis> is the null string,
B2X returns a null string. If the number of binary digits in
<emphasis role="italic">binary_string</emphasis> is not a multiple
of 4, then up to three <computeroutput>0</computeroutput>
digits are added on the left before the
conversion to make a total that is a multiple of 4.</para>
<para>Here are some examples:</para>
<indexterm><primary>B2X function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>B2X function</secondary></indexterm>
<example id="ex.bif-b2x">
<title>Builtin function B2X</title>
<programlisting>
B2X("11000011")    ->   "C3"
B2X("10111")       ->   "17"
B2X("101")         ->   "5"
B2X("1 1111 0000") ->   "1F0"
</programlisting>
</example>
<para>You can combine B2X with the functions X2D and X2C to convert a binary
number into other forms. For example: </para>
<example id="ex.bif-b2x-1">
<title>Builtin function B2X combined with X2D function</title>
<programlisting>
X2D(B2X("10111"))  ->   "23"   /* decimal 23 */
</programlisting>
</example>
</section>


<section id="bifBeep"><title>BEEP</title>
<indexterm><primary>BEEP function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>BEEP</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>BEEP</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/beep.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Sounds the speaker at frequency (Hertz) for duration (milliseconds).
The frequency can be any whole number in the range 37 to 32767 Hertz. The
duration can be any number in the range 1 to 60000 milliseconds.</para>
<para>This routine is most useful when called as a subroutine.  A null string
is returned.</para>

<note><title>Note</title>
<para>Both parameters (frequency, duration) are ignored on Windows 95 and Linux.
On computers with multimedia support the function plays the default sound
event. On computers without soundcard, the function plays the standard system
beep (if activated).</para></note>
<para>Here is an example for Windows NT: </para>
<indexterm><primary>BEEP function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>BEEP function</secondary></indexterm>
<example id="ex.bif-beep">
<title>Builtin function BEEP</title>
<programlisting>
/* C scale */
note.1 = 262    /* middle C */
note.2 = 294    /*    D     */
note.3 = 330    /*    E     */
note.4 = 349    /*    F     */
note.5 = 392    /*    G     */
note.6 = 440    /*    A     */
note.7 = 494    /*    B     */
note.8 = 523    /*    C     */

do i=1 to 8
call beep note.i,250    /* hold each note for */
/* one-quarter second */
end
</programlisting>
</example>
</section>


<section id="bifBitand"><title>BITAND (Bit by Bit AND)</title>
<indexterm><primary>BITAND function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>BITAND</secondary></indexterm>
<indexterm><primary>logical bit operations</primary>
<secondary>BITAND</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>logical bit operations</secondary></indexterm>
<indexterm><primary>ANDing character strings</primary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>BITAND</secondary></indexterm>
<indexterm><primary>character</primary>
<secondary>strings, ANDing</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/bitand.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a string composed of the two input strings logically ANDed, bit
by bit. (The encodings of the strings are used in the logical operation.)
The length of the result is the length of the longer of the two strings. If
no <emphasis role="italic">pad</emphasis> character is provided, the AND
operation stops when the shorter of the two strings is exhausted, and the
unprocessed portion of the longer string is appended to the partial result. If
<emphasis role="italic">pad</emphasis> is provided, it
extends the shorter of the two strings on the right before carrying out the
logical operation. The default for <emphasis role="italic">string2</emphasis>
is the zero-length (null) string.</para>
<para>Here are some examples:</para>
<indexterm><primary>BITAND function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>BITAND function</secondary></indexterm>
<example id="ex.bif-bitand">
<title>Builtin function BITAND</title>
<programlisting>
BITAND("12"x)                  ->    "12"x
BITAND("73"x,"27"x)            ->    "23"x
BITAND("13"x,"5555"x)          ->    "1155"x
BITAND("13"x,"5555"x,"74"x)    ->    "1154"x
BITAND("pQrS", ,"DF"x)         ->    "PQRS"      /* ASCII   */
</programlisting>
</example>
</section>


<section id="bifBitor"><title>BITOR (Bit by Bit OR)</title>
<indexterm><primary>BITOR function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>BITOR</secondary></indexterm>
<indexterm><primary>logical bit operations</primary>
<secondary>BITOR</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>logical bit operations</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>BITOR</secondary></indexterm>
<indexterm><primary>character</primary>
<secondary>strings, ORing</secondary></indexterm>
<indexterm><primary>ORing character together</primary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/bitor.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a string composed of the two input strings logically inclusive-ORed,
bit by bit. (The encodings of the strings are used in the logical operation.)
The length of the result is the length of the longer of the two strings. If
no <emphasis role="italic">pad</emphasis> character is provided, the OR
operation stops when the shorter of the two strings is exhausted, and the
unprocessed portion of the longer string is appended to the partial result. If
<emphasis role="italic">pad</emphasis> is provided, it
extends the shorter of the two strings on the right before carrying out the
logical operation. The default for <emphasis role="italic">string2</emphasis>
is the zero-length (null) string.</para>
<para>Here are some examples:</para>
<indexterm><primary>BITOR function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>BITOR function</secondary></indexterm>
<example id="ex.bif-bitor">
<title>Builtin function BITOR</title>
<programlisting>
BITOR("12"x)                  ->    "12"x
BITOR("15"x,"24"x)            ->    "35"x
BITOR("15"x,"2456"x)          ->    "3556"x
BITOR("15"x,"2456"x,"F0"x)    ->    "35F6"x
BITOR("1111"x, ,"4D"x)        ->    "5D5D"x
BITOR("pQrS", ,"20"x)         ->    "pqrs" /* ASCII   */
</programlisting>
</example>
</section>


<section id="bifBitxor"><title>BITXOR (Bit by Bit Exclusive OR)</title>
<indexterm><primary>BITXOR function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>BITXOR</secondary></indexterm>
<indexterm><primary>logical bit operations</primary>
<secondary>BITXOR</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>logical bit operations</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>BITXOR</secondary></indexterm>
<indexterm><primary>character</primary>
<secondary>strings, exclusive-ORing</secondary></indexterm>
<indexterm><primary>exclusive-ORing character strings together</primary></indexterm>
<indexterm><primary>XORing character strings together</primary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/bitxor.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a string composed of the two input strings logically eXclusive-ORed,
bit by bit. (The encodings of the strings are used in the logical operation.)
The length of the result is the length of the longer of the two strings. If
no <emphasis role="italic">pad</emphasis> character is provided, the
XOR operation stops when the shorter of the two strings is exhausted, and the
unprocessed portion of the longer string is appended to the partial result. If
<emphasis role="italic">pad</emphasis> is provided, it
extends the shorter of the two strings on the right before carrying out the
logical operation. The default for <emphasis role="italic">string2</emphasis>
is the zero-length (null) string.</para>
<para>Here are some examples:</para>
<indexterm><primary>BITXOR function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>BITXOR function</secondary></indexterm>
<example id="ex.bif-bitxor">
<title>Builtin function BITXOR</title>
<programlisting>
BITXOR("12"x)                     ->  "12"x
BITXOR("12"x,"22"x)               ->  "30"x
BITXOR("1211"x,"22"x)             ->  "3011"x
BITXOR("1111"x,"444444"x)         ->  "555544"x
BITXOR("1111"x,"444444"x,"40"x)   ->  "555504"x
BITXOR("1111"x, ,"4D"x)           ->  "5C5C"x
BITXOR("C711"x,"222222"x," ")     ->  "E53302"x  /* ASCII  */
</programlisting>
</example>
</section>


<section id="bifC2d"><title>C2D (Character to Decimal)</title>
<indexterm><primary>C2D function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>C2D</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>C2D</secondary></indexterm>
<indexterm><primary>character</primary>
<secondary>to decimal conversion</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>character to decimal</secondary></indexterm>

<para></para>
<mediaobject>
<imageobject>
<imagedata fileref="images/bif/c2d.svg" scale="50" />
</imageobject>
</mediaobject>
<para>
Returns the decimal value of the binary representation of
<emphasis role="italic">string</emphasis>. If the result cannot be expressed as
a whole number, an error results. That is, the result must not have more digits
than the current setting of NUMERIC DIGITS. If you specify
<emphasis role="italic">n</emphasis>, it is the length of the returned
result. If you do not specify <emphasis role="italic">n</emphasis>,
<emphasis role="italic">string</emphasis> is processed as
an unsigned binary number.</para>
<para>If <emphasis role="italic">string</emphasis> is null,
<computeroutput>0</computeroutput> is returned.</para>
<para>Here are some examples:</para>
<indexterm><primary>C2D function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>C2D function</secondary></indexterm>
<example id="ex.bif-c2d">
<title>Builtin function C2D</title>
<programlisting>
C2D("09"X)      ->        9
C2D("81"X)      ->      129
C2D("FF81"X)    ->    65409
C2D("")         ->        0
C2D("a")        ->       97     /*  ASCII   */
</programlisting>
</example>
<para>If you specify <emphasis role="italic">n</emphasis>,
the string is taken as a signed number expressed
in <emphasis role="italic">n</emphasis> characters. The number is positive if
the leftmost bit is off,
and negative if the leftmost bit is on. In both cases, it is converted to
a whole number, which can be negative. The
<emphasis role="italic">string</emphasis> is padded on the
left with "00"x characters (not &quot;sign-extended&quot;), or truncated
on the left to <emphasis role="italic">n</emphasis> characters.
This padding or truncation is as though
<computeroutput>RIGHT(string, n,"00"x)</computeroutput>
had been processed. If <emphasis role="italic">n</emphasis> is
<computeroutput>0</computeroutput>, C2D always returns
<computeroutput>0</computeroutput>.</para>
<para>Here are some examples: </para>
<example id="ex.bif-c2d-1">
<title>Builtin function C2D</title>
<programlisting>
C2D("81"X,1)      ->     -127
C2D("81"X,2)      ->      129
C2D("FF81"X,2)    ->     -127
C2D("FF81"X,1)    ->     -127
C2D("FF7F"X,1)    ->      127
C2D("F081"X,2)    ->    -3967
C2D("F081"X,1)    ->     -127
C2D("0031"X,0)    ->        0
</programlisting>
</example>
</section>


<section id="bifC2x"><title>C2X (Character to Hexadecimal)</title>
<indexterm><primary>C2X function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>C2X</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>C2X</secondary></indexterm>
<indexterm><primary>character</primary>
<secondary>to hexadecimal conversion</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>character to hexadecimal</secondary></indexterm>
<indexterm><primary>unpacking a string</primary>
<secondary>with C2X</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/c2x.svg" scale="50" />
</imageobject>
</mediaobject>
<para>Returns a string, in character format, that represents
<emphasis role="italic">string</emphasis> converted to hexadecimal.
The returned string contains twice as many bytes as the input string. On an
ASCII system, C2X(1) returns <computeroutput>31</computeroutput> because the
ASCII representation of the character 1 is "31"X.</para>
<para>The string returned uses uppercase alphabetical characters for the values
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput>
and does not include whitespace characters. The <emphasis role="italic">string</emphasis>
can be of any length. If
<emphasis role="italic">string</emphasis> is null, a null string is
returned.</para>
<para>Here are some examples:</para>
<indexterm><primary>C2X function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>C2X function</secondary></indexterm>
<example id="ex.bif-c2x">
<title>Builtin function C2X</title>
<programlisting>
C2X("0123"X)    ->    "0123"   /* "30313233"X     in ASCII */
C2X("ZD8")      ->    "5A4438" /* "354134343338"X in ASCII */
</programlisting>
</example>
</section>


<section id="bifCenter"><title>CENTER (or CENTRE)</title>
<indexterm><primary>CENTER function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>CENTER</secondary></indexterm>
<indexterm><primary>CENTRE function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>CENTRE</secondary></indexterm>
<indexterm><primary>centering a string</primary>
<secondary>CENTRE</secondary></indexterm>
<indexterm><primary>centering a string</primary>
<secondary>CENTER</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>CENTER</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>CENTRE</secondary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text centering</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>centering using CENTRE method</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>centering using CENTER method</secondary></indexterm>

<para></para>
<mediaobject>
<imageobject>
<imagedata fileref="images/bif/center.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a string of length <emphasis role="italic">length</emphasis>
with <emphasis role="italic">string</emphasis> centered in it and with
<emphasis role="italic">pad</emphasis> characters added as necessary to make up
length. The <emphasis role="italic">length</emphasis> must be a positive whole
number or zero. The default <emphasis role="italic">pad</emphasis> character
is blank. If the string is longer than <emphasis role="italic">length</emphasis>,
it is truncated at both ends to fit. If an odd number of characters is truncated
or added, the right-hand end loses or gains one more character than the left-hand
end.</para>
<para>Here are some examples:</para>
<indexterm><primary>CENTER function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>CENTER function</secondary></indexterm>
<indexterm><primary>CENTRE function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>CENTRE function</secondary></indexterm>
<example id="ex.bif-center">
<title>Builtin function CENTER</title>
<programlisting>
CENTER(abc,7)               ->    "  ABC  "
CENTER(abc,8,"-")           ->    "--ABC---"
CENTRE("The blue sky",8)    ->    "e blue s"
CENTRE("The blue sky",7)    ->    "e blue "
</programlisting>
</example>

<note><title>Note</title>
<para>To avoid errors because of the difference between British and American
spellings, this function can be called either CENTRE or CENTER.</para></note>
</section>


<section id="bifChangestr"><title>CHANGESTR</title>
<indexterm><primary>CHANGESTR function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>CHANGESTR</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>CHANGESTR</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/changestr.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a copy of <emphasis role="italic">haystack</emphasis> in which
<emphasis role="italic">newneedle</emphasis> replaces
occurrences of <emphasis role="italic">needle</emphasis>.
If <emphasis role="italic">count</emphasis> is not specified, all occurrences of
<emphasis role="italic">needle</emphasis> are replaced.  If <emphasis role="italic">count</emphasis>
is specified, it must be a positive, whole number that gives the maximum number of
occurrences to be replaced.
</para>
<para>Here are some examples:</para>
<indexterm><primary>CHANGESTR function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>CHANGESTR function</secondary></indexterm>
<example id="ex.bif-changestr">
<title>Builtin function CHANGESTR</title>
<programlisting>
CHANGESTR("1","101100","")     ->    "000"
CHANGESTR("1","101100","X")    ->    "X0XX00"
CHANGESTR("1","101100","X", 1) ->    "X01100"
</programlisting>
</example>
</section>


<section id="bifCharin"><title>CHARIN (Character Input)</title>
<indexterm><primary>CHARIN function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>CHARIN</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>CHARIN</secondary></indexterm>
<indexterm><primary>input and output</primary>
<secondary>functions</secondary>
<tertiary>CHARIN</tertiary></indexterm>
<indexterm><primary>string</primary>
<secondary>from stream</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/charin.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a string of up to <emphasis role="italic">length</emphasis>
characters read from the character input stream
<emphasis role="italic">name</emphasis>. (To understand the input and output functions,
see <xref linkend="iostrms" />.) If you omit
<emphasis role="italic">name</emphasis>, characters are read
from STDIN, which is the default input stream. The default
<emphasis role="italic">length</emphasis> is
<computeroutput>1</computeroutput>.</para>
<para>For persistent streams, a read position is maintained for each stream.
Any read from the stream starts at the current read position by default. When
the language processor completes reading, the read position is increased by
the number of characters read. You can give a
<emphasis role="italic">start</emphasis> value to specify
an explicit read position.  This read position must be a positive whole number and within
the bounds of the stream, and must not be specified for a transient stream. A value of
<computeroutput>1</computeroutput> for <emphasis role="italic">start</emphasis> refers to the first
character in the stream. If <emphasis role="italic">start</emphasis> is not a positive whole number the
appropriate syntax condition is raised. When the read position is past the bounds of the stream, the
empty string is returned and the NOTREADY condition is raised.
</para>
<para>If you specify a <emphasis role="italic">length</emphasis> of
<computeroutput>0</computeroutput>, then the read position
is set to the value of <emphasis role="italic">start</emphasis>, but no
characters are read and the null string is returned.</para>
<para>In a transient stream, if there are fewer than
<emphasis role="italic">length</emphasis> characters
available, the execution of the program generally stops until sufficient characters
become available.  If, however, it is impossible for those characters to become
available because of an error or another problem, the NOTREADY condition is
raised (see <xref linkend="stmerr" />)
and CHARIN returns with fewer than the requested number of characters.</para>
<para>Here are some examples:</para>
<indexterm><primary>CHARIN function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>CHARIN function</secondary></indexterm>
<example id="ex.bif-charin">
<title>Builtin function CHARIN</title>
<programlisting>
CHARIN(myfile,1,3)   ->   "MFC"    /* the first 3        */
                                   /* characters         */
CHARIN(myfile,1,0)   ->   ""       /* now at start       */
CHARIN(myfile)       ->   "M"      /* after last call    */
CHARIN(myfile, ,2)   ->   "FC"     /* after last call    */

/* Reading from the default input (here, the keyboard)   */
/* User types "abcd efg"                                 */
CHARIN()             ->   "a"      /* default is         */
                                   /* 1 character        */
CHARIN(, ,5)         ->   "bcd e"
</programlisting>
</example>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>CHARIN returns all characters that appear in the stream, including control
characters such as line feed, carriage return, and end of file.</para></listitem>
<listitem><para>When CHARIN reads from the keyboard, program execution stops until you
press the Enter key.</para></listitem>
</orderedlist>
</section>


<section id="bifCharout"><title>CHAROUT (Character Output)</title>
<indexterm><primary>CHAROUT function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>CHAROUT</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>CHAROUT</secondary></indexterm>
<indexterm><primary>count from stream</primary></indexterm>
<indexterm><primary>input and output</primary>
<secondary>functions</secondary>
<tertiary>CHAROUT</tertiary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/charout.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the count of characters remaining after attempting to write
<emphasis role="italic">string</emphasis> to the character output stream
<emphasis role="italic">name</emphasis>. (To understand the
input and output functions, see
<xref linkend="iostrms" />.) If you omit
<emphasis role="italic">name</emphasis>, characters in
<emphasis role="italic">string</emphasis> are written to STDOUT (generally
the display), which is the default output stream. The
<emphasis role="italic">string</emphasis> can
be a null string, in which case no characters are written to the stream, and
<computeroutput>0</computeroutput> is always returned.</para>
<para>For persistent streams, a write position is maintained for each stream.
Any write to the stream starts at the current write position by default. When
the language processor completes writing, the write position is increased
by the number of characters written. When the stream is first opened, the
write position is at the end of the stream so that calls to CHAROUT append
characters to the end of the stream.</para>
<para>You can give a <emphasis role="italic">start</emphasis> value to specify
an explicit write position
for a persistent stream. This write position must be a positive whole number.
A value of <computeroutput>1</computeroutput> for
<emphasis role="italic">start</emphasis> refers to the first character in
the stream.</para>
<para>You can omit the <emphasis role="italic">string</emphasis>
for persistent streams. In this case, the write position is set to the value
of <emphasis role="italic">start</emphasis> that was given, no
characters are written to the stream, and
<computeroutput>0</computeroutput> is returned. If you
do not specify <emphasis role="italic">start</emphasis> or
<emphasis role="italic">string</emphasis>, the stream is closed and
<computeroutput>0</computeroutput> is returned.</para>
<para>Execution of the program usually stops until the output operation is complete.</para>
<para>For example, when data is sent to a printer, the system accepts the data
and returns control to Rexx, even though the output data might not have been
printed.  Rexx considers this to be complete, even though the data has not
been printed. If, however, it is impossible for all the characters to be written,
the NOTREADY condition is raised (see
<xref linkend="stmerr" />) and CHAROUT returns
with the number of characters that could not be written (the residual count).</para>
<para>Here are some examples:</para>
<indexterm><primary>CHAROUT function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>CHAROUT function</secondary></indexterm>
<example id="ex.bif-charout">
<title>Builtin function CHAROUT</title>
<programlisting>
CHAROUT(myfile,"Hi")     ->   0   /* typically        */
CHAROUT(myfile,"Hi",5)   ->   0   /* typically        */
CHAROUT(myfile, ,6)      ->   0   /* now at char 6    */
CHAROUT(myfile)          ->   0   /* at end of stream */
CHAROUT(,"Hi")           ->   0   /* typically        */
CHAROUT(,"Hello")        ->   2   /* maybe            */
</programlisting>
</example>

<note><title>Note</title>
<para>This routine is often best called as a subroutine. The residual
count is then available in the variable RESULT.</para></note>
<para>For example: </para>
<example id="ex.bif-charout-sub">
<title>Builtin function CHAROUT</title>
<programlisting>
Call CHAROUT myfile,"Hello"
Call CHAROUT myfile,"Hi",6
Call CHAROUT myfile
</programlisting>
</example>
</section>


<section id="bifChars"><title>CHARS (Characters Remaining)</title>
<indexterm><primary>CHARS function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>CHARS</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>CHARS</secondary></indexterm>
<indexterm><primary>input and output</primary>
<secondary>functions</secondary>
<tertiary>CHARS</tertiary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/chars.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the total number of characters remaining in the character input
stream <emphasis role="italic">name</emphasis>. The count includes any
line separator characters, if
these are defined for the stream. In the case of persistent streams, it is
the count of characters from the current read position. (See
<xref linkend="iostrms" /> for
a discussion of Rexx input and output.) If you omit
<emphasis role="italic">name</emphasis>, the number
of characters available in the default input stream (STDIN) is returned.</para>
<para>The total number of characters remaining cannot be determined for some
streams (for example, STDIN). For these streams, the CHARS function returns
<computeroutput>1</computeroutput> to indicate that data is present, or
<computeroutput>0</computeroutput> if no data is present. For windows devices,
CHARS always returns <computeroutput>1</computeroutput>.</para>
<para>Here are some examples:</para>
<indexterm><primary>CHARS function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>CHARS function</secondary></indexterm>
<example id="ex.bif-chars">
<title>Builtin function CHARS</title>
<programlisting>
CHARS(myfile)     ->   42   /* perhaps */
CHARS(nonfile)    ->   0
CHARS()           ->   1    /* perhaps */
</programlisting>
</example>
</section>


<section id="bifCompare"><title>COMPARE</title>
<indexterm><primary>COMPARE function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>COMPARE</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>COMPARE</secondary></indexterm>
<indexterm><primary>comparisons</primary>
<secondary>of strings</secondary></indexterm>
<indexterm><primary>finding</primary>
<secondary>mismatch using COMPARE</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/compare.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns <computeroutput>0</computeroutput> if the strings
<emphasis role="italic">string1</emphasis> and
<emphasis role="italic">string2</emphasis> are
identical. Otherwise, it returns the position of the first character that
does not match. The shorter string is padded on the right with
<emphasis role="italic">pad</emphasis> if necessary.  The default
<emphasis role="italic">pad</emphasis> character is a blank.</para>
<para>Here are some examples:</para>
<indexterm><primary>COMPARE function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>COMPARE function</secondary></indexterm>
<example id="ex.bif-compare">
<title>Builtin function COMPARE</title>
<programlisting>
COMPARE("abc","abc")         ->    0
COMPARE("abc","ak")          ->    2
COMPARE("ab ","ab")          ->    0
COMPARE("ab ","ab"," ")      ->    0
COMPARE("ab ","ab","x")      ->    3
COMPARE("ab-- ","ab","-")    ->    5
</programlisting>
</example>
</section>


<section id="bifCondition"><title>CONDITION</title>
<indexterm><primary>CONDITION function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>CONDITION</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>CONDITION</secondary></indexterm>
<indexterm><primary>condition</primary>
<secondary>trap information using CONDITION</secondary></indexterm>
<indexterm><primary>trap conditions</primary>
<secondary>using CONDITION function</secondary></indexterm>
<indexterm><primary>trap conditions</primary>
<secondary>information about trapped conditions</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/condition.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the condition information associated with the current trapped
condition. (See <xref linkend="condtra" />
for a description of condition traps.) You can
request the following pieces of information: </para>
<itemizedlist>
<listitem><para>The name of the current trapped condition</para></listitem>
<listitem><para>Any descriptive string associated with that condition</para></listitem>
<listitem><para>Any condition-specific information associated with the current trapped
condition</para></listitem>
<listitem><para>The instruction processed as a result of the condition trap
(CALL or SIGNAL)</para></listitem>
<listitem><para>The status of the trapped condition</para></listitem>
</itemizedlist>
<para> In addition, you can request a condition object containing all of the
preceding information.</para>
<para>To select the information to be returned, use the following
<emphasis role="italic">option</emphasis>s. (Only the capitalized letter is
needed; all characters following it are ignored.) </para>
<variablelist>
<varlistentry><term>Additional</term>
<listitem><para>returns any additional object information associated with the
current trapped condition. See
<xref linkend="addinf" /> for a list of
possible values. If no additional object information is available or no
condition has been trapped, the language processor returns the Nil object.
</para></listitem></varlistentry>
<varlistentry><term>Condition name</term>
<listitem><para>returns the name of the current trapped condition.
For user conditions, the returned string is a concatenation of the word
<computeroutput>USER</computeroutput> and the
user condition name, separated by a whitespace character.
</para></listitem></varlistentry>
<varlistentry><term>Description</term>
<listitem><para>returns any descriptive string associated with the current
trapped condition. See <xref linkend="dstring" />
for the list of possible values. If no description
is available or no condition has been trapped, it returns a null string.
</para></listitem></varlistentry>
<varlistentry><term>Instruction</term>
<listitem><para>returns either <computeroutput>CALL</computeroutput> or
<computeroutput>SIGNAL</computeroutput>, the keyword for
the instruction processed when the current condition was trapped. This is
the default if you omit <emphasis role="italic">option</emphasis>. If no
condition has been trapped, it returns a null string.
</para></listitem></varlistentry>
<varlistentry><term>Object</term>
<listitem><para>returns an object that contains all the information about the
current trapped condition. See
<xref linkend="condtra" /> for more
information. If no condition has been trapped, it returns the Nil object.
</para></listitem></varlistentry>
<varlistentry><term>Status</term>
<listitem><para>returns the status of the current trapped condition.  This can
change during processing, and is one of the following: </para>
<itemizedlist>
<listitem><para><computeroutput>ON</computeroutput> - the condition is enabled
</para></listitem>
<listitem><para><computeroutput>OFF</computeroutput> - the condition is disabled
</para></listitem>
<listitem><para><computeroutput>DELAY</computeroutput> - any new occurrence of
the condition is delayed or ignored</para></listitem></itemizedlist>
<para>If no condition has been trapped, a null string is returned.</para>
</listitem></varlistentry>
</variablelist>
<para>Here are some examples:</para>
<indexterm><primary>CONDITION function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>CONDITION function</secondary></indexterm>
<example id="ex.bif-condition">
<title>Builtin function CONDITION</title>
<programlisting>
CONDITION()            ->    "CALL"        /* perhaps */
CONDITION("C")         ->    "FAILURE"
CONDITION("I")         ->    "CALL"
CONDITION("D")         ->    "FailureTest"
CONDITION("S")         ->    "OFF"        /* perhaps */
</programlisting>
</example>

<note><title>Note</title>
<para>The CONDITION function returns condition information that
is saved and restored across subroutine calls (including those a CALL ON condition
trap causes). Therefore, after a subroutine called with CALL ON
<emphasis role="italic">trapname</emphasis> has returned, the current trapped
condition reverts to the condition
that was current before the CALL took place (which can be none). CONDITION
returns the values it returned before the condition was trapped.</para></note>
</section>


<section id="bifCopies"><title>COPIES</title>
<indexterm><primary>COPIES function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>COPIES</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>COPIES</secondary></indexterm>
<indexterm><primary>copying a string using COPIES</primary></indexterm>
<indexterm><primary>repeating s string with COPIES</primary></indexterm>
<indexterm><primary>string</primary>
<secondary>copying using COPIES</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>reapting using COPIES</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/copies.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns <emphasis role="italic">n</emphasis> concatenated copies of
<emphasis role="italic">string</emphasis>. The
<emphasis role="italic">n</emphasis> must
be a positive whole number or zero.</para>
<para>Here are some examples:</para>
<indexterm><primary>COPIES function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>COPIES function</secondary></indexterm>
<example id="ex.bif-copies">
<title>Builtin function COPIES</title>
<programlisting>
COPIES("abc",3)    ->    "abcabcabc"
COPIES("abc",0)    ->    ""
</programlisting>
</example>
</section>


<section id="bifCountstr"><title>COUNTSTR</title>
<indexterm><primary>COUNTSTR function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>COUNTSTR</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>COUNTSTR</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/countstr.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a count of the occurrences of
<emphasis role="italic">needle</emphasis> in
<emphasis role="italic">haystack</emphasis> that
do not overlap.</para>
<para>Here are some examples: </para>
<indexterm><primary>COUNTSTR function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>COUNTSTR function</secondary></indexterm>
<example id="ex.bif-countstr">
<title>Builtin function COUNTSTR</title>
<programlisting>
COUNTSTR("1","101101")        ->    4
COUNTSTR("KK","J0KKK0")       ->    1
</programlisting>
</example>
</section>


<section id="bifD2c"><title>D2C (Decimal to Character)</title>
<indexterm><primary>D2C function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>D2C</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>D2C</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>decimal to character</secondary></indexterm>
<indexterm><primary>decimal</primary>
<secondary>to character conversion</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/d2c.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a string, in character format, that is the ASCII representation
of the decimal number. If you specify <emphasis role="italic">n</emphasis>,
it is the length of the final result in characters;
leading "00"x (for a positive <emphasis>wholenumber</emphasis>) or "FF"x
(for a negative <emphasis>wholenumber</emphasis>) characters are added to the
result string as necessary. <emphasis role="italic">n</emphasis> must be a
positive whole number or zero.</para>
<para><emphasis role="italic">Wholenumber</emphasis> must not have more digits
than the current setting of NUMERIC DIGITS.</para>
<para>If you omit <emphasis role="italic">n</emphasis>,
<emphasis role="italic">wholenumber</emphasis> must be a positive whole number
or zero, and the result length is as needed. Therefore, the returned result
has no leading "00"x characters.</para>
<para>Here are some examples:</para>
<indexterm><primary>D2C function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>D2C function</secondary></indexterm>
<example id="ex.bif-d2c">
<title>Builtin function D2C</title>
<programlisting>
D2C(65)      ->   "A"      /* "41"x is an ASCII "A"               */
D2C(65,1)    ->   "A"
D2C(65,2)    ->   " A"     /* the leading character is a "00"x    */
D2C(65,5)    ->   "    A"  /* the leading characters are "00"x    */
D2C(109)     ->   "m"      /* "6D"x  is an ASCII "m"              */
D2C(-109,1)  ->   "&ocirc;"      /* "93"x is an ASCII "&ocirc;"   */
D2C(76,2)    ->   " L"     /* "4C"x  is an ASCII "L"              */
D2C(-180,2)  ->   " L"     /* the leading character is a "FF"x    */
</programlisting>
</example>
</section>


<section id="bifD2x"><title>D2X (Decimal to Hexadecimal)</title>
<indexterm><primary>D2X function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>D2X</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>D2X</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>decimal to hexadecimal</secondary></indexterm>
<indexterm><primary>decimal</primary>
<secondary>to hexadecimal conversion</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/d2x.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a string, in character format, that represents
<emphasis role="italic">wholenumber</emphasis>, a decimal number, converted to
hexadecimal. The returned string uses uppercase alphabetics for the values
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput> and does
not include whitespace characters.</para>
<para><emphasis role="italic">Wholenumber</emphasis> must not have more digits
than the current setting of NUMERIC DIGITS.</para>
<para>If you specify <emphasis role="italic">n</emphasis>,
it is the length of the final result in characters.
After conversion the input string is sign-extended to the required length.
If the number is too big to fit <emphasis role="italic">n</emphasis>
characters, it is truncated on the left. <emphasis role="italic">n</emphasis>
must be a positive whole number or zero.</para>
<para>If you omit <emphasis role="italic">n</emphasis>,
<emphasis role="italic">wholenumber</emphasis> must be a positive whole number
or zero, and the returned result has no leading zeros.</para>
<para>Here are some examples:</para>
<indexterm><primary>D2X function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>D2X function</secondary></indexterm>
<example id="ex.bif-d2x">
<title>Builtin function D2X</title>
<programlisting>
D2X(9)         ->    "9"
D2X(129)       ->    "81"
D2X(129,1)     ->    "1"
D2X(129,2)     ->    "81"
D2X(129,4)     ->    "0081"
D2X(257,2)     ->    "01"
D2X(-127,2)    ->    "81"
D2X(-127,4)    ->    "FF81"
D2X(12,0)      ->    ""
</programlisting>
</example>
</section>


<section id="bifDatatype"><title>DATATYPE</title>
<indexterm><primary>DATATYPE function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>DATATYPE</secondary></indexterm>
<indexterm><primary>alphabetics</primary>
<secondary>checking with DATATYPE</secondary></indexterm>
<indexterm><primary>alphanumerics</primary>
<secondary>checking with DATATYPE</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>DATATYPE</secondary></indexterm>
<indexterm><primary>bits checked using DATATYPE function</primary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>checking with DATATYPE</secondary></indexterm>
<indexterm><primary>type of data, checking with DATATYPE</primary></indexterm>
<indexterm><primary>whole numbers</primary>
<secondary>checking with DATATYPE</secondary></indexterm>
<indexterm><primary>numbers</primary>
<secondary>checking with DATATYPE</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/datatype.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns <computeroutput>NUM</computeroutput> if you specify only
<emphasis role="italic">string</emphasis> and if
<emphasis role="italic">string</emphasis> is a valid Rexx number that can be
added to 0 without error; returns <computeroutput>CHAR</computeroutput> if
<emphasis role="italic">string</emphasis> is not a valid number.</para>
<para>If you specify <emphasis role="italic">type</emphasis>, it returns
<computeroutput>1</computeroutput> if <emphasis role="italic">string</emphasis>
matches the type. Otherwise, it returns <computeroutput>0</computeroutput>.
If <emphasis role="italic">string</emphasis> is null, the function returns
<computeroutput>0</computeroutput> (except when the
<emphasis role="italic">type</emphasis> is <computeroutput>X</computeroutput>
or <computeroutput>B</computeroutput>, for which DATATYPE returns
<computeroutput>1</computeroutput> for a null
string). The following are valid <emphasis role="italic">type</emphasis>s.
(Only the capitalized letter,
or the number of the last type listed, is needed; all characters surrounding
it are ignored. Note that for the <computeroutput>hexadecimal</computeroutput>
option, you must start your string specifying the name of the option with
<computeroutput>x</computeroutput> rather
than <computeroutput>h</computeroutput>.)</para>
<variablelist>
<varlistentry><term>Alphanumeric</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<emphasis role="italic">string</emphasis> contains only characters from
the ranges <computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>,
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>,
and <computeroutput>0</computeroutput>-<computeroutput>9</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Binary</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<emphasis role="italic">string</emphasis> contains only the characters
<computeroutput>0</computeroutput> or <computeroutput>1</computeroutput>, or
whitespace. Whitespace characters can appear only between groups of 4 binary
characters. It also returns
<computeroutput>1</computeroutput> if
<emphasis role="italic">string</emphasis> is
a null string, which is a valid binary string.
</para></listitem></varlistentry>
<varlistentry><term>Lowercase</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<emphasis role="italic">string</emphasis> contains only characters from
the range <computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Mixed case</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<emphasis role="italic">string</emphasis> contains only characters from
the ranges <computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>
and <computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Number</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<computeroutput>DATATYPE(string)</computeroutput> returns
<computeroutput>NUM</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>lOgical</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
the string is exactly "0" or "1". Otherwise it returns
<computeroutput>0</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Symbol</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<emphasis role="italic">string</emphasis> is a valid symbol, that is,
if <computeroutput>SYMBOL(string)</computeroutput> does not return
<computeroutput>BAD</computeroutput>. (See
<xref linkend="xsymbol" />.)
Note that both uppercase and lowercase alphabetics are
permitted.
</para></listitem></varlistentry>
<varlistentry><term>Uppercase</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<emphasis role="italic">string</emphasis> contains only characters from
the range <computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Variable</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<emphasis role="italic">string</emphasis> could appear on the left-hand
side of an assignment without causing a SYNTAX condition.
</para></listitem></varlistentry>
<varlistentry><term>Whole number</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<emphasis role="italic">string</emphasis> is a Rexx whole number under
the current setting of NUMERIC DIGITS.
</para></listitem></varlistentry>
<varlistentry><term>heXadecimal</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<emphasis role="italic">string</emphasis> contains only characters from
the ranges <computeroutput>a</computeroutput>-<computeroutput>f</computeroutput>,
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput>,
<computeroutput>0</computeroutput>-<computeroutput>9</computeroutput>, and
whitespace (as long as the whitespace characters appear only between pairs of
hexadecimal characters). It also returns
<computeroutput>1</computeroutput> if <emphasis role="italic">string</emphasis>
is a null string, which is a valid hexadecimal string.
</para></listitem></varlistentry>
<varlistentry><term>9 digits</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<computeroutput>DATATYPE(string,"W")</computeroutput> returns
<computeroutput>1</computeroutput> when NUMERIC DIGITS is set to
<computeroutput>9</computeroutput>.
</para></listitem></varlistentry>
</variablelist>
<para>Here are some examples:</para>
<indexterm><primary>DATATYPE function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>DATATYPE function</secondary></indexterm>
<example id="ex.bif-datatype">
<title>Builtin function DATATYPE</title>
<programlisting>
DATATYPE(" 12 ")         ->   "NUM"
DATATYPE("")             ->   "CHAR"
DATATYPE("123*")         ->   "CHAR"
DATATYPE("12.3","N")     ->    1
DATATYPE("12.3","W")     ->    0
DATATYPE("Fred","M")     ->    1
DATATYPE("Fred","U")     ->    0
DATATYPE("Fred","L")     ->    0
DATATYPE("?20K","s")     ->    1
DATATYPE("BCd3","X")     ->    1
DATATYPE("BC d3","X")    ->    1
DATATYPE("1","O")        ->    1
DATATYPE("11,"O")        ->    0
</programlisting>
</example>

<note><title>Note</title>
<para>The DATATYPE function tests the meaning or type of characters in a string,
independent of the encoding of those characters (for example, ASCII or EBCDIC).
</para></note>
</section>


<section id="bifDate"><title>DATE</title>
<indexterm><primary>DATE function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>DATE</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>DATE</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/date.svg" scale="50" />
</imageobject>
</mediaobject>
<para>
 </para>
<para>Returns, by default, the local date in the format:
<emphasis role="italic">dd mon yyyy</emphasis> (day
month year--for example, <computeroutput>13 Nov 1998</computeroutput>),
with no leading zero or blank on the day. The first three characters of the
English name of the month are used.</para>
<para>You can use the following
<emphasis role="italic">option</emphasis>s to obtain specific formats.
(Only the capitalized letter is needed; all characters following it are ignored.)
</para>
<variablelist>
<varlistentry><term>Base
<indexterm><primary>Base option of DATE function</primary></indexterm>
</term>
<listitem><para>returns the number of complete days (that is, not including the
current day) since and including the base date, 1 January 0001, in the format:
<emphasis role="italic">dddddd</emphasis> (no leading zeros or whitespace). The
expression <computeroutput>DATE("B")//7</computeroutput> returns a number in the
range
<computeroutput>0</computeroutput>-<computeroutput>6</computeroutput> that
corresponds to the current day of the week, where
<computeroutput>0</computeroutput> is Monday and
<computeroutput>6</computeroutput> is Sunday.
</para>

<note><title>Note</title>
<para>The base date of 1 January 0001 is determined
by extending the current Gregorian calendar backward (365 days each year,
with an extra day every year that is divisible by 4 except century years that
are not divisible by 400). It does not take into account any errors in the calendar
system that created the Gregorian calendar originally.</para></note>
</listitem></varlistentry>
<varlistentry><term>Days
<indexterm><primary>Days option of DATE function</primary></indexterm>
</term>
<listitem><para>returns the number of days, including the current day, that have passed
this year in the format <emphasis role="italic">ddd</emphasis>
(no leading zeros or whitespace).
</para></listitem></varlistentry>
<varlistentry><term>European
<indexterm><primary>European option of DATE function</primary></indexterm>
</term>
<listitem><para>returns the date in the format dd/mm/yy.
</para></listitem></varlistentry>
<varlistentry><term>Full
<indexterm><primary>Full option of DATE function</primary></indexterm>
</term>
<listitem><para>returns the number of microseconds
since 00:00:00.000000 on 1 January 0001, in the format:
<emphasis role="italic">dddddddddddddddddd</emphasis> (no leading zeros or
whitespace).
</para>
<note><title>Notes</title>
<para>The base date of 1 January 0001 is determined
by extending the current Gregorian calendar backward (365 days each year,
with an extra day every year that is divisible by 4 except century years that
are not divisible by 400). It does not take into account any errors in the calendar
system that created the Gregorian calendar originally.</para>
<para>The value returned by Date('F') can be used to calculate the interval between
any two dates.  Note, however, that values returned generally contain more digits
than the default NUMERIC DIGITS setting.  The NUMERIC DIGITS setting should be increased
to a minimum value of 18 when performing timestamp arithmetic.</para>
</note>
</listitem></varlistentry>
<varlistentry><term>Language
<indexterm><primary>Language (local) option of DATE function</primary></indexterm>
</term>
<listitem><para>returns the date in an implementation- and language-dependent, or local,
date format. The format is <emphasis role="italic">dd month yyyy</emphasis>.
The name of the month is according to the national language installed on the
system. If no local date format is available, the default format is returned.

<note><title>Note</title>
<para>This
format is intended to be used as a whole; Rexx programs must not make any
assumptions about the form or content of the returned string.</para></note>
</para></listitem></varlistentry>
<varlistentry><term>Month
<indexterm><primary>Month option of DATE function</primary></indexterm>
</term>
<listitem><para>returns the full English name of the current month, for example,
<computeroutput>August</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Normal
<indexterm><primary>Normal option of DATE function</primary></indexterm>
</term>
<listitem><para>returns the date in the format
<emphasis role="italic">dd mon yyyy</emphasis>. This is the default.
</para></listitem></varlistentry>
<varlistentry><term>Ordered
<indexterm><primary>Ordered option of DATE function</primary></indexterm>
</term>
<listitem><para>returns the date in the format
<emphasis role="italic">yy/mm/dd</emphasis> (suitable for sorting,
for example).
</para></listitem></varlistentry>
<varlistentry><term>Standard
<indexterm><primary>Standard option of DATE function</primary></indexterm>
</term>
<listitem><para>returns the date in the format
<emphasis role="italic">yyyymmdd</emphasis> (suitable for sorting,
for example).
</para></listitem></varlistentry>
<varlistentry><term>Ticks
<indexterm><primary>Ticks option of DATE function</primary></indexterm>
</term>
<listitem><para>returns the number of seconds
since 00:00:00.000000 on 1 January 1970, in the format:
<emphasis role="italic">dddddddddddd</emphasis> (no leading zeros or
whitespace).
</para>
<note><title>Notes</title>
<para>The base date of 1 January 1970 is determined
by extending the current Gregorian calendar backward (365 days each year,
with an extra day every year that is divisible by 4 except century years that
are not divisible by 400). It does not take into account any errors in the calendar
system that created the Gregorian calendar originally.</para>
<para>The value returned by Date('T') can be used to calculate the interval between
any two dates.  Note, however, that values returned generally contain more digits
than the default NUMERIC DIGITS setting.  The NUMERIC DIGITS setting should be increased
to a minimum value of 12 when performing timestamp arithmetic.</para>
<para>Date('T') will return a negative number for dates prior to 1 January 1970.</para>
</note>
</listitem></varlistentry>
<varlistentry><term>Usa
<indexterm><primary>Usa option of DATE function</primary></indexterm>
</term>
<listitem><para>returns the date in the format
<emphasis role="italic">mm/dd/yy</emphasis>.
</para></listitem></varlistentry>
<varlistentry><term>Weekday
<indexterm><primary>Weekday option of DATE function</primary></indexterm>
</term>
<listitem><para>returns the English name for the day of the week, in mixed case, for
example, <computeroutput>Tuesday</computeroutput>.
</para></listitem></varlistentry>
</variablelist>
<para>Here are some examples, assuming today is 13 November 1996:</para>
<indexterm><primary>DATE function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>DATE function</secondary></indexterm>
<example id="ex.bif-date">
<title>Builtin function DATE</title>
<programlisting>
DATE()         ->    "13 Nov 1996"
DATE("B")      ->    728975
DATE("D")      ->    318
DATE("E")      ->    "13/11/96"
DATE("L")      ->    "13 November 1996"
DATE("M")      ->    "November"
DATE("N")      ->    "13 Nov 1996"
DATE("O")      ->    "96/11/13"
DATE("S")      ->    "19961113"
DATE("U")      ->    "11/13/96"
DATE("W")      ->    "Wednesday"
</programlisting>
</example>

<note><title>Note</title>
<para>The first call to DATE or TIME in one clause causes a time
stamp to be made that is then used for all calls to
these functions in that clause. Therefore, several calls to any of the DATE
or TIME functions, or both, in a single expression or clause are consistent
with each other.</para></note>
<para>If you specify <emphasis role="italic">string</emphasis>, DATE returns
the date corresponding to <emphasis role="italic">string</emphasis>
in the format <emphasis role="italic">option</emphasis>. The
<emphasis role="italic">string</emphasis> must be supplied
in the format <emphasis role="italic">option2</emphasis>. The
<emphasis role="italic">option2</emphasis> format must specify day,
month, and year (that is, not "D", "L", "M", or "W").
The default for <emphasis role="italic">option2</emphasis> is "N", so you need
to specify <emphasis role="italic">option2</emphasis> if
<emphasis role="italic">string</emphasis> is not in the Normal
format. Here are some examples: </para>
<example id="ex.bif-date-1">
<title>Builtin function DATE set</title>
<programlisting>
DATE("O","13 Feb 1923")     ->    "23/02/13"
DATE("O","06/01/50","U")    ->    "50/06/01"
DATE("N", "63326132161828000", "f")   -> "23 Sep 2007"
</programlisting>
</example>
<para>If you specify an output separator character
<emphasis role="italic">osep</emphasis>, the
days, month, and year returned are separated by this character. Any nonalphanumeric
character or an empty string can be used. A separator character is only valid
for the formats "E", "N", "O", "S", and "U".
Here are some examples:</para>
<example id="ex.bif-date-2">
<title>Builtin function DATE set</title>
<programlisting>
DATE("S","13 Feb 1996","N","-")     ->    "1996-02-13"
DATE("N","13 Feb 1996","N","")      ->    "13Feb1996"
DATE("N","13 Feb 1996","N","-")     ->    "13-Feb-1996"
DATE("O","06/01/50","U","")         ->    "500601"
DATE("E","02/13/96","U",".")        ->    "13.02.96"
DATE("N", , ,"_")                   ->    "26_Mar_1998"  (today)
</programlisting>
</example>
<para>In this way, formats can be created that are derived from their
respective default format, which is the format associated with
<emphasis role="italic">option</emphasis> using its default separator character.
The default separator character for each of these formats is:</para>
<programlisting>
Option       Default separator

European     "/"
Normal       " "
Ordered      "/"
Standard     ""  (empty string)
Usa          "/"
</programlisting>
<para>If you specify a <emphasis role="italic">string</emphasis>
containing a separator that is different from the default separator character of
<emphasis role="italic">option2</emphasis>, you must also specify
<emphasis role="italic">isep</emphasis> to indicate which separator character
is valid for <emphasis role="italic">string</emphasis>. Basically,
any date format that can be generated with
any valid separator character can be used as input date
<emphasis role="italic">string</emphasis> as
long as its format has the generalized form specified by
<emphasis role="italic">option2</emphasis> and
its separator character matches the character specified by
<emphasis role="italic">isep</emphasis>.</para>
<para>Here are some examples:</para>
<example id="ex.bif-date-3">
<title>Builtin function DATE set</title>
<programlisting>
DATE("S","1996-11-13","S","","-")      ->    "19961113"
DATE("S","13-Nov-1996","N","","-")     ->    "19961113"
DATE("O","06*01*50","U","","*")        ->    "500601"
DATE("U","13.Feb.1996","N", ,".")      ->    "02/13/96"
</programlisting>
</example>
<para>You can determine the number of days between two dates; for example:</para>
<example id="ex.bif-date-4">
<title>Builtin function DATE days</title>
<programlisting>
say date("B","12/25/96","U")-date("B") " shopping days till Christmas!"
</programlisting>
</example>
<para>If <emphasis role="italic">string</emphasis> does not include the
century but <emphasis role="italic">option</emphasis> defines that the
century be returned as part of the date, the century
is determined depending on whether the year to be returned is within the past
50 years or the next 49 years. Assume, for example, that you specify 10/15/43
for <emphasis role="italic">string</emphasis> and today's date is 10/27/1998. In this case, 1943
would be 55 years ago and 2043 would be 45 years in the future. So, 10/15/2043
would be the returned date.</para>

<note><title>Note</title>
<para>This rule is suitable for dates
that are close to today's date. However, when working with birth dates,
it is recommended that you explicitly provide the century.</para></note>
<para>When requesting dates to be converted to Full format or Ticks format, a time value
of "00:00:00.000000" is used for the conversion.
A time stamp for a time and date combination can be created by
combining a value from Time() for the time of day.</para>
<example id="ex.bif-date-5">
<title>Builtin function DATE timestamp</title>
<programlisting>
    numeric digits 18  -- needed to add the timestamps
    timestamp = date('f, '20072301', 'S') + time('f', '08:14:22', 'N')
</programlisting>
</example>
</section>

<section id="bifDelstr"><title>DELSTR (Delete String)</title>
<indexterm><primary>DELSTR function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>DELSTR</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>DELSTR</secondary></indexterm>
<indexterm><primary>deleting</primary>
<secondary>part of a string</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>deleting part, DELSTR function</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/delstr.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns <emphasis role="italic">string</emphasis> after deleting the
substring that begins at the <emphasis role="italic">n</emphasis>th character
and is of <emphasis role="italic">length</emphasis> characters. If you omit
<emphasis role="italic">length</emphasis>, or if
<emphasis role="italic">length</emphasis> is greater than the number of
characters from <emphasis role="italic">n</emphasis> to the end of
<emphasis role="italic">string</emphasis>, the function deletes the rest
of <emphasis role="italic">string</emphasis> (including the
<emphasis role="italic">n</emphasis>th character). The
<emphasis role="italic">length</emphasis> must be a positive whole number or
zero. <emphasis role="italic">n</emphasis> must be a positive
whole number. If <emphasis role="italic">n</emphasis> is greater than the
length of <emphasis role="italic">string</emphasis>,
the function returns <emphasis role="italic">string</emphasis> unchanged.</para>
<para>Here are some examples:</para>
<indexterm><primary>DELSTR function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>DELSTR function</secondary></indexterm>
<example id="ex.bif-delstr">
<title>Builtin function DELSTR</title>
<programlisting>
DELSTR("abcd",3)       ->    "ab"
DELSTR("abcde",3,2)    ->    "abe"
DELSTR("abcde",6)      ->    "abcde"
</programlisting>
</example>
</section>


<section id="bifDelword"><title>DELWORD (Delete Word)</title>
<indexterm><primary>DELWORD function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>DELWORD</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>DELWORD</secondary></indexterm>
<indexterm><primary>deleting</primary>
<secondary>words from a string</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>deleting from a string</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/delword.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns <emphasis role="italic">string</emphasis> after deleting the
substring that starts at the <emphasis role="italic">n</emphasis>th word and
is of <emphasis role="italic">length</emphasis> whitespace-delimited words. If
you omit
<emphasis role="italic">length</emphasis>, or if
<emphasis role="italic">length</emphasis> is greater than the number of words
from <emphasis role="italic">n</emphasis> to the end of
<emphasis role="italic">string</emphasis>, the function deletes the remaining
words in <emphasis role="italic">string</emphasis> (including the
<emphasis role="italic">n</emphasis>th word). The
<emphasis role="italic">length</emphasis> must
be a positive whole number or zero. <emphasis role="italic">n</emphasis>
must be a positive whole number.
If <emphasis role="italic">n</emphasis> is greater than the number of words in
<emphasis role="italic">string</emphasis>, the function returns
<emphasis role="italic">string</emphasis> unchanged. The string deleted includes any
whitespace characters following the final word involved but none of the
whitespace preceding the first word involved.
</para>
<para>Here are some examples:</para>
<indexterm><primary>DELWORD function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>DELWORD function</secondary></indexterm>
<example id="ex.bif-delword">
<title>Builtin function DELWORD</title>
<programlisting>
DELWORD("Now is the  time",2,2)  ->  "Now time"
DELWORD("Now is the time ",3)    ->  "Now is "
DELWORD("Now is the  time",5)    ->  "Now is the  time"
DELWORD("Now is   the time",3,1) ->  "Now is   time"
DELWORD("Now is the  time",2,2)  ->  "Now time"
</programlisting>
</example>
</section>


<section id="bifDigits"><title>DIGITS</title>
<indexterm><primary>DIGITS function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>DIGITS</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>DIGITS</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/digits.svg" scale="50" />
</imageobject>
</mediaobject>
<para>
Returns the current setting
of NUMERIC DIGITS. See <xref linkend="keyNumeric" /> for more
information.</para>
<para>Here is an example:</para>
<indexterm><primary>DIGITS function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>DIGITS function</secondary></indexterm>
<example id="ex.bif-digits">
<title>Builtin function DIGITS</title>
<programlisting>
DIGITS()    ->    9      /* by default */
</programlisting>
</example>
</section>


<section id="bifDirectory"><title>DIRECTORY</title>
<indexterm><primary>DIRECTORY function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>DIRECTORY</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>DIRECTORY</secondary></indexterm>

<para></para>
<mediaobject>
<imageobject>
<imagedata fileref="images/bif/directory.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the current directory, changing it to
<emphasis role="italic">newdirectory</emphasis> if
an argument is supplied and the named directory exists. If
<emphasis role="italic">newdirectory</emphasis> is not specified, the name of
the current directory is returned.  Otherwise, an attempt is made to change to
the specified <emphasis role="italic">newdirectory</emphasis>. If successful,
the name of the <emphasis role="italic">newdirectory</emphasis> is returned;
if an error occurred, null is returned.</para>
<para>For example, the following program fragment saves the current directory
and switches to a new directory; it performs an operation there, and then
returns to the former directory. </para>
<indexterm><primary>DIRECTORY function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>DIRECTORY function</secondary></indexterm>
<example id="ex.bif-directory">
<title>Builtin function DIRECTORY</title>
<programlisting>
/* get current directory      */
curdir = directory()
/* go play a game             */
newdir = directory("/usr/games")    /* Linux type subdirectory */
if newdir = "/usr/games" then
  do
  fortune   /* tell a fortune */
/* return to former directory */
  call directory curdir
end
else
  say "Can&apos;t find /usr/games"
</programlisting>
</example>
</section>


<section id="bifEndlocal"><title>ENDLOCAL (Linux only)</title>
<indexterm><primary>ENDLOCAL function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>ENDLOCAL</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>ENDLOCAL</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/endlocal.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Restores the directory and environment variables in effect before the last
SETLOCAL (<xref linkend="bifSetlocal" />
function was run. If ENDLOCAL is not
included in a procedure, the initial environment saved by SETLOCAL is restored
upon exiting the procedure.</para>
<para>ENDLOCAL returns a value of 1 if the initial environment is successfully
restored and a value of 0 if no SETLOCAL was issued or the action is otherwise
unsuccessful.</para>
<para>Here is an example:</para>
<indexterm><primary>ENDLOCAL function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>ENDLOCAL function</secondary></indexterm>
<example id="ex.bif-endlocal">
<title>Builtin function ENDLOCAL</title>
<programlisting>
n = SETLOCAL()                   /* saves the current environment */
          /*
          The program can now change environment variables
          (with the VALUE function) and then work in the
          changed environment.
          */
n = ENDLOCAL()                   /* restores the initial environment */
</programlisting>
</example>
<para>For additional examples, see
<xref linkend="bifSetlocal" />.</para>
</section>


<section id="bifErrortext"><title>ERRORTEXT</title>
<indexterm><primary>ERRORTEXT function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>ERRORTEXT</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>ERRORTEXT</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/errortext.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the Rexx error message associated with error number
<emphasis role="italic">n</emphasis>.
<emphasis role="italic">n</emphasis> must be in the range
<computeroutput>0</computeroutput>-<computeroutput>99</computeroutput>.
It returns the null string if <emphasis role="italic">n</emphasis>
is in the allowed range but is not a defined Rexx error
number. See <xref linkend="errnum" /> for a
complete description of error numbers and messages.</para>
<para>Here are some examples:</para>
<indexterm><primary>ERRORTEXT function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>ERRORTEXT function</secondary></indexterm>
<example id="ex.bif-errortext">
<title>Builtin function ERRORTEXT</title>
<programlisting>
ERRORTEXT(16)    ->    "Label not found"
ERRORTEXT(60)    ->    ""
</programlisting>
</example>
</section>


<section id="bifFilespec"><title>FILESPEC</title>
<indexterm><primary>FILESPEC function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>FILESPEC</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>FILESPEC</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/filespec.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a selected element of <emphasis role="italic">filespec</emphasis>,
given file specification, identified by one of the following option strings:
</para>
<variablelist>
<varlistentry><term>Drive</term>
<listitem><para>The drive letter of the given filespec.  Only available on
Windows. On Unix, it returns a null string (&quot;&quot;).
</para></listitem></varlistentry>
<varlistentry><term>Path</term>
<listitem><para>The directory path of the given
<emphasis role="italic">filespec</emphasis>.
</para></listitem></varlistentry>
<varlistentry><term>Location</term>
<listitem><para>The full location portion of the given
<emphasis role="italic">filespec</emphasis>.  On Windows, this
will include both the Drive and Path information.  On other platforms,
this returns the same result as the Path option.
</para></listitem></varlistentry>
<varlistentry><term>Name</term>
<listitem><para>The file name of the given
<emphasis role="italic">filespec</emphasis>.
</para></listitem></varlistentry>
<varlistentry><term>Extension</term>
<listitem><para>The extension portion of the
<emphasis role="italic">filespec</emphasis> file name.
</para></listitem></varlistentry>
</variablelist>
<para>If <emphasis role="italic">filespec</emphasis> cannot find the requested
information, then the FILESPEC function returns a null string (&quot;&quot;).
</para>

<note><title>Note</title>
<para>Only the initial letter of option is needed.</para></note>
<para>Here are some Windows examples: </para>
<indexterm><primary>FILESPEC function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>FILESPEC function</secondary></indexterm>
<example id="ex.bif-filespec">
<title>Builtin function FILESPEC</title>
<programlisting>
thisfile = "C:\WINDOWS\UTIL\SYSTEM.INI"
say FILESPEC("drive",thisfile)     /* says "C:"              */
say FILESPEC("path",thisfile)      /* says "\WINDOWS\UTIL\"  */
say FILESPEC("location",thisfile)  /* says "C:\WINDOWS\UTIL\"  */
say FILESPEC("name",thisfile)      /* says "SYSTEM.INI"      */
say FILESPEC("extension",thisfile) /* says "INI"      */
part = "name"
say FILESPEC(part,thisfile)        /* says "SYSTEM.INI"      */
</programlisting>
</example>
</section>


<section id="bifForm"><title>FORM</title>
<indexterm><primary>FORM function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>FORM</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>FORM</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/form.svg" scale="50" />
</imageobject>
</mediaobject>
<para>
Returns the current setting of NUMERIC
FORM. See <xref linkend="keyNumeric" /> for more information.</para>
<para>Here is an example:</para>
<indexterm><primary>FORM function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>FORM function</secondary></indexterm>
<example id="ex.bif-form">
<title>Builtin function FORM</title>
<programlisting>
FORM()    ->    "SCIENTIFIC"  /* by default */
</programlisting>
</example>
</section>


<section id="bifFormat"><title>FORMAT</title>
<indexterm><primary>FORMAT function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>FORMAT</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>FORMAT</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>formatting numbers</secondary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>numbers for display</secondary></indexterm>
<indexterm><primary>numbers</primary>
<secondary>formatting for display</secondary></indexterm>
<indexterm><primary>numbers for display</primary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/format.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns <emphasis role="italic">number</emphasis>, rounded and formatted.
</para>
<para>The <emphasis role="italic">number</emphasis> is first rounded according
to standard Rexx rules, as though the operation
<computeroutput>number+0</computeroutput> had been carried out. The result
is precisely that of this operation if you specify only
<emphasis role="italic">number</emphasis>. If
you specify any other options, the <emphasis role="italic">number</emphasis>
is formatted as described in the following.</para>
<para>The <emphasis role="italic">before</emphasis> and
<emphasis role="italic">after</emphasis> options describe how many characters
are used for the integer and decimal parts of the result, respectively. If
you omit either or both of them, the number of characters used for that part
is as needed.</para>
<para>If <emphasis role="italic">before</emphasis> is not large enough to
contain the integer part of the number (plus the sign for a negative number),
an error results. If <emphasis role="italic">before</emphasis> is larger than
needed for that part, the number is padded on the left with blanks. If
<emphasis role="italic">after</emphasis> is not the same size as the decimal
part of the number, the number is rounded (or extended with zeros) to fit.
Specifying <computeroutput>0</computeroutput> causes the number to be rounded
to an integer.</para>
<para>Here are some examples:</para>
<indexterm><primary>FORMAT function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>FORMAT function</secondary></indexterm>
<example id="ex.bif-format">
<title>Builtin function FORMAT</title>
<programlisting>
FORMAT("3",4)            ->    "   3"
FORMAT("1.73",4,0)       ->    "   2"
FORMAT("1.73",4,3)       ->    "   1.730"
FORMAT("-.76",4,1)       ->    "  -0.8"
FORMAT("3.03",4)         ->    "   3.03"
FORMAT(" - 12.73", ,4)   ->    "-12.7300"
FORMAT(" - 12.73")       ->    "-12.73"
FORMAT("0.000")          ->    "0"
</programlisting>
</example>
<para>The first three arguments are as described previously.  In addition,
<emphasis role="italic">expp</emphasis> and
<emphasis role="italic">expt</emphasis> control the exponent part of the result, which,
by default, is formatted according to the current NUMERIC settings of DIGITS
and FORM. <emphasis role="italic">expp</emphasis> sets the number of places for
the exponent part; the default is to use as many as needed (which can be zero).
<emphasis role="italic">expt</emphasis> specifies
when the exponential expression is used. The default is the current setting
of NUMERIC DIGITS.</para>
<para>If <emphasis role="italic">expp</emphasis> is
<computeroutput>0</computeroutput>, the number is not in exponential notation.
If <emphasis role="italic">expp</emphasis> is not large enough to contain the
exponent, an error results.</para>
<para>If the number of places needed for the integer or decimal part exceeds
<emphasis role="italic">expt</emphasis> or twice
<emphasis role="italic">expt</emphasis>, respectively, the exponential notation
is used. If <emphasis role="italic">expt</emphasis> is
<computeroutput>0</computeroutput>, the exponential notation is always
used unless the exponent would be <computeroutput>0</computeroutput>. (If
<emphasis role="italic">expp</emphasis> is <computeroutput>0</computeroutput>,
this overrides a <computeroutput>0</computeroutput> value of
<emphasis role="italic">expt</emphasis>.) If the exponent
would be <computeroutput>0</computeroutput> when a nonzero
<emphasis role="italic">expp</emphasis> is specified, then
<emphasis role="italic">expp</emphasis>+2 blanks are supplied for the exponent
part of the result. If the exponent would be
<computeroutput>0</computeroutput> and <emphasis role="italic">expp</emphasis>
is not specified, the number is not an exponential expression.</para>
<para>Here are some examples: </para>
<example id="ex.bif-format-1">
<title>Builtin function FORMAT</title>
<programlisting>
FORMAT("12345.73", , ,2,2)  ->    "1.234573E+04"
FORMAT("12345.73", ,3, ,0)  ->    "1.235E+4"
FORMAT("1.234573", ,3, ,0)  ->    "1.235"
FORMAT("12345.73", , ,3,6)  ->    "12345.73"
FORMAT("1234567e5", ,3,0)   ->    "123456700000.000"
</programlisting>
</example>
</section>


<section id="bifFuzz"><title>FUZZ</title>
<indexterm><primary>FUZZ function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>FUZZ</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>FUZZ</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/fuzz.svg" scale="50" />
</imageobject>
</mediaobject>
<para>
Returns the current setting of NUMERIC
FUZZ. See <xref linkend="keyNumeric" /> for more information.</para>
<para>Here is an example:</para>
<indexterm><primary>FUZZ function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>FUZZ function</secondary></indexterm>
<example id="ex.bif-fuzz">
<title>Builtin function FUZZ</title>
<programlisting>
FUZZ()    ->    0     /* by default */
</programlisting>
</example>
</section>


<section id="bifInsert"><title>INSERT</title>
<indexterm><primary>INSERT function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>INSERT</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>INSERT</secondary></indexterm>
<indexterm><primary>inserting a string into another</primary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/insert.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Inserts the string <emphasis role="italic">new</emphasis>, padded or
truncated to length <emphasis role="italic">length</emphasis>, into the string
<emphasis role="italic">target</emphasis> after the
<emphasis role="italic">n</emphasis>th character. The default value for
<emphasis role="italic">n</emphasis> is <computeroutput>0</computeroutput>,
which means insertion before the beginning of the string. If specified,
<emphasis role="italic">n</emphasis> and
<emphasis role="italic">length</emphasis> must be positive whole numbers or
zero. If <emphasis role="italic">n</emphasis> is greater
than the length of the target string, the string
<emphasis role="italic">new</emphasis> is padded at
the beginning. The default value for <emphasis role="italic">length</emphasis>
is the length of <emphasis role="italic">new</emphasis>. If
<emphasis role="italic">length</emphasis> is less than the length of the
string <emphasis role="italic">new</emphasis>, then INSERT truncates
<emphasis role="italic">new</emphasis> to length
<emphasis role="italic">length</emphasis>. The default
<emphasis role="italic">pad</emphasis> character is a blank.</para>
<para>Here are some examples:</para>
<indexterm><primary>INSERT function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>INSERT function</secondary></indexterm>
<example id="ex.bif-insert">
<title>Builtin function INSERT</title>
<programlisting>
INSERT(" ","abcdef",3)         ->    "abc def"
INSERT("123","abc",5,6)        ->    "abc  123   "
INSERT("123","abc",5,6,"+")    ->    "abc++123+++"
INSERT("123","abc")            ->    "123abc"
INSERT("123","abc", ,5,"-")    ->    "123--abc"
</programlisting>
</example>
</section>


<section id="bifLastpos"><title>LASTPOS (Last Position)</title>
<indexterm><primary>LASTPOS function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>LASTPOS</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>LASTPOS</secondary></indexterm>
<indexterm><primary>position</primary>
<secondary>last occurrence of a string</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/lastpos.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the position of the last occurrence of one string,
<emphasis role="italic">needle</emphasis>,
in another, <emphasis role="italic">haystack</emphasis>. (See also
<xref linkend="bifPos" />.) It returns
<computeroutput>0</computeroutput> if <emphasis role="italic">needle</emphasis>
is a null string or not found. By default, the
search starts at the last character of
<emphasis role="italic">haystack</emphasis> and scans backward to the
beginning of the string.  You can
override this by specifying
<emphasis role="italic">start</emphasis>, the point at which the
backward scan starts and <emphasis role="italic">length</emphasis>, the range of
characters to scan.  The
<emphasis role="italic">start</emphasis> must be a positive whole number and
defaults to <computeroutput>receiving_string~length</computeroutput> if larger than that
value or omitted.
The <emphasis role="italic">length</emphasis> must be a non-negative whole
number and defaults to <emphasis role="italic">start</emphasis>.
</para>
<para>Here are some examples:</para>
<indexterm><primary>LASTPOS function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>LASTPOS function</secondary></indexterm>
<example id="ex.bif-lastpos">
<title>Builtin function LASTPOS</title>
<programlisting>
LASTPOS(" ","abc def ghi")      ->    8
LASTPOS(" ","abcdefghi")        ->    0
LASTPOS("xy","efgxyz")          ->    4
LASTPOS(" ","abc def ghi",7)    ->    4
LASTPOS(" ","abc def ghi",7,3)  ->    0
</programlisting>
</example>
</section>


<section id="bifLeft"><title>LEFT</title>
<indexterm><primary>LEFT function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>LEFT</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>LEFT</secondary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text left justification</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/left.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a string of length <emphasis role="italic">length</emphasis>,
containing the leftmost <emphasis role="italic">length</emphasis> characters
of <emphasis role="italic">string</emphasis>. The string returned is padded
with <emphasis role="italic">pad</emphasis> characters, or truncated, on the
right as needed. The default <emphasis role="italic">pad</emphasis> character
is a blank. <emphasis role="italic">length</emphasis> must be a positive
whole number or zero. The LEFT function is exactly equivalent to:
</para>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/left_xmp.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Here are some examples:</para>
<indexterm><primary>LEFT function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>LEFT function</secondary></indexterm>
<example id="ex.bif-left">
<title>Builtin function LEFT</title>
<programlisting>
LEFT("abc d",8)        ->    "abc d   "
LEFT("abc d",8,".")    ->    "abc d..."
LEFT("abc  def",7)     ->    "abc  de"
</programlisting>
</example>
</section>


<section id="bifLength"><title>LENGTH</title>
<indexterm><primary>LENGTH function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>LENGTH</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>LENGTH</secondary></indexterm>
<indexterm><primary>finding</primary>
<secondary>string length</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>finding length of</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/length.svg" scale="50" />
</imageobject>
</mediaobject>
<para>
Returns the length of <emphasis role="italic">string</emphasis>.</para>
<para>Here are some examples:</para>
<indexterm><primary>LENGTH function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>LENGTH function</secondary></indexterm>
<example id="ex.bif-length">
<title>Builtin function LENGTH</title>
<programlisting>
LENGTH("abcdefgh")    ->    8
LENGTH("abc defg")    ->    8
LENGTH("")            ->    0
</programlisting>
</example>
</section>


<section id="bifLinein"><title>LINEIN (Line Input)</title>
<indexterm><primary>LINEIN function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>LINEIN</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>LINEIN</secondary></indexterm>
<indexterm><primary>input and output</primary>
<secondary>functions</secondary>
<tertiary>LINEIN</tertiary></indexterm>
<indexterm><primary>LINES function</primary>
<secondary>from stream</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/linein.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns <emphasis role="italic">count</emphasis> lines read from the
character input stream <emphasis role="italic">name</emphasis>. The
<emphasis role="italic">count</emphasis> must be
<computeroutput>1</computeroutput> or <computeroutput>0</computeroutput>
(To understand the input and output functions, see
<xref linkend="iostrms" />.) If you omit
<emphasis role="italic">name</emphasis>, the line is read from the default
input stream, STDIN. The default <emphasis role="italic">count</emphasis> is
<computeroutput>1</computeroutput>.</para>
<para>For persistent streams, a read position is maintained for each stream.
Any read from the stream starts at the current read position by default. Under
certain circumstances, a call to LINEIN returns a partial line. This can happen
if the stream has already been read with the CHARIN function, and part but
not all of a line (and its termination, if any) has already been read. When
the language processor completes reading, the read position is moved to the
beginning of the next line.</para>
<para>A <emphasis role="italic">line</emphasis> number may be given to set
the read position to the start
of a specified line. This line number must be positive and within the bounds
of the stream, and must not be specified for a transient stream. The read
position can be set to the beginning of the stream by giving
<emphasis role="italic">line</emphasis> a
value of <computeroutput>1</computeroutput>.</para>
<para>If you give a <emphasis role="italic">count</emphasis> of
<computeroutput>0</computeroutput>, then no characters are read
and a null string is returned.</para>
<para>For transient streams, if a complete line is not available in the stream,
then execution of the program usually stops until the line is complete. If,
however, it is impossible for a line to be completed because of an error or
another problem, the NOTREADY condition is raised (see
<xref linkend="stmerr" />)
and LINEIN returns whatever characters are available.</para>
<para>Here are some examples:</para>
<indexterm><primary>LINEIN function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>LINEIN function</secondary></indexterm>
<example id="ex.bif-linein">
<title>Builtin function LINEIN</title>
<programlisting>
LINEIN()                             /* Reads one line from the    */
                                     /* default input stream;      */
                                     /* usually this is an entry   */
                                     /* typed at the keyboard      */
myfile = "ANYFILE.TXT"
LINEIN(myfile)     -> "Current line" /* Reads one line from        */
                                     /* ANYFILE.TXT, beginning     */
                                     /* at the current read        */
                                     /* position. (If first call,  */
                                     /* file is opened and the     */
                                     /* first line is read.)       */

LINEIN(myfile,1,1) ->  "first line"  /* Opens and reads the first  */
                                     /* line of ANYFILE.TXT (if    */
                                     /* the file is already open,  */
                                     /* reads first line); sets    */
                                     /* read position on the       */
                                     /* second line.               */

LINEIN(myfile,1,0) ->  ""            /* No read; opens ANYFILE.TXT */
                                     /* (if file is already open,  */
                                     /* sets the read position to  */
                                     /* the first line).           */

LINEIN(myfile, ,0)  ->  ""           /* No read; opens ANYFILE.TXT */
                                     /* (no action if the file is  */
                                     /* already open).             */

LINEIN("QUEUE:")   ->  "Queue line" /* Read a line from the queue. */
                                    /* If the queue is empty, the  */
                                    /* program waits until a line  */
                                    /* is put on the queue.        */
</programlisting>
</example>

<note><title>Note</title>
<para>If you want to read complete lines from the default input
stream, as in a dialog with a user, use the PULL or PARSE PULL instruction.
</para></note>
<para>The PARSE LINEIN instruction is also useful in certain cases. (See
<xref linkend="parlini" />.)</para>
</section>


<section id="bifLineout"><title>LINEOUT (Line Output)</title>
<indexterm><primary>LINEOUT function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>LINEOUT</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>LINEOUT</secondary></indexterm>
<indexterm><primary>input and output</primary>
<secondary>functions</secondary>
<tertiary>LINEOUT</tertiary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/lineout.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns <computeroutput>0</computeroutput> if successful in writing
<emphasis role="italic">string</emphasis> to the character
output stream <emphasis role="italic">name</emphasis>, or
<computeroutput>1</computeroutput> if an error occurs while writing
the line. (To understand the input and output functions, see
<xref linkend="iostrms" />.)
If you omit <emphasis role="italic">string</emphasis> but include
<emphasis role="italic">line</emphasis>, only the write position
is repositioned. If <emphasis role="italic">string</emphasis> is a null string,
LINEOUT repositions the write position (if you include
<emphasis role="italic">line</emphasis>) and does a carriage return.
Otherwise, the stream is closed. LINEOUT adds a line-feed and a carriage-return
character to the end of <emphasis role="italic">string</emphasis>.</para>
<para>If you omit <emphasis role="italic">name</emphasis>, the line is written
to the default output stream STDOUT (usually the display).</para>
<para>For persistent streams, a write position is maintained for each stream.
Any write to the stream starts at the current write position by default. (Under
certain circumstances the characters written by a call to LINEOUT can be added
to a partial line previously written to the stream with the CHAROUT routine.
 LINEOUT stops a line at the end of each call.) When
the language processor completes writing, the write position is set to the
beginning of the line following the one just written. When the stream is first
opened, the write position is at the end of the stream, so that calls to LINEOUT
append lines to the end of the stream.</para>
<para>You can specify a <emphasis role="italic">line</emphasis>
number to set the write position to the
start of a particular line in a persistent stream. This line number must be
positive and within the bounds of the stream unless it is a binary stream
(though it can specify the line number immediately after the end of the stream).
A value of <computeroutput>1</computeroutput> for
<emphasis role="italic">line</emphasis> refers to the first line in the
stream. Note that, unlike CHAROUT, you cannot specify a position beyond the
end of the stream for non-binary streams.</para>
<para>You can omit the <emphasis role="italic">string</emphasis> for persistent
streams. If you specify <emphasis role="italic">line</emphasis>, the write
position is set to the start of the <emphasis role="italic">line</emphasis> that
was given, nothing is written to the stream, and the function returns
<computeroutput>0</computeroutput>. If you specify neither
<emphasis role="italic">line</emphasis> nor
<emphasis role="italic">string</emphasis>, the stream
is closed. Again, the function returns <computeroutput>0</computeroutput>.</para>
<para>Execution of the program usually stops until the output operation is effectively
complete. For example, when data is sent to a printer, the system accepts
the data and returns control to Rexx, even though the output data might not
have been printed.  Rexx considers this to be complete, even though the data
has not been printed. If, however, it is impossible for a line to be written,
the NOTREADY condition is raised (see
<xref linkend="stmerr" />), and LINEOUT
returns a result of <computeroutput>1</computeroutput>, that is, the residual
count of lines written.</para>
<para>Here are some examples:</para>
<indexterm><primary>LINEOUT function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>LINEOUT function</secondary></indexterm>
<example id="ex.bif-lineout">
<title>Builtin function LINEOUT</title>
<programlisting>
LINEOUT(,"Display this")          /* Writes string to the default   */
                                  /* output stream (usually, the    */
                                  /* display); returns 0 if         */
                                  /* successful                     */

myfile = "ANYFILE.TXT"
LINEOUT(myfile,"A new line")      /* Opens the file ANYFILE.TXT and */
                                  /* appends the string to the end. */
                                  /* If the file is already open,   */
                                  /* the string is written at the   */
                                  /* current write position.        */
                                  /* Returns 0 if successful.       */

LINEOUT(myfile,"A new start",1)   /* Opens the file (if not already */
                                  /* open); overwrites first line   */
                                  /* with a new line.               */
                                  /* Returns 0 if successful.       */

LINEOUT(myfile, ,1)               /* Opens the file (if not already */
                                  /* open). No write; sets write    */
                                  /* position at first character.   */

LINEOUT(myfile)                   /* Closes ANYFILE.TXT             */
</programlisting>
</example>
<para> LINEOUT is often most useful when called as a subroutine. The return
value is then available in the variable RESULT. For example: </para>
<example id="ex.bif-lineout-1">
<title>Builtin function LINEOUT call</title>
<programlisting>
Call LINEOUT "A:rexx.bat","Shell",1
Call LINEOUT ,"Hello"
</programlisting>
</example>

<note><title>Note</title>
<para>If the lines are to be written
to the default output stream without the possibility of error, use the SAY
instruction instead.</para></note>
</section>


<section id="bifLines"><title>LINES (Lines Remaining)</title>
<indexterm><primary>LINES function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>LINES function</primary>
<secondary>remaining in stream</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>LINES</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>LINES</secondary></indexterm>
<indexterm><primary>input and output</primary>
<secondary>functions</secondary>
<tertiary>LINES</tertiary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/lines.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns <computeroutput>1</computeroutput> if any data remains between
the current read position and the end of the character input stream
<emphasis role="italic">name</emphasis>. It returns
<computeroutput>0</computeroutput> if no data remains. In effect, LINES reports
whether a read action that CHARIN (see
<xref linkend="bifCharin" />) or LINEIN (see
<xref linkend="bifLinein" />)
performs will succeed. (To understand the input and output functions, see
<xref linkend="iostrms" />.)</para>

<para>The ANSI Standard has extended this function to allow an option: "Count".
If this option is used, LINES returns the actual number of complete
lines remaining in the stream, irrespective of how long this operation takes.</para>

<para>The option "Normal" returns 1 if there is at least one complete line
remaining in the file or 0 if no lines remain.</para>

<para>The default is "Normal".</para>

<para>Here are some examples:</para>
<indexterm><primary>LINES function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>LINES function</secondary></indexterm>
<example id="ex.bif-lines">
<title>Builtin function LINES</title>
<programlisting>
LINES(myfile)    ->    0    /* at end of the file   */
LINES()          ->    1    /* data remains in the  */
                            /* default input stream */
                            /* STDIN:               */
</programlisting>
</example>

<note><title>Note</title>
<para>The CHARS function returns the number of characters in a persistent stream
or the presence of data in a transient stream.</para></note>
</section>


<section id="bifLower"><title>LOWER</title>
<indexterm><primary>LOWER function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>LOWER</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>LOWER</secondary></indexterm>
<indexterm><primary>character</primary>
<secondary>lowercasing using LOWER function</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>lowercasing using LOWER function</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/lower.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a new string with the characters of <emphasis role="italic">string</emphasis> beginning with
character <emphasis role="italic">n</emphasis> for <emphasis role="italic">length</emphasis>
characters converted to lowercase.  If <emphasis role="italic">n</emphasis> is specified, it must
be a positive whole number.  If <emphasis role="italic">n</emphasis> is not specified, the case
conversion will start with the first character.  If <emphasis role="italic">length</emphasis>
is specified, it must be a non-negative whole number.  If <emphasis role="italic">length</emphasis>
is not specified, the default is to convert the remainder of the string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>lower function</secondary></indexterm>
<example id="ex.bif-lower">
<title>Builtin function LOWER</title>
<programlisting>
lower("Albert Einstein")      ->    "albert einstein"
lower("ABCDEF", 4)            ->    "ABCdef"
lower("ABCDEF", 3, 2)         ->    "ABcdEF"
</programlisting>
</example>
</section>


<section id="bifMax"><title>MAX (Maximum)</title>
<indexterm><primary>MAX function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>MAX</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>MAX</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/max.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the largest number of the list specified, formatted according to
the current NUMERIC settings. You can specify any number of
<emphasis role="italic">number</emphasis>s.</para>
<para>Here are some examples:</para>
<indexterm><primary>MAX function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>MAX function</secondary></indexterm>
<example id="ex.bif-max">
<title>Builtin function MAX</title>
<programlisting>
MAX(12,6,7,9)                                                ->    12
MAX(17.3,19,17.03)                                           ->    19
MAX(-7,-3,-4.3)                                              ->    -3
MAX(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)   ->    21
</programlisting>
</example>
</section>


<section id="bifMin"><title>MIN (Minimum)</title>
<indexterm><primary>MIN function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>MIN</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>MIN</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/min.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the smallest number of the list specified, formatted according
to the current NUMERIC settings. You can specify any number of
<emphasis role="italic">number</emphasis>s.</para>
<para>Here are some examples:</para>
<indexterm><primary>MIN function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>MIN function</secondary></indexterm>
<example id="ex.bif-min">
<title>Builtin function MIN</title>
<programlisting>
MIN(12,6,7,9)                                                ->   6
MIN(17.3,19,17.03)                                           ->  17.03
MIN(-7,-3,-4.3)                                              ->  -7
MIN(21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1)   ->   1
</programlisting>
</example>
</section>


<section id="bifOverlay"><title>OVERLAY</title>
<indexterm><primary>OVERLAY function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>OVERLAY</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>OVERLAY</secondary></indexterm>
<indexterm><primary>overlaying a string onto another</primary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/overlay.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the string <emphasis role="italic">target</emphasis>,
which, starting at the <emphasis role="italic">n</emphasis>th character,
is overlaid with the string <emphasis role="italic">new</emphasis>, padded
or truncated to length <emphasis role="italic">length</emphasis>. The overlay
may extend beyond the end of the original
<emphasis role="italic">target</emphasis> string. If you specify
<emphasis role="italic">length</emphasis>,
it must be a positive whole number or zero. The default value for
<emphasis role="italic">length</emphasis> is the length of
<emphasis role="italic">new</emphasis>. If <emphasis role="italic">n</emphasis>
is greater than the length of the target string, the string
<emphasis role="italic">new</emphasis> is padded at the beginning.
The default <emphasis role="italic">pad</emphasis> character is a blank, and
the default value for <emphasis role="italic">n</emphasis> is
<computeroutput>1</computeroutput>. If you specify
<emphasis role="italic">n</emphasis>, it must be a positive whole
number.</para>
<para>Here are some examples:</para>
<indexterm><primary>OVERLAY function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>OVERLAY function</secondary></indexterm>
<example id="ex.bif-overlay">
<title>Builtin function OVERLAY</title>
<programlisting>
OVERLAY(" ","abcdef",3)         ->    "ab def"
OVERLAY(".","abcdef",3,2)       ->    "ab. ef"
OVERLAY("qq","abcd")            ->    "qqcd"
OVERLAY("qq","abcd",4)          ->    "abcqq"
OVERLAY("123","abc",5,6,"+")    ->    "abc+123+++"
</programlisting>
</example>
</section>


<section id="bifPos"><title>POS (Position)</title>
<indexterm><primary>POS function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>POS</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>POS</secondary></indexterm>
<indexterm><primary>finding</primary>
<secondary>string in another string</secondary></indexterm>
<indexterm><primary>locating</primary>
<secondary>string in another string</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/pos.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the position of one string,
<emphasis role="italic">needle</emphasis>, in another,
<emphasis role="italic">haystack</emphasis>. (See also
<xref linkend="bifLastpos" />.) It returns
<computeroutput>0</computeroutput> if <emphasis role="italic">needle</emphasis>
is a null string or not found or if <emphasis role="italic">start</emphasis>
is greater than the length of <emphasis role="italic">haystack</emphasis>.
By default, the search starts at the first
character of the receiving string (that is, the value of
<emphasis role="italic">start</emphasis> is <computeroutput>1</computeroutput>),
and continues to the end of the string.  You can override this by specifying
<emphasis role="italic">start
</emphasis>, the point at which the search starts, and
<emphasis role="italic">length</emphasis>, the bounding limit for the search.
If specified, <emphasis role="italic">start</emphasis> must be a positive
whole number and <emphasis role="italic">length</emphasis> must be
a non-negative whole number.
</para>
<para>Here are some examples:</para>
<indexterm><primary>POS function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>POS function</secondary></indexterm>
<example id="ex.bif-pos">
<title>Builtin function POS</title>
<programlisting>
POS("day","Saturday")       ->    6
POS("x","abc def ghi")      ->    0
POS(" ","abc def ghi")      ->    4
POS(" ","abc def ghi",5)    ->    8
POS(" ","abc def ghi",5,3)  ->    0
</programlisting>
</example>
</section>


<section id="bifQualify"><title>QUALIFY</title>
<indexterm><primary>QUALIFY function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>QUALIFY</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>QUALIFY</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/qualify.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the a fully qualified file name for <emphasis role="italic">name</emphasis>.
Qualifying merely expands the file name into a name that includes directory information.
The file does not need to exist to generate the full name.
</para>
</section>

<section id="bifQueued"><title>QUEUED</title>
<indexterm><primary>QUEUED function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>QUEUED</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>QUEUED</secondary></indexterm>
<indexterm><primary>external data queue</primary>
<secondary>counting lines in</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/queued.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the number of lines remaining in the external data queue when the
function is called. (See <xref linkend="iostrms" />
for a discussion of Rexx input and output.)</para>
<para>Here is an example:</para>
<indexterm><primary>QUEUED function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>QUEUED function</secondary></indexterm>
<example id="ex.bif-queued">
<title>Builtin function QUEUED</title>
<programlisting>
QUEUED()    ->    5    /* Perhaps */
</programlisting>
</example>
</section>


<section id="bifRandom"><title>RANDOM</title>
<indexterm><primary>RANDOM function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>RANDOM</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>RANDOM</secondary></indexterm>
<indexterm><primary>pseudo random number RANDOM function</primary></indexterm>
<indexterm><primary>random number RANDOM function</primary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/random.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a quasi-random whole number in the range
<emphasis role="italic">min</emphasis> to
<emphasis role="italic">max</emphasis> inclusive. If you specify
<emphasis role="italic">max</emphasis> or
<emphasis role="italic">min,max</emphasis>, then
<emphasis role="italic">max</emphasis> minus
<emphasis role="italic">min</emphasis> cannot exceed 999999999.
<emphasis role="italic">min</emphasis> and
<emphasis role="italic">max</emphasis> default to
<computeroutput>0</computeroutput> and <computeroutput>999</computeroutput>,
respectively. To start a repeatable sequence of results, use a specific
<emphasis role="italic">seed</emphasis> as the third
argument. This
<emphasis role="italic">seed</emphasis> must be a positive whole number from
0 to 999999999.</para>
<para>Here are some examples:</para>
<indexterm><primary>RANDOM function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>RANDOM function</secondary></indexterm>
<example id="ex.bif-random">
<title>Builtin function RANDOM</title>
<programlisting>
RANDOM()          ->    305
RANDOM(5,8)       ->      7
RANDOM(2)         ->      0  /*  0  to  2    */
RANDOM(, ,1983)   ->    123  /* reproducible */
RANDOM(-5, 5)     ->    -3
</programlisting>
</example>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para id="rsseed">
To obtain a predictable sequence of quasi-random numbers,
use RANDOM a number of times, but specify a
<emphasis role="italic">seed</emphasis> only the first time.
For example, to simulate 40 throws of a 6-sided, unbiased die:
<example id="ex.bif-random-1">
<title>Builtin function RANDOM with seed</title>
<programlisting>
sequence = RANDOM(1,6,12345)  /* any number would */
                              /* do for a seed    */
do 39
sequence = sequence RANDOM(1,6)
end
say sequence
</programlisting>
</example>
The numbers are generated mathematically, using the initial
<emphasis role="italic">seed</emphasis>, so that as far as possible they appear
to be random. Running the program again produces the same sequence; using a different
initial <emphasis role="italic">seed</emphasis> almost certainly produces a
different sequence. If you do not supply a
<emphasis role="italic">seed</emphasis>, the first time RANDOM is called,
an arbitrary seed is used. Hence, your program usually gives different
results each time it is run.</para></listitem>
<listitem><para>The random number generator is global for an entire program; the current
seed is not saved across internal routine calls.</para></listitem>
</orderedlist>
</section>


<section id="bifReverse"><title>REVERSE</title>
<indexterm><primary>REVERSE function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>REVERSE</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>REVERSE</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/reverse.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns <emphasis role="italic">string</emphasis> reversed.</para>
<para>Here are some examples:</para>
<indexterm><primary>REVERSE function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>REVERSE function</secondary></indexterm>
<example id="ex.bif-reverse">
<title>Builtin function REVERSE</title>
<programlisting>
REVERSE("ABc.")    ->    ".cBA"
REVERSE("XYZ ")    ->    " ZYX"
</programlisting>
</example>
</section>


<section id="bifRight"><title>RIGHT</title>
<indexterm><primary>RIGHT function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>RIGHT</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>RIGHT</secondary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text right justification</secondary></indexterm>
<indexterm><primary>justification, text right, RIGHT function</primary></indexterm>
<indexterm><primary>leading</primary>
<secondary>zeros</secondary>
<tertiary>adding with RIGHT function</tertiary></indexterm>
<indexterm><primary>zeros</primary>
<secondary>added on left with RIGHT function</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/right.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a string of length
<emphasis role="italic">length</emphasis> containing the rightmost
<emphasis role="italic">length</emphasis> characters of
<emphasis role="italic">string</emphasis>. The string returned is padded with
<emphasis role="italic">pad</emphasis> character, or truncated, on the left
as needed. The default <emphasis role="italic">pad</emphasis> character is a
blank. The <emphasis role="italic">length</emphasis> must be a positive whole
number or zero.</para>
<para>Here are some examples:</para>
<indexterm><primary>RIGHT function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>RIGHT function</secondary></indexterm>
<example id="ex.bif-right">
<title>Builtin function RIGHT</title>
<programlisting>
RIGHT("abc  d",8)     ->    "  abc  d"
RIGHT("abc def",5)    ->    "c def"
RIGHT("12",5,"0")     ->    "00012"
</programlisting>
</example>
</section>

<section id="bifRxfuncadd"><title>RXFUNCADD</title>
<indexterm><primary>RXFUNCADD function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>RXFUNCADD</secondary></indexterm>
<indexterm><primary>add external function</primary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>RXFUNCADD</secondary></indexterm>
<indexterm><primary>register external functions</primary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/rxfuncadd.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Registers the function,
making it available to
Rexx procedures.
The <emphasis role="italic">module</emphasis> is the name of an
external library where the native function is located.  In some
environments, such as Unix-based systems, the library name is
case sensitive.
The <emphasis role="italic">procedure</emphasis> is the name of
the exported procedure inside of <emphasis role="italic">module</emphasis>.
If procedure is not specified, it defaults to <emphasis role="italic">name</emphasis>.
The <emphasis role="italic">procedure</emphasis> is generally case-sensitive.  RxFuncAdd
will attempt to resolve the procedure address using the name as specified and if that
attempt fails, will retry using an uppercased name.</para>
<para>
A return value 0 signifies successful registration and
that the registered function has been located in the specified
<emphasis role="italic">module</emphasis>.
A return value 1 signifies that the function could not be resolved.</para>
<indexterm><primary>RXFUNCADD function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>RXFUNCADD function</secondary></indexterm>
<example id="ex.bif-rxfuncadd">
<title>Builtin function RXFUNCADD</title>
<programlisting>
rxfuncadd("SysCls","rexxutil", "SysCls") -> 0 /* if SysCls can be located */
                                         -> 1 /* if SysCls can not be located */
</programlisting>
</example>
</section>


<section id="bifRxfuncdrop"><title>RXFUNCDROP</title>
<indexterm><primary>RXFUNCDROP function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>RXFUNCDROP</secondary></indexterm>
<indexterm><primary>drop external function</primary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>RXFUNCDROP</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/rxfuncdrop.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Removes (deregisters) the function
<emphasis role="italic">name</emphasis> from the list of available
functions. A zero return value signifies successful removal. </para>
<indexterm><primary>RXFUNCDROP function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>RXFUNCDROP function</secondary></indexterm>
<example id="ex.bif-rxfuncdrop">
<title>Builtin function RXFUNCDROP</title>
<programlisting>
rxfuncdrop("SysLoadFuncs")         -> 0 /* if successfully removed   */
</programlisting>
</example>
</section>


<section id="bifRxfuncquery"><title>RXFUNCQUERY</title>
<indexterm><primary>RXFUNCQUERY function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>RXFUNCQUERY</secondary></indexterm>
<indexterm><primary>query external function</primary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>RXFUNCQUERY</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/rxfuncquery.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Queries the list of available functions for the function
<emphasis role="italic">name</emphasis>. It returns a value of
<computeroutput>0</computeroutput> if the function is registered, and a value
of <computeroutput>1</computeroutput> if it is not. </para>
<indexterm><primary>RXFUNCQUERY function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>RXFUNCQUERY function</secondary></indexterm>
<example id="ex.bif-rxfuncquery">
<title>Builtin function RXFUNCQUERY</title>
<programlisting>
rxfuncquery("SysLoadFuncs")        -> 0 /* if registered             */
</programlisting>
</example>
</section>


<section id="bifRxqueue"><title>RXQUEUE</title>
<indexterm><primary>RXQUEUE function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>RXQUEUE</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>RXQUEUE</secondary></indexterm>
<indexterm><primary>create external data queue</primary></indexterm>
<indexterm><primary>external data queue</primary>
<secondary>creating and deleting queues</secondary></indexterm>
<indexterm><primary>external data queue</primary>
<secondary>naming and querying queues</secondary></indexterm>
<indexterm><primary>external data queue</primary>
<secondary>RXQUEUE function</secondary></indexterm>
<indexterm><primary>queue</primary>
<secondary>RXQUEUE function</secondary></indexterm>
<indexterm><primary>queue</primary>
<secondary>naming and querying</secondary></indexterm>
<indexterm><primary>queue</primary>
<secondary>creating and deleting queues</secondary></indexterm>
<indexterm><primary>Queue interface from Rexx programs</primary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/rxqueue.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Creates and deletes external data queues. It also sets and queries their
names.</para>
<variablelist>
<varlistentry><term>&quot;Create&quot;</term>
<listitem><para>creates a queue with the name
<emphasis role="italic">queuename</emphasis> if you specify
<emphasis role="italic">queuename</emphasis> and if no queue of that name
exists already. You must not use SESSION as a
<emphasis role="italic">queuename</emphasis>. If you specify no
<emphasis role="italic">queuename</emphasis>, then
the language processor provides a name.  The name of the queue is returned
in either case.</para>
<para>The maximum length of <emphasis role="italic">queuename</emphasis>
can be 1024 characters.</para>
<para>Many queues can exist at the same time, and most systems have sufficient
resources available to support several hundred queues at a time. If a queue
with the specified name exists already, a queue is still created with a name
assigned by the language processor. The assigned name is then returned to
you.</para>
</listitem></varlistentry>
<varlistentry><term>&quot;Delete&quot;</term>
<listitem><para>deletes the named queue. It returns 0 if successful or a
nonzero number if an error occurs. Possible return values are:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>Queue has been deleted.
</para></listitem></varlistentry>
<varlistentry><term>5</term>
<listitem><para>Not a valid queue name or tried to delete queue named "SESSION".
</para></listitem></varlistentry>
<varlistentry><term>9</term>
<listitem><para>Specified queue does not exist.
</para></listitem></varlistentry>
<varlistentry><term>10</term>
<listitem><para>Queue is busy; wait is active.
</para></listitem></varlistentry>
<varlistentry><term>12</term>
<listitem><para>A memory failure has occurred.
</para></listitem></varlistentry>
<varlistentry><term>1002</term>
<listitem><para>Failure in memory manager.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>&quot;Get&quot;</term>
<listitem><para>returns the name of the queue currently in use.
</para></listitem></varlistentry>
<varlistentry><term>&quot;Set&quot;</term>
<listitem><para>sets the name of the current queue to
<emphasis role="italic">newqueuename</emphasis> and returns
the previously active queue name.
</para></listitem></varlistentry>
</variablelist>
<para>The first parameter determines the function. Only the first character of
the first parameter is significant. The parameter can be entered in any case.
The syntax for a valid queue name is the same as for a valid Rexx symbol.</para>
<para>The second parameter specified for Create, Set, and Delete must follow
the same syntax rules as the Rexx variable names. There is no connection,
however, between queue names and variable names.  A program can have a variable
and a queue with the same name. The actual name of the queue is the uppercase
value of the name requested.</para>
<para>Named queues prevent different Rexx programs that are running in a single
session from interfering with each other. They allow Rexx programs running
in different sessions to synchronize execution and pass data. LINEIN("QUEUE:")
is especially useful because the calling program stops running until another
program places a line on the queue.</para>
<indexterm><primary>RXFUNCQUEUE function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>RXFUNCQUEUE function</secondary></indexterm>
<example id="ex.bif-rxqueue">
<title>Builtin function RXQUEUE</title>
<programlisting>
/* default queue                                    */
rxqueue("Get")             -> "SESSION"
/* assuming FRED does not already exist             */
rxqueue("Create", "Fred")  -> "FRED"
/* assuming SESSION had been active                 */
rxqueue("Set", "Fred")     -> "SESSION"
/* assuming FRED exists                             */
rxqueue("delete", "Fred")  -> "0"
</programlisting>
</example>
</section>


<section id="bifSetlocal"><title>SETLOCAL (Linux only)</title>
<indexterm><primary>SETLOCAL function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>SETLOCAL</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>SETLOCAL</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/setlocal.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Saves the current working directory and the current values of the environment
variables that are local to the current process.</para>
<para>For example, SETLOCAL can be used to save the current environment before
changing selected settings with the VALUE function (see
<xref linkend="bifValue" />).
To restore the directory and environment, use the ENDLOCAL function (see
<xref linkend="bifEndlocal" />.</para>
<para>SETLOCAL returns a value of 1 if the initial directory and environment are
successfully saved and a value of 0 if unsuccessful. If SETLOCAL is not followed
by an ENDLOCAL function in a procedure, the initial environment saved by
SETLOCAL is restored upon exiting the procedure.</para>
<para>Here is an example:</para>
<indexterm><primary>SETLOCAL function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>SETLOCAL function</secondary></indexterm>
<example id="ex.bif-setlocal">
<title>Builtin function SETLOCAL</title>
<programlisting>
/* Current path is "user/bin" */
n = SETLOCAL()           /* saves all environment settings */
/* Now use the VALUE function to change the PATH variable */
p = VALUE("Path","home/user/bin"."ENVIRONMENT")
/* Programs in directory home/user/bin can now be run */
n = ENDLOCAL()           /* restores initial environment including */
                         /* the changed PATH variable, which is    */
                         /* "user/bin"                             */
</programlisting>
</example>
</section>


<section id="bifSign"><title>SIGN</title>
<indexterm><primary>SIGN function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>SIGN</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>SIGN</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/sign.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a number that indicates the sign of
<emphasis role="italic">number</emphasis>.
The <emphasis role="italic">number</emphasis> is first rounded according to
standard Rexx rules, as though the operation
<computeroutput>number+0</computeroutput> had been carried out. It returns
<computeroutput>-1</computeroutput> if
<emphasis role="italic">number</emphasis> is less than
<computeroutput>0</computeroutput>, <computeroutput>0</computeroutput> if it
is <computeroutput>0</computeroutput>, and <computeroutput>1</computeroutput>
if it is greater than <computeroutput>0</computeroutput>.</para>
<para>Here are some examples:</para>
<indexterm><primary>SIGN function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>SIGN function</secondary></indexterm>
<example id="ex.bif-sign">
<title>Builtin function SIGN</title>
<programlisting>
SIGN("12.3")       ->     1
SIGN(" -0.307")    ->    -1
SIGN(0.0)          ->     0
</programlisting>
</example>
</section>


<section id="bifSourceline"><title>SOURCELINE</title>
<indexterm><primary>SOURCELINE function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>SOURCELINE</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>SOURCELINE</secondary></indexterm>
<indexterm><primary>lines</primary>
<secondary>from a program retrieved with SOURCELINE</secondary></indexterm>
<indexterm><primary>programs</primary>
<secondary>retrieving lines with SOURCELINE</secondary></indexterm>
<indexterm><primary>retrieving</primary>
<secondary>lines with SOURCELINE</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/sourceline.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the line number of the final line in the program if you omit
<emphasis role="italic">n</emphasis>. If you specify
<emphasis role="italic">n</emphasis>, returns the
<emphasis role="italic">n</emphasis>th line in the program
if available at the time of execution. Otherwise, it returns a null string.
If specified, <emphasis role="italic">n</emphasis> must be a positive
whole number and must not exceed
the number that a call to SOURCELINE with no arguments returns.</para>
<para>If the Rexx program is in tokenized form the this function raises an error
for all attempts to retrieve a line of the program.</para>
<para>Here are some examples:</para>
<indexterm><primary>SOURCELINE function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>SOURCELINE function</secondary></indexterm>
<example id="ex.bif-sourceline">
<title>Builtin function SOURCELINE</title>
<programlisting>
SOURCELINE()    ->   10
SOURCELINE(1)   ->   "/* This is a 10-line Rexx program */"
</programlisting>
</example>
</section>


<section id="bifSpace"><title>SPACE</title>
<indexterm><primary>SPACE function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>SPACE</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>SPACE</secondary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text spacing</secondary></indexterm>
<indexterm><primary>spacing, formatting, SPACE function</primary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/space.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the whitespace-delimited words in
<emphasis role="italic">string</emphasis> with
<emphasis role="italic">n pad</emphasis> characters
between each word. If you specify <emphasis role="italic">n</emphasis>,
it must be a positive whole number or zero. If it is
<computeroutput>0</computeroutput>, all whitespace characters are removed.
Leading and trailing whitespace characters are always removed. The default for
<emphasis role="italic">n</emphasis> is <computeroutput>1</computeroutput>,
and the default <emphasis role="italic">pad</emphasis> character is a blank.
</para>
<para>Here are some examples:</para>
<indexterm><primary>SPACE function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>SPACE function</secondary></indexterm>
<example id="ex.bif-space">
<title>Builtin function SPACE</title>
<programlisting>
SPACE("abc  def  ")          ->    "abc def"
SPACE("  abc def",3)         ->    "abc   def"
SPACE("abc  def  ",1)        ->    "abc def"
SPACE("abc  def  ",0)        ->    "abcdef"
SPACE("abc  def  ",2,"+")    ->    "abc++def"
</programlisting>
</example>
</section>


<section id="bifStream"><title>STREAM</title>
<indexterm><primary>STREAM function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>STREAM</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>STREAM</secondary></indexterm>
<indexterm><primary>input and output</primary>
<secondary>functions</secondary>
<tertiary>STREAM</tertiary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/stream.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a string describing the state of, or the result of an operation
upon, the character stream <emphasis role="italic">name</emphasis>.
The result may depend on characteristics
of the stream that you have specified in other uses of the STREAM function.
(To understand the input and output functions, see
<xref linkend="iostrms" />.)
This function requests information on the state of an input or output stream
or carries out some specific operation on the stream.</para>
<para>The first argument, <emphasis role="italic">name</emphasis>,
specifies the stream to be accessed.
The second argument can be one of the following strings that describe the
action to be carried out. (Only the capitalized letter is needed; all
characters following it are ignored.) </para>
<variablelist>
<varlistentry><term>Command</term>
<listitem><para>an operation (specified by the
<emphasis role="italic">stream_command</emphasis> given as the
third argument) is applied to the selected input or output stream. The string
that is returned depends on the command performed and can be a null string.
The possible input strings for the
<emphasis role="italic">stream_command</emphasis> argument are described later.
</para></listitem></varlistentry>
<varlistentry><term>Description</term>
<listitem><para>returns any descriptive string associated with the current
state of the specified stream. It is identical to the State operation, except
that the returned string is followed by a colon and, if available, additional
information about the ERROR or NOTREADY states.
</para></listitem></varlistentry>
<varlistentry><term>State</term>
<listitem><para>returns a string that indicates the current state of the
specified stream. This is the default operation.</para>
<para>The returned strings are as described in
<xref linkend="mthStreamState" />.</para>
</listitem></varlistentry>
</variablelist>

<note><title>Note</title>
<para>The state (and operation)
of an input or output stream is global to a Rexx program; it is not saved
and restored across internal function and subroutine calls (including those
calls that a CALL ON condition trap causes).</para></note>

<section id="streacom"><title>Stream Commands</title>
<indexterm><primary>STREAM function</primary>
<secondary>command options</secondary></indexterm>
<para>The following stream commands are used to: </para>
<itemizedlist>
<listitem><para>Open a stream for reading, writing, or both.</para></listitem>
<listitem><para>Close a stream at the end of an operation.</para></listitem>
<listitem><para>Position the read or write position within a persistent stream
(for example, a file).</para></listitem>
<listitem><para>Get information about a stream (its existence, size, and last
edit date).</para></listitem></itemizedlist>
<para>The <emphasis role="italic">streamcommand</emphasis> argument must be
used when--and only when--you
select the operation C (command). The syntax is:</para>
<programlisting>
&gt;&gt;-STREAM(name,"C",streamcommand)------------------------------&gt;&lt;
</programlisting>

<para>In this form, the STREAM function itself returns a string corresponding
to the given <emphasis role="italic">streamcommand</emphasis>
if the command is successful. If the command
is unsuccessful, STREAM returns an error message string in the same form as
the <computeroutput>D</computeroutput> (Description) operation supplies.</para>
<para>For most error conditions, the additional information is in the form of
a numeric return code. This return code is the value of
<emphasis role="italic">ERRNO</emphasis> that
is set whenever one of the file system primitives returns with a -1.</para>

<section id="commandstrings"><title>Command Strings</title>
<indexterm><primary>STREAM function</primary>
<secondary>command strings</secondary></indexterm>
<para>The argument <emphasis role="italic">streamcommand</emphasis>
can be any expression that the language processor evaluates to a command
string that corresponds to the following diagram:</para>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/stream_command.svg" scale="50" />
</imageobject>
</mediaobject>

<para><emphasis role="bold">Write Options:</emphasis></para>
<indexterm><primary>STREAM function</primary>
<secondary>write options</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/stream_write_options.svg" scale="50" />
</imageobject>
</mediaobject>

<para><emphasis role="bold">Options:</emphasis></para>
<indexterm><primary>STREAM function</primary>
<secondary>options</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/stream_options.svg" scale="50" />
</imageobject>
</mediaobject>

<variablelist>
<varlistentry><term>OPEN</term>
<listitem><para>opens the named stream. The default for OPEN is to open the
stream for both reading and writing data, for example,
<computeroutput>"OPEN BOTH"</computeroutput>.</para>
<para>The STREAM function itself returns a description string similar to the one
that the <computeroutput>D</computeroutput> option provides, for example,
"READY:" if the named stream is successfully opened, or "ERROR:2" if the named
stream is not found.</para>
<para>The following
is a description of the options for OPEN: </para>
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>opens the stream for reading only.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>opens the stream for writing only.
</para></listitem></varlistentry>
<varlistentry><term>BOTH</term>
<listitem><para>opens the stream for both reading and writing. (This is the default.)
Separate read and write pointers are maintained.
</para></listitem></varlistentry>
<varlistentry><term>APPEND</term>
<listitem><para>positions the write pointer at the end of the stream. The write pointer
cannot be moved anywhere within the extent of the file as it existed when
the file was opened.
</para></listitem></varlistentry>
<varlistentry><term>REPLACE</term>
<listitem><para>sets the write pointer to the beginning of the stream and truncates
the file. In other words, this option deletes all data that was in the stream
when opened.
</para></listitem></varlistentry>
<varlistentry><term>SHARED</term>
<listitem><para>Enables another process to work with the stream in a shared mode. This
mode must be compatible with the shared mode (SHARED, SHAREREAD, or SHAREWRITE)
used by the process that opened the stream.
</para></listitem></varlistentry>
<varlistentry><term>SHAREREAD</term>
<listitem><para>Enables another process to read the stream in a shared mode.
</para></listitem></varlistentry>
<varlistentry><term>SHAREWRITE</term>
<listitem><para>Enables another process to write the stream in a shared mode.
</para></listitem></varlistentry>
<varlistentry><term>NOBUFFER</term>
<listitem><para>turns off buffering of the stream. Thus, all data written to the stream
is flushed immediately to the operating system for writing. This option can
severely affect output performance.  Therefore, use it only when data integrity
is a concern, or to force interleaved output to a stream to appear in the
exact order in which it was written.
</para></listitem></varlistentry>
<varlistentry><term>BINARY</term>
<listitem><para>causes the stream to be opened in binary mode.  This means that line
end characters are ignored and treated as another byte of data. This is intended
to force file operations that are compatible with other Rexx language processors
that run on record-based systems, or to process binary data using the line
operations.

<note><title>Note</title>
<para>Specifying the BINARY option for a stream that
does not exist but is opened for writing also requires the RECLENGTH option
to be specified. Omitting the RECLENGTH option in this case raises an error
condition.</para></note>
</para></listitem></varlistentry>
<varlistentry><term>RECLENGTH <emphasis role="italic">length</emphasis></term>
<listitem><para>allows the specification of an exact length for each line in a stream.
 This allows line operations on binary-mode streams to operate on individual
fixed-length records.  Without this option, line operations on binary-mode
files operate on the entire file (for example, as if the
<computeroutput>RECLENGTH</computeroutput> option
were specified with a length equal to that of the file).
<emphasis role="italic">length</emphasis> must be 1 or greater.
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>STREAM function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>STREAM function</secondary></indexterm>
<example id="ex.bif-stream">
<title>Builtin function STREAM</title>
<programlisting>
stream(strout,"c","open")
stream(strout,"c","open write")
stream(strinp,"c","open read")
stream(strinp,"c","open read shared")
</programlisting>
</example>
</listitem></varlistentry>
<varlistentry><term>CLOSE</term>
<listitem><para>closes the named stream. The STREAM function itself returns
<computeroutput>READY:</computeroutput> if the named stream is
successfully closed, or an appropriate error
message. If an attempt is made to close an unopened file, STREAM returns a
null string (&quot;&quot;). </para>
<example id="ex.bif-stream-1">
<title>Builtin function STREAM on unopened file</title>
<programlisting>
stream("STRM.TXT","c","close")
</programlisting>
</example>
</listitem></varlistentry>
<varlistentry><term>FLUSH</term>
<listitem><para>forces any data currently buffered for writing to be written
to this stream.
</para></listitem></varlistentry>
<varlistentry><term>SEEK <emphasis role="italic">offset</emphasis></term>
<listitem><para>sets the read or write position within a persistent stream.
 If the stream is opened for both reading and writing and no SEEK option is
specified, both the read and write positions are set. </para>

<note><title>Note</title>
<para>See <xref linkend="iostrms" /> for a
discussion of read and write positions in a persistent
stream.</para></note>
<para>To use this command, the named stream must first
be opened with the OPEN stream command or implicitly with an input or output
operation. One of the following characters can precede the
<emphasis role="italic">offset</emphasis> number: </para>
<variablelist>
<varlistentry><term><computeroutput>=</computeroutput></term>
<listitem><para>explicitly specifies the
<emphasis role="italic">offset</emphasis> from the beginning of the stream.
 This is the default if no prefix is supplied.
 <computeroutput>Line Offset=1</computeroutput> means
the beginning of stream.
</para></listitem></varlistentry>
<varlistentry><term><computeroutput>&lt;</computeroutput></term>
<listitem><para>specifies <emphasis role="italic">offset</emphasis>
from the end of the stream.
</para></listitem></varlistentry>
<varlistentry><term><computeroutput>+</computeroutput></term>
<listitem><para>specifies <emphasis role="italic">offset</emphasis>
forward from the current read or write position.
</para></listitem></varlistentry>
<varlistentry><term><computeroutput>-</computeroutput></term>
<listitem><para>specifies <emphasis role="italic">offset</emphasis>
backward from the current read or write position.
</para></listitem></varlistentry>
</variablelist>
<para>The STREAM function itself returns the new position in the stream
if the read or write position is successfully located or an appropriate error
message otherwise.</para>
<para>The following is a description of the options for
SEEK: </para>
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>specifies that the read position is to be set by this command.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>specifies that the write position is to be set by this command.
</para></listitem></varlistentry>
<varlistentry><term>CHAR</term>
<listitem><para>specifies that the positioning is to be done in terms of
characters. This is the default.
</para></listitem></varlistentry>
<varlistentry><term>LINE</term>
<listitem><para>specifies that the positioning is to be done in terms of lines.
For non-binary streams, this is an operation that can take a long time to
complete, because, in most cases, the file must be scanned from the top to
count line-end characters.  However, for binary streams with a specified record
length, this results in a simple multiplication of the new resulting line
number by the record length, and then a simple character positioning. See
<xref linkend="positio" /> for
a detailed discussion of this issue.

<note><title>Note</title>
<para>If you do line positioning
in a file open only for writing, you receive an error message.</para></note>
</para></listitem></varlistentry>
</variablelist>
<indexterm><primary>STREAM function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>STREAM function</secondary></indexterm>
<example id="ex.bif-stream-2">
<title>Builtin function STREAM examples</title>
<programlisting>
stream(name,"c","seek =2 read")
stream(name,"c","seek +15 read")
stream(name,"c","seek -7 write line")
fromend  = 125
stream(name,"c","seek &lt;"fromend read)
</programlisting>
</example>
</listitem></varlistentry>
<varlistentry><term>POSITION</term>
<listitem><para>is a synonym for SEEK.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="querysream"><title>QUERY Stream Commands</title>
<indexterm><primary>STREAM function</primary>
<secondary>query options</secondary></indexterm>
<para>Used with these stream commands, the STREAM function returns specific
information about a stream. Except for QUERY HANDLE and QUERY POSITION, the
language processor returns the query information even if the stream is not
open. The language processor returns UNKNOWN for QUERY STREAMTYPE and the null string for nonexistent
streams.
</para>
<para>
  Note that technically although a directory is persistent, it is not a stream. If the directory exists,
  the date / time queries return the time stamp of the directory, QUERY SIZE returns 0, and QUERY
  STREAMTYPE returns UNKNOWN. The other commands return the null string.
</para>
<variablelist>
<varlistentry><term>QUERY DATETIME</term>
<listitem><para>returns the date and time stamps of a stream in US format.
This is included for compatibility with
<trademark class="registered">OS/2</trademark>.
<example id="ex.bif-stream-3">
<title>Builtin function STREAM QUERY examples</title>
<programlisting>
stream("..\file.txt","c","query datetime")
</programlisting>
</example>
</para>
<para>A sample output might be: </para>
<programlisting>
11-12-98 03:29:12
</programlisting>
</listitem></varlistentry>
<varlistentry><term>QUERY EXISTS</term>
<listitem><para>returns the full path specification of the named stream, if it
exists, or a null string.</para>
<example id="ex.bif-stream-4">
<title>Builtin function STREAM QUERY EXISTS examples</title>
<programlisting>
stream("..\file.txt","c","query exists")
</programlisting>
</example>
<para>A sample output might be: </para>
<programlisting>
c:\data\file.txt
</programlisting>
</listitem></varlistentry>
<varlistentry><term>QUERY HANDLE</term>
<listitem><para>returns the handle associated with the open stream. </para>
<example id="ex.bif-stream-5">
<title>Builtin function STREAM QUERY HANDLE examples</title>
<programlisting>
stream("..\file.txt","c","query handle")
</programlisting>
</example>
<para>A sample output might be: </para>
<programlisting>
3
</programlisting>
</listitem></varlistentry>
<varlistentry><term>QUERY POSITION</term>
<listitem><para>returns the current read or write position for the stream, as
qualified by the following options:
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>returns the current read position.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>returns the current write position.

<note><title>Note</title>
<para>If the stream is
open for both reading and writing, the default is to return the read position.
Otherwise, it returns the appropriate position by default.</para></note>
</para></listitem></varlistentry>
<varlistentry><term>CHAR</term>
<listitem><para>returns the position in terms of characters. This is the
default.</para></listitem></varlistentry>
<varlistentry><term>LINE</term>
<listitem><para>returns the position in terms of lines. For non-binary streams,
this operation can take a long time to complete, because the language processor
starts tracking the current line number if not already doing so. Thus, it
might require a scan of the stream from the top to count line-end characters.
See <xref linkend="positio" /> for a
detailed discussion of this issue.</para>
<example id="ex.bif-stream-6">
<title>Builtin function STREAM QUERY POSITION examples</title>
<programlisting>
stream("myfile","c","query position write")
</programlisting>
</example>
<para>A sample output might
be: </para>
<programlisting>
247
</programlisting>
</listitem></varlistentry>
<varlistentry><term>SYS</term>
<listitem><para>returns the operating-system stream position in terms of
characters.</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>QUERY SIZE</term>
<listitem><para>returns the size, in bytes, of a persistent stream. </para>
<example id="ex.bif-stream-7">
<title>Builtin function STREAM QUERY SIZE examples</title>
<programlisting>
stream("..\file.txt","c","query size")
</programlisting>
</example>
<para>A sample output might be: </para>
<programlisting>
1305
</programlisting>
</listitem></varlistentry>
<varlistentry><term>QUERY STREAMTYPE</term>
<listitem><para>returns a string indicating whether the stream is
<computeroutput>PERSISTENT</computeroutput>,
<computeroutput>TRANSIENT</computeroutput>, or
<computeroutput>UNKNOWN</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>QUERY TIMESTAMP</term>
<listitem><para>returns the date and time stamps of a stream in an international format.
This is the preferred method of getting the date and time because it provides
the full 4-digit year.</para>
<example id="ex.bif-stream-8">
<title>Builtin function STREAM QUERY TIMESTAMP examples</title>
<programlisting>
stream("..\file.txt","c","query timestamp")
</programlisting>
</example>
<para>A sample output might be: </para>
<programlisting>
1998-11-12 03:29:12
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>
</section>
</section>

<section id="bifStrip"><title>STRIP</title>
<indexterm><primary>STRIP function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>STRIP</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>STRIP</secondary></indexterm>
<indexterm><primary>blanks</primary>
<secondary>removal with STRIP function</secondary></indexterm>
<indexterm><primary>whitespace</primary>
<secondary>removal with STRIP function</secondary></indexterm>
<indexterm><primary>leading</primary>
<secondary>zeros</secondary>
<tertiary>removing with STRIP function</tertiary></indexterm>
<indexterm><primary>leading</primary>
<secondary>leading whitespace removal with STRIP function</secondary></indexterm>
<indexterm><primary>trailing</primary>
<secondary>whitespace removed using STRIP function</secondary></indexterm>
<indexterm><primary>zeros</primary>
<secondary>removal with STRIP function</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/strip.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns <emphasis role="italic">string</emphasis> with leading
characters, trailing characters, or both, removed, based on the
<emphasis role="italic">option</emphasis> you specify. The following are
valid <emphasis role="italic">option</emphasis>s. (Only the capitalized letter
is needed; all characters following it are ignored.)</para>
<variablelist>
<varlistentry><term>Both</term>
<listitem><para>removes both leading and trailing characters from
<emphasis role="italic">string</emphasis>. This
is the default.
</para></listitem></varlistentry>
<varlistentry><term>Leading</term>
<listitem><para>removes leading characters from
<emphasis role="italic">string</emphasis>.
</para></listitem></varlistentry>
<varlistentry><term>Trailing</term>
<listitem><para>removes trailing characters from
<emphasis role="italic">string</emphasis>.
</para></listitem></varlistentry>
</variablelist>
<para>The third argument, <emphasis role="italic">chars</emphasis>, specifies
the set of characters to be removed, and the default is to remove all whitespace
characters (spaces and horizontal tabs). If
<emphasis role="italic">chars</emphasis>, is a null string, then no characters are
removed.  Otherwise, any occurrences of the characters in <emphasis role="italic">chars</emphasis>
will be removed.</para>
<para>Here are some examples:</para>
<indexterm><primary>STRIP function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>STRIP function</secondary></indexterm>
<example id="ex.bif-strip">
<title>Builtin function STRIP</title>
<programlisting>
STRIP("  ab c  ")        ->    "ab c"
STRIP("  ab c  ","L")    ->    "ab c  "
STRIP("  ab c  ","t")    ->    "  ab c"
STRIP("12.7000", ,0)     ->    "12.7"
STRIP("0012.700", ,0)    ->    "12.7"
STRIP("12.0000", "T", '.0') -> "12"
</programlisting>
</example>
</section>


<section id="bifSubstr"><title>SUBSTR (Substring)</title>
<indexterm><primary>SUBSTR function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>SUBSTR</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>SUBSTR</secondary></indexterm>
<indexterm><primary>character</primary>
<secondary>removal with STRIP function</secondary></indexterm>
<indexterm><primary>extracting</primary>
<secondary>substring</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>extracting using SUBSTR function</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/substr.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the substring of <emphasis role="italic">string</emphasis> that
begins at the <emphasis role="italic">n</emphasis>th
character and is of length <emphasis role="italic">length</emphasis>, padded
with <emphasis role="italic">pad</emphasis> if necessary.
<emphasis role="italic">n</emphasis> must be a positive whole number.
If <emphasis role="italic">n</emphasis> is greater than
<computeroutput>LENGTH(string)</computeroutput>, only pad characters are
returned.</para>
<para>If you omit <emphasis role="italic">length</emphasis>, the rest of the
string is returned.  The default <emphasis role="italic">pad</emphasis>
character is a blank.</para>
<para>Here are some examples:</para>
<indexterm><primary>SUBSTR function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>SUBSTR function</secondary></indexterm>
<example id="ex.bif-substr">
<title>Builtin function SUBSTR</title>
<programlisting>
SUBSTR("abc",2)          ->    "bc"
SUBSTR("abc",2,4)        ->    "bc  "
SUBSTR("abc",2,6,".")    ->    "bc...."
</programlisting>
</example>

<note><title>Note</title>
<para>In some situations the positional (numeric) patterns of parsing
templates are more convenient for selecting substrings, especially if more
than one substring is to be extracted from a string. See also
<xref linkend="bifLeft" /> and <xref linkend="bifRight" />.
</para></note>
</section>


<section id="bifSubword"><title>SUBWORD</title>
<indexterm><primary>SUBWORD function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>SUBWORD</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>SUBWORD</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>extracting words with SUBWORD</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>extracting from a string</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/subword.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the substring of <emphasis role="italic">string</emphasis> that
starts at the <emphasis role="italic">n</emphasis>th
word, and is up to <emphasis role="italic">length</emphasis>
whitespace-delimited words.
<emphasis role="italic">n</emphasis> must be a positive whole number. If you
omit
<emphasis role="italic">length</emphasis>, it defaults to the
number of remaining words in <emphasis role="italic">string</emphasis>.
The returned string never has
leading or trailing whitespace, but includes all whitespace characters between
the selected words.
</para>
<para>Here are some examples:</para>
<indexterm><primary>SUBWORD function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>SUBWORD function</secondary></indexterm>
<example id="ex.bif-subword">
<title>Builtin function SUBWORD</title>
<programlisting>
SUBWORD("Now is the  time",2,2)    ->    "is the"
SUBWORD("Now is the  time",3)      ->    "the  time"
SUBWORD("Now is the  time",5)      ->    ""
</programlisting>
</example>
</section>


<section id="bifSymbol"><title>SYMBOL</title>
<indexterm><primary>SYMBOL function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>SYMBOL</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>SYMBOL</secondary></indexterm>
<indexterm><primary>testing</primary></indexterm>
<indexterm><primary>variable initialization</primary></indexterm>
<indexterm><primary>variable</primary>
<secondary>testing for initialization</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/symbol.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the state of the symbol named by
<emphasis role="italic">name</emphasis>. It returns
<computeroutput>BAD</computeroutput> if
<emphasis role="italic">name</emphasis> is not a valid Rexx symbol. It returns
<computeroutput>VAR</computeroutput> if it is the name of a variable, that is,
a symbol that has been assigned a value. Otherwise, it returns
<computeroutput>LIT</computeroutput>, indicating that it is either
a constant symbol or a symbol that has not yet been assigned a value, that
is, a literal.</para>
<para>As with symbols in Rexx expressions, lowercase characters in
<emphasis role="italic">name</emphasis> are translated to uppercase and
substitution in a compound name occurs if possible. </para>

<note><title>Note</title>
<para>You should specify <emphasis role="italic">name</emphasis> as a literal
string, or it should be derived from an expression, to prevent substitution
before it is passed to the function.</para></note>
<para>Here are some examples:</para>
<indexterm><primary>SYMBOL function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>SYMBOL function</secondary></indexterm>
<example id="ex.bif-symbol">
<title>Builtin function SYMBOL</title>
<programlisting>
/* following: Drop A.3;  J=3 */
SYMBOL("J")      ->   "VAR"
SYMBOL(J)        ->   "LIT" /* has tested "3"     */
SYMBOL("a.j")    ->   "LIT" /* has tested A.3     */
SYMBOL(2)        ->   "LIT" /* a constant symbol  */
SYMBOL("*")      ->   "BAD" /* not a valid symbol */
</programlisting>
</example>
</section>


<section id="bifTime"><title>TIME</title>
<indexterm><primary>TIME function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>TIME</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>TIME</secondary></indexterm>
<indexterm><primary>elapsed-time clock</primary>
<secondary>measuring intervals with</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/time.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the local time in the 24-hour clock format hh:mm:ss
(hours, minutes, and seconds) by default, for example,
<computeroutput>04:41:37</computeroutput>.</para>
<para>You can use the following <emphasis role="italic">option</emphasis>s
to obtain alternative formats, or to gain access to the elapsed-time clock.
(Only the capitalized letter
is needed; all characters following it are ignored.) </para>
<variablelist>
<varlistentry><term>Civil</term>
<listitem><para>returns the time in Civil format hh:mmxx. The hours can take
the values <computeroutput>1</computeroutput> through
<computeroutput>12</computeroutput>, and the minutes the values
<computeroutput>00</computeroutput> through <computeroutput>59</computeroutput>.
The minutes are followed immediately by the letters
<computeroutput>am</computeroutput> or <computeroutput>pm</computeroutput>.
This distinguishes times in the morning (12 midnight through 11:59
a.m.--appearing as <computeroutput>12:00am</computeroutput> through
<computeroutput>11:59am</computeroutput>) from noon and afternoon (12 noon
through 11:59 p.m.--appearing as <computeroutput>12:00pm</computeroutput>
through <computeroutput>11:59pm</computeroutput>). The hour has no leading
zero.  The minute field shows the current minute (rather than the nearest
minute) for consistency with other TIME results.
</para></listitem></varlistentry>
<varlistentry><term>Elapsed</term>
<listitem><para>returns sssssssss.uuuuuu, the number of seconds and microseconds
since the elapsed-time clock (described later) was started or reset. The returned
number has no leading zeros or whitespace, and the setting of NUMERIC DIGITS
does not affect it. The number has always four trailing zeros in the decimal
portion.</para>
<para>The language processor calculates elapsed time by subtracting the time at
which the elapsed-time clock was started or reset from the current time. It
is possible to change the system time clock while the system is running.
This means that the calculated elapsed time value might not be a true elapsed
time.  If the time is changed so that the system time is earlier than when
the Rexx elapsed-time clock was started (so that the elapsed time would appear
negative), the language processor raises an error and disables the elapsed-time
clock.  To restart the elapsed-time clock, trap the error through SIGNAL ON
SYNTAX.</para>
<para>The clock can also be changed by programs on the system.  Many
LAN-attached programs synchronize the system time clock with the system time
clock of the server during startup.  This causes the Rexx elapsed time function
to be unreliable during LAN initialization.</para>
</listitem></varlistentry>
<varlistentry><term>Full
<indexterm><primary>Full option of Time function</primary></indexterm>
</term>
<listitem><para>returns the number of microseconds
since 00:00:00.000000 on 1 January 0001, in the format:
<emphasis role="italic">dddddddddddddddddd</emphasis> (no leading zeros or
whitespace).
</para>
<note><title>Notes</title>
<para>The base date of 1 January 0001 is determined
by extending the current Gregorian calendar backward (365 days each year,
with an extra day every year that is divisible by 4 except century years that
are not divisible by 400). It does not take into account any errors in the calendar
system that created the Gregorian calendar originally.</para>
<para>The value returned by Time('F') can be used to calculate the interval between
any two times.  Note, however, that values returned generally contain more digits
than the default NUMERIC DIGITS setting.  The NUMERIC DIGITS setting should be increased
to a minimum value of 18 when performing timestamp arithmetic.</para>
</note>
</listitem></varlistentry>
<varlistentry><term>Hours
<indexterm><primary>hours calculated from midnight</primary></indexterm>
</term>
<listitem><para>returns up to two characters giving the number of hours
since midnight in the format hh (no leading zeros or whitespace, except for a
result of
<computeroutput>0</computeroutput>).
</para></listitem></varlistentry>
<varlistentry><term>Long</term>
<listitem><para>returns time in the format hh:mm:ss.uuuuuu (where uuuuuu are
microseconds).
</para></listitem></varlistentry>
<varlistentry><term>Minutes
<indexterm><primary>minutes calculated from midnight</primary></indexterm>
</term>
<listitem><para>returns up to four characters giving the number of minutes
since midnight in the format mmmm (no leading zeros or whitespace, except for a
result of
<computeroutput>0</computeroutput>).
</para></listitem></varlistentry>
<varlistentry><term>Normal</term>
<listitem><para>returns the time in the default format hh:mm:ss. The hours
can have the values <computeroutput>00</computeroutput> through
<computeroutput>23</computeroutput>, and minutes and seconds,
<computeroutput>00</computeroutput> through <computeroutput>59</computeroutput>.
There are always two digits. Any fractions
of seconds are ignored (times are never rounded). This is the default.
</para></listitem></varlistentry>
<varlistentry><term>Offset</term>
<listitem><para>returns the offset of the local time from UTC in microseconds.
The offset value will be negative for timezones west of the Prime Meridian
and positive for timezones east of Prime Meridian.  The local time('F') value
can be converted to UTC by subtracting the time('O') value.
</para></listitem></varlistentry>
<varlistentry><term>Reset</term>
<listitem><para>returns sssssssss.uuuuuu, the number of seconds and microseconds
since the elapsed-time clock (described later) was started or reset and also
resets the elapsed-time clock to zero. The returned number has no leading
zeros or whitespace, and the setting of NUMERIC DIGITS does not affect it. The
number always has four trailing zeros in the decimal portion.
</para>
<para>See the Elapsed option for more information on resetting the system
time clock.</para>
</listitem></varlistentry>
<varlistentry><term>Seconds
<indexterm><primary>seconds calculated from midnight</primary></indexterm>
</term>
<listitem><para>returns up to five characters giving the number of seconds
since midnight in the format sssss (no leading zeros or whitespace, except for a
result of
<computeroutput>0</computeroutput>).
</para></listitem></varlistentry>
<varlistentry><term>Ticks
<indexterm><primary>Ticks option of Time function</primary></indexterm>
</term>
<listitem><para>returns the number of seconds
since 00:00:00.000000 on 1 January 1970, in the format:
<emphasis role="italic">dddddddddddd</emphasis> (no leading zeros or
whitespace).
</para>
<note><title>Notes</title>
<para>The base date of 1 January 1970 is determined
by extending the current Gregorian calendar backward (365 days each year,
with an extra day every year that is divisible by 4 except century years that
are not divisible by 400). It does not take into account any errors in the calendar
system that created the Gregorian calendar originally.</para>
<para>The value returned by Time('T') can be used to calculate the interval between
any two times.  Note, however, that values returned generally contain more digits
than the default NUMERIC DIGITS setting.  The NUMERIC DIGITS setting should be increased
to a minimum value of 12 when performing timestamp arithmetic.</para>
<para>Time('T') will return a negative number for dates prior to 1 January 1970.</para>
</note>
</listitem></varlistentry>
</variablelist>
<para>Here are some examples, assuming that the time is 4:54 p.m.:</para>
<indexterm><primary>TIME function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>TIME function</secondary></indexterm>
<example id="ex.bif-time">
<title>Builtin function TIME</title>
<programlisting>
TIME()       ->   "16:54:22"
TIME("C")    ->   "4:54pm"
TIME("H")    ->   "16"
TIME("L")    ->   "16:54:22.120000"   /* Perhaps */
TIME("M")    ->   "1014"           /* 54 + 60*16 */
TIME("N")    ->   "16:54:22"
TIME("S")    ->   "60862"  /* 22 + 60*(54+60*16) */
</programlisting>
</example>
<para><emphasis role="bold">The elapsed-time clock:</emphasis></para>
<para>You can use the TIME function to measure real (elapsed) time intervals.
On the first call in a program to <computeroutput>TIME("E")</computeroutput>
or <computeroutput>TIME("R")</computeroutput>, the elapsed-time clock is started,
and either call returns <computeroutput>0</computeroutput>. From
then on, calls to <computeroutput>TIME("E")</computeroutput> and
<computeroutput>TIME("R")</computeroutput> return the
elapsed time since that first call or since the last call to
<computeroutput>TIME("R")</computeroutput>.</para>
<para>The clock is saved across internal routine calls, which means that an internal
routine inherits the time clock that its caller started. Any timing the caller
is doing is not affected, even if an internal routine resets the clock. An
example of the elapsed-time clock: </para>
<indexterm><primary>TIME function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>TIME function</secondary></indexterm>
<example id="ex.bif-time-1">
<title>Builtin function TIME elapsed</title>
<programlisting>
time("E")    ->    0          /* The first call */
                  /* pause of one second here */
time("E")    ->    1.020000   /* or thereabouts */
                  /* pause of one second here */
time("R")    ->    2.030000   /* or thereabouts */
                  /* pause of one second here */
time("R")    ->    1.050000   /* or thereabouts */
</programlisting>
</example>

<note><title>Note</title>
<para>The elapsed-time clock is synchronized with the other calls
to TIME and DATE, so several calls to the elapsed-time clock in a single clause
always return the same result.  For this reason, the interval between two
usual TIME/DATE results can be calculated exactly using the elapsed-time clock.
</para></note>
<para>If you specify <emphasis role="italic">string</emphasis>, TIME returns
the time corresponding to <emphasis role="italic">string</emphasis> in the
format <emphasis role="italic">option</emphasis>.  The
<emphasis role="italic">string</emphasis> must be supplied
in the format <emphasis role="italic">option2</emphasis>. The default for
<emphasis role="italic">option2</emphasis> is "N".
So you need to specify <emphasis role="italic">option2</emphasis> only if
<emphasis role="italic">string</emphasis> is not in
the Normal format. <emphasis role="italic">option2</emphasis> must specify the
current time, for example, not "E" or "R". Here are some examples: </para>
<example id="ex.bif-time-2">
<title>Builtin function TIME formating</title>
<programlisting>
time("C","11:27:21")    ->    11:27am
time("N","11:27am","C") ->    11:27:00
time("N", "63326132161828000", "F")   ->   08:16:01
</programlisting>
</example>
<para>You can determine the difference between two times; for example:</para>
<example id="ex.bif-time-3">
<title>Builtin function TIME difference</title>
<programlisting>
If TIME("M","5:00pm","C")-TIME("M")&lt;=0
then say "Time to go home"
else say "Keep working"
</programlisting>
</example>
<para>The TIME returned is the earliest time consistent with
<emphasis role="italic">string</emphasis>.
For example, if the result requires components that are not specified in the
source format, then those components of the result are zero. If the source
has components that the result does not need, then those components of the
source are ignored.</para>
<para>When requesting times be converted to Full or Ticks format, a date value
of 1 January 0001 is used for the conversion.
A time stamp for a time and date combination can be created by
combining a value from Date('F') for the time of day.</para>
<example id="ex.bif-time-4">
<title>Builtin function TIME with F option</title>
<programlisting>
    numeric digits 18  -- needed to add the timestamps
    timestamp = date('f, '20072301', 'S') + time('f', '08:14:22', 'N')
</programlisting>
</example>
<indexterm><primary>implementation maximum</primary>
<secondary>TIME function</secondary></indexterm>
<para><emphasis role="bold">Implementation maximum:</emphasis>
<indexterm><primary>TIME function</primary>
<secondary>implementation maximum</secondary></indexterm>
If the number of seconds in the elapsed time exceeds nine digits
(equivalent to over 31.6 years), an error results.</para>
</section>


<section id="bifTrace"><title>TRACE</title>
<indexterm><primary>TRACE function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>TRACE</secondary></indexterm>
<indexterm><primary>altering</primary>
<secondary>TRACE setting</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>TRACE</secondary></indexterm>
<indexterm><primary>TRACE setting</primary>
<secondary>altering with TRACE function</secondary></indexterm>
<indexterm><primary>TRACE setting</primary>
<secondary>querying</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/trace.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns trace actions currently in effect and, optionally, alters the
setting.</para>
<para>If you specify <emphasis role="italic">option</emphasis>, it selects
the trace setting. It must be the valid prefix
<computeroutput>?</computeroutput>, one of the alphabetic character options
associated with the TRACE instruction (that is, starting with
<computeroutput>A</computeroutput>, <computeroutput>C</computeroutput>,
<computeroutput>E</computeroutput>, <computeroutput>F</computeroutput>,
<computeroutput>I</computeroutput>, <computeroutput>L</computeroutput>,
<computeroutput>N</computeroutput>, <computeroutput>O</computeroutput>,
or <computeroutput>R</computeroutput>), or both. (See the TRACE instruction
in <xref linkend="alphaco" /> for
full details.)</para>
<para>Unlike the TRACE instruction, the TRACE function alters the trace action
even if interactive debugging is active. Also unlike the TRACE instruction,
<emphasis role="italic">option</emphasis> cannot be a number.</para>
<para>Here are some examples:</para>
<indexterm><primary>TRACE function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>TRACE function</secondary></indexterm>
<example id="ex.bif-trace">
<title>Builtin function TRACE</title>
<programlisting>
TRACE()       ->   "?R" /* maybe */
TRACE("O")    ->   "?R" /* also sets tracing off */
TRACE("?I")   ->   "O"  /* now in interactive debugging */
</programlisting>
</example>
</section>


<section id="bifTranslate"><title>TRANSLATE</title>
<indexterm><primary>TRANSLATE function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>TRANSLATE</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>TRANSLATE</secondary></indexterm>
<indexterm><primary>reordering data</primary></indexterm>
<indexterm><primary>translation</primary>
<secondary>with TRANSLATE function</secondary></indexterm>
<indexterm><primary>uppercase translation</primary>
<secondary>with TRANSLATE function</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/translate.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns <emphasis role="italic">string</emphasis> with each character
translated to another character or unchanged. You can also use this function to
reorder the characters in <emphasis role="italic">string</emphasis>.</para>
<para>The output table is <emphasis role="italic">tableo</emphasis> and the
input translation table is <emphasis role="italic">tablei</emphasis>.
TRANSLATE searches <emphasis role="italic">tablei</emphasis> for each
character in <emphasis role="italic">string</emphasis>. If the character is
found, the corresponding character in <emphasis role="italic">tableo</emphasis>
is used in the result string; if there are duplicates in
<emphasis role="italic">tablei</emphasis>, the first (leftmost) occurrence
is used. If the character is not found, the original character in
<emphasis role="italic">string</emphasis> is used. The result string
is always the same length as <emphasis role="italic">string</emphasis>.</para>
<para>The tables can be of any length. If you specify neither table and omit
<emphasis role="italic">pad</emphasis>,
<emphasis role="italic">string</emphasis> is simply translated to uppercase
(that is, lowercase
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>
to uppercase
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>),
but, if you include <emphasis role="italic">pad</emphasis>, the language
processor translates the entire string to
<emphasis role="italic">pad</emphasis> characters.
<emphasis role="italic">tablei</emphasis> defaults to
<computeroutput>XRANGE("00"x,"FF"x)</computeroutput>, and
<emphasis role="italic">tableo</emphasis> defaults to the null string and is
padded with <emphasis role="italic">pad</emphasis> or truncated as necessary.
The default <emphasis role="italic">pad</emphasis> is a blank.</para>
<para><emphasis role="italic">pos</emphasis> is the position of the first
character of the translated range.  The default starting position is 1.
<emphasis role="italic">length</emphasis> is the range of characters to be
translated.  If omitted, <emphasis role="italic">length</emphasis> remainder of
the string from the starting position to the end is used. </para>
<para>Here are some examples:</para>
<indexterm><primary>TRANSLATE function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>TRANSLATE function</secondary></indexterm>
<example id="ex.bif-translate">
<title>Builtin function TRANSLATE</title>
<programlisting>
TRANSLATE("abcdef")                        ->    "ABCDEF"
TRANSLATE("abcdef", , , , 2, 3)            ->    "aBCDef"
TRANSLATE("abcdef", "12", "ec")            ->    "ab2d1f"
TRANSLATE("abcdef", "12", "abcd", ".")     ->    "12..ef"
TRANSLATE("APQRV", , "PR")                 ->    "A Q V"
TRANSLATE("APQRV", XRANGE("00"X, "Q"))     ->    "APQ  "
TRANSLATE("4123", "abcd", "1234", , 2, 2)  ->    "4ab3"
TRANSLATE("4123", "abcd", "1234")          ->    "dabc"
</programlisting>
</example>

<note><title>Note</title>
<para>The last example shows how to use the TRANSLATE function
to reorder the characters in a string.  The last character of any four-character
string specified as the second argument is moved to the beginning of the string.
</para></note>
</section>


<section id="bifTrunc"><title>TRUNC (Truncate)</title>
<indexterm><primary>TRUNC function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>TRUNC</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>TRUNC</secondary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>numbers with TRUNC</secondary></indexterm>
<indexterm><primary>numbers</primary>
<secondary>truncating</secondary></indexterm>
<indexterm><primary>truncating numbers</primary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/trunc.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the integer part of <emphasis role="italic">number</emphasis>
and <emphasis role="italic">n</emphasis> decimal places.
The default <emphasis role="italic">n</emphasis> is
<computeroutput>0</computeroutput> and returns an integer with no decimal
point. If you specify <emphasis role="italic">n</emphasis>, it must be
a positive whole number or zero. The <emphasis role="italic">number</emphasis>
is rounded according to standard Rexx rules, as though the operation
<computeroutput>number+0</computeroutput> had been carried out. Then it is
truncated to <emphasis role="italic">n</emphasis> decimal places or trailing
zeros are added to reach the specified
length. The result is never in exponential form. If there are no nonzero digits
in the result, any minus sign is removed.</para>
<para>Here are some examples:</para>
<indexterm><primary>TRUNC function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>TRUNC function</secondary></indexterm>
<example id="ex.bif-trunc">
<title>Builtin function TRUNC</title>
<programlisting>
TRUNC(12.3)           ->    12
TRUNC(127.09782,3)    ->    127.097
TRUNC(127.1,3)        ->    127.100
TRUNC(127,2)          ->    127.00
</programlisting>
</example>

<note><title>Note</title>
<para>The <emphasis role="italic">number</emphasis> is rounded according to the
current setting of NUMERIC DIGITS, if necessary, before the function processes
it.
</para></note>
</section>


<section id="bifUpper"><title>UPPER</title>
<indexterm><primary>UPPER function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>UPPER</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>UPPER</secondary></indexterm>
<indexterm><primary>character</primary>
<secondary>uppercasing using UPPER function</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>uppercasing using UPPER function</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/upper.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a new string with the characters of <emphasis role="italic">string</emphasis> beginning with
character <emphasis role="italic">n</emphasis> for <emphasis role="italic">length</emphasis>
characters converted to uppercase.  If <emphasis role="italic">n</emphasis> is specified, it must
be a positive whole number.  If <emphasis role="italic">n</emphasis> is not specified, the case
conversion will start with the first character.  If <emphasis role="italic">length</emphasis>
is specified, it must be a non-negative whole number.  If <emphasis role="italic">length</emphasis>
is not specified, the default is to convert the remainder of the string.</para>
<indexterm><primary>examples</primary>
<secondary>upper function</secondary></indexterm>
<example id="ex.bif-upper">
<title>Builtin function UPPER</title>
<programlisting>
upper("Albert Einstein")      ->    "ALBERT EINSTEIN"
upper("abcdef", 4)            ->    "abcDEF"
upper("abcdef", 3, 2)         ->    "abCDef"
</programlisting>
</example>
</section>


<section id="bifUserid"><title>USERID</title>
<indexterm><primary>USERID function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>USERID</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>USERID</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/userid.svg" scale="50" />
</imageobject>
</mediaobject>

<para>The return value is the active user identification.</para>
</section>


<section id="bifValue"><title>VALUE</title>
<indexterm><primary>VALUE function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>VALUE</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>VALUE</secondary></indexterm>
<indexterm><primary>external variables</primary>
<secondary>access with VALUE function</secondary></indexterm>
<indexterm><primary>variable</primary>
<secondary>access with VALUE function</secondary></indexterm>
<indexterm><primary>getting value with VALUE</primary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/value.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the value of the symbol that
<emphasis role="italic">name</emphasis> (often constructed
dynamically) represents and optionally assigns a new value to it. By default,
VALUE refers to the current Rexx-variables environment, but other, external
collections of variables can be selected. If you use the function to refer
to Rexx variables, <emphasis role="italic">name</emphasis> must be a valid
Rexx symbol. (You can confirm this by using the SYMBOL function.) Lowercase
characters in <emphasis role="italic">name</emphasis> are
translated to uppercase for the local environment. For the global environment
lowercase characters are not translated because the global environment supports
mixed-case identifiers. Substitution in a compound name (see
<xref linkend="compsym" />)
occurs if possible.</para>

<para>If you specify <emphasis role="italic">newvalue</emphasis>,
the named variable is assigned this new
value. This does not affect the result returned; that is, the function returns
the value of <emphasis role="italic">name</emphasis> as it was before the new
assignment.</para>
<para>Here are some examples:</para>
<indexterm><primary>VALUE function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>VALUE function</secondary></indexterm>
<example id="ex.bif-value">
<title>Builtin function VALUE</title>
<programlisting>
/* After: Drop A3; A33=7; K=3; fred="K"; list.5="Hi" */
VALUE("a"k)     ->  "A3" /* looks up A3                */
VALUE("a"k||k)  ->  "7"
VALUE("fred")   ->  "K"  /* looks up FRED              */
VALUE(fred)     ->  "3"  /* looks up K                 */
VALUE(fred,5)   ->  "3"  /* looks up K and             */
                         /* then sets K=5              */
VALUE(fred)     ->  "5"  /* looks up K                 */
VALUE("LIST."k) ->  "Hi" /* looks up LIST.5            */
</programlisting>
</example>

<indexterm><primary>global variables</primary>
<secondary>access with VALUE function</secondary></indexterm>
<indexterm><primary>variable</primary>
<secondary>global</secondary></indexterm>
<indexterm><primary>variable</primary>
<secondary>external collections</secondary></indexterm>
<para>To use VALUE to manipulate environment variables,
<emphasis role="italic"> selector</emphasis> must
be the string &quot;ENVIRONMENT&quot; or an expression that evaluates to
&quot;ENVIRONMENT&quot;. In this case, the variable
<emphasis role="italic">name</emphasis> need not be a valid Rexx symbol.
Environment variables set by VALUE are not kept after program termination.
</para>
<para><emphasis role="bold">Restriction:</emphasis>
The values assigned to the variables
must not contain any character that is a hexadecimal zero ("00"X).
 For example: </para>
<programlisting>
Call VALUE "MYVAR", "FIRST" || "00"X || "SECOND", "ENVIRONMENT"
</programlisting>
<para>sets MYVAR to &quot;FIRST&quot;, truncating "00"x and "SECOND".</para>
<para>Here are some more examples: </para>
<example id="ex.bif-value-1">
<title>Builtin function VALUE</title>
<programlisting>
/* Given that an external variable FRED has a value of 4         */
share = "ENVIRONMENT"
say VALUE("fred",7,share)      /* says "4" and assigns           */
                               /* FRED a new value of 7          */

say VALUE("fred", ,share)      /* says "7"                       */

/* Accessing and changing Windows environment entries given that */
                               /* PATH=C:\EDIT\DOCS;             */
env = "ENVIRONMENT"
new = "C:\EDIT\DOCS;"
say value("PATH",new,env)   /* says "C:\WINDOWS" (perhaps)       */
                            /* and sets PATH = "C:\EDIT\DOCS;"   */

say value("PATH", ,env)     /* says "C:\EDIT\DOCS;"              */
</programlisting>
</example>

<para>To delete an environment variable use the Nil object as the
<emphasis role="italic">newvalue</emphasis>. To delete the environment
variable "MYVAR" specify: value("MYVAR", .NIL, "ENVIRONMENT"). If you specify
an empty string as the <emphasis role="italic">newvalue</emphasis> like in
value("MYVAR", &quot;&quot;, "ENVIRONMENT")
the value of the external environment variable is set to an
empty string which on Windows and *nix is not the same as deleting the
environment variable.</para>

<para>A selector called "WSHENGINE" is also available to the VALUE function
when a Rexx script is run in a Windows Script Host scripting context
(running via
cscript, wscript or as embedded code in HTML for the Microsoft
Internet Explorer). The only currently supported value is
"NAMEDITEMS". Calling VALUE with these parameters returns an array
with the names of the named items that were added at script start.</para>

<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
myArray = VALUE("NAMEDITEMS", ,"WSHENGINE")
</programlisting>

<para>The value NAMEDITEMS is read-only, writing to it is prohibited.</para>

<para>Object Rexx scripts running via the scripting engine (in WSH
context) can now call the default method of an object as a function
call with the object name.</para>

<para><emphasis role="bold">Example:</emphasis></para>

<para>The SESSION object of ASP (Active Server Pages) has the default
method VALUE. The usual (and recommended) way of using the SESSION
object would be to use</para>

<programlisting>
SESSION~VALUE("key","value").
</programlisting>

<para>Because VALUE is the default method, a function call

<programlisting>
SESSION("key","value")
SESSION~VALUE("key","value").
</programlisting>

causes an invocation of VALUE with the given arguments. For
objects that have the name of a Rexx function, an explicit call to
the default method must be made, because Rexx functions have priority
over this implicit method invocation mechanism.</para>

<note><title>Note</title>
<para>In contrast to OS/2, the Windows and *nix environments are unchanged after
program termination.</para></note>
<para>You can use the VALUE function to return a value to the global
environment directory. To do so, omit
<emphasis role="italic">newvalue</emphasis> and specify
<emphasis role="italic">selector</emphasis> as
the null string. The language processor sends the message
<emphasis role="italic">name</emphasis> (without
arguments) to the current environment object. The environment returns the
object identified by <emphasis role="italic">name</emphasis>. If there is
no such object, it returns, by default, the string
<emphasis role="italic">name</emphasis> with an added initial period
(an environment symbol--see <xref linkend="ensym" />).
</para>

<para>Here are some examples: </para>
<indexterm><primary>VALUE function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>VALUE function</secondary></indexterm>
<example id="ex.bif-value-3">
<title>Builtin function VALUE</title>
<programlisting>
/* Assume the environment name MYNAME identifies the string "Simon"    */
name = value("MYNAME", ,"") /* Sends MYNAME message to the environment */
name = .myname              /* Same as previous instruction            */
say "Hello," name           /* Produces: "Hello, Simon"                */
/* Assume the environment name NONAME does not exist.                  */
name = value("NONAME", ,"") /* Sends NONAME message to the environment */
say "Hello," name           /* Produces:  "Hello, .NONAME"             */
</programlisting>
</example>
<para>You can use the VALUE function to change a value in the Rexx environment
directory. Include a <emphasis role="italic">newvalue</emphasis> and specify
<emphasis role="italic">selector</emphasis> as the
null string. The language processor sends the message
<emphasis role="italic">name</emphasis> (with <computeroutput>=</computeroutput>
appended) and the single argument <emphasis role="italic">newvalue</emphasis>
to the current
environment object. After receiving this message, the environment identifies
the object <emphasis role="italic">newvalue</emphasis> by the name
<emphasis role="italic">name</emphasis>.</para>
<para>Here is an example: </para>
<example id="ex.bif-value-4">
<title>Builtin function VALUE</title>
<programlisting>
name = value("MYNAME","David","") /* Sends "MYNAME=("David") message  */
/* to the environment.                                                */
/* You could also use:                                                */
/*   call value "MYNAME","David",""                                   */
say "Hello," .myname              /* Produces:  "Hello, David"        */
</programlisting>
</example>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>If the VALUE function refers to an uninitialized Rexx variable,
the default value of the variable is always returned. The NOVALUE condition
<indexterm><primary>NOVALUE condition</primary>
<secondary>not raised by VALUE function</secondary></indexterm>
is not raised
because a reference to an external collection of variables never raises
NOVALUE.</para></listitem>
<listitem><para>The VALUE function is used when a variable contains the name
of another variable, or when a name is constructed dynamically. If you
specify <emphasis role="italic">name</emphasis> as a single literal string
and omit <emphasis role="italic">newvalue</emphasis> and
<emphasis role="italic">selector</emphasis>, the symbol is a constant and the
string between the quotation marks can usually replace the whole function call.
For example, <computeroutput>fred=VALUE("k");</computeroutput> is identical
with the assignment <computeroutput>fred=k;</computeroutput>, unless the
NOVALUE condition is trapped. See
<xref linkend="condtra" />.
</para></listitem>
</orderedlist>
</section>


<section id="bifVar"><title>VAR</title>
<indexterm><primary>VAR function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>VAR</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>VAR</secondary></indexterm>
<indexterm><primary>variable</primary>
<secondary>checking name</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/var.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns <computeroutput>1</computeroutput> if
<emphasis role="italic">name</emphasis> is the name of a variable (that is,
a symbol that has been assigned a value), or
<computeroutput>0</computeroutput>.</para>
<para>Here are some examples: </para>
<indexterm><primary>VAR function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>VAR function</secondary></indexterm>
<example id="ex.bif-var">
<title>Builtin function VAR</title>
<programlisting>
/* Following: DROP A.3; J=3  */
VAR("J")       -> 1
VAR(J)         -> 0  /* has tested "3"    */
VAR("a.j")     -> 0  /* has tested "A.3"  */
VAR(2)         -> 0  /* a constant symbol */
VAR("*")       -> 0  /* an invalid symbol */
</programlisting>
</example>
</section>


<section id="bifVerify"><title>VERIFY</title>
<indexterm><primary>VERIFY function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>VERIFY</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>VERIFY</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>verifying contents of</secondary></indexterm>
<indexterm><primary>verifying contents of a string</primary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/verify.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a number that, by default, indicates whether
<emphasis role="italic">string</emphasis> is
composed only of characters from <emphasis role="italic">reference</emphasis>.
It returns <computeroutput>0</computeroutput> if
all characters in <emphasis role="italic">string</emphasis> are in
<emphasis role="italic">reference</emphasis>, or returns the
position of the first character in <emphasis role="italic">string</emphasis>
that is not in <emphasis role="italic">reference</emphasis>.</para>
<para>The <emphasis role="italic">option</emphasis> can be either
<computeroutput>Nomatch</computeroutput> (the
default) or <computeroutput>Match</computeroutput>. (Only the capitalized
and highlighted letter is needed. All characters following it are ignored,
and it can be in uppercase or lowercase characters.) If you specify
<computeroutput>Match</computeroutput>, the function returns the position
of the first
character in the <emphasis role="italic">string</emphasis> that is in
<emphasis role="italic">reference</emphasis>, or returns
<computeroutput>0</computeroutput> if none of the characters are found.</para>
<para>The default for <emphasis role="italic">start</emphasis> is
<computeroutput>1</computeroutput>; thus, the search starts
at the first character of <emphasis role="italic">string</emphasis>.
You can override this by specifying a different
<emphasis role="italic">start</emphasis> point, which must be a positive whole
number.</para>
<para>The default for <emphasis role="italic">length</emphasis> is the length of
the string from <emphasis role="italic">start</emphasis> to the end of the
string. Thus, the search proceeds to the end of the receiving string.  You can
override this by specifying a different
<emphasis role="italic">length</emphasis>, which must be a non-negative whole
number.
</para>
<para>If <emphasis role="italic">string</emphasis> is null, the function
returns <computeroutput>0</computeroutput>, regardless
of the value of the third argument. Similarly, if
<emphasis role="italic">start</emphasis> is greater
than <computeroutput>LENGTH(string)</computeroutput>, the function returns
<computeroutput>0</computeroutput>. If
<emphasis role="italic">reference</emphasis> is null, the function returns
<computeroutput>0</computeroutput> if you specify
<computeroutput>Match</computeroutput>; otherwise, the function returns the
<emphasis role="italic">start</emphasis> value.</para>
<para>Here are some examples:</para>
<indexterm><primary>VERIFY function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>VERIFY function</secondary></indexterm>
<example id="ex.bif-verify">
<title>Builtin function VERIFY</title>
<programlisting>
VERIFY("123","1234567890")             ->    0
VERIFY("1Z3","1234567890")             ->    2
VERIFY("AB4T","1234567890")            ->    1
VERIFY("AB4T","1234567890","M")        ->    3
VERIFY("AB4T","1234567890","N")        ->    1
VERIFY("1P3Q4","1234567890", ,3)       ->    4
VERIFY("123","",N,2)                   ->    2
VERIFY("ABCDE","", ,3)                 ->    3
VERIFY("AB3CD5","1234567890","M",4)    ->    6
VERIFY("ABCDEF","ABC","N",2,3)         ->    4
VERIFY("ABCDEF","ADEF","M",2,3)        ->    4
</programlisting>
</example>
</section>


<section id="bifWord"><title>WORD</title>
<indexterm><primary>WORD function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>WORD</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>WORD</secondary></indexterm>
<indexterm><primary>extracting</primary>
<secondary>word from a string</secondary></indexterm>
<indexterm><primary>locating</primary>
<secondary>word in another string</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/word.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the <emphasis role="italic">n</emphasis>th whitespace-delimited
word in
<emphasis role="italic">string</emphasis> or returns the null string if less
than <emphasis role="italic">n</emphasis> words are in
<emphasis role="italic">string</emphasis>. <emphasis role="italic">n</emphasis>
must be a positive whole number. This function is equal to
SUBWORD(<emphasis role="italic">string</emphasis>,
<emphasis role="italic">n</emphasis>,1).</para>
<para>Here are some examples:</para>
<indexterm><primary>WORD function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>WORD function</secondary></indexterm>
<example id="ex.bif-word">
<title>Builtin function WORD</title>
<programlisting>
WORD("Now is the time",3)    ->    "the"
WORD("Now is the time",5)    ->    ""
</programlisting>
</example>
</section>


<section id="bifWordindex"><title>WORDINDEX</title>
<indexterm><primary>WORDINDEX function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>WORDINDEX</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>WORDINDEX</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/wordindex.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the position of the first character in the
<emphasis role="italic">n</emphasis>th whitespace-delimited word in <emphasis
role="italic">string</emphasis> or returns
<computeroutput>0</computeroutput> if less than
<emphasis role="italic">n</emphasis> words
are in <emphasis role="italic">string</emphasis>.
<emphasis role="italic">n</emphasis> must be a positive whole number.</para>
<para>Here are some examples:</para>
<indexterm><primary>WORDINDEX function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>WORDINDEX function</secondary></indexterm>
<example id="ex.bif-wordindex">
<title>Builtin function WORDINDEX</title>
<programlisting>
WORDINDEX("Now is the time",3)    ->    8
WORDINDEX("Now is the time",6)    ->    0
</programlisting>
</example>
</section>


<section id="bifWordlength"><title>WORDLENGTH</title>
<indexterm><primary>WORDLENGTH function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>WORDLENGTH</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>WORDLENGTH</secondary></indexterm>
<indexterm><primary>finding</primary>
<secondary>word length</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/wordlength.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the length of the <emphasis role="italic">n</emphasis>th
whitespace-delimited word in the <emphasis role="italic">string</emphasis> or
returns <computeroutput>0</computeroutput> if less than
<emphasis role="italic">n</emphasis> words are in the
<emphasis role="italic">string</emphasis>.
<emphasis role="italic">n</emphasis> must be a positive whole number.</para>
<para>Here are some examples:</para>
<indexterm><primary>WORDLENGTH function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>WORDLENGTH function</secondary></indexterm>
<example id="ex.bif-wordlength">
<title>Builtin function WORDLENGTH</title>
<programlisting>
WORDLENGTH("Now is the time",2)       ->    2
WORDLENGTH("Now comes the time",2)    ->    5
WORDLENGTH("Now is the time",6)       ->    0
</programlisting>
</example>
</section>


<section id="bifWordpos"><title>WORDPOS (Word Position)</title>
<indexterm><primary>WORDPOS function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>WORDPOS</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>WORDPOS</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>locating in a string</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/wordpos.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the word number of the first word of
<emphasis role="italic">phrase</emphasis> found in
<emphasis role="italic">string</emphasis> or returns
<computeroutput>0</computeroutput> if <emphasis role="italic">phrase</emphasis>
contains no words or if <emphasis role="italic">phrase</emphasis> is not found.
Several whitespace characters between words in either
<emphasis role="italic">phrase</emphasis> or
<emphasis role="italic">string</emphasis> are treated as a single blank for
the comparison, but otherwise the words must match exactly.</para>
<para>By default, the search starts at the first word in
<emphasis role="italic">string</emphasis>. You
can override this by specifying <emphasis role="italic">start</emphasis>
(which must be positive), the
word at which to start the search.</para>
<para>Here are some examples:</para>
<indexterm><primary>WORDPOS function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>WORDPOS function</secondary></indexterm>
<example id="ex.bif-wordpos">
<title>Builtin function WORDPOS</title>
<programlisting>
WORDPOS("the","now is the time")              ->  3
WORDPOS("The","now is the time")              ->  0
WORDPOS("is the","now is the time")           ->  2
WORDPOS("is   the","now is the time")         ->  2
WORDPOS("is   time ","now is   the time")     ->  0
WORDPOS("be","To be or not to be")            ->  2
WORDPOS("be","To be or not to be",3)          ->  6
</programlisting>
</example>
</section>


<section id="bifWords"><title>WORDS</title>
<indexterm><primary>WORDS function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>WORDS</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>WORDS</secondary></indexterm>
<indexterm><primary>counting</primary>
<secondary>words in a string</secondary></indexterm>
<indexterm><primary>extracting</primary>
<secondary>words from a string</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>counting in a string</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>extracting from a string</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/words.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the number of whitespace-delimited words in
<emphasis role="italic">string</emphasis>.</para>
<para>Here are some examples:</para>
<indexterm><primary>WORDS function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>WORDS function</secondary></indexterm>
<example id="ex.bif-words">
<title>Builtin function WORDS</title>
<programlisting>
WORDS("Now is the time")    ->    4
WORDS(" ")                  ->    0
</programlisting>
</example>
</section>


<section id="bifX2b"><title>X2B (Hexadecimal to Binary)</title>
<indexterm><primary>X2B function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>X2B</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>X2B</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>hexadecimal to binary</secondary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>to binary, converting with X2B</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/x2b.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a string, in character format, that represents
<emphasis role="italic">hexstring</emphasis> converted
to binary. The <emphasis role="italic">hexstring</emphasis> is a string of
hexadecimal characters. It
can be of any length.  Each hexadecimal character is converted to a string
of 4 binary digits. You can optionally include whitespace characters in
<emphasis role="italic">hexstring</emphasis> (at
byte boundaries only, not leading or trailing) to improve readability; they
are ignored.</para>
<para>The returned string has a length that is a multiple of 4, and does not
include any whitespace.</para>
<para>If <emphasis role="italic">hexstring</emphasis> is null, the function
returns a null string.</para>
<para>Here are some examples:</para>
<indexterm><primary>X2B function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>X2B function</secondary></indexterm>
<example id="ex.bif-x2b">
<title>Builtin function X2B</title>
<programlisting>
X2B("C3")        ->  "11000011"
X2B("7")         ->  "0111"
X2B("1 C1")      ->  "000111000001"
</programlisting>
</example>
<para>You can combine X2B with the functions D2X and C2X to convert numbers or
character strings into binary form.</para>
<para>Here are some examples: </para>
<example id="ex.bif-x2b-1">
<title>Builtin function X2B</title>
<programlisting>
X2B(C2X("C3"x))  ->  "11000011"
X2B(D2X("129"))  ->  "10000001"
X2B(D2X("12"))   ->  "1100"
</programlisting>
</example>
</section>


<section id="bifX2c"><title>X2C (Hexadecimal to Character)</title>
<indexterm><primary>X2C function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>X2C</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>X2C</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>hexadecimal to character</secondary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>to character, converting with X2C</secondary></indexterm>
<indexterm><primary>packing a string with X2C</primary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/x2c.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a string, in character format, that represents
<emphasis role="italic">hexstring</emphasis> converted
to character. The returned string has half as many bytes as the original
<emphasis role="italic">hexstring</emphasis>.
<emphasis role="italic">hexstring</emphasis> can be of any length. If
necessary, it is padded with a leading zero to make an even number
of hexadecimal digits.</para>
<para>You can optionally include whitespace characters in
<emphasis role="italic">hexstring</emphasis> (at byte boundaries
only, not leading or trailing) to improve readability; they are ignored.</para>
<para>If <emphasis role="italic">hexstring</emphasis> is null, the function
returns a null string.</para>
<para>Here are some examples:</para>
<indexterm><primary>X2C function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>X2C function</secondary></indexterm>
<example id="ex.bif-x2c">
<title>Builtin function X2C</title>
<programlisting>
X2C("4865 6c6c 6f") ->  "Hello"     /*  ASCII             */
X2C("3732 73")      ->  "72s"       /*  ASCII             */
</programlisting>
</example>
</section>


<section id="bifX2d"><title>X2D (Hexadecimal to Decimal)</title>
<indexterm><primary>X2D function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>X2D</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>X2D</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>hexadecimal to decimal</secondary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>to decimal, converting with X2D</secondary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/x2d.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns the decimal representation of
<emphasis role="italic">hexstring</emphasis>.  The
<emphasis role="italic">hexstring</emphasis> is a string of hexadecimal
characters. If the result cannot be expressed
as a whole number, an error occurs. That is, the result must not have more
digits than the current setting of NUMERIC DIGITS.</para>
<para>You can optionally include whitespace characters in
<emphasis role="italic">hexstring</emphasis> (at byte boundaries
only, not leading or trailing) to aid readability; they are ignored.</para>
<para>If <emphasis role="italic">hexstring</emphasis> is null, the function
returns <computeroutput>0</computeroutput>.</para>
<para>If you do not specify <emphasis role="italic">n</emphasis>, the
<emphasis role="italic">hexstring</emphasis> is processed as
an unsigned binary number.</para>
<para>Here are some examples:</para>
<indexterm><primary>X2D function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>X2D function</secondary></indexterm>
<example id="ex.bif-x2d">
<title>Builtin function X2D</title>
<programlisting>
X2D("0E")        ->    14
X2D("81")        ->    129
X2D("F81")       ->    3969
X2D("FF81")      ->    65409
X2D("46 30"X)    ->    240          /*  ASCII   */
X2D("66 30"X)    ->    240          /*  ASCII   */
</programlisting>
</example>
<para>If you specify <emphasis role="italic">n</emphasis>, the string is
taken as a signed number expressed in <emphasis role="italic">n</emphasis>
hexadecimal digits. If the leftmost bit is off, then the number
is positive; otherwise, it is a negative number. In both cases it is converted
to a whole number, which can be negative. If
<emphasis role="italic">n</emphasis> is <computeroutput>0</computeroutput>,
the function returns <computeroutput>0</computeroutput>.</para>
<para>If necessary, <emphasis role="italic">hexstring</emphasis> is padded
on the left with <computeroutput>0</computeroutput> characters
(not &quot;sign-extended&quot;), or truncated on the left to
<emphasis role="italic">n</emphasis> characters.</para>
<para>Here are some examples: </para>
<indexterm><primary>X2D function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>X2D function</secondary></indexterm>
<example id="ex.bif-x2d-1">
<title>Builtin function X2D</title>
<programlisting>
X2D("81",2)      ->    -127
X2D("81",4)      ->    129
X2D("F081",4)    ->    -3967
X2D("F081",3)    ->    129
X2D("F081",2)    ->    -127
X2D("F081",1)    ->    1
X2D("0031",0)    ->    0
</programlisting>
</example>
</section>


<section id="bifXrange"><title>XRANGE (Hexadecimal Range)</title>
<indexterm><primary>XRANGE function</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>functions</primary>
<secondary>XRANGE</secondary></indexterm>
<indexterm><primary>built-in functions</primary>
<secondary>XRANGE</secondary></indexterm>
<indexterm><primary>collating sequence using XRANGE</primary></indexterm>
<indexterm><primary>sequence, collating using XRANGE</primary></indexterm>

<mediaobject>
<imageobject>
<imagedata fileref="images/bif/xrange.svg" scale="50" />
</imageobject>
</mediaobject>

<para>Returns a string of all valid 1-byte encodings (in ascending order)
between and including the values <emphasis role="italic">start</emphasis> and
<emphasis role="italic">end</emphasis>. The default value
for <emphasis role="italic">start</emphasis> is
<computeroutput>"00"x</computeroutput>, and the default value for
<emphasis role="italic">end</emphasis> is
<computeroutput>"FF"x</computeroutput>. If
<emphasis role="italic">start</emphasis> is greater than
<emphasis role="italic">end</emphasis>, the values wrap from
<computeroutput>"FF"x</computeroutput> to
<computeroutput>"00"x</computeroutput>. If specified,
<emphasis role="italic">start</emphasis> and
<emphasis role="italic">end</emphasis> must be single characters.</para>
<para>Here are some examples:</para>
<indexterm><primary>XRANGE function</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>XRANGE function</secondary></indexterm>
<example id="ex.bif-xrange">
<title>Builtin function XRANGE</title>
<programlisting>
XRANGE("a","f")      ->   "abcdef"
XRANGE("03"x,"07"x)  ->   "0304050607"x
XRANGE(,"04"x)       ->   "0001020304"x
XRANGE("FE"x,"02"x)  ->   "FEFF000102"x
XRANGE("i","j")      ->   "ij"                   /* ASCII  */
</programlisting>
</example>
</section>
</section>
</chapter>
