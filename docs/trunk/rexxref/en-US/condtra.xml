<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "rexxref.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: Reference XML File
    #
    # Copyright (c) 2005-2022, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<chapter id="condtra"><title>Conditions and Condition Traps</title>
<indexterm><primary>condition</primary>
<secondary>trapping of</secondary></indexterm>
<indexterm><primary>trap conditions</primary>
<secondary>explanation</secondary></indexterm>
<indexterm><primary>trap conditions</primary>
<secondary>how to</secondary></indexterm>
<indexterm><primary>flow of control</primary>
<secondary>unusual, with CALL</secondary></indexterm>
<indexterm><primary>flow of control</primary>
<secondary>unusual, with SIGNAL</secondary></indexterm>
<indexterm><primary>GOTO, unusual</primary></indexterm>
<indexterm><primary>unusual change in flow of control</primary></indexterm>
<para>A condition is an event or state that CALL ON or SIGNAL ON can trap. A
condition trap can modify the flow of execution in a Rexx program. Condition
traps are turned on or off using the ON or OFF subkeywords of the
<xref linkend="keySignal" xrefstyle="select:title"/> and
<xref linkend="keyCall" xrefstyle="select:title"/> instructions.
</para>

<mediaobject>
<imageobject>
<imagedata fileref="images/keywords/call_on.svg" scale="55" />
</imageobject>
</mediaobject>
<mediaobject>
<imageobject>
<imagedata fileref="images/keywords/call_off.svg" scale="55" />
</imageobject>
</mediaobject>

<mediaobject>
<imageobject>
<imagedata fileref="images/keywords/signal_on.svg" scale="55" />
</imageobject>
</mediaobject>
<mediaobject>
<imageobject>
<imagedata fileref="images/keywords/signal_off.svg" scale="55" />
</imageobject>
</mediaobject>

<indexterm><primary>condition</primary>
<secondary>definition</secondary></indexterm>
<para><emphasis role="italic">condition</emphasis>,
<emphasis role="italic">usercondition</emphasis>, and
<emphasis role="italic">trapname</emphasis> are single
symbols that are taken as constants. Following one of these instructions,
a condition trap is set to either ON (enabled) or OFF (disabled). The initial
setting for all condition traps is OFF.</para>
<para>If a condition trap is enabled and the specified
<emphasis role="italic">condition</emphasis> or
<emphasis role="italic">usercondition</emphasis> occurs, control passes
to the routine or label <emphasis role="italic">trapname</emphasis>
if you have specified <emphasis role="italic">trapname</emphasis>.
Otherwise, control passes to
the routine or label <emphasis role="italic">usercondition</emphasis> or
<emphasis role="italic">condition</emphasis>. CALL or
<indexterm><primary>syntax</primary>
<secondary>error</secondary>
<tertiary>trapping with SIGNAL instruction</tertiary></indexterm>
SIGNAL is used, depending on whether the most recent trap for the condition
was set using CALL ON or SIGNAL ON, respectively.
</para>
<para>If you use CALL, the <emphasis role="italic">trapname</emphasis>
can be an internal label, a built-in function, or an external routine.
When calling <emphasis role="italic">trapname</emphasis>, the current
<xref linkend="conobj" xrefstyle="select:title"/> is supplied as an
argument.
</para>
<para>If you use SIGNAL, the
<emphasis role="italic">trapname</emphasis> can only
be an internal label.
</para>
<para>The conditions and their corresponding events that can be trapped are:</para>
<variablelist>
<varlistentry><term>ANY
<indexterm><primary>ANY subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>ANY subkeyword</primary>
<secondary>in a CALL instruction</secondary></indexterm>
<indexterm><primary>action taken when a condition is trapped</primary></indexterm>
<indexterm><primary>condition</primary>
<secondary>ANY</secondary></indexterm>
</term>
<listitem><para>
traps any condition that a more specific condition trap does not trap.
For example, if NOVALUE is raised and there is no NOVALUE trap enabled, but
there is a SIGNAL ON ANY trap, the ANY trap is called for the NOVALUE condition.
For example, a CALL ON ANY trap is ignored if NOVALUE is raised because CALL
ON NOVALUE is not allowed.
</para></listitem></varlistentry>

<varlistentry><term>ERROR
<indexterm><primary>ERROR subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>ERROR subkeyword</primary>
<secondary>in a CALL instruction</secondary></indexterm>
<indexterm><primary>condition</primary>
<secondary>ERROR</secondary></indexterm>
<indexterm><primary>error</primary>
<secondary>trapping</secondary></indexterm>
</term>
<listitem><para>raised if a command indicates an error condition upon return. It is
<indexterm><primary>command</primary>
<secondary>errors, trapping</secondary></indexterm>
also raised if any command indicates failure and none of the following is
active:
<itemizedlist>
<listitem><para>CALL ON FAILURE</para></listitem>
<listitem><para>SIGNAL ON FAILURE</para></listitem>
<listitem><para>CALL ON ANY</para></listitem>
<listitem><para>SIGNAL ON ANY</para></listitem></itemizedlist>
The condition
is raised at the end of the clause that called the command but is ignored
if the ERROR condition trap is already in the delayed state.
<indexterm><primary>delayed state</primary>
<secondary>description</secondary></indexterm>
The delayed state is the state of a condition trap when the condition has
been raised but the trap has not yet been reset to the enabled (ON) or disabled
(OFF) state.
</para>
<para>If the package contains an
<xref linkend="optionsd" xrefstyle="select:title"/> ERROR SYNTAX directive and
ERROR is not trapped with CALL/SIGNAL ON/OFF ERROR/ANY, a SYNTAX condition is
raised instead.
</para>
</listitem></varlistentry>

<varlistentry><term>FAILURE
<indexterm><primary>FAILURE subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>FAILURE subkeyword</primary>
<secondary>in a CALL instruction</secondary></indexterm>
<indexterm><primary>condition</primary>
<secondary>FAILURE</secondary></indexterm>
</term>
<listitem><para>raised if a command indicates a failure condition upon return. The condition
is raised at the end of the clause that called the command but is ignored
if the FAILURE condition trap is already in the delayed state. </para>
<para>An attempt
to enter a command to an unknown subcommand environment also raises a FAILURE
condition.
</para>
<para>If the package contains an
<xref linkend="optionsd" xrefstyle="select:title"/> FAILURE SYNTAX directive and
FAILURE is not trapped with CALL/SIGNAL ON/OFF FAILURE/ANY, a SYNTAX condition is
raised instead.
</para>
</listitem></varlistentry>

<varlistentry><term>HALT
<indexterm><primary>HALT subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>HALT subkeyword</primary>
<secondary>in a CALL instruction</secondary></indexterm>
<indexterm><primary>halt, trapping</primary></indexterm>
<indexterm><primary>condition</primary>
<secondary>HALT</secondary></indexterm>
</term>
<listitem><para>raised if an external attempt is made to interrupt and end execution
of the program. The condition is usually raised at the end of the clause that
was processed when the external interruption occurred. When a Rexx program
is running in a full-screen or command prompt session, the Ctrl+Break key
combination raises the halt condition. However, if Ctrl+Break is pressed while
a command or non-Rexx external function is processing,
the command or function ends. </para>
<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>Application programs that use the Rexx language processor might use the
RXHLT exit or the RexxStart programming interface to halt the execution of
a Rexx macro. (See the
<citetitle pubwork="book">Open Object Rexx: Application Programming Interfaces</citetitle>
for details about exits.)</para></listitem>
<listitem><para>Only SIGNAL ON HALT or CALL ON HALT can trap error 4, described
in <xref linkend="errnum" />.</para></listitem>
</orderedlist>
</listitem></varlistentry>

<varlistentry><term>LOSTDIGITS
<indexterm><primary>LOSTDIGITS subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>condition</primary>
<secondary>LOSTDIGITS</secondary></indexterm>
</term>
<listitem><para>raised if a number used in an arithmetic operation has more digits than
the current setting of NUMERIC DIGITS. Leading zeros are not counted in this
comparison. You can specify the LOSTDIGITS condition only for SIGNAL ON.
</para>
<para>If the package contains an
<xref linkend="optionsd" xrefstyle="select:title"/> LOSTDIGITS SYNTAX directive and
LOSTDIGITS is not trapped with SIGNAL ON/OFF LOSTDIGITS/ANY, a SYNTAX condition is
raised instead.
</para>
</listitem></varlistentry>

<varlistentry><term>NOMETHOD
<indexterm><primary>NOMETHOD subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>condition</primary>
<secondary>NOMETHOD</secondary></indexterm>
</term>
<listitem><para>raised if an object receives a message for which it has no method defined,
and the object does not have an UNKNOWN method. You can specify the NOMETHOD
condition only for SIGNAL ON.
</para></listitem></varlistentry>

<varlistentry><term>NOSTRING
<indexterm><primary>NOSTRING subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>condition</primary>
<secondary>NOSTRING</secondary></indexterm>
</term>
<listitem><para>raised when the language processor requires a string value from an object
and the object does not directly provide a string value. See
<xref linkend="reqstr" /> for
more information. You can specify the NOSTRING condition only for SIGNAL ON.
</para>
<para>If the package contains an
<xref linkend="optionsd" xrefstyle="select:title"/> NOSTRING SYNTAX directive and
NOSTRING is not trapped with SIGNAL ON/OFF NOSTRING/ANY, a SYNTAX condition is
raised instead.
</para>
</listitem></varlistentry>

<varlistentry><term>NOTREADY
<indexterm><primary>NOTREADY subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>condition</primary>
<secondary>NOTREADY</secondary></indexterm>
</term>
<listitem><para>raised if an error occurs during an input or output operation.
See <xref linkend="stmerr" />. This
condition is ignored if the NOTREADY condition trap is already in the
delayed state.
</para>
<para>If the package contains an
<xref linkend="optionsd" xrefstyle="select:title"/> NOTREADY SYNTAX directive and
NOTREADY is not trapped with CALL/SIGNAL ON/OFF NOTREADY/ANY, a SYNTAX condition is
raised instead.
</para>
</listitem></varlistentry>

<varlistentry><term id="uninit">NOVALUE
<indexterm><primary>NOVALUE subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>condition</primary>
<secondary>NOVALUE</secondary></indexterm>
</term>
<listitem><para>raised if an uninitialized variable is used as:
<itemizedlist>
<listitem><para>A term in an expression</para></listitem>
<listitem><para>The <emphasis role="italic">name</emphasis> following the
VAR subkeyword of a PARSE instruction</para></listitem>
<listitem><para>A variable reference in a parsing template, an EXPOSE
instruction, a PROCEDURE instruction, or a DROP instruction</para></listitem>
<listitem><para>A method selection override specifier in a message term</para></listitem></itemizedlist>
</para>
<para><emphasis role="bold">Notes:</emphasis></para>
<para>NOVALUE is not raised
for any uninitialized variables in tails in compound variables.
</para>
<para>If the package contains an
<xref linkend="optionsd" xrefstyle="select:title"/> NOVALUE SYNTAX directive and
NOVALUE is not trapped with SIGNAL ON/OFF NOVALUE/ANY, a SYNTAX condition is
raised instead.
</para>
<para>
<example id="ex.signal-novalue">
<title>NOVALUE not raised for stems</title>
<programlisting>
/* The following does not raise NOVALUE. */
signal on novalue
a.=0
say a.z
say "NOVALUE is not raised."
exit

novalue:
say "NOVALUE is raised."
</programlisting>
</example>
You can specify this condition
only for SIGNAL ON.</para>
</listitem></varlistentry>
<varlistentry><term>SYNTAX
<indexterm><primary>SYNTAX subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>condition</primary>
<secondary>SYNTAX</secondary></indexterm>
</term>
<listitem><para>raised if any language-processing error is detected while the program
is running. This includes all kinds of processing errors:
<itemizedlist>
<listitem><para>True syntax errors</para></listitem>
<listitem><para>&quot;Run-time&quot; errors (such as attempting an arithmetic operation
on nonnumeric terms)</para></listitem>
<listitem><para>Syntax errors propagated from higher call or method invocation
levels</para></listitem>
<listitem><para>Untrapped HALT conditions</para></listitem>
<listitem><para>Untrapped NOMETHOD conditions</para></listitem></itemizedlist>
You can specify this condition only for SIGNAL ON.</para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>SIGNAL ON SYNTAX cannot trap the errors 3 and 5.</para></listitem>
<listitem><para>SIGNAL ON SYNTAX can trap the errors 6 and 30 only if they occur during
the execution of an INTERPRET instruction.</para></listitem>
</orderedlist>
<para>For information on these errors, refer to
<xref linkend="errnum" />.</para>
</listitem></varlistentry>
<varlistentry><term>USER
<indexterm><primary>USER subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>USER subkeyword</primary>
<secondary>in a CALL instruction</secondary></indexterm>
<indexterm><primary>condition</primary>
<secondary>USER</secondary></indexterm>
</term>
<listitem><para>raised if a condition specified on the USER option of CALL ON or SIGNAL
ON occurs. USER conditions are raised by a RAISE instruction that specifies
a USER option with the same <emphasis role="italic">usercondition</emphasis>
name. The specified <emphasis role="italic">usercondition</emphasis> can be
any symbol, including those specified as possible
values for <emphasis role="italic">condition</emphasis>.
</para></listitem></varlistentry>
</variablelist>
<indexterm><primary>condition</primary>
<secondary>traps, notes</secondary></indexterm>
<para>Any ON or OFF reference to a condition trap replaces the previous state
(ON, OFF, or DELAY, and any
<indexterm><primary>trapname</primary></indexterm>
<emphasis role="italic">trapname</emphasis>) of that condition trap. Thus,
a CALL ON HALT replaces any current SIGNAL ON HALT (and a SIGNAL ON HALT replaces
any current CALL ON HALT), a CALL ON or SIGNAL ON with a new trap name replaces
any previous trap name, and any OFF reference disables the trap for CALL or
SIGNAL.</para>

<section id="atwcnt"><title>Action Taken when a Condition Is Not Trapped</title>
<indexterm><primary>condition</primary>
<secondary>action taken when not trapped</secondary></indexterm>
<indexterm><primary>action taken when a condition is not trapped</primary></indexterm>
<para>When a condition trap is currently disabled (OFF) and the specified condition
occurs, the default action depends on the condition:</para>
<itemizedlist>
<listitem><para>For HALT and NOMETHOD, a SYNTAX condition is raised with the appropriate
Rexx error number.</para></listitem>
<listitem><para>For SYNTAX conditions, the clause in error is terminated, and a SYNTAX
condition is propagated to each CALL instruction, INTERPRET instruction, message
instruction, or clause with function or message invocations active at the
time of the error, terminating each instruction if a SYNTAX trap is not active
at the instruction level. If the SYNTAX condition is not trapped at any of
the higher levels, processing stops, and a message (see
<xref linkend="errnum" />)
describing the nature of the event that occurred usually indicates the
condition.</para></listitem>
<listitem><para>For all other conditions, the condition is ignored and its state remains
OFF.</para></listitem></itemizedlist>
</section>

<section id="acttaken"><title>Action Taken when a Condition Is Trapped</title>
<indexterm><primary>action taken when a condition is trapped</primary></indexterm>
<indexterm><primary>condition</primary>
<secondary>action taken when trapped</secondary></indexterm>
<para>When a condition trap is currently enabled (ON) and the specified condition
occurs, a CALL <emphasis role="italic">trapname</emphasis> or SIGNAL
<emphasis role="italic">trapname</emphasis> instruction is
processed automatically. You can specify the
<emphasis role="italic">trapname</emphasis> after the NAME
subkeyword of the CALL ON or SIGNAL ON instruction. If you do not specify
a <emphasis role="italic">trapname</emphasis>, the name of the condition itself
(for example, ERROR or FAILURE) is used.</para>
<para>For example, the instruction
<computeroutput>call on error</computeroutput> enables the condition
trap for the ERROR condition. If the condition occurred, then a call to the
routine identified by the name ERROR is made. The instruction
<computeroutput>call on error name commanderror</computeroutput>
would enable the trap and call the routine COMMANDERROR
if the condition occurred, and the caller usually receives an indication of
failure.</para>
<para>The sequence of events, after a condition has been trapped, varies depending
on whether a SIGNAL or CALL is processed: </para>
<itemizedlist>
<listitem><para>If the action taken is a SIGNAL, execution of the current instruction
ceases immediately, the condition is disabled (set to OFF), and
<xref linkend="keySignal" xrefstyle="select:title"/> proceeds as usually.
</para>
<para>If any new occurrence of the condition
is to be trapped, a new CALL ON or SIGNAL ON instruction for the condition
is required to re-enable it when the label is reached. For example, if SIGNAL
ON SYNTAX is enabled when a SYNTAX condition occurs, a usual syntax error
termination occurs if the SIGNAL ON SYNTAX label name is not found.</para></listitem>
<listitem><para>If the action taken is a CALL, the
<xref linkend="keyCall" xrefstyle="select:title"/> <emphasis role="italic">trapname</emphasis>
proceeds in the usual way when the instruction completes.
The call does not affect the special variable RESULT. If the routine should
RETURN any data, that data is ignored. </para>
<para>When the condition is raised, and
before the CALL is made, the condition trap is put into a delayed state. This
state persists until the RETURN from the CALL, or until an explicit CALL (or
SIGNAL) ON (or OFF) is made for the condition. This delayed state prevents
a premature condition trap at the start of the routine called to process a
condition trap. When a condition trap is in the delayed state, it remains
enabled, but if the condition is raised again, it is either ignored (for ERROR
and FAILURE) or (for the other conditions) any action (including the updating
of the condition information) is delayed until one of the following events
occurs:
<orderedlist>
<listitem><para>A CALL ON or SIGNAL ON for the delayed condition is processed. In this
case, a CALL or SIGNAL takes place immediately after the new CALL ON or SIGNAL
ON instruction has been processed.</para></listitem>
<listitem><para>A CALL OFF or SIGNAL OFF for the delayed condition is processed. In this
case, the condition trap is disabled and the default action for the condition
occurs at the end of the CALL OFF or SIGNAL OFF instruction.</para></listitem>
<listitem><para>A RETURN is made from the subroutine.  In this case, the condition trap
is no longer delayed and the subroutine is called again immediately.</para></listitem>
</orderedlist>
On RETURN from the CALL, the original flow of execution is resumed,
that is, the flow is not affected by the CALL.</para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>In all cases, the condition is raised immediately upon detection. If SIGNAL
ON traps the condition, the current instruction is ended, if necessary. Therefore,
the instruction during which an event occurs can only be partly processed.
For example, if SYNTAX is raised during the evaluation of the expression in
an assignment, the assignment does not take place. Note that the CALL for
traps for which CALL ON is enabled can only occur at clause boundaries. If
these conditions arise in the middle of an INTERPRET instruction, execution
of INTERPRET can be interrupted and resumed later. Similarly, other instructions,
for example DO or SELECT, can be temporarily interrupted by a CALL at a clause
boundary.</para></listitem>
<listitem><para>
The state (ON, OFF, or DELAY, and any
<emphasis role="italic">trapname</emphasis>)
of each condition trap is saved on entry to a subroutine and is then restored
on RETURN.  This means that CALL ON, CALL OFF, SIGNAL ON, and SIGNAL OFF can
be used in a subroutine without affecting the conditions set up by the caller.
See <xref linkend="keyCall" /> for details of other information that is saved during
a subroutine call.</para></listitem>
<listitem><para>The state of condition traps is not affected when an external routine
is called by a CALL, even if the external routine is a Rexx program.  On entry
to any Rexx program, all condition traps have an initial setting of OFF.</para></listitem>
<listitem><para>While user input is processed during interactive tracing, all condition
traps are temporarily set OFF. This prevents any unexpected transfer of control&mdash;for
example, should the user accidentally use an uninitialized variable while
SIGNAL ON NOVALUE is active. For the same reason, a syntax error during interactive
tracing does not cause the exit from the program but is trapped specially
and then ignored after a message is given.</para></listitem>
<listitem><para>The system interface detects certain execution errors either before the
execution of the program starts or after the program has ended. SIGNAL ON
SYNTAX cannot trap these errors.</para></listitem>
</orderedlist>
<para>Note that a label is a clause consisting
of a single symbol followed by a colon. Any number of successive clauses can
be labels; therefore, several labels are allowed before another type of clause.
</para></listitem>
</itemizedlist>
</section>

<section id="coninfo"><title>Condition Information</title>
<indexterm><primary>condition</primary>
<secondary>information</secondary>
<tertiary>described</tertiary></indexterm>
<para>When a condition is trapped and causes a SIGNAL or CALL, this becomes the
current trapped condition, and certain condition information associated with
it is recorded. You can inspect this information by using the
<xref linkend="bifCondition" xrefstyle="select:title"/> built-in function.
</para>

<para>The condition information includes: </para>
<itemizedlist>
<listitem><para>The name of the current trapped condition</para></listitem>
<listitem><para>The name of the instruction processed as a result of the condition trap
(CALL or SIGNAL)</para></listitem>
<listitem><para>The status of the trapped condition</para></listitem>
<listitem><para>A descriptive string (see
<xref linkend="dstring" />) associated with that
condition</para></listitem>
<listitem><para>Optional additional object information (see
<xref linkend="addinf" />)</para></listitem>
</itemizedlist>
<para>The current condition information is replaced when control is passed to
a label as the result of a condition trap (CALL ON or SIGNAL ON). Condition
information is saved and restored across subroutine or function calls, including
one because of a CALL ON trap and across method invocations. Therefore, a
routine called by CALL ON can access the appropriate condition information.
Any previous condition information is still available after the routine returns.</para>

<section id="dstring"><title>Descriptive Strings</title>
<para>The descriptive string varies, depending on the condition trapped: </para>
<variablelist>
<varlistentry><term>ERROR
<indexterm><primary>ERROR subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>ERROR subkeyword</primary>
<secondary>in a CALL instruction</secondary></indexterm>
</term>
<listitem><para>The string that was processed and resulted in the error condition.
</para></listitem></varlistentry>
<varlistentry><term>FAILURE
<indexterm><primary>FAILURE subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>FAILURE subkeyword</primary>
<secondary>in a CALL instruction</secondary></indexterm>
</term>
<listitem><para>The string that was processed and resulted in the failure condition.
</para></listitem></varlistentry>
<varlistentry><term>HALT
<indexterm><primary>HALT subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>HALT subkeyword</primary>
<secondary>in a CALL instruction</secondary></indexterm>
</term>
<listitem><para>Any string associated with the halt request. This can be the null string
if no string was provided.
</para></listitem></varlistentry>
<varlistentry><term>LOSTDIGITS
<indexterm><primary>LOSTDIGITS subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>LOSTDIGITS subkeyword</primary>
<secondary>in a CALL instruction</secondary></indexterm>
</term>
<listitem><para>The number with excessive digits that caused the LOSTDIGITS condition.
</para></listitem></varlistentry>
<varlistentry><term>NOMETHOD
<indexterm><primary>NOMETHOD subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
</term>
<listitem><para>The name of the method that could not be found.
</para></listitem></varlistentry>
<varlistentry><term>NOSTRING
<indexterm><primary>NOSTRING subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
</term>
<listitem><para>The readable string representation of the object causing the NOSTRING
condition.
</para></listitem></varlistentry>
<varlistentry><term>NOTREADY
<indexterm><primary>NOTREADY subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>NOTREADY subkeyword</primary>
<secondary>in a CALL instruction</secondary></indexterm>
</term>
<listitem><para>The name of the stream being manipulated when the error occurred and
the NOTREADY condition was raised. If the stream was a default stream with
no defined name, then the null string might be returned.
</para></listitem></varlistentry>
<varlistentry><term>NOVALUE
<indexterm><primary>NOVALUE subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
</term>
<listitem><para>The derived name of the variable whose attempted reference caused the
NOVALUE condition.
</para></listitem></varlistentry>
<varlistentry><term>SYNTAX
<indexterm><primary>SYNTAX subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
</term>
<listitem><para>Any string the language processor associated with the error. This can
be the null string if you did not provide a specific string. Note that the
special variables RC and SIGL provide information on the nature and position
of the processing error. You can enable the SYNTAX condition trap only by
using SIGNAL ON.
</para></listitem></varlistentry>
<varlistentry><term>USER
<indexterm><primary>USER subkeyword</primary>
<secondary>in a SIGNAL instruction</secondary></indexterm>
<indexterm><primary>USER subkeyword</primary>
<secondary>in a CALL instruction</secondary></indexterm>
</term>
<listitem><para>Any string specified by the DESCRIPTION option of the RAISE instruction
that raised the condition. If a description string was not specified, a null
string is used.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="addinf"><title>Additional Object Information</title>

<para>The language processor can provide additional information, depending
on the condition trapped: </para>
<variablelist>
<varlistentry><term>NOMETHOD</term>
<listitem><para>The object that raised the NOMETHOD condition.
</para></listitem></varlistentry>
<varlistentry><term>NOSTRING</term>
<listitem><para>The object that caused the NOSTRING condition.
</para></listitem></varlistentry>
<varlistentry><term>NOTREADY</term>
<listitem><para>The stream object that raised the NOTREADY condition.
</para></listitem></varlistentry>
<varlistentry><term>SYNTAX</term>
<listitem><para>An array containing the objects substituted into the secondary error
message (if any) for the syntax error. If the message did not contain substitution
values, a zero element array is used.
</para></listitem></varlistentry>
<varlistentry><term>USER</term>
<listitem><para>Any object specified by an ADDITIONAL or ARRAY option of the
RAISE instruction that raised the condition.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="spec"><title>The Special Variable RC</title>
<indexterm><primary>special</primary>
<secondary>variables</secondary>
<tertiary>RC</tertiary></indexterm>
<para> When an ERROR or
FAILURE condition is trapped, the Rexx special variable RC is set to the command
return code before control is transferred to the target label (whether by
CALL or by SIGNAL).</para>
<para>Similarly, when SIGNAL ON SYNTAX traps a SYNTAX condition, the special
variable RC is set to the syntax error number before control is transferred
to the target label.</para>
</section>

<section id="consigl"><title>The Special Variable SIGL</title>
<indexterm><primary>special</primary>
<secondary>variables</secondary>
<tertiary>SIGL</tertiary></indexterm>
<indexterm><primary>variable</primary>
<secondary>special</secondary>
<tertiary>SIGL</tertiary></indexterm>
<indexterm><primary>SIGL</primary>
<secondary>in condition trapping</secondary></indexterm>
<indexterm><primary>variable</primary>
<secondary>SIGL</secondary></indexterm>
<para>Following any transfer of control because of a CALL or SIGNAL, the program
line number of the clause causing the transfer of control is stored in the
special variable SIGL. If the transfer of control is because of a condition
trap, the line number assigned to SIGL is that of the last clause processed
(at the current subroutine level) before the CALL or SIGNAL took place. The
setting of SIGL is especially useful after a SIGNAL ON SYNTAX trap when the
number of the line in error can be used, for example, to control a text editor.
Typically, code following the SYNTAX label can PARSE SOURCE to find the source
of the data and then call an editor to edit the source file, positioned at
the line in error. Note that in this case you might have to run the program
again before any changes made in the editor can take effect.</para>
<para>Alternatively, SIGL can help determine the cause of an error (such as the
occasional failure of a function call) as in the following example:   </para>
<indexterm><primary>examples</primary>
<secondary>SIGL, special variable</secondary></indexterm>
<example id="ex.sigl">
<title>SIGL</title>
<programlisting>
signal on syntax
a = a + 1      /* This is to create a syntax error */
say "SYNTAX error not raised"
exit

/* Standard handler for SIGNAL ON SYNTAX */
syntax:
say "Rexx error" rc "in line" sigl":" "ERRORTEXT"(rc)
say "SOURCELINE"(sigl)
trace ?r; nop
</programlisting>
</example>
<para>This code first displays the error code, line number, and error message.
 It then displays the line in error, and finally drops into debug mode to
let you inspect the values of the variables used at the line in error.</para>
</section>

<section id="conobj"><title>Condition Object</title>
<para>A condition object is a <classname>Directory</classname> returned by the
<option>Object</option> option of the
<xref linkend="bifCondition" xrefstyle="select:title"/> built-in function.
This directory contains
all information currently available on a trapped condition. The information
varies with the trapped condition. &nil; is returned for any entry
not available to the condition. The following entries can be found in a condition
object: </para>
<variablelist>
<varlistentry><term>ADDITIONAL</term>
<listitem><para>The additional information object associated with the condition. This
is the same object that the Additional option of the CONDITION built-in function
returns. The ADDITIONAL information may be specified with the ADDITIONAL or
ARRAY options of the RAISE instruction.
</para></listitem></varlistentry>
<varlistentry><term>DESCRIPTION</term>
<listitem><para>The string describing the condition. The Description option of
the CONDITION built-in function also returns this value.
</para></listitem></varlistentry>
<varlistentry><term>INSTRUCTION</term>
<listitem><para>The keyword for the instruction executed when the condition was
trapped, either <computeroutput>CALL</computeroutput> or
<computeroutput>SIGNAL</computeroutput>. The Instruction option of the
CONDITION built-in function also returns this value.
</para></listitem></varlistentry>
<varlistentry><term>CONDITION</term>
<listitem><para>The name of the trapped condition. The Condition name option of
the CONDITION built-in function also returns this value.
</para></listitem></varlistentry>
<varlistentry><term>RESULT</term>
<listitem><para>Any result specified on the RETURN or EXIT options of a RAISE
instruction.
</para></listitem></varlistentry>
<varlistentry><term>RC
<indexterm><primary>RC (return code)</primary>
<secondary>special variable</secondary></indexterm>
</term>
<listitem><para>
The major Rexx error number for a SYNTAX condition. This is the same
error number assigned to the special variable RC.
</para></listitem></varlistentry>
<varlistentry><term>CODE</term>
<listitem><para>The detailed identification of the error that caused a SYNTAX condition.
This number is a nonnegative number in the form <emphasis role="italic">nn.nnn</emphasis>. The integer
portion is the Rexx major error number (the same value as the RC entry). The
fractional portion is a subcode that gives a precise indication of the error
that occurred.
</para></listitem></varlistentry>
<varlistentry><term>ERRORTEXT</term>
<listitem><para>The primary error message for a SYNTAX condition. This is the same message
available from the ERRORTEXT built-in function.
</para></listitem></varlistentry>
<varlistentry><term>MESSAGE</term>
<listitem><para>The secondary error message for a SYNTAX condition. The message also
contains the content of the ADDITIONAL information.
</para></listitem></varlistentry>
<varlistentry><term>PACKAGE</term>
<listitem><para>The Package object associated with the program where a condition
was raised.
</para></listitem></varlistentry>
<varlistentry><term>POSITION</term>
<listitem><para>The line number in source code at which a condition was raised.
</para></listitem></varlistentry>
<varlistentry><term>PROGRAM</term>
<listitem><para>The name of the program where a condition was raised.
</para></listitem></varlistentry>
<varlistentry><term>STACKFRAMES</term>
<listitem><para>A single-index list of <xref linkend="clsStackFrame" xrefstyle="template:StackFrame"/> instances.
</para></listitem></varlistentry>
<varlistentry><term>TRACEBACK
</term>
<listitem><para>A single-index list of formatted traceback lines.
</para></listitem></varlistentry>
<varlistentry><term>PROPAGATED</term>
<listitem><para>&false; if the
condition was raised at the same level as the condition trap or the value
&true; if the condition was reraised with RAISE PROPAGATE.
</para></listitem></varlistentry>
</variablelist>
<para></para>
</section>
</section>
</chapter>
