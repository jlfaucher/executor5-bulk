<!--#########################################################################
    #
    # Description: Open Object Rexx: Reference SGML file.
    #
    # Copyright (c) 2005-2009, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<section id="streamclasses"><title>The Stream Classes</title>
<para>This section describes the Rexx classes which implement
Rexx data streams.</para>

<section id="clsInputStream"><title>The InputStream Class</title>
<indexterm><primary>InputStream class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>InputStream class</secondary></indexterm>
<para>This class is defined as an abstract mixin class. It must be implemented
by subclassing it or inheriting from it as a mixin. Many of the methods in this
class are abstract and must be overridden or they will throw a syntax error when invoked.</para>
<figure><title>The InputStream class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxInputStreamClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The InputStream class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;

</section>

<section id="mthInputStreamArrayIn"><title>arrayIn</title>
<indexterm><primary>arrayIn method</primary>
<secondary>of InputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>arrayIn method</secondary>
<tertiary>of InputStream class</tertiary></indexterm>
<para>This is a default implementation of the arrayIn method using linein() method calls
to fill the array.</para>
</section>

<section id="mthInputStreamCharIn"><title>charIn</title>
<indexterm><primary>charIn method</primary>
<secondary>of InputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>charIn method</secondary>
<tertiary>of InputStream class</tertiary></indexterm>
<para>This method is defined as an abstract method. Invoking it will cause
syntax error 93.965 to be raised.</para>
</section>

<section id="mthInputStreamCharOut"><title>charOut</title>
<indexterm><primary>charOut method</primary>
<secondary>of InputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>charOut method</secondary>
<tertiary>of InputStream class</tertiary></indexterm>
<para>This is an unsupported operation for InputSteams. Invoking it will cause
syntax error 93.963 to be raised.</para>
</section>

<section id="mthInputStreamChars"><title>chars</title>
<indexterm><primary>chars method</primary>
<secondary>of InputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>chars method</secondary>
<tertiary>of InputStream class</tertiary></indexterm>
<para>This method is defined as an abstract method. Invoking it will cause
syntax error 93.965 to be raised.</para>
</section>

<section id="mthInputStreamClose"><title>close</title>
<indexterm><primary>close method</primary>
<secondary>of InputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>close method</secondary>
<tertiary>of InputStream class</tertiary></indexterm>
<para>This method is a NOP by default.
</para>
</section>

<section id="mthInputStreamLineIn"><title>lineIn</title>
<indexterm><primary>lineIn method</primary>
<secondary>of InputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lineIn method</secondary>
<tertiary>of InputStream class</tertiary></indexterm>
<para>This method is defined as an abstract method. Invoking it will cause
syntax error 93.965 to be raised.</para>
</section>

<section id="mthInputStreamLineOut"><title>lineOut</title>
<indexterm><primary>lineOut method</primary>
<secondary>of InputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lineOut method</secondary>
<tertiary>of InputStream class</tertiary></indexterm>
<para>This is an unsupported operation for InputSteams. Invoking it will cause
syntax error 93.963 to be raised.</para>
</section>

<section id="mthInputStreamLines"><title>lines</title>
<indexterm><primary>lines method</primary>
<secondary>of InputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lines method</secondary>
<tertiary>of InputStream class</tertiary></indexterm>
<para>This method is defined as an abstract method. Invoking it will cause
syntax error 93.965 to be raised.</para>
</section>

<section id="mthInputStreamOpen"><title>open</title>
<indexterm><primary>open method</primary>
<secondary>of InputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>open method</secondary>
<tertiary>of InputStream class</tertiary></indexterm>
<para>This method is a NOP method.</para>
</section>

<section id="mthInputStreamPosition"><title>position</title>
<indexterm><primary>position method</primary>
<secondary>of InputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>position method</secondary>
<tertiary>of InputStream class</tertiary></indexterm>
<para>This method is an optionally supported operation.  By default, it will cause
syntax error 93.963 to be raised.</para>
</section>
</section>

<section id="clsOutputStream"><title>The OutputStream Class</title>
<indexterm><primary>OutputStream class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>OutputStream class</secondary></indexterm>

<para>This class is defined as an abstract mixin class. It must be implemented
by subclassing it or inheriting from it as a mixin. Many of the methods in this
class are abstract and must be overridden or they will throw a syntax error when invoked.</para>
<figure><title>The OutputStream class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxOutputStreamClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The OutputStream class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;

</section>

<section id="mthOutputStreamArrayOut"><title>arrayOut</title>
<indexterm><primary>arrayOut method</primary>
<secondary>of OutputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>arrayOut method</secondary>
<tertiary>of OutputStream class</tertiary></indexterm>
<para>This method is a default arrayOut implementation that writes all lines to the
stream using lineout.</para>
</section>

<section id="mthOutputStreamCharIn"><title>charIn</title>
<indexterm><primary>charIn method</primary>
<secondary>of OutputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>charIn method</secondary>
<tertiary>of OutputStream class</tertiary></indexterm>
<para>This is an unsupported operation for OutputSteams. Invoking it will cause
syntax error 93.963 to be raised.</para>
</section>

<section id="mthOutputStreamCharOut"><title>charOut</title>
<indexterm><primary>charOut method</primary>
<secondary>of OutputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>charOut method</secondary>
<tertiary>of OutputStream class</tertiary></indexterm>
<para>This method is defined as an abstract method. Invoking it will cause
syntax error 93.965 to be raised.</para>
</section>

<section id="mthOutputStreamChars"><title>chars</title>
<indexterm><primary>chars method</primary>
<secondary>of OutputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>chars method</secondary>
<tertiary>of OutputStream class</tertiary></indexterm>
<para>This is an unsupported operation for OutputSteams. Invoking it will cause
syntax error 93.963 to be raised.</para>
</section>

<section id="mthOutputStreamClose"><title>close</title>
<indexterm><primary>close method</primary>
<secondary>of OutputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>close method</secondary>
<tertiary>of OutputStream class</tertiary></indexterm>
<para>This method is a NOP by default.
</para>
</section>

<section id="mthOutputStreamLineIn"><title>lineIn</title>
<indexterm><primary>lineIn method</primary>
<secondary>of OutputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lineIn method</secondary>
<tertiary>of OutputStream class</tertiary></indexterm>
<para>This is an unsupported operation for OutputSteams. Invoking it will cause
syntax error 93.963 to be raised.</para>
</section>

<section id="mthOutputStreamLineOut"><title>lineOut</title>
<indexterm><primary>lineOut method</primary>
<secondary>of OutputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lineOut method</secondary>
<tertiary>of OutputStream class</tertiary></indexterm>
<para>This method is defined as an abstract method. Invoking it will cause
syntax error 93.965 to be raised.</para>
</section>

<section id="mthOutputStreamLines"><title>lines</title>
<indexterm><primary>lines method</primary>
<secondary>of OutputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lines method</secondary>
<tertiary>of OutputStream class</tertiary></indexterm>
<para>This is an unsupported operation for OutputSteams. Invoking it will cause
syntax error 93.963 to be raised.</para>
</section>

<section id="mthOutputStreamOpen"><title>open</title>
<indexterm><primary>open method</primary>
<secondary>of OutputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>open method</secondary>
<tertiary>of OutputStream class</tertiary></indexterm>
<para>This method is a NOP by default.
</para>
</section>

<section id="mthOutputStreamPosition"><title>position</title>
<indexterm><primary>position method</primary>
<secondary>of OutputStream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>position method</secondary>
<tertiary>of OutputStream class</tertiary></indexterm>
<para>This method is an optionally supported operation.  By default, it will cause
syntax error 93.963 to be raised.</para>
</section>
</section>

<section id="clsInputOutputStream"><title>The InputOutputStream Class</title>
<indexterm><primary>InputOutputStream class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>InputOutputStream class</secondary></indexterm>

<para>This class is defined as an abstract mixin class. It must be implemented
by subclassing it or inheriting from it as a mixin. Many of the methods in this
class are abstract and must be overridden or they will throw a syntax error when invoked.</para>
<figure><title>The InputOutputStream class</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxInputOutputStreamClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The InputOutputStream class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.
</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;

<para>Methods inherited from the
<link linkend="clsInputStream">InputStream class</link>.</para>
<note><para>This class is searched second for inherited methods.
</para></note>
<simplelist type="vert" columns="3">
<member><link linkend="mthInputStreamArrayIn">arrayIn</link></member>
<member><link linkend="mthInputStreamCharIn">charIn</link></member>
<member><link linkend="mthInputStreamCharOut">charOut</link></member>
<member><link linkend="mthInputStreamChars">chars</link></member>
<member><link linkend="mthInputStreamClose">close</link></member>
<member><link linkend="mthInputStreamLineIn">lineIn</link></member>
<member><link linkend="mthInputStreamLineOut">lineOut</link></member>
<member><link linkend="mthInputStreamLines">lines</link></member>
<member><link linkend="mthInputStreamOpen">open</link></member>
<member><link linkend="mthInputStreamPosition">position</link></member>
</simplelist>

<para>Methods inherited from the
<link linkend="clsOutputStream">OutputStream class</link>.</para>
<note><para>This class is searched first for inherited methods.
</para></note>
<simplelist type="vert" columns="3">
<member><link linkend="mthOutputStreamArrayOut">arrayOut</link></member>
<member><link linkend="mthOutputStreamCharIn">charIn</link></member>
<member><link linkend="mthOutputStreamCharOut">charOut</link></member>
<member><link linkend="mthOutputStreamChars">chars</link></member>
<member><link linkend="mthOutputStreamClose">close</link></member>
<member><link linkend="mthOutputStreamLineIn">lineIn</link></member>
<member><link linkend="mthOutputStreamLineOut">lineOut</link></member>
<member><link linkend="mthOutputStreamLines">lines</link></member>
<member><link linkend="mthOutputStreamOpen">open</link></member>
<member><link linkend="mthOutputStreamPosition">position</link></member>
</simplelist>

</section>
</section>

<section id="clsStream"><title>The Stream Class</title>
<indexterm><primary>Stream class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Stream class</secondary></indexterm>

<para>A stream object allows external communication from
Rexx. (See <link linkend="iostrms">Input and Output Streams</link> for a
discussion of Rexx input and output.)</para>
<para>The Stream class is a subclass of the
<link linkend="clsInputOutputStream">InputOutputStream class</link>.</para>
<figure><title>The Stream class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxStreamClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Stream class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.
It also inherits methods from the
<link linkend="clsInputOutputStream">InputOutputStream class</link>.
</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;

<para>Methods inherited from the
<link linkend="clsInputStream">InputStream class</link>.</para>
<note><para>This class is searched second for inherited methods.
</para></note>
<simplelist type="vert" columns="3">
<member><link linkend="mthInputStreamArrayIn">arrayIn</link></member>
<member><link linkend="mthInputStreamCharIn">charIn</link></member>
<member><link linkend="mthInputStreamCharOut">charOut</link></member>
<member><link linkend="mthInputStreamChars">chars</link></member>
<member><link linkend="mthInputStreamClose">close</link></member>
<member><link linkend="mthInputStreamLineIn">lineIn</link></member>
<member><link linkend="mthInputStreamLineOut">lineOut</link></member>
<member><link linkend="mthInputStreamLines">lines</link></member>
<member><link linkend="mthInputStreamOpen">open</link></member>
<member><link linkend="mthInputStreamPosition">position</link></member>
</simplelist>

<para>Methods inherited from the
<link linkend="clsOutputStream">OutputStream class</link>.</para>
<note><para>This class is searched first for inherited methods.
</para></note>
<simplelist type="vert" columns="3">
<member><link linkend="mthOutputStreamArrayOut">arrayOut</link></member>
<member><link linkend="mthOutputStreamCharIn">charIn</link></member>
<member><link linkend="mthOutputStreamCharOut">charOut</link></member>
<member><link linkend="mthOutputStreamChars">chars</link></member>
<member><link linkend="mthOutputStreamClose">close</link></member>
<member><link linkend="mthOutputStreamLineIn">lineIn</link></member>
<member><link linkend="mthOutputStreamLineOut">lineOut</link></member>
<member><link linkend="mthOutputStreamLines">lines</link></member>
<member><link linkend="mthOutputStreamOpen">open</link></member>
<member><link linkend="mthOutputStreamPosition">position</link></member>
</simplelist>

</section>

<section id="mthStreamNew"><title>new (Inherited Class Method)</title>
<indexterm><primary>new method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new(name)---------------------------------------------------><
]]>
</programlisting>

<para>Initializes a stream object for stream
<emphasis role="italic">name</emphasis>, but does not open the stream.
Returns the new stream object</para>
</section>

<section id="mthStreamArrayIn"><title>arrayIn</title>
<indexterm><primary>arrayIn method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>arrayIn method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
            +-(LINES)-+
>>-arrayIn--+---------+----------------------------------------><
            +-(CHARS)-+
]]>
</programlisting>

<para>Returns a fixed array that contains the data of the stream in line or
character format, starting from the current read position. The line format is
the default.</para>
<para>If you have used the <emphasis role="bold">charIn</emphasis>
method, the first line can be a partial line.
</para>
</section>

<section id="mthStreamArrayOut"><title>arrayOut</title>
<indexterm><primary>arrayOut method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>arrayOut method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
                  +-,--LINES-+
>>-arrayOut(array-+----------+-)-------------------------------><
                  +-,--CHARS-+
]]>
</programlisting>

<para>Writes the data in array
<emphasis role="italic">array</emphasis> to the stream.
If LINES is specified, each element of the array is written using
lineout().  If CHARS is specified, each element is written using charout().  The
default method is LINES.
</para>
</section>

<section id="mthStreamCharIn"><title>charIn</title>
<indexterm><primary>charIn method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>charIn method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-charIn-+----------------------------+-----------------------><
          +-(-+-------+--+---------+-)-+
              +-start-+  +-,length-+
]]>
</programlisting>

<para>Returns a string of up to <emphasis role="italic">length</emphasis>
characters from the input stream. The stream advances
advances the read pointer by the number of characters read. If you omit
<emphasis role="italic">length</emphasis>, it defaults to
<computeroutput>1</computeroutput>. If you specify
<emphasis role="italic">start</emphasis>, this positions the read pointer
before reading. The <emphasis role="italic">start</emphasis> value must be a positve whole number within
the bounds of the stream. If the value is not a positive whole number, a syntax condition is raised. When
the value is past the end of the stream, the empty string is returned and the NOTREADY condition is
raised. If the stream is not already open, the stream attempts to open for reading and writing. If that
fails, the stream opens for input only.
</para>
</section>

<section id="mthStreamCharOut"><title>charOut</title>
<indexterm><primary>charOut method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>charOut method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-charOut-+----------------------------+----------------------><
           +-(-+--------+--+--------+-)-+
               +-string-+  +-,start-+
]]>
</programlisting>

<para>Returns the count of characters remaining after trying to write
<emphasis role="italic">string</emphasis> to the output stream.
The stream also
advances the write pointer.</para>
<para>The <emphasis role="italic">string</emphasis> can be the null string.
In this case, <emphasis role="bold">charOut</emphasis> writes
no characters to the stream and returns <computeroutput>0</computeroutput>.
If you omit <emphasis role="italic">string</emphasis>,
<emphasis role="bold">charOut</emphasis> writes no
characters to the stream and returns <computeroutput>0</computeroutput>.
The stream is also closed.</para>
<para>If you specify <emphasis role="italic">start</emphasis>, this positions
the write pointer before
writing. If the stream is not already open, the stream attempts to open
for reading and writing. If that fails, the stream opens for
for output only.
</para>
</section>

<section id="mthStreamChars"><title>chars</title>
<indexterm><primary>chars method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>chars method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-chars-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the total number of characters remaining in the
input stream.
The count includes any line separator characters, if these are defined
for the stream. For persistent the count is the count of characters
from the current read position. (See
<link linkend="iostrms">Input and Output Streams</link> for a discussion
of Rexx input and output.) The total number of characters remaining cannot
be determined for some streams (for example, STDIN). For these streams. the
CHARS method returns <computeroutput>1</computeroutput>
to indicate that data is present, or <computeroutput>0</computeroutput>
if no data is present. For Windows devices,
CHARS always returns <computeroutput>1</computeroutput>.
</para>
</section>

<section id="mthStreamClose"><title>close</title>
<indexterm><primary>close method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>close method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-close-------------------------------------------------------><
]]>
</programlisting>

<para>Closes the stream.
<emphasis role="bold">close</emphasis> returns
<computeroutput>READY:</computeroutput> if closing the stream is successful,
or an appropriate error message.
If you have tried to close an unopened file, then the
<emphasis role="bold">close</emphasis> method returns
a null string (&quot;&quot;).</para>
</section>

<section id="mthStreamCommand"><title>command</title>
<indexterm><primary>command method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>command method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-command(stream_command)-------------------------------------><
]]>
</programlisting>

<para>Returns a string after performing the specified
<emphasis role="italic">stream_command</emphasis>. The returned string depends
on the <emphasis role="italic">stream_command</emphasis> performed
and can be the null string. The following
<emphasis role="italic">stream_command</emphasis>s: </para>
<itemizedlist>
<listitem><para>Open a stream for reading, writing, or both</para></listitem>
<listitem><para>Close a stream at the end of an operation</para></listitem>
<listitem><para>Move the line read or write position within a persistent stream
(for example, a file)</para></listitem>
<listitem><para>Get information about a stream</para></listitem></itemizedlist>

<para>If the method is unsuccessful, it returns an error message
string in the same form that the
<emphasis role="bold">description</emphasis> method uses.</para>
<para>For most error conditions, the additional information is in the form of
a numeric return code. This return code is the value of
<computeroutput>ERRNO</computeroutput> that
is set whenever one of the file system primitives returns with a
<computeroutput>-1</computeroutput>.</para>

<section id="StreamCommandStrings"><title>Command Strings</title>
<para>The argument <emphasis role="italic">stream_command</emphasis>
can be any expression that to one of the following command strings:
</para>
<programlisting>
<![CDATA[
           +-BOTH--| Write Options |-+
>>-+-OPEN--+-------------------------+--+-------------+-+------><
   |       +-READ--------------------+  +-| Options |-+ |
   |       +-WRITE--+---------+------+                  |
   |                +-APPEND--+                         |
   |                +-REPLACE-+                         |
   +-CLOSE----------------------------------------------+
   +-FLUSH----------------------------------------------+
   |               +- = -+                    +-CHAR-+  |
   +-+-SEEK-----+--+-----+-offset--+-------+--+------+--+
   | +-POSITION-+  +- < -+         +-READ--+  +-LINE-+  |
   |               +- + -+         +-WRITE-+            |
   |               +- - -+                              |
   +-QUERY--+-DATETIME--------------------------+-------+
            +-EXISTS----------------------------+
            +-HANDLE----------------------------+
            |                       +-CHAR-+    |
            +-+-SEEK-----+--+-READ--+------+--+-+
            | +-POSITION-+  |       +-LINE-+  | |
            |               |        +-CHAR-+ | |
            |               +-WRITE--+------+-+ |
            |               |        +-LINE-+ | |
            |               +-SYS-------------+ |
            +-SIZE------------------------------+
            +-STREAMTYPE------------------------+
            +-TIMESTAMP-------------------------+
]]>
</programlisting>

<para><emphasis role="bold">Write Options:</emphasis></para>

<programlisting>
<![CDATA[
|--+---------+--------------------------------------------------|
   +-APPEND--+
   +-REPLACE-+
]]>
</programlisting>

<para><emphasis role="bold">Options:</emphasis></para>

<programlisting>
<![CDATA[
                   +-----------------------------------+
                   V                                   |
|--+------------+----+-NOBUFFER----------------------+-+--------|
   +-SHARED-----+    +-BINARY--+-------------------+-+
   +-SHAREREAD--+              +-RECLENGTH--length-+
   +-SHAREWRITE-+
]]>
</programlisting>

<variablelist>
<varlistentry><term>OPEN</term>
<listitem><para>Opens the stream object and returns
<computeroutput>READY:</computeroutput>. (If unsuccessful, the previous
information about return codes applies.)
The default for OPEN is to open the stream for both reading and writing data,
for example: <computeroutput>&apos;OPEN BOTH&apos;</computeroutput>. To specify that the
stream be only opened for input or output,
add READ or WRITE, to the command string. </para>
<para>The following is a description of the options for
OPEN: </para>
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>Opens the stream only for reading.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>Opens the stream only for writing.
</para></listitem></varlistentry>
<varlistentry><term>BOTH</term>
<listitem><para>Opens the stream for both reading and writing. (This is the
default.) The stream maintains separate read and write pointers.
</para></listitem></varlistentry>
<varlistentry><term>APPEND</term>
<listitem><para>Positions the write pointer at the end of the stream. The write
pointer cannot be moved anywhere within the extent of the file as it existed
when the file was opened.
</para></listitem></varlistentry>
<varlistentry><term>REPLACE</term>
<listitem><para>Sets the write pointer to the beginning of the stream and
truncates the file. In other words, this option deletes all data that was in
the stream when opened.
</para></listitem></varlistentry>
<varlistentry><term>SHARED</term>
<listitem><para>Enables another process to work with the stream in a shared
mode. This mode must be compatible with the shared mode (SHARED, SHAREREAD, or
SHAREWRITE) used by the process that opened the stream.
</para></listitem></varlistentry>
<varlistentry><term>SHAREREAD</term>
<listitem><para>Enables another process to read the stream in a shared mode.
</para></listitem></varlistentry>
<varlistentry><term>SHAREWRITE</term>
<listitem><para>Enables another process to write the stream in a shared mode.
</para></listitem></varlistentry>
<varlistentry><term>NOBUFFER</term>
<listitem><para>Turns off buffering of the stream.
All data written to the stream is
flushed immediately to the operating system for writing. This option can have
a severe impact on output performance. Use it only when data integrity is
a concern, or to force interleaved output to a stream to appear in the exact
order in which it was written.
</para></listitem></varlistentry>
<varlistentry><term>BINARY</term>
<listitem><para>Opens the stream in binary mode.
This means that line end characters
are ignored; they are treated like any other byte of data. This is intended
to process
binary data using the line operations.</para>

<note><title>Note</title>
<para>Specifying the BINARY option for a stream that
does not exist but is opened for writing also requires the RECLENGTH option
to be specified. Omitting the RECLENGTH option in this case raises an error
condition.</para></note>
</listitem></varlistentry>
<varlistentry><term>RECLENGTH <emphasis role="italic">length</emphasis></term>
<listitem><para>Allows the specification of an exact length
for each line in a stream.
This allows line operations on binary-mode streams to operate on individual
fixed-length records. Without this option, line operations on binary-mode
files operate on the entire file (for example, as if you specified the
<computeroutput>RECLENGTH</computeroutput> option with a length equal to
that of the file). The <emphasis role="italic">length</emphasis> must be
<computeroutput>1</computeroutput> or greater.
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>command method</secondary>
<tertiary>OPEN option</tertiary></indexterm>
<programlisting>
stream_name~command("open")
stream_name~command("open write")
stream_name~command("open read")
stream_name~command("open read shared")
</programlisting>
</listitem></varlistentry>
<varlistentry><term>CLOSE</term>
<listitem><para>closes the stream object. The COMMAND
method with the CLOSE option returns <computeroutput>READY:</computeroutput>
if the stream
is successfully closed or an appropriate error message otherwise. If an attempt
to close an unopened file occurs, then the COMMAND method with the CLOSE option
returns a null string (&quot;&quot;).
</para></listitem></varlistentry>
<varlistentry><term>FLUSH</term>
<listitem><para>forces any data currently buffered for writing to be written to
this stream.
</para></listitem></varlistentry>
<varlistentry><term>SEEK <emphasis role="italic">offset</emphasis></term>
<listitem><para>sets the read or write position to a given number
(<emphasis role="italic">offset</emphasis>) within a persistent stream. If the
stream is open for both reading
and writing and you do not specify READ or WRITE, both the read and write
positions are set.</para>

<note><title>Note</title>
<para>See <link linkend="iostrms">Input and Output Streams</link>  for a
discussion of read and write positions in a persistent stream.</para></note>
<para>To
use this command, you must first open the stream (with the
OPEN stream command described previously or implicitly with an input or output
operation). One of the following characters can precede the
<emphasis role="italic">offset</emphasis> number. </para>
<variablelist>
<varlistentry><term>=</term>
<listitem><para>explicitly specifies the
<emphasis role="italic">offset</emphasis> from the beginning of the stream.
This is the default if you supply no prefix. For example, an
<emphasis role="italic">offset</emphasis> of <computeroutput>1</computeroutput>
with the LINE option means the beginning of the stream.
</para></listitem></varlistentry>
<varlistentry><term>&lt;</term>
<listitem><para>specifies <emphasis role="italic">offset</emphasis> from the
end of the stream.</para></listitem></varlistentry>
<varlistentry><term>+</term>
<listitem><para>specifies <emphasis role="italic">offset</emphasis>
forward from the current read or write position.
</para></listitem></varlistentry>
<varlistentry><term>-</term>
<listitem><para>specifies <emphasis role="italic">offset</emphasis>
backward from the current read or write position.
</para></listitem></varlistentry>
</variablelist>
<para>The <emphasis role="bold">command</emphasis>
method with the SEEK option returns the new position
in the stream if the read or write position is successfully located, or an
appropriate error message.</para>
<para>The following is a description of the options
for SEEK: </para>
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>specifies that this command sets the read position.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>specifies that this command sets the write position.
</para></listitem></varlistentry>
<varlistentry><term>CHAR</term>
<listitem><para>specifies the positioning in terms of characters. This is the
default.
</para></listitem></varlistentry>
<varlistentry><term>LINE</term>
<listitem><para>specifies the positioning in terms of lines. For non-binary streams,
this is potentially an operation that can take a long time to complete because,
in most cases, the file must be scanned from the top to count the line-end
characters. However, for binary streams with a specified record length, the
new resulting line number is simply multiplied by the record length before
character positioning. See
<link linkend="positio">Line versus Character Positioning</link>
for a detailed discussion of this issue. </para>

<note><title>Note</title>
<para>If you do line positioning in a file open only
for writing, you receive an error message.</para></note>
</listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>command method</secondary>
<tertiary>SEEK option</tertiary></indexterm>
<programlisting>
<![CDATA[
stream_name~command("seek =2 read")
stream_name~command("seek +15 read")
stream_name~command("seek -7 write line")
fromend  = 125
stream_name~command("seek <"fromend read)
]]>
</programlisting>
</listitem></varlistentry>
<varlistentry><term>POSITION</term>
<listitem><para>is a synonym for SEEK.</para>
<para>Used with these <emphasis role="italic">stream_command</emphasis>s, the
COMMAND method returns
specific information about a stream. Except for QUERY HANDLE and QUERY POSITION,
the stream returns the query information even if the stream is
not open. The stream returns the null string for nonexistent streams.
</para>
</listitem>
</varlistentry>
<varlistentry><term>QUERY DATETIME</term>
<listitem><para>Returns the date and time stamps of a stream in US format. For
example:
<indexterm><primary>examples</primary>
<secondary>command method</secondary>
<tertiary>QUERY DATETIME option</tertiary></indexterm>
<programlisting>
stream_name~command("query datetime")
</programlisting>
</para><para>A sample output might be: </para>
<programlisting>
11-12-95 03:29:12
</programlisting>
</listitem></varlistentry>
<varlistentry><term>QUERY EXISTS</term>
<listitem><para>Returns the full path specification of the stream object,
if it exists, or a null string. For example: </para>
<indexterm><primary>examples</primary>
<secondary>command method</secondary>
<tertiary>QUERY EXISTS option</tertiary></indexterm>
<programlisting>
stream_name~command("query exists")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
c:\data\file.txt
</programlisting>
</listitem></varlistentry>
<varlistentry><term>QUERY HANDLE</term>
<listitem><para>Returns the handle associated with the open stream.
For example: </para>
<indexterm><primary>examples</primary>
<secondary>command method</secondary>
<tertiary>QUERY HANDLE option</tertiary></indexterm>
<programlisting>
stream_name~command("query handle")
</programlisting>
<para>A sample output might be:
<computeroutput>3</computeroutput></para>

</listitem></varlistentry>
<varlistentry><term>QUERY POSITION</term>
<listitem><para>Returns the current read or write position for the stream,
as qualified by the following options:
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>Returns the current read position.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>Returns the current write position. </para>

<note><title>Note</title>
<para>If the stream is
open for both reading and writing, this returns the read position by default.
Otherwise, this returns the appropriate position by default.</para></note>
</listitem></varlistentry>
<varlistentry><term>CHAR</term>
<listitem><para>Returns the position in terms of characters. This is the
default.
</para></listitem></varlistentry>
<varlistentry><term>LINE</term>
<listitem><para>Returns the position in terms of lines. For non-binary streams,
this operation can take a long time to complete. This is because the language
processor starts tracking the current line number if not
already doing so, and, thus, might require a scan of the stream from
the top to count the line-end characters. See
<link linkend="positio">Line versus Character Positioning</link>
for a detailed discussion of this issue. For example: </para>
<programlisting>
stream_name~command("query position write")
</programlisting>
<para>A sample
output might be: </para>
<programlisting>
247
</programlisting>
</listitem></varlistentry>
<varlistentry><term>SYS</term>
<listitem><para>Returns the operating system stream position in terms of
characters.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>QUERY SEEK</term>
<listitem><para>Is a synonym for QUERY POSITION.
</para></listitem></varlistentry>
<varlistentry><term>QUERY SIZE</term>
<listitem><para>Returns the size, in bytes, of a persistent stream.
For example: </para>
<programlisting>
stream_name~command("query size")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
1305
</programlisting>
</listitem></varlistentry>
<varlistentry><term>QUERY STREAMTYPE</term>
<listitem><para>Returns a string indicating whether the stream
is <computeroutput>PERSISTENT</computeroutput>,
<computeroutput>TRANSIENT</computeroutput>, or
<computeroutput>UNKNOWN</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>QUERY TIMESTAMP</term>
<listitem><para>Returns the date and time stamps of a persistent stream
in an international format. This is the preferred method of getting date and
time because it provides the full 4-digit year. For example:</para>
<programlisting>
stream_name~command("query timestamp")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
1995-11-12 03:29:12
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="mthStreamDescription"><title>description</title>
<indexterm><primary>description method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>description method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-description-------------------------------------------------><
]]>
</programlisting>

<para>Returns any descriptive string associated with the
current state of the stream or the Nil object if no descriptive string is
available. The <emphasis role="bold">description</emphasis>
method is identical with the STATE method except
that the string that <emphasis role="bold">description</emphasis>
returns is followed by a colon and, if
available, additional information about ERROR or NOTREADY states. (The
<link linkend="mthStreamState">state</link> method describes these states.)</para>
</section>

<section id="mthStreamFlush"><title>flush</title>
<indexterm><primary>flush method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>flush method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-flush-------------------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>READY:</computeroutput>. It forces the stream to write
any buffered data to the output stream.
</para>
</section>

<section id="mthStreamInit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of Stream class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-init(name)-----------------------------------------------><
]]>
</programlisting>

<para>Initializes a stream object defined by <emphasis role="italic">name</emphasis>.
</para>
</section>

<section id="mthStreamLineIn"><title>lineIn</title>
<indexterm><primary>lineIn method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lineIn method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-lineIn-+-------------------------+--------------------------><
          +-(-+------+-+--------+-)-+
              +-line-+ +-,count-+
]]>
</programlisting>

<para>Returns the next <emphasis role="italic">count</emphasis> lines. The
count must be <computeroutput>0</computeroutput> or
<computeroutput>1</computeroutput>. The stream advances the read
pointer. If you omit <emphasis role="italic">count</emphasis>, it defaults to
<computeroutput>1</computeroutput>. A <emphasis role="italic">line</emphasis>
number may be given to set the read position to the start of a specified
line. This line number must be positive and within the bounds of the stream,
and must not be specified for a transient stream. A value of 1 for
<emphasis role="italic">line</emphasis> refers to the first line in the stream.
If the stream is not already
open, the it tries to open the stream for reading and writing.
If that fails, the stream is opened for input only.
</para>
</section>

<section id="mthStreamLineOut"><title>lineOut</title>
<indexterm><primary>lineOut method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lineOut method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-lineOut-+--------------------------+------------------------><
           +-(-+--------+-+-------+-)-+
               +-string-+ +-,line-+
]]>
</programlisting>

<para>Returns <computeroutput>0</computeroutput> if successful in writing
<emphasis role="italic">string</emphasis> to the output stream
or <computeroutput>1</computeroutput> if
an error occurs while writing the line. The stream advances the
write pointer. If you omit <emphasis role="italic">string</emphasis>, the
stream is closed.  If you specify
<emphasis role="italic">line</emphasis>, this positions the write pointer
before writing. If the stream is not already open, the stream
attempts to open for reading and writing. If that fails, the stream is
opened for output only.
</para>
</section>

<section id="mthStreamLines"><title>lines</title>
<indexterm><primary>lines method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lines method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
           +-Count--+
>>-lines(--+--------+---)--------------------------------------><
           +-Normal-+
]]>
</programlisting>

<para>Returns the number of completed lines that available for input.
If the stream has already been read with
<emphasis role="bold">charIn</emphasis>emphasis.
this can include an initial partial line. For persistent streams the count
starts at the current read position. In effect,
<emphasis role="bold">lines</emphasis> reports whether a read
action of charIn (see <link linkend="mthStreamCharIn">charIn</link>) or lineIn (see
<link linkend="mthStreamLineIn">lineIn</link>) will succeed. (For an explanation of
input and output, see
<link linkend="iostrms">Input and Output Streams</link>.)</para>
<para>For a Queue, <emphasis role="bold">lines</emphasis>
returns the actual number of lines.
</para>
<para> </para>

<note><title>Note</title>
<para>The <emphasis role="bold">chars</emphasis>
method returns the number of characters in a
persistent stream or the presence of data in a transient stream. The
<emphasis role="bold">lines</emphasis>emphasis
method determines the actual number of lines by scanning the stream starting
at the current position and counting the lines. For large streams, this can
be a time-consuming operation.  Therefore, avoid the use of the LINES method
in the  condition of a loop reading a stream. It is recommended that you use
the <emphasis role="bold"><link linkend="mthStreamChars">chars</link></emphasis>
method.
</para></note>

<para>The ANSI Standard has extended this function to allow an option: "Count".
If this option is used, <emphasis role="bold">lines</emphasis>
returns the actual number of complete
lines remaining in the stream, irrespective of how long this operation takes.
</para>

<para>The option "Normal" returns 1 if there is at least one complete line
remaining in the file or 0 if no lines remain.</para>

<para>The default is "Count".</para>
</section>

<section id="mthStreamMakeArray"><title>makeArray</title>
<indexterm><primary>makeArray method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>makeArray method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
              +-(LINES)-+
>>-makeArray--+---------+--------------------------------------><
              +-(CHARS)-+
]]>
</programlisting>

<para>Returns a fixed array that contains
the data of the stream in line or character format, starting from the current
read position. The line format is the default.</para>
<para>If you have used the <emphasis role="bold">charIn</emphasis>
method, the first line can be a partial line.
</para>
</section>

<section id="mthStreamOpen"><title>open</title>
<indexterm><primary>open method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>open method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
         +-(BOTH-| Write Options |--+  +-SHARED-----+
>>-open--+--------------------------+--+------------+----------->
         +-(READ--------------------+  +-SHAREREAD--+
         +-(WRITE-| Write Options |-+  +-SHAREWRITE-+

   +-----------------------------------+
   V                                   |
>----+-------------------------------+-+--+---+----------------><
     +-NOBUFFER----------------------+    +-)-+
     +-BINARY--+-------------------+-+
               +-RECLENGTH--length-+
]]>
</programlisting>

<para><emphasis role="bold">Write Options:</emphasis></para>

<programlisting>
<![CDATA[
   +-------------+
   V +-APPEND--+ |
|----+---------+-+----------------------------------------------|
     +-REPLACE-+
]]>
</programlisting>

<para>Opens the stream and returns
<computeroutput>READY:</computeroutput>. If the method is unsuccessful, it
returns an error message string in the same form that the
<emphasis role="bold">description</emphasis> method uses.</para>
<para>For most error conditions, the additional information is in the form of
a numeric return code. This return code is the value of
<computeroutput>ERRNO</computeroutput>,
which is set whenever one of the file system primitives returns with a
<computeroutput>-1</computeroutput>.</para>
<para>By default, <emphasis role="bold">open</emphasis>
opens the stream for both reading and writing data, for
example: <computeroutput>&apos;open BOTH&apos;</computeroutput>. To specify that the
stream be only opened for input or output,
specify READ or WRITE.</para>
<para>The options for the
<emphasis role="bold">open</emphasis> method are: </para>
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>Opens the stream for input only.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>Opens the stream for output only.
</para></listitem></varlistentry>
<varlistentry><term>BOTH</term>
<listitem><para>Opens the stream for both input and output.  (This is the
default.) The stream maintains separate read and write pointers.
</para></listitem></varlistentry>
<varlistentry><term>APPEND</term>
<listitem><para>Positions the write pointer at the end of the stream.
(This is the default.)
The write pointer cannot be moved anywhere within the extent of the file as
it existed when the file was opened.
</para></listitem></varlistentry>
<varlistentry><term>REPLACE</term>
<listitem><para>Sets the write pointer to the beginning of the stream
and truncates
the file. In other words, this option deletes all data that was in the stream
when opened.
</para></listitem></varlistentry>
<varlistentry><term>SHARED</term>
<listitem><para>Enables another process to work with the stream in a shared mode. (This
is the default.) This mode must be compatible with the shared mode (SHARED,
SHAREREAD, or SHAREWRITE) used by the process that opened the stream.
</para></listitem></varlistentry>
<varlistentry><term>SHAREREAD</term>
<listitem><para>Enables another process to read the stream in a shared mode.
</para></listitem></varlistentry>
<varlistentry><term>SHAREWRITE</term>
<listitem><para>Enables another process to write the stream in a shared mode.
</para></listitem></varlistentry>
<varlistentry><term>NOBUFFER</term>
<listitem><para>Turns off buffering of the stream. All data written to the stream is
flushed immediately to the operating system for writing. This option can have
a severe impact on output performance. Use it only when data integrity is
a concern, or to force interleaved output to a stream to appear in the exact
order in which it was written.
</para></listitem></varlistentry>
<varlistentry><term>BINARY</term>
<listitem><para>Opens the stream in binary mode. This means that line-end
characters are ignored; they are treated like any other byte of data. This is
for processing binary record data using the line
operations. </para>

<note><title>Note</title>
<para>Specifying the BINARY option for a stream that
does not exist but is opened for writing also requires the RECLENGTH option
to be specified. Omitting the RECLENGTH option in this case raises an error
condition.</para></note>
</listitem></varlistentry>
<varlistentry><term>RECLENGTH <emphasis role="italic">length</emphasis></term>
<listitem><para>Allows the specification of an exact length for each line
in a stream.
This allows line operations on binary-mode streams to operate on individual
fixed-length records. Without this option, line operations on binary-mode
files operate on the entire file (for example, as if you specified the
<computeroutput>RECLENGTH</computeroutput> option with a length equal to that
of the file). The <emphasis role="italic">length</emphasis> must be
<computeroutput>1</computeroutput> or greater.
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>open method</secondary></indexterm>
<programlisting>
stream_name~open
stream_name~open("write")
stream_name~open("read")
</programlisting>
</section>

<section id="mthStreamPosition"><title>position</title>
<indexterm><primary>position method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>position method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
             +- = -+                  +-CHAR-+
>>-position(-+-----+-offset-+-READ--+-+------+-)---------------><
             +- < -+        +-WRITE-+ +-LINE-+
             +- + -+
             +- - -+
]]>
</programlisting>

<para><emphasis role="bold">position</emphasis> is a synonym for
<emphasis role="bold">seek</emphasis>. (See
<link linkend="mthStreamSeek">seek</link> .)</para>
</section>

<section id="mthStreamQualify"><title>qualify</title>
<indexterm><primary>qualify method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>qualify method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-qualify-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the stream's fully qualified name. The stream need
not be open.</para>
</section>

<section id="mthStreamQuery"><title>query</title>
<indexterm><primary>method</primary>
<secondary>query</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<indexterm><primary>query method</primary>
<secondary>of Stream class</secondary></indexterm>

<programlisting>
<![CDATA[
>>-query(--+-DATETIME--------------------------+--)------------><
           +-EXISTS----------------------------+
           +-HANDLE----------------------------+
           |                       +-CHAR-+    |
           +-+-SEEK-----+--+-READ--+------+--+-+
           | +-POSITION-+  |       +-LINE-+  | |
           |               |        +-CHAR-+ | |
           |               +-WRITE--+------+-+ |
           |               |        +-LINE-+ | |
           |               +-SYS-------------+ |
           +-SIZE------------------------------+
           +-STREAMTYPE------------------------+
           +-TIMESTAMP-------------------------+
]]>
</programlisting>

<para>Used with these options, the <emphasis role="bold">query</emphasis>
method returns specific information about a stream. Except for
<emphasis role="bold">query</emphasis> HANDLE and
<emphasis role="bold">query</emphasis> POSITION, the
stream
returns the query information even if the stream is not open. A null string
is returned for nonexistent streams. </para>
<variablelist>
<varlistentry><term>DATETIME</term>
<listitem><para>returns the date and time stamps of a persistent stream
in US format. For example:</para>
<programlisting>
stream_name~query("datetime")
</programlisting>
<para>A sample output might
be: </para>
<programlisting>
11-12-98 03:29:12
</programlisting>
</listitem></varlistentry>
<varlistentry><term>EXISTS</term>
<listitem><para>returns the full path specification of the stream,
if it exists, or a null string. For example: </para>
<indexterm><primary>examples</primary>
<secondary>query method</secondary></indexterm>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~query("exists")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
c:\data\file.txt
</programlisting>
</listitem></varlistentry>
<varlistentry><term>HANDLE</term>
<listitem><para>returns the handle associated with the open stream.
For example:</para>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~query("handle")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
3
</programlisting>
</listitem></varlistentry>
<varlistentry><term>POSITION</term>
<listitem><para>returns the current read or write position for the
stream, as qualified by the following options:
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>returns the current read position.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>returns the current write position. </para>

<note><title>Note</title>
<para>If the stream is
open for both reading and writing, this returns the read position by default.
Otherwise, this returns the specified position.</para></note>
</listitem></varlistentry>
<varlistentry><term>CHAR</term>
<listitem><para>returns the position in terms of characters.
This is the default.
</para></listitem></varlistentry>
<varlistentry><term>LINE</term>
<listitem><para>returns the position in terms of lines. For non-binary streams,
this operation can take a long time to complete. This is because the language
processor starts tracking the current line number if not already doing so, and,
thus, might require a scan of the stream from the top to count the line-end
characters. See
<link linkend="positio">Line versus Character Positioning</link>
for a detailed discussion of this issue. For example: </para>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~query("position write")
</programlisting>
<para>A sample output
might be: </para>
<programlisting>
247
</programlisting>
</listitem></varlistentry>
<varlistentry><term>SYS</term>
<listitem><para>returns the operating system stream position in terms of
characters. </para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>SIZE</term>
<listitem><para>returns the size, in bytes, of a persistent stream.
For example: </para>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~query("size")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
1305
</programlisting>
</listitem></varlistentry>
<varlistentry><term>STREAMTYPE</term>
<listitem><para>returns a string indicating whether the stream
object is <computeroutput>PERSISTENT</computeroutput>,
<computeroutput>TRANSIENT</computeroutput>, or
<computeroutput>UNKNOWN</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>TIMESTAMP</term>
<listitem><para>returns the date and time stamps of a persistent stream
in an international format. This is the preferred method of getting the date and
time because it provides the full 4-digit year. For example:</para>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~query("timestamp")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
1998-11-12 03:29:12
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>

<section id="mthStreamSay"><title>say</title>
<indexterm><primary>say method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>say method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-say--+----------------+-------------------------------------><
        +-(-+--------+-)-+
            +-string-+
]]>
</programlisting>

<para>Returns <computeroutput>0</computeroutput> if successful in writing
<emphasis role="italic">string</emphasis> to the output stream
or <computeroutput>1</computeroutput> if
an error occurs while writing the line.</para>
</section>

<section id="mthStreamSeek"><title>seek</title>
<indexterm><primary>seek method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>seek method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
         +- = -+                  +-CHAR-+
>>-seek(-+-----+-offset-+-------+-+------+-)-------------------><
         +- < -+        +-READ--+ +-LINE-+
         +- + -+        +-WRITE-+
         +- - -+
]]>
</programlisting>

<para>Sets the read or write position to a given number
(<emphasis role="italic">offset</emphasis>) within a persistent stream. If
the stream is open for both reading
and writing and you do not specify READ or WRITE, both the read and write
positions are set. </para>

<note><title>Note</title>
<para>See <link linkend="iostrms">Input and Output Streams</link>
for a discussion
of read and write positions in a persistent stream.</para></note>
<para>To use this method, you must first open the stream object (with
the OPEN method described previously or implicitly with an input or output
operation). One of the following characters can precede the
<emphasis role="italic">offset</emphasis> number:</para>
<variablelist>
<varlistentry><term>=</term>
<listitem><para>Explicitly specifies the
<emphasis role="italic">offset</emphasis> from the beginning of the stream.
This is the default if you supply no prefix. For example, an
<emphasis role="italic">offset</emphasis> of <computeroutput>1</computeroutput>
means the beginning of the stream.
</para></listitem></varlistentry>
<varlistentry><term>&lt;</term>
<listitem><para>Specifies <emphasis role="italic">offset</emphasis>
from the end of the stream.
</para></listitem></varlistentry>
<varlistentry><term>+</term>
<listitem><para>Specifies <emphasis role="italic">offset</emphasis>
forward from the current read or write position.
</para></listitem></varlistentry>
<varlistentry><term>-</term>
<listitem><para>Specifies <emphasis role="italic">offset</emphasis>
backward from the current read or write position.
</para></listitem></varlistentry>
</variablelist>
<para>The <emphasis role="bold">seek</emphasis>
method returns the new position in the stream if the read or
write position is successfully located, or an appropriate error message.</para>
<para>The following is a description of the options for
<emphasis role="bold">seek</emphasis>: </para>
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>specifies that the read position be set.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>specifies that the write position be set.
</para></listitem></varlistentry>
<varlistentry><term>CHAR</term>
<listitem><para>specifies that positioning be done in terms of characters.
This is the default.
</para></listitem></varlistentry>
<varlistentry><term>LINE</term>
<listitem><para>specifies that the positioning be done in terms of lines. For
non-binary streams, this is potentially an operation that can take a long time
to complete because, in most cases, the file must be scanned from the top to
count the line-end characters. However, for binary streams with a specified
record length, the new resulting line number is simply multiplied by the record
length before character positioning. See
<link linkend="positio">Line versus Character Positioning</link>
for a detailed discussion of this issue. </para>

<note><title>Note</title>
<para>If you do line positioning in a file open only
for writing, you receive an error message.</para></note>
</listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>seek method</secondary></indexterm>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~seek("=2 read")
<emphasis role="italic">stream_name</emphasis>~seek("+15 read")
<emphasis role="italic">stream_name</emphasis>~seek("-7 write line")
fromend  = 125
<emphasis role="italic">stream_name</emphasis>~seek("&lt;"fromend read)
</programlisting>
</section>

<section id="mthStreamState"><title>state</title>
<indexterm><primary>state method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>state method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-state-------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string indicating the current stream state.
</para>
<para>The returned strings are as follows: </para>
<variablelist>
<varlistentry><term>ERROR</term>
<listitem><para>The stream has been subject to an erroneous operation
(possibly during input, output, or through the STREAM function). See
<link linkend="stmerr">Errors during Input and Output</link>.
You might be able to obtain additional information about the error with the
<emphasis role="bold">description</emphasis>
method or by calling the STREAM function with a request for the
description.
</para></listitem></varlistentry>
<varlistentry><term>NOTREADY</term>
<listitem><para>The stream is known to be in such a state that the usual input
or output operations attempted upon would raise the NOTREADY condition. (See
<link linkend="stmerr">Errors during Input and Output</link>.)
 For example, a simple input stream can have a defined length. An attempt
to read that stream (with CHARIN or LINEIN, perhaps) beyond that limit can
make the stream unavailable until the stream has been closed (for example,
with LINEOUT(<emphasis role="italic">name</emphasis>)) and then reopened.
</para></listitem></varlistentry>
<varlistentry><term>READY</term>
<listitem><para>The stream is known to be in such a state that the usual input
or output operations might be attempted. This is the usual state for a stream,
although it does not guarantee that any particular operation will succeed.
</para></listitem></varlistentry>
<varlistentry><term>UNKNOWN</term>
<listitem><para>The state of the stream is unknown. This generally means that
the stream is closed or has not yet been opened.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="mthStreamString"><title>string</title>
<indexterm><primary>string method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>string method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-string------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string that indicates the name of the object the stream
represents i.e. the name of the file.
</para>
</section>

<section id="mthStreamSupplier"><title>supplier</title>
<indexterm><primary>supplier method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>supplier method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-supplier----------------------------------------------------><
]]>
</programlisting>

<para>Returns a <link linkend="clsStreamSupplier">StreamSupplier object</link> for the stream containing
the remaining stream lines and linenumber positions for the stream.
</para>
</section>

<section id="mthStreamUninit"><title>uninit</title>
<indexterm><primary>uninit method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>uninit method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-uninit------------------------------------------------------><
]]>
</programlisting>

<para>This method cleans up the object when it is garbage collected. It should
not be invoked directly except via an
<emphasis role="bold">uninit</emphasis> method of a subclass of the Stream
class.
</para>
<para>If the Stream class is subclassed and the subclass provides an
<emphasis role="bold">uninit</emphasis>
method then that method must invoke the superclass
<emphasis role="bold">uninit</emphasis> method.
For example:</para>
<programlisting>
<![CDATA[
::class CustomStream subclass Stream

...

::method uninit
/* the subclass instance cleanup code should be placed here */
super~uninit  -- this should be the last action in the method
return
]]>
</programlisting>
</section>
</section>

</section>

