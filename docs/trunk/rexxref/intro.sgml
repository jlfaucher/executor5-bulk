<!--####################################c#####################################
    #
    # Description: Open Object Rexx: Reference SGML file.
    #
    # Copyright (c) 2005-2007, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<chapter id="intro"><title>Object Rexx General Concepts</title>
<indexterm><primary>general concepts</primary></indexterm>
<para>The Rexx language is particularly suitable for:
<itemizedlist>
<listitem><para>Application scripting</para></listitem>
<listitem><para>Command procedures</para></listitem>
<listitem><para>Application front ends</para></listitem>
<listitem><para>User-defined macros (such as editor subcommands)</para>
</listitem>
<listitem><para>Prototyping</para></listitem>
<listitem><para>Personal computing</para></listitem>
</itemizedlist></para>
<para> As an object-oriented language, Rexx provides, for example, data
encapsulation,
polymorphism, an object class hierarchy, class-based inheritance of methods,
and concurrency. Object Rexx is compatible with earlier Rexx versions. It
has the usual structured-programming instructions, for example IF, SELECT,
DO WHILE, and LEAVE, and a number of useful built-in functions.</para>
<para>The language imposes few restrictions
<indexterm><primary>programming restrictions</primary></indexterm>
<indexterm><primary>restrictions</primary>
<secondary>in programming</secondary></indexterm>
on the program format. There can be more than one clause on a line, or a single
clause can occupy more than one line. Indentation is allowed. You can,
therefore, code programs in a format that emphasizes their structure,
making them easier to read.</para>
<para>There is no limit to the length of the values of variables, as long as
all variables fit into the storage available. There are no restrictions on
the types of data that variables can contain.</para>
<para>The limit on the length of symbols (variable names) is 250 characters.
You can use compound symbols, such as </para>
<programlisting>
NAME.Y.Z
</programlisting>
<para>where <varname>Y</varname> and <varname>Z</varname> can be the names
of variables or can
be constant symbols, for constructing arrays and for other purposes.</para>
<indexterm><primary>execution</primary>
<secondary>by language processor</secondary></indexterm>
<indexterm><primary>language</primary>
<secondary>processor execution</secondary></indexterm>
<para>A language processor (interpreter)
runs Rexx programs. That is, the program runs line by line and word by word,
without first being translated to another form (compiled). The advantage of
this is that you can fix the error and rerun the program faster than with
a compiler.</para>

<section id="object"><title>What Is Object-Oriented Programming?</title>
<indexterm><primary>object-oriented programming</primary></indexterm>
<para> Object-oriented
programming is a way to write computer programs by focusing not on the
instructions
and operations a program uses to manipulate data, but on the data itself.
First, the program simulates, or models, objects in the physical world as
closely as possible. Then the objects interact with each other to produce
the desired result.</para>
<para>Real-world objects, such as a company's employees, money in a bank
account, or a report, are stored as data so the computer can act upon it.
For example, when you print a report, print is the action
and report is the object acted upon. Often several actions apply; you could
also send or erase the report.</para>
</section>

<section id="module"><title>Modularizing Data</title>
<indexterm><primary>data</primary>
<secondary>modularization</secondary></indexterm>
<indexterm><primary>modularizing data</primary></indexterm>
<para> In conventional, structured programming, actions like print
are often isolated from the data by placing them in subroutines or modules.
A module typically contains an operation for implementing one simple action.
You might have a PRINT module, a SEND module, an ERASE module. These actions
are independent of the data they operate on.</para>

<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxo90020.jpg" scale="65">
</imageobject>
</mediaobject>

<para>But with object-oriented programming, it is the data that is modularized.
And each data module includes its own operations for performing actions directly
related to its data.</para>

<figure><title>Modular Data--a Report Object</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxo90004.jpg" scale="70">
</imageobject>
</mediaobject>
</figure>

<para>In the case of report, the report object would contain its own built-in
PRINT, SEND, ERASE, and FILE operations.</para>
<para>Object-oriented programming lets you model real-world objects--even
very complex ones--precisely and elegantly. As a result, object manipulation
becomes easier and computer instructions become simpler and can be modified
later with minimal effort.</para>
<para>Object-oriented programming <emphasis>hides</emphasis> any information
that is not important for acting on an object, thereby concealing the object's
complexities. Complex tasks can then be initiated simply, at a very high level.
</para>
</section>

<section id="objects"><title>Modeling Objects</title>
<para>In object-oriented programming, objects are modeled to real-world objects.
A real-world object has actions related to it and characteristics of its own.
</para>
<para>Take a ball, for example. A ball can be acted on--rolled, tossed,
thrown, bounced, caught. But it also has its own physical characteristics--size,
shape, composition, weight, color, speed, position. An accurate data model
of a real ball would define not only the physical characteristics but
<emphasis>all</emphasis> related actions and characteristics in one package:
</para>

<figure><title>A Ball Object</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxo90005.jpg" scale="70">
</imageobject>
</mediaobject>
</figure>

<para>In object-oriented programming,
objects are the basic building blocks--the fundamental units of data.</para>
<indexterm><primary>object</primary>
<secondary>definition</secondary></indexterm>
<indexterm><primary>object</primary>
<secondary>kinds of</secondary></indexterm>
<para>There are many kinds of objects; for example, character
strings, collections, and input and output streams. An object--such as
a character string--always consists of two parts: the possible actions
or operations related to it, and its characteristics or variables. A variable
has a variable <emphasis>name</emphasis>, and an associated data value
that can change over time. These actions and characteristics are so closely
associated that they cannot be separated:</para>

<figure><title>Ball Object with Variable Names and Values</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxo90006.jpg" scale="70">
</imageobject>
</mediaobject>
</figure>

<para>To access an object's data, you must always specify an
action. For example, suppose the object is the number
<computeroutput>5</computeroutput>. Its actions
might include addition, subtraction, multiplication, and division. Each of
these actions is an interface to the object's data. The data is said to
be <emphasis>encapsulated</emphasis>
<indexterm><primary>encapsulation of data</primary></indexterm>
<indexterm><primary>data</primary>
<secondary>encapsulation</secondary></indexterm>
because the only way to access it
is through one of these surrounding actions. The encapsulated internal
characteristics of an object are its
<indexterm><primary>variables</primary>
<secondary>in objects</secondary></indexterm>
<emphasis>variables</emphasis>. Variables are associated
with an object and exist for the lifetime of that object:</para>

<figure><title>Encapsulated 5 Object</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxo90007.jpg" scale="70">
</imageobject>
</mediaobject>
</figure>

<para>Rexx comes with a basic set of classes for creating objects (see
<link linkend="provide">Objects and Classes</link>). Therefore, you can create
objects that exactly match the needs of a particular application.</para>
</section>

<section id="interac"><title>How Objects Interact</title>
<indexterm><primary>messages</primary></indexterm>
<para>The actions within an object
are its only interface to other objects. Actions form a kind of &quot;wall&quot;
that encapsulates the object, and shields its internal information from outside
objects. This shielding is called
<indexterm><primary>information hiding</primary></indexterm>
<emphasis role="italic">information hiding.</emphasis> Information
hiding protects an object's data from corruption by outside objects, and
also protects outside objects from relying on another object's private
data, which can change without warning.</para>
<para>One object can act upon another (or
cause it to act) only by calling that object's actions, namely by sending
<emphasis>messages</emphasis>. Objects respond to these messages by performing
an action, returning data, or both. A message to an object must specify:
<itemizedlist>
<listitem><para>A receiving object</para></listitem>
<listitem>
<indexterm><primary>~ (tilde or twiddle)</primary></indexterm>
<indexterm><primary>tilde (~)</primary></indexterm>
<indexterm><primary>twiddle (~)</primary></indexterm>
<indexterm><primary>message-send operator (~)</primary></indexterm>
<para>The &quot;message send&quot; symbol, ~,
which is called the <emphasis>twiddle</emphasis></para></listitem>
<listitem><para>The action and, optionally in parentheses, any parameters
required</para></listitem>
</itemizedlist></para>
<para>So the message format looks like this: </para>
<programlisting>
object~action(parameters)
</programlisting>
<para>Assume that the object is the string
<computeroutput>!iH.</computeroutput> Sending it a message
to use its REVERSE action: </para>
<programlisting>
"!iH"~reverse
</programlisting>
<para>returns the string object <computeroutput>Hi!.</computeroutput></para>
</section>

<section id="methods"><title>Methods</title>
<indexterm><primary>method</primary>
<secondary>definition</secondary></indexterm>
<para>Sending a message to
an object results in performing some action; that is, it results in running
some underlying code. The action-generating code is called a
<emphasis>method</emphasis>. When you send a message to an object,
you specify its method
name in the message. Method names are character strings like REVERSE. In the
preceding example, sending the <computeroutput>reverse</computeroutput> message
to the <computeroutput>!iH</computeroutput> object causes it to run the
REVERSE method. Most objects are capable
of more than one action, and so have a number of available methods.</para>
<para>The classes Rexx provides include their own predefined methods. The Message
class, for example, has the COMPLETED, INIT, NOTIFY, RESULT, SEND, and START
methods. When you create your own classes, you can write new methods for them
in Rexx code. Much of the object programming in Rexx is writing the code for
the methods you create.</para>
</section>

<section id="xpolym"><title>Polymorphism</title>
<indexterm><primary>variables</primary>
<secondary>aquiring</secondary></indexterm>
<indexterm><primary>polymorphism</primary></indexterm>
<para>Rexx lets you send the same message to objects that are different:</para>
<programlisting>
"!iH"~reverse   /* Reverses the characters "!iH" to form "Hi!"  */
pen~reverse     /* Reverses the direction of a plotter pen      */
ball~reverse    /* Reverses the direction of a moving ball      */
</programlisting>

<para>As long as each object has its own REVERSE method, REVERSE runs
even if the programming implementation is different for each object. This
ability to hide different functions behind a common interface is called
<emphasis>polymorphism</emphasis>.  As a result of information
hiding, each object in the previous example knows only its own version of
REVERSE. And even though the objects are different, each reverses itself as
dictated by its own code.</para>
<para>Although the <computeroutput>!iH</computeroutput> object's
REVERSE code is different from
the plotter pen's, the method name can be the same because Rexx keeps
track of the methods each object owns. The ability to reuse the same method
name so that one message can initiate more than one function is another feature
of polymorphism. You do not need to have several message names like
REVERSE_STRING,
REVERSE_PEN, REVERSE_BALL. This keeps method-naming schemes simple and makes
complex programs easy to follow and modify.</para>
<para>The ability to hide the various implementations of a method while leaving
the interface the same illustrates polymorphism at its lowest level. On a
higher level, polymorphism permits extensive code reuse.</para>
</section>

<section id="xclass"><title>Classes and Instances</title>
<indexterm><primary>class</primary>
<secondary>definition</secondary></indexterm>
<indexterm><primary>instances</primary>
<secondary>definition</secondary></indexterm>

<para>In Rexx, objects are
organized into <emphasis>classes</emphasis>. Classes are like templates;
they define the methods and variables that a group of similar objects have
in common and store them in one place.</para>
<para>If you write a program to manipulate some screen icons, for example, you
might create an Icon class. In that Icon class you can include all the icon
objects with similar actions and characteristics:</para>

<figure><title>A Simple Class</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxo90008.jpg" scale="70">
</imageobject>
</mediaobject>
</figure>

<para>All the icon objects might use common methods like DRAW or ERASE. They
might contain common variables like position, color, or size. What makes each
icon object different from one another is the data assigned to its variables.
For the Windows system icon, it might be position="20,20",
while for the shredder it is "20,30" and for information it is "20,40":</para>

<figure><title>Icon Class</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxo90011.jpg" scale="70">
</imageobject>
</mediaobject>
</figure>

<para>Objects that belong to a class are called
<emphasis>instances</emphasis> of that class. As instances of the Icon class,
the Windows system icon, shredder icon, and
information icon <emphasis>acquire</emphasis> the methods and variables
of that class. Instances behave as if they each had their own methods and
variables of the same name. All instances, however, have their own unique
properties--the <emphasis>data</emphasis> associated with the variables.
Everything else can be stored at the class level.</para>

<figure><title>Instances of the Icon Class</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxo90014.jpg" scale="70">
</imageobject>
</mediaobject>
</figure>

<para>If you must update or change a particular method, you
only have to change it at one place, at the class level. This single update
is then acquired by every new instance that uses the method.</para>
<para>A class that can create instances
of an object is called an <emphasis>object class</emphasis>.
<indexterm><primary>object classes</primary></indexterm>
The Icon class
is an object class you can use to create other objects with similar properties,
such as an application icon or a drives icon.</para>
<para>An object class is like a factory for producing instances of the objects.
</para>
</section>

<section id="abstrac"><title>Data Abstraction</title>
<indexterm><primary>data</primary>
<secondary>abstraction</secondary></indexterm>
<para>The ability to create
new, high-level data types and organize them into a meaningful class structure
is called <emphasis>data abstraction</emphasis>. Data abstraction is at
the core of object-oriented programming. Once you model objects with real-world
properties from the basic data types, you can continue creating, assembling,
and combining them into increasingly complex objects. Then you can use these
objects as if they were part of the original programming language.</para>
</section>

<section id="sub"><title>Subclasses, Superclasses, and Inheritance</title>
<indexterm><primary>inheritance</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>subclasses</secondary></indexterm>
<indexterm><primary>class</primary>
<secondary>superclasses</secondary></indexterm>
<indexterm><primary>multiple inheritance</primary></indexterm>
<indexterm><primary>subclasses</primary></indexterm>
<indexterm><primary>superclasses</primary></indexterm>
<para>When you write your first object-oriented program, you do not have to begin
your real-world modeling from scratch. Rexx provides predefined classes and
methods. From there you can create additional classes and methods of your
own, according to your needs.</para>
<para>Rexx classes are hierarchical. Any subclass (a class below
another class in the hierarchy) <emphasis>inherits</emphasis> the methods and
variables of one or more <emphasis>superclasses</emphasis> (classes above a
class in the hierarchy):</para>

<figure><title>Superclass and Subclasses</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxo90017.jpg" scale="70">
</imageobject>
</mediaobject>
</figure>

<para>You can add a class to an existing superclass. For example, you might add
the Icon class to the Screen-Object superclass:</para>

<figure><title>The Screen-Object Superclass</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxo90018.jpg" scale="70">
</imageobject>
</mediaobject>
</figure>

<para>In this way, the subclass inherits additional methods
from the superclass. A class can have more than one superclass, for example,
subclass Bitmap might have the superclasses Screen-Object and Art-Object.
Acquiring methods and variables from more than one superclass is known as
<emphasis>multiple inheritance</emphasis>:</para>

<figure><title>Multiple Inheritance</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxo90019.jpg" scale="70">
</imageobject>
</mediaobject>
</figure>
</section>

<section id="structu"><title>Structure and General Syntax</title>
<indexterm><primary>language</primary>
<secondary>structure and syntax</secondary></indexterm>
<indexterm><primary>clauses</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>syntax</primary>
<secondary>general</secondary></indexterm>
<indexterm><primary>structure and syntax</primary></indexterm>
<indexterm><primary>variables</primary>
<secondary>aquiring</secondary></indexterm>
<para>On Windows and *nix, Rexx programs are not required
to start with a standard comment. However, for portability reasons, start
each Rexx program with a standard comment that begins in the first column
of the first line. For more information on comments, refer to
<link linkend="cmts">Comments</link>.</para>
<para>A Rexx program is built from a series of
<emphasis>clauses</emphasis> that are composed of: </para>
<itemizedlist>
<listitem><para>Zero or more whitespace characters (blank or horizontal tabs)
(which are ignored)</para></listitem>
<listitem><para>A sequence of tokens (see
<link linkend="xtokens">Tokens</link>)</para></listitem>
<listitem><para>Zero or more whitespace characters (again
ignored)</para></listitem>
<listitem><para>A semicolon (;)
<indexterm><primary>semicolons</primary>
<secondary>within a clause</secondary></indexterm>
delimiter that the line end, certain keywords, or the colon (:)
implies.</para></listitem></itemizedlist>
<para>Conceptually,
each clause is scanned from left to right before processing, and the tokens
composing it are identified. Instruction keywords are recognized at this stage,
comments are removed, and sequences of whitespace characters (except within
literal strings) are converted to single blanks.  Whitespace characters adjacent
to operator characters and special
<indexterm><primary>blanks</primary>
<secondary>adjacent to special character</secondary></indexterm>
<indexterm><primary>whitespace</primary>
<secondary>adjacent to special character</secondary></indexterm>
characters are also removed.</para>

<section id="characters"><title>Characters</title>
<indexterm><primary>character</primary>
<secondary>definition</secondary></indexterm>
<para>A <emphasis>character</emphasis> is a member of a
defined set of elements that is used for the
control or representation of data. You can usually enter a character with
a single keystroke. The coded representation of a character
is its representation
in digital form. A character, the letter A, for example, differs from
its <emphasis>coded representation</emphasis> or encoding.
Various coded character
sets (such as ASCII and EBCDIC) use different encodings
for the letter A (decimal
values 65 and 193, respectively). This book uses characters to convey meanings
and not to imply a specific character code, except where otherwise stated.
The exceptions are certain built-in functions that convert between characters
and their representations. The functions C2D, C2X, D2C, X2C, and XRANGE depend
on the character set used.</para>
<indexterm><primary>code page</primary></indexterm>
<indexterm><primary>page, code</primary></indexterm>
<para>A code page specifies the encodings for each character in a set. Be aware
that:
<itemizedlist>
<listitem><para>Some code pages do not contain all characters that Rexx defines
as valid (for example, the logical NOT character).</para></listitem>
<listitem><para>Some characters that Rexx defines
as valid have different encodings in
different code pages, for example the exclamation mark (!).</para></listitem>
</itemizedlist></para>
</section>

<section id="cmts"><title>Comments</title>
<indexterm><primary>comments</primary></indexterm>
<para>A comment is a sequence of characters delimited by specific characters.
It is ignored by the program but acts as a separator. For example, a token
containing one comment is treated as two tokens.</para>
<para>The interpreter recognizes the following types of comments:</para>
<itemizedlist>
<listitem><para>A line comment, where the comment is limited to one line
<indexterm><primary>comments</primary>
<secondary>line comment</secondary></indexterm>
</para></listitem>
<listitem><para>The standard Rexx comment, where the comment
can cover several lines
<indexterm><primary>comments</primary>
<secondary>standard comment</secondary></indexterm>
</para></listitem></itemizedlist>
<para>A <emphasis>line comment</emphasis> is
started by two subsequent minus signs (--) and ends at the end
of a line. Example:</para>
<indexterm><primary>examples</primary>
<secondary>line comments</secondary></indexterm>
<programlisting>
"Fred"
"Don&apos;t Panic!"
&apos;You shouldn&apos;&apos;t&apos;        -- Same as "You shouldn&apos;t"
""
</programlisting>
<para>In this example, the language processor processes the statements
from <computeroutput>&apos;Fred&apos;</computeroutput> to
<computeroutput>&apos;You shouldn&apos;&apos;t&apos;</computeroutput>, ignores the words following
the line comment, and continues to process the statement
<computeroutput>&apos;&apos;</computeroutput>.</para>
<para>A <emphasis>standard comment</emphasis> is a sequence of characters
(on one or more lines) delimited by /* and */. Within these delimiters any
characters are allowed.
Standard comments can contain other standard comments, as long as each begins
and ends with the necessary delimiters. They are called
<emphasis>nested comments</emphasis>. Standard comments can be anywhere and
of any length.</para>
<indexterm><primary>examples</primary>
<secondary>standard comments</secondary></indexterm>
<programlisting>
/* This is an example of a valid Rexx comment */
</programlisting>
<para>Take special care when commenting out lines of code containing
<computeroutput>/*</computeroutput> or <computeroutput>*/</computeroutput>
as part of a literal string. Consider the following
program segment: </para>
<programlisting>
01    parse pull input
02    if substr(input,1,5) = "/*123"
03      then call process
04    dept = substr(input,32,5)
</programlisting>
<para>To comment out lines 2 and 3, the following change would be incorrect:
</para>
<programlisting>
01    parse pull input
02 /* if substr(input,1,5) = "/*123"
03      then call process
04 */ dept = substr(input,32,5)
</programlisting>
<para>This is incorrect because the language processor would interpret the
<computeroutput>/*</computeroutput> that is part of the literal string
<computeroutput>/*123</computeroutput> as the start
of a nested standard comment. It would not process the rest of the program
because it would be looking for a matching standard comment end
(<computeroutput>*/</computeroutput>).</para>
<para>You can avoid this type of problem by using concatenation for literal
strings containing <computeroutput>/*</computeroutput> or
<computeroutput>*/</computeroutput>; line 2 would be: </para>
<programlisting>
if substr(input,1,5) = "/" || "*123"
</programlisting>
<para>You could comment out lines 2 and 3 correctly as follows: </para>
<programlisting>
01    parse pull input
02 /* if substr(input,1,5) = "/" || "*123"
03      then call process
04 */ dept = substr(input,32,5)
</programlisting>
<para>Both types of comments can be mixed and nested. However, when
you nest the two types, the type of comment that comes first takes precedence
over the one nested. Here is an example:</para>
<programlisting>
"Fred"
"Don&apos;t Panic!"
&apos;You shouldn&apos;&apos;t&apos;        /* Same as "You shouldn&apos;t"
""                      -- The null string         */
</programlisting>
<para>In this example, the language processor ignores everything after
<computeroutput>&apos;You shouldn&apos;&apos;t&apos;</computeroutput> up to the end of the last
line. In this case, the standard comment has precedence over the line comment.
</para>
<para>When nesting the two comment types, make sure that the start
delimiter of the standard comment <computeroutput>/*</computeroutput> is not
in the line commented out with the line comment signs.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
"Fred"
"Don&apos;t Panic!"
&apos;You shouldn&apos;&apos;t&apos;        -- Same as /* "You shouldn&apos;t"
""                      The null string         */
</programlisting>
<para>This example produces an error because the language processor
ignores the start delimiter of the standard comment, which is commented out
using the line comment.</para>
</section>

<section id="xtokens"><title>Tokens</title>
<indexterm><primary>tokens</primary>
<secondary>description</secondary></indexterm>
<para>A <emphasis>token</emphasis> is the unit of low-level syntax from which
clauses are built. Programs written in Rexx are composed of tokens. Tokens
can be of any length, up to an implementation-restricted maximum. They are
separated by whitespace or comments, or by the nature of the tokens themselves.
The classes of tokens are:
</para>
<itemizedlist>
<listitem><para>Literal strings</para></listitem>
<listitem><para>Hexadecimal strings</para></listitem>
<listitem><para>Binary strings</para></listitem>
<listitem><para>Symbols</para></listitem>
<listitem><para>Numbers</para></listitem>
<listitem><para>Operator characters</para></listitem>
<listitem><para>Special characters</para></listitem></itemizedlist>

<section id="litstrings"><title>Literal Strings</title>
<indexterm><primary>tokens</primary>
<secondary>literal strings</secondary></indexterm>
<indexterm><primary>literal</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>null</primary>
<secondary>strings</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>as literal constant</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>as name of function</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>null</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>quotations marks in</secondary></indexterm>
<para>A literal string is a sequence including <emphasis>any</emphasis>
characters except line feed (X"10") and delimited by a single quotation mark
(<computeroutput>&apos;</computeroutput>) or a double quotation mark
(<computeroutput>&quot;</computeroutput>). You use
two consecutive double quotation marks
(<computeroutput>&quot;&quot;</computeroutput>) to represent
one double quotation mark (<computeroutput>"</computeroutput>)
within a string delimited by double
quotation marks. Similarly, you use two consecutive single quotation marks
(<computeroutput>&apos;&apos;</computeroutput>) to represent one single quotation mark
(<computeroutput>&apos;</computeroutput>) within a string delimited by single
quotation marks. A literal string
is a constant and its contents are never modified when it is processed. Literal
strings must be complete on a single line. This means that unmatched quotation
marks can be detected on the line where they occur.</para>
<para>A literal string with no characters (that is, a string of length
<computeroutput>0</computeroutput>) is called a
<emphasis>null string</emphasis>.</para>
<para>These are valid strings: </para>
<programlisting>
"Fred"
"Don&apos;t Panic!"
&apos;You shouldn&apos;&apos;t&apos;        /* Same as "You shouldn&apos;t" */
""                      /* The null string         */
</programlisting>
<para><emphasis role="bold">Implementation maximum:</emphasis>
<indexterm><primary>implementation maximum</primary>
<secondary>literal strings</secondary></indexterm>
<indexterm><primary>literal</primary>
<secondary>implementation maximum</secondary></indexterm>
A literal string can contain an unlimited number of characters. The length
of the evaluated result of an expression, however, is limited only by the
available virtual storage of your computer, with an additional limit of 512MB
maximum per process.</para>
<para>Note that a string immediately followed by a right bracket is considered
to be the name of a function. If immediately followed by the symbol
<varname>X</varname> or <varname>x</varname>, it is considered to be a
hexadecimal string. If followed immediately by the symbol <varname>B</varname>
or <varname>b</varname>, it is considered to be a binary string.</para>
</section>

<section id="hexastrings"><title>Hexadecimal Strings</title>
<indexterm><primary>hexadecimal</primary>
<secondary>digits</secondary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>strings</secondary>
<tertiary>description</tertiary></indexterm>
<indexterm><primary>string</primary>
<secondary>hexidecimal specification of</secondary></indexterm>
<indexterm><primary>tokens</primary>
<secondary>hexadecimal strings</secondary></indexterm>
<para>A hexadecimal string is a literal string, expressed using
a hexadecimal notation of its encoding. It is any sequence of zero or more
hexadecimal digits
(<computeroutput>0</computeroutput>-<computeroutput>9</computeroutput>,
<computeroutput>a</computeroutput>-<computeroutput>f</computeroutput>,
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput>),
grouped in pairs. A single leading
0 is assumed, if necessary, at the beginning of the string to make an even
number of hexadecimal digits. The groups of digits are optionally separated
by one or more whitespace characters, and the whole sequence is delimited by
single or double quotation marks and immediately followed by the symbol
<computeroutput>X</computeroutput> or <computeroutput>x</computeroutput>.
Neither <computeroutput>x</computeroutput> nor
<computeroutput>X</computeroutput> can be part of a longer symbol. The
whitespace characters, which can only be byte boundaries (and not at the
beginning or end of the string), are to improve readability.  The language
processor ignores them.
</para>
<para>A hexadecimal string is a literal string formed by packing the hexadecimal
digits given. Packing the hexadecimal digits removes whitespace and converts
each pair of hexadecimal digits into its equivalent character, for example,
"41"X to A.
</para>
<para>Hexadecimal strings let you include characters in a program even if you
cannot directly enter the characters themselves. These are valid hexadecimal
strings: </para>

<programlisting>
"ABCD"x
"1d ec f8"X
"1 d8"x
</programlisting>

<note><title>Note</title>
<para>A hexadecimal string is <emphasis>not</emphasis> a representation
of a number. It is an escape mechanism that lets a user describe a character
in terms of its encoding (and, therefore, is machine-dependent). In ASCII, "20"X
is the encoding for a blank. In every case, a string of the form "....."x
is an alternative to a straightforward string. In ASCII "41"x and "A"
are identical, as are "20"x and a blank, and must be treated identically.
</para></note>
<para><emphasis role="bold">Implementation maximum:</emphasis>
<indexterm><primary>hexadecimal</primary>
<secondary>strings</secondary>
<tertiary>implementation maximum</tertiary></indexterm>
<indexterm><primary>implementation maximum</primary>
<secondary>hexadecimal strings</secondary></indexterm>
The packed length of a hexadecimal string (the string with whitespace removed)
is unlimited.
</para>
</section>

<section id="binstrings"><title>Binary Strings</title>
<indexterm><primary>binary</primary>
<secondary>digits</secondary></indexterm>
<indexterm><primary>binary</primary>
<secondary>strings</secondary>
<tertiary>description</tertiary></indexterm>
<indexterm><primary>binary</primary>
<secondary>strings</secondary>
<tertiary>nibbles</tertiary></indexterm>
<indexterm><primary>nibbles</primary></indexterm>
<indexterm><primary>string</primary>
<secondary>binary specification of</secondary></indexterm>
<indexterm><primary>tokens</primary>
<secondary>binary strings</secondary></indexterm>
<para>A binary string is a literal string, expressed using
a binary representation of its encoding. It is any sequence of zero or more
binary digits (<computeroutput>0</computeroutput> or
<computeroutput>1</computeroutput>) in groups of 8 (bytes) or 4 (nibbles).
The first group can have less than four digits; in this case, up to three
0 digits are assumed to the left of the first digit, making a total of four
digits. The groups of digits are optionally separated by one or more whitespace
characters, and the whole sequence is delimited by matching single or double
quotation marks and immediately followed by the symbol
<computeroutput>b</computeroutput> or <computeroutput>B</computeroutput>.
Neither <computeroutput>b</computeroutput> nor
<computeroutput>B</computeroutput> can be part of a longer symbol. The
whitespace characters, which can only be byte or nibble boundaries (and not at
the beginning or end of the string), are to improve readability. The language
processor ignores them.
</para>
<para>A binary string is a literal string formed by packing the binary digits
given. If the number of binary digits is not a multiple of 8, leading zeros
are added on the left to make a multiple of 8 before packing. Binary strings
allow you to specify characters explicitly, bit by bit. These are valid binary
strings: </para>

<programlisting>
"11110000"b        /* == "f0"x                  */
"101 1101"b        /* == "5d"x                  */
"1"b               /* == "00000001"b and "01"x  */
"10000 10101010"b  /* == "0001 0000 1010 1010"b */
""b                /* == ""                     */
</programlisting>
<para><emphasis role="bold">Implementation maximum:</emphasis>
<indexterm><primary>binary</primary>
<secondary>strings</secondary>
<tertiary>implementation maximum</tertiary></indexterm>
<indexterm><primary>implementation maximum</primary>
<secondary>binary strings</secondary></indexterm>
The packed length of a binary-literal string is unlimited.</para>
</section>

<section id="xsymbol"><title>Symbols</title>
<indexterm><primary>alphabetics</primary>
<secondary>used in symbols</secondary></indexterm>
<indexterm><primary>names</primary>
<secondary>of variables</secondary></indexterm>
<indexterm><primary>symbol</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>symbol</primary>
<secondary>uppercase translation</secondary></indexterm>
<indexterm><primary>symbol</primary>
<secondary>valid names</secondary></indexterm>
<indexterm><primary>tokens</primary>
<secondary>symbols</secondary></indexterm>
<indexterm><primary>variable</primary>
<secondary>names</secondary></indexterm>
<para>Symbols are groups of characters, selected
from the:</para>
<itemizedlist>
<listitem><para>English alphabetic characters
(<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>
and <computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>).
Note that some code pages do not include lowercase
English characters a-z.</para></listitem>
<listitem><para>Numeric characters
(<computeroutput>0</computeroutput>-<computeroutput>9</computeroutput>)
</para></listitem>
<listitem><para>Characters <computeroutput>. ! ?</computeroutput>
and underscore (<computeroutput>_</computeroutput>).
Note that the encoding of the exclamation mark depends on the code page used.
</para></listitem></itemizedlist>
<indexterm><primary>uppercase translation</primary>
<secondary>of symbols</secondary></indexterm>
<para>Any lowercase alphabetic character in a symbol is translated to uppercase
(that is, lowercase
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>
to uppercase
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>) before
use.</para>
<para>These are valid symbols: </para>
<programlisting>
Fred
Albert.Hall
WHERE?
</programlisting>
<para>If a symbol does not begin with a digit or a period, you can use it as
a variable and can assign it a value. If you have not assigned a value to
it, its value is the characters of the symbol itself, translated to uppercase
(that is, lowercase
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>
to uppercase
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>).
Symbols that begin with a number or a period are constant symbols
and cannot directly be assigned a value. (See
<link linkend="ensym">Environment Symbols</link>.)</para>
<para>One other form of symbol is allowed to support the representation of
numbers in exponential format. The symbol starts with a digit
(<computeroutput>0</computeroutput>-<computeroutput>9</computeroutput>)
or a period, and it can end with the sequence
<computeroutput>E</computeroutput> or <computeroutput>e</computeroutput>,
followed immediately by an optional sign (<computeroutput>-</computeroutput>
or <computeroutput>+</computeroutput>), followed immediately by one
or more digits (which cannot be followed
by any other symbol characters). The sign in this context is part of the symbol
and is not an operator.</para>
<para>These are valid numbers in exponential notation: </para>
<indexterm><primary>exponential notation</primary>
<secondary>example</secondary></indexterm>
<programlisting>
17.3E-12
.03e+9
</programlisting>
</section>

<section id="numbrs"><title>Numbers</title>
<indexterm><primary>numbers</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>rounding</primary>
<secondary>using a character string as a number</secondary></indexterm>
<indexterm><primary>tokens</primary>
<secondary>numbers</secondary></indexterm>
<para>Numbers are character strings consisting of one or more decimal digits,
with an optional prefix of a plus (+) or minus (-) sign, and optionally
including a single period (<computeroutput>.</computeroutput>) that represents
a decimal point. A number can also have a power of 10
<indexterm><primary>powers of ten in numbers</primary></indexterm>
suffixed in conventional exponential notation: an
<computeroutput>E</computeroutput> (uppercase or lowercase),
followed optionally by a plus or minus sign,
then followed by one or more decimal digits defining the power of 10. Whenever
a character string is used as a number, rounding can occur to a precision
specified by the NUMERIC DIGITS instruction (the default is nine digits).
See <link linkend="numarit">Numbers and Arithmetic</link> for
a full definition of numbers.</para>
<para>Numbers
<indexterm><primary>restrictions</primary>
<secondary>embedded in numbers</secondary></indexterm>
can have leading whitespace (before and after the sign) and trailing whitespace.
Whitespace characters cannot be embedded among the digits of a number or in the
exponential part. Note that a symbol or a literal string can be a number. A
number cannot be the name of a variable.
</para>
<para>These are valid numbers: </para>
<programlisting>
12
"-17.9"
127.0650
73e+128
" + 7.9E5 "
</programlisting>
<para>You can specify numbers with or without quotation marks around them. Note
that the sequence <computeroutput>-17.9</computeroutput>
(without quotation marks) in an expression
is not simply a number. It is a minus operator (which can be prefix minus
if no term is to the left of it) followed by a positive number. The result
of the operation is a number.</para>
<para>A <emphasis>whole number</emphasis> is a number that has a no decimal
part and that the language
processor would not usually express in exponential notation. That is, it has
no more digits before the decimal point than the current setting of NUMERIC
DIGITS (the default is nine).</para>
<para><emphasis role="bold">Implementation maximum:</emphasis>
<indexterm><primary>numbers</primary>
<secondary>implementation maximum</secondary></indexterm>
<indexterm><primary>implementation maximum</primary>
<secondary>numbers</secondary></indexterm>
<indexterm><primary>whole numbers</primary>
<secondary>description</secondary></indexterm>
The exponent of a number expressed in exponential notation can have
up to nine digits.</para>
</section>

<section id="operatorchar"><title>Operator Characters</title>
<indexterm><primary>concatenation</primary>
<secondary>operator</secondary>
<tertiary>||</tertiary></indexterm>
<indexterm><primary>operator</primary>
<secondary>as special characters</secondary></indexterm>
<indexterm><primary>operator</primary>
<secondary>characters</secondary></indexterm>
<indexterm><primary>tokens</primary>
<secondary>operator characters</secondary></indexterm>
<para>The characters
<computeroutput>+ -  \ /  %  *  | | &amp;  =  &not;  >  &lt;</computeroutput>
and the sequences
<computeroutput>>=  &lt;=  \>  \&lt;  \=  >&lt;  &lt;>  ==  \==  //  &amp;&amp;
||  ** &not;>  &not;&lt;  &not;=  &not;==  >>  &lt;&lt;  >>=  \&lt;&lt;
&not;&lt;&lt;  \>> &not;>>  &lt;&lt;=</computeroutput> indicate operations
 (see <link linkend="opera">Operators</link>).
(The <computeroutput>||</computeroutput> can also be used as the
concatenation symbol.)
A few of these are also used in parsing templates, and the equal sign
<indexterm><primary>equal</primary>
<secondary>sign</secondary>
<tertiary>to indicate assignment</tertiary></indexterm>
and the sequences <computeroutput>+=, -=, *= /=, %=, //=, ||=, &amp;=, |=, and &amp;&amp;=</computeroutput>
are also
used to indicate assignment. Whitespace characters adjacent to operator
characters are removed. Therefore, the following are identical in meaning:
</para>
<programlisting>
345>=123
345 >=123
345 >= 123
345 > = 123
</programlisting>
<para>Some of these characters (and some special characters--see the next
section) might not be available in all character sets. In this case,
appropriate translations can be used.
<indexterm><primary>logical OR operator</primary></indexterm>
In particular, the vertical bar (|) is often
shown as a split vertical bar (&brvbar;).</para>
<para>Throughout the language, the NOT (&not;)
<indexterm><primary>logical NOT character</primary></indexterm>
<indexterm><primary>NOT operator</primary></indexterm>
character is synonymous with the backslash
<indexterm><primary>backslash, use of</primary></indexterm>
(<computeroutput>\</computeroutput>). You can
use the two characters interchangeably according to availability and personal
preference.</para>

<note><title>Note</title>
<para>The Rexx interpreter uses ASCII character
124 in the concatenation operator and as the logical OR operator. Depending
on the code page or keyboard for your particular country, ASCII 124 can be
shown as a solid vertical bar (|) or a split vertical bar (&brvbar;).
The character on the screen might not match the character engraved on the
key. If you receive error 13,
<computeroutput>Invalid character in program</computeroutput>, on
an instruction including a vertical bar character, make sure this character
is ASCII 124.</para></note>
<para>The Rexx
interpreter uses ASCII character 170 for the logical NOT operator. Depending
on your country, the &not; might not appear on your keyboard. If the character
is not available, you can use the backslash (\) in place of &not;.</para>
</section>

<section id="specchar"><title>Special Characters</title>
<indexterm><primary>special</primary>
<secondary>characters and example</secondary></indexterm>
<indexterm><primary>tokens</primary>
<secondary>special characters</secondary></indexterm>
<para>The following characters, together with the operator characters,
have special significance when found outside of literal strings: </para>
<programlisting>
,   ;   :   (   )   [   ]   ~
</programlisting>
<indexterm><primary>comma</primary>
<secondary>as a special character</secondary></indexterm>
<indexterm><primary>, (comma)</primary>
<secondary>as a special character</secondary></indexterm>
<indexterm><primary>; semicolon</primary>
<secondary>as a special character</secondary></indexterm>
<indexterm><primary>: (colon)</primary>
<secondary>as a special character</secondary></indexterm>
<indexterm><primary>colon</primary>
<secondary>as a special character</secondary></indexterm>
<para>These characters constitute the set of special characters. They all act
as token delimiters, and
<indexterm><primary>parentheses</primary>
<secondary>adjacent to whitespace</secondary></indexterm> whitespace characters
(blank or horizontal tab)
adjacent to any of these are removed. There is an exception: a whitespace
character adjacent to the outside of a parenthesis or bracket is deleted only if
it is also adjacent to another special character (unless the character is a
parenthesis or bracket and the whitespace character is outside it, too). For
example, the language processor does not remove the blank in
<computeroutput>A&nbsp;(Z)</computeroutput>. This is a concatenation that is
not equivalent to <computeroutput>A(Z)</computeroutput>,
a function call. The language processor removes the blanks in
<computeroutput>(A)&nbsp;+&nbsp;(Z)</computeroutput> because this is equivalent
to <computeroutput>(A)+(Z)</computeroutput>.</para>
</section>

<section id="speccharexmp"><title>Example</title>
<para>The following
example shows how a clause is composed of tokens:</para>
<indexterm><primary>examples</primary>
<secondary>special characters</secondary></indexterm>
<programlisting>
"REPEAT"   A + 3;
</programlisting>
<para>This example is composed of six tokens--a literal string
(<computeroutput>"REPEAT"</computeroutput>), a blank operator, a symbol
(<computeroutput>A</computeroutput>, which can have an assigned
value), an operator (<computeroutput>+</computeroutput>), a second symbol
(<computeroutput>3</computeroutput>, which is
a number and a symbol), and the clause delimiter
(<computeroutput>;</computeroutput>). The blanks
between the <computeroutput>A</computeroutput> and the
<computeroutput>+</computeroutput> and between the
<computeroutput>+</computeroutput> and
the <computeroutput>3</computeroutput> are removed.
However, one of the blanks between the
<computeroutput>"REPEAT"</computeroutput> and the
<computeroutput>A</computeroutput> remains as an operator. Thus, this clause
is treated as though written: </para>
<programlisting>
"REPEAT" A+3;
</programlisting>
</section>
</section>

<section id="imsemi"><title>Implied Semicolons</title>
<indexterm><primary>implied semicolons</primary></indexterm>
<indexterm><primary>semicolons</primary>
<secondary>implied</secondary></indexterm>
<para>The last element in a clause is the semicolon (;) delimiter.
 The language processor implies the semicolon at a line end, after certain
keywords, and after a colon if it follows a single symbol. This means that
you need to include semicolons only when there is more than one clause on
a line or to end an instruction whose last character is a comma.</para>
<para>A line end usually marks the end of a clause and, thus, Rexx implies a
semicolon at most end of lines. However, there are the following exceptions:
<itemizedlist>
<listitem><para>The line ends in the middle of a comment. The clause continues
on to the next line.</para></listitem>
<listitem><para>The last token was the continuation character (a comma
or a minus sign) and the
line does not end in the middle of a comment.
(Note that a comment is not a token.)</para></listitem>
</itemizedlist></para>
<para>Rexx automatically implies semicolons after colons (when following a single
symbol, a label) and after certain keywords when they are in the correct context.
 The keywords that have this effect are ELSE, OTHERWISE, and THEN.  These
special cases reduce typographical errors significantly. </para>

<note><title>Note</title>
<para>The two characters forming the comment delimiters,
<computeroutput>/*</computeroutput> and
<computeroutput>*/</computeroutput>, must not be split by a line end (that is,
<computeroutput>/</computeroutput> and <computeroutput>*</computeroutput>
should not appear on different lines) because they could not then
be recognized correctly; an implied semicolon would be added. The two consecutive
characters forming a literal quotation mark within a string are also subject
to this line-end ruling.</para></note>
</section>

<section id="contin"><title>Continuations</title>
<indexterm><primary>, (comma)</primary>
<secondary>as continuation character</secondary></indexterm>
<indexterm><primary>clauses</primary>
<secondary>continuation of</secondary></indexterm>
<indexterm><primary>comma</primary>
<secondary>as continuation character</secondary></indexterm>
<indexterm><primary>continuation</primary>
<secondary>character</secondary></indexterm>
<indexterm><primary>continuation</primary>
<secondary>clauses</secondary></indexterm>
<para>One way to continue a clause on the next line is to use the comma or
the minus sign (-), which is referred to as the
<emphasis>continuation character</emphasis>. The continuation character is
functionally replaced by a blank, and, thus, no semicolon is implied.
One or more comments can follow
the continuation character before the end of the line.</para>
<para>The following example shows how to use the continuation character to
continue a clause:</para>
<indexterm><primary>continuation</primary>
<secondary>example</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>continuation</secondary></indexterm>
<programlisting>
say "You can use a comma",       -- this line is continued
"to continue this clause."
</programlisting><para>or </para>
<programlisting>
say "You can use a minus"-       -- this line is continued
"to continue this clause."
</programlisting>
</section>
</section>

<section id="expopr"><title>Terms, Expressions, and Operators</title>
<indexterm><primary>terms and data</primary></indexterm>
<para>Expressions in Rexx are a general mechanism for combining one or more
pieces of data in various ways to produce a result, usually different from the
original data. All expressions evaluate to objects.
<indexterm><primary>object</primary></indexterm>
</para>
<para>Everything in Rexx is an object.
<indexterm><primary>data</primary>
<secondary>objects</secondary></indexterm>
Rexx provides some objects, which are described in later sections. You can
also define and create objects that are useful in particular applications--for
example, a menu object for user interaction. See
<link linkend="objects">Modeling Objects</link> for
more information.</para>

<section id="expres"><title>Terms and Expressions</title>
<indexterm><primary>data</primary>
<secondary>terms</secondary></indexterm>
<para><emphasis>Terms</emphasis> are literal strings, symbols, message
terms, function calls, or subexpressions interspersed with zero or
more operators
that denote operations to be carried out on terms.</para>
<para><emphasis role="italic">Literal strings</emphasis>,
which are delimited by quotation marks, are constants.</para>
<para><emphasis>Symbols</emphasis> (no quotation marks) are translated to
uppercase. A symbol that does not begin with a digit or a period can be the
name of a variable; in this case the
<indexterm><primary>value</primary></indexterm>
value of that variable is used. A symbol
that begins with a period can identify an object that the current environment
provides; in this case, that object is used. Otherwise a symbol is treated
as a constant string. A symbol can also be
<emphasis role="italic">compound</emphasis>.</para>
<para><emphasis role="italic">Message terms</emphasis>
are described in <link linkend="mssg">Message Terms</link>.</para>
<para><emphasis role="italic">Function calls</emphasis>
(see <link linkend="funct">Functions</link>), which
are of the following form:
</para>
<programlisting>
<![CDATA[
                    +-,--------------+
                    V                |
>>-symbolorstring(----+------------+-+--)----------------------><
                      +-expression-+
]]>
</programlisting>

<para>The <emphasis role="italic">symbolorstring</emphasis> is a symbol or
literal string.</para>
<para>An <emphasis role="italic">expression</emphasis> consists of
one or more terms. A <emphasis role="italic">subexpression</emphasis>
<indexterm><primary>subexpression</primary></indexterm>
is a term in an
expression surrounded with a left and a right parenthesis.</para>
<indexterm><primary>evaluation of expressions</primary></indexterm>
<indexterm><primary>expressions</primary>
<secondary>evaluation</secondary></indexterm>
<para>Evaluation of an expression is left to right, modified by parentheses
and operator precedence in the usual algebraic manner (see
<link linkend="oprpri">Parentheses and Operator Precedence</link>).
Expressions are wholly evaluated, unless an error occurs during evaluation.
</para>
<indexterm><primary>expressions</primary>
<secondary>results of</secondary></indexterm>
<para>As each term is used in an expression, it is evaluated
as appropriate. The result is an object. Consequently, the result of evaluating
any expression is itself an object
<indexterm><primary>object</primary>
<secondary>as data value</secondary></indexterm>
(such as a character string).</para>
</section>

<section id="opera"><title>Operators</title>
<indexterm><primary>arithmetic</primary>
<secondary>operators</secondary></indexterm>
<indexterm><primary>messages to objects</primary>
<secondary>operator as message</secondary></indexterm>
<indexterm><primary>operator</primary>
<secondary>arithmetic</secondary>
<tertiary>description</tertiary></indexterm>
<indexterm><primary>operator</primary>
<secondary>as message</secondary></indexterm>
<para>An <emphasis role="italic">operator</emphasis> is a representation
of an operation, such as an addition, to be carried out on one or two terms.
Each operator, except for the prefix operators, acts on two terms, which can
be symbols, strings, function calls, message terms, intermediate results,
or subexpressions. Each prefix operator acts on the term or subexpression
that follows it. Whitespace characters (and comments) adjacent to operator
characters have no effect on the operator; thus, operators constructed from more
than one character can have embedded whitespace and comments. In addition, one
or more whitespace characters, if they occur in expressions but are not adjacent
to another operator, also act as an operator. The language processor
functionally translates operators into message terms. For dyadic operators,
<indexterm><primary>dyadic operators</primary></indexterm>
which operate on two terms, the
language processor sends the operator as a message to the term on the left,
passing the term on the right as an argument. For example, the sequence </para>
<programlisting>
say 1+2
</programlisting>
<para>is functionally equivalent to:</para>
<programlisting>
say 1~"+"(2)
</programlisting>
<para>The blank concatenation operator sends the message &quot;&nbsp;&quot;
(a single blank), and the abuttal concatenation operator sends the &quot;&quot;
message (a null string). When the &not; character is used in an operator, it
is changed to a <computeroutput>\</computeroutput>. That is, the operators
&not;= and \= both send the message \= to the target object.</para>
<para>For an operator that works on a single term (for example, the
prefix&nbsp;- and prefix&nbsp;+ operators), Rexx sends a message to the operand,
with no arguments. This means <computeroutput>-z</computeroutput> has the
same effect as <computeroutput>z~"-"</computeroutput>.</para>
<para>See <link linkend="mthObjectOperators">Operator Methods</link> for operator methods of
the Object class and   <link linkend="mthStringArithmeticMethods">Arithmetic Methods</link>
for operator methods of the String class.</para>
<para>There are four types of operators:
<itemizedlist>
<listitem><para>Concatenation</para></listitem>
<listitem><para>Arithmetic</para></listitem>
<listitem><para>Comparison</para></listitem>
<listitem><para>Logical</para></listitem></itemizedlist></para>

<section id="strgcon"><title>String Concatenation</title>
<indexterm><primary>concatenation</primary>
<secondary>of strings</secondary></indexterm>
<indexterm><primary>operator</primary>
<secondary>concatenation</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>concatenation of</secondary></indexterm>
<para>The concatenation operators combine two strings to form one string by
appending the second string to the right-hand end of the first string. The
concatenation may occur with or without an intervening blank. The concatenation
operators are: </para>
<variablelist>
<varlistentry><term><emphasis role="bold">(blank)</emphasis></term>
<listitem><para>Concatenate terms with one blank in between
<indexterm><primary>blanks</primary></indexterm>
<indexterm><primary>concatenation</primary>
<secondary>as concatenation operator</secondary></indexterm>
<indexterm><primary>concatenation</primary>
<secondary>blank</secondary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">||</emphasis></term>
<listitem><para>Concatenate without an intervening blank
<indexterm><primary>|| concatenation operator</primary></indexterm>
<indexterm><primary>concatenation</primary>
<secondary>operator</secondary>
<tertiary>||</tertiary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">(abuttal)</emphasis></term>
<listitem><para>Concatenate without an intervening blank
<indexterm><primary>concatenation</primary>
<secondary>abuttal</secondary></indexterm>
<indexterm><primary>abuttal</primary></indexterm>
</para></listitem></varlistentry>
</variablelist>
<para>You can force concatenation without a blank by using the
<computeroutput>||</computeroutput> operator.</para>
<para>The abuttal operator is assumed between two terms that are not separated
by another operator. This can occur when two terms are syntactically distinct,
such as a literal string and a symbol, or when they are only separated by
a comment.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<para>An example of syntactically distinct terms is: if
<computeroutput>Fred</computeroutput> has the
value <computeroutput>37.4</computeroutput>, then
<computeroutput>Fred"%"</computeroutput> evaluates to
<computeroutput>37.4%</computeroutput>.</para>
<para></para>
<para>If the variable <varname>PETER</varname> has the value
<computeroutput>1</computeroutput>, then <varname>(Fred)(Peter)</varname>
evaluates to <computeroutput>37.41</computeroutput>.</para>
<para>The two adjoining strings, one hexadecimal and one literal,
<computeroutput>"4a 4b"x"LMN"</computeroutput> evaluate to
<computeroutput>JKLMN</computeroutput>.</para>
<para>In the case of </para>
<programlisting>
Fred/* The NOT operator precedes Peter. */&not;Peter
</programlisting>
<para> there is no abuttal operator implied, and the expression is not valid.
 However, </para>
<programlisting>
(Fred)/* The NOT operator precedes Peter. */(&not;Peter)
</programlisting><para> results
in an abuttal, and evaluates to <computeroutput>37.40</computeroutput>.</para>
</section>

<section id="xarithm"><title>Arithmetic</title>
<indexterm><primary>numbers</primary>
<secondary>arithmetic on</secondary></indexterm>
<indexterm><primary>operator</primary>
<secondary>arithmetic</secondary>
<tertiary>list</tertiary></indexterm>
<indexterm><primary>operator</primary>
<secondary>comparison</secondary></indexterm>
<para>You can combine character strings that are
valid numbers (see <link linkend="numbrs">Numbers</link>)
using the following arithmetic operators: </para>
<variablelist>
<varlistentry><term>+
<indexterm><primary>+ (addition operator)</primary></indexterm>
<indexterm><primary>addition operator</primary></indexterm>
</term>
<listitem><para>Add
</para></listitem></varlistentry>
<varlistentry><term>-
<indexterm><primary>- (subtraction operator)</primary></indexterm>
<indexterm><primary>subtraction operator</primary></indexterm>
</term>
<listitem><para>Subtract
</para></listitem></varlistentry>
<varlistentry><term>*
<indexterm><primary>* (multiplication operator)</primary></indexterm>
<indexterm><primary>multiplication operator</primary></indexterm>
</term>
<listitem><para>Multiply
</para></listitem></varlistentry>
<varlistentry><term>/
<indexterm><primary>/ (division operator)</primary></indexterm>
<indexterm><primary>division operator</primary></indexterm>
</term>
<listitem><para>Divide
</para></listitem></varlistentry>
<varlistentry><term>%
<indexterm><primary>% (integer division operator)</primary></indexterm>
<indexterm><primary>integer division operator</primary></indexterm>
</term>
<listitem><para>Integer divide (divide and return the integer part of the
result) </para></listitem></varlistentry>
<varlistentry><term>//
<indexterm><primary>remainder operator</primary></indexterm>
</term>
<listitem><para>Remainder (divide and return the remainder--not modulo, because
the result can be negative)
</para></listitem></varlistentry>
<varlistentry><term>**
<indexterm><primary>exponentiation</primary>
<secondary>operator</secondary></indexterm>
</term>
<listitem><para>Power (raise a number to a whole-number power)
<indexterm><primary>power operator</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>
<emphasis role="bold">Prefix -</emphasis>
<indexterm><primary>prefix - operator</primary></indexterm>
<indexterm><primary>negation</primary>
<secondary>of logical values</secondary></indexterm>
</term>
<listitem><para>Same as the subtraction:
<computeroutput>0 - number</computeroutput>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Prefix +</emphasis>
<indexterm><primary>prefix + operator</primary></indexterm>
</term>
<listitem><para>Same as the addition:
<computeroutput>0 + number</computeroutput>
</para></listitem></varlistentry>
</variablelist><para> See <link linkend="numarit">Numbers and Arithmetic</link>
for details about precision, the format of valid numbers, and the
operation rules for arithmetic. Note that if an arithmetic result is
shown in exponential notation, it is likely that rounding has occurred.</para>
</section>

<section id="compari"><title>Comparison</title>
<indexterm><primary>comparisons</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>comparisons</primary>
<secondary>of strings</secondary></indexterm>
<indexterm><primary>equality, testing of</primary></indexterm>
<indexterm><primary>numbers</primary>
<secondary>comparison of</secondary></indexterm>
<indexterm><primary>strict comparison</primary></indexterm>
<indexterm><primary>string</primary>
<secondary>comparison of</secondary></indexterm>
<para>The
comparison operators compare two terms and return the value
<computeroutput>1</computeroutput> if
the result of the comparison is true, or <computeroutput>0</computeroutput>
otherwise.</para>
<para>The strict comparison operators
<indexterm><primary>strict comparison</primary></indexterm>
all have one of the characters defining the operator doubled. The
<computeroutput>==</computeroutput>,
<indexterm><primary>== (strictly equal operator)</primary></indexterm>
<indexterm><primary>strictly equal operator</primary></indexterm>
<computeroutput>\==</computeroutput>,
<indexterm><primary>inequality, testing of</primary></indexterm>
<indexterm><primary>\== (not strictly equal operator)</primary></indexterm>
<indexterm><primary>prefix \ operator</primary></indexterm>
and <computeroutput>&not;==</computeroutput>
<indexterm><primary>&not;== (not strictly equal operator)</primary></indexterm>
<indexterm><primary>strictly not equal operator</primary></indexterm>
operators test for an exact
match between two strings.  The two strings must be identical (character by
character) and of the same length to be considered strictly equal. Similarly,
the strict comparison operators such as
<computeroutput>&gt;&gt;</computeroutput>
<indexterm><primary>&gt;&gt; (strictly greater than operator)</primary>
</indexterm>
<indexterm><primary>strictly greater than operator</primary></indexterm>
or <computeroutput>&lt;&lt;</computeroutput>
<indexterm><primary>&lt;&lt; (strictly less than operator)</primary></indexterm>
<indexterm><primary>strictly less than operator</primary></indexterm>
carry out a simple character-by-character comparison, with no padding of either
of the strings being compared.  The comparison of the two strings is from
left to right. If one string is shorter than the other and is a leading
substring of another, then it is smaller than (less than) the other.
The strict comparison
<indexterm><primary>comparisons</primary>
<secondary>of numbers</secondary></indexterm>
operators also do not attempt to perform a numeric comparison on the two
operands.</para>
<para>For all other comparison operators, if both terms
involved are numeric, a numeric comparison (see
<link linkend="numcom">Numeric Comparisons</link>) is
effected. Otherwise, both terms are treated as character strings, leading
and trailing whitespace characters are ignored, and the shorter string is padded
with blanks on the right.
</para>
<para>Character comparison and strict comparison operations are both
case-sensitive, and the exact collating order might depend on the
character set used for the implementation. In an ASCII environment,
such as Windows and *nix, the ASCII character value of digits is lower than
that of the alphabetic characters,
and that of lowercase alphabetic characters is higher than that of uppercase
alphabetic characters.</para>
<para>The comparison operators and operations are: </para>
<variablelist>
<varlistentry><term>=</term>
<listitem><para>True if the terms are equal (numerically or when padded)
<indexterm><primary>= (equal sign)</primary>
<secondary>equal operator</secondary></indexterm>
<indexterm><primary>equal</primary>
<secondary>operator</secondary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>\=, &not;=</term>
<listitem><para>True if the terms are not equal (inverse of =)
<indexterm><primary>\= (not equal operator)</primary></indexterm>
<indexterm><primary>&not;= (not equal operator)</primary></indexterm>
<indexterm><primary>not equal operator</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>>
<indexterm><primary>greater than operator (>)</primary></indexterm>
</term>
<listitem><para>Greater than
<indexterm><primary>&gt; (greater than operator)</primary></indexterm>
<indexterm><primary>greater than operator</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>&lt;
<indexterm><primary>less than operator (&lt;)</primary></indexterm>
</term>
<listitem><para>Less than
<indexterm><primary>&lt; (less than operator)</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>>&lt;
<indexterm><primary>greater than or less than operator (>&lt;)</primary>
</indexterm>
</term>
<listitem><para>Greater than or less than (same as not equal)
<indexterm><primary>>&lt; (greater than or less than operator)</primary>
</indexterm>
<indexterm><primary>greater than or less than operator</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>&lt;&gt;
<indexterm><primary>less than or greater than operator (&lt;>)</primary>
</indexterm>
</term>
<listitem><para>Greater than or less than (same as not equal)
<indexterm><primary>&lt;&gt; (less than or greater than operator)</primary>
</indexterm>
</para></listitem></varlistentry>
<varlistentry><term>&gt;=
<indexterm><primary>greater than or equal to operator (>=)</primary>
</indexterm>
</term>
<listitem><para>Greater than or equal to
<indexterm><primary>&gt;= (greater than or equal operator)</primary>
</indexterm>
<indexterm><primary>greater than or equal operator</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>\&lt;, &not;&lt;</term>
<listitem><para>Not less than
<indexterm><primary>\&lt; (not less than operator)</primary></indexterm>
<indexterm><primary>&not;&lt; (not less than operator)</primary></indexterm>
<indexterm><primary>not less than operator</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>&lt;=
<indexterm><primary>less than or equal to operator (>=)</primary></indexterm>
</term>
<listitem><para>Less than or equal to
<indexterm><primary>&lt;= (less than or equal operator(&lt;=)</primary>
</indexterm>
</para></listitem></varlistentry>
<varlistentry><term>\>, &not;></term>
<listitem><para>Not greater than
<indexterm><primary>\&gt; (not greater than operator)</primary></indexterm>
<indexterm><primary>&not;> (not greater than operator)</primary></indexterm>
<indexterm><primary>not greater than operator</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>==</term>
<listitem><para>True if terms are strictly equal (identical)
<indexterm><primary>== (strictly equal operator)</primary></indexterm>
<indexterm><primary>strictly equal operator</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>\==, &not;==</term>
<listitem><para>True if the terms are not strictly equal (inverse of ==)
<indexterm><primary>\== (not strictly equal operator)</primary></indexterm>
<indexterm><primary>&not;== (not strictly equal operator)</primary></indexterm>
<indexterm><primary>strictly not equal operator</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>&gt;&gt;</term>
<listitem><para>Strictly greater than
<indexterm><primary>&gt;&gt; (strictly greater than operator)</primary>
</indexterm>
<indexterm><primary>strictly greater than operator</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>&lt;&lt;</term>
<listitem><para>Strictly less than
<indexterm><primary>&lt;&lt; (strictly less than operator)</primary></indexterm>
<indexterm><primary>strictly less than operator</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>&gt;&gt;=</term>
<listitem><para>Strictly greater than or equal to
<indexterm><primary>&gt;&gt;= (strictly greater than or equal operator)</primary>
</indexterm>
<indexterm><primary>strictly greater than or equal operator</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>\&lt;&lt;, &not;&lt;&lt;</term>
<listitem><para>Strictly not less than
<indexterm><primary>\&lt;&lt; (strictly not less than operator)</primary>
</indexterm>
<indexterm><primary>&not;&lt;&lt; (strictly not less than operator)</primary>
</indexterm>
<indexterm><primary>strictly not less than operator</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>&lt;&lt;=</term>
<listitem><para>Strictly less than or equal to
<indexterm><primary>&lt;&lt;= (strictly less than or equal operator)</primary>
</indexterm>
</para></listitem></varlistentry>
<varlistentry><term>\&gt;&gt;, &not;&gt;&gt;</term>
<listitem><para>Strictly not greater than
<indexterm><primary>\&gt;&gt; (strictly not greater than operator)</primary>
</indexterm>
<indexterm><primary>&not;&gt;&gt; (strictly not greater than operator)</primary>
</indexterm>
<indexterm><primary>strictly not greater than operator</primary></indexterm>
</para></listitem></varlistentry>
</variablelist>

<note><title>Note</title>
<para>Throughout the language, the NOT (&not;)
<indexterm><primary>&not; (NOT operator)</primary></indexterm>
character is
synonymous with the backslash(<computeroutput>\</computeroutput>).
<indexterm><primary>backslash, use of</primary></indexterm>
<indexterm><primary>\ (NOT operator)</primary></indexterm>
<indexterm><primary>prefix \ operator</primary></indexterm>
 You can use the two
characters interchangeably, according to availability and personal preference.
The backslash can appear in the following operators:
<computeroutput>\</computeroutput> (prefix
not),<computeroutput>\=</computeroutput>, <computeroutput>\==</computeroutput>,
<computeroutput>\&lt;</computeroutput>, <computeroutput>\></computeroutput>,
<computeroutput>\&lt;&lt;</computeroutput>, and
<computeroutput>\>></computeroutput>.
</para></note>
</section>

<section id="logicl"><title>Logical (Boolean)</title>
<indexterm><primary>boolean operations</primary></indexterm>
<indexterm><primary>logical</primary>
<secondary>operations</secondary></indexterm>
<indexterm><primary>operator</primary>
<secondary>logical</secondary></indexterm>
<para>A character string has the value false if it is
<computeroutput>0</computeroutput>, and true
if it is <computeroutput>1</computeroutput>. A logical operator can take at
least two values and return <computeroutput>0</computeroutput> or
<computeroutput>1</computeroutput> as appropriate: </para>
<variablelist>
<varlistentry><term>&amp;</term>
<listitem><para>AND -- returns <computeroutput>1</computeroutput> if both
terms are true.
<indexterm><primary>&amp; (AND logical operator) operator</primary></indexterm>
<indexterm><primary>AND, logical operator</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>|
<indexterm><primary>inclusive OR operator</primary></indexterm>
<indexterm><primary>OR, logical</primary></indexterm>
</term>
<listitem><para>Inclusive OR -- returns <computeroutput>1</computeroutput>
if either term or both terms are true.
<indexterm><primary>| inclusive OR operator</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term>&amp;&amp;
<indexterm><primary>exclusive OR operator</primary></indexterm>
<indexterm><primary>XOR, logical</primary></indexterm>
</term>
<listitem><para>Exclusive OR -- returns <computeroutput>1</computeroutput>
if either term, but not both terms, is true.
<indexterm><primary>&amp;&amp; (exclusive OR operator)</primary></indexterm>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Prefix</emphasis> \, &not;
<indexterm><primary>NOT operator</primary></indexterm>
<indexterm><primary>negation</primary>
<secondary>of logical values</secondary></indexterm>
</term>
<listitem><para>Logical NOT-- negates; <computeroutput>1</computeroutput>
becomes <computeroutput>0</computeroutput>, and
<computeroutput>0</computeroutput> becomes <computeroutput>1</computeroutput>.
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="oprpri"><title>Parentheses and Operator Precedence</title>
<indexterm><primary>algebraic precedence</primary></indexterm>
<indexterm><primary>precedence of operators</primary></indexterm>
<indexterm><primary>operator</primary>
<secondary>precedence (priorities) of</secondary></indexterm>
<indexterm><primary>parentheses</primary>
<secondary>in expressions</secondary></indexterm>
<para>Expression
evaluation is from left to right; parentheses and operator precedence modify
this:
<itemizedlist>
<listitem><para>When parentheses are encountered--other than those that
identify the arguments on messages (see
<link linkend="mssg">Message Terms</link>) and function calls--the
entire subexpression between the parentheses is evaluated immediately when
the term is required.</para></listitem>
<listitem><para>When the sequence </para>
<programlisting>
term1 operator1 term2 operator2 term3
</programlisting>
<para>is encountered, and <computeroutput>operator2</computeroutput>
has precedence over <computeroutput>operator1</computeroutput>,
the subexpression (<computeroutput>term2 operator2 term3</computeroutput>)
is evaluated first.</para>
<para>Note, however, that individual terms are evaluated from left
to right in the expression (that is, as soon as they are encountered).  The
precedence rules affect only the order of
<emphasis role="bold">operations</emphasis>.</para></listitem>
</itemizedlist></para>
<para> For example, <computeroutput>*</computeroutput> (multiply) has a
higher priority than <computeroutput>+</computeroutput> (add), so
<computeroutput>3+2*5</computeroutput> evaluates to
<computeroutput>13</computeroutput> (rather than
the <computeroutput>25</computeroutput> that would result if a
strict left-to-right evaluation occurred).
To force the addition to occur before the multiplication, you could rewrite
the expression as <computeroutput>(3+2)*5</computeroutput>.
Adding the parentheses makes the first
three tokens a subexpression. Similarly, the expression
<computeroutput>-3**2</computeroutput> evaluates
to <computeroutput>9</computeroutput> (instead of
<computeroutput>-9</computeroutput>) because the prefix minus operator
has a higher priority than the power operator.</para>
<para>The order of precedence of the operators is (highest at the top):</para>
<variablelist>
<varlistentry><term>+  -  &not;  \</term>
<listitem><para>(prefix operators)
</para></listitem></varlistentry>
<varlistentry><term>**</term>
<listitem><para>(power)
</para></listitem></varlistentry>
<varlistentry><term>*  /  %  //</term>
<listitem><para>(multiply and divide)
</para></listitem></varlistentry>
<varlistentry><term>+  -</term>
<listitem><para>(add and subtract)
</para></listitem></varlistentry>
<varlistentry><term>(blank) || (abuttal)</term>
<listitem><para>(concatenation with or without blank)
</para></listitem></varlistentry>
<varlistentry><term>=    >    &lt;</term>
<listitem><para>(comparison operators)
</para></listitem></varlistentry>
<varlistentry><term>==   >>   &lt;&lt;</term>
<listitem><para>&nbsp;
</para></listitem></varlistentry>
<varlistentry><term>\=  &not;=</term>
<listitem><para>&nbsp;
</para></listitem></varlistentry>
<varlistentry><term>>&lt;   &lt;></term>
<listitem><para>&nbsp;
</para></listitem></varlistentry>
<varlistentry><term>\>   &not;></term>
<listitem><para>&nbsp;
</para></listitem></varlistentry>
<varlistentry><term>\&lt;   &not;&lt;</term>
<listitem><para>&nbsp;
</para></listitem></varlistentry>
<varlistentry><term>\==   &not;==</term>
<listitem><para>&nbsp;
</para></listitem></varlistentry>
<varlistentry><term>\>>   &not;>></term>
<listitem><para>&nbsp;
</para></listitem></varlistentry>
<varlistentry><term>\&lt;&lt;   &not;&lt;&lt;</term>
<listitem><para>&nbsp;
</para></listitem></varlistentry>
<varlistentry><term>>=   >>=</term>
<listitem><para>&nbsp;
</para></listitem></varlistentry>
<varlistentry><term>&lt;=   &lt;&lt;=</term>
<listitem><para>&nbsp;
</para></listitem></varlistentry>
<varlistentry><term>&amp;</term>
<listitem><para>(and)
</para></listitem></varlistentry>
<varlistentry><term>|  &amp;&amp;</term>
<listitem><para>(or, exclusive or)
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<para>Suppose the symbol <computeroutput>A</computeroutput> is a variable
whose value is <computeroutput>3</computeroutput>,
<computeroutput>DAY</computeroutput> is a variable whose value is
<computeroutput>Monday</computeroutput>, and other variables are
uninitialized. Then:</para>
<indexterm><primary>examples</primary>
<secondary>expressions</secondary></indexterm>
<indexterm><primary>expressions</primary>
<secondary>examples</secondary></indexterm>
<programlisting>
<![CDATA[
A+5                  ->    "8"
A-4*2                ->    "-5"
A/2                  ->    "1.5"
0.5**2               ->    "0.25"
(A+1)>7              ->    "0"         /* that is, False */
" "=""               ->    "1"         /* that is, True  */
" "==""              ->    "0"         /* that is, False */
" "\==""             ->    "1"
/* that is, True  */
(A+1)*3=12           ->    "1"         /* that is, True  */
"077">"11"           ->    "1"         /* that is, True  */
"077" >> "11"        ->    "0"         /* that is, False */
"abc" >> "ab"        ->    "1"         /* that is, True  */
"abc" << "abd"       ->    "1"         /* that is, True  */
"ab " << "abd"       ->    "1"         /* that is, True  */
Today is Day         ->    "TODAY IS Monday"
"If it is" day       ->    "If it is Monday"
Substr(Day,2,3)      ->    "ond"    /* Substr is a function */
"!"xxx"!"            ->    "!XXX!"
]]>
</programlisting>

<note><title>Note</title>
<para>The Rexx order of precedence usually causes no difficulty because it is the
same as in conventional algebra and other computer languages. There are two
differences from common notations:
<itemizedlist>
<listitem><para>The prefix minus operator always has a higher priority than the
power operator.</para></listitem>
<listitem><para>Power operators (like other operators) are evaluated from
left to right.</para></listitem></itemizedlist></para>
<para>For example: </para>
<programlisting>
-3**2     ==  9  /* not -9  */
-(2+1)**2 ==  9  /* not -9  */
2**2**3   == 64  /* not 256 */
</programlisting></note>
</section>

<section id="mssg"><title>Message Terms</title>
<para>You can include <emphasis>messages</emphasis> to objects in an expression
wherever a term, such as a literal string, is valid. A message can be sent
to an object to perform an action, obtain a result, or both.</para>
<para>A <emphasis>message term</emphasis> can have one of the following forms:
</para>

<programlisting>
<![CDATA[
>>-receiver-+- ~ --+-messagename--+---------+------------------->
            +- ~~ -+              +-:symbol-+

>--+--------------------------+--------------------------------><
   +-(--+----------------+--)-+
        | .-,----------+ |
        | V            | |
        +---expression-+-+
]]>
</programlisting>

<programlisting>
<![CDATA[
>>-receiver[--+----------------+--]----------------------------><
              | +-,----------+ |
              | V            | |
              +---expression-+-+
]]>
</programlisting>

<para>The <emphasis role="italic">receiver</emphasis> is a term (see
<link linkend="expres">Terms and Expressions</link> for a definition
of term). It receives the message. The ~ or ~~ indicates
sending a message. The <emphasis role="italic">messagename</emphasis>
is a literal string or a symbol that is taken as a constant. The
<emphasis role="italic">expression</emphasis>s (separated by commas)
between the parentheses or brackets are the arguments for
the message. The <emphasis role="italic">receiver</emphasis>
and the argument <emphasis role="italic">expressions</emphasis> can
themselves include message terms. If the message has no arguments, you can
omit the parentheses.</para>
<para>The left parenthesis, if present, must immediately follow a token
(<emphasis role="italic">messagename</emphasis> or
<emphasis role="italic">symbol</emphasis>) with no blank in
between them. Otherwise, only the first part of the construct is recognized
as a message term. (A blank operator would be assumed at that point.) Only
a comment (which has no effect) can appear between a token and the left
parenthesis.</para>
<para>You can use any number of <emphasis role="italic">expressions</emphasis>,
separated by commas. The <emphasis role="italic">expressions</emphasis>
are evaluated from left to right and form the argument during
the execution of the routine. Any ARG, PARSE ARG, or USE ARG instruction or
ARG built-in function in the called routine accesses these objects while the
called routine is running. You can omit
<emphasis role="italic">expressions</emphasis>, if appropriate,
by including extra commas.</para>
<para>The <emphasis role="italic">receiver</emphasis> is evaluated, followed
by one or more <emphasis role="italic">expression</emphasis> arguments.
The message name (in uppercase) and the resulting argument
objects are then sent to the receiver object. The receiver object selects
a method to be run based on the message name
(see <link linkend="meths1">Classes and Inheritance</link>), and
runs the selected method with the specified argument objects. The receiver
eventually returns, allowing processing to continue.</para>
<para>If the message term uses ~, the receiver must return a result object.
This object is included in the original expression as if the entire message
term had been replaced by the name of a variable whose value is the returned
object.</para>
<para>For example, the message POS is valid for strings, and you could code:
</para>
<programlisting>
c="escape"
a="Position of &apos;e&apos; is:" c~pos("e",3)
/* would set A to "Position of &apos;e&apos; is: 6" */
</programlisting>
<para>If the message term uses ~~, the receiver needs not return
a result object. Any result object is discarded, and the receiver object is
included in the original expression in place of the message term.</para>
<para>For example, the messages INHERIT and SUBCLASS are valid for classes
(see <link linkend="clsClass">The Class Class</link>) and, assuming the
existence of the Persistent class, you could code:</para>
<programlisting>
account = .object~subclass("Account")~~inherit(.persistent)
/* would set ACCOUNT to the object returned by SUBCLASS, */
/* after sending that object the message INHERIT */
</programlisting>
<para>If the message term uses brackets, the message [] is sent to
the receiver object. (The <emphasis role="italic">expression</emphasis>s
within the brackets are available to the receiver object as arguments.)
The effect is the same as for the corresponding ~
form of the message term. Thus, <computeroutput>a[b]</computeroutput>
is the same as <computeroutput>a~"[]"(b)</computeroutput>.</para>

<para>For example, the message [] is valid for arrays
(see <link linkend="clsArray">The Array Class</link>) and you could code:</para>
<programlisting>
a = .array~of(10,20)
say "Second item is" a[2]   /* Same as: a~at(2)              */
/* or a~"[]"(2)                  */
/* Produces: "Second item is 20" */
</programlisting>
<indexterm><primary>arguments</primary>
<secondary>passing in messages</secondary></indexterm>
<para>A message can have a variable number of arguments. You need to specify
only those required. For example,
<computeroutput>"ESCAPE"~POS("E")</computeroutput> returns
<computeroutput>1</computeroutput>.</para>
<para>A colon (:) and symbol can follow the message name. In this case, the
symbol must be the name of a variable (usually the special variable SUPER--see
page <link linkend="xsuper">SUPER</link>) or an environment symbol
(see <link linkend="ensym">Environment Symbols</link>).
The resulting value changes the usual method selection. For more information,
see <link linkend="chsrod">Changing the Search Order for Methods</link>.</para>
</section>

<section id="mseq"><title>Message Sequences</title>
<indexterm><primary>messages to objects</primary>
<secondary>~, using</secondary></indexterm>
<indexterm><primary>messages to objects</primary>
<secondary>~~, using</secondary></indexterm>
<para>The ~
<indexterm><primary>~ (tilde or twiddle)</primary></indexterm>
and ~~
<indexterm><primary>~~</primary></indexterm>
forms of message terms
differ only in their treatment of the result object. Using
<computeroutput>~</computeroutput> returns the result of the method.
Using <computeroutput>~~</computeroutput> returns
the object that received the message. Here is an example: </para>
<programlisting>
/* Two ways to use the INSERT method to add items to a list */
/* Using only ~ */
team = .list~of("Bob","Mary")
team~insert("Jane")
team~insert("Joe")
team~insert("Steve")
say "First on the team is:" team~firstitem     /* Bob   */
say "Last on the team is:" team~lastitem       /* Steve */
/* Do the same thing using ~~ */
team=.list~of("Bob","Mary")
/* Because ~~ returns the receiver of the message       */
/* each INSERT message following returns the list       */
/* object (after inserting the argument value).         */
team~~insert("Jane")~~insert("Joe")~~insert("Steve")
say "First on the team is:" team~firstitem     /* Bob   */
say "Last on the team is:" team~lastitem       /* Steve */
</programlisting>
<para>Thus, you would use ~ when you want the returned result to incorporate
the methods included in each stage of the message.</para>
</section>
</section>

<section id="clausin"><title>Clauses and Instructions</title>
<para>Clauses can be subdivided into the following types:
<itemizedlist>
<listitem><para>Null clauses</para></listitem>
<listitem><para>Directives</para></listitem>
<listitem><para>Labels</para></listitem>
<listitem><para>Instructions</para></listitem>
<listitem><para>Assignments</para></listitem>
<listitem><para>Message instructions</para></listitem>
<listitem><para>Keyword instructions</para></listitem>
<listitem><para>Commands</para></listitem></itemizedlist></para>

<section id="nullcla"><title>Null Clauses</title>
<indexterm><primary>clauses</primary>
<secondary>null</secondary></indexterm>
<indexterm><primary>null</primary>
<secondary>clauses</secondary></indexterm>
<para>A clause consisting only of whitespace characterss, comments, or both is a
<emphasis>null clause
</emphasis>. It is completely ignored.</para>

<note><title>Note</title>
<para>A null clause is not an instruction; for example, putting an extra
semicolon after the THEN or ELSE in an IF instruction is not equivalent to
using a dummy instruction (as it would be in the C language). The NOP
instruction is provided for this purpose.</para></note>
</section>

<section id="directives"><title>Directives</title>
<indexterm><primary>clauses</primary>
<secondary>directives</secondary></indexterm>
<para>A clause that begins with two colons is a <emphasis>directive</emphasis>.
Directives are nonexecutable code and can start in any column. They
divide a program into separate executable units (methods and routines) and
supply information about the program or its executable units. Directives perform
various functions, such as associating methods with a particular class (::CLASS
directive) or defining a method (::METHOD directive). See
<link linkend="dire">Directives</link> for
more information about directives.</para>
</section>

<section id="labels"><title>Labels</title>
<indexterm><primary>label</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>clauses</primary>
<secondary>labels</secondary></indexterm>
<indexterm><primary>colon</primary>
<secondary>as label terminators</secondary></indexterm>
<indexterm><primary>colon</primary>
<secondary>in a label</secondary></indexterm>
<para>A clause that consists of a single symbol
or string followed by a colon is a <emphasis>label</emphasis>. The colon
<indexterm><primary>: (colon)</primary>
<secondary>in a label</secondary></indexterm>
in this context implies a semicolon (clause separator), so no semicolon is
required.</para>

<para>The label's name is taken from the string or symbol part
of the label. If the label uses a symbol for the name, the label's name
is in uppercase. If a label uses a string, the name can contain mixed-case
characters.</para>
<para>Labels identify the targets of CALL instructions, SIGNAL instructions,
and internal function calls. Label searches for CALL, SIGNAL, and internal
function calls are case-sensitive. Label-search targets specified as symbols
cannot match labels with lowercase characters. Literal-string or computed-label
searches can locate labels with lowercase characters. More than one label
can precede an instruction. Labels are treated as null clauses and can be
traced selectively to aid debugging.</para>
<para>Labels can be any number of successive clauses. Several labels can precede
other clauses. Duplicate labels are permitted, but control is only passed
to the first of any duplicates in a program. The duplicate labels occurring
later can be traced but cannot be used as a target of a CALL, SIGNAL, or
function invocation.</para>
</section>

<section id="instructions"><title>Instructions</title>
<indexterm><primary>clauses</primary>
<secondary>instructions</secondary></indexterm>
<indexterm><primary>instructions</primary>
<secondary>definition</secondary></indexterm>
<para>An <emphasis>instruction</emphasis> consists
of one or more clauses describing some course of action for the language
processor to take. Instructions can be assignments, message instructions,
keyword instructions, or commands.</para>
</section>

<section id="assigns"><title>Assignments</title>
<indexterm><primary>clauses</primary>
<secondary>assignment</secondary></indexterm>
<para>A single clause of
the form <emphasis role="italic">symbol=expression</emphasis> is an instruction
known as an <emphasis>assignment</emphasis>. An assignment gives a (new) value
to a variable. See <link linkend="assinmt">Assignments and Symbols</link>.
</para>
<section><title>Extended Assignments</title>
<para>The character sequences <computeroutput>+=, -=, *= /=, %=, //=, ||=, &amp;=, |=, and &amp;&amp;=</computeroutput>
can be used to create extended assignments.  These sequences combine an operation with the assignment.
See <link linkend="extassign">Extended Assignments</link> for more details.</para>
</section>

<section id="msgit"><title>Message Instructions</title>
<indexterm><primary>clauses</primary>
<secondary>message instructions</secondary></indexterm>
<indexterm><primary>instructions</primary>
<secondary>message</secondary></indexterm>
<indexterm><primary>message instructions</primary></indexterm>
<para>A <emphasis>message instruction</emphasis> is a single clause in the
form of a message term (see <link linkend="mssg">Message Terms</link>)
or in the form
<emphasis role="italic">messageterm</emphasis>=<emphasis role="italic">expression</emphasis>.
A message is sent to an object, which responds by performing some action.
See <link linkend="msgi">Message Instructions</link>.</para>
</section>

<section id="keyinst"><title>Keyword Instructions</title>
<indexterm><primary>clauses</primary>
<secondary>keyword instructions</secondary></indexterm>
<indexterm><primary>instructions</primary>
<secondary>keyword</secondary></indexterm>
<indexterm><primary>subkeyword</primary></indexterm>
<para>A <emphasis>keyword instruction</emphasis> is one or more clauses, the
first of which starts
with a keyword that identifies the instruction. Keyword instructions control,
for example, the external interfaces and the flow of control. Some keyword
instructions can include nested instructions. In the following example, the
DO construct (DO, the group of instructions that follow it, and its associated
END keyword) is considered a single keyword instruction.</para>
<programlisting>
DO
  instruction
  instruction
  instruction
END
</programlisting>
<para>A <emphasis>subkeyword</emphasis> is
a keyword that is reserved within the context of a particular instruction,
for example, the symbols TO and WHILE in the DO instruction.</para>
</section>
</section>

<section id="cmds"><title>Commands</title>
<indexterm><primary>clauses</primary>
<secondary>commands</secondary></indexterm>
<indexterm><primary>command</primary>
<secondary>clause</secondary></indexterm>
<para>A <emphasis>command</emphasis> is a clause consisting of an expression
only. The expression is evaluated and the result is passed as a command string
to an external environment.</para>
</section>
</section>

<section id="assinmt"><title>Assignments and Symbols</title>
<indexterm><primary>assignment</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>clauses</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>clauses</primary>
<secondary>assignment</secondary></indexterm>
<indexterm><primary>equal</primary>
<secondary>sign</secondary>
<tertiary>to indicate assignment</tertiary></indexterm>
<indexterm><primary>restrictions</primary>
<secondary>first character of variable name</secondary></indexterm>
<indexterm><primary>symbol</primary>
<secondary>assigning values to</secondary></indexterm>
<indexterm><primary>symbol</primary>
<secondary>use of</secondary></indexterm>
<indexterm><primary>symbol</primary>
<secondary>simple</secondary></indexterm>
<indexterm><primary>variable</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>variable</primary>
<secondary>setting a new value</secondary></indexterm>
<indexterm><primary>variable</primary>
<secondary>valid names</secondary></indexterm>
<para>A <emphasis>variable</emphasis> is an object whose value can change
during the running of a
Rexx program. The process of changing the value of a variable is
called <emphasis>assigning</emphasis> a new value to it. The value of a
variable is a single object. Note that an object can be
composed of other objects, such as an array or directory object.</para>
<para>You can assign
a new value to a variable with the ARG, PARSE, PULL, or USE instructions,
the VALUE built-in function, or the
<indexterm><primary>variable</primary>
<secondary>pool interface</secondary></indexterm>
variable pool interface, but the most
common way of changing the value of a variable is the assignment instruction
itself. Any clause in the form</para>
<para><emphasis role="italic">symbol</emphasis>=<emphasis role="italic">
expression</emphasis>;</para>
<indexterm><primary>= (equal sign)</primary>
<secondary>assignment operator</secondary></indexterm>
<indexterm><primary>assignment</primary>
<secondary>indicator (=)</secondary></indexterm>
<para>is taken
to be an assignment. The result of
<emphasis role="italic">expression</emphasis> becomes the new value
of the variable named by the symbol to the left of the equal sign.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
/* Next line gives FRED the value "Frederic" */
Fred="Frederic"
</programlisting>
<para>The symbol naming the variable cannot begin with a digit
(<computeroutput>0</computeroutput>-<computeroutput>9</computeroutput>)
or a period.</para>
<para>You can use a symbol
in an expression even if you have not assigned a value to it, because a symbol
has a defined value at all times. A variable to which you have not assigned
<indexterm><primary>uninitialized variable</primary></indexterm>
a value is <emphasis>uninitialized</emphasis>.  Its value is the characters
of the symbol itself, translated to uppercase (that is,
lowercase <computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>
to uppercase
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>).
However, if it is a compound symbol (described under
<link linkend="compsym">Compound Symbols</link>), its value is the
derived name of the symbol.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
/* If Freda has not yet been assigned a value,   */
/* then next line gives FRED the value "FREDA"   */
Fred=Freda
</programlisting>
<indexterm><primary>symbol</primary>
<secondary>classifying</secondary></indexterm>
<indexterm><primary>symbol</primary>
<secondary>constant</secondary></indexterm>
<para>The meaning of a symbol
in Rexx varies according to its context. As a term in an expression, a symbol
belongs to one of the following groups: constant symbols, simple symbols,
compound symbols, environment symbols, and stems. Constant symbols cannot
be assigned new values. You can use simple symbols for variables where the
name corresponds to a single value. You can use compound symbols and stems
for more complex collections of variables although the collection classes
might be preferable in many cases. See
<link linkend="clsCollection">The Collection Classes</link>.</para>

<section id="extassign"><title>Extended Assignments</title>
<indexterm><primary>extended assignments</primary></indexterm>
<indexterm><primary>assignment</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>clauses</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>clauses</primary>
<secondary>extended assignment</secondary></indexterm>
<indexterm><primary>symbol</primary>
<secondary>assigning values to</secondary></indexterm>
<indexterm><primary>symbol</primary>
<secondary>use of</secondary></indexterm>
<indexterm><primary>variable</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>variable</primary>
<secondary>setting a new value</secondary></indexterm>
<para>The character sequences <computeroutput>+=, -=, *= /=, %=, //=, ||=, &amp;=, |=, and &amp;&amp;=</computeroutput>
can be used to create extended assignment instructions.  An extended assignment combines an binary operation with
an assignment where the term on the left side of the assignment is also used as the left term of the operator.  For
example,</para>
<programlisting>
    a += 1
</programlisting>
<para>is exactly equivalent to the instruction</para>
<programlisting>
    a = a + 1
</programlisting>
<para>Extended assignments are processed identically to the longer form of the instruction.</para>
</section>

<section id="constnt"><title>Constant Symbols</title>
<indexterm><primary>constant symbols</primary></indexterm>
<para>A <emphasis role="italic">constant symbol</emphasis> starts with
a digit (<computeroutput>0</computeroutput>-<computeroutput>9</computeroutput>)
or a period.</para>
<para>You cannot change the value of a constant symbol.  It is simply the string
consisting of the characters of the symbol (that is, with any lowercase
alphabetic characters translated to uppercase).</para>
<para>These are constant symbols: </para>
<programlisting>
77
827.53
.12345
12e5       /* Same as 12E5 */
3D
17E-3
</programlisting>
<para>Symbols where the first character is a period and the second character
is alphabetic are environment symbols.</para>
</section>

<section id="simpsym"><title>Simple Symbols</title>
<indexterm><primary>simple</primary>
<secondary>symbols</secondary></indexterm>
<indexterm><primary>variable</primary>
<secondary>simple</secondary></indexterm>
<para>A <emphasis role="italic">simple symbol</emphasis> does not contain
any periods and does not start with a digit
(<computeroutput>0</computeroutput>-<computeroutput>9</computeroutput>).</para>
<para>By default, its value is the characters of the symbol (that is, translated
to uppercase). If the symbol has been assigned a value, it names a variable
and its value is the value of that variable.</para>
<para>These are simple symbols: </para>
<programlisting>
FRED
Whatagoodidea?    /* Same as WHATAGOODIDEA? */
?12
</programlisting>
</section>

<section id="stems"><title>Stems</title>
<indexterm><primary>assignment</primary>
<secondary>of stems variables</secondary></indexterm>
<indexterm><primary>array</primary>
<secondary>initialization</secondary></indexterm>
<para>A <emphasis role="italic">stem</emphasis> is
a symbol that contains a period as the last character. It cannot start with
a digit or a period.</para>
<para>These are stems: </para>
<programlisting>
FRED.
A.
</programlisting><para>By default, the value of a stem is a Stem object. (See
<link linkend="clsStem">The Stem Class</link>.)
The stem variable's Stem object is automatically created the first time
you use the stem variable or a compound variable
(see <link linkend="compsym">Compound Symbols</link>)
containing the stem variable name. The Stem object's assigned name is
the name of the stem variable (with the characters translated to uppercase).
If the stem variable has been assigned a value, or the Stem object has been
given a default value, a reference to the stem variable returns the assigned
default value.</para>
<indexterm><primary>compound</primary>
<secondary>variable</secondary>
<tertiary>setting new value</tertiary></indexterm>
<indexterm><primary>stem of a variable</primary>
<secondary>assignment to</secondary></indexterm>
<para>Further, when a stem is the target of an assignment, a new Stem object
is created and assigned to the stem variable. The new value assigned to the
stem variable is given to the new Stem object as a default value. Following
the assignment, a reference to any compound symbol with that stem variable
returns the new value until another value is assigned to the stem, the Stem
object, or the individual compound variable.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
hole.  = "empty"
hole.19 = "full"
say  hole.1  hole.mouse  hole.19
/* says "empty empty full" */
</programlisting>
<indexterm><primary>initialization</primary>
<secondary>of arrays</secondary></indexterm>
<indexterm><primary>initialization</primary>
<secondary>of compound variables</secondary></indexterm>
<para>Thus, you can give a whole collection of variables the same value.</para>
<para>If the object assigned to a stem variable is already a Stem object, then
a new Stem object is not created. The assignment updates the stem variable
to refer to the existing Stem object.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
hole.   = "empty"
hole.19 = "full"
say  hole.1  hole.mouse  hole.19
/* Says "empty empty full" */

hole2. = hole.       /* copies reference to hole. stem to hole2. */

say  hole2.1  hole2.mouse  hole2.19

/* Also says "empty empty full" */
</programlisting>
<para>You can pass stem collections as function, subroutine, or method
arguments.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
/* CALL RANDOMIZE count, stem. calls routine */
Randomize: Use Arg count, stem.
do i = 1 to count
  stem.i = random(1,100)
end
return
</programlisting>

<note><title>Note</title>
<para>USE ARG must be used to access the stem variable as a collection.
PARSE and PARSE ARG force the stem to be a string value.</para></note>
<para>Stems can also be returned as function, subroutine, or method results.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
/* RANDOMIZE(count) calls routine */
Randomize: Use Arg count
do i = 1 to count
  stem.i = random(1,100)
end
return stem.
</programlisting>

<note><title>Note</title>
<para>The value that has been assigned to the
whole collection of variables can always be obtained by using the stem. However,
this is not the same as using a compound variable whose derived name is the
null string.</para></note>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
total. = 0
null = ""
total.null = total.null + 5
say total. total.null              /* says "0 5" */
</programlisting>
<para>You can use the DROP, EXPOSE, and PROCEDURE instructions to manipulate
collections of variables, referred to by their stems.
<computeroutput>DROP FRED.</computeroutput> assigns
a new Stem object to the specified stem. (See
<link linkend="keyDrop">DROP</link>.) <computeroutput>EXPOSE FRED.</computeroutput>
and <computeroutput>PROCEDURE EXPOSE FRED.</computeroutput> expose all possible
variables with that stem (see <link linkend="keyExpose">EXPOSE</link> and
<link linkend="keyProcedure">PROCEDURE</link>).</para>

<para>The DO instruction can also iterate over all of the values
assigned to a stem variable. See <link linkend="keyDo">DO</link> for more details.
</para>

<para><emphasis role="bold">Notes:</emphasis></para>
<orderedlist>
<listitem><para>When the ARG, PARSE, PULL, or USE instruction, the VALUE
built-in function, or the variable pool interface changes a variable, the
effect is identical with an assignment. Wherever a value can be assigned,
using a stem sets an entire collection of variables.</para></listitem>
<listitem><para>Any clause that starts with a symbol and whose second token is
(or starts with) an equal sign (<computeroutput>=</computeroutput>)
is an assignment, rather than an expression
(or a keyword instruction). This is not a restriction, because you can ensure
that the clause is processed as a command, such as by putting a null string
before the first name, or by enclosing the first part of the expression in
parentheses. </para>
<para>If you unintentionally use a Rexx keyword as the variable
name in an assignment, this should not cause confusion.  For example, the
following clause is an assignment, not an ADDRESS instruction:</para>
<programlisting>
Address="10 Downing Street";
</programlisting>
</listitem>
<listitem><para>You can use the VAR function (see
<link linkend="bifVar">VAR</link>) to test whether
a symbol has been assigned a value. In addition, you can set SIGNAL ON NOVALUE
to trap the use of any uninitialized variables (except when they are tails
in compound variables--see
<link linkend="uninit">UNINIT</link>-or stems).</para></listitem>
</orderedlist>
</section>

<section id="compsym"><title>Compound Symbols</title>
<indexterm><primary>tail</primary></indexterm>
<indexterm><primary>stem of a variable</primary>
<secondary>description</secondary></indexterm>
<indexterm><primary>assignment</primary>
<secondary>of compound variables</secondary></indexterm>
<indexterm><primary>associative storage</primary></indexterm>
<indexterm><primary>content addressable storage</primary></indexterm>
<indexterm><primary>array</primary>
<secondary>setting up</secondary></indexterm>
<indexterm><primary>compound</primary>
<secondary>symbols</secondary></indexterm>
<indexterm><primary>derived names of variables</primary></indexterm>
<indexterm><primary>compound</primary>
<secondary>variable</secondary>
<tertiary>description</tertiary></indexterm>
<indexterm><primary>period</primary>
<secondary>causing substitution in variable names</secondary></indexterm>
<indexterm><primary>substitution</primary>
<secondary>in variable names</secondary></indexterm>
<indexterm><primary>symbol</primary>
<secondary>compound</secondary></indexterm>
<indexterm><primary>variable</primary>
<secondary>compound</secondary></indexterm>
<para>A <emphasis role="italic">compound symbol</emphasis>
contains at least one period and two other characters.
It cannot start with a digit or a period, and if there is only one period
it cannot be the last character.</para>
<para>The name begins with a stem (that
part of the symbol up to and including the first period) and is followed by
a tail, which are parts of the name (delimited by periods)
<indexterm><primary>. (period)</primary>
<secondary>causing substitution in variable names</secondary></indexterm>
that are constant
symbols, simple symbols, or null. Note that you cannot use constant symbols
with embedded signs (for example, 12.3E+5) after a stem; in this case the
whole symbol would not be valid.</para>
<para>These are compound symbols: </para>
<programlisting>
FRED.3
Array.I.J
AMESSY..One.2.
</programlisting>
<para>Before the
symbol is used, that is, at the time of reference, the language processor
substitutes in the compound symbol the character string values of any simple
symbols in the tail (<computeroutput>I</computeroutput>,
<computeroutput>J</computeroutput>, and
<computeroutput>One</computeroutput> in the
examples), thus generating a new, derived name. The value of a compound symbol
is, by default, its derived name (used exactly as is) or, if it has been used
as the target of an assignment, the value of the variable named by the derived
name.</para>
<para>The substitution in the symbol permits arbitrary indexing (subscripting)
of collections of variables that have a common stem. Note that the values
substituted can contain <emphasis>any</emphasis> characters (including
periods and blanks). Substitution is done only once.</para>
<para>More formally, the derived name of a compound variable that is referenced
by the symbol </para>
<programlisting>
s0.s1.s2. --- .sn
</programlisting>
<para>is given by </para>
<programlisting>
d0.v1.v2. --- .vn
</programlisting>
<para>where <computeroutput>d0</computeroutput> is the name of the Stem
object associated with the stem variable <computeroutput>s0</computeroutput> and
<computeroutput>v1</computeroutput> to <computeroutput>vn</computeroutput>
are the values of the constant or simple symbols
<computeroutput>s1</computeroutput> through <computeroutput>sn</computeroutput>.
Any of the symbols <computeroutput>s1</computeroutput> to
<computeroutput>sn</computeroutput> can be null. The values
<computeroutput>v1</computeroutput> to <computeroutput>vn</computeroutput>
can also be null and can contain <emphasis>any</emphasis> characters.
Lowercase characters are not translated to uppercase,
blanks are not removed, and periods have no special significance. There is
no limit on the length of the evaluated name.</para>
<para>Some examples of simple and compound symbols follow in the form of a small
extract from a Rexx program: </para>
<programlisting>
a=3       /* assigns "3" to the variable A    */
z=4                 /*   "4"      to Z        */
c="Fred"            /*   "Fred"   to C        */
a.z="Fred"          /*   "Fred"   to A.4      */
a.fred=5            /*   "5"      to A.FRED   */
a.c="Bill"          /*   "Bill"   to A.Fred   */
c.c=a.fred          /*   "5"      to C.Fred   */
y.a.z="Annie"       /*   "Annie"  to Y.3.4    */
say  a  z  c  a.a  a.z  a.c  c.a  a.fred y.a.4
/* displays the string:                     */
/*    "3 4 Fred A.3 Fred Bill C.3 5 Annie"  */
</programlisting>
<para>You can use compound symbols to set up arrays and lists of variables in
which the subscript is not necessarily numeric, thus offering a great scope
for the creative programmer. A useful application is to set up an array in
which the subscripts are taken from the value of one or more variables,
producing a form of associative memory (content-addressable).</para>

<section id="evcoms"><title>Evaluated Compound Variables</title>
<para>The value of a stem variable is always a Stem object (see
<link linkend="clsStem">The Stem Class</link> for
details). A Stem object is a type of collection that supports the []
and []= methods used by other collection classes. The []
provides an alternate means of accessing compound variables that also allows
embedded subexpressions.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
a=3       /* assigns "3" to the variable A    */
z=4                 /*   "4"      to Z        */
c="Fred"            /*   "Fred"   to C        */
a.[z]="Fred"        /*   "Fred"   to A.4      */
a.[z+1]="Rick"      /*   "Rick"   to A.5      */
a.[fred]=5          /*   "5"      to A.FRED   */
a.[c]="Bill"        /*   "Bill"   to A.Fred   */
c.[c]=a.fred        /*   "5"      to C.Fred   */
y.[a,z]="Annie"     /*   "Annie"  to Y.3.4    */
say  a  z  c  a.[a] a.[z]  a.[z+1]
a.[c]  c.[a]  a.[fred] y.[a,z]
/* displays the string:                     */
/*    "3 4 Fred A.3 Fred Rick Bill C.3 5 Annie"  */
</programlisting>
</section>
</section>

<section id="ensym"><title>Environment Symbols</title>
<indexterm><primary>symbols</primary>
<secondary>environment</secondary></indexterm>
<para>An environment symbol starts with a period and has at least one other character.
This character must not be a digit. By default the value of an environment
symbol is the string consisting of the characters of the symbol (translated
to uppercase). If the symbol identifies an object in the current environment,
its value is that object.</para>
<para>These are environment symbols: </para>
<programlisting>
.method    /* Same as .METHOD */

.true
</programlisting>
<para>When you use an environment symbol, the language processor performs a
series of searches to see if the environment symbol has an assigned value. The
search locations and their ordering are:
<orderedlist>
<listitem><para>The directory of classes declared on ::CLASS directives (see
<link linkend="clasdi">::CLASS</link>)
within the current program file.</para></listitem>
<listitem><para>The directory of PUBLIC classes declared on ::CLASS directives
of other files included with a ::REQUIRES directive.</para></listitem>
<listitem><para>The local environment directory. The local
environment includes process-specific
objects such as the .INPUT and .OUTPUT objects. You can directly access the
local environment directory by using the .LOCAL environment symbol. (See
<link linkend="locenv">The Local Environment Object  (.LOCAL)</link>.)</para>
</listitem>
<listitem><para>The global environment directory.  The global environment
includes all
permanent Rexx objects such as the Rexx supplied classes (.ARRAY and so on)
and constants such as .TRUE and .FALSE. You can directly access the global
environment by using the .ENVIRONMENT environment symbol (see
<link linkend="envo">The Environment Object</link>)
or the VALUE built-in function (see <link linkend="bifValue">VALUE</link>)
with a null string for the
<emphasis role="italic">selector</emphasis> argument.</para></listitem>
<listitem><para>Rexx defined symbols. Other simple environment symbols are
reserved for use by Rexx built-in objects. The currently defined built-in
objects are .RS, .LINE, and .METHODS.</para></listitem>
</orderedlist>
</para>
<para>If an entry is not found for an environment symbol, then the default
character string value is used. </para>

<note><title>Note</title>
<para>You can place entries in both the .LOCAL
and the .ENVIRONMENT directories for programs to use. To avoid conflicts with
future Rexx defined entries, it is recommended that the entries that you place
in either directory include at least one period in the entry name.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
/* establish settings directory */
.local~setentry("MyProgram.settings", .directory~new)
</programlisting>
</note>
</section>
</section>

<section id="msgi"><title>Message Instructions</title>
<indexterm><primary>message instructions</primary></indexterm>
<indexterm><primary>message sequence instructions</primary></indexterm>
<indexterm><primary>instructions</primary>
<secondary>message</secondary></indexterm>
<para>You can send a message to an object to perform an action, obtain a result,
or both. You use a message instruction if the main purpose of the message
is to perform an action. You use a message term (see
<link linkend="mssg">Message Terms</link>)
if the main purpose of the message is to obtain a result.</para>
<para>A <emphasis>message instruction</emphasis> is a clause of the form:
</para>
<programlisting>
<![CDATA[
>>-messageterm--+-------------+--;-----------------------------><
                +-=expression-+
]]>
</programlisting>

<para>If there is only a <emphasis role="italic">messageterm</emphasis>,
the message is sent in exactly the same way as for a message term (see
<link linkend="mssg">Message Terms</link>). If the message
yields a result object, it is assigned to the sender's special variable RESULT.
If you use the ~~ form of message term, the receiver object
is used as the result. If there is no result object, the variable RESULT is
dropped (becomes uninitialized).
A message term using ~~ is sometimes referred to as a
<emphasis role="italic">cascading message</emphasis>.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>message instructions</secondary></indexterm>
<programlisting>
mytable~add("John",123)
</programlisting>
<para>This sends the message ADD to the object MYTABLE. The ADD method need not
return a result. If ADD returns a result, the result is assigned to the variable
RESULT.</para>
<para>The equal sign (=) sets a value. If
<computeroutput>=expression</computeroutput> follows
the message term, a message is sent to the receiver object with an
<computeroutput>=</computeroutput> concatenated to the end of the
message name. The result of evaluating
the expression is passed as the first argument of the message.</para>

<para><emphasis role="bold">Example:</emphasis></para>

<programlisting>
person~age = 39                   /* Same as person~"AGE="(39) */
table[i] = 5                      /* Same as table~"[]="(5,i)  */
</programlisting>
<para>The expressions are evaluated in the order in which the arguments are
passed to the method. That is, the language processor evaluates the
<computeroutput>=expression</computeroutput> first. Then it evaluates
the argument expressions within any [] pairs from left to right.</para>
<para>The extended assignment form may also be used with messaging terms.</para>
<para><emphasis role="bold">Example:</emphasis></para>

<programlisting>
   table[i] += 1        -- Same as table[i] = table[i] + 1
</programlisting>
<para>See <link linkend="extassign">Extended Assignments</link> for more details</para>
</section>

<section id="cmdhost"><title>Commands to External Environments</title>
<para>Issuing commands to the surrounding environment is an integral part of
Rexx.</para>

<section id="xenvir"><title>Environment</title>
<indexterm><primary>default</primary>
<secondary>environment</secondary></indexterm>
<para>The base system for the language processor is assumed to include
at least one environment for processing commands. An environment is selected by
default on entry to a Rexx program. You can change the environment by using
the ADDRESS instruction. You can find out the name of the current environment
by using the ADDRESS built-in function. The underlying operating system defines
environments external to the Rexx program. The environments selected depend
on the caller. Normally the default environment is the used shell, mostly "CMD"
on Windows systems and "bash" on Linux systems.
If called from an editor that accepts subcommands from
the language processor, the default environment can be that editor.</para>
<para>A Rexx program can issue commands--called
<emphasis>subcommands</emphasis>--to other application programs.
For example, a Rexx program written
for a text editor can inspect a file being edited, issue subcommands to make
changes, test return codes to check that the subcommands have been processed
as expected, and display messages to the user when appropriate.</para>
<para>An application that uses Rexx as a macro language must register its
environment with the Rexx language processor. See the
<citetitle pubwork="book">Open Object Rexx: Programming Guide</citetitle>
for a discussion of this mechanism.</para>
</section>

<section id="commnds"><title>Commands</title>
<indexterm><primary>command</primary>
<secondary>alternative destinations</secondary></indexterm>
<indexterm><primary>command</primary>
<secondary>issuing to host</secondary></indexterm>
<indexterm><primary>host commands</primary>
<secondary>issuing commands to underlying operating system</secondary>
</indexterm>
<indexterm><primary>special</primary>
<secondary>variables</secondary>
<tertiary>RC</tertiary></indexterm>
<para>To send a command to the currently addressed environment, use a clause
of the form:</para>
<programlisting>
expression;
</programlisting>
<para>The expression (which must not be an expression that forms a valid message
instruction--see <link linkend="msgi">Message Instructions</link>)
is evaluated, resulting in a character string value
(which can be the null string), which is then prepared as appropriate
and submitted to the underlying system. Any part of the expression not to
be evaluated must be enclosed in quotation marks.</para>
<para>The environment then processes the command and returns control
to the language processor after setting a return code. A
<emphasis>return code</emphasis> is a string, typically a number,
that returns some information
about the command processed. A return code usually indicates if a command
was successful but can also represent other information. The language processor
places this return code in the Rexx special variable RC.
<indexterm><primary>return</primary>
<secondary>code</secondary>
<tertiary>as set by commands</tertiary></indexterm>
<indexterm><primary>RC (return code)</primary>
<secondary>set by commands</secondary></indexterm>
<indexterm><primary>altering</primary>
<secondary>special variables</secondary></indexterm>
<indexterm><primary>variable</primary>
<secondary>special</secondary>
<tertiary>RC</tertiary></indexterm>
See <link linkend="spvard">Special Variables</link>.</para>

<para>In addition to setting a return code, the underlying system can also
indicate to the language processor if an error or failure occurred. An
<emphasis>error</emphasis> is a condition raised by a command to which a program
that uses that command can respond. For example, a locate command to an editing
system might report <computeroutput>requested string not found</computeroutput>
as an error. A <emphasis>failure</emphasis> is a condition raised by a command
to which a program that uses that command cannot respond, for example, a
command that is not executable or cannot be found.</para>
<para>Errors
<indexterm><primary>error</primary>
<secondary>definition</secondary></indexterm>
and failures in commands can affect Rexx processing if a condition
trap for ERROR or FAILURE is ON (see
<link linkend="condtra">Conditions and Condition Traps</link>). They can also
<indexterm><primary>failure, definition</primary></indexterm>
<indexterm><primary>error</primary>
<secondary>from commands</secondary></indexterm>
cause the command to be traced if <computeroutput>TRACE E</computeroutput>
or <computeroutput>TRACE F</computeroutput> is
set. <computeroutput>TRACE Normal</computeroutput> is the same as
<computeroutput>TRACE F</computeroutput> and is the
default--see <link linkend="keyTrace">TRACE</link>.</para>
<para>The .RS environment symbol can also be used to detect command failures
and errors. When the command environment indicates that a command failure
has occurred, the Rexx environment symbol .RS has the value
<computeroutput>-1</computeroutput>.
When a command error occurs, .RS has a value of
<computeroutput>1</computeroutput>. If the command
did not have a FAILURE or ERROR condition, .RS is
<computeroutput>0</computeroutput>.</para>
<para>Here is an example of submitting a command. Where the default
environment is Windows, the sequence:</para>
<programlisting>
fname = "CHESHIRE"
exten = "CAT"
"TYPE" fname"."exten
</programlisting>
<para>would result in passing the string
<computeroutput>TYPE CHESHIRE.CAT</computeroutput> to
the command processor. On Windows 95, this is COMMAND.COM. On
<trademark class="registered">Windows NT</trademark>, this is CMD.EXE.
The simpler expression:</para>
<programlisting>
"TYPE CHESHIRE.CAT"
</programlisting>
<para>has the same effect.</para>
<para>On return, the return code placed in RC will have the value
0 if the file CHESHIRE.CAT were typed, or a nonzero value if the file could
not be found in the current directory.</para>

<note><title>Note</title>
<para>Remember that the expression is evaluated before
it is passed to the environment. Enclose in quotation marks any part of the
expression that is not to be evaluated.</para></note>
<para><emphasis role="bold">Windows Example:</emphasis></para>
<programlisting>
delete "*".lst           /* not "multiplied by" */
var.003 = anyvalue
type "var.003"           /* not a compound symbol */

w = any
dir"/w"                  /* not "divided by ANY" */
</programlisting>
<para><emphasis role="bold">Linux Example:</emphasis></para>
<programlisting>
rm "*".lst               /* not "multiplied by" */
var.003 = anyvalue
cat "var.003"            /* not a compound symbol */

w = any
ls "/w"                  /* not "divided by ANY" */
</programlisting>

<para>Enclosing an entire message instruction in parentheses causes
the message result to be used as a command. Any clause that is a message
instruction is not treated as a command. Thus, for example, the clause </para>
<programlisting>
myfile~linein
</programlisting>
<para>causes the returned line to be assigned to the variable RESULT, not to
be used as a command to an external environment.</para>
</section>
</section>

<section id="linux"><title>Using Rexx on Windows and Unix</title>
<para></para>
<para>Rexx programs can call other Rexx programs as external
functions or subroutines with the
<link linkend="keyCall">call</link> instruction.</para>
<para>If a program is called with the
<link linkend="keyCall">call</link> instruction, the program runs in the same
process as the calling program.
If you call another program by a Rexx command, the program is executed in
a new process and therefore does not share .environment, .local,
or the Windows/Unix shell environment.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
call "other.REX"         /* runs in the same process */
"rexx other.REX"         /* runs in a new child process */
"start rexx other.REX"   /* runs in a new detached process */
</programlisting>
<para>When Rexx programs call other Rexx programs as commands, the return code
of the command is the exit value of the called program provided that this
value is a whole number in the range -32768 to 32767.  Otherwise, the exit
value is ignored and the called program is given a return code of 0.</para>
</section>
</chapter>
