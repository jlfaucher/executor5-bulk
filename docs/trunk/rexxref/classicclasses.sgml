<!--#########################################################################
    #
    # Description: Open Object Rexx: Reference SGML file.
    #
    # Copyright (c) 2005-2007, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<section id="classicclasses"><title>The Classic Rexx Classes</title>
<para>This section describes the ooRexx classes which implement the classic
Rexx data types including the string and stem types.</para>

<section id="strc"><title>The String Class</title>
<indexterm><primary>String class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>String class</secondary></indexterm>
<para>String objects represent character-string data values. A character
string value can have any length and contain any characters. If you are familiar
with earlier versions of Rexx you might find the notation for functions more
convenient than the notation for methods. See
<link linkend="funct">Functions</link> for function
descriptions.</para>
<para>The String class is a subclass of the Object class.</para>
<para><emphasis role="bold">Methods the String class defines:</emphasis></para>
<simplelist>
<member>NEW (Class method.&nbsp;&nbsp;Overrides Object class method)</member>
<member>Arithmetic methods: +, -, *, /, %, //, **</member>
<member>Comparison methods: =, \=, &lt;>, >&lt;, ==,
\==&nbsp;&nbsp;(Override Object class methods)</member>
<member>Comparison methods:&nbsp;&nbsp;>, &lt;, >=, \&lt;, &lt;=, \>, >>,
&lt;&lt;, >>=, \&lt;&lt;, &lt;&lt;=, \>></member>
<member>Logical methods:&nbsp;&nbsp;&amp;, |, &amp;&amp;, \</member>
<member>Concatenation methods:&nbsp;&nbsp;&quot;&quot; (abuttal),
&quot;&nbsp;&quot; (blank), ||</member>
<member>NEW (Overrides Object class method)</member>
<member>ABBREV</member>
<member>ABS</member>
<member>BITAND</member>
<member>BITOR</member>
<member>BITXOR</member>
<member>B2X</member>
<member>CENTER (or CENTRE)</member>
<member>CHANGESTR</member>
<member>COMPARE</member>
<member>COPIES</member>
<member>COUNTSTR</member>
<member>C2D</member>
<member>C2X</member>
<member>DATATYPE</member>
<member>DECODEBASE64</member>
<member>DELSTR</member>
<member>DELWORD</member>
<member>D2C</member>
<member>D2X</member>
<member>ENCODEBASE64</member>
<member>FORMAT</member>
<member>INSERT</member>
<member>LASTPOS</member>
<member>LEFT</member>
<member>LENGTH</member>
<member>MAKEARRAY</member>
<member>MAKESTRING</member>
<member>MAX</member>
<member>MIN</member>
<member>OVERLAY</member>
<member>POS</member>
<member>REVERSE</member>
<member>RIGHT</member>
<member>SIGN</member>
<member>SPACE</member>
<member>STRING (Overrides Object class method)</member>
<member>STRIP</member>
<member>SUBCHAR</member>
<member>SUBSTR</member>
<member>SUBWORD</member>
<member>TRANSLATE</member>
<member>TRUNC</member>
<member>VERIFY</member>
<member>WORD</member>
<member>WORDINDEX</member>
<member>WORDLENGTH</member>
<member>WORDPOS</member>
<member>WORDS</member>
<member>X2B</member>
<member>X2C</member>
<member>X2D</member>
</simplelist>
<para><emphasis role="bold">Methods inherited from the Object class:</emphasis>
</para>
<simplelist>
<member>CLASS</member>
<member>COPY</member>
<member>DEFAULTNAME</member>
<member>HASMETHOD</member>
<member>INIT</member>
<member>OBJECTNAME</member>
<member>OBJECTNAME=</member>
<member>REQUEST</member>
<member>RUN</member>
<member>SETMETHOD</member>
<member>START</member>
<member>UNSETMETHOD</member>
</simplelist>

<note><title>Note</title>
<para>The String class also has available class methods that its
metaclass, the Class class, defines.</para></note>

<section id="stinew"><title>NEW  (Class Method)</title>
<indexterm><primary>NEW method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>NEW method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-NEW(stringvalue)--------------------------------------------><
]]>
</programlisting>

<para>Returns a new string object initialized with the characters in
<emphasis role="italic">stringvalue</emphasis>.</para>
</section>

<section id="aritcso"><title>Arithmetic Methods</title>
<indexterm><primary>method</primary>
<secondary>arithmetic methods</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-arithmetic_operator(argument)-------------------------------><
]]>
</programlisting>


<note><title>Note</title>
<para>For the prefix - and prefix + operators, omit the parentheses
and <emphasis role="italic">argument</emphasis>.</para></note>
<para>Returns the result of performing the specified arithmetic operation on
the receiver object. The receiver object and the
<emphasis role="italic">argument</emphasis> must be
valid numbers (see <link linkend="numbrs">Numbers</link>). The
<emphasis role="italic">arithmetic_operator</emphasis> can be:
</para>
<variablelist>
<varlistentry><term>+
<indexterm><primary>+ method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>+</secondary></indexterm>
</term>
<listitem><para>Addition
</para></listitem></varlistentry>
<varlistentry><term>-
<indexterm><primary>- method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>-</secondary></indexterm>
</term>
<listitem><para>Subtraction
</para></listitem></varlistentry>
<varlistentry><term>*
<indexterm><primary>* method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>*</secondary></indexterm>
</term>
<listitem><para>Multiplication
</para></listitem></varlistentry>
<varlistentry><term>/
<indexterm><primary>/ method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>/</secondary></indexterm>
</term>
<listitem><para>Division
</para></listitem></varlistentry>
<varlistentry><term>%
<indexterm><primary>% method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>%</secondary></indexterm>
</term>
<listitem><para>Integer division (divide and return the integer part of the
result)</para></listitem></varlistentry>
<varlistentry><term>//
<indexterm><primary>// method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>//</secondary></indexterm>
</term>
<listitem><para>Remainder (divide and return the remainder--not modulo, because
the result can be negative)
</para></listitem></varlistentry>
<varlistentry><term>**
<indexterm><primary>** method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>**</secondary></indexterm>
</term>
<listitem><para>Exponentiation (raise a number to a whole-number power)
</para></listitem></varlistentry>
<varlistentry><term>Prefix -
<indexterm><primary>method</primary>
<secondary>prefix -</secondary></indexterm>
</term>
<listitem><para>Same as the subtraction:
<computeroutput>0 - number</computeroutput>
</para></listitem></varlistentry>
<varlistentry><term>Prefix +
<indexterm><primary>method</primary>
<secondary>prefix +</secondary></indexterm>
</term>
<listitem><para>Same as the addition:
<computeroutput>0 + number</computeroutput>
</para></listitem></varlistentry>
</variablelist>
<para>See <link linkend="numarit">Numbers and Arithmetic</link> for details
about precision, the format of valid
numbers, and the operation rules for arithmetic. Note that if an arithmetic
result is shown in exponential notation, it might have been rounded.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>arithmetic methods of String class</secondary></indexterm>
<programlisting>
<![CDATA[
5+5     ->    10
8-5     ->     3
5*2     ->    10
6/2     ->     3
9//4    ->     1
9%4     ->     2
2**3    ->     8
+5      ->     5             /* Prefix +  */
-5      ->    -5             /* Prefix -  */
]]>
</programlisting>
</section>

<section id="commeth"><title>Comparison Methods</title>
<indexterm><primary>method</primary>
<secondary>comparison methods</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-comparison_operator(argument)-------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) or
<computeroutput>0</computeroutput> (false), the result of performing
the specified comparison operation. The receiver object and the
<emphasis role="italic">argument</emphasis> are the terms compared. Both must
be string objects.</para>

<para>The comparison operators you can use in a message are: </para>
<variablelist>
<varlistentry><term>=
<indexterm><primary>= method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>=</secondary>
<tertiary>of String class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are equal (for example, numerically or when
padded)
</para></listitem></varlistentry>
<varlistentry><term>\=, &gt;&lt;, &lt;&gt;
<indexterm><primary>>&lt; method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>&gt;&lt; method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>&lt;&gt; method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>\=</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>>&lt;</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;&gt;</secondary>
<tertiary>of String class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are not equal (inverse of =)
</para></listitem></varlistentry>
<varlistentry><term>&gt;
<indexterm><primary>&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>></secondary></indexterm>
</term>
<listitem><para>Greater than
</para></listitem></varlistentry>
<varlistentry><term>&lt;
<indexterm><primary>&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;</secondary></indexterm>
</term>
<listitem><para>Less than
</para></listitem></varlistentry>
<varlistentry><term>&gt;=
<indexterm><primary>&gt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&gt;=</secondary></indexterm>
</term>
<listitem><para>Greater than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&lt;
<indexterm><primary>\&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&lt;</secondary></indexterm>
</term>
<listitem><para>Not less than
</para></listitem></varlistentry>
<varlistentry><term>&lt;=
<indexterm><primary>&lt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;=</secondary></indexterm>
</term>
<listitem><para>Less than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&gt;
<indexterm><primary>\&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&gt;</secondary></indexterm>
</term>
<listitem><para>Not greater than
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>comparison methods of String class</secondary></indexterm>
<programlisting>
<![CDATA[
5=5        ->     1          /* equal            */

42\=41     ->     1          /* All of these are */
42><41     ->     1          /* "not equal"      */
42<>41     ->     1

13>12      ->     1          /* Variations of    */
12<13      ->     1          /* less than and    */
13>=12     ->     1          /* greater than     */
12\<13     ->     0
12<=13     ->     1
12\>13     ->     1
]]>
</programlisting>
<para>All strict comparison operations have one of the characters doubled that
define the operator. The <computeroutput>==</computeroutput> and
<computeroutput>\==</computeroutput> operators check
whether two strings match exactly. The two strings must be identical (character
by character) and of the same length to be considered strictly equal.</para>
<para>The strict comparison operators such as
<computeroutput>>></computeroutput> or
<computeroutput>&lt;&lt;</computeroutput> carry out a simple
character-by-character comparison. There is no padding
of either of the strings being compared. The comparison of the two strings
is from left to right. If one string is shorter than and a leading substring
of another, then it is smaller than (less than) the other. The strict
comparison operators do not attempt to perform a numeric comparison on the
two operands.</para>
<para>For all the other comparison operators, if both terms
are numeric, the language processor does a numeric comparison (ignoring, for
example, leading zeros--see <link linkend="numcom">Numeric Comparisons</link>).
Otherwise, it treats
both terms as character strings, ignoring leading and trailing blanks and
padding the shorter string on the right with blanks.</para>
<para>Character comparison and strict comparison operations are both
case-sensitive,
and for both the exact collating order can depend on the character set. In
an ASCII environment, the digits are lower than the alphabetic characters,
and lowercase alphabetic characters are higher than uppercase alphabetic
characters.</para>
<para>The strict comparison operators you can use in a message are: </para>
<variablelist>
<varlistentry><term>==
<indexterm><primary>== method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>==</secondary>
<tertiary>of String class</tertiary></indexterm>
</term>
<listitem><para>True if terms are strictly equal (identical)
</para></listitem></varlistentry>
<varlistentry><term>\==
<indexterm><primary>\== method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\==</secondary>
<tertiary>of String class</tertiary></indexterm>
</term>
<listitem><para>True if the terms are NOT strictly equal (inverse of ==)
</para></listitem></varlistentry>
<varlistentry><term>&gt;&gt;
<indexterm><primary>&gt;&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>>></secondary></indexterm>
</term>
<listitem><para>Strictly greater than
</para></listitem></varlistentry>
<varlistentry><term>&lt;&lt;
<indexterm><primary>&lt;&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;&lt;</secondary></indexterm>
</term>
<listitem><para>Strictly less than
</para></listitem></varlistentry>
<varlistentry><term>&gt;&gt;=
<indexterm><primary>&gt;&gt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&gt;&gt;=</secondary></indexterm>
</term>
<listitem><para>Strictly greater than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&lt;&lt;
<indexterm><primary>\&lt;&lt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&lt;&lt;</secondary></indexterm>
</term>
<listitem><para>Strictly NOT less than
</para></listitem></varlistentry>
<varlistentry><term>&lt;&lt;=
<indexterm><primary>&lt;&lt;= method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&lt;&lt;=</secondary></indexterm>
</term>
<listitem><para>Strictly less than or equal to
</para></listitem></varlistentry>
<varlistentry><term>\&gt;&gt;
<indexterm><primary>\&gt;&gt; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>\&gt;&gt;</secondary></indexterm>
</term>
<listitem><para>Strictly NOT greater than
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
<![CDATA[
"space"=="space"     ->     1         /* Strictly equal     */

"space"\==" space"   ->     1         /* Strictly not equal */

"space">>" space"    ->     1         /* Variations of      */
" space"<<"space"    ->     1         /* strictly greater   */
"space">>=" space"   ->     1         /* than and less than */
"space"\<<" space"   ->     1
" space"<<="space"   ->     1
" space"\>>"space"   ->     1
]]>
</programlisting>
</section>

<section id="logmeth"><title>Logical Methods</title>
<indexterm><primary>method</primary>
<secondary>logical methods</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-logical_operator(argument)----------------------------------><
]]>
</programlisting>


<note><title>Note</title>
<para>For NOT (prefix \),
<indexterm><primary>\ method</primary></indexterm>
omit the parentheses and <emphasis role="italic">argument</emphasis>.</para>
<para>Returns <computeroutput>1</computeroutput> (true) or
<computeroutput>0</computeroutput> (false), the result of performing
the specified logical operation. The receiver object and the
<emphasis role="italic">argument</emphasis> are character strings that
evaluate to <computeroutput>1</computeroutput> or
<computeroutput>0</computeroutput>.</para>
</note>
<para>The <emphasis role="italic">logical_operator</emphasis> can be: </para>

<variablelist>
<varlistentry><term>&amp;
<indexterm><primary>&amp; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&amp;</secondary></indexterm>
</term>
<listitem><para>AND (Returns <computeroutput>1</computeroutput>
if both terms are true.)
</para></listitem></varlistentry>
<varlistentry><term>|
<indexterm><primary>| method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>|</secondary></indexterm>
</term>
<listitem><para>Inclusive OR (Returns <computeroutput>1</computeroutput>
if either term or both terms are
true.)
</para></listitem></varlistentry>
<varlistentry><term>&amp;&amp;
<indexterm><primary>&amp;&amp; method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>&amp;&amp;</secondary></indexterm>
</term>
<listitem><para>Exclusive OR (Returns <computeroutput>1</computeroutput>
if either term, but not both terms,
is true.)
</para></listitem></varlistentry>
<varlistentry><term>Prefix \
<indexterm><primary>method</primary>
<secondary>\</secondary></indexterm>
</term>
<listitem><para>Logical NOT (Negates; <computeroutput>1</computeroutput>
becomes <computeroutput>0</computeroutput>, and
<computeroutput>0</computeroutput> becomes <computeroutput>1</computeroutput>.)
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>logical methods of String class</secondary></indexterm>
<programlisting>
<![CDATA[
1&0     ->     0
1|0     ->     1
1&&0    ->     1
\1      ->     0
]]>
</programlisting>
</section>

<section id="concmeth"><title>Concatenation Methods</title>
<indexterm><primary>method</primary>
<secondary>concatenation methods</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-concatenation_operator(argument)----------------------------><
]]>
</programlisting>

<para>Concatenates the receiver object with
<emphasis role="italic">argument</emphasis>. (See
<link linkend="strgcon">String Concatenation</link>.)
The <emphasis role="italic">concatenation_operator</emphasis> can be: </para>
<variablelist>
<varlistentry><term>&quot;&quot;</term>
<listitem><para>concatenates without an intervening blank. The abuttal operator
&quot;&quot;
is the null string. The language processor uses the abuttal to concatenate
two terms that another operator does not separate.
</para></listitem></varlistentry>
<varlistentry><term>||
<indexterm><primary>|| method</primary></indexterm>
<indexterm><primary>method</primary>
<secondary>||</secondary></indexterm>
</term>
<listitem><para>concatenates without an intervening blank.
</para></listitem></varlistentry>
<varlistentry><term>&quot;&nbsp;&quot;
</term>
<listitem><para>concatenates with one blank between the receiver
object and the <emphasis role="italic">argument</emphasis>.
(The operator &quot;&nbsp;&quot; is a blank.)
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>concatenation methods of String class</secondary></indexterm>
<indexterm><primary>prefix - method</primary></indexterm>
<indexterm><primary>prefix + method</primary></indexterm>
<programlisting>
<![CDATA[
5+5     ->    10
8-5     ->     3
5*2     ->    10
6/2     ->     3
9//4    ->     1
9%4     ->     2
2**3    ->     8
+5      ->     5             /* Prefix +  */
-5      ->    -5             /* Prefix -  */
]]>
</programlisting>
</section>

<section id="stabbr"><title>ABBREV</title>
<indexterm><primary>ABBREV method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ABBREV method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>default</primary>
<secondary>selecting with ABBREV method</secondary></indexterm>
<indexterm><primary>selecting a default with ABBREV method</primary></indexterm>
<indexterm><primary>testing</primary>
<secondary>abbreviations with ABBREV method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-ABBREV(info-+---------+-)-----------------------------------><
               +-,length-+
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> if
<emphasis role="italic">info</emphasis> is equal to the leading characters
of the receiving string and the length of
<emphasis role="italic">info</emphasis> is not less than
<emphasis role="italic">length</emphasis>. Returns
<computeroutput>0</computeroutput> if either of these conditions is not met.
</para>
<para>If you specify <emphasis role="italic">length</emphasis>, it must be a
positive whole number or zero. The default for
<emphasis role="italic">length</emphasis> is the number of characters in
<emphasis role="italic">info</emphasis>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>ABBREV method</secondary></indexterm>
<programlisting>
<![CDATA[
"Print"~ABBREV("Pri")      ->    1
"PRINT"~ABBREV("Pri")      ->    0
"PRINT"~ABBREV("PRI",4)    ->    0
"PRINT"~ABBREV("PRY")      ->    0
"PRINT"~ABBREV("")         ->    1
"PRINT"~ABBREV("",1)       ->    0
]]>
</programlisting>
<note><title>Note</title>
<para>A null string always matches if a length of
<computeroutput>0</computeroutput>, or the
default, is used. This allows a default keyword to be selected automatically
if desired.</para></note>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
say "Enter option:";   pull option .
select  /* keyword1 is to be the default */
  when "keyword1"~abbrev(option) then ...
  when "keyword2"~abbrev(option) then ...
  ...
  otherwise nop;
end;
</programlisting>
<para>(See <link linkend="abbrev">ABBREV (Abbreviation)</link>
for information about the ABBREV built-in function.)</para>
</section>

<section id="stabs"><title>ABS</title>
<indexterm><primary>ABS method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ABS method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>absolute value</primary>
<secondary>finding using the ABS method</secondary></indexterm>
<programlisting>
<![CDATA[
>>-ABS---------------------------------------------------------><
]]>
</programlisting>

<para>Returns the absolute value of the receiving string. The result has no
sign and is formatted according to the current NUMERIC settings.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>ABS method</secondary></indexterm>
<programlisting>
12.3~abs      ->     12.3
"-0.307"~abs  ->     0.307
</programlisting>
<para>(See <link linkend="abs">ABS (Absolute Value)</link>
for information about the ABS built-in function.)</para>
</section>

<section id="stb2x"><title>B2X</title>
<indexterm><primary>B2X method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>B2X method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>binary</primary>
<secondary>to hexadecimal conversion</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>binary to hexadecimal</secondary></indexterm>
<indexterm><primary>unpacking a string</primary>
<secondary>with B2X</secondary></indexterm>

<programlisting>
<![CDATA[
>>-B2X---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string, in character format, that represents the receiving
binary string converted to hexadecimal.</para>
<para>The receiving string is a string of binary
(<computeroutput>0</computeroutput> or <computeroutput>1</computeroutput>)
digits. It can be of any length. It can optionally include blanks (at 4-digit
boundaries only, not leading or trailing). These are to improve readability;
the language processor ignores them.</para>
<para>The returned string uses uppercase alphabetic characters for the values
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput> and does
not include blanks.</para>
<para>If the receiving binary string is a null string, B2X returns a null string.
If the number of binary digits in the receiving string is not a multiple of
four, the language processor adds up to three <computeroutput>0</computeroutput>
digits on the left
before the conversion to make a total that is a multiple of four.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>B2X method</secondary></indexterm>
<programlisting>
<![CDATA[
"11000011"~B2X     ->   "C3"
"10111"~B2X        ->   "17"
"101"~B2X          ->   "5"
"1 1111 0000"~B2X  ->   "1F0"
]]>
</programlisting>
<para>You can combine B2X with the methods X2D and X2C to convert a binary
number into other forms.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>"10111"~B2X~X2D  ->   "23"   /* decimal 23 */</programlisting>
<para>(See <link linkend="b2x">B2X (Binary to Hexadecimal)</link>
for information about the B2X built-in function.)</para>
</section>

<section id="stbita"><title>BITAND</title>
<indexterm><primary>BITAND method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>BITAND method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>ANDing character strings</primary></indexterm>
<indexterm><primary>character</primary>
<secondary>strings, ANDing</secondary></indexterm>
<programlisting>
<![CDATA[
>>-BITAND-+--------------------+-------------------------------><
          +-(string-+------+-)-+
                    +-,pad-+
]]>
</programlisting>

<para>Returns a string composed of the receiver string and the argument
<emphasis role="italic">string</emphasis> logically ANDed together,
bit by bit. (The encodings of the strings
are used in the logical operation.) The length of the result is the length
of the longer of the two strings. If you omit the
<emphasis role="italic">pad</emphasis> character,
the AND operation stops when the shorter of the two strings is exhausted,
and the unprocessed portion of the longer string is appended to the partial
result. If you provide <emphasis role="italic">pad</emphasis>,
it extends the shorter of the two strings
on the right before the logical operation. The default for
<emphasis role="italic">string</emphasis> is
the zero-length (null) string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>BITAND method</secondary></indexterm>
<programlisting>
<![CDATA[
"12"x~BITAND                   ->    "12"x
"73"x~BITAND("27"x)            ->    "23"x
"13"x~BITAND("5555"x)          ->    "1155"x
"13"x~BITAND("5555"x,"74"x)    ->    "1154"x
"pQrS"~BITAND(,"DF"x)          ->    "PQRS"      /* ASCII   */
]]>
</programlisting>
<para>(See <link linkend="bitand">BITAND (Bit by Bit AND)</link>
for information about the BITAND built-in function.)</para>
</section>

<section id="stbito"><title>BITOR</title>
<indexterm><primary>BITOR method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>BITOR method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>character</primary>
<secondary>strings, ORing</secondary></indexterm>
<indexterm><primary>ORing character together</primary></indexterm>

<programlisting>
<![CDATA[
>>-BITOR-+--------------------+--------------------------------><
         +-(string-+------+-)-+
                   +-,pad-+
]]>
</programlisting>

<para>Returns a string composed of the receiver string and the argument
<emphasis role="italic">string</emphasis> logically inclusive-ORed, bit by bit.
The encodings of the strings
are used in the logical operation. The length of the result is the length
of the longer of the two strings. If you omit the
<emphasis role="italic">pad</emphasis> character,
the OR operation stops when the shorter of the two strings is exhausted, and
the unprocessed portion of the longer string is appended to the partial result.
If you provide <emphasis role="italic">pad</emphasis>, it extends the shorter
of the two strings on the right before the logical operation. The default for
<emphasis role="italic">string</emphasis> is
the zero-length (null) string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>BITOR method</secondary></indexterm>
<programlisting>
<![CDATA[
"12"x~BITOR                   ->    "12"x
"15"x~BITOR("24"x)            ->    "35"x
"15"x~BITOR("2456"x)          ->    "3556"x
"15"x~BITOR("2456"x,"F0"x)    ->    "35F6"x
"1111"x~BITOR(,"4D"x)         ->    "5D5D"x
"pQrS"~BITOR(,"20"x)          ->    "pqrs" /* ASCII   */
]]>
</programlisting>
<para>(See <link linkend="bitor">BITOR (Bit by Bit OR)</link>
for information about the BITOR built-in function.)</para>
</section>

<section id="stbitx"><title>BITXOR</title>
<indexterm><primary>BITXOR method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>BITXOR method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>character</primary>
<secondary>strings, exclusive-ORing</secondary></indexterm>
<indexterm><primary>exclusive-ORing character strings together</primary>
</indexterm>
<indexterm><primary>XORing character strings together</primary></indexterm>

<programlisting>
<![CDATA[
>>-BITXOR-+--------------------+-------------------------------><
          +-(string-+------+-)-+
                    +-,pad-+
]]>
</programlisting>

<para>Returns a string composed of the receiver string and the argument
<emphasis role="italic">string</emphasis> logically eXclusive-ORed, bit by bit.
The encodings of the strings
are used in the logical operation. The length of the result is the length
of the longer of the two strings. If you omit the
<emphasis role="italic">pad</emphasis> character,
the XOR operation stops when the shorter of the two strings is exhausted,
and the unprocessed portion of the longer string is appended to the partial
result. If you provide <emphasis role="italic">pad</emphasis>,
it extends the shorter of the two strings
on the right before carrying out the logical operation. The default for
<emphasis role="italic">string</emphasis> is the zero-length (null) string.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>BITXOR method</secondary></indexterm>
<programlisting>
<![CDATA[
"12"x~BITXOR                      ->  "12"x
"12"x~BITXOR("22"x)               ->  "30"x
"1211"x~BITXOR("22"x)             ->  "3011"x
"1111"x~BITXOR("444444"x)         ->  "555544"x
"1111"x~BITXOR("444444"x,"40"x)   ->  "555504"x
"1111"x~BITXOR(,"4D"x)            ->  "5C5C"x
"C711"x~BITXOR("222222"x," ")     ->  "E53302"x  /* ASCII  */
]]>
</programlisting>
<para>(See <link linkend="ybitxor">BITXOR (Bit by Bit Exclusive OR)</link>
for information about the BITXOR built-in
function.)</para>
</section>

<section id="stc2d"><title>C2D</title>
<indexterm><primary>C2D method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>C2D method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>character</primary>
<secondary>to decimal conversion</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>character to decimal</secondary></indexterm>

<programlisting>
<![CDATA[
>>-C2D-+-----+-------------------------------------------------><
       +-(n)-+
]]>
</programlisting>

<para>Returns the decimal value of the binary representation of the receiving
string. If the result cannot be expressed as a whole number, an error results.
That is, the result must not have more digits than the current setting of
NUMERIC DIGITS. If you specify <emphasis role="italic">n</emphasis>, it is the
length of the returned result. If you do not specify
<emphasis role="italic">n</emphasis>, the receiving string is processed
as an unsigned binary number. If the receiving string is null, C2D returns
<computeroutput>0</computeroutput>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>C2D method</secondary></indexterm>
<programlisting>
<![CDATA[
"09"X~C2D       ->        9
"81"X~C2D       ->      129
"FF81"X~C2D     ->    65409
""~C2D          ->        0
"a"~C2D         ->       97     /*  ASCII   */
]]>
</programlisting>
<para>If you specify <emphasis role="italic">n</emphasis>, the receiving string
is taken as a signed number expressed in <emphasis role="italic">n</emphasis>
characters. The number is positive if the leftmost bit is off, and negative
if the leftmost bit is on. In both cases, it is converted
to a whole number, which can therefore be negative. The receiving string is
padded on the left with "00"x characters (not &quot;sign-extended&quot;),
or truncated on the left to <emphasis role="italic">n</emphasis> characters.
This padding or truncation is as though
<computeroutput>receiving_string~RIGHT(n,&apos;00&apos;x)</computeroutput> had
been processed. If <emphasis role="italic">n</emphasis> is
<computeroutput>0</computeroutput>, C2D always returns
<computeroutput>0</computeroutput>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
<![CDATA[
"81"X~C2D(1)      ->     -127
"81"X~C2D(2)      ->      129
"FF81"X~C2D(2)    ->     -127
"FF81"X~C2D(1)    ->     -127
"FF7F"X~C2D(1)    ->      127
"F081"X~C2D(2)    ->    -3967
"F081"X~C2D(1)    ->     -127
"0031"X~C2D(0)    ->        0
]]>
</programlisting>
<para>(See <link linkend="c2d">C2D (Character to Decimal)</link>
for information about the C2D built-in function.)</para>
</section>

<section id="stc2x"><title>C2X</title>
<indexterm><primary>C2X method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>C2X method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>character</primary>
<secondary>to hexadecimal conversion</secondary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>character to hexadecimal</secondary></indexterm>
<indexterm><primary>unpacking a string</primary>
<secondary>with C2X</secondary></indexterm>

<programlisting>
<![CDATA[
>>-C2X---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string, in character format, that represents the receiving
string converted to hexadecimal. The returned string contains twice as many
bytes as the receiving string. On an ASCII system, sending a C2X message to the
receiving string <computeroutput>1</computeroutput> returns
<computeroutput>31</computeroutput> because "31"X
is the ASCII representation of <computeroutput>1</computeroutput>.</para>
<para>The returned string has uppercase alphabetic characters for the values
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput> and does
not include blanks. The receiving string
can be of any length. If the receiving string is null, C2X returns a null
string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>C2X method</secondary></indexterm>
<programlisting>
<![CDATA[
"0123"X~C2X    ->    "0123"   /* "30313233"X     in ASCII */
"ZD8"~C2X      ->    "5A4438" /* "354134343338"X in ASCII */
]]>
</programlisting>
<para>(See <link linkend="c2x">C2X (Character to Hexadecimal)</link>
for information about the C2X built-in function.)</para>
</section>

<section id="stcent"><title>CENTER/CENTRE</title>
<indexterm><primary>CENTER method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CENTER method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>CENTRE method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CENTRE method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text centering</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>centering using CENTER function</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>centering using CENTRE function</secondary></indexterm>

<programlisting>
<![CDATA[
>>-+-CENTER(-+-length-+--------+-)-----------------------------><
   +-CENTRE(-+        +-,--pad-+
]]>
</programlisting>

<para>Returns a string of length <emphasis role="italic">length</emphasis>
with the receiving string centered in it. The language processor adds
<emphasis role="italic">pad</emphasis> characters as necessary to
make up length. The <emphasis role="italic">length</emphasis> must be a
positive whole number or zero. The default
<emphasis role="italic">pad</emphasis> character is blank. If the receiving
string is longer than <emphasis role="italic">length</emphasis>, it is
truncated at both ends to fit. If an odd number
of characters are truncated or added, the right-hand end loses or gains one
more character than the left-hand end. </para>

<note><title>Note</title>
<para>To avoid errors because
of the difference between British and American spellings, this method can
be called either CENTRE or CENTER.</para></note>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>CENTER method</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>CENTRE method</secondary></indexterm>
<programlisting>
<![CDATA[
abc~CENTER(7)               ->    "  ABC  "
abc~CENTER(8,"-")           ->    "--ABC---"
"The blue sky"~CENTRE(8)    ->    "e blue s"
"The blue sky"~CENTRE(7)    ->    "e blue "
]]>
</programlisting>
<para>(See <link linkend="centre">CENTER (or CENTRE)</link>
for information about the CENTER built-in function.)</para>
</section>

<section id="stchst"><title>CHANGESTR</title>
<indexterm><primary>CHANGESTR method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CHANGESTR method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CHANGESTR(needle,newneedle)---------------------------------><
]]>
</programlisting>

<para>Returns a copy of the receiver object in which
<emphasis role="italic">newneedle</emphasis> replaces
all occurrences of <emphasis role="italic">needle</emphasis>.</para>
<para>Here are some examples:</para>
<indexterm><primary>examples</primary>
<secondary>CHANGESTR method</secondary></indexterm>
<programlisting>
<![CDATA[
101100~CHANGESTR("1","")     ->    "000"
101100~CHANGESTR("1","X")    ->    "X0XX00"
]]>
</programlisting>
<para>(See <link linkend="xchgstr">CHANGESTR</link>
for information about the CHANGESTR built-in
function.)</para>
</section>

<section id="stcomp"><title>COMPARE</title>
<indexterm><primary>COMPARE method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>COMPARE method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>comparisons</primary>
<secondary>of strings</secondary></indexterm>
<indexterm><primary>finding</primary>
<secondary>mismatch using COMPARE</secondary></indexterm>

<programlisting>
<![CDATA[
>>-COMPARE(string-+------+-)-----------------------------------><
                  +-,pad-+
]]>
</programlisting>

<para>Returns <computeroutput>0</computeroutput> if the argument
<emphasis role="italic">string</emphasis> is identical to the
receiving string. Otherwise, returns the position of the first character that
does not match. The shorter string is padded on the right with
<emphasis role="italic">pad</emphasis> if
necessary. The default <emphasis role="italic">pad</emphasis> character is a
blank.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>COMPARE method</secondary></indexterm>
<programlisting>
<![CDATA[
"abc"~COMPARE("abc")         ->    0
"abc"~COMPARE("ak")          ->    2
"ab "~COMPARE("ab")          ->    0
"ab "~COMPARE("ab"," ")      ->    0
"ab "~COMPARE("ab","x")      ->    3
"ab-- "~COMPARE("ab","-")    ->    5
]]>
</programlisting>
<para>(See <link linkend="compare">COMPARE</link>  for information about the
COMPARE built-in function.)</para>
</section>

<section id="stcopi"><title>COPIES</title>
<indexterm><primary>COPIES method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>COPIES method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>copying a string using COPIES</primary></indexterm>
<indexterm><primary>repeating s string with COPIES</primary></indexterm>
<indexterm><primary>string</primary>
<secondary>copying using COPIES</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>repeating using COPIES</secondary></indexterm>

<programlisting>
<![CDATA[
>>-COPIES(n)---------------------------------------------------><
]]>
</programlisting>

<para>Returns <emphasis role="italic">n</emphasis> concatenated copies of the
receiving string. The <emphasis role="italic">n</emphasis> must be a positive
whole number or zero.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>COPIES method</secondary></indexterm>
<programlisting>
<![CDATA[
"abc"~COPIES(3)    ->    "abcabcabc"
"abc"~COPIES(0)    ->    ""
]]>
</programlisting>
<para>(See <link linkend="copies">COPIES</link>  for information about the
COPIES built-in function.)</para>
</section>

<section id="stcous"><title>COUNTSTR</title>
<indexterm><primary>COUNTSTR method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>COUNTSTR method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-COUNTSTR(needle)--------------------------------------------><
]]>
</programlisting>

<para>Returns a count of the occurrences of
<emphasis role="italic">needle</emphasis> in the receiving
string that do not overlap.</para>
<para>Here are some examples:</para>
<indexterm><primary>examples</primary>
<secondary>COUNTSTR method</secondary></indexterm>
<programlisting>
<![CDATA[
"101101"~COUNTSTR("1")        ->    4
"J0KKK0"~COUNTSTR("KK")       ->    1
]]>
</programlisting>
<para>(See <link linkend="chgtr">COUNTSTR</link>
for information about the COUNTSTR built-in
function.)</para>
</section>

<section id="std2c"><title>D2C</title>
<indexterm><primary>D2C method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>D2C method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>decimal to character</secondary></indexterm>
<indexterm><primary>decimal</primary>
<secondary>to character conversion</secondary></indexterm>

<programlisting>
<![CDATA[
>>-D2C-+-----+-------------------------------------------------><
       +-(n)-+
]]>
</programlisting>

<para>Returns a string, in character format, that is the ASCII representation
of the receiving string, a decimal number. If you specify
<emphasis role="italic">n</emphasis>, it is
the length of the final result in characters; leading blanks are added to
the returned string. The <emphasis role="italic">n</emphasis> must be a
positive whole number or zero.</para>
<para>The receiving string must not have more digits than the current setting
of NUMERIC DIGITS.</para>
<para>If you omit <emphasis role="italic">n</emphasis>, the receiving string
must be a positive whole number
or zero, and the result length is as needed. Therefore, the returned result
has no leading "00"x characters.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>D2C method</secondary></indexterm>
<programlisting>
"65"~D2C       ->   "A"      /* "41"x is an ASCII "A"    */
"65"~D2C(1)    ->   "A"
"65"~D2C(2)    ->   " A"
"65"~D2C(5)    ->   "    A"
"109"~D2C      ->   "m"      /* "6D"x  is an ASCII "m"   */
"-109"~D2C(1)  ->   "&ocirc;"      /* "93"x  is an ASCII "&ocirc;"   */
"76"~D2C(2)    ->   " L"     /* "4C"x  is an ASCII " L"  */
"-180"~D2C(2)  ->   " L"
</programlisting>
<indexterm><primary>implementation maximum</primary>
<secondary>D2C method</secondary></indexterm>
<para>Implementation maximum: The returned string must not have more than 250
significant
characters, although a longer result is possible if it has additional leading
sign characters ("00"x and "FF"x).</para>
<para>(See <link linkend="d2c">D2C (Decimal to Character)</link>
for information about the D2C built-in function.)</para>
</section>

<section id="std2x"><title>D2X</title>
<indexterm><primary>D2X method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>D2X method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>decimal to hexadecimal</secondary></indexterm>
<indexterm><primary>decimal</primary>
<secondary>to hexadecimal conversion</secondary></indexterm>

<programlisting>
<![CDATA[
>>-D2X-+-----+-------------------------------------------------><
       +-(n)-+
]]>
</programlisting>

<para>Returns a string, in character format, that represents the receiving
string, a decimal number converted to hexadecimal. The returned string uses
uppercase alphabetic characters for the values
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput> and does
not include blanks.</para>
<para>The receiving string must not have more digits than the current setting
of NUMERIC DIGITS.</para>
<para>If you specify <emphasis role="italic">n</emphasis>, it is the length of
the final result in characters.
After conversion the returned string is sign-extended to the required length.
If the number is too big to fit into <emphasis role="italic">n</emphasis>
characters, it is truncated
on the left. If you specify <emphasis role="italic">n</emphasis>, it must be a
positive whole number or zero.</para>
<para>If you omit <emphasis role="italic">n</emphasis>, the receiving string
must be a positive whole number
or zero, and the returned result has no leading zeros.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>D2X method</secondary></indexterm>
<programlisting>
"9"~D2X        ->    "9"
"129"~D2X      ->    "81"
"129"~D2X(1)   ->    "1"
"129"~D2X(2)   ->    "81"
"129"~D2X(4)   ->    "0081"
"257"~D2X(2)   ->    "01"
"-127"~D2X(2)  ->    "81"
"-127"~D2X(4)  ->    "FF81"
"12"~D2X(0)    ->    ""
</programlisting>
<indexterm><primary>implementation maximum</primary>
<secondary>D2X method</secondary></indexterm>
<para>Implementation maximum: The returned string must not have more than 500
significant hexadecimal characters, although a longer result is possible if it
has additional leading sign characters (0 and F).</para>
<para>(See <link linkend="d2x">D2X (Decimal to Hexadecimal)</link>
for information about the D2X built-in function.)</para>
</section>

<section id="stdata"><title>DATATYPE</title>
<indexterm><primary>DATATYPE method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DATATYPE method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>alphabetics</primary>
<secondary>checking with DATATYPE</secondary></indexterm>
<indexterm><primary>alphnumerics</primary>
<secondary>checking with DATATYPE</secondary></indexterm>
<indexterm><primary>bits checked using DATATYPE method</primary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>checking with DATATYPE</secondary></indexterm>
<indexterm><primary>type of data, checking with DATATYPE</primary></indexterm>
<indexterm><primary>whole numbers</primary>
<secondary>checking with DATATYPE</secondary></indexterm>
<indexterm><primary>numbers</primary>
<secondary>checking with DATATYPE</secondary></indexterm>

<programlisting>
<![CDATA[
>>-DATATYPE-+--------+-----------------------------------------><
            +-(type)-+
]]>
</programlisting>

<para>Returns <computeroutput>NUM</computeroutput> if you specify no argument
and the receiving string
is a valid Rexx number that can be added to 0 without error. It returns
<computeroutput>CHAR</computeroutput> if the receiving string is not a
valid number.</para>
<para>If you specify <emphasis role="italic">type</emphasis>, it returns
<computeroutput>1</computeroutput> if the receiving
string matches the type. Otherwise, it returns
<computeroutput>0</computeroutput>. If the receiving
string is null, the method returns <computeroutput>0</computeroutput>
(except when the <emphasis role="italic">type</emphasis> is
<computeroutput>X</computeroutput> or <computeroutput>B</computeroutput>,
for which DATATYPE returns <computeroutput>1</computeroutput> for
a null string). The following are valid
<emphasis role="italic">type</emphasis>s. You need to specify
only the capitalized letter, or the number of the last type listed. The language
processor ignores all characters surrounding it.</para>
<variablelist>
<varlistentry><term>Alphanumeric</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only characters from the ranges
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>,
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>, and
<computeroutput>0</computeroutput>-<computeroutput>9</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Binary</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only the characters <computeroutput>0</computeroutput> or
<computeroutput>1</computeroutput>, or a blank. Blanks can appear only between
groups of 4 binary characters. It also returns 1 if string is
a null string, which is a valid binary string.
</para></listitem></varlistentry>
<varlistentry><term>Lowercase</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only characters from the range
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Mixed case</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only characters from the ranges
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput> and
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Number</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<computeroutput>receiving_string~DATATYPE</computeroutput> returns
<computeroutput>NUM</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>lOgical</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
the receiving string is exactly "0" or "1". Otherwise it returns
<computeroutput>0</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Symbol</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string is a valid symbol, that is, if SYMBOL(string) does not return
<computeroutput>BAD</computeroutput>. (See
<link linkend="xsymbol">Symbols</link>.)
Note that both uppercase and lowercase alphabetic characters are permitted.
</para></listitem></varlistentry>
<varlistentry><term>Uppercase</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only characters from the range
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>Variable</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string could appear on the left-hand
side of an assignment without causing a SYNTAX condition.
</para></listitem></varlistentry>
<varlistentry><term>Whole number</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string is a whole number under the current setting of NUMERIC DIGITS.
</para></listitem></varlistentry>
<varlistentry><term>heXadecimal</term>
<listitem><para>returns <computeroutput>1</computeroutput> if the receiving
string contains only characters from the ranges
<computeroutput>a</computeroutput>-<computeroutput>f</computeroutput>,
<computeroutput>A</computeroutput>-<computeroutput>F</computeroutput>,
<computeroutput>0</computeroutput>-<computeroutput>9</computeroutput>,
and blank (as long as blanks appear
only between pairs of hexadecimal characters). Also returns
<computeroutput>1</computeroutput> if
the receiving string is a null string.
</para></listitem></varlistentry>
<varlistentry><term>9 Digits</term>
<listitem><para>returns <computeroutput>1</computeroutput> if
<computeroutput>receiving_string~DATATYPE("W")</computeroutput> returns
<computeroutput>1</computeroutput> when NUMERIC DIGITS is set to 9.
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>DATATYPE method</secondary></indexterm>
<programlisting>
<![CDATA[
" 12 "~DATATYPE          ->   "NUM"
""~DATATYPE              ->   "CHAR"
"123*"~DATATYPE          ->   "CHAR"
"12.3"~DATATYPE("N")     ->    1
"12.3"~DATATYPE("W")     ->    0
"Fred"~DATATYPE("M")     ->    1
""~DATATYPE("M")         ->    0
"Fred"~DATATYPE("L")     ->    0
"?20K"~DATATYPE("s")     ->    1
"BCd3"~DATATYPE("X")     ->    1
"BC d3"~DATATYPE("X")    ->    1
"1"~DATATYPE("O")        ->    1
"11"~DATATYPE("O")        ->   0
]]>
</programlisting><para> </para>

<note><title>Note</title>
<para>The DATATYPE method tests the meaning or type of characters in a
string, independent of the encoding of those characters (for example, ASCII
or EBCDIC).</para></note>
<para>(See <link linkend="datatyp">DATATYPE</link> for information about the
DATATYPE built-in function.)</para>
</section>

<section id="decodebase64"><title>DECODEBASE64</title>
<indexterm><primary>DECODEBASE64 method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DECODEBASE64 method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>base64</primary>
<secondary>DECODEBASE64 method</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>DECODEBASE64 method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-DECODEBASE64------------------------------------------------><
]]>
</programlisting>

<para>Returns the decoded version of the base64 encoded recieving string.
If the recieving string is not in base64 format then the
returned result is undefined.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>DECODEBASE64 method</secondary></indexterm>
<programlisting>
<![CDATA[
"YWJjZGVm"~DECODEBASE64       ->    "abcdef"
]]>
</programlisting>
<para>Please note that there is no corresponding DECODEBASE64 builtin function
for this method in ooRexx.</para>
</section>

<section id="stdels"><title>DELSTR</title>
<indexterm><primary>DELSTR method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DELSTR method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>deleting</primary>
<secondary>part of a string</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>deleting part, DELSTR method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-DELSTR(n--+---------+--)------------------------------------><
             +-,length-+
]]>
</programlisting>

<para>Returns a copy of the receiving string after deleting the substring that
begins at the <emphasis role="italic">n</emphasis>th character and is of
<emphasis role="italic">length</emphasis> characters.
If you omit <emphasis role="italic">length</emphasis>, or if
<emphasis role="italic">length</emphasis> is greater than the number
of characters from <emphasis role="italic">n</emphasis> to the end of
<emphasis role="italic">string</emphasis>, the method deletes
the rest of <emphasis role="italic">string</emphasis> (including the
<emphasis role="italic">n</emphasis>th character). The
<emphasis role="italic">length</emphasis> must be a positive whole number or
zero. The <emphasis role="italic">n</emphasis> must be
a positive whole number. If <emphasis role="italic">n</emphasis> is greater
than the length of the receiving
string, the method returns the receiving string unchanged.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>DELSTR method</secondary></indexterm>
<programlisting>
<![CDATA[
"abcd"~DELSTR(3)       ->    "ab"
"abcde"~DELSTR(3,2)    ->    "abe"
"abcde"~DELSTR(6)      ->    "abcde"
]]>
</programlisting>
<para>(See <link linkend="delstr">DELSTR (Delete String)</link>
for information about the DELSTR built-in function.)</para>
</section>

<section id="stdelw"><title>DELWORD</title>
<indexterm><primary>DELWORD method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DELWORD method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>deleting</primary>
<secondary>words from a string</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>deleting from a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-DELWORD(n--+---------+--)-----------------------------------><
              +-,length-+
]]>
</programlisting>

<para>Returns a copy of the receiving string after deleting the substring that
starts at the <emphasis role="italic">n</emphasis>th word and is of
<emphasis role="italic">length</emphasis> blank-delimited
words. If you omit <emphasis role="italic">length</emphasis>, or if
<emphasis role="italic">length</emphasis> is greater than
the number of words from <emphasis role="italic">n</emphasis> to the end of the
receiving string, the
method deletes the remaining words in the receiving string (including the
<emphasis role="italic">n</emphasis>th word). The
<emphasis role="italic">length</emphasis> must be a positive whole number or
zero. The <emphasis role="italic">n</emphasis> must be a positive whole number.
If <emphasis role="italic">n</emphasis> is greater than
the number of words in the receiving string, the method returns the receiving
string unchanged. The string deleted includes any blanks following the final
word involved but none of the blanks preceding the first word involved.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>DELWORD method</secondary></indexterm>
<indexterm><primary>examples</primary>
<secondary>INSERT method</secondary></indexterm>
<programlisting>
<![CDATA[
"Now is the  time"~DELWORD(2,2)  ->  "Now time"
"Now is the time "~DELWORD(3)    ->  "Now is "
"Now is the  time"~DELWORD(5)    ->  "Now is the  time"
"Now is   the time"~DELWORD(3,1) ->  "Now is   time"
]]>
</programlisting>
<para>(See <link linkend="delword">DELWORD (Delete Word)</link>
for information about the DELWORD built-in function.)</para>
</section>

<section id="encodebase64"><title>ENCODEBASE64</title>
<indexterm><primary>ENCODEBASE64 method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ENCODEBASE64 method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>base64</primary>
<secondary>ENCODEBASE64 method</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>ENCODEBASE64 method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-ENCODEBASE64------------------------------------------------><
]]>
</programlisting>

<para>Returns the base64 encoded version of the recieving string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>ENCODEBASE64 method</secondary></indexterm>
<programlisting>
<![CDATA[
"abcdef"~ENCODEBASE64       ->    "YWJjZGVm"
]]>
</programlisting>
<para>Please note that there is no corresponding ENCODEBASE64 builtin function
for this method in ooRexx.</para>
</section>

<section id="stform"><title>FORMAT</title>
<indexterm><primary>FORMAT method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>FORMAT method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>formating numbers</secondary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>numbers for display</secondary></indexterm>
<indexterm><primary>numbers</primary>
<secondary>formatting for display</secondary></indexterm>
<indexterm><primary>numbers for display</primary></indexterm>

<programlisting>
<![CDATA[
>>-FORMAT-+---------------------------------------------------------+-><
          +-(-before-+------------------------------------------+-)-+
                     +-,--+-------+--+------------------------+-+
                          +-after-+  +-,--+------+--+-------+-+
                                          +-expp-+  +-,expt-+
]]>
</programlisting>

<para>Returns the receiving string, a number, rounded and formatted.</para>
<para>The number is first rounded according to standard Rexx rules, as though
the operation <computeroutput>receiving_string+0</computeroutput> had been
carried out. If you
specify no arguments the result of the method is the same as the result of
this operation. If you specify any options, the number is formatted as
described in the following.</para>
<para>The <emphasis role="italic">before</emphasis> and
<emphasis role="italic">after</emphasis> options describe how many characters
are to be used for the integer and decimal parts of the result. If you omit
either or both of them, the number of characters for that part is as needed.
</para>
<para>If <emphasis role="italic">before</emphasis> is not large enough to
contain the integer part of the
number (plus the sign for a negative number), an error results. If
<emphasis role="italic">before</emphasis> is larger than needed for that part,
the number is padded on the left with blanks. If
<emphasis role="italic">after</emphasis> is not the same size as the decimal
part of the number, the number is rounded (or extended with zeros) to fit.
Specifying <computeroutput>0</computeroutput> causes the number to be rounded
to an integer.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>FORMAT method</secondary></indexterm>
<programlisting>
"3"~FORMAT(4)            ->    "   3"
"1.73"~FORMAT(4,0)       ->    "   2"
"1.73"~FORMAT(4,3)       ->    "   1.730"
"-.76"~FORMAT(4,1)       ->    "  -0.8"
"3.03"~FORMAT(4)         ->    "   3.03"
" - 12.73"~FORMAT(,4)    ->    "-12.7300"
" - 12.73"~FORMAT        ->    "-12.73"
"0.000"~FORMAT           ->    "0"
</programlisting>
<para><emphasis role="italic">expp</emphasis> and
<emphasis role="italic">expt</emphasis> control the exponent part of the result,
which, by default, is formatted according to the current NUMERIC settings
of DIGITS and FORM. <emphasis role="italic">expp</emphasis> sets the number of
places for the exponent part; the default is to use as many as needed
(which can be zero). <emphasis role="italic">expt</emphasis>
specifies when the exponential expression is used. The default is the
current setting of NUMERIC DIGITS.</para>
<para>If <emphasis role="italic">expp</emphasis> is
<computeroutput>0</computeroutput>, the number is not an exponential expression.
If <emphasis role="italic">expp</emphasis> is not large enough to contain the
exponent, an error results.</para>
<para>If the number of places needed for the integer or decimal part exceeds
<emphasis role="italic">expt</emphasis> or twice
<emphasis role="italic">expt</emphasis>, respectively, exponential notation is
used. If <emphasis role="italic">expt</emphasis> is
<computeroutput>0</computeroutput>, exponential notation is always used unless
the exponent would be <computeroutput>0</computeroutput>. (If
<emphasis role="italic">expp</emphasis> is
<computeroutput>0</computeroutput>, this
overrides a <computeroutput>0</computeroutput> value of
<emphasis role="italic">expt</emphasis>.) If the exponent would be
<computeroutput>0</computeroutput> when a nonzero
<emphasis role="italic">expp</emphasis> is specified, then
<emphasis role="italic">expp</emphasis>+2 blanks
are supplied for the exponent part of the result. If the exponent would be
<computeroutput>0</computeroutput> and <emphasis role="italic">expp</emphasis>
is not specified, the number is not an exponential
expression.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
"12345.73"~FORMAT(, ,2,2)   ->    "1.234573E+04"
"12345.73"~FORMAT(,3, ,0)   ->    "1.235E+4"
"1.234573"~FORMAT(,3, ,0)   ->    "1.235"
"12345.73"~FORMAT(, ,3,6)   ->    "12345.73"
"1234567e5"~FORMAT(,3,0)    ->    "123456700000.000"
</programlisting>
<para>(See <link linkend="xformat">FORMAT</link>  for information about the
FORMAT built-in function.)</para>
</section>

<section id="stinse"><title>INSERT</title>
<indexterm><primary>INSERT method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>INSERT method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>inserting a string into another</primary></indexterm>

<programlisting>
<![CDATA[
>>-INSERT(new-+---------------------------------------+-)------><
              +-,--+---+--+-------------------------+-+
                   +-n-+  +-,--+--------+--+------+-+
                               +-length-+  +-,pad-+
]]>
</programlisting>

<para>Inserts the string <emphasis role="italic">new</emphasis>, padded or
truncated to length <emphasis role="italic">length</emphasis>, into the
receiving string. after the <emphasis role="italic">n</emphasis>th character.
The default value for <emphasis role="italic">n</emphasis> is
<computeroutput>0</computeroutput>, which means insertion at the beginning
of the string. If specified, <emphasis role="italic">n</emphasis> and
<emphasis role="italic">length</emphasis> must be positive
whole numbers or zero. If <emphasis role="italic">n</emphasis> is greater than
the length of the receiving string, the string
<emphasis role="italic">new</emphasis> is padded at the beginning. The default
value for <emphasis role="italic">length</emphasis> is the length of
<emphasis role="italic">new</emphasis>. If
<emphasis role="italic">length</emphasis> is less
than the length of the string <emphasis role="italic">new</emphasis>,
then INSERT truncates <emphasis role="italic">new</emphasis> to length
<emphasis role="italic">length</emphasis>. The default
<emphasis role="italic">pad</emphasis> character is a blank.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>INSERT method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
"abc"~INSERT("123")            ->    "123abc"
"abcdef"~INSERT(" ",3)         ->    "abc def"
"abc"~INSERT("123",5,6)        ->    "abc  123   "
"abc"~INSERT("123",5,6,"+")    ->    "abc++123+++"
"abc"~INSERT("123", ,5,"-")    ->    "123--abc"
</programlisting>
<para>(See <link linkend="insert">INSERT</link>
for information about the INSERT built-in function.)</para>
</section>

<section id="stlast"><title>LASTPOS</title>
<indexterm><primary>LASTPOS method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LASTPOS method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>position</primary>
<secondary>last occurrence of a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-LASTPOS(needle-+--------+-)---------------------------------><
                  +-,start-+
]]>
</programlisting>

<para>Returns the position of the last occurrence of a string,
<emphasis role="italic">needle</emphasis>,
in the receiving string. (See also <link linkend="stpos">POS</link>.) It
returns <computeroutput>0</computeroutput> if
<emphasis role="italic">needle</emphasis> is the null string or not found.
By default, the search starts at the last character of the receiving string
and scans backward. You can override this by specifying
<emphasis role="italic">start</emphasis>, the point at which the
backward scan starts. The <emphasis role="italic">start</emphasis> must be a
positive whole number and defaults to
<computeroutput>receiving_string~length</computeroutput> if larger than that
value or omitted.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>LASTPOS method</secondary></indexterm>
<programlisting>
"abc def ghi"~LASTPOS(" ")      ->    8
"abcdefghi"~LASTPOS(" ")        ->    0
"efgxyz"~LASTPOS("xy")          ->    4
"abc def ghi"~LASTPOS(" ",7)    ->    4
</programlisting>
<para>(See <link linkend="lastpos">LASTPOS (Last Position)</link>
for information about the LASTPOS built-in function.)</para>
</section>

<section id="stleft"><title>LEFT</title>
<indexterm><primary>LEFT method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LEFT method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text left justification</secondary></indexterm>

<programlisting>
<![CDATA[
>>-LEFT(length-+------+-)--------------------------------------><
               +-,pad-+
]]>
</programlisting>

<para>Returns a string of length <emphasis role="italic">length</emphasis>,
containing the leftmost <emphasis role="italic">length</emphasis> characters
of the receiving string. The string returned is padded
with <emphasis role="italic">pad</emphasis> characters (or truncated) on the
right as needed. The default <emphasis role="italic">pad</emphasis> character
is a blank. The <emphasis role="italic">length</emphasis> must be a positive
whole number or zero. The LEFT method is exactly equivalent to:</para>
<programlisting>
<![CDATA[
>>-SUBSTR(string,1,length-+------+-)---------------------------><
                          +-,pad-+
]]>
</programlisting>

<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>LEFT method</secondary></indexterm>
<programlisting>
"abc d"~LEFT(8)        ->    "abc d   "
"abc d"~LEFT(8,".")    ->    "abc d..."
"abc  def"~LEFT(7)     ->    "abc  de"
</programlisting>
<para>(See <link linkend="left">LEFT</link>
for information about the LEFT built-in function.)</para>
</section>

<section id="stleng"><title>LENGTH</title>
<indexterm><primary>LENGTH method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LENGTH method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>finding</primary>
<secondary>string length</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>finding length of</secondary></indexterm>

<programlisting>
<![CDATA[
>>-LENGTH------------------------------------------------------><
]]>
</programlisting>

<para>Returns the length of the receiving string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>LENGTH method</secondary></indexterm>
<programlisting>
"abcdefgh"~LENGTH     ->    8
"abc defg"~LENGTH     ->    8
""~LENGTH             ->    0
</programlisting>
<para>(See <link linkend="length">LENGTH</link>
for information about the LENGTH built-in function.)</para>
</section>

<section id="stmaka"><title>MAKEARRAY</title>
<indexterm><primary>MAKEARRAY method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MAKEARRAY method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MAKEARRAY(-+-----------+-)----><
              +-Separator-+
]]>
</programlisting>

<para>This method returns an array of strings containing the single
lines that were separated using the separator character. The
default separator is the newline character.</para>

<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[
nl = "0d0a"x
string = "hello"nl"world"nl"this is an array."
array = string~makearray
say "the second line is:" array[2]

string = "hello*world*this is an array."
array = string~makearray("*")
say "the third line is:" array[3]
]]>
</programlisting>
</section>



<section id="stmaks"><title>MAKESTRING</title>
<indexterm><primary>MAKESTRING method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MAKESTRING method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MAKESTRING--------------------------------------------------><
]]>
</programlisting>

<para>Returns a string with the same string value as the receiver object. If
the receiver is an instance of a subclass of the String class, this method
returns an equivalent string object. If the receiver is a string object (not
an instance of a subclass of the String class), this method returns the receiver
object. See <link linkend="reqstr">Required String Values</link>.</para>
</section>

<section id="stmax"><title>MAX</title>
<indexterm><primary>MAX method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MAX method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MAX-+------------------+------------------------------------><
       |    +-,------.    |
       |    V        |    |
       +-(----number-+--)-+
]]>
</programlisting>

<para>Returns the largest number from among the receiver and any arguments. The
number that MAX returns is formatted according to the current NUMERIC settings.
You can specify any number of <emphasis role="italic">number</emphasis>s.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>MAX method</secondary></indexterm>
<programlisting>
12~MAX(6,7,9)                                                ->    12
17.3~MAX(19,17.03)                                           ->    19
"-7"~MAX("-3","-4.3")                                        ->    -3
1~MAX(2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)   ->    21
</programlisting>
<para>(See <link linkend="max">MAX (Maximum)</link>
for information about the MAX built-in function.)</para>
</section>

<section id="stmin"><title>MIN</title>
<indexterm><primary>MIN method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MIN method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MIN-+------------------+------------------------------------><
       |    +-,------.    |
       |    V        |    |
       +-(----number-+--)-+
]]>
</programlisting>

<para>Returns the smallest number from among the receiver and any arguments.
The number that MIN returns is formatted according to the current NUMERIC
settings. You can specify any number of
<emphasis role="italic">number</emphasis>s.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>MIN method</secondary></indexterm>
<programlisting>
12~MIN(6,7,9)                                                ->     6
17.3~MIN(19,17.03)                                           ->    17.03
"-7"~MIN("-3","-4.3")                                        ->    -7
21~MIN(20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1)   ->     1
</programlisting>
<para>(See <link linkend="min">MIN (Minimum)</link>
for information about the MIN built-in function.)</para>
</section>

<section id="stover"><title>OVERLAY</title>
<indexterm><primary>OVERLAY method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>OVERLAY method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>overlaying a string onto another</primary></indexterm>

<programlisting>
<![CDATA[
>>-OVERLAY(new-+---------------------------------------+-)-----><
               +-,--+---+--+-------------------------+-+
                    +-n-+  +-,--+--------+--+------+-+
                                +-length-+  +-,pad-+
]]>
</programlisting>

<para>Returns the receiving string, which, starting at the
<emphasis role="italic">n</emphasis>th character,
is overlaid with the string <emphasis role="italic">new</emphasis>,
padded or truncated to length <emphasis role="italic">length</emphasis>.
The overlay can extend beyond the end of the receiving string.
If you specify <emphasis role="italic">length</emphasis>, it must be a positive
whole number or zero. The default value for
<emphasis role="italic">length</emphasis> is the length of
<emphasis role="italic">new</emphasis>. If <emphasis role="italic">n</emphasis>
is greater than the length of the receiving string, padding is added
before the <emphasis role="italic">new</emphasis> string. The default
<emphasis role="italic">pad</emphasis> character is a blank,
and the default value for <emphasis role="italic">n</emphasis> is
<computeroutput>1</computeroutput>. If you specify
<emphasis role="italic">n</emphasis>, it must be a positive whole number.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>OVERLAY method</secondary></indexterm>
<programlisting>
"abcdef"~OVERLAY(" ",3)         ->    "ab def"
"abcdef"~OVERLAY(".",3,2)       ->    "ab. ef"
"abcd"~OVERLAY("qq")            ->    "qqcd"
"abcd"~OVERLAY("qq",4)          ->    "abcqq"
"abc"~OVERLAY("123",5,6,"+")    ->    "abc+123+++"
</programlisting>
<para>(See <link linkend="overlay">OVERLAY</link>
for information about the OVERLAY built-in function.)</para>
</section>

<section id="stpos"><title>POS</title>
<indexterm><primary>POS method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>POS method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>finding</primary>
<secondary>string in another string</secondary></indexterm>
<indexterm><primary>locating</primary>
<secondary>string in another string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-POS(needle-+--------+-)-------------------------------------><
              +-,start-+
]]>
</programlisting>

<para>Returns the position in the receiving string of another string,
<emphasis role="italic">needle</emphasis>. (See also
<link linkend="stlast">LASTPOS</link>.) It returns
<computeroutput>0</computeroutput> if
<emphasis role="italic">needle</emphasis> is the null string or is not found
or if <emphasis role="italic">start</emphasis> is greater than
the length of the receiving string. By default, the search starts at the first
character of the receiving string (that is, the value of
<emphasis role="italic">start</emphasis> is <computeroutput>1</computeroutput>).
You can override this by specifying <emphasis role="italic">start</emphasis>
(which must be
a positive whole number), the point at which the search starts.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>POS method</secondary></indexterm>
<programlisting>
"Saturday"~POS("day")       ->    6
"abc def ghi"~POS("x")      ->    0
"abc def ghi"~POS(" ")      ->    4
"abc def ghi"~POS(" ",5)    ->    8
</programlisting>
<para>(See <link linkend="pos">POS (Position)</link>
for information about the POS built-in function.)</para>
</section>

<section id="streve"><title>REVERSE</title>
<indexterm><primary>REVERSE method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>REVERSE method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-REVERSE-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the receiving string reversed.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>REVERSE method</secondary></indexterm>
<programlisting>
"ABc."~REVERSE    ->    ".cBA"
"XYZ "~REVERSE    ->    " ZYX"
</programlisting>
<para>(See <link linkend="reverse">REVERSE</link>
for information about the REVERSE built-in function.)</para>
</section>

<section id="strigh"><title>RIGHT</title>
<indexterm><primary>RIGHT method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>RIGHT method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text right justification</secondary></indexterm>
<indexterm><primary>justification, text right, RIGHT method</primary>
</indexterm>
<indexterm><primary>leading</primary>
<secondary>zeros</secondary>
<tertiary>adding with RIGHT method</tertiary></indexterm>
<indexterm><primary>zeros</primary>
<secondary>added on left with RIGHT method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-RIGHT(length-+------+-)-------------------------------------><
                +-,pad-+
]]>
</programlisting>

<para>Returns a string of length <emphasis role="italic">length</emphasis>
containing the rightmost <emphasis role="italic">length</emphasis> characters
of the receiving string. The string returned is padded
with <emphasis role="italic">pad</emphasis> characters, or truncated, on the
left as needed. The default <emphasis role="italic">pad</emphasis> character
is a blank. The <emphasis role="italic">length</emphasis> must be a positive
whole number or zero.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>RIGHT method</secondary></indexterm>
<programlisting>
"abc  d"~RIGHT(8)     ->    "  abc  d"
"abc def"~RIGHT(5)    ->    "c def"
"12"~RIGHT(5,"0")     ->    "00012"
</programlisting>
<para>(See <link linkend="right">RIGHT</link>
for information about the RIGHT built-in function.)</para>
</section>

<section id="stsign"><title>SIGN</title>
<indexterm><primary>SIGN method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SIGN method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SIGN--------------------------------------------------------><
]]>
</programlisting>

<para>Returns a number that indicates the sign of the receiving string, which
is a number. The receiving string is first rounded according to standard Rexx
rules, as though the operation
<computeroutput>receiving_string+0</computeroutput> had been carried
out. It returns <computeroutput>-1</computeroutput> if the receiving string is
less than <computeroutput>0</computeroutput>,
<computeroutput>0</computeroutput> if it is
<computeroutput>0</computeroutput>, and <computeroutput>1</computeroutput>
if it is greater than <computeroutput>0</computeroutput>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>SIGN method</secondary></indexterm>
<programlisting>
"12.3"~SIGN       ->     1
" -0.307"~SIGN    ->    -1
0.0~SIGN          ->     0
</programlisting>
<para>(See <link linkend="sign">SIGN</link>
for information about the SIGN built-in function.)</para>
</section>

<section id="stspac"><title>SPACE</title>
<indexterm><primary>SPACE method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SPACE method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>text spacing</secondary></indexterm>
<indexterm><primary>spacing, formatting, SPACE method</primary></indexterm>

<programlisting>
<![CDATA[
>>-SPACE-+---------------+-------------------------------------><
         +-(n-+------+-)-+
              +-,pad-+
]]>
</programlisting>

<para>Returns the blank-delimited words in the receiving string, with
<emphasis role="italic">n</emphasis>&nbsp;<emphasis role="italic">pad</emphasis>
characters between each word. If you specify
<emphasis role="italic">n</emphasis>, it must
be a positive whole number or zero. If it is
<computeroutput>0</computeroutput>, all blanks are
removed. Leading and trailing blanks are always removed. The default for
<emphasis role="italic">n</emphasis> is <computeroutput>1</computeroutput>,
and the default <emphasis role="italic">pad</emphasis> character is a blank.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>SPACE method</secondary></indexterm>
<programlisting>
"abc  def  "~SPACE           ->    "abc def"
"  abc def"~SPACE(3)         ->    "abc   def"
"abc  def  "~SPACE(1)        ->    "abc def"
"abc  def  "~SPACE(0)        ->    "abcdef"
"abc  def  "~SPACE(2,"+")    ->    "abc++def"
</programlisting>
<para>(See <link linkend="space">SPACE</link>
for information about the SPACE built-in function.)</para>
</section>

<section><title>SUBCHAR</title>
<indexterm><primary>STRING method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SUBCHAR method</secondary>
<tertiary>of String</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-SUBCHAR(n)----------------------------------------------><
]]>
</programlisting>

<para>Returns the <emphasis>n</emphasis>'th character of the receiving
string. <emphasis>n</emphasis> must be a positive whole number. If
<emphasis>n</emphasis> is greater that the length of the receiving string
then a zero-length string is returned.</para>
</section>

<section id="ststrn"><title>STRING</title>
<indexterm><primary>STRING method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>STRING method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-STRING------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string with the same string value as the receiver object. If
the receiver is an instance of a subclass of the String class, this method
returns a string having an equivalent value. If the receiver is a string (but
is not an instance of a subclass of the String class), this method returns
the receiver object. See also the STRING method of the Object class in
<link linkend="obstri">STRING</link> .</para>
</section>

<section id="stripm"><title>STRIP</title>
<indexterm><primary>STRIP method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>STRIP method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>blanks</primary>
<secondary>removal with STRIP method</secondary></indexterm>
<indexterm><primary>character</primary>
<secondary>removal with STRIP method</secondary></indexterm>
<indexterm><primary>leading</primary>
<secondary>zeros</secondary>
<tertiary>removing with STRIP method</tertiary></indexterm>
<indexterm><primary>leading</primary>
<secondary>blank removal with STRIP method</secondary></indexterm>
<indexterm><primary>trailing</primary>
<secondary>blank removed using STRIP method</secondary></indexterm>
<indexterm><primary>zeros</primary>
<secondary>removal with STRIP method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-STRIP-+---------------------+-------------------------------><
         +-(option-+-------+-)-+
                   +-,char-+
]]>
</programlisting>

<para>Returns the receiving string with leading characters, trailing characters,
or both, removed, based on the <emphasis role="italic">option</emphasis> you
specify. The following are valid <emphasis role="italic">option</emphasis>s.
(You need to specify only the first capitalized
letter; the language processor ignores all characters following it.) </para>
<variablelist>
<varlistentry><term>Both</term>
<listitem><para>Removes both leading and trailing characters. This is the
default.
</para></listitem></varlistentry>
<varlistentry><term>Leading</term>
<listitem><para>Removes leading characters.
</para></listitem></varlistentry>
<varlistentry><term>Trailing</term>
<listitem><para>Removes trailing characters.
</para></listitem></varlistentry>
</variablelist>
<para>The <emphasis role="italic">char</emphasis> specifies the character to be
removed, and the default is a blank. If you specify
<emphasis role="italic">char</emphasis>, it must be exactly one character
long.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>STRIP method</secondary></indexterm>
<programlisting>
"  ab c  "~STRIP         ->    "ab c"
"  ab c  "~STRIP("L")    ->    "ab c  "
"  ab c  "~STRIP("t")    ->    "  ab c"
"12.7000"~STRIP(,0)      ->    "12.7"
"0012.700"~STRIP(,0)     ->    "12.7"
</programlisting>
<para>(See <link linkend="strip">STRIP</link>
for information about the STRIP built-in function.)</para>
</section>

<section id="stsubs"><title>SUBSTR</title>
<indexterm><primary>SUBSTR method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SUBSTR method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>extracting</primary>
<secondary>substring</secondary></indexterm>
<indexterm><primary>string</primary>
<secondary>extracting using SUBSTR method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-SUBSTR(n-+-------------------------+-)----------------------><
            +-,--+--------+--+------+-+
                 +-length-+  +-,pad-+
]]>
</programlisting>

<para>Returns the substring of the receiving string that begins at the
<emphasis role="italic">n</emphasis>th character and is of length
<emphasis role="italic">length</emphasis>, padded with
<emphasis role="italic">pad</emphasis> if
necessary. The <emphasis role="italic">n</emphasis> must be a positive whole
number. If <emphasis role="italic">n</emphasis> is
greater than <computeroutput>receiving_string~LENGTH</computeroutput>,
only pad characters are returned.</para>
<para>If you omit <emphasis role="italic">length</emphasis>, the rest of the
string is returned. The default <emphasis role="italic">pad</emphasis>
character is a blank.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>SUBSTR method</secondary></indexterm>
<programlisting>
"abc"~SUBSTR(2)          ->    "bc"
"abc"~SUBSTR(2,4)        ->    "bc  "
"abc"~SUBSTR(2,6,".")    ->    "bc...."
</programlisting>

<note><title>Note</title>
<para>In some situations the positional (numeric) patterns
of parsing templates are more convenient for selecting substrings, in particular
if you need to extract more than one substring from a string. See also
<link linkend="stleft">LEFT</link> and <link linkend="strigh">RIGHT</link>.
</para></note>
<para>(See <link linkend="substr">SUBSTR (Substring)</link>
for information about the SUBSTR built-in function.)</para>
</section>

<section id="stsubw"><title>SUBWORD</title>
<indexterm><primary>SUBWORD method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SUBWORD method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>extracting words with SUBWORD</primary></indexterm>
<indexterm><primary>word</primary>
<secondary>extracting from a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-SUBWORD(n-+---------+-)-------------------------------------><
             +-,length-+
]]>
</programlisting>

<para>Returns the substring of the receiving string that starts at the
<emphasis role="italic">n</emphasis>th word and is up to
<emphasis role="italic">length</emphasis> blank-delimited words. The
<emphasis role="italic">n</emphasis> must be a positive whole number.
If you omit <emphasis role="italic">length</emphasis>, it defaults
to the number of remaining words in the receiving string. The returned string
never has leading or trailing blanks, but includes all blanks between the
selected words.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>SUBWORD method</secondary></indexterm>
<programlisting>
"Now is the  time"~SUBWORD(2,2)    ->    "is the"
"Now is the  time"~SUBWORD(3)      ->    "the  time"
"Now is the  time"~SUBWORD(5)      ->    ""
</programlisting>
<para>(See <link linkend="subword">SUBWORD</link>
for information about the SUBWORD built-in
function.)</para>
</section>

<section id="sttran"><title>TRANSLATE</title>
<indexterm><primary>TRANSLATE method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>TRANSLATE method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>reordering data</primary></indexterm>
<indexterm><primary>translation</primary>
<secondary>with TRANSLATE method</secondary></indexterm>
<indexterm><primary>uppercase translation</primary>
<secondary>with TRANSLATE method</secondary></indexterm>

<programlisting>
<![CDATA[
>>-TRANSLATE-+-----------------------------------------------+-><
             +-(--+-------------------------------------+--)-+
                  +-tableo--+-------------------------+-+
                            +-,--+--------+--+------+-+
                                 +-tablei-+  +-,pad-+
]]>
</programlisting>

<para>Returns the receiving string with each character translated to another
character or unchanged. You can also use this method to reorder the characters
in the receiving string.</para>
<para>The output table is <emphasis role="italic">tableo</emphasis>
and the input translation table is <emphasis role="italic">tablei</emphasis>.
TRANSLATE searches <emphasis role="italic">tablei</emphasis> for each character
in the receiving string. If the character is found, the corresponding character
in <emphasis role="italic">tableo</emphasis> is used in the result string. If
there are duplicates in <emphasis role="italic">tablei</emphasis>, the first
(leftmost) occurrence is used. If the character is
not found, the original character in the receiving string is used. The result
string is always of the same length as the receiving string.</para>
<para>The tables can be of any length. If you specify translation table and
omit <emphasis role="italic">pad</emphasis>, the receiving string is
translated to uppercase (that is, lowercase
<computeroutput>a</computeroutput>-<computeroutput>z</computeroutput>
to uppercase
<computeroutput>A</computeroutput>-<computeroutput>Z</computeroutput>),
but if you include <emphasis role="italic">pad</emphasis>
the language processor translates the entire
string to <emphasis role="italic">pad</emphasis> characters.
<emphasis role="italic">tablei</emphasis> defaults to
<computeroutput>XRANGE("00"x,"FF"x)</computeroutput>, and
<emphasis role="italic">tableo</emphasis> defaults to the null string and
is padded with <emphasis role="italic">pad</emphasis> or truncated as necessary.
The default <emphasis role="italic">pad</emphasis> is a blank.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>TRANSLATE method</secondary></indexterm>
<programlisting>
"abcdef"~TRANSLATE                     ->    "ABCDEF"
"abcdef"~TRANSLATE("12","ec")          ->    "ab2d1f"
"abcdef"~TRANSLATE("12","abcd",".")    ->    "12..ef"
"APQRV"~TRANSLATE(,"PR")               ->    "A Q V"
"APQRV"~TRANSLATE(XRANGE("00"X,"Q"))   ->    "APQ  "
"4123"~TRANSLATE("abcd","1234")        ->    "dabc"
</programlisting>

<note><title>Note</title>
<para>The last example shows how to use the TRANSLATE method
to reorder the characters in a string. In the example, the last character
of any 4-character string specified as the first argument would be moved to
the beginning of the string.</para></note>
<para>(See <link linkend="transl">TRANSLATE</link>
for information about the TRANSLATE built-in
function.)</para>
</section>

<section id="sttrun"><title>TRUNC</title>
<indexterm><primary>TRUNC method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>TRUNC method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>formatting</primary>
<secondary>numbers with TRUNC</secondary></indexterm>
<indexterm><primary>trincating numbers</primary></indexterm>
<indexterm><primary>numbers</primary>
<secondary>truncating</secondary></indexterm>


<programlisting>
<![CDATA[
>>-TRUNC-+-----+-----------------------------------------------><
         +-(n)-+
]]>
</programlisting>

<para>Returns the integer part the receiving string, which is a number, and
<emphasis role="italic">n</emphasis> decimal places. The default
<emphasis role="italic">n</emphasis> is <computeroutput>0</computeroutput>
and returns an integer with no decimal point. If you specify
<emphasis role="italic">n</emphasis>, it must be a
positive whole number or zero. The receiving string is first rounded according
to standard Rexx rules, as though the operation
<computeroutput>receiving_string+0</computeroutput> had been carried out.
This number is then truncated to <emphasis role="italic">n</emphasis> decimal
places or trailing zeros are added if needed to reach the specified length.
The result is never in exponential form. If there are no nonzero digits in
the result, any minus sign is removed.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>TRUNC method</secondary></indexterm>
<programlisting>
12.3~TRUNC            ->    12
127.09782~TRUNC(3)    ->    127.097
127.1~TRUNC(3)        ->    127.100
127~TRUNC(2)          ->    127.00
</programlisting>

<note><title>Note</title>
<para>The <emphasis role="italic">number</emphasis> is rounded according to the
current setting of NUMERIC DIGITS if necessary, before the method processes it.
</para></note>
<para>(See <link linkend="trunc">TRUNC (Truncate)</link>
for information about the TRUNC built-in function.)</para>
</section>

<section id="stveri"><title>VERIFY</title>
<indexterm><primary>VERIFY method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>VERIFY method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>string</primary>
<secondary>verifying contents of</secondary></indexterm>
<indexterm><primary>verifying contents of a string</primary></indexterm>

<programlisting>
<![CDATA[
>>-VERIFY(reference-+---------------------------+-)------------><
                    +-,--+--------+--+--------+-+
                         +-option-+  +-,start-+
]]>
</programlisting>

<para>Returns a number that, by default, indicates whether the receiving string
is composed only of characters from
<emphasis role="italic">reference</emphasis>. It returns
<computeroutput>0</computeroutput> if all characters in the receiving string
are in <emphasis role="italic">reference</emphasis> or
returns the position of the first character in the receiving string not in
<emphasis role="italic">reference</emphasis>.</para>
<para>The <emphasis role="italic">option</emphasis> can be either
<computeroutput>Nomatch</computeroutput> (the
default) or <computeroutput>Match</computeroutput>. (You need to specify only
the first capitalized and highlighted letter; the language processor ignores
all characters following the first character, which can be in uppercase or
lowercase.)</para>
<para>If you specify <computeroutput>Match</computeroutput>, the method returns
the position of the first character in the receiving string that is in
<emphasis role="italic">reference</emphasis>, or returns
<computeroutput>0</computeroutput> if none of the characters
are found.</para>
<para>The default for <emphasis role="italic">start</emphasis> is
<computeroutput>1</computeroutput>. Thus, the search starts
at the first character of the receiving string. You can override this by
specifying a different <emphasis role="italic">start</emphasis> point,
which must be a positive whole number.</para>
<para>If the receiving string is null, the method returns
<computeroutput>0</computeroutput>, regardless
of the value of the <emphasis role="italic">option</emphasis>. Similarly, if
<emphasis role="italic">start</emphasis> is greater
than <computeroutput>receiving_string~LENGTH</computeroutput>, the method
returns <computeroutput>0</computeroutput>. If
<emphasis role="italic">reference</emphasis> is null, the method returns
<computeroutput>0</computeroutput> if
you specify <computeroutput>Match</computeroutput>. Otherwise, the method
returns the <emphasis role="italic">start</emphasis> value.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>VERIFY method</secondary></indexterm>
<programlisting>
"123"~VERIFY("1234567890")             ->    0
"1Z3"~VERIFY("1234567890")             ->    2
"AB4T"~VERIFY("1234567890")            ->    1
"AB4T"~VERIFY("1234567890","M")        ->    3
"AB4T"~VERIFY("1234567890","N")        ->    1
"1P3Q4"~VERIFY("1234567890", ,3)       ->    4
"123"~VERIFY("",N,2)                   ->    2
"ABCDE"~VERIFY("", ,3)                 ->    3
"AB3CD5"~VERIFY("1234567890","M",4)    ->    6
</programlisting>
<para>(See <link linkend="verify">VERIFY</link>
for information about the VERIFY built-in function.)</para>
</section>

<section id="stword"><title>WORD</title>
<indexterm><primary>WORD method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>WORD method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>extracting</primary>
<secondary>word from a string</secondary></indexterm>
<indexterm><primary>locating</primary>
<secondary>word in another string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-WORD(n)-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the <emphasis role="italic">n</emphasis>th blank-delimited word
in the receiving string or the null string if the receiving string has
fewer than <emphasis role="italic">n</emphasis> words. The
<emphasis role="italic">n</emphasis> must be a positive whole number. This
method is exactly equivalent
to <computeroutput>receiving_string~SUBWORD(n,1)</computeroutput>.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>WORD method</secondary></indexterm>
<programlisting>
"Now is the time"~WORD(3)    ->    "the"
"Now is the time"~WORD(5)    ->    ""
</programlisting>
<para>(See <link linkend="xword">WORD</link>
for information about the WORD built-in function.)</para>
</section>

<section id="stwori"><title>WORDINDEX</title>
<indexterm><primary>WORDINDEX method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>WORDINDEX method</secondary>
<tertiary>of String class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-WORDINDEX(n)------------------------------------------------><
]]>
</programlisting>

<para>Returns the position of the first character in the
<emphasis role="italic">n</emphasis>th blank-delimited
word in the receiving string. It returns <computeroutput>0</computeroutput>
if the receiving string has fewer than <emphasis role="italic">n</emphasis>
words. The <emphasis role="italic">n</emphasis> must be a positive whole number.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>WORDINDEX method</secondary></indexterm>
<programlisting>
"Now is the time"~WORDINDEX(3)    ->    8
"Now is the time"~WORDINDEX(6)    ->    0
</programlisting>
<para>(See <link linkend="xwordind">WORDINDEX</link>
for information about the WORDINDEX built-in
function.)</para>
</section>

<section id="stworl"><title>WORDLENGTH</title>
<indexterm><primary>WORDLENGTH method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>WORDLENGTH method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>finding</primary>
<secondary>word length</secondary></indexterm>

<programlisting>
<![CDATA[
>>-WORDLENGTH(n)-----------------------------------------------><
]]>
</programlisting>

<para>Returns the length of the <emphasis role="italic">n</emphasis>th
blank-delimited word in the receiving
string or <computeroutput>0</computeroutput> if the receiving string has fewer
than <emphasis role="italic">n</emphasis> words.
The <emphasis role="italic">n</emphasis> must be a positive whole number.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>WORDLENGTH method</secondary></indexterm>
<programlisting>
"Now is the time"~WORDLENGTH(2)       ->    2
"Now comes the time"~WORDLENGTH(2)    ->    5
"Now is the time"~WORDLENGTH(6)       ->    0
</programlisting>
<para>(See <link linkend="xwordlen">WORDLENGTH</link>
for information about the WORDLENGTH built-in
function.)</para>
</section>

<section id="stworp"><title>WORDPOS</title>
<indexterm><primary>WORDPOS method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>WORDPOS method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>word</primary>
<secondary>locating in a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-WORDPOS(phrase-+--------+-)---------------------------------><
                  +-,start-+
]]>
</programlisting>

<para>Returns the word number of the first word of
<emphasis role="italic">phrase</emphasis> found in the
receiving string, or <computeroutput>0</computeroutput> if
<emphasis role="italic">phrase</emphasis> contains no words or
if <emphasis role="italic">phrase</emphasis> is not found. Several blanks
between words in either <emphasis role="italic">phrase</emphasis> or the
receiving string are treated as a single blank for the
comparison, but, otherwise, the words must match exactly.</para>
<para>By default the search starts at the first word in the receiving string.
You can override this by specifying <emphasis role="italic">start</emphasis>
(which must be positive),
the word at which the search is to be started.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>WORDPOS method</secondary></indexterm>
<programlisting>
"now is the time"~WORDPOS("the")              ->  3
"now is the time"~WORDPOS("The")              ->  0
"now is the time"~WORDPOS("is the")           ->  2
"now is the time"~WORDPOS("is   the")         ->  2
"now is   the time"~WORDPOS("is   time ")     ->  0
"To be or not to be"~WORDPOS("be")            ->  2
"To be or not to be"~WORDPOS("be",3)          ->  6
</programlisting>
<para>(See <link linkend="wordpos">WORDPOS (Word Position)</link>
for information about the WORDPOS built-in
function.)</para>
</section>

<section id="stwors"><title>WORDS</title>
<indexterm><primary>WORDS method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>WORDS method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>counting</primary>
<secondary>words in a string</secondary></indexterm>
<indexterm><primary>extracting</primary>
<secondary>words from a string</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>counting in a string</secondary></indexterm>
<indexterm><primary>word</primary>
<secondary>extracting from a string</secondary></indexterm>

<programlisting>
<![CDATA[
>>-WORDS-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of blank-delimited words in the receiving string.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>WORDS method</secondary></indexterm>
<programlisting>
"Now is the time"~WORDS      ->    4
" "~WORDS                    ->    0
</programlisting>
<para>(See <link linkend="words">WORDS</link>
for information about the WORDS built-in function.)</para>
</section>

<section id="stx2b"><title>X2B</title>
<indexterm><primary>X2B method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>X2B method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>hexadecimal to binary</secondary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>to binary, converting with X2B</secondary></indexterm>

<programlisting>
<![CDATA[
>>-X2B---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string, in character format, that represents the receiving
string, which is a string of hexadecimal characters converted to binary. The
receiving string can be of any length. Each hexadecimal character is converted
to a string of 4 binary digits. The receiving string can optionally include
blanks (at byte boundaries only, not leading or trailing) to improve
readability; they are ignored.</para>
<para>The returned string has a length that is a multiple of four, and does not
include any blanks.</para>
<para>If the receiving string is null, the method returns a null string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>X2B method</secondary></indexterm>
<programlisting>
"C3"~X2B        ->  "11000011"
"7"~X2B         ->  "0111"
"1 C1"~X2B      ->  "000111000001"
</programlisting>
<para>You can combine X2B with the methods D2X and C2X to convert numbers or
character strings into binary form.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
"C3"x~C2X~X2B  ->  "11000011"
"129"~D2X~X2B  ->  "10000001"
"12"~D2X~X2B   ->  "1100"
</programlisting>
<para>(See <link linkend="x2b">X2B (Hexadecimal to Binary)</link>
for information about the X2B built-in function.)</para>
</section>

<section id="stx2c"><title>X2C</title>
<indexterm><primary>X2C method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>X2C method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>hexadecimal to character</secondary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>to character, converting with X2C</secondary></indexterm>
<indexterm><primary>packing a string with X2C</primary></indexterm>

<programlisting>
<![CDATA[
>>-X2C---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string, in character format, that represents the receiving
string, which is a hexadecimal string converted to character. The returned string
is half as many bytes as the receiving string. The receiving string can be
any length. If necessary, it is padded with a leading 0 to make an even number
of hexadecimal digits.</para>
<para>You can optionally include blanks in the receiving string (at byte boundaries
only, not leading or trailing) to improve readability; they are ignored.</para>
<para>If the receiving string is null, the method returns a null string.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>X2C method</secondary></indexterm>
<programlisting>
"4865 6c6c 6f"~X2C ->  "Hello"     /*  ASCII             */
"3732 73"~X2C      ->  "72s"       /*  ASCII             */
</programlisting>
<para>(See <link linkend="x2c">X2C (Hexadecimal to Character)</link>
for information about the X2C built-in function.)</para>
</section>

<section id="stx2d"><title>X2D</title>
<indexterm><primary>X2D method</primary>
<secondary>of String class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>X2D method</secondary>
<tertiary>of String class</tertiary></indexterm>
<indexterm><primary>conversion</primary>
<secondary>hexadecimal to deciaml</secondary></indexterm>
<indexterm><primary>hexadecimal</primary>
<secondary>to decimal, converting with X2D</secondary></indexterm>

<programlisting>
<![CDATA[
>>-X2D-+-----+-------------------------------------------------><
       +-(n)-+
]]>
</programlisting>

<para>Returns the decimal representation of the receiving string, which is a
string of hexadecimal characters. If the result cannot be expressed as a whole
number, an error results. That is, the result must not have more digits than
the current setting of NUMERIC DIGITS.</para>
<para>You can optionally include blanks in the receiving string (at byte
boundaries only, not leading or trailing) to improve readability; they are
ignored.</para>
<para>If the receiving string is null, the method returns
<computeroutput>0</computeroutput>.</para>
<para>If you do not specify <emphasis role="italic">n</emphasis>,
the receiving string is processed as
an unsigned binary number.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>X2D method</secondary></indexterm>
<programlisting>
"0E"~X2D        ->    14
"81"~X2D        ->    129
"F81"~X2D       ->    3969
"FF81"~X2D      ->    65409
"46 30"X~X2D    ->    240          /*  ASCII   */
"66 30"X~X2D    ->    240          /*  ASCII   */
</programlisting>
<para>If you specify <emphasis role="italic">n</emphasis>, the receiving string
is taken as a signed number expressed in <emphasis role="italic">n</emphasis>
hexadecimal digits. If the leftmost bit is off, then
the number is positive; otherwise, it is a negative number. In both cases
it is converted to a whole number, which can be negative. If
<emphasis role="italic">n</emphasis> is <computeroutput>0</computeroutput>,
the method returns <computeroutput>0</computeroutput>.</para>
<para>If necessary, the receiving string is padded on the left with
<computeroutput>0</computeroutput> characters
(note, not &quot;sign-extended&quot;), or truncated on the left to
<emphasis role="italic">n</emphasis> characters.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<programlisting>
"81"~X2D(2)      ->    -127
"81"~X2D(4)      ->    129
"F081"~X2D(4)    ->    -3967
"F081"~X2D(3)    ->    129
"F081"~X2D(2)    ->    -127
"F081"~X2D(1)    ->    1
"0031"~X2D(0)    ->    0
</programlisting>
<para>(See <link linkend="x2d">X2D (Hexadecimal to Decimal)</link>
for information about the X2D built-in function.)</para>
</section>
</section>

<section id="stemcl"><title>The Stem Class</title>
<indexterm><primary>Stem class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Stem class</secondary></indexterm>
<para>A stem object is a collection with unique indexes
that are character strings.</para>
<para>Stems are automatically created whenever a Rexx stem variable or Rexx
compound variable is used. For example: </para>
<programlisting>
a.1 = 2
</programlisting>
<para>creates a new stem collection with the name <computeroutput>A.</computeroutput>
and assigns it to the Rexx variable <computeroutput>A.</computeroutput>; it also assigns
the value 2 to entry 1 in the collection.</para>
<para>The value of an uninitialied stem index is the stem object NAME
concatenated with the derived stem index.  For
example</para>
<programlisting>
say a.[1,2]  -- implcitly creates stem object with name "A."
-- displays "A.1.2"

a = .stem~new("B.")
say a[1,2]     -- displays "B.1.2"
</programlisting>
<para>In addition to the items explicitly assigned to the
collection indexes,
a value may be assigned to all possible stem indexes.  The
<computeroutput>[]=</computeroutput> method (with no index argument)
will assign the target value to all possible stem indexes.
Following assignment, a reference to any index will return the new value until
another value is assigned or the index is dropped.</para>
<para>The <computeroutput>[]</computeroutput> method (with no index specified) will retrieve any
globally assigned value.  By default, this
returns the stem NAME value.</para>
<para>In addition to the methods defined in the following, the Stem class removes
the methods =, ==, \=, \==, &lt;>, and >&lt; using the DEFINE method.</para>
<para><emphasis role="bold">Methods the Stem class defines:</emphasis></para>
<simplelist>
<member>NEW (Class method.&nbsp;&nbsp;Overrides Object class method.)</member>
<member>[]</member>
<member>[]=</member>
<member>MAKEARRAY</member>
<member>REQUEST (Overrides Object class method)</member>
<member>UNKNOWN</member>
</simplelist>
<para><emphasis role="bold">Methods inherited from the Object class:</emphasis>
</para>
<simplelist>
<member>Operator methods:&nbsp;&nbsp;=, ==, \=, >&lt;, &lt;>, \==</member>
<member>CLASS</member>
<member>COPY</member>
<member>DEFAULTNAME</member>
<member>HASMETHOD</member>
<member>OBJECTNAME</member>
<member>OBJECTNAME=</member>
<member>RUN</member>
<member>SETMETHOD</member>
<member>START</member>
<member>STRING</member>
<member>UNSETMETHOD</member>
</simplelist>

<note><title>Note</title>
<para>The Stem class also has available class methods that its metaclass,
the Class class, defines.</para></note>

<section id="newste"><title>NEW  (Class Method)</title>
<indexterm><primary>NEW method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>NEW method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-NEW-+--------+----------------------------------------------><
       +-(name)-+
]]>
</programlisting>

<para>Returns a new stem object. If you specify a string
<emphasis role="italic">name</emphasis>, this
value is used to create the derived name of compound variables. The default
stem name is a null string.</para>
</section>

<section id="stlbrk"><title>[]</title>
<indexterm><primary>[] method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[] method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
     +-,---------+
     V           |
>>-[---+-------+-+-]-------------------------------------------><
       +-index-+
]]>
</programlisting>

<para>Returns the item associated with the specified
<emphasis role="italic">index</emphasis>es. Each
<emphasis role="italic">index</emphasis> is an expression; use commas to
separate the expressions. The language processor concatenates the
<emphasis role="italic">index</emphasis> expression string values, separating
them with a period (.), to create a derived index. A null string (&quot;&quot;)
is used for any omitted expressions. The resulting string references the stem
item. If the stem has no item associated with the specified final
<emphasis role="italic">index</emphasis>, the stem default value is returned.
If a default value has not been
set, the stem name concatenated with the final index string is returned.</para>
<para>If you do not specify <emphasis role="italic">index</emphasis>, the stem
default value is returned.
If no default value has been assigned, the stem name is returned. </para>

<note><title>Note</title>
<para>You cannot use the [] method in a DROP or PROCEDURE instruction
or in a parsing template.</para></note>
</section>

<section id="lreqsm"><title>[]=</title>
<indexterm><primary>[]= method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[]= method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
     +-,---------+
     V           |
>>-[---+-------+-+-]=value-------------------------------------><
       +-index-+
]]>
</programlisting>

<para>Makes the value a member item of the stem collection and associates it
with the specified index. If you specify no
<emphasis role="italic">index</emphasis> expressions, a
new default stem value is assigned. Assigning a new default value will
re-initialize the stem and remove all existing assigned indexes.</para>
</section>

<section id="makasm"><title>MAKEARRAY</title>
<indexterm><primary>MAKEARRAY method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MAKEARRAY method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-MAKEARRAY---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all stem indexes that currently have an associated
value. The items appear in the array in an unspecified order.  (The program
should not rely on any order.)</para>
</section>

<section id="reqsm"><title>REQUEST</title>
<indexterm><primary>REQUEST method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>REQUEST method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-REQUEST(classid)--------------------------------------------><
]]>
</programlisting>

<para>Returns the result of the Stem class MAKEARRAY method, if the requested
class is ARRAY. For all other classes, REQUEST forwards the message to the
default value of the stem and returns this result. This method requests
conversion to a specific class. All conversion requests except ARRAY are
forwarded to the current stem default value.</para>
</section>

<section id="unkstm"><title>UNKNOWN</title>
<indexterm><primary>UNKNOWN method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>UNKNOWN method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-UNKNOWN-(messagename,messageargs)---------------------------><
]]>
</programlisting>

<para>Reissues or forwards to the current stem default value all unknown
messages sent to a stem collection. For additional information, see
<link linkend="unkno">Defining an UNKNOWN Method</link>.</para>
</section>
</section>

<section id="strcl"><title>The Stream Class</title>
<indexterm><primary>Stream class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Stream class</secondary></indexterm>
<para>A stream object allows external communication from
Rexx. (See <link linkend="iostrms">Input and Output Streams</link> for a
discussion of Rexx input and output.)</para>
<para>The Stream class is a subclass of the Object class.</para>
<para><emphasis role="bold">Methods the Stream class defines:</emphasis></para>
<simplelist>
<member>ARRAYIN</member>
<member>ARRAYOUT</member>
<member>CHARIN</member>
<member>CHAROUT</member>
<member>CHARS</member>
<member>CLOSE</member>
<member>COMMAND</member>
<member>DESCRIPTION</member>
<member>FLUSH</member>
<member>LINEIN</member>
<member>LINEOUT</member>
<member>LINES</member>
<member>MAKEARRAY</member>
<member>OPEN</member>
<member>POSITION</member>
<member>QUALIFY</member>
<member>QUERY</member>
<member>SAY</member>
<member>SEEK</member>
<member>STATE</member>
<member>SUPPLIER</member>
<member>UNINIT</member>
</simplelist>
<para><emphasis role="bold">Methods inherited from the Object class:</emphasis>
</para>
<simplelist>
<member>NEW (Class method)</member>
<member>Operator methods:&nbsp;&nbsp;=, ==, \=, >&lt;, &lt;>, \==</member>
<member>CLASS</member>
<member>COPY</member>
<member>DEFAULTNAME</member>
<member>HASMETHOD</member>
<member>OBJECTNAME</member>
<member>OBJECTNAME=</member>
<member>REQUEST</member>
<member>RUN</member>
<member>SETMETHOD</member>
<member>START</member>
<member>STRING</member>
<member>UNSETMETHOD</member>
</simplelist>

<note><title>Note</title>
<para>The Stream class also has available class methods that its
metaclass, the Class class, defines.</para></note>

<section id="strmnew"><title>NEW</title>
<indexterm><primary>NEW method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>NEW method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-NEW(name)---------------------------------------------------><
]]>
</programlisting>

<para>Initializes a stream object for a stream
named <emphasis role="italic">name</emphasis>, but does not open the stream.
See <link linkend="creo">Initialization</link> for
more information. Returns the new stream object</para>
</section>

<section id="stmari"><title>ARRAYIN</title>
<indexterm><primary>ARRAYIN method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ARRAYIN method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
            +-(LINES)-+
>>-ARRAYIN--+---------+----------------------------------------><
            +-(CHARS)-+
]]>
</programlisting>

<para>Returns a fixed array that contains the data of the stream in line or
character format, starting from the current read position. The line format is
the default.</para>
<para>If you have used the CHARIN method, the first line can be a partial line.
</para>
</section>

<section id="stmaro"><title>ARRAYOUT</title>
<indexterm><primary>ARRAYOUT method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ARRAYOUT method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
                  +-,--LINES-+
>>-ARRAYOUT(array-+----------+-)-------------------------------><
                  +-,--CHARS-+
]]>
</programlisting>

<para>Returns a stream object that contains the data from
<emphasis role="italic">array</emphasis>.</para>
</section>

<section id="charim"><title>CHARIN</title>
<indexterm><primary>CHARIN method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CHARIN method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CHARIN-+----------------------------+-----------------------><
          +-(-+-------+--+---------+-)-+
              +-start-+  +-,length-+
]]>
</programlisting>

<para>Returns a string of up to <emphasis role="italic">length</emphasis>
characters from the character input stream receiving the message. The language
processor advances the read pointer. If you omit
<emphasis role="italic">length</emphasis>, it defaults to
<computeroutput>1</computeroutput>. If you specify
<emphasis role="italic">start</emphasis>, this positions the read pointer
before reading. If the stream is not already open, the language processor tries
to open the stream for reading and writing. If that fails, the language
processor opens the stream for read only. (See
<link linkend="charin">CHARIN (Character Input)</link>  for information
about the CHARIN built-in function.)</para>
</section>

<section id="charom"><title>CHAROUT</title>
<indexterm><primary>CHAROUT method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CHAROUT method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CHAROUT-+----------------------------+----------------------><
           +-(-+--------+--+--------+-)-+
               +-string-+  +-,start-+
]]>
</programlisting>

<para>Returns the count of characters remaining after trying to write
<emphasis role="italic">string</emphasis> to the character output stream
receiving the message. The language processor
advances the write pointer.</para>
<para>The <emphasis role="italic">string</emphasis> can be the null string.
In this case, CHAROUT writes
no characters to the stream and returns <computeroutput>0</computeroutput>.
If you omit <emphasis role="italic">string</emphasis>, CHAROUT writes no
characters to the stream and returns <computeroutput>0</computeroutput>.
The language processor closes the stream.</para>
<para>If you specify <emphasis role="italic">start</emphasis>, this positions
the write pointer before
writing. If the stream is not already open, the language processor tries to
open the stream for reading and writing. If that fails, the language processor
opens the stream for write only. (See <link linkend="charout">CHAROUT
(Character Output)</link>  for information
about the CHAROUT built-in function.)</para>
</section>

<section id="charsm"><title>CHARS</title>
<indexterm><primary>CHARS method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CHARS method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CHARS-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the total number of characters remaining in the
character input stream receiving the message. The default input stream is
STDIN. The count includes any line separator characters, if these are defined
for the stream. In the case of persistent streams, it is the count of characters
from the current read position. (See
<link linkend="iostrms">Input and Output Streams</link> for a discussion
of Rexx input and output.) The total number of characters remaining cannot
be determined for some streams (for example, STDIN). For these streams. the
CHARS method returns <computeroutput>1</computeroutput>
to indicate that data is present, or <computeroutput>0</computeroutput>
if no data is present. For Windows devices,
CHARS always returns <computeroutput>1</computeroutput>. (See
<link linkend="chars">CHARS (Characters Remaining)</link> for information
about the CHARS built-in function.)</para>
</section>

<section id="stclos"><title>CLOSE</title>
<indexterm><primary>CLOSE method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>CLOSE method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-CLOSE-------------------------------------------------------><
]]>
</programlisting>

<para>Closes the stream that receives the message. CLOSE returns
<computeroutput>READY:</computeroutput> if closing the stream is successful,
or an appropriate error message.
If you have tried to close an unopened file, then the CLOSE method returns
a null string (&quot;&quot;).</para>
</section>

<section id="cmdmet"><title>COMMAND</title>
<indexterm><primary>COMMAND method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>COMMAND method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-COMMAND(stream_command)-------------------------------------><
]]>
</programlisting>

<para>Returns a string after performing the specified
<emphasis role="italic">stream_command</emphasis>. The returned string depends
on the <emphasis role="italic">stream_command</emphasis> performed
and can be the null string. The following
<emphasis role="italic">stream_command</emphasis>s: </para>
<itemizedlist>
<listitem><para>Open a stream for reading, writing, or both</para></listitem>
<listitem><para>Close a stream at the end of an operation</para></listitem>
<listitem><para>Move the line read or write position within a persistent stream
(for example, a file)</para></listitem>
<listitem><para>Get information about a stream</para></listitem></itemizedlist>

<para>If the method is unsuccessful, it returns an error message
string in the same form that the DESCRIPTION method uses.</para>
<para>For most error conditions, the additional information is in the form of
a numeric return code. This return code is the value of
<computeroutput>ERRNO</computeroutput> that
is set whenever one of the file system primitives returns with a
<computeroutput>-1</computeroutput>.</para>

<section id="commstr"><title>Command Strings</title>
<para>The argument <emphasis role="italic">stream_command</emphasis>
can be any expression that the language processor evaluates to a command string
that corresponds to the following diagram:</para>
<programlisting>
<![CDATA[
           +-BOTH--| Write Options |-+
>>-+-OPEN--+-------------------------+--+-------------+-+------><
   |       +-READ--------------------+  +-| Options |-+ |
   |       +-WRITE--+---------+------+                  |
   |                +-APPEND--+                         |
   |                +-REPLACE-+                         |
   +-CLOSE----------------------------------------------+
   +-FLUSH----------------------------------------------+
   |               +- = -+                    +-CHAR-+  |
   +-+-SEEK-----+--+-----+-offset--+-------+--+------+--+
   | +-POSITION-+  +- < -+         +-READ--+  +-LINE-+  |
   |               +- + -+         +-WRITE-+            |
   |               +- - -+                              |
   +-QUERY--+-DATETIME--------------------------+-------+
            +-EXISTS----------------------------+
            +-HANDLE----------------------------+
            |                       +-CHAR-+    |
            +-+-SEEK-----+--+-READ--+------+--+-+
            | +-POSITION-+  |       +-LINE-+  | |
            |               |        +-CHAR-+ | |
            |               +-WRITE--+------+-+ |
            |               |        +-LINE-+ | |
            |               +-SYS-------------+ |
            +-SIZE------------------------------+
            +-STREAMTYPE------------------------+
            +-TIMESTAMP-------------------------+
]]>
</programlisting>

<para><emphasis role="bold">Write Options:</emphasis></para>

<programlisting>
<![CDATA[
|--+---------+--------------------------------------------------|
   +-APPEND--+
   +-REPLACE-+
]]>
</programlisting>

<para><emphasis role="bold">Options:</emphasis></para>

<programlisting>
<![CDATA[
                   +-----------------------------------+
                   V                                   |
|--+------------+----+-NOBUFFER----------------------+-+--------|
   +-SHARED-----+    +-BINARY--+-------------------+-+
   +-SHAREREAD--+              +-RECLENGTH--length-+
   +-SHAREWRITE-+
]]>
</programlisting>

<variablelist>
<varlistentry><term>OPEN</term>
<listitem><para>Opens the stream object receiving the message and returns
<computeroutput>READY:</computeroutput>. (If unsuccessful, the previous
information about return codes applies.)
The default for OPEN is to open the stream for both reading and writing data,
for example: <computeroutput>&apos;OPEN BOTH&apos;</computeroutput>. To specify that the
<emphasis role="italic">stream_name</emphasis> receiving the message can be
only read or written to, add READ or WRITE, to the command string. </para>
<para>The following is a description of the options for
OPEN: </para>
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>Opens the stream only for reading.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>Opens the stream only for writing.
</para></listitem></varlistentry>
<varlistentry><term>BOTH</term>
<listitem><para>Opens the stream for both reading and writing. (This is the
default.) The language processor maintains separate read and write pointers.
</para></listitem></varlistentry>
<varlistentry><term>APPEND</term>
<listitem><para>Positions the write pointer at the end of the stream. The write
pointer cannot be moved anywhere within the extent of the file as it existed
when the file was opened.
</para></listitem></varlistentry>
<varlistentry><term>REPLACE</term>
<listitem><para>Sets the write pointer to the beginning of the stream and
truncates the file. In other words, this option deletes all data that was in
the stream when opened.
</para></listitem></varlistentry>
<varlistentry><term>SHARED</term>
<listitem><para>Enables another process to work with the stream in a shared
mode. This mode must be compatible with the shared mode (SHARED, SHAREREAD, or
SHAREWRITE) used by the process that opened the stream.
</para></listitem></varlistentry>
<varlistentry><term>SHAREREAD</term>
<listitem><para>Enables another process to read the stream in a shared mode.
</para></listitem></varlistentry>
<varlistentry><term>SHAREWRITE</term>
<listitem><para>Enables another process to write the stream in a shared mode.
</para></listitem></varlistentry>
<varlistentry><term>NOBUFFER</term>
<listitem><para>Turns off buffering of the stream.
All data written to the stream is
flushed immediately to the operating system for writing. This option can have
a severe impact on output performance. Use it only when data integrity is
a concern, or to force interleaved output to a stream to appear in the exact
order in which it was written.
</para></listitem></varlistentry>
<varlistentry><term>BINARY</term>
<listitem><para>Opens the stream in binary mode.
This means that line end characters
are ignored; they are treated like any other byte of data. This is intended
to force file operations that are compatible with other
Rexx language processors that run on record-based systems, or to process
binary data using the line operations.</para>

<note><title>Note</title>
<para>Specifying the BINARY option for a stream that
does not exist but is opened for writing also requires the RECLENGTH option
to be specified. Omitting the RECLENGTH option in this case raises an error
condition.</para></note>
</listitem></varlistentry>
<varlistentry><term>RECLENGTH <emphasis role="italic">length</emphasis></term>
<listitem><para>Allows the specification of an exact length
for each line in a stream.
This allows line operations on binary-mode streams to operate on individual
fixed-length records. Without this option, line operations on binary-mode
files operate on the entire file (for example, as if you specified the
<computeroutput>RECLENGTH</computeroutput> option with a length equal to
that of the file). The <emphasis role="italic">length</emphasis> must be
<computeroutput>1</computeroutput> or greater.
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>COMMAND method</secondary>
<tertiary>OPEN option</tertiary></indexterm>
<programlisting>
stream_name~Command("open")
stream_name~Command("open write")
stream_name~Command("open read")
stream_name~Command("open read shared")
</programlisting>
</listitem></varlistentry>
<varlistentry><term>CLOSE</term>
<listitem><para>closes the stream object receiving the message. The COMMAND
method with the CLOSE option returns <computeroutput>READY:</computeroutput>
if the receiving stream object
is successfully closed or an appropriate error message otherwise. If an attempt
to close an unopened file occurs, then the COMMAND method with the CLOSE option
returns a null string (&quot;&quot;).
</para></listitem></varlistentry>
<varlistentry><term>FLUSH</term>
<listitem><para>forces any data currently buffered for writing to be written to
this stream.
</para></listitem></varlistentry>
<varlistentry><term>SEEK <emphasis role="italic">offset</emphasis></term>
<listitem><para>sets the read or write position to a given number
(<emphasis role="italic">offset</emphasis>) within a persistent stream. If the
stream is open for both reading
and writing and you do not specify READ or WRITE, both the read and write
positions are set.</para>

<note><title>Note</title>
<para>See <link linkend="iostrms">Input and Output Streams</link>  for a
discussion of read and write positions in a persistent stream.</para></note>
<para>To
use this command, you must first open the receiving stream object (with the
OPEN stream command described previously or implicitly with an input or output
operation). One of the following characters can precede the
<emphasis role="italic">offset</emphasis> number. </para>
<variablelist>
<varlistentry><term>=</term>
<listitem><para>explicitly specifies the
<emphasis role="italic">offset</emphasis> from the beginning of the stream.
This is the default if you supply no prefix. For example, an
<emphasis role="italic">offset</emphasis> of <computeroutput>1</computeroutput>
with the LINE option means the beginning of the stream.
</para></listitem></varlistentry>
<varlistentry><term>&lt;</term>
<listitem><para>specifies <emphasis role="italic">offset</emphasis> from the
end of the stream.</para></listitem></varlistentry>
<varlistentry><term>+</term>
<listitem><para>specifies <emphasis role="italic">offset</emphasis>
forward from the current read or write position.
</para></listitem></varlistentry>
<varlistentry><term>-</term>
<listitem><para>specifies <emphasis role="italic">offset</emphasis>
backward from the current read or write position.
</para></listitem></varlistentry>
</variablelist>
<para>The COMMAND method with the SEEK option returns the new position
in the stream if the read or write position is successfully located, or an
appropriate error message.</para>
<para>The following is a description of the options
for SEEK: </para>
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>specifies that this command sets the read position.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>specifies that this command sets the write position.
</para></listitem></varlistentry>
<varlistentry><term>CHAR</term>
<listitem><para>specifies the positioning in terms of characters. This is the
default.
</para></listitem></varlistentry>
<varlistentry><term>LINE</term>
<listitem><para>specifies the positioning in terms of lines. For non-binary streams,
this is potentially an operation that can take a long time to complete because,
in most cases, the file must be scanned from the top to count the line-end
characters. However, for binary streams with a specified record length, the
new resulting line number is simply multiplied by the record length before
character positioning. See
<link linkend="positio">Line versus Character Positioning</link>
for a detailed discussion of this issue. </para>

<note><title>Note</title>
<para>If you do line positioning in a file open only
for writing, you receive an error message.</para></note>
</listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>COMMAND method</secondary>
<tertiary>SEEK option</tertiary></indexterm>
<programlisting>
<![CDATA[
stream_name~Command("seek =2 read")
stream_name~Command("seek +15 read")
stream_name~Command("seek -7 write line")
fromend  = 125
stream_name~Command("seek <"fromend read)
]]>
</programlisting>
</listitem></varlistentry>
<varlistentry><term>POSITION</term>
<listitem><para>is a synonym for SEEK.</para>
<para>Used with these <emphasis role="italic">stream_command</emphasis>s, the
COMMAND method returns
specific information about a stream. Except for QUERY HANDLE and QUERY POSITION,
the language processor returns the query information even if the stream is
not open. The language processor returns the null string for nonexistent streams.
</para>
</listitem>
</varlistentry>
<varlistentry><term>QUERY DATETIME</term>
<listitem><para>Returns the date and time stamps of a stream in US format. For
example:
<indexterm><primary>examples</primary>
<secondary>COMMAND method</secondary>
<tertiary>QUERY DATETIME option</tertiary></indexterm>
<programlisting>
stream_name~Command("query datetime")
</programlisting>
</para><para>A sample output might be: </para>
<programlisting>
11-12-95 03:29:12
</programlisting>
</listitem></varlistentry>
<varlistentry><term>QUERY EXISTS</term>
<listitem><para>Returns the full path specification of the stream object
receiving the message, if it exists, or a null string. For example: </para>
<indexterm><primary>examples</primary>
<secondary>COMMAND method</secondary>
<tertiary>QUERY EXISTS option</tertiary></indexterm>
<programlisting>
stream_name~Command("query exists")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
c:\data\file.txt
</programlisting>
</listitem></varlistentry>
<varlistentry><term>QUERY HANDLE</term>
<listitem><para>Returns the handle associated with the open stream that is the
receiving stream object. For example: </para>
<indexterm><primary>examples</primary>
<secondary>COMMAND method</secondary>
<tertiary>QUERY HANDLE option</tertiary></indexterm>
<programlisting>
stream_name~Command("query handle")
</programlisting>
<para>A sample output might be:
<computeroutput>3</computeroutput></para>

</listitem></varlistentry>
<varlistentry><term>QUERY POSITION</term>
<listitem><para>Returns the current read or write position for the receiving
stream object, as qualified by the following options:
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>Returns the current read position.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>Returns the current write position. </para>

<note><title>Note</title>
<para>If the stream is
open for both reading and writing, this returns the read position by default.
Otherwise, this returns the appropriate position by default.</para></note>
</listitem></varlistentry>
<varlistentry><term>CHAR</term>
<listitem><para>Returns the position in terms of characters. This is the
default.
</para></listitem></varlistentry>
<varlistentry><term>LINE</term>
<listitem><para>Returns the position in terms of lines. For non-binary streams,
this operation can take a long time to complete. This is because the language
processor starts tracking the current line number if not
already doing so, and, thus, might require a scan of the stream from
the top to count the line-end characters. See
<link linkend="positio">Line versus Character Positioning</link>
for a detailed discussion of this issue. For example: </para>
<programlisting>
stream_name~Command("query position write")
</programlisting>
<para>A sample
output might be: </para>
<programlisting>
247
</programlisting>
</listitem></varlistentry>
<varlistentry><term>SYS</term>
<listitem><para>Returns the operating system stream position in terms of
characters.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>QUERY SEEK</term>
<listitem><para>Is a synonym for QUERY POSITION.
</para></listitem></varlistentry>
<varlistentry><term>QUERY SIZE</term>
<listitem><para>Returns the size in bytes of a persistent stream that is the
receiving stream object. For example: </para>
<programlisting>
stream_name~Command("query size")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
1305
</programlisting>
</listitem></varlistentry>
<varlistentry><term>QUERY STREAMTYPE</term>
<listitem><para>Returns a string indicating whether the receiving stream object
is <computeroutput>PERSISTENT</computeroutput>,
<computeroutput>TRANSIENT</computeroutput>, or
<computeroutput>UNKNOWN</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>QUERY TIMESTAMP</term>
<listitem><para>Returns the date and time stamps of the receiving stream object
in an international format. This is the preferred method of getting date and
time because it provides the full 4-digit year. For example:</para>
<programlisting>
stream_name~Command("query timestamp")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
1995-11-12 03:29:12
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="desmet"><title>DESCRIPTION</title>
<indexterm><primary>DESCRIPTION method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>DESCRIPTION method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-DESCRIPTION-------------------------------------------------><
]]>
</programlisting>

<para>Returns any descriptive string associated with the
current state of the stream or the NIL object if no descriptive string is
available. The DESCRIPTION method is identical with the STATE method except
that the string that DESCRIPTION returns is followed by a colon and, if
available, additional information about ERROR or NOTREADY states. (The
<link linkend="statsm">STATE</link> method describes these states.)</para>
</section>

<section id="stflus"><title>FLUSH</title>
<indexterm><primary>FLUSH method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>FLUSH method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-FLUSH-------------------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>READY:</computeroutput>. It forces any data
currently buffered for writing
to be written to the stream receiving the message.</para>
</section>

<section id="linein1"><title>LINEIN</title>
<indexterm><primary>LINEIN method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LINEIN method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-LINEIN-+-------------------------+--------------------------><
          +-(-+------+-+--------+-)-+
              +-line-+ +-,count-+
]]>
</programlisting>

<para>Returns the next <emphasis role="italic">count</emphasis> lines. The
count must be <computeroutput>0</computeroutput> or
<computeroutput>1</computeroutput>. The language processor advances the read
pointer. If you omit <emphasis role="italic">count</emphasis>, it defaults to
<computeroutput>1</computeroutput>. A <emphasis role="italic">line</emphasis>
number may be given to set the read position to the start of a specified
line. This line number must be positive and within the bounds of the stream,
and must not be specified for a transient stream. A value of 1 for
<emphasis role="italic">line</emphasis> refers to the first line in the stream.
If the stream is not already
open, the language processor tries to open the stream for reading and writing.
If that fails, the language processor opens the stream for read-only. (See
<link linkend="linein">LINEIN (Line Input)</link>  for information about the
LINEIN built-in function.)</para>
</section>

<section id="lineom"><title>LINEOUT</title>
<indexterm><primary>LINEOUT method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LINEOUT method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-LINEOUT-+--------------------------+------------------------><
           +-(-+--------+-+-------+-)-+
               +-string-+ +-,line-+
]]>
</programlisting>

<para>Returns <computeroutput>0</computeroutput> if successful in writing
<emphasis role="italic">string</emphasis> to the character output stream
receiving the message or <computeroutput>1</computeroutput> if
an error occurs while writing the line. The language processor advances the
write pointer. If you omit <emphasis role="italic">string</emphasis>, the
language processor closes the stream. If you specify
<emphasis role="italic">line</emphasis>, this positions the write pointer
before writing. If the stream is not already open, the language processor
tries to open the stream for reading and writing. If that fails, the language
processor opens the stream for write-only. (See
<link linkend="lineout">LINEOUT (Line Output)</link>  for
information about the LINEOUT built-in function.)</para>
</section>

<section id="linesm"><title>LINES</title>
<indexterm><primary>LINES method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>LINES method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
           +-Count--+
>>-LINES(--+--------+---)--------------------------------------><
           +-Normal-+
]]>
</programlisting>

<para>Returns the number of completed lines that remain in the character input
stream receiving the message. If the stream has already been read with CHARIN,
this can include an initial partial line. For persistent streams the count
starts at the current read position. In effect, LINES reports whether a read
action of CHARIN (see <link linkend="charim">CHARIN</link>) or LINEIN (see
<link linkend="linein1">LINEIN</link>) will succeed. (For an explanation of
input and output, see
<link linkend="iostrms">Input and Output Streams</link>.)</para>
<para>For QUEUE, LINES returns the actual number of lines. (See
<link linkend="ylines">LINES (Lines Remaining)</link> for
information about the LINES built-in function.)</para>
<para> </para>

<note><title>Note</title>
<para>The CHARS method returns the number of characters in a
persistent stream or the presence of data in a transient stream. The LINES
method determines the actual number of lines by scanning the stream starting
at the current position and counting the lines. For large streams, this can
be a time-consuming operation.  Therefore, avoid the use of the LINES method
in the  condition of a loop reading a stream. It is recommended that you use
the CHARS method (see <link linkend="charsm">CHARS</link>) or the LINES
built-in function for this purpose.</para></note>

<para>The ANSI Standard has extended this function to allow an option: "Count".
If this option is used, LINES returns the actual number of complete
lines remaining in the stream, irrespective of how long this operation takes.
</para>

<para>The option "Normal" returns 1 if there is at least one complete line
remaining in the file or 0 if no lines remain.</para>

<para>The default is "Count".</para>

<para>The defaults of the LINES method and function are different because of
compatibility reasons.</para>

</section>

<section id="stasfa"><title>MAKEARRAY</title>
<indexterm><primary>MAKEARRAY method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>MAKEARRAY method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
              +-(LINES)-+
>>-MAKEARRAY--+---------+--------------------------------------><
              +-(CHARS)-+
]]>
</programlisting>

<para>Returns a fixed array that contains
the data of the stream in line or character format, starting from the current
read position. The line format is the default.</para>
<para>If you have used the CHARIN method, the first line can be a partial line.
</para>
</section>

<section id="stopen"><title>OPEN</title>
<indexterm><primary>OPEN method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>OPEN method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
         +-(BOTH-| Write Options |--+  +-SHARED-----+
>>-OPEN--+--------------------------+--+------------+----------->
         +-(READ--------------------+  +-SHAREREAD--+
         +-(WRITE-| Write Options |-+  +-SHAREWRITE-+

   +-----------------------------------+
   V                                   |
>----+-------------------------------+-+--+---+----------------><
     +-NOBUFFER----------------------+    +-)-+
     +-BINARY--+-------------------+-+
               +-RECLENGTH--length-+
]]>
</programlisting>

<para><emphasis role="bold">Write Options:</emphasis></para>

<programlisting>
<![CDATA[
   +-------------+
   V +-APPEND--+ |
|----+---------+-+----------------------------------------------|
     +-REPLACE-+
]]>
</programlisting>

<para>Opens the stream to which you send the message and returns
<computeroutput>READY:</computeroutput>. If the method is unsuccessful, it
returns an error message string
in the same form that the DESCRIPTION method uses.</para>
<para>For most error conditions, the additional information is in the form of
a numeric return code. This return code is the value of
<computeroutput>ERRNO</computeroutput>,
which is set whenever one of the file system primitives returns with a
<computeroutput>-1</computeroutput>.</para>
<para>By default, OPEN opens the stream for both reading and writing data, for
example: <computeroutput>&apos;OPEN BOTH&apos;</computeroutput>. To specify that the
stream receiving
the message can be only read or only written to, specify READ or WRITE.</para>
<para>The options for the OPEN method are: </para>
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>Opens the stream only for reading.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>Opens the stream only for writing.
</para></listitem></varlistentry>
<varlistentry><term>BOTH</term>
<listitem><para>Opens the stream for both reading and writing. (This is the
default.) The language processor maintains separate read and write pointers.
</para></listitem></varlistentry>
<varlistentry><term>APPEND</term>
<listitem><para>Positions the write pointer at the end of the stream.
(This is the default.)
The write pointer cannot be moved anywhere within the extent of the file as
it existed when the file was opened.
</para></listitem></varlistentry>
<varlistentry><term>REPLACE</term>
<listitem><para>Sets the write pointer to the beginning of the stream
and truncates
the file. In other words, this option deletes all data that was in the stream
when opened.
</para></listitem></varlistentry>
<varlistentry><term>SHARED</term>
<listitem><para>Enables another process to work with the stream in a shared mode. (This
is the default.) This mode must be compatible with the shared mode (SHARED,
SHAREREAD, or SHAREWRITE) used by the process that opened the stream.
</para></listitem></varlistentry>
<varlistentry><term>SHAREREAD</term>
<listitem><para>Enables another process to read the stream in a shared mode.
</para></listitem></varlistentry>
<varlistentry><term>SHAREWRITE</term>
<listitem><para>Enables another process to write the stream in a shared mode.
</para></listitem></varlistentry>
<varlistentry><term>NOBUFFER</term>
<listitem><para>Turns off buffering of the stream. All data written to the stream is
flushed immediately to the operating system for writing. This option can have
a severe impact on output performance. Use it only when data integrity is
a concern, or to force interleaved output to a stream to appear in the exact
order in which it was written.
</para></listitem></varlistentry>
<varlistentry><term>BINARY</term>
<listitem><para>Opens the stream in binary mode. This means that line-end
characters are ignored; they are treated like any other byte of data. This is
intended to force file operations that are compatible with
other Rexx language processors
that run on record-based systems, or to process binary data using the line
operations. </para>

<note><title>Note</title>
<para>Specifying the BINARY option for a stream that
does not exist but is opened for writing also requires the RECLENGTH option
to be specified. Omitting the RECLENGTH option in this case raises an error
condition.</para></note>
</listitem></varlistentry>
<varlistentry><term>RECLENGTH <emphasis role="italic">length</emphasis></term>
<listitem><para>Allows the specification of an exact length for each line
in a stream.
This allows line operations on binary-mode streams to operate on individual
fixed-length records. Without this option, line operations on binary-mode
files operate on the entire file (for example, as if you specified the
<computeroutput>RECLENGTH</computeroutput> option with a length equal to that
of the file). The <emphasis role="italic">length</emphasis> must be
<computeroutput>1</computeroutput> or greater.
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>OPEN method</secondary></indexterm>
<programlisting>
stream_name~OPEN
stream_name~OPEN("write")
stream_name~OPEN("read")
</programlisting>
</section>

<section id="stposi"><title>POSITION</title>
<indexterm><primary>POSITION method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>POSITION method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
             +- = -+                  +-CHAR-+
>>-POSITION(-+-----+-offset-+-READ--+-+------+-)---------------><
             +- < -+        +-WRITE-+ +-LINE-+
             +- + -+
             +- - -+
]]>
</programlisting>

<para>POSITION is a synonym for SEEK. (See
<link linkend="stseek">SEEK</link> .)</para>
</section>

<section id="qualm"><title>QUALIFY</title>
<indexterm><primary>QUALIFY method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>QUALIFY method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-QUALIFY-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the stream's fully qualified name. The stream need
not be open.</para>
</section>

<section id="stquer"><title>QUERY</title>
<indexterm><primary>method</primary>
<secondary>QUERY</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<indexterm><primary>QUERY method</primary>
<secondary>of Stream class</secondary></indexterm>

<programlisting>
<![CDATA[
>>-QUERY(--+-DATETIME--------------------------+--)------------><
           +-EXISTS----------------------------+
           +-HANDLE----------------------------+
           |                       +-CHAR-+    |
           +-+-SEEK-----+--+-READ--+------+--+-+
           | +-POSITION-+  |       +-LINE-+  | |
           |               |        +-CHAR-+ | |
           |               +-WRITE--+------+-+ |
           |               |        +-LINE-+ | |
           |               +-SYS-------------+ |
           +-SIZE------------------------------+
           +-STREAMTYPE------------------------+
           +-TIMESTAMP-------------------------+
]]>
</programlisting>

<para>Used with these options, the QUERY method returns specific information
about a stream. Except for QUERY HANDLE and QUERY POSITION, the
language processor
returns the query information even if the stream is not open. The language
processor returns the null string for nonexistent streams. </para>
<variablelist>
<varlistentry><term>DATETIME</term>
<listitem><para>returns the date and time stamps of the receiving stream object
in US format. For example:</para>
<programlisting>
stream_name~query("datetime")
</programlisting>
<para>A sample output might
be: </para>
<programlisting>
11-12-98 03:29:12
</programlisting>
</listitem></varlistentry>
<varlistentry><term>EXISTS</term>
<listitem><para>returns the full path specification of the receiving stream
object, if it exists, or a null string. For example: </para>
<indexterm><primary>examples</primary>
<secondary>QUERY method</secondary></indexterm>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~query("exists")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
c:\data\file.txt
</programlisting>
</listitem></varlistentry>
<varlistentry><term>HANDLE</term>
<listitem><para>returns the handle associated with the open stream that is the
receiving stream object. For example:</para>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~query("handle")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
3
</programlisting>
</listitem></varlistentry>
<varlistentry><term>POSITION</term>
<listitem><para>returns the current read or write position for the receiving
stream object, as qualified by the following options:
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>returns the current read position.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>returns the current write position. </para>

<note><title>Note</title>
<para>If the stream is
open for both reading and writing, this returns the read position by default.
Otherwise, this returns the appropriate position by default.</para></note>
</listitem></varlistentry>
<varlistentry><term>CHAR</term>
<listitem><para>returns the position in terms of characters.
This is the default.
</para></listitem></varlistentry>
<varlistentry><term>LINE</term>
<listitem><para>returns the position in terms of lines. For non-binary streams,
this operation can take a long time to complete. This is because the language
processor starts tracking the current line number if not already doing so, and,
thus, might require a scan of the stream from the top to count the line-end
characters. See
<link linkend="positio">Line versus Character Positioning</link>
for a detailed discussion of this issue. For example: </para>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~query("position write")
</programlisting>
<para>A sample output
might be: </para>
<programlisting>
247
</programlisting>
</listitem></varlistentry>
<varlistentry><term>SYS</term>
<listitem><para>returns the operating system stream position in terms of
characters. </para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>SIZE</term>
<listitem><para>returns the size, in bytes, of a persistent stream that is the
receiving stream object. For example: </para>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~query("size")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
1305
</programlisting>
</listitem></varlistentry>
<varlistentry><term>STREAMTYPE</term>
<listitem><para>returns a string indicating whether the receiving stream
object is <computeroutput>PERSISTENT</computeroutput>,
<computeroutput>TRANSIENT</computeroutput>, or
<computeroutput>UNKNOWN</computeroutput>.
</para></listitem></varlistentry>
<varlistentry><term>TIMESTAMP</term>
<listitem><para>returns the date and time stamps of the receiving stream object
in an international format. This is the preferred method of getting the date and
time because it provides the full 4-digit year. For example:</para>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~query("timestamp")
</programlisting>
<para>A sample output might be: </para>
<programlisting>
1998-11-12 03:29:12
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>

<section id="strmsay"><title>SAY</title>
<indexterm><primary>SAY method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SAY method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SAY--+----------------+-------------------------------------><
        +-(-+--------+-)-+
            +-string-+
]]>
</programlisting>

<para>Returns <computeroutput>0</computeroutput> if successful in writing
<emphasis role="italic">string</emphasis> to the character output stream
receiving the message or <computeroutput>1</computeroutput> if
an error occurs while writing the line.</para>
</section>

<section id="stseek"><title>SEEK</title>
<indexterm><primary>SEEK method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SEEK method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
         +- = -+                  +-CHAR-+
>>-SEEK(-+-----+-offset-+-------+-+------+-)-------------------><
         +- < -+        +-READ--+ +-LINE-+
         +- + -+        +-WRITE-+
         +- - -+
]]>
</programlisting>

<para>Sets the read or write position to a given number
(<emphasis role="italic">offset</emphasis>) within a persistent stream. If
the stream is open for both reading
and writing and you do not specify READ or WRITE, both the read and write
positions are set. </para>

<note><title>Note</title>
<para>See <link linkend="iostrms">Input and Output Streams</link>
for a discussion
of read and write positions in a persistent stream.</para></note>
<para>To use this method, you must first open the receiving stream object (with
the OPEN method described previously or implicitly with an input or output
operation). One of the following characters can precede the
<emphasis role="italic">offset</emphasis> number:</para>
<variablelist>
<varlistentry><term>=</term>
<listitem><para>Explicitly specifies the
<emphasis role="italic">offset</emphasis> from the beginning of the stream.
This is the default if you supply no prefix. For example, an
<emphasis role="italic">offset</emphasis> of <computeroutput>1</computeroutput>
means the beginning of the stream.
</para></listitem></varlistentry>
<varlistentry><term>&lt;</term>
<listitem><para>Specifies <emphasis role="italic">offset</emphasis>
from the end of the stream.
</para></listitem></varlistentry>
<varlistentry><term>+</term>
<listitem><para>Specifies <emphasis role="italic">offset</emphasis>
forward from the current read or write position.
</para></listitem></varlistentry>
<varlistentry><term>-</term>
<listitem><para>Specifies <emphasis role="italic">offset</emphasis>
backward from the current read or write position.
</para></listitem></varlistentry>
</variablelist>
<para>The SEEK method returns the new position in the stream if the read or
write position is successfully located, or an appropriate error message.</para>
<para>The following is a description of the options for SEEK: </para>
<variablelist>
<varlistentry><term>READ</term>
<listitem><para>specifies that the read position be set.
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>specifies that the write position be set.
</para></listitem></varlistentry>
<varlistentry><term>CHAR</term>
<listitem><para>specifies that positioning be done in terms of characters.
This is the default.
</para></listitem></varlistentry>
<varlistentry><term>LINE</term>
<listitem><para>specifies that the positioning be done in terms of lines. For
non-binary streams, this is potentially an operation that can take a long time
to complete because, in most cases, the file must be scanned from the top to
count the line-end characters. However, for binary streams with a specified
record length, the new resulting line number is simply multiplied by the record
length before character positioning. See
<link linkend="positio">Line versus Character Positioning</link>
for a detailed discussion of this issue. </para>

<note><title>Note</title>
<para>If you do line positioning in a file open only
for writing, you receive an error message.</para></note>
</listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>SEEK method</secondary></indexterm>
<programlisting>
<emphasis role="italic">stream_name</emphasis>~seek("=2 read")
<emphasis role="italic">stream_name</emphasis>~seek("+15 read")
<emphasis role="italic">stream_name</emphasis>~seek("-7 write line")
fromend  = 125
<emphasis role="italic">stream_name</emphasis>~seek("&lt;"fromend read)
</programlisting>
</section>

<section id="statsm"><title>STATE</title>
<indexterm><primary>STATE method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>STATE method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-STATE-------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string that indicates the current state of the specified
stream.</para>
<para>The returned strings are as follows: </para>
<variablelist>
<varlistentry><term>ERROR</term>
<listitem><para>The stream has been subject to an erroneous operation
(possibly during input, output, or through the STREAM function). See
<link linkend="stmerr">Errors during Input and Output</link>.
You might be able to obtain additional information about the error with the
DESCRIPTION method or by calling the STREAM function with a request for the
description.
</para></listitem></varlistentry>
<varlistentry><term>NOTREADY</term>
<listitem><para>The stream is known to be in such a state that the usual input
or output operations attempted upon would raise the NOTREADY condition. (See
<link linkend="stmerr">Errors during Input and Output</link>.)
 For example, a simple input stream can have a defined length. An attempt
to read that stream (with CHARIN or LINEIN, perhaps) beyond that limit can
make the stream unavailable until the stream has been closed (for example,
with LINEOUT(<emphasis role="italic">name</emphasis>)) and then reopened.
</para></listitem></varlistentry>
<varlistentry><term>READY</term>
<listitem><para>The stream is known to be in such a state that the usual input
or output operations might be attempted. This is the usual state for a stream,
although it does not guarantee that any particular operation will succeed.
</para></listitem></varlistentry>
<varlistentry><term>UNKNOWN</term>
<listitem><para>The state of the stream is unknown. This generally means that
the stream is closed or has not yet been opened.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="strmstr"><title>STRING</title>
<indexterm><primary>STRING method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>STRING method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-STRING------------------------------------------------------><
]]>
</programlisting>

<para>Returns a string that indicates the name of the object the stream
represents i.e. the name of the file.
</para>
</section>

<section id="stsup"><title>SUPPLIER</title>
<indexterm><primary>SUPPLIER method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>SUPPLIER method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-SUPPLIER----------------------------------------------------><
]]>
</programlisting>

<para>Returns a supplier object for the stream. When you send appropriate
messages to the supplier object (see
<link linkend="supp">The Supplier Class</link>), it enumerates all the lines
in the stream object. The supplier enumerates the items in their line order.
</para>
</section>

<section id="strmuninit"><title>UNINIT</title>
<indexterm><primary>UNINIT method</primary>
<secondary>of Stream class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>UNINIT method</secondary>
<tertiary>of Stream class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-UNINIT------------------------------------------------------><
]]>
</programlisting>

<para>This method cleans up the object when it is garbage collected. It should
not be invoked directly except via an UNINIT method of a subclass of the Stream
class.
</para>
<para>If the Stream class is subclassed and the subclass provides an UNINIT
method then that method must invoke the superclass UNINIT method.
The following example shows how to accomplish this.</para>
<programlisting>
<![CDATA[
::class CustomStream subclass Stream

...

::method uninit
/* the subclass instance cleanup code should be placed here */
super~uninit  -- this should be the last action in the method
return
]]>
</programlisting>
</section>
</section>

</section>

