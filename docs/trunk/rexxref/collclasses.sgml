<!--#########################################################################
    #
    # Description: Open Object Rexx: Reference SGML file.
    #
    # Copyright (c) 2005-2007, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<section id="CollectionClasses"><title>The Collection Classes</title>
<indexterm><primary>Collection classes</primary></indexterm>
<para>A collection is an object that contains a number of
<emphasis role="italic">items</emphasis>, which can be any objects. Every item
stored in a Rexx collection has an associated index that you can use to
retrieve the item from the collection with the AT or [] methods.</para>
<para>Each collection defines its own acceptable index types. Rexx provides the
following collection classes:</para>

<variablelist>
<varlistentry><term>Array</term>
<listitem><para>A sequenced collection of objects ordered by whole-number
indexes. See <link linkend="clsArray">The Array Class</link> for details.
</para></listitem></varlistentry>
<varlistentry><term>Bag</term>
<listitem><para>A collection where the index and the item are the same object. Bag indexes
can be any object (as with the table class) and each index can appear more
than once. See <link linkend="clsBag">The Bag Class</link> for details.
</para></listitem></varlistentry>
<varlistentry><term>CircularQueue</term>
<listitem><para>
The CircularQueue class allows for storing objects in a circular queue
of a predefined size. Once the end of the queue has been reached, new item
objects are inserted from the beginning, replacing earlier entries.
The collected objects can be processed in FIFO (first in, first out) or in a
stack-like LIFO (last in, first out) order.
See <link linkend="clsCircularQueue">The CircularQueue Class</link> for details
</para></listitem>
</varlistentry>
<varlistentry><term>Directory</term>
<listitem><para>A collection with character string indexes. Index comparisons are performed
using the string == comparison method. See
<link linkend="clsDirectory">The Directory Class</link> for details.
</para></listitem></varlistentry>
<varlistentry><term>List</term>
<listitem><para>A sequenced collection that lets you add new items at any position in
the sequence. A list generates and returns an index value for each item placed
in the list. The returned index remains valid until the item is removed from
the list. See <link linkend="clsList">The List Class</link> for details.
</para></listitem></varlistentry>
<varlistentry><term>Queue</term>
<listitem><para>A sequenced collection with the items ordered as a queue. You can remove
items from the head of the queue and add items at either its tail or its head.
Queues index the items with whole-number indexes, in the order in which the
items would be removed. The current head of the queue has index 1, the item
after the head item has index 2, up to the number of items in the queue. See
<link linkend="clsQueue">The Queue Class</link> for details.
</para></listitem></varlistentry>
<varlistentry><term>Relation</term>
<listitem><para>A collection with indexes that can be any object (as with the table
class). A relation can contain duplicate indexes. See
<link linkend="clsRelation">The Relation Class</link> for details.
</para></listitem></varlistentry>
<varlistentry><term>Set</term>
<listitem><para>A collection where the index and the item are the same object. Set indexes
can be any object (as with the table class) and each index is unique. See
<link linkend="clsSet">The Set Class</link> for details.
</para></listitem></varlistentry>
<varlistentry><term>Table</term>
<listitem><para>A collection with indexes that can be any object. For example, string
objects, array objects, alarm objects, or any user-created object can be a
table index.  The table class determines the index match by using the == comparison
method. A table contains no duplicate indexes. See
<link linkend="clsTable">The Table Class</link> for details.
</para></listitem></varlistentry>
</variablelist>

<section id="CollectionClassOrganization"><title>
Organization of the Collection Classes</title>
<indexterm><primary>Collection class</primary>
<secondary>organization</secondary></indexterm>
<para>The following shows the logical organization of the Collection Classes.
This does NOT represent the order that methods are inherited but rather
the organization of the classes.</para>

<programlisting>
<link linkend="clsCollection">Collection</link>
   <link linkend="clsMapCollection">MapCollection</link>
      <link linkend="clsDirectory">Directory</link>
      <link linkend="clsProperties">Properties</link>
      <link linkend="clsRelation">Relation</link>
      <link linkend="clsStem">Stem</link>
      <link linkend="clsTable">Table</link>
   <link linkend="clsOrderedCollection">OrderedCollection</link>
      <link linkend="clsArray">Array</link>
      <link linkend="clsList">List</link>
      <link linkend="clsQueue">Queue</link>
      <link linkend="clsCircularQueue">CircularQueue</link>
   <link linkend="clsSetCollection">SetCollection</link>
      <link linkend="clsBag">Bag</link>
      <link linkend="clsSet">Set</link>
</programlisting>
</section>

<section id="clsCollection"><title>The Collection Class</title>
<indexterm><primary>Collection class</primary></indexterm>
<figure><title>The Collection Class</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxCollectionsClass.png" align="left">
</imageobject>
</mediaobject>
</figure>

<section id="mthCollectionAtGet"><title>[]</title>
<indexterm><primary>[] method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[] method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
     +-,-----+
     V       |
>>-[---index-+-]-----------------------------------------------><
]]>
</programlisting>

<para>This is an abstract method that must be implemented by a subclass
if this class.</para>
</section>

<section id="mthCollectionPutSet"><title>[]=</title>
<indexterm><primary>[]= method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[]= method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
     +-,-----+
     V       |
>>-[---index-+-]=value-----------------------------------------><
]]>
</programlisting>

<para>This is an abstract method that must be implemented by a subclass
if this class.</para>
</section>

<section id="mthCollectionAllIndexes"><title>allIndexes</title>
<indexterm><primary>allIndexes method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allIndexes method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allIndexes---------------------------------------------------><
]]>
</programlisting>

<para>This is an abstract method which must be implemented by a subclass
of this class.</para>
</section>

<section id="mthCollectionAllItems"><title>allItems</title>
<indexterm><primary>allItems method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allItems method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allItems---------------------------------------------------><
]]>
</programlisting>

<para>This is an abstract method which must be implemented by a subclass
of this class.</para>
</section>

<section id="mthCollectionAt"><title>at</title>
<indexterm><primary>at method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>at method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
       +-,-----+
       V       |
>>-at(---index-+-)---------------------------------------------><
]]>
</programlisting>

<para>Returns the item associated with the specified
<emphasis role="italic">index</emphasis> or
<emphasis role="italic">index</emphasis>es. If the collection has no item associated
with the specified <emphasis role="italic">index</emphasis> or
<emphasis role="italic">index</emphasis>es, this method returns the
Nil object.</para>
</section>

<section id="mthCollectionDifference"><title>difference</title>
<indexterm><primary>difference method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>difference method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-difference(argument)----------------------------------------><
]]>
</programlisting>

<para>Returns a new collection (of the same class as the receiver) containing
only those items from the receiver whose indexes the
<emphasis role="italic">argument</emphasis> collection
does not contain. The <emphasis role="italic">argument</emphasis> can be any
collection class object. The
<emphasis role="italic">argument</emphasis> must also
allow all of the index values in the receiver collection.</para>
</section>

<section id="mthCollectionHasIndex"><title>hasIndex</title>
<indexterm><primary>hasIndex method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasIndex method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
             +-,-----+
             V       |
>>-hasIndex(---index-+-)---------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the array contains
an item associated with the specified index or indexes. Returns
<computeroutput>0</computeroutput> (false) otherwise.</para>
</section>

<section id="mthCollectionHasItem"><title>hasItem</title>
<indexterm><primary>hasItem method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasItem method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasItem(item)----------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the collection contains
the specified item at any index location.  Returns
<computeroutput>0</computeroutput> (false) otherwise.</para>
</section>

<section id="mthCollectionIndex"><title>index</title>
<indexterm><primary>index method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>index method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-index(item)------------------------------------------------><
]]>
</programlisting>

<para>This is an abstract method which must be implemented by a subclass
of this class.</para>
</section>

<section id="mthCollectionIntersection"><title>intersection</title>
<indexterm><primary>intersection method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>intersection method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-intersection(argument)--------------------------------------><
]]>
</programlisting>

<para>Returns a new collection (of the same class as the receiver) containing
only those items from the receiver whose indexes are in both the receiver
collection and the <emphasis role="italic">argument</emphasis> collection.
The <emphasis role="italic">argument</emphasis> can be any
collection class object.
The <emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>

<section id="mthCollectionItems"><title>items</title>
<indexterm><primary>items method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>items method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-items-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of items in the collection.</para>
</section>

<section id="mthCollectionMakeArray"><title>makeArray</title>
<indexterm><primary>makeArray method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>makeArray method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-makeArray---------------------------------------------------><
]]>
</programlisting>

<para>Returns a single-index array with the same number of items as the receiver
object. Any index with no associated item is omitted from the new array.
Items in the new array will have the same order as the source array.
</para>
</section>

<section id="mthCollectionPut"><title>put</title>
<indexterm><primary>put method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>put method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
            +--------+
            V        |
>>-put(item---,index-+-)---------------------------------------><
]]>
</programlisting>

<para>This is an abstract method that must be implemented by a subclass
if this class.</para>
</section>

<section id="mthCollectionSubset"<title>subset</title>
<indexterm><primary>subset method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>subset method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-subset(argument)--------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if all indexes in the
receiver collection are also contained in the
<emphasis role="italic">argument</emphasis> collection; returns
<computeroutput>0</computeroutput> (false) otherwise. The
<emphasis role="italic">argument</emphasis> can be any
collection class object.
The <emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>

<section id="mthCollectionSupplier"><title>supplier</title>
<indexterm><primary>supplier method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>supplier method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
-supplier------------------------------------------------------><
]]>
</programlisting>

<para>Returns a supplier object for the collection. After you have obtained a
supplier, you can send it messages (see
<link linkend="clsSupplier">The Supplier Class</link>) to enumerate
all the items that were in the collection at the time of the supplier's creation.
</para>
</section>

<section id="mthCollectionUnion"<title>union</title>
<indexterm><primary>union method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>union method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-union(argument)---------------------------------------------><
]]>
</programlisting>

<para>Returns a new collection of the same class as the receiver that contains
all the items from the receiver collection and selected items from the
<emphasis role="italic">argument</emphasis> collection. This method includes
an item from <emphasis role="italic">argument</emphasis> in
the new collection only if there is no item with the same associated index
in the receiver collection and the method has not already included an item
with the same index. The order in which this method selects items in
<emphasis role="italic">argument</emphasis> is unspecified (the program
should not rely on any order.). The
<emphasis role="italic">argument</emphasis> can be any
collection class object. The
<emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>

<section id="mthCollectionXor"<title>xor</title>
<indexterm><primary>xor method</primary>
<secondary>of Collection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>xor method</secondary>
<tertiary>of Collection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-xor(argument)-----------------------------------------------><
]]>
</programlisting>

<para>Returns a new collection of the same class as the receiver that contains
all items from the receiver collection and the
<emphasis role="italic">argument</emphasis> collection;
all indexes that appear in both collections are removed. The
<emphasis role="italic">argument</emphasis> can be any
collection class object.
The <emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>
</section>

<section id="clsMapCollection"><title>The MapCollection Class</title>
<indexterm><primary>MapCollection class</primary></indexterm>
<figure><title>The MapCollection class</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxMapCollectionClass.png" align="left">
</imageobject>
</mediaobject>
</figure>

<para>This class is defined as a mixin class.</para>

<section><title>Inherited Methods</title>

&objclsmthods;
&collclsmthods;

</section>

<section id="mthMapCollectionPutAll"<title>putAll</title>
<indexterm><primary>putAll method</primary>
<secondary>of MapCollection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>putAll method</secondary>
<tertiary>of MapCollection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-putAll(collection)---------------------------------------><
]]>
</programlisting>
<para>Adds all items <emphasis role="italic">collection</emphasis> to the target directory.  The
<emphasis role="italic">collection</emphasis> argument can be any object that supports a supplier
method.  Items from <emphasis role="italic">collection</emphasis> are added using the index values returned by the supplier.  The item
indexes from the source <emphasis role="italic">collection</emphasis> must be strings.  The items are
added in the order provided by the supplier object.
If duplicate
indexes exist in <emphasis role="italic">collection</emphasis>, the last item provided by the
supplier will overwrite previous items with the same index.
</para>
</section>

<section id="mthMapCollectionMakeArray"><title>makeArray</title>
<indexterm><primary>makeArray method</primary>
<secondary>of MapCollection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>makeArray method</secondary>
<tertiary>of MapCollection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-makeArray---------------------------------------------------><
]]>
</programlisting>

<para>Returns a single-index array of the index values used by the receiver object.
The index objects will not be ordered in any predictable order.
</para>
</section>
</section>

<section id="clsOrderedCollection"><title>The OrderedCollection Class</title>
<indexterm><primary>OrderedCollection class</primary></indexterm>
<figure><title>The OrderedCollection class</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxOrderedCollectionClass.png" align="left">
</imageobject>
</mediaobject>
</figure>

<para>This class is defined as a mixin class.</para>

<section id="mthOrderedCollectionAppend"><title>append</title>
<indexterm><primary>append method</primary>
<secondary>of OrederedCollection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>append method</secondary>
<tertiary>of OrderedCollection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-append(item)------------------------------------------------><
]]>
</programlisting>

<para>This is an abstract method that must be implemented by a subclass
if this class.</para>
</section>

<section id="mthOrderedCollectionAppendAll"><title>appendAll</title>
<indexterm><primary>appendAll method</primary>
<secondary>of OrderedCollection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>appendAll method</secondary>
<tertiary>of OrderedCollection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-appendAll(collection)---------------------------------------><
]]>
</programlisting>

<para>Appends all items in collection to the end of the target collection. The
<emphasis role="italic">collection</emphasis> may be any object that implements an
<emphasis role="bold">allItems</emphasis> method.</para>
</section>

<section id="mthOrderedCollectionDifference"><title>difference</title>
<indexterm><primary>difference method</primary>
<secondary>of OrderedCollection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>difference method</secondary>
<tertiary>of OrderedCollection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-difference(argument)----------------------------------------><
]]>
</programlisting>

<para>Returns a new collection (of the same class as the receiver) containing
only those items from the receiver whose indexes the
<emphasis role="italic">argument</emphasis> collection
does not contain. The <emphasis role="italic">argument</emphasis> can be any
collection class object. The
<emphasis role="italic">argument</emphasis> must also
allow all of the index values in the receiver collection.</para>
</section>

<section id="mthOrderedCollectionIntersection"><title>intersection</title>
<indexterm><primary>intersection method</primary>
<secondary>of OrderedCollection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>intersection method</secondary>
<tertiary>of OrderedCollection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-intersection(argument)--------------------------------------><
]]>
</programlisting>

<para>Returns a new collection (of the same class as the receiver) containing
only those items from the receiver whose indexes are in both the receiver
collection and the <emphasis role="italic">argument</emphasis> collection.
The <emphasis role="italic">argument</emphasis> can be any
collection class object.
The <emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>

<section id="mthOrderedCollectionSubset"<title>subset</title>
<indexterm><primary>subset method</primary>
<secondary>of OrderedCollection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>subset method</secondary>
<tertiary>of OrderedCollection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-subset(argument)--------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if all indexes in the
receiver collection are also contained in the
<emphasis role="italic">argument</emphasis> collection; returns
<computeroutput>0</computeroutput> (false) otherwise. The
<emphasis role="italic">argument</emphasis> can be any
collection class object.
The <emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>

<section id="mthOrderedCollectionUnion"<title>union</title>
<indexterm><primary>union method</primary>
<secondary>of OrderedCollection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>union method</secondary>
<tertiary>of OrderedCollection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-union(argument)---------------------------------------------><
]]>
</programlisting>

<para>Returns a new collection of the same class as the receiver that contains
all the items from the receiver collection and selected items from the
<emphasis role="italic">argument</emphasis> collection. This method includes
an item from <emphasis role="italic">argument</emphasis> in
the new collection only if there is no item with the same associated index
in the receiver collection and the method has not already included an item
with the same index. The order in which this method selects items in
<emphasis role="italic">argument</emphasis> is unspecified (the program
should not rely on any order.). The
<emphasis role="italic">argument</emphasis> can be any
collection class object. The
<emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>

<section id="mthOrderedCollectionXor"<title>xor</title>
<indexterm><primary>xor method</primary>
<secondary>of OrderedCollection class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>xor method</secondary>
<tertiary>of OrderedCollection class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-xor(argument)-----------------------------------------------><
]]>
</programlisting>

<para>Returns a new collection of the same class as the receiver that contains
all items from the receiver collection and the
<emphasis role="italic">argument</emphasis> collection;
all indexes that appear in both collections are removed. The
<emphasis role="italic">argument</emphasis> can be any
collection class object.
The <emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>
</section>

<section id="clsSetCollection"><title>The SetCollection Class</title>
<indexterm><primary>SetCollection class</primary></indexterm>
<para>This is a tagging mixin class only and does not define any methods of
its own.</para>
<figure><title>The SetCollection class</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxSetCollectionClass.png" align="left">
</imageobject>
</mediaobject>
</figure>

<para>This class is defined as a mixin class.</para>

<section><title>Inherited Methods</title>

&objclsmthods;
&collclsmthods;

</section>
</section>

<section id="clsArray"><title>The Array Class</title>
<indexterm><primary>Array class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Array class</secondary></indexterm>
<indexterm><primary>Ordered collection classes</primary>
<secondary>Array class</secondary></indexterm>

<para> An array is a possibly sparse collection with indexes
that are positive whole numbers. You can reference array items by using one
or more indexes. The number of indexes is the same as the number of dimensions
of the array. This number is called the dimensionality of the array.</para>
<figure><title>The Array class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxArrayClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Array class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.
It also inherits methods from the <link linkend="clsOrderedCollection">Ordered Collection
class</link>, although there are not currently any methods defined in that class.
</para></note>
<para>Array objects are variable-sized. The dimensionality of an array is fixed,
but the size of each dimension is variable. When you create an array, you
can specify a hint about how many elements you expect to put into the array
or the array's dimensionality. However, you do not need to specify a size
or dimensionality of an array when you are creating it. You can use any
whole-number indexes to reference items in an array.</para>

<section><title>Inherited Methods</title>

&objclsmthods;
&collclsmthods;
&ocollclsmthods;

</section>

<section id="mthArrayNew"><title>new (Class Method)</title>
<indexterm><primary>new method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new-+----------------+--------------------------------------><
       |    +-,----+    |
       |    V      |    |
       +-(----size-+--)-+
]]>
</programlisting>

<para> Returns a new empty array. If you specify
any <emphasis role="italic">size</emphasis>,
the size is taken as a hint about how big each dimension
should be. The language processor uses this only to allocate the array object
initially. For multiple dimension arrays, you can also specify how much space
is to be allocated initially for each dimension of the array.</para>
<para>Each <emphasis role="italic">size</emphasis> argument must be
<computeroutput>0</computeroutput> or a positive whole number.
If it is <computeroutput>0</computeroutput>, the corresponding dimension is
initially empty.</para>
</section>

<section id="mthArrayOf"><title>of (Class Method)</title>
<indexterm><primary>of method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>of method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-of-+----------------+---------------------------------------><
      |    +-,----+    |
      |    V      |    |
      +-(----item-+--)-+
]]>
</programlisting>

<para>Returns a newly created
single-index array containing the specified
<emphasis role="italic">item</emphasis> objects. The first
<emphasis role="italic">item</emphasis> has index 1, the second has index 2,
and so on.</para>
<para>If you use the OF method and omit any argument items, the returned array
does not include the indexes corresponding to those you omitted.</para>
</section>

<section id="mthArrayAtGet"><title>[]</title>
<indexterm><primary>[] method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[] method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
     +-,-----+
     V       |
>>-[---index-+-]-----------------------------------------------><
]]>
</programlisting>

<para>Returns the same value as the
<emphasis role="bold">at</emphasis> method, which follows. See
<link linkend="mthArrayAt">at</link>.</para>
</section>

<section id="mthArrayPutSet"><title>[]=</title>
<indexterm><primary>[]= method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[]= method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
     +-,-----+
     V       |
>>-[---index-+-]=value-----------------------------------------><
]]>
</programlisting>

<para>This method is the same as the
<emphasis role="bold">put</emphasis> method, which follows. See
<link linkend="mthArrayPut">put</link>.</para>
</section>

<section id="mthArrayAllIndexes"><title>allIndexes</title>
<indexterm><primary>allIndexes method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allIndexes method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allIndexes---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all index positions in the array containing items.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>wordPos method</secondary></indexterm>
<programlisting>
   a = .array~of("Fred", "Mike", "David")

   do name over a~allIndexes
      say name  -- displays "1", "2", and "3"
   end

   a~remove(2)  -- remove second item

   do name over a~allIndexes
      say name  -- displays "1" and "3"
   end
</programlisting>
</section>

<section id="mthArrayAllItems"><title>allItems</title>
<indexterm><primary>allItems method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allItems method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allItems---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all items contained in the array.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>wordPos method</secondary></indexterm>
<programlisting>
   a = .array~of("Fred", "Mike", "David")

   do name over a~allItems
      say name  -- displays "Fred", "Mike", and "David"
   end

   a~remove(2)  -- remove second item

   do name over a~allItems
      say name  -- displays "Fred" and "David"
   end
</programlisting>
</section>

<section id="mthArrayAppend"><title>append</title>
<indexterm><primary>append method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>append method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-append(item)------------------------------------------------><
]]>
</programlisting>

<para>Appends an item to the array after the last item (the item with the highest index.  The
return value is the index of newly added item.
</para>
</section>

<section id="mthArrayAt"><title>at</title>
<indexterm><primary>at method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>at method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
       +-,-----+
       V       |
>>-at(---index-+-)---------------------------------------------><
]]>
</programlisting>

<para>Returns the item associated with the specified
<emphasis role="italic">index</emphasis> or
<emphasis role="italic">index</emphasis>es. If the array has no item associated
with the specified <emphasis role="italic">index</emphasis> or
<emphasis role="italic">index</emphasis>es, this method returns the
Nil object.</para>
</section>

<section id="mthArrayDimension"><title>dimension</title>
<indexterm><primary>dimension method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>dimension method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-dimension-+-----+-------------------------------------------><
             +-(n)-+
]]>
</programlisting>

<para>Returns the current size (upper bound) of dimension
<emphasis role="italic">n</emphasis> (a positive
whole number). If you omit <emphasis role="italic">n</emphasis>,
this method returns the dimensionality
(number of dimensions) of the array. If the number of dimensions has not been
determined, <emphasis role="bold">dimension</emphasis>
returns <computeroutput>0</computeroutput>.</para>
</section>

<section id="mthArrayEmpty"><title>empty</title>
<indexterm><primary>empty method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>empty method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-empty-------------------------------------------------------><
]]>
</programlisting>

<para>Removes all items from the array.</para>
</section>

<section id="mthArrayFirst"><title>first</title>
<indexterm><primary>first method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>first method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-first-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the first item in the array or the Nil object if the
array is empty. The <emphasis role="bold">first</emphasis>
method is valid only for single-index arrays.</para>
</section>

<section id="mthArrayHasIndex"><title>hasIndex</title>
<indexterm><primary>hasIndex method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasIndex method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
             +-,-----+
             V       |
>>-hasIndex(---index-+-)---------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the array contains
an item associated with the specified index or indexes. Returns
<computeroutput>0</computeroutput> (false) otherwise.</para>
</section>

<section id="mthArrayHasItem"><title>hasItem</title>
<indexterm><primary>hasItem method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasItem method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasItem(item)----------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the array contains
the specified item at any index location.  Returns
<computeroutput>0</computeroutput> (false) otherwise.</para>
</section>

<section id="mthArrayIndex"><title>index</title>
<indexterm><primary>index method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>index method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-index(item)------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the specified item within the array.  If the
target item appears at more than one index, the first located index will
be returned.  If the array does not contain the specified item, .nil is
returned.
</para>
</section>

<section id="mthArrayIsEmpty"><title>isEmpty</title>
<indexterm><primary>isEmpty method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isEmpty method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isEmpty----------------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the array is
empty.  Returns
<computeroutput>0</computeroutput> (false) otherwise.</para>
</section>

<section id="mthArrayItems"><title>items</title>
<indexterm><primary>items method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>items method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-items-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of items in the collection.</para>
</section>

<section id="mthArrayLast"><title>last</title>
<indexterm><primary>last method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>last method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-last--------------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the last item in the array or the NIL object if the
array is empty. The <emphasis role="bold">last</emphasis>
method is valid only for single-index arrays.</para>
</section>

<section id="mthArrayMakeArray"><title>makeArray</title>
<indexterm><primary>makeArray method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>makeArray method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-makeArray---------------------------------------------------><
]]>
</programlisting>

<para>Returns a single-index array with the same number of items as the receiver
object. Any index with no associated item is omitted from the new array.
Items in the new array will have the same order as the source array.
</para>
</section>

<section id="mthArrayMakeString"><title>makeString</title>
<indexterm><primary>makeString method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>makeString method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
                         +-,separator-+
               +-(LINE)--+------------+-+
>>-makeString(-+---------+--------------+-)------------------------><
               +-(CHAR)--+
]]>
</programlisting>

<para>Returns a string that contains the data of an array (one to n dimensional).
The elements of the array are treated either in line or character format,
starting at the first element in the array. The line format is the default.
If the line format is use, a <emphasis role="italic">separator</emphasis> string
can be specified.  The separator will be used between concatenated elements instead of the
default linend separator.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<para>See <link linkend="mthArrayToString">toString</link> for examples.</para>
</section>

<section id="mthArrayNext"><title>next</title>
<indexterm><primary>next method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>next method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-next(index)-------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the item that
follows the array item having index <emphasis role="italic">index</emphasis>
or returns the Nil object if the item having that index is last in the array.
The <emphasis role="bold">next</emphasis>
method is valid only for single-index arrays.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>next method</secondary></indexterm>
<programlisting>
   a = .array~of("Fred",, "Mike",, "David")
   say a~next(3)  -- says: 5
</programlisting>
</section>

<section id="mthArrayPrevious"><title>previous</title>
<indexterm><primary>previous method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>previous method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-previous(index)---------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the item that precedes the array item having index
<emphasis role="italic">index</emphasis> or the Nil object if the
item having that index is first in the
array. The <emphasis role="bold">previous</emphasis>
method is valid only for single-index arrays.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>previous method</secondary></indexterm>
<programlisting>
   a = .array~of("Fred",, "Mike",, "David")
   say a~previous(3)  -- says: 1
</programlisting>
</section>

<section id="mthArrayPut"><title>put</title>
<indexterm><primary>put method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>put method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
            +--------+
            V        |
>>-put(item---,index-+-)---------------------------------------><
]]>
</programlisting>

<para>Makes the object <emphasis role="italic">item</emphasis>
a member item of the array and associates it with the specified
<emphasis role="italic">index</emphasis> or
<emphasis role="italic">index</emphasis>es. This replaces any
existing item associated with the specified
<emphasis role="italic">index</emphasis> or
<emphasis role="italic">index</emphasis>es
with the new item. If the <emphasis role="italic">index</emphasis> for a
particular dimension is greater than the current size of
that dimension, the array is expanded to the new dimension size.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>put method</secondary></indexterm>
<programlisting>
   a = .array~new
   a~put(1, "Fred")  -- a = .array~of("Fred")
   a~put(2, "Mike")  -- a = .array~of("Fred", "Mike")
   a~put(1, "Mike")  -- a = .array~of("Mike", "Mike")
</programlisting>
</section>

<section id="mthArrayRemove"><title>remove</title>
<indexterm><primary>remove method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>remove method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
           +-,-----+
           V       |
>>-remove(---index-+-)-----------------------------------------><
]]>
</programlisting>

<para>Returns and removes the member item with the specified
<emphasis role="italic">index</emphasis> or
<emphasis role="italic">index</emphasis>es from the array. If there is no
item with the specified <emphasis role="italic">index</emphasis> or
<emphasis role="italic">index</emphasis>es, the Nil object is returned and
no item is removed.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>remove method</secondary></indexterm>
<programlisting>
   a = .array~of("Fred", "Mike", "Mike", "David")
   a~removeItem(2)  -- removes "Mike"
</programlisting>
</section>

<section id="mthArrayRemoveItem"><title>removeItem</title>
<indexterm><primary>removeItem method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>removeItem method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-removeItem(item)--------------------------------------------><
]]>
</programlisting>

<para>Removes an item from the array.  If the target item exists at more than
one index, the first located item is removed.  The return value is the
removed item.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>removeItem method</secondary></indexterm>
<programlisting>
   a = .array~of("Fred", "Mike", "Mike", "David")
   a~removeItem("Mike")  -- removes the item at index "2"
</programlisting>
</section>

<section id="mthArraySection"><title>section</title>
<indexterm><primary>section method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>section method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-section(start-+--------+-)----------------------------------><
                 +-,items-+
]]>
</programlisting>

<para>Returns a new array (of the same class as the receiver) containing selected
items from the receiver array. The first item in the new array is the item
corresponding to index <emphasis role="italic">start</emphasis>
in the receiver array. Subsequent items in the new array correspond to those
in the receiver array (in the same sequence). If you specify the whole number
<emphasis role="italic">items</emphasis>, the new array contains only
this number of items (or the number of subsequent items in the receiver array,
if this is less than <emphasis role="italic">items</emphasis>).
If you do not specify <emphasis role="italic">items</emphasis>,
the new array contains all subsequent items of the receiver array. The receiver
array remains unchanged. The <emphasis role="bold">section</emphasis>
method is valid only for single-index arrays.</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>section method</secondary></indexterm>
<programlisting>
   a = .array~of(1,2,3,4)  -- Loads the array

   b = a~section(2)   -- b = .array~of(2,3,4)
   c = a~section(2,2) -- c = .array~of(2,3)
   d = a~section(2,0) -- d = .array~new
</programlisting>
</section>

<section id="mthArraySize"><title>size</title>
<indexterm><primary>size method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>size method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-size--------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of items that can be placed in the array before it needs
to be extended. This value is the same as the product of the sizes of the
dimensions in the array.</para>
</section>

<section id="mthArraySort"><title>sort</title>
<indexterm><primary>sort method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sort method</secondary>
<tertiary>of Array class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-sort--------------------------------------------------------><
]]>
</programlisting>

<para>Sorts an array of Comparable items into ascending order using an unstable Quicksort algorithm.
See <link linkend="sortarray">Sorting Arrays</link> for details.
</para>
</section>

<section id="mthArraySortWith"<title>sortWith</title>
<indexterm><primary>sortWith method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sortWith method</secondary>
<tertiary>of Array class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-sortWith(comparator)---------------------------------------------><
]]>
</programlisting>

<para>Sorts an array of items into ascending order using an unstable Quicksort algorithm.
Ordering of elements is determined using the <emphasis role="italic">comparator</emphasis> argument.
See <link linkend="sortarray">Sorting Arrays</link> for details.
</para>
</section>

<section id="mthArrayStableSort"><title>stableSort</title>
<indexterm><primary>stableSort method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>stableSort method</secondary>
<tertiary>of Array class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-stableSort--------------------------------------------------------><
]]>
</programlisting>

<para>Sorts an array of Comparable items into ascending order using a stable Mergesort algorithm.
See <link linkend="sortarray">Sorting Arrays</link> for details.
</para>
</section>

<section id="mthArrayStableSortWith"<title>stableSortWith</title>
<indexterm><primary>stableSortWith method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>stableSortWith method</secondary>
<tertiary>of Array class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-stableSortWith(comparator)---------------------------------------------><
]]>
</programlisting>

<para>Sorts an array of items into ascending order using a stable Mergesort algorithm.
Ordering of elements is determined using the <emphasis role="italic">comparator</emphasis> argument.
See <link linkend="sortarray">Sorting Arrays</link> for details.
</para>
</section>

<section id="mthArraySupplier"><title>supplier</title>
<indexterm><primary>supplier method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>supplier method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
-supplier------------------------------------------------------><
]]>
</programlisting>

<para>Returns a supplier object for the collection. After you have obtained a
supplier, you can send it messages (see
<link linkend="clsSupplier">The Supplier Class</link>) to enumerate
all the items that were in the array at the time of the supplier's creation.
The supplier enumerates the array items in their sequenced order.
For multi-dimensional arrays, the supplier index method will return the
index values as an array of index numbers.
</para>
</section>

<section id="mthArrayToString"<title>toString</title>
<indexterm><primary>toString method</primary>
<secondary>of Array class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>toString method</secondary>
<tertiary>of Array class</tertiary></indexterm>
<programlisting>
<![CDATA[
                       +-,separator-+
             +-(LINE)--+------------+-+
>>-toString(-+---------+--------------+-)------------------------><
             +-(CHAR)--+
]]>
</programlisting>

<para>Returns a string that contains the data of an array (one to n dimensional).
The elements of the array are treated either in line or character format,
starting at the first element in the array. The line format is the default.
If the line format is use, a <emphasis role="italic">separator</emphasis> string
can be specified.  The separator will be used between concatenated elements instead of the
default linend separator.
</para>
<para><emphasis role="bold">Examples:</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>toString method</secondary></indexterm>
<programlisting>
   a = .array~of(1,2,3,4)  -- Loads the array

   say a~toString  -- Produces: 1
                   --           2
                   --           3
                   --           4

   say a~toString("c")  -- Produces: 1234

   say a~toString(, ", ")  -- Produces: 1, 2, 3, 4
</programlisting>
</section>

<section id="arex"><title>Examples</title>
<indexterm><primary>examples</primary>
<secondary>of Array class</secondary></indexterm>
<programlisting>
array1=.array~of(1,2,3,4)  /* Loads the array */

/* Alternative way to create and load an array */
array2=.array~new(4)  /* Creates array2, containing 4 items */
do i=1 to 4                   /* Loads the array */
  array2[i]=i
end
</programlisting>
<para>You can produce the elements loaded into an array, for example: </para>
<programlisting>
do i=1 to 4
  say array1[i]
end
</programlisting>
<para>If you omit any argument values before arguments you supply, the corresponding
indexes are skipped in the returned array: </para>
<programlisting>
directions=.array~of("North","South", ,"West")
do i=1 to 4                                  /* Produces: North          */
  say directions[i]                          /*           South          */
                                             /*           The NIL object */
end                                          /*           West           */
</programlisting>

<para>Here is an example using the ~~: </para>
<programlisting>
z=.array~of(1,2,3)~~put(4,4)
do i = 1 to z~size
  say z[i]              /* Produces:  1 2 3 4 */
end
</programlisting>
</section>
</section>

<section id="clsBag"><title>The Bag Class</title>
<indexterm><primary>Bag class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Bag class</secondary></indexterm>
<indexterm><primary>Set Collection classes</primary>
<secondary>Bag class</secondary></indexterm>

<para>A bag is a collection that restricts the elements
to having an item that is the same as the index. Any object can be placed
in a bag, and the same object can be placed in a bag several times.</para>
<figure><title>The Bag class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxBagClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Bag class also has available class methods that its metaclass,
the <link linkend="clsClass">Class class</link>, defines.
It also inherits methods from the <link linkend="clsSetCollection">Set Collection
class</link>, although there are not currently any methods defined in that class.
</para></note>
<para>The Bag class is a subclass of the Relation class. In addition to its own
methods, it inherits the methods of the Object class and the Relation class.</para>

<section><title>Inherited Methods</title>

&objclsmthods;
&collclsmthods;
&mcollclsmthods;

<para>Methods inherited from the
<link linkend="clsRelation">Relation class</link>.</para>
<simplelist type="vert" columns="3">
<member><link linkend="mthRelationNew">new (class method)</link></member>
<member><link linkend="mthRelationAllAt">allAt</link></member>
<member><link linkend="mthRelationAllIndex">allIndex</link></member>
<member><link linkend="mthRelationAllIndexes">allIndexes</link></member>
<member><link linkend="mthRelationAllItems">allItems</link></member>
<member><link linkend="mthRelationAt">at</link></member>
<member><link linkend="mthRelationAtGet">[ ]</link></member>
<member><link linkend="mthRelationDifference">difference</link></member>
<member><link linkend="mthRelationEmpty">empty</link></member>
<member><link linkend="mthRelationHasIndex">hasIndex</link></member>
<member><link linkend="mthRelationHasItem">hasItem</link></member>
<member><link linkend="mthRelationIndex">index</link></member>
<member><link linkend="mthRelationIntersection">intersection</link></member>
<member><link linkend="mthRelationIsEmpty">isEmpty</link></member>
<member><link linkend="mthRelationItems">items</link></member>
<member><link linkend="mthRelationMakeArray">makeArray</link></member>
<member><link linkend="mthRelationPut">put</link></member>
<member><link linkend="mthRelationPutSet">[ ]=</link></member>
<member><link linkend="mthRelationRemove">remove</link></member>
<member><link linkend="mthRelationRemoveItem">removeItem</link></member>
<member><link linkend="mthRelationSubset">subset</link></member>
<member><link linkend="mthRelationSupplier">supplier</link></member>
<member><link linkend="mthRelationUnion">union</link></member>
<member><link linkend="mthRelationXor">xor</link></member>
</simplelist>

</section>

<section id="mthBagPutSet"><title>[]=</title>
<indexterm><primary>[]= method</primary>
<secondary>of Bag class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[]= method</secondary>
<tertiary>of Bag class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-[index]=item------------------------------------------------><
]]>
</programlisting>

<para>This method is the same as the
<emphasis role="bold">put</emphasis> method. See
<link linkend="mthBagPut">put</link>.</para>
</section>

<section id="mthBagOf"><title>of (Class Method)</title>
<indexterm><primary>of method</primary>
<secondary>of Bag class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>of method</secondary>
<tertiary>of Bag class</tertiary></indexterm>
<programlisting>
<![CDATA[
       +-,----+
       V      |
>>-of(---item-+-)----------------------------------------------><
]]>
</programlisting>

<para>Returns a newly created bag containing the specified
<emphasis role="italic">item</emphasis> objects.</para>
</section>

<section id="mthBagDifference"<title>difference</title>
<indexterm><primary>difference method</primary>
<secondary>of Bag class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>difference method</secondary>
<tertiary>of Bag class</tertiary></indexterm>

<para>This method overrides the
<link linkend="mthRelationDifference">difference method</link> from the
<link linkend="clsRelation">Relation class</link>.</para>
<programlisting>
<![CDATA[
>>-difference(argument)----------------------------------------><
]]>
</programlisting>

<para>Returns a new collection (of the same class as the receiver) containing
only those items from the receiver whose indexes the
<emphasis role="italic">argument</emphasis> collection
does not contain. The <emphasis role="italic">argument</emphasis> can be any
collection class object. The
<emphasis role="italic">argument</emphasis> must also
allow all of the index values in the receiver collection.</para>
</section>

<section id="mthBagHasIndex"><title>hasIndex</title>
<indexterm><primary>hasIndex method</primary>
<secondary>of Bag class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasIndex method</secondary>
<tertiary>of Bag class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasIndex(index)---------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the collection
contains any item associated with index <emphasis role="italic">index</emphasis>,
or <computeroutput>0</computeroutput> (false).</para>
</section>

<section id="mthBagIntersection"<title>intersection</title>
<indexterm><primary>intersection method</primary>
<secondary>of Bag class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>intersection method</secondary>
<tertiary>of Bag class</tertiary></indexterm>

<para>This method overrides the
<link linkend="mthRelationIntersection">intersection method</link> from the
<link linkend="clsRelation">Relation class</link>.</para>
<programlisting>
<![CDATA[
>>-intersection(argument)--------------------------------------><
]]>
</programlisting>

<para>Returns a new collection (of the same class as the receiver) containing
only those items from the receiver whose indexes are in both the receiver
collection and the <emphasis role="italic">argument</emphasis> collection.
The <emphasis role="italic">argument</emphasis> can be any
collection class object.
The <emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>

<section id="mthBagPut"><title>put</title>
<indexterm><primary>put method</primary>
<secondary>of Bag class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>put method</secondary>
<tertiary>of Bag class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-put(item,index)---------------------------------------------><
]]>
</programlisting>

<para>Makes the object <emphasis role="italic">item</emphasis>
a member item of the bag and associates it with index
<emphasis role="italic">index</emphasis>. If the relation already contains
any items with index
<emphasis role="italic">index</emphasis>, this method adds a new member item
<emphasis role="italic">item</emphasis> with
the same index, without removing any existing member items.</para>
</section>

<section id="mthBagPutAll"<title>putAll</title>
<indexterm><primary>putAll method</primary>
<secondary>of Bag class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>putAll method</secondary>
<tertiary>of Bag class</tertiary></indexterm>

<para>This method overrides the
<link linkend="mthMapCollectionPutAll">putAll method</link> from the
<link linkend="clsMapCollection">Map Collection class</link>.</para>
<programlisting>
<![CDATA[
>>-putAll(collection)---------------------------------------><
]]>
</programlisting>
<para>Adds all items <emphasis role="italic">collection</emphasis> to the target bag.  The
<emphasis role="italic">collection</emphasis> argument can be any object that supports a supplier
method.  Items from <emphasis role="italic">collection</emphasis> are added using the index values
returned by the supplier.
</para>
</section>

<section id="mthBagSubset"<title>subset</title>
<indexterm><primary>subset method</primary>
<secondary>of Bag class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>subset method</secondary>
<tertiary>of Bag class</tertiary></indexterm>

<para>This method overrides the
<link linkend="mthRelationSubset">subset method</link> from the
<link linkend="clsRelation">Relation class</link>.</para>
<programlisting>
<![CDATA[
>>-subset(argument)--------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if all indexes in the
receiver collection are also contained in the
<emphasis role="italic">argument</emphasis> collection; returns
<computeroutput>0</computeroutput> (false) otherwise. The
<emphasis role="italic">argument</emphasis> can be any
collection class object.
The <emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>

<section id="mthBagUnion"<title>union</title>
<indexterm><primary>union method</primary>
<secondary>of Bag class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>union method</secondary>
<tertiary>of Bag class</tertiary></indexterm>

<para>This method overrides the
<link linkend="mthRelationUnion">union method</link> from the
<link linkend="clsRelation">Relation class</link>.</para>
<programlisting>
<![CDATA[
>>-union(argument)---------------------------------------------><
]]>
</programlisting>

<para>Returns a new collection of the same class as the receiver that contains
all the items from the receiver collection and selected items from the
<emphasis role="italic">argument</emphasis> collection. This method includes
an item from <emphasis role="italic">argument</emphasis> in
the new collection only if there is no item with the same associated index
in the receiver collection and the method has not already included an item
with the same index. The order in which this method selects items in
<emphasis role="italic">argument</emphasis> is unspecified. (The program
should not rely on any order.) See also the
<emphasis role="bold">union</emphasis> method of the Collection
(<link linkend="mthCollectionUnion">union</link>) and Relation
(<link linkend="mthRelationUnion">union</link>) classes. The
<emphasis role="italic">argument</emphasis> can be any
collection class object. The
<emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>

<section id="mthBagXor"<title>xor</title>
<indexterm><primary>xor method</primary>
<secondary>of Bag class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>xor method</secondary>
<tertiary>of Bag class</tertiary></indexterm>

<para>This method overrides the
<link linkend="mthRelationXor">xor method</link> from the
<link linkend="clsRelation">Relation class</link>.</para>
<programlisting>
<![CDATA[
>>-xor(argument)-----------------------------------------------><
]]>
</programlisting>

<para>Returns a new collection of the same class as the receiver that contains
all items from the receiver collection and the
<emphasis role="italic">argument</emphasis> collection;
all indexes that appear in both collections are removed. The
<emphasis role="italic">argument</emphasis> can be any
collection class object.
The <emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>

<section id="bagex"><title>Examples</title>
<indexterm><primary>examples</primary>
<secondary>of Bag class</secondary></indexterm>
<programlisting>
/* Create a bag of fruit */
fruit = .bag~of("Apple", "Orange", "Apple", "Pear")
say fruit~items          /* How many pieces? (4)      */
say fruit~items("Apple") /* How many apples? (2)      */
fruit~remove("Apple")    /* Remove one of the apples. */
fruit~~put("Banana")~put("Orange") /* Add a couple.   */
say fruit~items          /* How many pieces? (5)      */
</programlisting>
</section>
</section>

<section id="clsCircularQueue"><title>The CircularQueue Class</title>
<indexterm><primary>class</primary>
<secondary>CircularQueue class</secondary></indexterm>
<indexterm><primary>CircularQueue class</primary></indexterm>
<indexterm><primary>Ordered collection classes</primary>
<secondary>CircularQueue class</secondary></indexterm>

<para>
The CircularQueue class allows for storing objects in a circular queue
of a predefined size. Once the end of the queue has been reached, new item
objects are inserted from the beginning, replacing earlier entries.
</para>
<figure><title>The CircularQueue class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxCircularQueueClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>
The CircularQueue class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.</para>
</note>
<para>
The collected objects can be processed in FIFO (first in, first out) or in a
stack-like LIFO (last in, first out) order.
</para>

<section><title>Inherited Methods</title>

&objclsmthods;
&collclsmthods;
&ocollclsmthods;

<para>Methods inherited from the
<link linkend="clsQueue">Queue class</link>.</para>
<simplelist type="vert" columns="3">
<member><link linkend="mthQueueNew">new (class method)</link></member>
<member><link linkend="mthQueueOf">of (class method)</link></member>
<member><link linkend="mthQueueAllIndexes">allIndexes</link></member>
<member><link linkend="mthQueueAllItems">allItems</link></member>
<member><link linkend="mthQueueAppend">append</link></member>
<member><link linkend="mthQueueAt">at</link></member>
<member><link linkend="mthQueueAtGet">[ ]</link></member>
<member><link linkend="mthQueueEmpty">empty</link></member>
<member><link linkend="mthQueueFirst">first</link></member>
<member><link linkend="mthQueueHasIndex">hasIndex</link></member>
<member><link linkend="mthQueueHasItem">hasItem</link></member>
<member><link linkend="mthQueueIndex">index</link></member>
<member><link linkend="mthQueueInsert">insert</link></member>
<member><link linkend="mthQueueIsEmpty">isEmpty</link></member>
<member><link linkend="mthQueueItems">items</link></member>
<member><link linkend="mthQueueLast">last</link></member>
<member><link linkend="mthQueueMakeArray">makeArray</link></member>
<member><link linkend="mthQueueNext">next</link></member>
<member><link linkend="mthQueuePeek">peek</link></member>
<member><link linkend="mthQueuePrevious">previous</link></member>
<member><link linkend="mthQueuePull">pull</link></member>
<member><link linkend="mthQueuePush">push</link></member>
<member><link linkend="mthQueuePut">put</link></member>
<member><link linkend="mthQueuePutSet">[ ]=</link></member>
<member><link linkend="mthQueueQueue">queue</link></member>
<member><link linkend="mthQueueRemove">remove</link></member>
<member><link linkend="mthQueueRemoveItem">removeItem</link></member>
<member><link linkend="mthQueueSupplier">supplier</link></member>
</simplelist>

</section>

<section id="mthCircularQueueOf"><title>of (Class Method)</title>
<indexterm><primary>of method</primary>
<secondary>of CircularQueue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>of method</secondary>
<tertiary>of CircularQueue class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-of-+----------------+---------------------------------------><
      |    +-,----+    |
      |    V      |    |
      +-(----item-+--)-+
]]>
</programlisting>


<para>This method overrides the
<link linkend="mthQueueOf">of method</link> from the
<link linkend="clsQueue">Queue class</link>.</para>
<para>
Returns a newly created circular queue containing the specified
<emphasis role="italic">item</emphasis> objects. The first
<emphasis role="italic">item</emphasis> has index 1, the second has index 2,
and so on. The number of <emphasis role="italic">item</emphasis> objects
determines the <emphasis role="italic">size</emphasis> of the circular queue.
</para>
</section>

<section id="mthCircularQueueInit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of CircularQueue class</secondary>
</indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of CircularQueue class</tertiary>
</indexterm>

<programlisting>
<![CDATA[
>>-init--------------------------------------------------------><
]]>
</programlisting>

<para>
Performs initialization of the circular queue.
</para>
</section>

<section id="mthCircularQueueMakeArray"><title>makeArray</title>
<indexterm><primary>makeArray method</primary>
<secondary>of CircularQueue class</secondary>
</indexterm>
<indexterm><primary>method</primary>
<secondary>makeArray method</secondary>
<tertiary>of CircularQueue class</tertiary>
</indexterm>

<programlisting>
<![CDATA[
              +-Fifo----+
>>-makeArray(-+---------+-)------------------------------------><
              +--order--+
]]>
</programlisting>

<para>This method overrides the
<link linkend="mthQueueMakeArray">makeArray method</link> from the
<link linkend="clsQueue">Queue class</link>.</para>
<para>
Returns a single-index array containing the items of the circular queue in the
specified <emphasis role="italic">order</emphasis>.
</para>

<para>
The following <emphasis role="italic">order</emphasis> can be used. (Only
the capitalized letter is needed; all characters following it are ignored.)
</para>

<variablelist>
<varlistentry><term>Fifo</term>
<listitem>
<para>First-in, first-out, default
</para>
</listitem>
</varlistentry>
<varlistentry><term>Lifo</term>
<listitem>
<para>Last-in, first-out (stacklike)
</para>
</listitem>
</varlistentry>
</variablelist>
</section>

<section id="mthCircularQueuePush"><title>push</title>
<indexterm><primary>push method</primary>
<secondary>of CircularQueue class</secondary>
</indexterm>
<indexterm><primary>method</primary>
<secondary>push method</secondary>
<tertiary>of CircularQueue class</tertiary>
</indexterm>

<programlisting>
<![CDATA[
>>-push(item)--------------------------------------------------><
]]>
</programlisting>

<para>This method overrides the
<link linkend="mthQueuePush">push method</link> from the
<link linkend="clsQueue">Queue class</link>.</para>
<para>
Makes the object <emphasis role="italic">item</emphasis> a member item of
the circular queue, inserting the item object in front of the first item in
the queue. The pushed item object will be the new first item in the circular queue.
</para>

<para>
If the circular queue is full, than the last item stored in the circular queue
will be deleted, before the insertion takes place. In this case the
<emphasis role="italic">deleted item</emphasis> will be returned, otherwise
<emphasis role="italic">.nil</emphasis>.
</para>
</section>


<section id="mthCircularQueueQueue"><title>queue</title>
<indexterm><primary>queue method</primary>
<secondary>of CircularQueue class</secondary>
</indexterm>
<indexterm><primary>method</primary>
<secondary>queue method</secondary>
<tertiary>of CircularQueue class</tertiary>
</indexterm>

<programlisting>
<![CDATA[
>>-queue(item)-------------------------------------------------><
]]>
</programlisting>

<para>This method overrides the
<link linkend="mthQueueQueue">queue method</link> from the
<link linkend="clsQueue">Queue class</link>.</para>
<para>
Makes the object <emphasis role="italic">item</emphasis> a member item of the circular queue, inserting the item
at the end of the circular queue.
</para>

<para>
If the circular queue is full, than the first item will be deleted, before the
insertion takes place.  In this case the <emphasis role="italic">deleted item</emphasis>
will be returned, otherwise <emphasis role="italic">.nil</emphasis>.
</para>
</section>

<section id="mthCircularQueueResize"><title>resize</title>
<indexterm><primary>resize method</primary>
<secondary>of CircularQueue class</secondary>
</indexterm>
<indexterm><primary>method</primary>
<secondary>resize method</secondary>
<tertiary>of CircularQueue class</tertiary>
</indexterm>

<programlisting>
<![CDATA[
                   +--,Fifo---+
>>-resize(-newSize-+----------+-)------------------------------><
                   +--,order--+
]]>
</programlisting>

<para>
Resizes the circular queue object to be able to contain
<emphasis role="italic">newSize</emphasis> items.
If the previous size was larger than <emphasis role="italic">newSize</emphasis>,
then the now superfluous items are removed in the specified
<emphasis role="italic">order</emphasis>.
</para>

<para>
The following <emphasis role="italic">order</emphasis> can be used. (Only
the capitalized letter is needed; all characters following it are ignored.)
</para>

<variablelist>
<varlistentry><term>Fifo</term>
<listitem>
<para>First-in, first-out, default: keeps the newest entries
</para>
</listitem>
</varlistentry>
<varlistentry><term>Lifo</term>
<listitem>
<para>Last-in, first-out (stacklike): keeps the oldest entries
</para>
</listitem>
</varlistentry>
</variablelist>

<note><title>Note:</title>
<para>
Resizing with a value of <computeroutput>0</computeroutput> effectively removes all
items from the circular queue.
</para>
</note>
</section>

<section id="mthCircularQueueSize"><title>size</title>
<indexterm><primary>size method</primary>
<secondary>of CircularQueue class</secondary>
</indexterm>
<indexterm><primary>method</primary>
<secondary>size method</secondary>
<tertiary>of CircularQueue class</tertiary>
</indexterm>

<programlisting>
<![CDATA[
>>-size--------------------------------------------------------><
]]>
</programlisting>

<para>
Returns the maximum number of objects that can be stored in the circular queue.
</para>
</section>

<section id="mthCircularQueueString"><title>string</title>
<indexterm><primary>string method</primary>
<secondary>of CircularQueue class</secondary>
</indexterm>
<indexterm><primary>method</primary>
<secondary>string method</secondary>
<tertiary>of CircularQueue class</tertiary>
</indexterm>

<programlisting>
<![CDATA[
           +--","------+  +-,-Fifo--+
>>-string(-+-----------+--+---------+-)------------------------><
           +-delimiter-+  +-,-order-+
]]>
</programlisting>

<para>
Returns a string object that concatenates the string values of the collected
item objects, using the <emphasis role="italic">delimiter</emphasis> string
to delimit them, in the specified <emphasis role="italic">order</emphasis>.
The default <emphasis role="italic">delimiter</emphasis> is a single comma.
</para>

<para>
If the delimiter string argument is omitted the comma character
(<computeroutput>","</computeroutput>) is used as the default delimiter string.
</para>

<para>
The following <emphasis role="italic">order</emphasis> can be used. (Only
the capitalized letter is needed; all characters following it are ignored.)
</para>

<variablelist>
<varlistentry><term>Fifo</term>
<listitem>
<para>First-in, first-out, default
</para>
</listitem>
</varlistentry>
<varlistentry><term>Lifo</term>
<listitem>
<para>Last-in, first-out (stacklike)
</para>
</listitem>
</varlistentry>
</variablelist>
</section>

<section id="mthCircularQueueSupplier"><title>supplier</title>
<indexterm><primary>supplier method</primary>
<secondary>of CircularQueue class</secondary>
</indexterm>
<indexterm><primary>method</primary>
<secondary>supplier method</secondary>
<tertiary>of CircularQueue class</tertiary>
</indexterm>

<programlisting>
<![CDATA[
             +--Fifo----+
>>-supplier(-+----------+-)------------------------------------><
             +--order---+
]]>
</programlisting>

<para>This method overrides the
<link linkend="mthQueueSupplier">supplier method</link> from the
<link linkend="clsQueue">Queue class</link>.</para>
<para>
Returns a supplier object for the collection. After you have obtained a
supplier, you can send it messages (see
<link linkend="clsSupplier">The Supplier Class</link>) to enumerate
all the items that were in the queue at the time of the supplier's creation.
</para>

<para>
The supplier will enumerate the items in the specified
<emphasis role="italic">order</emphasis>. (Only the capitalized
letter is needed; all characters following it are ignored.)
</para>

<variablelist>
<varlistentry><term>Fifo</term>
<listitem>
<para>First-in, first-out, default
</para>
</listitem>
</varlistentry>
<varlistentry><term>Lifo</term>
<listitem>
<para>Last-in, first-out (stacklike)
</para>
</listitem>
</varlistentry>
</variablelist>
</section>

<section id="cquex"><title>Example</title>
<indexterm>
<primary>examples</primary>
<secondary>of CircularQueue class</secondary>
</indexterm>

<programlisting>
  -- create a circular buffer with five items
u=.circularQueue~of("a", "b", "c", "d", "e")
say "content: ["u"]," "content (LIFO): ["u~string("->","L")"]"
say

u~resize(4, "FIFO")     -- resize fifo-style (keep newest)
say "after resizing to 4 items in FIFO style (keeping the newest):"
say "content: ["u"]," "content (LIFO): ["u~string("->","L")"]"
say

u~resize(2, "LILO")     -- resize lifo-style (keep oldest)
say "after resizing to 2 items in LIFO style (keeping the oldest):"
say "content: ["u"]," "content (LIFO): ["u~string("->","L")"]"
say

u~resize(0)             -- resize lifo-style (keep oldest)
say "after resizing to 0 items, thereby deleting all items:"
say "content: ["u"]," "content (LIFO): ["u~string("->","L")"]"
say

u~resize(2)             -- resize lifo-style (keep oldest)
say "after resizing to 2, size="u~size "and items="u~items
u~~queue(&apos;x&apos;)~~queue(&apos;y&apos;)~~queue(&apos;z&apos;)
say "after queuing the three items &apos;x&apos;, &apos;y&apos;, &apos;z&apos;:"
say "content: ["u"]," "content (LIFO): ["u~string("->","L")"]"
say

u~~push(&apos;1&apos;)~~push(&apos;2&apos;)~~push(&apos;3&apos;)
say "after pushing the three items &apos;1&apos;, &apos;2&apos;, &apos;3&apos;:"
say "content: ["u"]," "content (LIFO): ["u~string("->","L")"]"
say
</programlisting>

<para>
Output:
</para>

<programlisting>
content: [a,b,c,d,e], content (LIFO): [e->d->c->b->a]

after resizing to 4 items in FIFO style (keeping the newest):
content: [b,c,d,e], content (LIFO): [e->d->c->b]

after resizing to 2 items in LIFO style (keeping the oldest):
content: [b,c], content (LIFO): [c->b]

after resizing to 0 items, thereby deleting all items:
content: [], content (LIFO): []

after resizing to 2, size=2 and items=0
after queuing the three items &apos;x&apos;, &apos;y&apos;, &apos;z&apos;:
content: [y,z], content (LIFO): [z->y]

after pushing the three items &apos;1&apos;, &apos;2&apos;, &apos;3&apos;:
content: [3,2], content (LIFO): [2->3]
</programlisting>
</section>
</section>

<section id="clsDirectory"><title>The Directory Class</title>
<indexterm><primary>Directory class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Directory class</secondary></indexterm>
<indexterm><primary>Map Collection classes</primary>
<secondary>Directory class</secondary></indexterm>

<para>A directory is a collection with unique
indexes that are character strings representing names.</para>
<figure><title>The Directory class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxDirectoryClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Directory class also has available class methods that
metaclass, the <link linkend="clsClass">Class class</link>, defines.
It also inherits methods from the <link linkend="clsMapCollection">Map Collection
class</link>, although there are not currently any methods defined in that class.
</para></note>
<para>Directories let you refer to objects by name, for example:</para>
<programlisting>
.environment~array
</programlisting>
<para>For directories, items are often referred to as entries.</para>

<section><title>Inherited Methods</title>

&objclsmthods;
&collclsmthods;
&mcollclsmthods;

</section>

<section id="mthDirectoryNew"><title>new (Class Method)</title>
<indexterm><primary>new method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new---------------------------------------------------------><
]]>
</programlisting>

<para>Returns an empty Directory object.</para>
</section>

<section id="mthDirectoryAtGet"><title>[]</title>
<indexterm><primary>[] method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[] method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-[name]------------------------------------------------------><
]]>
</programlisting>

<para>Returns the same item as the
<emphasis role="bold">at</emphasis> method, which follows. See
<link linkend="mthDirectoryAt">at</link>.</para>
</section>

<section id="mthDirectoryPutSet"><title>[]=</title>
<indexterm><primary>[]= method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[]= method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-[name]=item-------------------------------------------------><
]]>
</programlisting>

<para>This method is the same as the
<emphasis role="bold">put</emphasis> method. See
<link linkend="mthDirectoryPut">put</link>.</para>
</section>

<section id="mthDirectoryAllIndexes"<title>allIndexes</title>
<indexterm><primary>allIndexes method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allIndexes method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allIndexes---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all the directory indices, including those of all
the <link linkend="mthDirectorySetMethod">setMethod</link> methods.</para>
</section>

<section id="mthDirectoryAllItems"<title>allItems</title>
<indexterm><primary>allItems method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allItems method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allItems---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all items contained in the directory.</para>
</section>

<section id="mthDirectoryAt"><title>at</title>
<indexterm><primary>at method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>at method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-at(name)----------------------------------------------------><
]]>
</programlisting>

<para>Returns the item associated with index
<emphasis role="italic">name</emphasis>. If a method that
<emphasis role="bold">setMethod</emphasis> supplies is associated with index
<emphasis role="italic">name</emphasis>, the result of running
this method is returned. If the collection has no item or method associated
with index <emphasis role="italic">name</emphasis>, this method returns
the Nil object.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
say .environment~at("OBJECT")   /* Produces: "The Object class" */
</programlisting>
</section>

<section id="mthDirectoryEmpty"<title>empty</title>
<indexterm><primary>empty method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>empty method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-empty-------------------------------------------------------><
]]>
</programlisting>

<para>Removes all items from the directory.</para>
</section>

<section id="mthDirectoryEntry"><title>entry</title>
<indexterm><primary>entry method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>entry method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-entry(name)-------------------------------------------------><
]]>
</programlisting>

<para>Returns the directory entry with name
<emphasis role="italic">name</emphasis> (translated to uppercase).
If there is no such entry, <emphasis role="italic">name</emphasis>
returns the item for any method that
<emphasis role="bold">setMethod</emphasis> supplied. If there is
neither an entry nor a method for <emphasis role="italic">name</emphasis>
or for <emphasis role="bold">unknown</emphasis>,
the language processor raises an error.</para>
</section>

<section id="mthDirectoryHasEntry"><title>hasEntry</title>
<indexterm><primary>hasEntry method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasEntry method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasEntry(name)----------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the directory has
an entry or a method for name <emphasis role="italic">name</emphasis>
(translated to uppercase), or <computeroutput>0</computeroutput> (false).</para>
</section>

<section id="mthDirectoryHasIndex"><title>hasIndex</title>
<indexterm><primary>hasIndex method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasIndex method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasIndex(name)----------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the collection
contains any item associated with index
<emphasis role="italic">name</emphasis>, or <computeroutput>0</computeroutput>
(false).</para>
</section>

<section id="mthDirectoryHasItem"<title>hasItem</title>
<indexterm><primary>hasItem method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasItem method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasItem(value)----------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the collection
contains the <emphasis role="italic">value</emphasis> at any index position or
otherwise returns <computeroutput>0</computeroutput> (false).</para>
</section>

<section id="mthDirectoryIndex"<title>index</title>
<indexterm><primary>index method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>index method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-index(item)------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the specified item within the directory.  If the
target item appears at more than one index, the first located index will
be returned.  If the directory does not contain the specified item, .nil is
returned.
</para>
</section>

<section id="mthDirectoryIsEmpty"<title>isEmpty</title>
<indexterm><primary>isEmpty method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isEmpty method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isEmpty----------------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the directory
is empty.  Returns
<computeroutput>0</computeroutput> (false) otherwise.</para>
</section>

<section id="mthDirectoryItems"><title>items</title>
<indexterm><primary>items method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>items method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-items-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of items in the collection.</para>
</section>

<section id="mthDirectoryMakeArray"><title>makeArray</title>
<indexterm><primary>makeArray method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>makeArray method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-makeArray---------------------------------------------------><
]]>
</programlisting>

<para>Returns a single-index array containing the index objects. The array
indexes range from <computeroutput>1</computeroutput> to the number of items.
The collection items appear in the array in an unspecified order.
(The program should not rely on any order.)</para>
</section>

<section id="mthDirectoryPut"><title>put</title>
<indexterm><primary>put method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>put method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-put(item,name)----------------------------------------------><
]]>
</programlisting>

<para>Makes the object <emphasis role="italic">item</emphasis>
a member item of the collection and associates
it with index <emphasis role="italic">name</emphasis>.
The new item replaces any existing item or method
associated with index <emphasis role="italic">name</emphasis>.</para>
</section>

<section id="mthDirectoryRemove"><title>remove</title>
<indexterm><primary>remove method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>remove method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-remove(name)------------------------------------------------><
]]>
</programlisting>

<para>Returns and removes the member item with index
<emphasis role="italic">name</emphasis> from a collection.
If a method is associated with
<emphasis role="bold">setMethod</emphasis> for index
<emphasis role="italic">name</emphasis>,
<emphasis role="bold">remove</emphasis> removes
the method and returns the result of running it. If there is no item or method
with index <emphasis role="italic">name</emphasis>, the
<emphasis role="bold">unknown</emphasis> method returns
the Nil object and removes nothing.</para>
</section>

<section id="mthDirectoryRemoveItem"<title>removeItem</title>
<indexterm><primary>removeItem method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>removeItem method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-removeItem(item)--------------------------------------------><
]]>
</programlisting>

<para>Removes an item from the directory. If the target item exists at more than
one index, the first located item is removed.  The return value is the
removed item.
</para>
</section>

<section id="mthDirectorySetEntry"><title>setEntry</title>
<indexterm><primary>setEntry method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>setEntry method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-setEntry(name-+--------+-)----------------------------------><
                 +-,entry-+
]]>
</programlisting>

<para>Sets the directory entry with name
<emphasis role="italic">name</emphasis> (translated to uppercase)
to the object <emphasis role="italic">entry</emphasis>, replacing any existing
entry or method for <emphasis role="italic">name</emphasis>. If you omit
<emphasis role="italic">entry</emphasis>, this method removes any entry or
method with this <emphasis role="italic">name</emphasis>.</para>
</section>

<section id="mthDirectorySetMethod"><title>setMethod</title>
<indexterm><primary>setMethod method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>setMethod method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-setMethod(name-+---------+-)--------------------------------><
                  +-,method-+
]]>
</programlisting>

<para>Associates entry name <emphasis role="italic">name</emphasis>
(translated to uppercase) with method <emphasis role="italic">method</emphasis>.
Thus, the language processor returns the result of running
<emphasis role="italic">method</emphasis> when you access this entry.
This occurs when you specify <emphasis role="italic">name</emphasis> on the
<emphasis role="bold">at</emphasis>,
<emphasis role="bold">entry</emphasis>, or
<emphasis role="bold">remove</emphasis> method. This method replaces any existing
item or method for <emphasis role="italic">name</emphasis>.</para>
<para>You can specify the name <emphasis role="bold">unknown</emphasis> as
<emphasis role="italic">name</emphasis>. Doing so supplies a
method to run whenever an <emphasis role="bold">at</emphasis> or
<emphasis role="bold">entry</emphasis> message specifies a name for which no item
or method exists in the collection. This method's first argument is the
specified directory index. This method has no effect on the action of any
<emphasis role="bold">hasEntry</emphasis>,
<emphasis role="bold">hasIndex</emphasis>,
<emphasis role="bold">items</emphasis>,
<emphasis role="bold">remove</emphasis>, or
<emphasis role="bold">supplier</emphasis> message sent to the collection.
</para>
<para>The <emphasis role="italic">method</emphasis> can be a
string containing a method source line instead
of a method object. Alternatively, an array of strings containing individual
method lines can be passed. In either case,
<emphasis role="bold">setMethod</emphasis> creates an equivalent
method object.</para>
<para>If you omit <emphasis role="italic">method</emphasis>,
<emphasis role="bold">setMethod</emphasis> removes the entry with the specified
<emphasis role="italic">name</emphasis>.</para>
</section>

<section id="mthDirectorySupplier"><title>supplier</title>
<indexterm><primary>supplier method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>supplier method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-supplier----------------------------------------------------><
]]>
</programlisting>

<para>Returns a supplier object for the collection. After you have obtained a
supplier, you can send it messages (see
<link linkend="clsSupplier">The Supplier Class</link>) to enumerate
all the items that were in the collection at the time of the supplier's
creation. The supplier enumerates the items in an unspecified order. (The
program should not rely on any order.)</para>
</section>

<section id="mthDirectoryUnknown"><title>unknown</title>
<indexterm><primary>unknown method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>unknown method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-unknown(messagename,messageargs)----------------------------><
]]>
</programlisting>

<para>Runs either the <emphasis role="bold">entry</emphasis> or
<emphasis role="bold">setEntry</emphasis> method, depending on whether
<emphasis role="italic">messagename</emphasis> ends with an equal sign. If
<emphasis role="italic">messagename</emphasis> does not end with an
equal sign, this method runs the
<emphasis role="bold">entry</emphasis> method, passing
<emphasis role="italic">messagename</emphasis> as
its argument. The language processor ignores any arguments specified in the
array <emphasis role="italic">messageargs</emphasis>. In this case,
<emphasis role="bold">unknown</emphasis>
returns the result of the <emphasis role="bold">entry</emphasis> method.</para>
<para>If <emphasis role="italic">messagename</emphasis> does end with an equal
sign, this method runs the
<emphasis role="bold">setEntry</emphasis> method, passing the first part of
<emphasis role="italic">messagename</emphasis> (up to, but
not including, the final equal sign) as its first argument, and the first
item in the array <emphasis role="italic">messageargs</emphasis>
as its second argument. In this case,
<emphasis role="bold">unknown</emphasis> returns no result.</para>
</section>

<section id="mthDirectoryUnsetMethod"<title>unsetMethod</title>
<indexterm><primary>unsetMethod method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>unsetMethod method</secondary>
<tertiary>of Directory class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-unsetMethod(name)--------------------------------><
]]>
</programlisting>

<para>Removes the association between entry name <emphasis role="italic">name</emphasis>
(translated to uppercase) and a method.</para>
</section>

<section id="mthDirectoryXor"><title>xor</title>
<indexterm><primary>xor method</primary>
<secondary>of Directory class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>xor method</secondary>
<tertiary>of Directory class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-xor(argument)-----------------------------------------------><
]]>
</programlisting>

<para>Returns a new collection of the same class as the receiver that contains
all items from the receiver collection and the
<emphasis role="italic">argument</emphasis> collection;
all indexes that appear in both collections are removed. The
<emphasis role="italic">argument</emphasis> can be any
collection class object.
The <emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>

<section id="direx"><title>Examples</title>
<indexterm><primary>examples</primary>
<secondary>of Directory class</secondary></indexterm>
<programlisting>
/******************************************************************************/
/*  A Phone Book Directory program                                            */
/*  This program demonstrates use of the directory class.                     */
/******************************************************************************/

/* Define an UNKNOWN method that adds an abbreviation lookup feature.         */
/* Directories do not have to have an UNKNOWN method.                         */
book = .directory~new~~setMethod("UNKNOWN", .methods["UNKNOWN"])

book["ANN" ] = "Ann B. ....... 555-6220"
book["ann" ] = "Little annie . 555-1234"
book["JEFF"] = "Jeff G. ...... 555-5115"
book["MARK"] = "Mark C. ...... 555-5017"
book["MIKE"] = "Mike H. ...... 555-6123"
book~Rick    = "Rick M. ...... 555-5110"  /* Same as book["RICK"] = ...       */

Do i over book                 /* Iterate over the collection                 */
  Say book[i]
end i

Say ""                         /* Index lookup is case sensitive...           */
Say book~entry("Mike")         /* ENTRY method uppercases before lookup       */
Say book["ANN"]                /* Exact match                                 */
Say book~ann                   /* Message sends uppercase before lookup       */
Say book["ann"]                /* Exact match with lowercase index            */

Say ""
Say book["M"]                  /* Uses UNKNOWN method for lookup              */
Say book["Z"]
Exit

/* Define an unknown method to handle indexes not found.                      */
/* Check for abbreviations or indicate listing not found                      */
::Method unknown
  Parse arg at_index
  value = ""
  Do i over self
    If abbrev(i, at_index) then do
      If value &lt;> "" then value = value", "
      value = value || self~at(i)
    end
  end i
  If value = "" then value = "No listing found for" at_index
  Return value
</programlisting>
</section>
</section>

<section id="clsList"><title>The List Class</title>
<indexterm><primary>List class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>List class</secondary></indexterm>
<indexterm><primary>Ordered collection classes</primary>
<secondary>List class</secondary></indexterm>

<para>A list is a non-sparse sequenced collection similar to the
<link linkend="clsArray">The Array Class</link> to which you
can add new items at any position in the sequence. The collection supplies
the list indexes at the time items are added with the
<emphasis role="bold">insert</emphasis> method. The
<emphasis role="bold">first</emphasis>,
<emphasis role="bold">last</emphasis>, and
<emphasis role="bold">next</emphasis> methods can also retrieve list indexes.
Only indexes the list
object generates are valid i.e. the list is never a sparse list and the list
object may modify idexes for items in the list.</para>
<figure><title>The List class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxListClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The List class also has available class methods that its metaclass,
metaclass, the <link linkend="clsClass">Class class</link>, defines.
It also inherits methods from the <link linkend="clsOrderedCollection">Ordered Collection
class</link>, although there are not currently any methods defined in that class.
</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;
&collclsmthods;
&ocollclsmthods;

</section>

<section id="mthListNew"><title>new (Class Method)</title>
<indexterm><primary>new method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a new empty List object.</para>
</section>

<section id="mthListOf"><title>of (Class Method)</title>
<indexterm><primary>of method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>of method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
       +-,----+
       V      |
>>-of(---item-+-)----------------------------------------------><
]]>
</programlisting>

<para>Returns a newly created list containing the specified
<emphasis role="italic">item</emphasis> objects in the order specified.</para>
</section>

<section id="mthListAtGet"><title>[]</title>
<indexterm><primary>[] method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[] method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-[index]-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the same item as the
<emphasis role="bold">at</emphasis> method. See
<link linkend="mthListAt">at</link>.</para>
</section>

<section id="mthListPutSet"><title>[]=</title>
<indexterm><primary>[]= method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[]= method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-[index]=item------------------------------------------------><
]]>
</programlisting>

<para>This method is the same as the
<emphasis role="bold">put</emphasis> method. See
<link linkend="mthListPut">put</link>.</para>
</section>

<section id="mthListAllIndexes"><title>allIndexes</title>
<indexterm><primary>allIndexes method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allIndexes method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allIndexes---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all element contained in the list in sorted order.</para>
</section>

<section id="mthListAllItems"><title>allItems</title>
<indexterm><primary>allItems method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allItems method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allItems---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all items contained in the list.</para>
</section>

<section id="mthListAppend"><title>append</title>
<indexterm><primary>append method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>append method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-append(item)---------------------------------------------------><
]]>
</programlisting>

<para>Appends <emphasis role="italic">item</emphasis> to the end of the list.</para>
</section>

<section id="mthListAt"><title>at</title>
<indexterm><primary>at method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>at method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-at(index)---------------------------------------------------><
]]>
</programlisting>

<para>Returns the item associated with index
<emphasis role="italic">index</emphasis>. If the collection
has no item associated with <emphasis role="italic">index</emphasis>,
this method returns the Nil object.</para>
</section>

<section id="mthListEmpty"><title>empty</title>
<indexterm><primary>empty method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>empty method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-empty-------------------------------------------------------><
]]>
</programlisting>

<para>Removes all items from the list.</para>
</section>

<section id="mthListFirst"><title>first</title>
<indexterm><primary>first method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>first method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-first-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the first item in the list or the NIL object if the
list is empty. The example for <emphasis role="bold">insert</emphasis>
(see <link linkend="mthListInsert">insert</link>) includes
<emphasis role="bold">first</emphasis>.</para>
</section>

<section id="mthListFirstItem"><title>firstItem</title>
<indexterm><primary>firstItem method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>firstItem method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-firstItem---------------------------------------------------><
]]>
</programlisting>

<para> </para>
<para>Returns the first item in the list or the Nil object if the list is
empty.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
musketeers=.list~of(Porthos,Athos,Aramis) /* Creates list MUSKETEERS      */
item=musketeers~firstItem                 /* Gives first item in list     */
                                          /* (Assigns "Porthos" to item)  */
</programlisting>
</section>

<section id="mthListHasIndex"><title>hasIndex</title>
<indexterm><primary>hasIndex method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasIndex method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasIndex(index)---------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the collection
contains any item associated with index
<emphasis role="italic">index</emphasis>, or
<computeroutput>0</computeroutput> (false).</para>
</section>

<section id="mthListHasItem"><title>hasItem</title>
<indexterm><primary>hasItem method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasItem method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasItem(value)----------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the collection
contains the <emphasis role="italic">value</emphasis> at any index position or
otherwise returns <computeroutput>0</computeroutput> (false).</para>
</section>

<section id="mthListIndex"><title>index</title>
<indexterm><primary>index method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>index method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-index(item)------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the specified item within the list.  If the
target item appears at more than one index, the first located index will
be returned.  If the list does not contain the specified item, .nil is
returned.
</para>
</section>

<section id="mthListInsert"><title>insert</title>
<indexterm><primary>insert method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>insert method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-insert(item-+--------+-)------------------------------------><
               +-,index-+
]]>
</programlisting>

<para>Returns a list-supplied index for a new item
<emphasis role="italic">item</emphasis>, which is added to the list. The new
item follows the existing item with index
<emphasis role="italic">index</emphasis> in the list ordering.
If <emphasis role="italic">index</emphasis> is the Nil object, the new item
becomes the first item in the list. If you omit
<emphasis role="italic">index</emphasis>, the new item becomes the last item in
the list. </para>
<para>Inserting an item in the list at position
<emphasis role="italic">index</emphasis> will cause the items in the list after
position <emphasis role="italic">index</emphasis> to have their indexes modified
by the list object.</para>
<note><para>The term <emphasis role="italic">index</emphasis> as used above does
not imply that the list order is maitained via an array-like index. The indexes
refered to above are internal handles maintained by the interpreter and are not
available to the user.</para></note>
<indexterm><primary>examples</primary>
<secondary>insert method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
musketeers=.list~of(Porthos,Athos,Aramis) /* Creates list MUSKETEERS        */
                                          /* consisting of: Porthos         */
                                          /*                Athos           */
                                          /*                Aramis          */
index=musketeers~first                    /* Gives index of first item      */
musketeers~insert("D&apos;Artagnan",index) /* Adds D&apos;Artagnan after Porthos  */
                                          /* List is now: Porthos           */
                                          /*              D&apos;Artagnan   */
                                          /*              Athos             */
                                          /*              Aramis            */
/* Alternately, you could use */
musketeers~insert("D&apos;Artagnan",.nil) /* Adds D&apos;Artagnan before Porthos */
                                          /* List is now:  D&apos;Artagnan  */
                                          /*               Porthos          */
                                          /*               Athos            */
                                          /*               Aramis           */
/* Alternately, you could use */
musketeers~insert("D&apos;Artagnan")      /* Adds D&apos;Artagnan after Aramis   */
                                          /* List is now:  Porthos          */
                                          /*               Athos            */
                                          /*               Aramis           */
                                          /*               D&apos;Artagnan  */
</programlisting>
</section>

<section id="mthListIsEmpty"><title>isEmpty</title>
<indexterm><primary>isEmpty method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isEmpty method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isEmpty----------------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the list
is empty.  Returns
<computeroutput>0</computeroutput> (false) otherwise.</para>
</section>

<section id="mthListItems"><title>items</title>
<indexterm><primary>items method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>items method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-items-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of items in the collection.</para>
</section>

<section id="mthListLast"><title>last</title>
<indexterm><primary>last method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>last method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-last--------------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the last item in the list or the Nil object if the
list is empty.</para>
</section>

<section id="mthListLastItem"><title>lastItem</title>
<indexterm><primary>lastItem method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>lastItem method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-lastItem----------------------------------------------------><
]]>
</programlisting>

<para>Returns the last item in the list or the NIL object if the list is empty.
</para>
</section>

<section id="mthListMakeArray"><title>makeArray</title>
<indexterm><primary>makeArray method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>makeArray method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-makeArray---------------------------------------------------><
]]>
</programlisting>

<para>Returns a single-index array containing the receiver collection items.
The array indexes range from <computeroutput>1</computeroutput> to the number
of items. The order in which the collection items appear in the array is the
same as their sequence in the list collection.</para>
</section>

<section id="mthListNext"><title>next</title>
<indexterm><primary>next method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>next method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-next(index)-------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the item that follows the list item having index
<emphasis role="italic">index</emphasis> or returns the Nil object if the
item having that index is last in the list.</para>
</section>

<section id="mthListPrevious"><title>previous</title>
<indexterm><primary>previous method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>previous method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-previous(index)---------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the item that precedes the list item having index
<emphasis role="italic">index</emphasis> or the Nil object if the item having
that index is first in the list.</para>
</section>

<section id="mthListPut"><title>put</title>
<indexterm><primary>put method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>put method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-put(item,index)---------------------------------------------><
]]>
</programlisting>

<para>Replaces any existing item associated with the specified
<emphasis role="italic">index</emphasis> with
the new item <emphasis role="italic">item</emphasis>. If the
<emphasis role="italic">index</emphasis> does not exist in the list,
an error is raised.</para>
</section>

<section id="mthListRemove"><title>remove</title>
<indexterm><primary>remove method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>remove method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-remove(index)-----------------------------------------------><
]]>
</programlisting>

<para>Returns and removes from a collection the member item with index
<emphasis role="italic">index</emphasis>. If no item has index
<emphasis role="italic">index</emphasis>, this method returns
the Nil object and removes no item.</para>
<para>Removinf an item from the list at position
<emphasis role="italic">index</emphasis> will cause the items in the list after
position <emphasis role="italic">index</emphasis> to have their indexes modified
by the list object.</para>
</section>

<section id="mthListRemoveItem"><title>removeItem</title>
<indexterm><primary>removeItem method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>removeItem method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-removeItem(item)--------------------------------------------><
]]>
</programlisting>

<para>Removes an item from the list. If the target item exists at more than
one index, the first located item is removed.  The return value is the
removed item.
</para>
</section>

<section id="mthListSection"><title>section</title>
<indexterm><primary>section method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>section method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-section(start-+--------+-)----------------------------------><
                 +-,items-+
]]>
</programlisting>

<para>Returns a new list (of the same class as the receiver) containing selected
items from the receiver list. The first item in the new list is the item corresponding
to index <emphasis role="italic">start</emphasis> in the receiver list.
Subsequent items in the new list correspond to those in the receiver list
(in the same sequence). If you specify the whole number
<emphasis role="italic">items</emphasis>, the new list contains only this
number of items (or the number of subsequent items in the receiver list, if this
is less than <emphasis role="italic">items</emphasis>). If you do not specify
<emphasis role="italic">items</emphasis>, the new
list contains all subsequent items from the receiver list. The receiver list
remains unchanged.</para>
</section>

<section id="mthListSupplier"><title>supplier</title>
<indexterm><primary>supplier method</primary>
<secondary>of List class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>supplier method</secondary>
<tertiary>of List class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-supplier----------------------------------------------------><
]]>
</programlisting>

<para>Returns a supplier object for the list. If you send appropriate messages
to the supplier (see <link linkend="clsSupplier">The Supplier Class</link>), the
supplier enumerates all the items in the list at the time of the supplier's
creation. The supplier enumerates the items in their sequenced order.</para>
</section>
</section>

<section id="clsProperties"><title>The Properties Class</title>
<indexterm><primary>Properties class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Properties class</secondary></indexterm>
<indexterm><primary>Map Collection classes</primary>
<secondary>Properties class</secondary></indexterm>
<para>A properties object is a collection with unique
indexes that are character strings representing names and items that
are also restricted to character string values.  Properties objects
are useful for processing bundles of application option values.
</para>

<figure><title>The Properties class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxPropertiesClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Properties class also has available class methods that
its metaclass, the <link linkend="clsClass">Class class</link>, defines.</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;
&collclsmthods;
&mcollclsmthods;

<para>Methods inherited from the
<link linkend="clsDirectory">Directory class</link>.</para>
<simplelist type="vert" columns="3">
<member><link linkend="mthDirectoryAllIndexes">allIndexes</link></member>
<member><link linkend="mthDirectoryAllItems">allItems</link></member>
<member><link linkend="mthDirectoryAt">at</link></member>
<member><link linkend="mthDirectoryAtGet">[ ]</link></member>
<member><link linkend="mthDirectoryEmpty">empty</link></member>
<member><link linkend="mthDirectoryEntry">entry</link></member>
<member><link linkend="mthDirectoryHasEntry">hasEntry</link></member>
<member><link linkend="mthDirectoryHasIndex">hasIndex</link></member>
<member><link linkend="mthDirectoryHasItem">hasItem</link></member>
<member><link linkend="mthDirectoryIndex">index</link></member>
<member><link linkend="mthDirectoryIsEmpty">isEmpty</link></member>
<member><link linkend="mthDirectoryItems">items</link></member>
<member><link linkend="mthDirectoryMakeArray">makeArray</link></member>
<member><link linkend="mthDirectoryPut">put</link></member>
<member><link linkend="mthDirectoryPutSet">[ ]=</link></member>
<member><link linkend="mthDirectoryRemove">remove</link></member>
<member><link linkend="mthDirectoryRemoveItem">removeItem</link></member>
<member><link linkend="mthDirectorySetEntry">setEntry</link></member>
<member><link linkend="mthDirectorySetMethod">setMethod</link></member>
<member><link linkend="mthDirectorySupplier">supplier</link></member>
<member><link linkend="mthDirectoryUnsetMethod">unsetMethod</link></member>
</simplelist>

</section>

<section id="mthPropertiesLoadClsMth"<title>load (Class method)</title>
<indexterm><primary>load method</primary>
<secondary>of Properties class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>load method</secondary>
<tertiary>of Properties class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-load(source)-----------------------------------------------><
]]>
</programlisting>

<para>Loads a set of properties from <emphasis role="italic">source</emphasis> and returns them as a new Properties object.
The load source can be either the string name of a file or a stream object.  Properties are read from the source as
individual lines using <emphasis role="bold">linein</emphasis>.  Blank lines and lines with a Rexx line comment ("--")
as the first non-blank characters are ignored.  Otherwise, the lines are assumed to be of the form "name=value" and
are added to the receiver Properties value using name as the index for the value.
</para>
</section>

<section id="mthPropertiesNew"<title>new (Class method)</title>
<indexterm><primary>new method</primary>
<secondary>of Properties class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of Properties class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new---------------------------------------------------------><
]]>
</programlisting>

<para>Returns an empty Properties object.</para>
</section>

<section id="mthPropertiesPutSet"<title>[]=</title>
<indexterm><primary>[]= method</primary>
<secondary>of Properties class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[]= method</secondary>
<tertiary>of Properties class</tertiary></indexterm>

<para>This method overrides the
<link linkend="mthDirectoryPutSet">[]= method</link> from the
<link linkend="clsDirectory">Directory class</link>.</para>
<programlisting>
<![CDATA[
>>-[name]=item-------------------------------------------------><
]]>
</programlisting>

<para>This method is the same as the
<emphasis role="bold">put</emphasis> method. See
<link linkend="mthPropertiesPut">put</link>.</para>
</section>

<section id="mthPropertiesGetLogical"<title>getLogical</title>
<indexterm><primary>getLogical method</primary>
<secondary>of Properties class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getLogical method</secondary>
<tertiary>of Properties class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getLogical(name-+----------+-)------------------------------------><
                   +-,default-+
]]>
</programlisting>

<para>Returns the value of <emphasis role="italic">name</emphasis> as either .true or .false.
The raw value of the <emphasis role="italic">name</emphasis> may be either the numeric values "0" or "1" or
the string values "true" or "false".  Any other value will raise a syntax error.  If the
property <emphasis role="italic">name</emphasis> does not exist and <emphasis role="italic">default</emphasis>
has been specified, the default value will be returned.  If <emphasis role="italic">default</emphasis> has not
been specified, a syntax error is raised for missing values.</para>
</section>

<section id="mthPropertiesGetProperty"<title>getProperty</title>
<indexterm><primary>getProperty method</primary>
<secondary>of Properties class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getProperty method</secondary>
<tertiary>of Properties class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getProperty(name-+----------+-)------------------------------------><
                    +-,default-+
]]>
</programlisting>

<para>Returns the value of <emphasis role="italic">name</emphasis>.  If
property <emphasis role="italic">name</emphasis> does not exist and <emphasis role="italic">default</emphasis>
has been specified, the default value will be returned.  If <emphasis role="italic">default</emphasis> has not
been specified, .nil is returned for the property value.</para>
</section>

<section id="mthPropertiesGetWhole"<title>getWhole</title>
<indexterm><primary>getWhole method</primary>
<secondary>of Properties class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getWhole method</secondary>
<tertiary>of Properties class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getWhole(name-+----------+-)-----------------------------------><
                 +-,default-+
]]>
</programlisting>

<para>Returns the value of <emphasis role="italic">name</emphasis>, validated as being a Rexx whole number.
If property <emphasis role="italic">name</emphasis> does not exist and <emphasis role="italic">default</emphasis>
has been specified, the default value will be returned.  If <emphasis role="italic">default</emphasis> has not
been specified, a syntax error is raised for missing values.</para>
</section>

<section id="mthPropertiesLoad"<title>load</title>
<indexterm><primary>load method</primary>
<secondary>of Properties class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>load method</secondary>
<tertiary>of Properties class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-load(source)-----------------------------------------------><
]]>
</programlisting>

<para>Loads a set of properties into the receiving Properties object from <emphasis role="italic">source</emphasis>.
The load source can be either the string name of a file or a stream object.  Properties are read from the source as
individual lines using <emphasis role="bold">linein</emphasis>.  Blank lines and lines with a Rexx line comment ("--")
as the first non-blank characters are ignored.  Otherwise, the lines are assumed to be of the form "name=value" and
are added to the receiver Properties value using name as the index for the value.
Properties loaded from <emphasis role="italic">source</emphasis> that with the same names as existing items will
replace the current entries.
</para>
</section>

<section id="mthPropertiesPut"<title>put</title>
<indexterm><primary>put method</primary>
<secondary>of Properties class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>put method</secondary>
<tertiary>of Properties class</tertiary></indexterm>

<para>This method overrides the
<link linkend="mthDirectoryPut">put method</link> from the
<link linkend="clsDirectory">Directory class</link>.</para>
<programlisting>
<![CDATA[
>>-put(item,name)----------------------------------------------><
]]>
</programlisting>

<para>Makes the object <emphasis role="italic">item</emphasis>
a member item of the collection and associates
it with index <emphasis role="italic">name</emphasis>.  The item
value must be a character string.
The new item replaces any existing item or method
associated with index <emphasis role="italic">name</emphasis>.</para>
</section>

<section id="mthPropertiesSave"<title>save</title>
<indexterm><primary>save method</primary>
<secondary>of Properties class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>save method</secondary>
<tertiary>of Properties class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-save(target)-----------------------------------------------><
]]>
</programlisting>

<para>Saves a set of properties into <emphasis role="italic">target</emphasis>.
The save target can be either the string name of a file or a stream object.  Properties are stored as
individual lines using <emphasis role="bold">lineout</emphasis>.
The lines are written in the form "name=value".  A saved Properties file can be reloaded using the Properties
<emphasis role="bold">load</emphasis> method.
</para>
</section>

<section id="mthPropertiesSetLogical"<title>setLogical</title>
<indexterm><primary>setLogical method</primary>
<secondary>of Properties class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>setLogical method</secondary>
<tertiary>of Properties class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-setLogical(name,value)--------------------------------------------><
]]>
</programlisting>
<para>Sets a logical value in the property bundle.  The <emphasis role="italic">value</emphasis>
argument must be either the numbers "0" or "1", or the character string values "true" or "false".  The
property value will be added with <emphasis role="italic">value</emphasis> converted in to the appropriate
"true" or "false" string value.</para>
</section>

<section id="mthPropertiesSetProperty"<title>setProperty</title>
<indexterm><primary>setProperty method</primary>
<secondary>of Properties class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>setProperty method</secondary>
<tertiary>of Properties class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-setProperty(name,value)--------------------------------------------><
]]>
</programlisting>
<para>Sets a named property the property bundle.  The <emphasis role="italic">value</emphasis>
argument must be a character string value.</para>
</section>

<section id="mthPropertiesSetWhole"<title>setWhole</title>
<indexterm><primary>setWhole method</primary>
<secondary>of Properties class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>setWhole method</secondary>
<tertiary>of Properties class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-setWhole(name,value)--------------------------------------------><
]]>
</programlisting>
<para>Sets a whole number value in the property bundle.  The <emphasis role="italic">value</emphasis>
argument must be a valid Rexx whole number.</para>
</section>
</section>

<section id="clsQueue"><title>The Queue Class</title>
<indexterm><primary>class</primary>
<secondary>Queue class</secondary></indexterm>
<indexterm><primary>Queue class</primary></indexterm>
<indexterm><primary>Ordered collection classes</primary>
<secondary>Queue class</secondary></indexterm>

<para>A queue is a non-sparse sequenced collection with whole-number
indexes. The indexes specify the position of an item relative to the head
(first item) of the queue. Adding or removing an item changes the association
of an index to its queue item. You can add items at either the tail or the
head of the queue.</para>
<figure><title>The Queue class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxQueueClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Queue class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.
It also inherits methods from the <link linkend="clsOrderedCollection">Ordered Collection
class</link>, although there are not currently any methods defined in that class.
</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;
&collclsmthods;
&ocollclsmthods;

</section>

<section id="mthQueueNew"><title>new (Class Method)</title>
<indexterm><primary>new method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new---------------------------------------------------------><
]]>
</programlisting>

<para>Returns a new empty Queue object.</para>
</section>

<section id="mthQueueOf"><title>of (Class Method)</title>
<indexterm><primary>of method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>of method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
       +-,----+
       V      |
>>-of(---item-+-)----------------------------------------------><
]]>
</programlisting>

<para>Returns a newly created queue containing the specified
<emphasis role="italic">item</emphasis> objects in the order specified.</para>
</section>

<section id="mthQueueAtGet"><title>[]</title>
<indexterm><primary>[] method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[] method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-[index]-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the same value as the <emphasis role="bold">at</emphasis> method. See
<link linkend="mthQueueAt">at</link>.</para>
<para>The order in which the queue items appear in the array is the same as their
queuing order, with the head of the queue as index 1.</para>
</section>

<section id="mthQueuePutSet"><title>[]=</title>
<indexterm><primary>[]= method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[]= method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-[index]=item------------------------------------------------><
]]>
</programlisting>

<para>This method is the same as the <emphasis role="bold">put</emphasis>
method. See <link linkend="mthQueuePut">put</link>.
</para>
</section>

<section id="mthQueueAllIndexes"><title>allIndexes</title>
<indexterm><primary>allIndexes method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allIndexes method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allIndexes---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all element containing all the index values for the
queue. For the Queue class, the indices are integers 1 -
<link linkend="mthQueueItems">items</link>.</para>
</section>

<section id="mthQueueAllItems"><title>allItems</title>
<indexterm><primary>allItems method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allItems method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allItems---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all items contained in the queue.</para>
</section>

<section id="mthQueueAppend"><title>append</title>
<indexterm><primary>append method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>append method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-append(item)---------------------------------------------------><
]]>
</programlisting>

<para>Appends <emphasis role="italic">item</emphasis> to the end of the queue.</para>
</section>

<section id="mthQueueAt"><title>at</title>
<indexterm><primary>at method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>at method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-at(index)---------------------------------------------------><
]]>
</programlisting>

<para>Returns the item associated with index
<emphasis role="italic">index</emphasis>. If the collection has no item associated with
<emphasis role="italic">index</emphasis>, this method returns the Nil object.</para>
</section>

<section id="mthQueueEmpty"><title>empty</title>
<indexterm><primary>empty method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>empty method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-empty-------------------------------------------------------><
]]>
</programlisting>

<para>Removes all items from the queue.</para>
</section>

<section id="mthQueueFirst"><title>first</title>
<indexterm><primary>first method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>first method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-first-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the first item in the queue or the Nil object if the
queue is empty.</para>
</section>

<section id="mthQueueHasIndex"><title>hasIndex</title>
<indexterm><primary>hasIndex method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasIndex method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasIndex(index)---------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the collection
contains any item associated with index <emphasis role="italic">index</emphasis>,
or <computeroutput>0</computeroutput> (false).</para>
</section>

<section id="mthQueueHasItem"><title>hasItem</title>
<indexterm><primary>hasItem method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasItem method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasItem(value)----------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the collection
contains the <emphasis role="italic">value</emphasis> at any index position or
otherwise returns <computeroutput>0</computeroutput> (false).</para>
</section>

<section id="mthQueueIndex"><title>index</title>
<indexterm><primary>index method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>index method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-index(item)------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the specified item within the queue.  If the
target item appears at more than one index, the first located index will
be returned.  If the queue does not contain the specified item, .nil is
returned.
</para>
</section>

<section id="mthQueueInsert"><title>insert</title>
<indexterm><primary>insert method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>insert method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-insert(item-+--------+-)------------------------------------><
               +-,index-+
]]>
</programlisting>

<para>Returns a queue-supplied index for a new item
<emphasis role="italic">item</emphasis>, which is added to the queue. The new
item follows the existing item with index
<emphasis role="italic">index</emphasis> in the queue ordering.
If <emphasis role="italic">index</emphasis> is the Nil object, the new item
becomes the first item in the queue. If you omit
<emphasis role="italic">index</emphasis>, the new item becomes the last item in
the queue. </para>
<para>Inserting an item in the queue at position
<emphasis role="italic">index</emphasis> will cause the items in the queue after
position <emphasis role="italic">index</emphasis> to have their indexes modified
by the queue object.</para>
<note><para>The term <emphasis role="italic">index</emphasis> as used above does
not imply that the queue order is maitained via an array-like index. The indexes
refered to above are internal handles maintained by the interpreter and are not
available to the user.</para></note>
<indexterm><primary>examples</primary>
<secondary>insert method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
musketeers=.queue~of(Porthos,Athos,Aramis) /* Creates queue MUSKETEERS       */
                                           /* consisting of: Porthos         */
                                           /*                Athos           */
                                           /*                Aramis          */
index=musketeers~first                     /* Gives index of first item      */
musketeers~insert("D&apos;Artagnan",index) /* Adds D&apos;Artagnan after Porthos  */
                                           /* List is now: Porthos           */
                                           /*              D&apos;Artagnan   */
                                           /*              Athos             */
                                           /*              Aramis            */
/* Alternately, you could use */
musketeers~insert("D&apos;Artagnan",.nil)  /* Adds D&apos;Artagnan before Porthos */
                                           /* List is now:  D&apos;Artagnan  */
                                           /*               Porthos          */
                                           /*               Athos            */
                                           /*               Aramis           */
/* Alternately, you could use */
musketeers~insert("D&apos;Artagnan")       /* Adds D&apos;Artagnan after Aramis   */
                                           /* List is now:  Porthos          */
                                           /*               Athos            */
                                           /*               Aramis           */
                                           /*               D&apos;Artagnan  */
</programlisting>
</section>

<section id="mthQueueIsEmpty"<title>isEmpty</title>
<indexterm><primary>isEmpty method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isEmpty method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isEmpty----------------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the queue
is empty.  Returns
<computeroutput>0</computeroutput> (false) otherwise.</para>
</section>

<section id="mthQueueItems"><title>items</title>
<indexterm><primary>items method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>items method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-items-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of items in the collection.</para>
</section>

<section id="mthQueueLast"<title>last</title>
<indexterm><primary>last method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>last method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-last--------------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the last item in the queue or the Nil object if the
queue is empty.</para>
</section>

<section id="mthQueueMakeArray"><title>makeArray</title>
<indexterm><primary>makeArray method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>makeArray method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-makeArray---------------------------------------------------><
]]>
</programlisting>

<para>Returns a single-index array containing the receiver queue items. The array
indexes range from <computeroutput>1</computeroutput> to the number of items.
The order in which the queue items appear in the array is the same as their
queuing order, with the head of the queue as index 1.</para>
</section>

<section id="mthQueueNext"<title>next</title>
<indexterm><primary>next method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>next method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-next(index)-------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the item that follows the queue item having index
<emphasis role="italic">index</emphasis> or returns the Nil object if the
item having that index is last in the queue.</para>
</section>

<section id="mthQueuePeek"><title>peek</title>
<indexterm><primary>peek method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>peek method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-peek--------------------------------------------------------><
]]>
</programlisting>

<para>Returns the item at the head of the queue. If the queue is empty then
the method returns the .Nil object.
The collection remains unchanged.</para>
</section>

<section id="mthQueuePrevious"<title>previous</title>
<indexterm><primary>previous method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>previous method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-previous(index)---------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the item that precedes the queue item having index
<emphasis role="italic">index</emphasis> or the Nil object if the item having
that index is first in the queue.</para>
</section>

<section id="mthQueuePull"><title>pull</title>
<indexterm><primary>pull method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>pull method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-pull--------------------------------------------------------><
]]>
</programlisting>

<para>Returns and removes the item at the head of the queue. If the queue is
empty then the method returns the .Nil object</para>
</section>

<section id="mthQueuePush"><title>push</title>
<indexterm><primary>push method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>push method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-push(item)--------------------------------------------------><
]]>
</programlisting>

<para>Adds the object <emphasis role="italic">item</emphasis> to the head of
the queue.</para>
</section>

<section id="mthQueuePut"><title>put</title>
<indexterm><primary>put method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>put method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-put(item,index)---------------------------------------------><
]]>
</programlisting>

<para>Replaces any existing item associated with the specified
<emphasis role="italic">index</emphasis> with
the new item. If the <emphasis role="italic">index</emphasis> does not exist
in the queue, an error is raised.</para>
</section>

<section id="mthQueueQueue"><title>queue</title>
<indexterm><primary>queue method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>queue method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-queue(item)-------------------------------------------------><
]]>
</programlisting>

<para>Adds the object <emphasis role="italic">item</emphasis> to the tail of
the queue.</para>
</section>

<section id="mthQueueRemove"><title>remove</title>
<indexterm><primary>remove method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>remove method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-remove(index)-----------------------------------------------><
]]>
</programlisting>

<para>Returns and removes from a collection the member item with index
<emphasis role="italic">index</emphasis>. If no item has index
<emphasis role="italic">index</emphasis>, this method returns
the Nil object and removes no item.</para>
</section>

<section id="mthQueueRemoveItem"<title>removeItem</title>
<indexterm><primary>removeItem method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>removeItem method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-removeItem(item)--------------------------------------------><
]]>
</programlisting>

<para>Removes an item from the queue. If the target item exists at more than
one index, the first located item is removed.  The return value is the
removed item.
</para>
</section>

<section id="mthQueueSupplier"><title>supplier</title>
<indexterm><primary>supplier method</primary>
<secondary>of Queue class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>supplier method</secondary>
<tertiary>of Queue class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-supplier----------------------------------------------------><
]]>
</programlisting>

<para>Returns a supplier object for the collection. After you have obtained a
supplier, you can send it messages (see
<link linkend="clsSupplier">The Supplier Class</link>) to enumerate
all the items that were in the queue at the time of the supplier's creation.
The supplier enumerates the items in their queuing order, with the head of
the queue first.</para>
</section>
</section>

<section id="clsRelation"><title>The Relation Class</title>
<indexterm><primary>Relation class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Relation class</secondary></indexterm>
<indexterm><primary>Map Collection classes</primary>
<secondary>Relation class</secondary></indexterm>

<para>A relation is a collection with indexes that can
be any objects the user supplies. In a relation, each item is associated with
a single index, but there can be more than one item with the same index (unlike
a table, which can contain only one item for any index).</para>
<figure><title>The Relation class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxRelationClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Relation class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.
It also inherits methods from the <link linkend="clsMapCollection">Map Collection
class</link>, although there are not currently any methods defined in that class.
</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;
&collclsmthods;
&mcollclsmthods;

</section>

<section id="mthRelationNew"><title>new (Class Method)</title>
<indexterm><primary>new method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new---------------------------------------------------------><
]]>
</programlisting>

<para>This method overrides the
<link linkend="mthObjectNew">new class method</link> from the
<link linkend="clsObject">Object class</link>.</para>
<para>Returns an empty Relation object.</para>
</section>

<section id="mthRelationAtGet"><title>[]</title>
<indexterm><primary>[] method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[] method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-[index]-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the same item as the
<emphasis role="bold">at</emphasis> method. See
<link linkend="mthRelationAt">at</link>.</para>
</section>

<section id="mthRelationPutSet"><title>[]=</title>
<indexterm><primary>[]= method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[]= method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-[index]=item------------------------------------------------><
]]>
</programlisting>

<para>This method is the same as the
<emphasis role="bold">put</emphasis> method. See
<link linkend="mthRelationPut">put</link>.</para>
</section>

<section id="mthRelationAllAt"><title>allAt</title>
<indexterm><primary>allAt method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allAt method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allAt(index)------------------------------------------------><
]]>
</programlisting>

<para>Returns a single-index array containing all the items associated with
index <emphasis role="italic">index</emphasis>. The indexes of the returned
array range from <computeroutput>1</computeroutput> to the
number of items. Items in the array appear in an unspecified order.</para>
</section>

<section id="mthRelationAllIndex"><title>allIndex</title>
<indexterm><primary>allIndex method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allIndex method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allIndex(item)----------------------------------------------><
]]>
</programlisting>

<para>Returns a single-index array containing all indexes for item
<emphasis role="italic">item</emphasis>,
in an unspecified order (the program should not rely on any order).</para>
</section>

<section id="mthRelationAllIndexes"<title>allIndexes</title>
<indexterm><primary>allIndexes method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allIndexes method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allIndexes---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all indices contained in the Relation. If the Relation
contains multiple indices of the same value the duplicates will be eliminated
from the returned array.</para>
</section>

<section id="mthRelationAllItems"<title>allItems</title>
<indexterm><primary>allItems method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allItems method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allItems---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all items contained in the relation.</para>
</section>

<section id="mthRelationAt"><title>at</title>
<indexterm><primary>at method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>at method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-at(index)---------------------------------------------------><
]]>
</programlisting>

<para>Returns the item associated with index
<emphasis role="italic">index</emphasis>. If the relation
contains more than one item associated with index
<emphasis role="italic">index</emphasis>, the item
returned is unspecified. (The program should not rely on any particular item
being returned.) If the relation has no item associated with index
<emphasis role="italic">index</emphasis>, this method returns the Nil object.</para>
</section>

<section id="mthRelationDifference"><title>difference</title>
<indexterm><primary>differencemethod</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>difference method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-difference(argument)----------------------------------------><
]]>
</programlisting>

<para>Returns a new collection (of the same class as the receiver) containing
only those items that the <emphasis role="italic">argument</emphasis>
collection does not contain (with the same associated index). The
<emphasis role="italic">argument</emphasis> can be any
collection class object.</para>
</section>

<section id="mthRelationEmpty"<title>empty</title>
<indexterm><primary>empty method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>empty method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-empty-------------------------------------------------------><
]]>
</programlisting>

<para>Removes all items from the relation.</para>
</section>

<section id="mthRelationHasIndex"><title>hasIndex</title>
<indexterm><primary>hasIndex method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasIndex method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasIndex(index)---------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the collection
contains any item associated with index
<emphasis role="italic">index</emphasis>, or <computeroutput>0</computeroutput>
(false).</para>
</section>

<section id="mthRelationHasItem"><title>hasItem</title>
<indexterm><primary>hasItem method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasItem method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasItem(item,index)-----------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the relation
contains the member item <emphasis role="italic">item</emphasis>
(associated with index <emphasis role="italic">index</emphasis>, or
<computeroutput>0</computeroutput> (false).</para>
</section>

<section id="mthRelationIndex"><title>index</title>
<indexterm><primary>index method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>index method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-index(item)-------------------------------------------------><
]]>
</programlisting>

<para>Returns the index for item <emphasis role="italic">item</emphasis>.
If there is more than one index associated with item
<emphasis role="italic">item</emphasis>, the one this method returns is not
defined.</para>
</section>

<section id="mthRelationIntersection"><title>intersection</title>
<indexterm><primary>intersection method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>intersection method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-intersection(argument)--------------------------------------><
]]>
</programlisting>

<para>Returns a new collection (of the same class as the receiver) containing
only those items that are in both the receiver collection
and the <emphasis role="italic">argument</emphasis> collection with the
same associated index. The <emphasis role="italic">argument</emphasis>
can be any collection class object.</para>
</section>

<section id="mthRelationIsEmpty"<title>isEmpty</title>
<indexterm><primary>isEmpty method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isEmpty method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isEmpty----------------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the relation
is empty.  Returns
<computeroutput>0</computeroutput> (false) otherwise.</para>
</section>

<section id="mthRelationItems"><title>items</title>
<indexterm><primary>items method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>items method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-items-+---------+-------------------------------------------><
         +-(index)-+
]]>
</programlisting>

<para>Returns the number of relation items with index
<emphasis role="italic">index</emphasis>. If you
specify no <emphasis role="italic">index</emphasis>, this method returns the
total number of items associated with all indexes in the relation.</para>
</section>

<section id="mthRelationMakeArray"><title>makeArray</title>
<indexterm><primary>makeArray method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>makeArray method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-makeArray---------------------------------------------------><
]]>
</programlisting>

<para>Returns a single-index array containing the index objects. The array
indexes range from <computeroutput>1</computeroutput> to the number of items.
The collection items appear in the array in an unspecified order. (The program
should not rely on any order.)</para>
</section>

<section id="mthRelationPut"><title>put</title>
<indexterm><primary>put method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>put method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-put(item,index)---------------------------------------------><
]]>
</programlisting>

<para>Makes the object <emphasis role="italic">item</emphasis>
a member item of the relation and associates it with index
<emphasis role="italic">index</emphasis>. If the relation already contains
any items with index
<emphasis role="italic">index</emphasis>, this method adds a new member item
<emphasis role="italic">item</emphasis> with
the same index, without removing any existing member items.</para>
</section>

<section id="mthRelationRemove"><title>remove</title>
<indexterm><primary>remove method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>remove method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-remove(index)-----------------------------------------------><
]]>
</programlisting>

<para>Returns and removes from a relation the member item with index
<emphasis role="italic">index</emphasis>. If the relation contains more than
one item associated with index <emphasis role="italic">index</emphasis>,
the item returned and removed is unspecified. If no item has index
<emphasis role="italic">index</emphasis>, this method returns the NIL object
and removes nothing.</para>
</section>

<section id="mthRelationRemoveItem"><title>removeItem</title>
<indexterm><primary>removeItem method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>removeItem method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-removeItem(item,index)--------------------------------------><
]]>
</programlisting>

<para>Returns and removes from a relation the member item
<emphasis role="italic">item</emphasis> (associated with index
<emphasis role="italic">index</emphasis>). If
<emphasis role="italic">value</emphasis> is not a member item associated
with index <emphasis role="italic">index</emphasis>, this method returns
the Nil object and removes no item. If
<emphasis role="italic">item</emphasis> is the only member with
<emphasis role="italic">index</emphasis>) then the
<emphasis role="italic">index</emphasis>) is also removed from the Relation.
</para>
</section>

<section id="mthRelationSubset"><title>subset</title>
<indexterm><primary>subset method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>subset method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-subset(argument)--------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if all items in the
receiver collection are also contained in the
<emphasis role="italic">argument</emphasis> collection with the same associated
index; returns <computeroutput>0</computeroutput> (false) otherwise. The
<emphasis role="italic">argument</emphasis> can be any
collection class object.</para>
</section>

<section id="mthRelationSupplier"><title>supplier</title>
<indexterm><primary>supplier method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>supplier method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-supplier--+---------+---------------------------------------><
             +-(index)-+
]]>
</programlisting>

<para>Returns a supplier object for the collection. After you have obtained a
supplier, you can send it messages (see
<link linkend="clsSupplier">The Supplier Class</link>) to enumerate
all the items that were in the collection at the time of the supplier's
creation. The supplier enumerates the items in an unspecified order. (The
program should not rely on any order.) If you specify
<emphasis role="italic">index</emphasis>, the
supplier enumerates all of the items in the relation with the specified index.
</para>
</section>

<section id="mthRelationUnion"><title>union</title>
<indexterm><primary>union method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>union method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-union(argument)---------------------------------------------><
]]>
</programlisting>

<para>Returns a new collection containing all items from the receiver collection
and the <emphasis role="italic">argument</emphasis> collection. The
<emphasis role="italic">argument</emphasis> can be any
collection class object.</para>
</section>

<section id="mthRelationXor"><title>xor</title>
<indexterm><primary>xor method</primary>
<secondary>of Relation class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>xor method</secondary>
<tertiary>of Relation class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-xor(argument)-----------------------------------------------><
]]>
</programlisting>

<para>Returns a new collection of the same class as the receiver that contains
all items from the receiver collection and the
<emphasis role="italic">argument</emphasis> collection.
All index-item pairs that appear in both collections are removed. The
<emphasis role="italic">argument</emphasis> can be any
collection class object.</para>
</section>

<section id="relex"><title>Examples</title>
<indexterm><primary>examples</primary>
<secondary>of Relation class</secondary></indexterm>
<programlisting>
/* Use a relation to express parent-child relationships */
family = .relation~new
family["Henry"] = "Peter"    /* Peter is Henry&apos;s child   */
family["Peter"] = "Bridget"  /* Bridget is Peter&apos;s child */
family["Henry"] = "Jane"     /* Jane is Henry&apos;s child    */

/* Show all children of Henry recorded in the family relation */
henrys_kids = family~allAt("Henry")
Say "Here are all the listed children of Henry:"
Do kid Over henrys_kids
  Say " "kid
End

/* Show all parents of Bridget recorded in the family relation */
bridgets_parents = family~allIndex("Bridget")
Say "Here are all the listed parents of Bridget:"
Do parent Over bridgets_parents
  Say " "parent
End

/* Display all the grandparent relationships we know about. */
checked_for_grandkids = .set~new         /* Records those we have checked      */
Do grandparent Over family               /* Iterate for each index in family   */
  If checked_for_grandkids~hasIndex(grandparent)
    Then Iterate                         /* Already checked this one           */
  kids = family~allat(grandparent)       /* Current grandparent&apos;s children     */
  Do kid Over kids                       /* Iterate for each item in kids      */
    grandkids = family~allAt(kid)        /* Current kid&apos;s children             */
    Do grandkid Over grandkids           /* Iterate for each item in grandkids */
      Say grandparent "has a grandchild named" grandkid"."
    End
  End
  checked_for_grandkids~put(grandparent) /* Add to already-checked set         */
End
</programlisting>
</section>
</section>

<section id="clsSet"><title>The Set Class</title>
<indexterm><primary>Set class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Set class</secondary></indexterm>
<indexterm><primary>Set Collection classes</primary>
<secondary>Set class</secondary></indexterm>

<para>A set is a collection containing the member items
where the index is the same as the item. Any object can be placed in a set.
 There can be only one occurrence of any object in a set. </para>
<figure><title>The Set class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxSetClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Set class also has available class methods that its metaclass,
the <link linkend="clsClass">Class class</link>, defines.
It also inherits methods from the <link linkend="clsSetCollection">Set Collection
class</link>, although there are not currently any methods defined in that class.
</para></note>
<para>The Set class is a subclass of the Table class. In addition to its own
methods, it inherits the methods of the Object class (see
<link linkend="clsObject">The Object Class</link>)
and the Table class.</para>

<section><title>Inherited Methods</title>

&objclsmthods;
&collclsmthods;
&mcollclsmthods;

<para>Methods inherited from the
<link linkend="clsTable">Table class</link>.</para>
<simplelist type="vert" columns="3">
<member><link linkend="mthTableNew">new (class method)</link></member>
<member><link linkend="mthTableAllIndexes">allIndexes</link></member>
<member><link linkend="mthTableAllItems">allItems</link></member>
<member><link linkend="mthTableAt">at</link></member>
<member><link linkend="mthTableAtGet">[ ]</link></member>
<member><link linkend="mthTableEmpty">empty</link></member>
<member><link linkend="mthTableHasIndex">hasIndex</link></member>
<member><link linkend="mthTableHasItem">hasItem</link></member>
<member><link linkend="mthTableIndex">index</link></member>
<member><link linkend="mthTableIsEmpty">isEmpty</link></member>
<member><link linkend="mthTableItems">items</link></member>
<member><link linkend="mthTableMakeArray">makeArray</link></member>
<member><link linkend="mthTablePut">put</link></member>
<member><link linkend="mthTablePutSet">[ ]=</link></member>
<member><link linkend="mthTableRemove">remove</link></member>
<member><link linkend="mthTableRemoveItem">removeItem</link></member>
<member><link linkend="mthTableSupplier">supplier</link></member>
</simplelist>

</section>

<section id="mthSetPutSet"><title>[]=</title>
<indexterm><primary>[]= method</primary>
<secondary>of Set class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[]= method</secondary>
<tertiary>of Set class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-[index]=item------------------------------------------------><
]]>
</programlisting>

<para>This method is the same as the
<emphasis role="bold">put</emphasis> method. See
<link linkend="mthSetPut">put</link>.</para>
</section>

<section id="mthSetOf"><title>of (Class Method)</title>
<indexterm><primary>of method</primary>
<secondary>of Set class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>of method</secondary>
<tertiary>of Set class</tertiary></indexterm>
<programlisting>
<![CDATA[
       +-,----+
       V      |
>>-of(---item-+-)----------------------------------------------><
]]>
</programlisting>

<para>Returns a newly created set containing the specified
<emphasis role="italic">item</emphasis> objects.</para>
</section>

<section id="mthSetIntersection"<title>intersection</title>
<indexterm><primary>intersection method</primary>
<secondary>of Set class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>intersection method</secondary>
<tertiary>of Set class</tertiary></indexterm>

<para>This method overrides the
<link linkend="mthCollectionIntersection">intersection method</link> from the
<link linkend="clsCollection">Collection class</link>.</para>
<programlisting>
<![CDATA[
>>-intersection(argument)--------------------------------------><
]]>
</programlisting>

<para>Returns a new collection (of the same class as the receiver) containing
only those items from the receiver whose indexes are in both the receiver
collection and the <emphasis role="italic">argument</emphasis> collection.
The <emphasis role="italic">argument</emphasis> can be any
collection class object.
The <emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>

<section id="mthSetPut"><title>put</title>
<indexterm><primary>put method</primary>
<secondary>of Set class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>put method</secondary>
<tertiary>of Set class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-put(item,index)---------------------------------------------><
]]>
</programlisting>

<para>Makes the object <emphasis role="italic">item</emphasis>
a member item of the collection and associates it with index
<emphasis role="italic">index</emphasis>. The new item replaces any existing
items associated with index <emphasis role="italic">index</emphasis>.</para>
</section>

<section id="mthSetPutAll"<title>putAll</title>
<indexterm><primary>putAll method</primary>
<secondary>of Set class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>putAll method</secondary>
<tertiary>of Set class</tertiary></indexterm>

<para>This method overrides the
<link linkend="mthMapCollectionPutAll">putAll method</link> from the
<link linkend="clsMapCollection">Map Collection class</link>.</para>
<programlisting>
<![CDATA[
>>-putAll(collection)---------------------------------------><
]]>
</programlisting>
<para>Adds all items <emphasis role="italic">collection</emphasis> to the target set.  The
<emphasis role="italic">collection</emphasis> argument can be any object that supports a supplier
method.  Items from <emphasis role="italic">collection</emphasis> are added using the index values
returned by the supplier.
The items are
added in the order provided by the supplier object.
If duplicate
indexes exist in <emphasis role="italic">collection</emphasis>, the last item provided by the
supplier will overwrite previous items with the same index.
</para>
</section>

<section id="mthSetSubset"<title>subset</title>
<indexterm><primary>putAll method</primary>
<secondary>of Set class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>subset method</secondary>
<tertiary>of Set class</tertiary></indexterm>

<para>This method overrides the
<link linkend="mthCollectionSubset">subset method</link> from the
<link linkend="clsCollection">Collection class</link>.</para>
<programlisting>
<![CDATA[
>>-subset(argument)--------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if all indexes in the
receiver collection are also contained in the
<emphasis role="italic">argument</emphasis> collection; returns
<computeroutput>0</computeroutput> (false) otherwise. The
<emphasis role="italic">argument</emphasis> can be any
collection class object.
The <emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>

<section id="mthSetUnion"<title>union</title>
<indexterm><primary>union method</primary>
<secondary>of Set class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>union method</secondary>
<tertiary>of Set class</tertiary></indexterm>

<para>This method overrides the
<link linkend="mthCollectionUnion">union method</link> from the
<link linkend="clsCollection">Collection class</link>.</para>
<programlisting>
<![CDATA[
>>-union(argument)---------------------------------------------><
]]>
</programlisting>

<para>Returns a new collection of the same class as the receiver that contains
all the items from the receiver collection and selected items from the
<emphasis role="italic">argument</emphasis> collection. This method includes
an item from <emphasis role="italic">argument</emphasis> in
the new collection only if there is no item with the same associated index
in the receiver collection and the method has not already included an item
with the same index. The order in which this method selects items in
<emphasis role="italic">argument</emphasis> is unspecified. (The program
should not rely on any order.) See also the
<emphasis role="bold">union</emphasis> method of the Collection
(<link linkend="mthCollectionUnion">union</link>) and Relation
(<link linkend="mthRelationUnion">union</link>) classes. The
<emphasis role="italic">argument</emphasis> can be any
collection class object. The
<emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>

<section id="mthSetXor"<title>xor</title>
<indexterm><primary>xor method</primary>
<secondary>of Set class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>xor method</secondary>
<tertiary>of Set class</tertiary></indexterm>

<para>This method overrides the
<link linkend="mthCollectionXor">xor method</link> from the
<link linkend="clsCollection">Collection class</link>.</para>
<programlisting>
<![CDATA[
>>-xor(argument)-----------------------------------------------><
]]>
</programlisting>

<para>Returns a new collection of the same class as the receiver that contains
all items from the receiver collection and the
<emphasis role="italic">argument</emphasis> collection;
all indexes that appear in both collections are removed. The
<emphasis role="italic">argument</emphasis> can be any
collection class object.
The <emphasis role="italic">argument</emphasis> must also allow all of the
index values in the receiver collection.</para>
</section>
</section>

<section id="clsStem"><title>The Stem Class</title>
<indexterm><primary>Stem class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Stem class</secondary></indexterm>
<indexterm><primary>Map Collection classes</primary>
<secondary>Stem class</secondary></indexterm>

<para>A stem object is a collection with unique indexes
that are character strings.</para>
<figure><title>The Stem class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxStemClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Stem class also has available class methods that its metaclass,
the <link linkend="clsClass">Class class</link>, defines.
It also inherits methods from the <link linkend="clsMapCollection">Map Collection
class</link>, although there are not currently any methods defined in that class.
</para></note>
<para>Stems are automatically created whenever a Rexx stem variable or Rexx
compound variable is used. For example: </para>
<programlisting>
a.1 = 2
</programlisting>
<para>creates a new stem collection with the name <computeroutput>A.</computeroutput>
and assigns it to the Rexx variable <computeroutput>A.</computeroutput>; it also assigns
the value 2 to entry 1 in the collection.</para>
<para>The value of an uninitialied stem index is the stem object NAME
concatenated with the derived stem index.  For
example</para>
<programlisting>
say a.[1,2]  -- implcitly creates stem object with name "A."
-- displays "A.1.2"

a = .stem~new("B.")
say a[1,2]     -- displays "B.1.2"
</programlisting>
<para>In addition to the items explicitly assigned to the
collection indexes,
a value may be assigned to all possible stem indexes.  The
<computeroutput>[]=</computeroutput> method (with no index argument)
will assign the target value to all possible stem indexes.
Following assignment, a reference to any index will return the new value until
another value is assigned or the index is dropped.</para>
<para>The <computeroutput>[]</computeroutput> method (with no index specified) will retrieve any
globally assigned value.  By default, this
returns the stem NAME value.</para>
<para>In addition to the methods defined in the following, the Stem class removes
the methods =, ==, \=, \==, &lt;>, and >&lt; using the DEFINE method.</para>

<section><title>Inherited Methods</title>

&objclsmthods;
&collclsmthods;
&mcollclsmthods;

</section>

<section id="mthStemNew"><title>new (Class Method)</title>
<indexterm><primary>new method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new-+--------+----------------------------------------------><
       +-(name)-+
]]>
</programlisting>

<para>This method overrides the
<link linkend="mthObjectNew">new class method</link> from the
<link linkend="clsObject">Object class</link>.</para>
<para>Returns a new stem object. If you specify a string
<emphasis role="italic">name</emphasis>, this
value is used to create the derived name of compound variables. The default
stem name is a null string.</para>
</section>

<section id="mthStemAtGet"><title>[]</title>
<indexterm><primary>[] method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[] method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
     +-,---------+
     V           |
>>-[---+-------+-+-]-------------------------------------------><
       +-index-+
]]>
</programlisting>

<para>Returns the item associated with the specified
<emphasis role="italic">index</emphasis>es. Each
<emphasis role="italic">index</emphasis> is an expression; use commas to
separate the expressions. The language processor concatenates the
<emphasis role="italic">index</emphasis> expression string values, separating
them with a period (.), to create a derived index. A null string (&quot;&quot;)
is used for any omitted expressions. The resulting string references the stem
item. If the stem has no item associated with the specified final
<emphasis role="italic">index</emphasis>, the stem default value is returned.
If a default value has not been
set, the stem name concatenated with the final index string is returned.</para>
<para>If you do not specify <emphasis role="italic">index</emphasis>, the stem
default value is returned.
If no default value has been assigned, the stem name is returned. </para>

<note><title>Note</title>
<para>You cannot use the [] method in a DROP or PROCEDURE instruction
or in a parsing template.</para></note>
</section>

<section id="mthStemPutSet"><title>[]=</title>
<indexterm><primary>[]= method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[]= method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
     +-,---------+
     V           |
>>-[---+-------+-+-]=value-------------------------------------><
       +-index-+
]]>
</programlisting>

<para>Makes the value a member item of the stem collection and associates it
with the specified index. If you specify no
<emphasis role="italic">index</emphasis> expressions, a
new default stem value is assigned. Assigning a new default value will
re-initialize the stem and remove all existing assigned indexes.</para>
</section>

<section id="mthStemAllIndexes"<title>allIndexes</title>
<indexterm><primary>allIndexes method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allIndexes method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allIndexes---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all the stem tail names used in the stem.</para>
</section>

<section id="mthStemAllItems"<title>allItems</title>
<indexterm><primary>allItems method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allItems method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allItems---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all items contained in the stem.</para>
</section>

<section id="mthStemAt"<title>at</title>
<indexterm><primary>at method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>at method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-at(tail)----------------------------------------------------><
]]>
</programlisting>

<para>Returns the item associated with the specified
<emphasis role="italic">tail</emphasis>. If the stem has no item associated
with the specified <emphasis role="italic">tail</emphasis>
this method returns the Nil object.</para>
</section>

<section id="mthStemEmpty"<title>empty</title>
<indexterm><primary>empty method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>empty method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-empty-------------------------------------------------------><
]]>
</programlisting>

<para>Removes all items from the stem.</para>
</section>

<section id="mthStemHasIndex"<title>hasIndex</title>
<indexterm><primary>hasIndex method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasIndex method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasIndex(tail)----------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the collection
contains any item associated with a stem tail
<emphasis role="italic">tail</emphasis>,
or <computeroutput>0</computeroutput> (false).</para>
</section>

<section id="mthStemHasItem"<title>hasItem</title>
<indexterm><primary>hasItem method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasItem method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasItem(value)----------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the collection
contains the <emphasis role="italic">value</emphasis> at any tail position or
otherwise returns <computeroutput>0</computeroutput> (false).</para>
</section>

<section id="mthStemIndex"<title>index</title>
<indexterm><primary>index method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>index method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-index(item)------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the specified item within the stem.
If the stem does not contain the specified item, .nil is
returned.
</para>
</section>

<section id="mthStemIsEmpty"<title>isEmpty</title>
<indexterm><primary>isEmpty method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isEmpty method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isEmpty----------------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the stem
is empty.  Returns
<computeroutput>0</computeroutput> (false) otherwise.</para>
</section>

<section id="mthStemItems"<title>items</title>
<indexterm><primary>items method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>items method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-items-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of items in the collection.</para>
</section>

<section id="mthStemMakeArray"><title>makeArray</title>
<indexterm><primary>makeArray method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>makeArray method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-makeArray---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all stem indexes that currently have an associated
value. The items appear in the array in an unspecified order.  (The program
should not rely on any order.)</para>
</section>

<section id="mthStemPut"<title>put</title>
<indexterm><primary>put method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>put method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-put(item,tail)----------------------------------------------><
]]>
</programlisting>

<para>Replaces any existing item associated with the specified
<emphasis role="italic">tail</emphasis> with
the new item <emphasis role="italic">item</emphasis>. If the
<emphasis role="italic">tail</emphasis> does not exist in the stem,
an error is raised.</para>
</section>

<section id="mthStemRemove"<title>remove</title>
<indexterm><primary>remove method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>remove method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-remove(tail)------------------------------------------------><
]]>
</programlisting>

<para>Returns and removes from the stem the member item with index
<emphasis role="italic">tail</emphasis>. If no item has index
<emphasis role="italic">tail</emphasis>, this method returns
the Nil object and removes no item.</para>
</section>

<section id="mthStemRemoveItem"<title>removeItem</title>
<indexterm><primary>removeItem method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>removeItem method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-removeItem(item)--------------------------------------------><
]]>
</programlisting>

<para>Removes an item from the stem. If the target item exists at more than
one tail, the first located item is removed.  The return value is the
removed item.
</para>
</section>

<section id="mthStemRequest"><title>request</title>
<indexterm><primary>request method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>request method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-request(classid)--------------------------------------------><
]]>
</programlisting>

<para>Returns the result of the Stem class
<emphasis role="bold">makeArray</emphasis> method, if the requested
class is Array. For all other classes,
<emphasis role="bold">request</emphasis> forwards the message to the
default value of the stem and returns this result. This method requests
conversion to a specific class. All conversion requests except Array are
forwarded to the current stem default value.</para>
</section>

<section id="mthStemSupplier"<title>supplier</title>
<indexterm><primary>supplier method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>supplier method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-supplier----------------------------------------------------><
]]>
</programlisting>

<para>Returns a supplier object for the stem. After you have obtained a
supplier, you can send it messages (see
<link linkend="clsSupplier">The Supplier Class</link>) to enumerate
all the items that were in the stem at the time of the supplier's
creation. The supplier enumerates the items in an unspecified order. (The
program should not rely on any order.)</para>
</section>

<section id="mthStemUnknown"><title>unknown</title>
<indexterm><primary>unknown method</primary>
<secondary>of Stem class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>unknown method</secondary>
<tertiary>of Stem class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-unknown-(messagename,messageargs)---------------------------><
]]>
</programlisting>

<para>Reissues or forwards to the current stem default value all unknown
messages sent to a stem collection. For additional information, see
<link linkend="unkno">Defining an unknown Method</link>.</para>
</section>
</section>

<section id="clsTable"><title>The Table Class</title>
<indexterm><primary>Table class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>Table class</secondary></indexterm>
<indexterm><primary>Map Collection classes</primary>
<secondary>Table class</secondary></indexterm>

<para>A table is a collection with indexes
that can be any object the user supplies. In a table, each item is associated
with a single index, and there can be only one item for each index (unlike
a relation, which can contain more than one item with the same index).</para>
<figure><title>The Table class and methods</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="ooRexxTableClass.png" align="left">
</imageobject>
</mediaobject>
</figure>
<note><title>Note</title>
<para>The Table class also has available class methods that its
metaclass, the <link linkend="clsClass">Class class</link>, defines.
It also inherits methods from the <link linkend="clsMapCollection">Map Collection
class</link>, although there are not currently any methods defined in that class.
</para></note>

<section><title>Inherited Methods</title>

&objclsmthods;
&collclsmthods;
&mcollclsmthods;

</section>

<section id="mthTableNew"><title>new (Class Method)</title>
<indexterm><primary>new method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new---------------------------------------------------------><
]]>
</programlisting>

<para>This method overrides the
<link linkend="mthObjectNew">new class method</link> from the
<link linkend="clsObject">Object class</link>.</para>
<para>Returns an empty Table object.</para>
</section>

<section id="mthTableAtGet"><title>[]</title>
<indexterm><primary>[] method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[] method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-[index]-----------------------------------------------------><
]]>
</programlisting>

<para>Returns the same item as the
<emphasis role="bold">at</emphasis> method. See
<link linkend="mthTableAt">at</link>.</para>
</section>

<section id="mthTablePutSet"><title>[]=</title>
<indexterm><primary>[]= method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>[]= method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-[index]=item------------------------------------------------><
]]>
</programlisting>

<para>This method is the same as the
<emphasis role="bold">put</emphasis> method. See
<link linkend="mthTablePut">put</link>.</para>
</section>

<section id="mthTableAllIndexes"<title>allIndexes</title>
<indexterm><primary>allIndexes method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allIndexes method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allIndexes---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all indices contained in the table.</para>
</section>

<section id="mthTableAllItems"<title>allItems</title>
<indexterm><primary>allItems method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>allItems method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-allItems---------------------------------------------------><
]]>
</programlisting>

<para>Returns an array of all items contained in the table.</para>
</section>

<section id="mthTableAt"><title>at</title>
<indexterm><primary>at method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>at method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-at(index)---------------------------------------------------><
]]>
</programlisting>

<para>Returns the item associated with index
<emphasis role="italic">index</emphasis>. If the collection
has no item associated with <emphasis role="italic">index</emphasis>, this
method returns the Nil object.</para>
</section>

<section id="mthTableEmpty"<title>empty</title>
<indexterm><primary>difference method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>empty method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-empty-------------------------------------------------------><
]]>
</programlisting>

<para>Removes all items from the table.</para>
</section>

<section id="mthTableHasIndex"><title>hasIndex</title>
<indexterm><primary>hasIndex method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasIndex method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasIndex(index)---------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the collection
contains any item associated with index <emphasis role="italic">index</emphasis>,
or <computeroutput>0</computeroutput> (false).</para>
</section>

<section id="mthTableHasItem"<title>hasItem</title>
<indexterm><primary>hasItem method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hasItem method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hasItem(value)----------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the collection
contains the <emphasis role="italic">value</emphasis> at any index position or
otherwise returns <computeroutput>0</computeroutput> (false).</para>
</section>

<section id="mthTableIndex"<title>index</title>
<indexterm><primary>index method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>index method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-index(item)------------------------------------------------><
]]>
</programlisting>

<para>Returns the index of the specified item within the table.  If the
target item appears at more than one index, the first located index will
be returned.  If the table does not contain the specified item, .nil is
returned.
</para>
</section>

<section id="mthTableIsEmpty"<title>isEmpty</title>
<indexterm><primary>isEmpty method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isEmpty method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isEmpty----------------------------------------------------><
]]>
</programlisting>

<para>Returns <computeroutput>1</computeroutput> (true) if the table
is empty.  Returns
<computeroutput>0</computeroutput> (false) otherwise.</para>
</section>

<section id="mthTableItems"><title>items</title>
<indexterm><primary>items method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>items method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-items-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of items in the collection.</para>
</section>

<section id="mthTableMakeArray"><title>makeArray</title>
<indexterm><primary>makeArray method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>makeArray method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-makeArray---------------------------------------------------><
]]>
</programlisting>

<para>Returns a single-index array containing the index objects. The array
indexes range from <computeroutput>1</computeroutput> to the number of items.
The collection items appear in the array in an unspecified order. (The program
should not rely on any order.)</para>
</section>

<section id="mthTablePut"><title>put</title>
<indexterm><primary>put method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>put method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-put(item,index)---------------------------------------------><
]]>
</programlisting>

<para>Makes the object <emphasis role="italic">item</emphasis>
a member item of the collection and associates it with index
<emphasis role="italic">index</emphasis>. The new item replaces any existing
items associated with index <emphasis role="italic">index</emphasis>.</para>
</section>

<section id="mthTableRemove"><title>remove</title>
<indexterm><primary>remove method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>remove method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-remove(index)-----------------------------------------------><
]]>
</programlisting>

<para>Returns and removes from a collection the member item with index
<emphasis role="italic">index</emphasis>. If no item has index
<emphasis role="italic">index</emphasis>, this method returns
the Nil object and removes no item.</para>
</section>

<section id="mthTableRemoveItem"<title>removeItem</title>
<indexterm><primary>removeItem method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>removeItem method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-removeItem(item)--------------------------------------------><
]]>
</programlisting>

<para>Removes an item from the table. If the target item exists at more than
one index, the first located item is removed.  The return value is the
removed item.
</para>
</section>

<section id="mthTableSupplier"><title>supplier</title>
<indexterm><primary>supplier method</primary>
<secondary>of Table class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>supplier method</secondary>
<tertiary>of Table class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-supplier----------------------------------------------------><
]]>
</programlisting>

<para>Returns a supplier object for the collection. After you have obtained a
supplier, you can send it messages (see
<link linkend="clsSupplier">The Supplier Class</link>) to enumerate
all the items that were in the collection at the time of the supplier's
creation. The supplier enumerates the items in an unspecified order. (The
program should not rely on any order.)</para>
</section>
</section>

<section id="sortarray"><title>Sorting Arrays</title>
<para>Any non-sparse Array instance can have its elements placed into sorted order using the
<emphasis role="bold">sort</emphasis> method of the Array class.  The simplest sort is
sorting an array of strings.  For example:</para>
<programlisting>
myArray = .array~of("Zoe", "Fred", "Xavier", "Andy")
myArray~sort

do name over myArray
   say name
end
</programlisting>
<para>will display the names in the order "Andy", "Fred", "Xavier", "Zoe".</para>
<para>The <emphasis role="bold">sort</emphasis> method orders the strings by using the
<emphasis role="bold">compareTo</emphasis> method of the String class.  The
<emphasis role="bold">compareTo</emphasis> method knows how to compare one string to another, and
returns the values -1 (less than), 0 (equal), or 1 (greater than) to indicate the relative ordering
of the two strings.</para>
<section id="sortcomparable"><title>Sorting non-strings</title>
<para>Sorting is not limited to string value.  Any object that inherits the Comparable mixin class and
implements a <emphasis role="bold">compareTo</emphasis> method can be sorted.  For example, consider the
following simple class:</para>
<programlisting>
    ::class Employee inherit Comparable
    ::method init
      expose id name
      use arg id, name
    ::method id attribute
    ::method name attribute
    ::method compareTo
      expose id
      use arg other
      return id~compareTo(other~id)  -- comparison performed using employee id
    ::method string
      expose name
      use arg name
      return "Employee" name
</programlisting>
<para>The Employee class implements its sort order using the employee identification number.  When the
<emphasis role="bold">sort</emphasis> method needs to compare two Employee instances, it will call the
<emphasis role="bold">compareTo</emphasis> method on one of the instances, passing the second instance as an argument.
The <emphasis role="bold">compareTo</emphasis> method tells the <emphasis role="bold">sort</emphasis> method
which of the two instances should be first.</para>
<programlisting>
    a = .array~new
    a[1] = .Employee~new(654321, "Fred")
    a[2] = .Employee~new(123456, "George")
    a[3] = .Employee~new(333333, "William")

    a~sort

    do employee over a
       say employee    -- sorted order is "George", "William", "Fred"
    end
</programlisting>
</section>
<section id="sortcomparator"><title>Sorting with more than one order</title>
<para>The String class <emphasis role="bold">compareTo</emphasis> method only implements a sort ordering for an ascending
sort using a strict comparison.  Frequently it's desirable to override a class-defined sort order or even to sort
items that do not implement a <emphasis role="bold">compareTo</emphasis> method.  To change the sorting criteria,
use the Array <emphasis role="bold">sortWith</emphasis> method.  The <emphasis role="bold">sortWith</emphasis>
method takes a single argument, which is a Comparator that implements a <emphasis role="bold">compare</emphasis>
method.  The <emphasis role="bold">compare</emphasis> method performs comparisons between pairs of items.  Different
comparators can be customized for different comparison purposes.  For example, the Rexx language provides a
DescendingComparator class that will sort items into descending order:</para>
<programlisting>
::CLASS 'DescendingComparator' MIXINCLASS Comparator
::METHOD compare
use strict arg left, right
return -left~compareTo(right)
</programlisting>
<para>The DescendingComparator merely inverts the result returned by the item
<emphasis role="bold">compareTo</emphasis> method.  Our previous example</para>
<programlisting>
myArray = .array~of("Zoe", "Fred", "Xavier", "Andy")
myArray~sortWith(.DescendingComparator~new)

do name over myArray
   say name
end
</programlisting>
<para>now displays in the order "Zoe", "Xavier", "Fred", "Andy".</para>
<para>Custom Comparators are simple to create for any sorting purpose.  The only requirement is a
<emphasis role="bold">compare</emphasis> method that knows how to compare pairs of items in some particular
manner.  For example, to sort our Employee class by name rather employee id, we can use the following
simple comparator class:</para>
<programlisting>
::CLASS EmployeeNameSorter MIXINCLASS Comparator
::METHOD compare
  use strict arg left, right
  return left~name~compareTo(right~name)  -- do the comparison using the names
</programlisting>
</section>
<section id="ltcomparators"><title>Builtin Comparators</title>
<para>ooRexx includes a number of builtin Comparators for common sorting operations.</para>
<variablelist>
    <varlistentry>
        <term>Comparator</term>
        <listitem><para>Base comparator.  The Comparator class just uses the <emphasis role="bold">compareTo</emphasis>
        method of the first argument to generate the result.  Using <emphasis role="bold">sortWith</emphasis>
        and a Comparator instance is equivalent to using the <emphasis role="bold">sort</emphasis> method and
        no comparator.
        </para></listitem>
    </varlistentry>
    <varlistentry>
        <term>DescendingComparator</term>
        <listitem><para>The reverse of the Comparator class.
        The DescendingComparator can be used to sort items in descending order.
        </para></listitem>
    </varlistentry>
    <varlistentry>
        <term>InvertingComparator</term>
        <listitem><para>The InvertingComparator will invert the result returned by another Comparator instance.
        This comparator can be combined with another comparator instance to reverse the Comparator sort order.
        </para></listitem>
    </varlistentry>
    <varlistentry>
        <term>CaselessComparator</term>
        <listitem><para>Like the base comparator, but uses the <emphasis role="bold">caselessCompareTo</emphasis>
        method to determine order.  The String class implements <emphasis role="bold">caselessCompareTo</emphasis>,
        so the CaselessComparator can be used to sort arrays of strings independent of case.
        </para></listitem>
    </varlistentry>
    <varlistentry>
        <term>ColumnComparator</term>
        <listitem><para>The ColumnComparator will sort string items using specific substrings within each string item.
        If sorting is performed on multiple column positions, the
        <emphasis role="bold">stableSortWith</emphasis> method is recommended to ensure the results of
        previous sort operations are retained.
        </para></listitem>
    </varlistentry>
    <varlistentry>
        <term>CaselessColumnComparator</term>
        <listitem><para>Like the ColumnComparator, but the substring comparisons are done independently of case.
        </para></listitem>
    </varlistentry>
</variablelist>
</section>
<section id="stablesort"><title>Stable and Unstable Sorts</title>
<para>The default sorting algorithm is a Quicksort.  A Quicksort is a very efficient
sorting algorithm that does not require any additional memory to implement.
Unfortunately, a Quicksort is also an <emphasis role="italic">unstable</emphasis> sort.
In an unstable sort, items are not guaranteed to maintain their original positions if they
compare equal during the sort.  Consider the following simple example:</para>
<programlisting>
a = .array~of("Fred", "George", "FRED", "Mike", "fred")
a~sortwith(.caselesscomparator~new)
do name over a
  say name
end
</programlisting>
<para>This example displays the 3 occurrences of Fred in the order "Fred", "fred", "FRED", even though they compare
equal using a caseless comparison.</para>
<para>ooRexx implements a second sort algorithm that is available using the
<emphasis role="bold">stableSort</emphasis> and <emphasis role="bold">stableSortWith</emphasis> methods.
These methods implement a Mergesort algorithm, which is less efficient than the default Quicksort, and requires
additional memory to perform the sort.  The Mergesort is a stable sort algorithm that will maintain the original
relative ordering of equivalent items.  Our example above, sorted with <emphasis role="bold">stableSortWith</emphasis>,
would display "Fred", "FRED", "fred".</para>
</section>
</section>

<section id="setop"><title>The Concept of Set Operations</title>
<indexterm><primary>examples</primary>
<secondary>set operations</secondary>
<tertiary>concepts</tertiary></indexterm>
<indexterm><primary>set-operator methods</primary></indexterm>
<para>The following sections describe the concept of set operations to help you
work with set operators, in particular if the receiver collection class differs
from the argument collection class.</para>
<para>Rexx provides the following set-operator methods:</para>
<itemizedlist>
<listitem><para>difference</para></listitem>
<listitem><para>intersection</para></listitem>
<listitem><para>subset</para></listitem>
<listitem><para>union</para></listitem>
<listitem><para>xor</para></listitem></itemizedlist>
<para>These methods are available to instances of the following collection
classes:</para>
<itemizedlist>
<listitem><para>The OrderedCollections Array, List, and Queue</para></listitem>
<listitem><para>The MapCollections Directory, Stem, Table, and Relation</para></listitem>
<listitem><para>The SetCollections Set and Bag.</para></listitem>
</itemizedlist>
<programlisting>
result = receiver~setoperator(argument)
</programlisting>
<para>where:</para>
<variablelist>
<varlistentry><term><emphasis role="italic">receiver</emphasis></term>
<listitem><para>is the collection object receiving the set-operator message.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="italic">setoperator</emphasis></term>
<listitem><para>is the set-operator method used.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="italic">argument</emphasis></term>
<listitem><para>is the argument collection supplier supplied to the method. It can be an
instance of one of the Rexx collection classes or any object that implements a
<emphasis role="bold">makearray</emphasis> method or <emphasis role="bold">supplier</emphasis> method,
depending on class of <emphasis role="italic">receiver</emphasis>.
</para></listitem></varlistentry>
</variablelist>
<para>The result object is of the same class as the <emphasis role="italic">receiver</emphasis> collection object.
</para>

<section id="princoper"><title>The Principles of Operation</title>
<indexterm><primary>examples</primary>
<secondary>set operations</secondary>
<tertiary>principals</tertiary></indexterm>
<para>A set operation is performed by iterating over the elements of the <emphasis role="italic">receiver</emphasis>
collection to compare each element of the <emphasis role="italic">receiver</emphasis> with each element
of the <emphasis role="italic">argument</emphasis> collection. The element is defined as the tuple &lt;
<emphasis role="italic">index,item</emphasis>> (see
<link linkend="idit">Determining the Identity of an Item</link>).
Depending on the set-operator method and
the result of the comparison, an element of the receiver collection is, or
is not, included in the resulting collection. A receiver collection that allows
for duplicate elements can, depending on the set-operator method, also accept
elements of the argument collection after they have been coerced to the type
of the receiver collection.</para>
<para>The following examples are to help you understand the semantics of set
operations. The collections are represented as a list of elements enclosed
in curly brackets. The list elements are separated by a comma.</para>
</section>

<section id="opercoll"><title>Set Operations on Collections without Duplicates</title>
<indexterm><primary>examples</primary>
<secondary>set operations</secondary>
<tertiary>eliminating duplicates</tertiary></indexterm>
<para>Assume that the example sets are <computeroutput>A={a,b}</computeroutput>
and <computeroutput>B={b,c,d}</computeroutput>. The result of a set operation
is another set. The only exception is a subset resulting in a Boolean .true
or .false. Using the collection <computeroutput>A</computeroutput> and
<computeroutput>B</computeroutput>, the different set operators produce the
following: </para>
<variablelist>
<varlistentry><term>UNION operation</term>
<listitem><para>All elements of <computeroutput>A</computeroutput> and
<computeroutput>B</computeroutput> are united:
<programlisting>
A UNION B = {a,b,c,d}
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>DIFFERENCE operation</term>
<listitem><para>The resulting collection contains all elements of the first set except
for those that also appear in the second set. The system iterates over the
elements of the second set and removes them from the first set one by one.
<programlisting>
A DIFFERENCE B = {a}
B DIFFERENCE A = {c,d}
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>XOR operation</term>
<listitem><para>The resulting collection contains all elements of the first set that
are not in the second set and all elements of the second set that are not
in the first set:
<programlisting>
A XOR B = {a,c,d}
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>INTERSECTION operation</term>
<listitem><para>The resulting collection contains all elements that appear in both sets:
<programlisting>
A INTERSECTION B = {b}
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>SUBSET operation</term>
<listitem><para>Returns <computeroutput>.true</computeroutput>
if the first set contains only elements that also appear in the second set,
otherwise it returns <computeroutput>.false</computeroutput>:
<programlisting>
A SUBSET B = .false
B SUBSET A = .false
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="setlike"><title>Set-Like Operations on Collections with Duplicates</title>
<indexterm><primary>examples</primary>
<secondary>set operations</secondary>
<tertiary>with duplicates</tertiary></indexterm>
<para>Assume that the example bags are
<computeroutput>A={a,b,b}</computeroutput> and
<computeroutput>B={b,b,c,c,d}</computeroutput>. The result of any set-like
operation is a collection, in this case
a bag. The only exception is
<emphasis role="bold">subset</emphasis> resulting in a Boolean .true or .false.
Using the collections <computeroutput>A</computeroutput> and
<computeroutput>B</computeroutput>, the different set-like
operators produce the following: </para>
<variablelist>
<varlistentry><term>UNION operation</term>
<listitem><para>All elements of <computeroutput>A</computeroutput> and
<computeroutput>B</computeroutput> are united:
<programlisting>
A UNION B = {a,b,b,b,b,c,c,d}
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>DIFFERENCE operation</term>
<listitem><para>The resulting collection contains all elements of the first bag except
for those that also appear in the second bag. The system iterates over the
elements of the second bag and removes them from the first bag one by one.
<programlisting>
A DIFFERENCE B = {a}
B DIFFERENCE A = {c,c,d}
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>XOR operation</term>
<listitem><para>The resulting collection contains all elements of the first
bag that are not in the second bag and all elements of the second bag that
are not in the second bag:
<programlisting>
A XOR B = {a,c,c,d}
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>INTERSECTION operation</term>
<listitem><para>The resulting collection contains all elements that appear in
both bags:
<programlisting>
A INTERSECTION B = {b,b}
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>SUBSET operation</term>
<listitem><para>Returns <computeroutput>.true</computeroutput>
if the first set contains only elements that also appear in the second set,
otherwise it returns <computeroutput>.false</computeroutput>:
<programlisting>
A SUBSET B = .false
B SUBSET A = .false
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="idit"><title>Determining the Identity of an Item</title>
<para>Set operations require the definition of the identity of an element to
determine whether a certain element exists in the receiver collection. The
element of a collection is conceived as the tuple
&lt;<emphasis role="italic">index,item</emphasis>>.
The <emphasis role="italic">index</emphasis> is used as the identification
tag associated with the item.
Depending on the collection class, the index is an instance of a particular
class, for example, the string class for a directory element, an integer for
an array, or any arbitrary class for a relation. The Array class is an exception
because it can be multidimensional having more than one index. However, as
a collection, it is conceptionally linearized by the set operator.</para>
<para>For collection classes that require unique indexes, namely
the Set, Table, Directory, and Stem, an item is identified by its
<emphasis role="italic">index</emphasis>. For collections of collection classes
that allow several items to have the same index, namely the Relation class,
an item is identified by both its <emphasis role="italic">index</emphasis>
and its <emphasis role="italic">item</emphasis>. For the Bag and the Set
subclasses, where several items can have the same index but
<emphasis role="italic">index</emphasis> and
<emphasis role="italic">item</emphasis> must
be identical, the item is identified by its
<emphasis role="italic">index</emphasis>.
For Array, List, and Queue classes, the index is derived from an object's position
within the collection's order.  Items are identified using only
<emphasis role="italic">item</emphasis>.
According to this
concept, an item of a collection is identified for the different <emphasis role="italic">receiver</emphasis>
categories as follows:</para>
<variablelist>
<varlistentry><term>Map Collection</term>
<listitem><para>If <emphasis role="italic">argument</emphasis> is a MapCollection, then
<emphasis role="italic">index</emphasis> values are used to determine membership, and items
are inserted into the result using the <emphasis role="italic">index</emphasis> and
<emphasis role="italic">item</emphasis> pairs.</para>
<para>If <emphasis role="italic">argument</emphasis> is an OrderedCollection, the
<emphasis role="italic">item</emphasis> values from <emphasis role="italic">argument</emphasis>
are used.  Items are inserted into the result using the item for both the index and the value.</para>
<para>For all other <emphasis role="italic">argument</emphasis> objects, the
<emphasis role="bold">makearray</emphasis> method is used to obtain a set of values which are
used as if <emphasis role="italic">argument</emphasis> was an OrderedCollection.</para>
</listitem></varlistentry>
<varlistentry><term>Ordered Collection and Set Collection</term>
<listitem>
<para>If <emphasis role="italic">argument</emphasis> is an instance of Collection, the
matching set is obtained from the <emphasis role="bold">allItems</emphasis> method.  For
any other class of object, the <emphasis role="bold">makearray</emphasis> method is used.
The <emphasis role="bold">hasItem</emphasis> method is used to perform the matching operations
between the two collections.</para>
</listitem></varlistentry>
<varlistentry><term>Relation</term>
<listitem><para>If <emphasis role="italic">argument</emphasis> is a MapCollection, then
<emphasis role="italic">index</emphasis> values are used to determine membership, and items
are inserted into the result using the <emphasis role="italic">index</emphasis> and
<emphasis role="italic">item</emphasis> pairs.</para>
<para>If <emphasis role="italic">argument</emphasis> is an OrderedCollection, the
<emphasis role="italic">item</emphasis> values from <emphasis role="italic">argument</emphasis>
are used.  Items are inserted into the result using the item for both the index and the value.</para>
<para>For all other <emphasis role="italic">argument</emphasis> objects, the
<emphasis role="bold">makearray</emphasis> method is used to obtain a set of values which are
used as if <emphasis role="italic">argument</emphasis> was an OrderedCollection.
All tests for result membership are made using both the index and item values.
</para>
</listitem></varlistentry>
</variablelist>
</section>
</section>

</section>
