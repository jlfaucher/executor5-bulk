<!--#########################################################################
    #
    # Description: Open Object Rexx: Reference SGML file.
    #
    # Copyright (c) 2005-2007, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<chapter id="winclasses"><title>The Windows Specific Classes</title>
<para>This section describes the Windows-specific classes supplied with
ooRexx.</para>

<section id="clsWinMenuObject"><title>The Windows MenuObject Class</title>
<indexterm><primary>MenuObject class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>MenuObject class</secondary></indexterm>
<para>The MenuObject class provides methods to query, manipulate, and  interact
with the menu or submenu of a window.</para>
<para>Access to MenuObjects requires that the following directive
appear in the Rexx program.</para>
<programlisting>
::requires 'winsystm.cls'
</programlisting>
<para><emphasis role="bold">Methods the MenuObject Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>findItem</para></listitem>
<listitem><para>findSubmenu</para></listitem>
<listitem><para>idOf</para></listitem>
<listitem><para>ischecked</para></listitem>
<listitem><para>isMenu</para></listitem>
<listitem><para>isSubMenu</para></listitem>
<listitem><para>isSeparator</para></listitem>
<listitem><para>items</para></listitem>
<listitem><para>processItem</para></listitem>
<listitem><para>submenu</para></listitem>
<listitem><para>textOf(id)</para></listitem>
<listitem><para>textOf(position)</para></listitem></itemizedlist>

<section id="ismenumo"><title>isMenu</title>
<indexterm><primary>isMenu method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isMenu method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isMenu------------------------------------------------------><
]]>
</programlisting>

<para>Returns 1 if the associated window is a menu, otherwise 0.</para>
</section>

<section id="issubmenumo"><title>isSubMenu</title>
<indexterm><primary>isSubMenu method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isSubMenu method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isSubMenu(--position--)-------------------------------------><
]]>
</programlisting>

<para>
  Returns <computeroutput>.true</computeroutput> if the menu item at the position specified is a submenu
  of this menu, otherwise <computeroutput>.false</computeroutput>. Menu items are zero-based, so the
  first menu item is at position 0.
</para>
</section>

<section id="ischeckedmo"><title>isChecked</title>
<indexterm><primary>isChecked method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isChecked method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isChecked(--position--)-------------------------------------><
]]>
</programlisting>

<para>
  Returns <computeroutput>.true</computeroutput> if the menu item at the position specified is checked,
  otherwise <computeroutput>.false</computeroutput>. Menu items are zero-based, so the first menu item is
  at position 0. Submenus and separators can be be checked.
</para>
<para>
  This method can not be 100% reliable. Some applications do not set the check mark for a menu item until
  the menu is displayed. To be confident of the result, the programmer should first test how a specific
  application behaves.
</para>
</section>

<section id="isseparatormo"><title>isSeparator</title>
<indexterm><primary>isSeparator method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isSeparator method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isSeparator(--position--)-----------------------------------><
]]>
</programlisting>

<para>
  Returns <computeroutput>.true</computeroutput> if the menu item at the position specified is a
  separator line,, otherwise <computeroutput>.false</computeroutput>. Menu items are zero-based, so the
  first menu item is at position 0.
</para>
</section>

<section id="itemsmo"><title>items</title>
<indexterm><primary>items method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>items method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-items-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of menu items contained in the associated menu.</para>
</section>

<section id="idofmo"><title>idOf</title>
<indexterm><primary>idOf method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>idOf method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-idOf--(--position--)----------------------------------------><
]]>
</programlisting>

<para>Returns the ID of the menu item at the specified
<emphasis role="italic">position</emphasis>, starting with 0.</para>
</section>

<section id="textofpositionmo"><title>textOf(position)</title>
<indexterm><primary>textOf(position) method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>textOf(position) method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-textOf--(--position--)--------------------------------------><
]]>
</programlisting>

<para>Returns the text of the menu item at the specified
<emphasis role="italic">position</emphasis>, starting
with 0. A mnemonic (underscored letter) is represented by a leading ampersand
(&amp;). If the menu item contains an accelerator, it is separated by a tab.
</para>
</section>

<section id="textofidmo"><title>textOf(id)</title>
<indexterm><primary>textOf(id) method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>textOf(id) method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-textOf--(--id--)--------------------------------------------><
]]>
</programlisting>

<para>Returns the text of menu item <emphasis role="italic">id</emphasis>.
A mnemonic is represented by a leading ampersand (&amp;). If the menu item
contains an accelerator, it is separated by a tab.</para>
</section>

<section id="submenumo"><title>submenu</title>
<indexterm><primary>submenu method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>submenu method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-submenu--(--position--)-------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the MenuObject class that is associated with the
submenu at the specified <emphasis role="italic">position</emphasis>,
starting with 0. If no submenu
exists at this position, the .Nil object is returned.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
sub = menu~submenu(5)
    if sub \= .Nil then do
         say "Items:" sub~items
    end
</programlisting>
</section>

<section id="findsubmenumo"><title>findSubmenu</title>
<indexterm><primary>findSubmenu method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>findSubmenu method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-findSubmenu--(--label--)------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the MenuObject class that is associated with the
submenu with the specified <emphasis role="italic">label</emphasis>.
If the associated menu does not
contain such a submenu, the .Nil object is returned.</para>
</section>

<section id="finditemmo"><title>findItem</title>
<indexterm><primary>findItem method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>findItem method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-findItem--(--label--)---------------------------------------><
]]>
</programlisting>

<para>Returns the ID of the menu item <emphasis role="italic">label</emphasis>.
If the specified label
does not include an accelerator, the comparison excludes the accelerators
of the menu items. If no menu item is found that matches the specified label,
0 is returned.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
f = menu~findItem("&amp;Tools" || "9"x || "Ctrl+T")
    if f \= 0 then menu~processItem(f)
</programlisting>
</section>

<section id="processitemmo"><title>processItem</title>
<indexterm><primary>processItem method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>processItem method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-processItem--(--id--)---------------------------------------><
]]>
</programlisting>

<para>Selects the menu item <emphasis role="italic">id</emphasis>. This causes
a WM_COMMAND to be sent to the window owning the menu.</para>
</section>
</section>

<section id="clsWinOLEObject"><title>The Windows OLEObject Class</title>
<indexterm><primary>OLEObject class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>OLEObject class</secondary></indexterm>
<para>
  This class provides support for OLE automation. OLE (Object Linking and Embedding) is an implementation
  of COM (Component Object Model). OLE automation makes it possible for one application to manipulate
  objects implemented in another application, or to expose objects so they can be manipulated.
</para>
<para>
  An automation client is an application that can manipulate exposed objects belonging to another
  application. An automation server is an application that exposes the objects. The OLEObject class
  enables Rexx to be an OLE automation client. In addition, some automation servers have an event <link
  linkend="oleevents">mechanism</link> that allows them to invoke methods in the OLE automation client.
  The OLEObject class also supports this mechanism.
</para>
<para>
  Applications can provide OLE objects, and OLE objects that support automation can be used by a Rexx
  script to remotely control the object through the supplied methods. This lets you write a Rexx script
  that, for example, starts a Web browser, navigates to a certain page, and changes the display mode of
  the browser.
</para>
<para>
  Every application that supports OLE places a unique identifier in the registry. This identifier is
  called the class ID (CLSID) of the OLE object. It consists of several hexadecimal numbers separated by
  the minus symbol.
</para>
<para>
  <emphasis role="bold">Example:</emphasis> CLSID of <trademark class="registered">Microsoft</trademark>
  Internet Explorer (Version 5.00.2014.0216):
</para>
<programlisting>
"{0002DF01-0000-0000-C000-000000000046}"
</programlisting>
<para>
  The CLSID number can prove inconvenient when you want to create or access a certain object, so a
  corresponding easy-to-remember entry is provided in the registry, and this entry is mapped to the
  CLSID. This entry is called the ProgID (the program ID), and is a string containing words separated by
  periods.
</para>
<para>
  <emphasis role="bold">Example:</emphasis> ProgID of Microsoft Internet Explorer:
  <computeroutput>"InternetExplorer.Application"</computeroutput>
</para>
<para>
  To find the ProgID of an application, you can use the sample script
  <computeroutput>OLEINFO.REX</computeroutput> or the Microsoft OLEViewer, you can consult the
  documentation of the application, or you can search the registry manually.
</para>
<para>
  The OLEObject class is a built-in class. No <computeroutput>::requires</computeroutput> directive is
  needed to use the class.
</para>
<para>
  Several sample programs are provided in the Open Object Rexx installation directory under
  <computeroutput>samples\ole</computeroutput>
</para>
<itemizedlist>
<listitem>
<para>
  The apps directory contains examples of how to use Rexx to remote-control other applications.
</para>
</listitem>
<listitem>
<para>
  The oleinfo directory is a sample Rexx application that can be used to browse through the information
  an OLE object provides.
</para>
</listitem>
<listitem>
<para>
    In the adsi directory there are eight examples of how to use the Active Directory Services Interface
    with the Rexx OLE interface.
</para>
</listitem>
<listitem>
<para>
  The methinfo directory contains a very basic example of how to access the information an OLE object
  provides.
</para>
</listitem>
<listitem>
<para>
  Finally, the wmi directory contains five examples of how to work with the Windows Management
  Instrumentation.
</para>
</listitem>
</itemizedlist>
<para>
  <emphasis role="bold">Methods available to the OLEObject class:</emphasis>
</para>
<simplelist>
<member>new (Class method)</member>
<member>addEventMethod</member>
<member>connectEvents</member>
<member>disconnectEvents</member>
<member>dispatch</member>
<member>getConstant</member>
<member>getKnownEvents</member>
<member>getKnownMethods</member>
<member>getObject(Class method)</member>
<member>getOutParameters</member>
<member>isConnected</member>
<member>isConnectable</member>
<member>removeEvents</member>
<member>removeEventHandler</member>
<member>unknown</member>
</simplelist>
<para>
  <emphasis role="bold">Note:</emphasis> It is somewhat useful to think of the Rexx OLEObject object as a
  proxy to the real OLE object. The real OLE object has its own methods. Which methods it has is
  dependent on its individual implementation.  These methods are then accessed transparently through the
  <link linkend="oleobunk">unknown</link>() method mechanism of the OLEObject by invoking a method of the
  same name on the OLEObject object.
</para>

<section id="oleevents"><title>OLE Events</title>
<indexterm><primary>OLE Events</primary>
<secondary>of OLEObject class</secondary></indexterm>
<para>
  Some, but not all, OLE automation objects support <emphasis role="italic">events</emphasis>. The most
  prevalent use of OLE is for the automation server (the OLE object) to implement methods that the
  automation client (the ooRexx OLEObject) invokes. However, it is also possible for the automation
  client (the ooRexx OLEOjbect) to implement methods that the automation server (the OLE object) invokes.
</para>
<para>
  The methods that the automation client implements are called event methods and the automation server
  that suports event methods is called a <emphasis role="italic">connectable</emphasis> object. The
  connectable object defines the events it supports by defining the name of the method and its arugments,
  but does not implement the method. Rather the automation client implements the method. The client asks
  the automation server to make a <emphasis role="italic">connection</emphasis>. If the connection is
  established, then from that point on whenever one of the defined events occurs, the server invokes the
  event method on the connected client.
</para>
<para>
  In effect, what is happening is that the automation server is <emphasis
  role="italic">notifying</emphasis> the automation client that some event has occurred and giving the
  client a chance to react to the event. Any number of clients can be connected to the same connectable
  object at the same time. Each client will recieve a notification for any event they are interested in.
  There is no need for the client to receive notifications for evey event. When the client is not
  interested in an event, the client simply does not implement a method for that event.
</para>
<para>
  The original implementation of OLEObject allowed the Rexx programmer to use events in this way: The
  programmer defines and implements a subclass of the OLEObject. Within the subclass, the programmer
  defines and implements the event methods for which she wants to recieve notifications. The progammer
  has the client make a connection to the automation server at the time the OLEObject object is <link
  linkend="oleobjinit">instantiated</link> by using the <computeroutput>WITHEVENTS</computeroutput>
  keyword for the <emphasis role="italic">events</emphasis> argument. If the
  <computeroutput>WITHEVENTS</computeroutput> keyword is not used during instantiation, then no event
  connection can be made.
</para>
<para>
  This is relatively easy to understand and a simple example should make this clear. In the following,
  rather than create a new OLEObject, the programmer defines a subclass of the OLEObject, a WatchedIE
  class. The WatcheID object is instantiated with events. This tells the OLEObject to make an event
  connection, if possible. In the subclass, the programmer implements the events he is interested in
  receiving notifications for.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[

-- Instantiate an instance of the subclassed OLEObject
myIE = .WatchedIE~new("InternetExplorer.Application", "WITHEVENTS")
...

-- This class is derived from OLEObject and contains several methods
-- that will be called when certain events take place.
::class 'WatchedIE' subclass OLEObject

-- This is an event of the Internet Explorer */
::method titleChange
  use arg Text
  say "The title has changed to:" text

-- This is an event of the Internet Explorer
::method beforeNavigate2
  use arg pDisp, URL, Flags, TargetFrameName, PostData, Headers, Cancel
  ...

-- This is an event of the Internet Explorer */
::method onQuit
  ...

]]>
</programlisting>
<para>
  However, the process described above only allows using events with OLEObject objects that are directly
  instantiated by the programmer. There are a number of OLE objects that support events, where the
  OLEObject object is not instantiated by the programmer, but rather is returned from a method
  invocation. Prior to ooRexx 4.0.0, events could not be used with these objects. In 4.0.0, methods were
  added to the OLEObject class that allow using events with any OLE object that supports events.
</para>
<para>
  This second process works this way: With an already instantiated object, the programmer can create
  method objects for any events of interest and use the <link
  linkend="oleobjaddeventmethod">addEventMethod</link>() method to add the method to the instantiated
  object. Then the <link linkend="oleobjconnectevents">connectEvents</link>() method is used to connect
  the automation client (the instantiated object in this case) to the connectable OLE automation server.
</para>
<para>
  The following example demonstrates this second process that is available in ooRexx 4.0.0 and onwards.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[

  wordApp = .OLEObject~new("Word.Application")
  wordApp~visible = .true
  document = wordApp~documents~Add

  -- Use the isConnectable method to ensure the object supports connections.
  if document~isConnectable then do

    -- Create a method for the OLEEvent_Close event. From the Word documentation
    --and experimentation, it is known that this event has no arguments.
    mArray = .array~new
    mArray[1] = 'say "Received the OLEEvent_Close event."'
    mArray[2] = 'say "  Event has" arg() "parameters."'
    mArray[3] = 'say'

    mClose = .Method~new("OLEEvent_Close", mArray)

    -- Now add this method to the document object.
    document~addEventMethod("OLEEvent_Close", mClose)

    -- Tell the object to make an events connection.
    document~connectEvents
  end

]]>
</programlisting>
<para>
  The preceding example brings up one last point that is important to note when defining event methods.
  It is possible for an event method to have the same name as a normal invocation method of the OLE
  object.  This gives rise to this scenario:
</para>
<para>
  The programmer adds an ooRexx event method to the OLEObject with that name. Then the programmer tries
  to invoke the normal method.  However, the invocation will no longer get forwarded to the <link
  linkend="oleobunk">unknown</link>() method. Instead the event method by the same name is invoked. This
  is the case in the above example. The document object has a <computeroutput>close</computeroutput>()
  method that is used to close the document. The document also has the
  <computeroutput>close</computeroutput>() event method that is used to notify clients that the document
  is about to close.
</para>
<para>
  To prevent this scenario, when an event method of an OLE object has the same name as a normal method
  name, the programmer must prepend <computeroutput>OLEEvent_</computeroutput> to the method name. The
  implementation of OLEObject assumes the programer has done so. If the programmer does not name the
  event methods using this convention, the results are unpredicatable.
</para>
<para>
  <emphasis role="bold">Note</emphasis> that <emphasis role="italic">only</emphasis> the event method
  names that have matching normal event names can be prepended with the OLEEvent_prefix. Other event
  names must not have the prefix. One way to check for this is to use the <link
  linkend="oleobgetknev">getKnownEvents</link>() method. This method will return the correct names for
  all events the OLE object supports.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<para>
  This example is a compelete working program. To run it, Microsoft OutLook must be installed. The
  program demonstrates some of the various methods of the OLEObject that deal with events. The interface
  to the program is simplistic, but workable.
</para>
<para>
  Once the program starts, the user controls it by creating specific named files in working directory of
  the program.  This could be done for example using echo:
<programlisting>
<![CDATA[
echo " " > stop.monitor
]]>
</programlisting>
  The three specific file names are: <computeroutput>stop.monitor</computeroutput>,
  <computeroutput>pause.monitor</computeroutput>, and <computeroutput>restart.monitor</computeroutput>.
  The stop file ends the program. The pause file has the program stop monitoring for new mail, but keep
  running. The restart file has the program restart monitoring from the paused state.
</para>
<programlisting>
<![CDATA[

/* Monitor OutLook for new mail */
  say; say; say 'ooRexx Mail Monitor version 1.0.0'

  outLook = .oleObject~new("Outlook.Application")

  inboxID = outLook~getConstant(olFolderInBox)
  inboxItems = outLook~getNameSpace("MAPI")~getDefaultFolder(inboxID)~items

  if \ inboxItems~isConnectable then do
    say 'Inbox items is NOT connectable, quitting'
    return 99
  end

  inboxItems~addEventMethod("ItemAdd", .methods~printNewMail)
  inboxItems~connectEvents

  if \ inboxItems~isConnected then do
    say 'Error connecting to inbox events, quitting'
    return 99
  end

  monitor = .Monitor~new
  say 'ooRexx Mail Monitor - monitoring ...'
  do while monitor~isActive
    j = SysSleep(1)
    status = monitor~getStatus

    select
      when status == 'disconnect' then do
        inboxItems~disconnectEvents
        say 'ooRexx Mail Monitor - paused ...'
      end
      when status == "reconnect" then do
        inboxItems~connectEvents
        say 'ooRexx Mail Monitor - monitoring ...'
      end
      otherwise do
        nop
      end
    end
    -- End select
  end
  say 'ooRexx Mail Monitor version 1.0.0 ended'

return 0

::method printNewMail unguarded
  use arg mailItem
  say 'You have mail'
  say 'Subject:' mailItem~subject

::class 'Monitor'
::method init
  expose state active

  state = 'continue'
  active = .true
  j = SysFileDelete('stop.monitor')
  j = SysFileDelete('pause.monitor')
  j = SysFileDelete('restart.monitor')

::method isActive
  expose active
  return active

::method getStatus
  expose state active

  if SysIsFile('stop.monitor') then do
    j = SysFileDelete('stop.monitor')
    active = .false
    state = 'quit'
    return state
  end

  if SysIsFile('pause.monitor') then do
    j = SysFileDelete('pause.monitor')
    if state == "paused" then return "continue"

    if state \== 'quit' then do
      state = "paused"
      return 'disconnect'
    end
  end

  if SysIsFile('restart.monitor') then do
    j = SysFileDelete('restart.monitor')
    if state == 'continue' then return state

    if state \== 'quit' then do
      state = 'continue'
      return 'reconnect'
    end
  end

  return 'continue'

]]>
</programlisting>
</section>

<section id="oleobjinit"><title>new (Class method)</title>
<indexterm><primary>new method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>--new(--classID--+-----------+--+--------------+--)-------------------><
                   +-,-events--+  +-,-getObject--+
]]>
</programlisting>

<para>
  Instantiates a new OLEObject as a proxy for a COM / OLE object with the specified <emphasis
  role="italic">classID</emphasis> (the <computeroutput>ProgID</computeroutput> or
  <computeroutput>CLSID</computeroutput>). If the COM / OLE object can not be accessed or created, an
  error will be raised. See the list of OLE specific errors in the Open Object Rexx Reference document.
</para>
<variablelist>
  <varlistentry><term><emphasis role="bold">Arguments:</emphasis></term>
  <listitem>
    <para>The arguments are:
    <variablelist>
      <varlistentry><term>classID</term>
      <listitem>
        <para>
          The <computeroutput>ProgID</computeroutput> or <computeroutput>CLSID</computeroutput> that
          identifies the COM / OLE object to proxy for.
        </para>
      </listitem></varlistentry>
      <varlistentry><term>events</term>
      <listitem>
        <para>
          Controls how the event methods of the COM / OLE object are handled:
        </para>
        <para>
          If the argument is omitted completely, then no action concerning the event methods is taken.
        </para>
        <para>
           If the argument is NOEVENTS then the COM / OLE object is queried to determine if it is a
           connectable object. If it is, an internal table is constructed listing all the event methods.
           But the object is not connected.
        </para>
        <para>
           If the argument is WITHEVENTS then the COM / OLE object is queried to determine if it is a
           connectable object. If it is, an internal table is constructed listing all the event methods,
           and an event connection is established.
        </para>
      </listitem></varlistentry>
      <varlistentry><term>getObject</term>
      <listitem>
        <para>
          A flag asking to first try to get an already instantiated OLE object, rather than instantiate a
          new object. Some OLE automation servers register themselves with the operating system when an
          object is first created, but not all do. If this flag is true, then the OLEObject first tries
          to proxy for an already running OLE / COM object. If this fails, then a new OLE / COM object is
          instantiated.
        </para>
        <para>
          If the flag is omitted, or <computeroutput>.false</computeroutput> then no attempt to look for
          an already running OLE / COM object is made.
        </para>
      </listitem></varlistentry>
    </variablelist>
    </para>
  </listitem></varlistentry>
  <varlistentry><term><emphasis role="bold">Example:</emphasis></term>
  <listitem>
<programlisting>
<![CDATA[
myOLEObject = .OLEObject~new("InternetExplorer.Application")
]]>
</programlisting>
  </listitem></varlistentry>
</variablelist>

</section>

<section id="oledispatch"><title>dispatch</title>
<indexterm><primary>dispatch method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>dispatch method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-dispatch(methodname--+------------+--)----------------------><
                        |  +------+  |
                        |  V      |  |
                        +----,arg-+--+
]]>
</programlisting>

<para>
Dispatches a method with the optionally supplied arguments.
</para>
</section>

<section id="oleobgetcon"><title>getConstant</title>
<indexterm><primary>getConstant method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getConstant</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getConstant(-+--------------+-)-----------------------------><
                +-ConstantName-+
]]>
</programlisting>

<para>Retrieves the value of a constant that is associated with this
OLE object. If no constant of that name exists, the .Nil object will be returned.
You can also omit the name of the constant; this returns a stem with all known
constants and their values. In this case the constant names will be prefixed
with a "!" symbol.</para>
<para><emphasis role="bold">Example 1:</emphasis></para>
<programlisting>
myExcel = .OLEObject~new("Excel.Application")
say "xlCenter has the value" myExcel~getConstant("xlCenter")
myExcel~quit
exit
</programlisting>
<para>Possible output:</para>
<programlisting>
xlCenter has the value -4108
</programlisting>
<para><emphasis role="bold">Example 2:</emphasis></para>
<programlisting>
myExcel = .OLEObject~new("Excel.Application")
constants. = myExcel~getConstant
myExcel~quit

do i over constants.
  say i"="constants.i
end
</programlisting>
<para>Possible output:</para>
<programlisting>
!XLFORMULA=5
!XLMOVE=2
!XLTEXTMAC=19
...
</programlisting>
</section>

<section id="oleobgetknev"><title>getKnownEvents</title>
<indexterm><primary>getKnownEvents method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getKnownEvents method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getKnownEvents----------------------------------------------><
]]>
</programlisting>

<para>
  Returns a stem with information on the <link linkend="oleevents">events</link> that the connectable OLE
  object supports. It collects this information from the type library of the OLE object. A type library
  provides the names, types, and arguments of the provided methods. The OLEObject object does not need to
  be currently connected to connectable OLE object.
</para>
<para>
  This method will return the event methods for any connectable object.  Prior to ooRexx 4.0.0, only
  OLEObjects created directly, and created with the 'event' flag (WITHEVENTS or NOEVENTS) would return
  any known events. This fact had not been fully documented. Therefore, if the user did not create the
  OLEObject correctly, .nil would be returned for objects that did support event connections.
</para>
<para>
  In 4.0.0, the behavior is fixed (or enhanced depending on the point of view) so that the known events
  are returned for all connectable objects under all circumstances.
</para>
<para>The stem provides the following information:</para>

<table frame="all">
<title>Stem Information</title>
<tgroup cols="2">
<tbody>
<row>
<entry>stem.0</entry>
<entry>The number of events.</entry>
</row>
<row>
<entry>stem.n.!NAME</entry>
<entry>Name of n-th event.</entry>
</row>
<row>
<entry>stem.n.!DOC</entry>
<entry>Description of n-th event (if available).</entry>
</row>
<row>
<entry>stem.n.!PARAMS.0</entry>
<entry>Number of parameters for n-th event.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!NAME</entry>
<entry>Name of i-th parameter of n-th event.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!TYPE</entry>
<entry>Type of i-th parameter of n-th event.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!FLAGS</entry>
<entry>Flags of i-th parameter of n-th event; can be "in",
"out", "opt", or any combination of these.</entry>
</row>
</tbody>
</tgroup>
</table>
<para>
  If no information is available, the .NIL object is returned. This indicates that the OLE object does
  support events.
</para>
<para><emphasis role="bold">Example script:</emphasis></para>
<programlisting>
myIE = .OLEObject~new("InternetExplorer.Application","NOEVENTS")
events. = myIE~getKnownEvents

if events. == .nil then
  say "Sorry, this object does not have any events."
else do
  say "The following events may occur:"
  do i = 1 to events.0
    say events.i.!NAME
  end
end

exit
</programlisting>
<para><emphasis role="bold">Sample output:</emphasis></para>
<programlisting>
The following events may occur:
ONTHEATERMODE
ONFULLSCREEN
ONSTATUSBAR
...
</programlisting>
<para>
  For an example of how to use events, see examples
  <computeroutput>samples\ole\apps\samp12.rex</computeroutput> and
  <computeroutput>samples\ole\apps\samp13.rex</computeroutput>. The samples directory is installed as
  part of the normal Windows installation.
</para>
</section>

<section id="oleobjconnectevents"><title>connectEvents</title>
<indexterm><primary>connectEvents method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>connectEvents</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>--connectEvents----------------------------------------------><
]]>
</programlisting>

<para>
  The connectEvents() method is used to connect the instantiated automation client (the OLEObject
  subclass object) to the automation server (the OLE object) at any time. The method returns
  <computeroutput>.true</computeroutput> if the connection was made, otherwise
  <computeroutput>.false</computeroutput>. Remember, not all OLE objects support events. The programmer
  can determine if the OLE object supports events by using the <link
  linkend="oleobjisconnectable">isConnectable</link>() method.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[

  wordApp = .OLEObject~new("Word.Application")
  wordApp~visible = .true
  document = wordApp~documents~Add

  wordApp~connectEvents

]]>
</programlisting>
</section>

<section id="oleobjisconnected"><title>isConnected</title>
<indexterm><primary>isConnected method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isConnected</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>--isConnected------------------------------------------------><
]]>
</programlisting>

<para>
  Determines if the OLEObject instance is currently connected to a connectable OLE automation server.
  Returns <computeroutput>.true</computeroutput> if the instance is connected and
  <computeroutput>.false</computeroutput> if not.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[
  wordObj = .oleObject~new("Word.Application", "WITHEVENTS")
  if wordObj~isConnected then do
    ...
  end
  else do
    ...
  end

]]>
</programlisting>
</section>

<section id="oleobjisconnectable"><title>isConnectable</title>
<indexterm><primary>isConnectable method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isConnectable</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>--isConnectable----------------------------------------------><
]]>
</programlisting>

<para>
  Determines if the OLE object is a connectable object. In other words, does the OLE object support event
  methods and will it accept connections at this time. Not all OLE objects support events, probably the
  majority do not support events. This method returns <computeroutput>.true</computeroutput> if the
  object is connectable, otherwise <computeroutput>.false</computeroutput>.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[

  outLook = .oleObject~new("Outlook.Application")

  -- This searches all folders for the 'Mailbox - .. ' folder.  Which is
  -- usually the default folder in a business installation of Outlook.
  nameSpace = outLook~getNameSpace('MAPI')
  folders = nameSpace~folders
  do i = 1 to folders~count
    if folders~item(i)~name~caselessPos("Mailbox") <> 0 then do
      theMailBoxFolder = folders~item(i)
      leave
    end
  end

  -- Now that we have the Mailbox folder, get the collection of folders that
  -- are contained in the Mailbox folder.
  folders = theMailBoxFolder~folders

  if folders~isConnectable then do
    -- Add event methods to the folders object.
    ...
  end

]]>
</programlisting>
</section>

<section id="oleobjdisconnectevents"><title>disconnectEvents</title>
<indexterm><primary>disconnectEvents method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>disconnectEvents</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>--disconnectEvents-------------------------------------------><
]]>
</programlisting>

<para>
  This method disconnects from the connectable OLE object. The method returns
  <computeroutput>.false</computeroutput> if there is not a current connection, otherwise
  <computeroutput>.true</computeroutput>. After this method is called, the OLE object will no longer
  invoke the event methods, in effect stopping event notifications.
</para>
<para>
  The internal data structures used to manage events remain intact. The programmer can use the <link
  linkend="oleobjconnectevents">connectEvents</link>() method to reconnect at any time. Since the
  internal data structures do not need to be rebuilt, this will save some small amount of processor time.
  To completely remove the internal data structures use the <link
  linkend="oleobjremoveeventhandler">removeEventHandler</link>() method.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<para>
  This example shows some code snippets from a program that monitors the user's inbox in OutLook. When a
  new mail item arrives, the user is notified. The interface for the program allows the user to turn off
  the notifications when she wants, then turn them back on later. When the interface signals the program
  to stop the notifications, the program simply disconnects the events from the OutLook object. When the
  user wants to resume notifications, the program reconnects the events.
</para>
<programlisting>
<![CDATA[

  outLook = .oleObject~new("Outlook.Application")
  inboxID = outLook~getConstant(olFolderInBox)
  inboxItems = outLook~getNameSpace("MAPI")~getDefaultFolder(inboxID)~items

  ...

  inboxItems~addEventMethod("ItemAdd", .methods~printNewMail)
  inboxItems~connectEvents

  ...

    select
      when status == 'disconnect' then do
        inboxItems~disconnectEvents
        say 'ooRexx Mail Monitor - paused ...'
      end
      when status == "reconnect" then do
        inboxItems~connectEvents
        say 'ooRexx Mail Monitor - monitoring ...'
      end
      otherwise do
        nop
      end
    end
    -- End select


]]>
</programlisting>
</section>

<section id="oleobjremoveeventhandler"><title>removeEventHandler</title>
<indexterm><primary>removeEventHandler method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>removeEventHandler</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>--removeEventHandler-----------------------------------------><
]]>
</programlisting>

<para>
  Removes the event handler and cleans up the internal data structures used to manage events. No event
  methods will be invoked after this method is called. See the <link
  linkend="oleobjdisconnectevents">disconnectEvents</link>() method for a way to temporarily disconnect
  from event notifications.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[

  inboxItems~removeEventHandler
  inboxItems~removeEventMethod("ItemAdd")

]]>
</programlisting>
</section>

<section id="oleobjaddeventmethod"><title>addEventMethod</title>
<indexterm><primary>addEventMethod method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addEventMethod</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>--addEventMethod(--name-,-methodObject--)--------------------><
]]>
</programlisting>

<para>
  <computeroutput>addEventMethod</computeroutput> adds a new method to this object's collection of
  methods. The <emphasis role="italic">name</emphasis> argument specifies the name of the new method and
  the <emphasis role="italic">methodObject</emphasis> argument defines the method. The acceptable values
  for <emphasis role="italic">methodObject</emphasis> are the same as those for the second argument to
  the <computeroutput>setMethod</computeroutput> method of the<computeroutput>.Object</computeroutput>
  class. That is, it can be a method object, a string containing a method source line, or an array of
  strings containgin individual method source lines.
</para>
<para>
  The purpose of this method is to add an event method to a OLEObject after the object has been
  instantiated. See the <link linkend="oleevents">OLE Events</link> section for more details on events.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<para>
  Note that in this example, the printNewMail method is defined as a floating method. See the
  documentation for the <computeroutput>.methods</computeroutput> directory in the Open Object Rexx
  Reference book for more details if needed.
</para>
<programlisting>
<![CDATA[

  inboxID = outLook~getConstant(olFolderInBox)
  inboxItems = outLook~getNameSpace("MAPI")~getDefaultFolder(inboxID)~items

  inboxItems~addEventMethod("ItemAdd", .methods~printNewMail)

...

::method printNewMail unguarded
  use arg mailItem
  say 'You have mail'
  say 'Subject:' mailItem~subject


]]>
</programlisting>
</section>

<section id="oleobjremoveeventmethod"><title>removeEventMethod</title>
<indexterm><primary>removeEventMethod method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>removeEventMethod</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>--removeEventMethod(--name--)-----------------------------------><
]]>
</programlisting>

<para>
  Removes the event method with the specified <emphasis role="italic">name</emphasis> that has been
  previously added to this object by the <link linkend="oleobjaddeventmethod">addEventMethod</link>()
  method.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[

  inboxID = outLook~getConstant(olFolderInBox)
  inboxItems = outLook~getNameSpace("MAPI")~getDefaultFolder(inboxID)~items

  inboxItems~addEventMethod("ItemAdd", .methods~printNewMail)
  inboxItems~connectEvents

  ...

::method doneWithItemEvents private
  expose inboxItems

  inboxItems~removeEventHandler
  inboxItems~removeEventMethod("ItemAdd")

]]>
</programlisting>
</section>

<section id="oleobgetknme"><title>getKnownMethods</title>
<indexterm><primary>getKnownMethods method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getKnownMethods method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getKnownMethods---------------------------------------------><
]]>
</programlisting>

<para>Returns a stem with information on the methods that the OLE object
supplies. It collects this information from the type library of the object. A
type library provides the names, types, and arguments of the provided methods.
Parts of the supplied information have only informational character as you
cannot use them directly.</para>
<para>The stem provides the following information:</para>

<table frame="all">
<title>Stem Information</title>
<tgroup cols="2">
<tbody>
<row>
<entry>stem.0</entry>
<entry>The number of methods.</entry>
</row>
<row>
<entry>stem.!LIBNAME</entry>
<entry>Name of the type library that describes this object.</entry>
</row>
<row>
<entry>stem.!LIBDOC</entry>
<entry>A help string describing the type library. Only set
when the string is available.</entry>
</row>
<row>
<entry>stem.!COCLASSNAME</entry>
<entry>COM class name of this object.</entry>
</row>
<row>
<entry>stem.!COCLASSDOC</entry>
<entry>A string describing the COM class. Only set
when the string is supplied by the type library.</entry>
</row>
<row>
<entry>stem.n.!NAME</entry>
<entry>The name of the n-th method.</entry>
</row>
<row>
<entry>stem.n.!DOC</entry>
<entry>A help string for the n-th method. If this information
is not supplied in the type library this value will not be set.</entry>
</row>
<row>
<entry>stem.n.!INVKIND</entry>
<entry>A number that represents the invocation kind of the
method: 1 = normal method call, 2 =
<computeroutput>property get</computeroutput>, 4 = <computeroutput>property
put</computeroutput>. A normal method call is used with brackets; for a
<computeroutput>property
get</computeroutput> only the name is to be specified; and a
<computeroutput>property set</computeroutput> uses
the "=" symbol, as in these examples:
<computeroutput>object~methodCall(a,b,c)</computeroutput>
<computeroutput>object~propertyPut="Hello"</computeroutput>
<computeroutput>say object~propertyGet</computeroutput></entry>
</row>
<row>
<entry>stem.n.!RETTYPE</entry>
<entry>The return type of the n-th method. The return type
will be automatically converted to a Rexx object (see
<link linkend="oleobtypconv">Type Conversion</link> in
the description of the UNKNOWN method of the OLEObject class).</entry>
</row>
<row>
<entry>stem.n.!MEMID</entry>
<entry>The MemberID of the n-th method. This is only used internally
to call the method.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.0</entry>
<entry>The number of parameters of the n-th method.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!NAME</entry>
<entry>The name of the i-th parameter of the n-th method.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!TYPE</entry>
<entry>The type of the i-th parameter of the n-th method.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!FLAGS</entry>
<entry>The flags of the i-th parameter of the n-th method;
can be "in", "out", "opt", or any combination of these (for example: "[in,
opt]").</entry>
</row>
</tbody>
</tgroup>
</table>
<para>If no information is available, the .NIL object is returned.</para>

<para>
  <emphasis role="bold">Note</emphasis> that it is not required that an OLE object supply a type library.
  The methods of OLE objects that do not supply a type library can still be invoked by name, but there is
  no way for <computeroutput>getKnownMethods</computeroutput> to look up the methods. To use these OLE
  objects the Rexx programmer would need to consult the documentation for the OLE object.
</para>
<para>
  In addition all OLE objects have methods that can only be used internally. There are mechanisms to
  <emphasis role="italic">hide</emphasis> these methods from the user, because they can not be used by
  the automation client. It is possible that these are not hidden properly and will be listed when using
  <computeroutput>getKnownMethods</computeroutput>. The following methods can not be used by an instance
  of the OLEObject:
</para>
<simplelist>
<member>AddRef</member>
<member>GetTypeInfoCount</member>
<member>GetTypeInfo</member>
<member>GetIDsOfNames</member>
<member>QueryInterface</member>
<member>Release</member>
</simplelist>
<para><emphasis role="bold">Example script:</emphasis></para>
<programlisting>
myOLEObject = .OLEObject~new("InternetExplorer.Application")
methods. = myOLEObject~getKnownMethods

if methods. == .nil then
  say "Sorry, no information on the methods available!"
else do
  say "The following methods are available to this OLE object:"
  do i = 1 to methods.0
    say methods.i.!NAME
  end
end

exit
</programlisting>
<para><emphasis role="bold">Sample output:</emphasis></para>
<programlisting>
The following methods are available to this OLE object:
GoBack
GoForward
GoHome
...
</programlisting>
</section>

<section id="oleobgetob"><title>getObject (Class method)</title>
<indexterm><primary>getObject method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getObject method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getObject(Moniker-+--------+-)------------------------------><
                     +-,class-+
]]>
</programlisting>

<para>
  This is a class method that allows you to obtain an OLE object through the use of a moniker. A moniker
  is a string and is similar to a nickname. Monikers are used by OLE to connect to and activate OLE
  objects. OLE returns the object that the moniker identifies.
</para>
<para>
  If the object is already running, OLE will find it in memory. If the object is stored passively on
  disk, OLE will locate a server for the object, run the server, and have the server bring the object
  into the running state. This makes monikers very easy for the automation client to use. OLE hides all
  the details from the client. However, since the OLEObject also hides all the details when a new OLE
  object is instantiated, for the Rexx programmer there is not much difference between using the
  <computeroutput>getObject</computeroutput> method and using the <computeroutput>new</computeroutput>
  method.
</para>
<para>
  Note that file system names are monikers. Therefore, if a file is assoicated with an application that
  is an OLE automation server, a new OLE object can be instantiated by using the file name as the
  moniker. Obviously, this is not true of every file. It is true for files like
  <computeroutput>.xls</computeroutput> and <computeroutput>.doc</computeroutput> files, for example,
  because Word and Excel are OLE automation applications.
</para>
<para>
  The optional <emphasis role="italic">class</emphasis> argument can be used to specify a subclass of
  OLEObject, and can be used to obtain an OLE object that supports events
  (the<computeroutput>&apos;WITHEVENTS&apos;</computeroutput> option will be used in this case).  This
  method is similar to the <computeroutput>new</computeroutput> method where the programmer supplies a
  ProgID or CLSID. In this case the programmer supplies a moniker.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
/* create a Word.Document by opening a certain file */
myOLEObject = .OLEObject~GetObject("C:\DOCS\HELLOWORLD.DOC")
</programlisting>
</section>

<section id="oleobgetoutpar"><title>getOutParameters</title>
<indexterm><primary>getOutParameters method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getOutParameters method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getOutParameters--------------------------------------------><
]]>
</programlisting>

<para>Returns an array containing the results of the single
<computeroutput>out</computeroutput> parameters
of the OLE object, or the .NIL object if it does not have any.
<computeroutput>Out</computeroutput> parameters
are arguments to the OLE object that are filled in by the OLE object. As this
is not possible in Rexx due to data encapsulation, the results are placed
in the array mentioned above.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<para>Consider an OLE object method with the following signature:</para>
<programlisting>
aMethod([in] A, [in] B, [out] sumAB)
</programlisting>
<para>The resulting <computeroutput>out</computeroutput> parameter of the
method invocation will be placed in the <computeroutput>out</computeroutput>
array at position one; the "normal" return
value gets processed as usual. In this case the method will return the .NIL
object:</para>
<programlisting>
resultTest = myOLEObject~aMethod(1, 2, .NIL)
say "Invocation result  :" resultTest
say "Result in out array:" myOLEObject~getOutParameters~at(1)
</programlisting>
<para>The output of this sample script will be:</para>
<programlisting>
The NIL object
3
</programlisting>
<para><computeroutput>Out</computeroutput> parameters are placed in the
<computeroutput>out</computeroutput> array in order
from left to right. If the above OLE method looked like this:</para>
<programlisting>
aMethod([in] A, [in] B, [out] sumAB, [out] productAB),
</programlisting>
<para>then the <computeroutput>out</computeroutput> array would contain the sum
of A and B at position one, and the product at position two.</para>
</section>

<section id="oleobunk"><title>unknown</title>
<indexterm><primary>unknown method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>unknown method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-unknown(messageName--+----------------+--)------------------><
                        +--,messageArgs--+
]]>
</programlisting>

<para>
  The <computeroutput>unknown</computeroutput> message is the central mechanism through which methods of
  the OLE object are called.
</para>
<para>
  For further information on the details on how an <computeroutput>unknown</computeroutput> method works,
  see <emphasis role="italic">Defining an unknown Method</emphasis> in the Open Object Rexx Reference.
</para>
<para>
  The programmer can invoke the methods of the real OLE object by simply invoking the methods on the
  the Rexx (proxy) OLEObject object like this:
</para>
<programlisting>
myOLEObject~OLEMethodName
</programlisting>
<para>
  This calls the method <computeroutput>"OLEMethodName"</computeroutput> of the real OLE object for any
  message (method) <emphasis role="italic">that does not exist</emphasis> in the Rexx OLEObject object
  through the <emphasis role="italic">unknown</emphasis> method mechanism. The implementation for the
  <computeroutput>unknown</computeroutput>() method in the OLEObject class does this by dispatching the
  method call to the real OLE object.
</para>
<para>
  This presents a problem when an OLE object has a method with a name that is identical to a method
  defined for the OLEObject object. When this situation happens, the programmer has two choices.
</para>
<para>
  One choice is for the programmer to call the <computeroutput>unknown</computeroutput> method directly.
  E.g., take an OLE object that has the method <computeroutput>copy</computeroutput> used to copy
  something from a source to a destination. Since <computeroutput>copy</computeroutput> is a method
  of the <computeroutput>Object</computeroutput> class, the copy method of the OLE object is a method
  name already defined for the OLEObject. The programmer can invoke the
  <computeroutput>unknown</computeroutput> method directly, like this:
</para>
<programlisting>
msgArgs = .array~of("C:\open\myFile.txt", "C:\processDir\")
val = myOLEObject~unknown("copy", msgArgs)
</programlisting>
<para>
  This causes the implementation of the <computeroutput>unknown</computeroutput>() method in the
  OLEObject object to invoke the <computeroutput>copy</computeroutput> method of the OLE object with the
  arguments of <computeroutput>C:\open\myFile.txt</computeroutput> and
  <computeroutput>C:\processDir\</computeroutput>.
</para>
<para>
  The other thing the Rexx programmer can do is use the <link linkend="oledispatch">dispatch</link>()
  method. Since, in OLE automation terms, the act of invoking a method on the OLE object is commonly
  referred to as <emphasis role="italic">dispatching</emphasis> a message to the OLE object, this may
  make the code a little easier to understand.  In the above example the
  <computeroutput>dispatch</computeroutput> method would be used like this:
</para>
<programlisting>
val = myOLEObject~dispatch("copy", "C:\open\myFile.txt", "C:\processDir\")
</programlisting>
</section>

<section id="oleobtypconv"><title>Type Conversion</title>
<indexterm><primary>Type conversion</primary></indexterm>
<para>Unlike Rexx, OLE uses strict typing of data. Conversion to and from these
types is done automatically, if conversion is possible. OLE types are called
variants, because they are stored in one structure that
gets flagged with the type it represents. The following is a list of all variant
types valid for use with OLE Automation and the Rexx objects that they are
converted from or into.</para>

<table frame="all">
<title>OLE/Rexx Types</title>
<tgroup cols="2">
<thead>
<row>
<entry>VARIANT type</entry>
<entry>Rexx object</entry>
</row>
</thead>
<tbody>
<row>
<entry>VT_EMPTY</entry>
<entry>.NIL</entry>
</row>
<row>
<entry>VT_NULL</entry>
<entry>.NIL</entry>
</row>
<row>
<entry>VT_ERROR</entry>
<entry>.NIL</entry>
</row>
<row>
<entry>VT_I1</entry>
<entry>Rexx string (a whole number)</entry>
</row>
<row>
<entry>VT_I2</entry>
<entry>Rexx string (a whole number)</entry>
</row>
<row>
<entry>VT_I4</entry>
<entry>Rexx string (a whole number)</entry>
</row>
<row>
<entry>VT_I8</entry>
<entry>Rexx string (a whole number)</entry>
</row>
<row>
<entry>VT_UI1</entry>
<entry>Rexx string (a whole, positive number)</entry>
</row>
<row>
<entry>VT_UI2</entry>
<entry>Rexx string (a whole, positive number)</entry>
</row>
<row>
<entry>VT_UI4</entry>
<entry>Rexx string (a whole, positive number)</entry>
</row>
<row>
<entry>VT_UI8</entry>
<entry>Rexx string (a whole, positive number)</entry>
</row>
<row>
<entry>VT_INT</entry>
<entry>Rexx string (a whole number)</entry>
</row>
<row>
<entry>VT_UINT</entry>
<entry>Rexx string (a whole, positive number)</entry>
</row>
<row>
<entry>VT_DECIMAL</entry>
<entry>Rexx string (a decimal number)</entry>
</row>
<row>
<entry>VT_R4</entry>
<entry>Rexx string (a real number)</entry>
</row>
<row>
<entry>VT_R8</entry>
<entry>Rexx string (a real number)</entry>
</row>
<row>
<entry>VT_CY</entry>
<entry>Rexx string (currency, a fixed-point number with 15 digits to
the left of the decimal point and 4 digits to the right)</entry>
</row>
<row>
<entry>VT_DATE</entry>
<entry>Rexx string (a date)</entry>
</row>
<row>
<entry>VT_BSTR</entry>
<entry>Rexx string</entry>
</row>
<row>
<entry>VT_DISPATCH Rexx</entry>
<entry>OLEObject</entry>
</row>
<row>
<entry>VT_BOOL</entry>
<entry>.TRUE or .FALSE</entry>
</row>
<row>
<entry>VT_VARIANT</entry>
<entry>Any Rexx object that can be represented as a VARIANT</entry>
</row>
<row>
<entry>VT_UNKNOWN</entry>
<entry>OLEObject</entry>
</row>
<row>
<entry>VT_ARRAY *</entry>
<entry>Rexx Array</entry>
</row>
<row>
<entry>VT_BYREF *</entry>
<entry>Any Rexx object</entry>
</row>
</tbody>
</tgroup>
</table>
<para>* VT_ARRY and VT_BYREF are combined with any of the other variant types
and never used alone. VT_ARRAY and another variant type are used for a SAFEARRAY
datatype, an array of the other variant type.  VT_BYREF and another variant type
are used to pass the other variant type to or from an OLE object by reference.
The programmer need not worry about this passing by reference, the OLE support
handles this transparently.</para>
</section>
</section>

<section id="clsWinOLEVariant"><title>The Windows OLEVariant Class</title>
<indexterm><primary>OLEVariant Class</primary></indexterm>

<para>
The OLEVariant class enhances the support for OLE Automation provided by the
<link linkend="clsWinOLEObject">OLEObject class</link> and is used in conjunction with
that class.  An OLEVariant object is used as a parameter in a method call of
an OLEObject object.  In the OLEObject's role as a proxy for a OLE / COM
object, the parameters in method calls are forwarded on to the actual OLE /
COM object.  (OLE / COM objects will be referred to simply as COM objects.)
</para>
<para>
There are two areas where the OLEVariant adds to the capabilities of
OLEObject method calls.</para>
<itemizedlist>
<listitem><para>Parameters forwarded on to COM objects must be converted to and from
the proper datatypes.  This conversion is done automatically (see
<link linkend="oleobtypconv">OLEObject Type Conversion</link>.)
Occasionally this automatic conversion is
incorrect.  The OLEVariant allows the ooRexx programmer to override the
automatic conversion by specifying how the conversion should be done.
</para></listitem>
<listitem><para>COM objects can return data to the caller in "out" parameters ([OUT]
parameters.)  The OLEVariant can be used to transport this returned data
back to the calling ooRexx program.
</para></listitem>
</itemizedlist>
<para>
In general, the automatic type conversion in the OLE support uses type
libraries to determine how to format the parameters being sent to an OLE
object in a method call.  The information in a type library specifies the
variant type an ooRexx object, used as a parameter, needs to be converted
to.  Type libraries also detail how a parameter is to be flagged when it is
sent to the COM object.
</para>
<para>
However, COM objects are not required to supply type libraries.  When there
is no type library, ooRexx uses an educated guess to determine this
information.  On rare occasions this guess is wrong and the method call
fails.  In theses cases, if the ooRexx programmer knows what the correct
information is, the programmer can use an OLEVariant to specify this
information.  The programmer can supply either or both of these pieces of
information by specifying the variant type for the converted ooRexx object
and the parameter flags.
</para>
<para>
The following is a real world example where the automatic conversion in the
OLE support does not work and shows how the OLEVariant is used to specify
the correct conversion.  The snippet comes from code to automate a CICS
client.  In this case the variant type that the ooRexx object needs to be
converted to is specified.  The parameter flags are omitted.  The fourth
parameter to the ~link method call is the parameter where the default
conversion was failing.
</para>
<programlisting>
  connect  = .OLEObject~new("Ccl.Connect")
  flow     = .OLEObject~new("Ccl.Flow")
  buffer   = .OLEObject~new("Ccl.Buffer")

  uow      = .OLEVariant~New(.nil, VT_DISPATCH)
  ...
  connect~link(flow, "FOO", buffer, uow)
</programlisting>
<note><para>
It is extremely rare that the OLE support fails to do the right thing
with its automatic conversion.  99.999% of the time the ooRexx programmer
does not need to use an OLEVariant object to specify the type conversion.
This use of the OLEVariant is provided for those few times when it is
necessary to override the default conversion.  Furthermore, if the ooRexx
programmer does not know what variant type to specify, this usage will not
be much help.  Normally the ooRexx programmer would know what type to
specify through the documentation for the COM class the programmer is using.
</para></note>
<para>
The next example shows how the OLEVariant can be used to transport the data
returned in an "out" parameter back to the calling ooRexx program.  This
usage will be more common and does not require that the ooRexx have a lot of
detailed knowledge of the COM object.  Obviously, the programmer does need
to know that the parameter is an out parameter.  This example comes from
updating a MS Access database where the number of records affected by the
update is returned in an "out" parameter.  Here the out parameter is the
second parameter in the ~execute method call.
</para>
<programlisting>
  sql = "update myTable set id=id*3 where id > 7"
  param = .OLEVariant~new(0)
  conn~execute(sql, param)
  count = param~!varValue_
  say count "record(s) were affected."
</programlisting>
<para>
Finally an example where the OLE support does not use the correct parameter
flags for the method call.  The Windows Management Instrumentation,
Win32_Process COM class does not supply a type library.  The fourth
parameter in the ~create method call is an "out" parameter.  That
information is known by the ooRexx programmer through the documentation of
the class.  However, without a type library, ooRexx has no way to know that.
Here the variant type specification is omitted (signaling ooRexx to go
ahead and use its automatic conversion) and the parameter flags are
specified.  Since this an out parameter, the OLEVariant object is also used
to transport the returned data back to the calling program.
</para>
<programlisting>
  objProcess = .oleObject~getObject("WinMgmts:Win32_Process")

  param = .OLEVariant~new( 0, , "IN,OUT" )
  ret = objProcess~create('notepad.exe', .nil, .nil, param)
  if ret == 0 then do
    pid = param~!varValue_
    say 'The notepad process was created and its PID is' pid
  end
</programlisting>
<para>
<emphasis role="bold">Methods available to the OLEVariant class</emphasis>
</para>
<simplelist>
<member>new</member>
<member>!varValue_</member>
<member>!varValue_=</member>
<member>!varType_</member>
<member>!varType_=</member>
<member>!paramFlags_</member>
<member>!paramFlags_=</member>
</simplelist>
<note><para>
A possible future enhancement of the OLEVariant class requires that
its method names be unique, which is the reason for the method name style.
In normal usage the ooRexx programmer would only be concerned with the new
and the !varValue methods.  Therefore the slightly unorthodox method names
should not present a problem.
</para></note>

<section id="olevarnew"><title>new Class method</title>
<programlisting>
<![CDATA[
>>-new(valueObject-+----------+--+-------------+-)-------------><
                   +-,varType-+  +-,paramFlags-+
]]>
</programlisting>
<para>
Instantiates a new OLEVariant object to be used as a parameter in an
OLEObject method call.  The first argument is the ooRexx object to be
converted to a variant type for the method call.  It is the object to be
used in the method call.  This argument is required.  The varType and
paramFlags arguments are optional.
</para>
<para>
The varType argument is used to specify the type of the variant that the
valueObject is to be converted to.  If this argument is omitted or is .nil
then ooRexx will use the default conversion for the valueObject.  If it is
not omitted it must be a valid OLE Automation variant type and ooRexx will
attempt to convert the valueObject to this variant type.
</para>
<para>
The valid variant type symbols are listed in Table
<link linkend="oleobtypconv">OLE/Rexx Types</link>.
In addition any of those symbols can be combined with the
VT_BYREF or the VT_ARRAY symbol.  When symbols are combined a comma is used
to separate the two symbols.  This of course necessitates that the argument
be quoted.  Case does not matter for this argument.  For example vt_bool,
VT_bool, or VT_BOOL are all treated the same.
</para>
<para>
The paramFlags argument is used to specify the flags for the parameter.  The
flags are separated by a comma.  Although any combination of valid
PARAMFLAGS as defined for OLE Automation will be accepted, in practice the
ooRexx programmer will probably only need to use "IN,OUT" for this argument.
</para>
<para>
The PARAMFLAGS defined for OLE Automation:
</para>
<simplelist>
<member>PARAMFLAG_NONE</member>
<member>PARAMFLAG_FIN</member>
<member>PARAMFLAG_FOUT</member>
<member>PARAMFLAG_FLCID</member>
<member>PARAMFLAG_FRETVAL</member>
<member>PARAMFLAG_FOPT</member>
<member>PARAMFLAG_FHASDEFAULT</member>
<member>PARAMFLAG_FHASCUSTDATA</member>
</simplelist>
<para>
The ooRexx programmer should only use the last portion of the symbol.  I.e.,
NONE, IN, OUT, LCID, RETVAL, OPT, HASDEFAULT, or HASCUSTOMDATA.  Case also
does not matter for this argument and "in,out" is equivalent to "IN,OUT"
</para>
<para>
If the paramFlags argument is omitted or .nil, (the normal case,) ooRexx
will determine the flags for the parameter through its default mechanism.
If the argument is not omitted, ooRexx will use the specified flags
unconditionally.
</para>
<note><para>
If either the varType or paramFlags arguments are used, and not the
.nil object, they must be valid variant types or param flags for OLE
Automation.  If they are not valid, a syntax error will be raised.
</para></note>
<programlisting>
manager = .oleObject~new("com.sun.star.ServiceManager", "WITHEVENTS")
cf = manager~createInstance("com.sun.star.reflection.CoreReflection")
...
classSize = .cf~forName("com.sun.star.awt.Size")

param = .OLEVariant~new(.nil, "VT_DISPATCH,VT_BYREF", "IN,OUT")

retVal = classSize~createObject(param)
</programlisting>
</section>

<section><title>!VARVALUE_</title>

<programlisting>
<![CDATA[
>>-!VARVALUE_--------------------------------------------------><
]]>
</programlisting>
<para>
Returns the value object set within an instance of an OLEVariant.  If the
parameter in a COM method call that the OLEVariant was used for is an "out"
parameter, than the value object of the instance will be the data returned
by the COM object.  Otherwise, the value object is that set by the ooRexx
programmer.
</para>
<programlisting>
manager = .oleObject~new("com.sun.star.ServiceManager", "WITHEVENTS")
cf = manager~createInstance("com.sun.star.reflection.CoreReflection")
...
classSize = .cf~forName("com.sun.star.awt.Size")

param = .OLEVariant~new(.nil, "VT_DISPATCH,VT_BYREF", "IN,OUT")

retVal = classSize~createObject(param)
size = param~!varValue_
</programlisting>
</section>

<section><title>!VARVALUE_=</title>

<programlisting>
<![CDATA[
>>-!VARVALUE_=-------------------------------------------------><
]]>
</programlisting>
<para>
Sets the value object an instance of an OLEVariant contains.
</para>
</section>

<section><title>!VARTYPE_</title>

<programlisting>
<![CDATA[
>>-!VARTYPE_---------------------------------------------------><
]]>
</programlisting>
<para>
Returns the variant type specification of the OLEVariant instance.
</para>
</section>

<section><title>!VARTYPE_=</title>

<programlisting>
<![CDATA[
>>-!VARTYPE_=--------------------------------------------------><
]]>
</programlisting>
<para>
Sets the variant type specification of an OLEVariant instance.  This serves
the same purpose as the second argument to the
<link linkend="olevarnew">new method</link>
and follows the same rules as specified in the documentation of the
new method.  I.e., the value must be a valid variant type used in OLE
Automation, or .nil.  If not a syntax error is raised.
</para>
</section>

<section><title>!PARAMFLAGS_</title>

<programlisting>
<![CDATA[
>>-!PARAMFLAGS_------------------------------------------------><
]]>
</programlisting>
<para>
Returns the parameter flags specification of the OLEVariant instance.
</para>
</section>

<section><title>!PARAMFLAGS_=</title>

<programlisting>
<![CDATA[
>>-!PARAMFLAGS_=-----------------------------------------------><
]]>
</programlisting>
<para>
Sets the flags specification of an OLEVariant instance.  This serves the
same purpose as the third argument to the
<link linkend="olevarnew">new method</link>
and follows the same rules as specified in the documentation of the new
method.  I.e., the value must be a valid combination of PARAMFLAG types as
documented for use in OLE Automation, or .nil.  If not a syntax error is
raised.
</para>
</section>
</section>

<section id="clsWinClipboard"><title>The WindowsClipboard Class</title>
<indexterm><primary>WindowsClipboard class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsClipboard class</secondary></indexterm>
<para>The WindowsClipboard class provides methods to access the data in the
Windows clipboard.</para>
<para>The WindowsClipboard class is not a built-in class. It is defined
in the WINSYSTM.CLS file. This means, you must use a
::requires statement to activate its functionality, as follows:</para>
<programlisting>
<![CDATA[
::requires "WINSYSTM.CLS"
]]>
</programlisting>
<para><emphasis role="bold">Methods the WindowsClipboard Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>copy</para></listitem>
<listitem><para>makeArray</para></listitem>
<listitem><para>paste</para></listitem>
<listitem><para>empty</para></listitem>
<listitem><para>isDataAvailable</para></listitem></itemizedlist>

<section id="copywc"><title>copy</title>
<indexterm><primary>copy method</primary>
<secondary>of WindowsClipboard class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>copy method</secondary>
<tertiary>of WindowsClipboard class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-copy--(--text--)--------------------------------------------><
]]>
</programlisting>

<para>Empties the clipboard and copies the specified text to it.</para>
</section>

<section id="mkarwc"><title>makeArray</title>
<indexterm><primary>makeArray method</primary>
<secondary>of WindowsClipboard class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>makeArray method</secondary>
<tertiary>of WindowsClipboard class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-makeArray---------------------------------------------------><
]]>
</programlisting>

<para>If the content of the clipboard is a string with newline characters
in it, makeArray can be used to split up the string into individual
lines. An array is returned containing those lines.</para>
</section>

<section id="pastewc"><title>paste</title>
<indexterm><primary>paste method</primary>
<secondary>of WindowsClipboard class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>paste method</secondary>
<tertiary>of WindowsClipboard class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-paste-------------------------------------------------------><
]]>
</programlisting>

<para>Retrieves the text data stored on the clipboard.</para>
</section>

<section id="emptywc"><title>empty</title>
<indexterm><primary>empty method</primary>
<secondary>of WindowsClipboard class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>empty method</secondary>
<tertiary>of WindowsClipboard class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-empty-------------------------------------------------------><
]]>
</programlisting>

<para>Empties the clipboard.</para>
</section>

<section id="isdataavailablewc"><title>isDataAvailable</title>
<indexterm><primary>isDataAvailable method</primary>
<secondary>of WindowsClipboard class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isDataAvailable method</secondary>
<tertiary>of WindowsClipboard class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isDataAvailable---------------------------------------------><
]]>
</programlisting>

<para>Returns 1 if the text data is available on the clipboard. If no data is
available, 0 is returned.</para>
</section>
</section>

<section id="clsWinEventLog"><title>The WindowsEventLog Class</title>
<indexterm><primary>WindowsEventLog class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsEventLog class</secondary></indexterm>
<para>Object Rexx provides a class for interaction with the Windows NT event
log. You can use this class to read, write, and clear event-log
records. This class is specifically for Windows NT systems and might not be
available on other systems.</para>
<para>The WindowsEventLog class is not a built-in class; it is defined in the
file <computeroutput>WINSYSTM.CLS</computeroutput>. Use a
<computeroutput>::requires</computeroutput> statement to activate
its function: </para>
<programlisting>
::requires "winsystm.cls"
</programlisting>
<para>A sample program <computeroutput>EventLog.REX</computeroutput>
is provided in the <computeroutput>ooRexx\SAMPLES</computeroutput> directory.
</para>
<para><emphasis role="bold">Methods the WindowsEventLog Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>new (Class method)</para></listitem>
<listitem><para>open</para></listitem>
<listitem><para>close</para></listitem>
<listitem><para>read</para></listitem>
<listitem><para>write</para></listitem>
<listitem><para>clear</para></listitem>
<listitem><para>getNumber</para></listitem></itemizedlist>

<section id="initwel"><title>new (Class method)</title>
<indexterm><primary>new method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>--new--------------------------------------------------------><
]]>
</programlisting>

<para>
  Creates an instance of the WindowsEventLog class.
</para>
</section>

<section id="openwel"><title>open</title>
<indexterm><primary>open method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>open method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-open-+---------------------------------+--------------------><
        +-(--+-----------------------+--)-+
             +-server--+-----------+-+
                       +-,--source-+
]]>
</programlisting>

<para>Opens the specified event log.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>server</term>
<listitem><para>The UNC (universal naming convention) name of the server on which
the event log is to be opened. If this argument is not specified, the log is
opened at the local machine.
</para></listitem></varlistentry>
<varlistentry><term>source</term>
<listitem><para>The name of the source of the event log. It must be a subkey of
a log file entry under the EventLog key in the registry. If, for example, the
registry looks as follows:
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
      EventLog
        Application
          WinApp1
        Security
          WinApp2
        System
</programlisting>
&quot;Application&quot;, &quot;Security&quot;, &quot;System&quot;,
&quot;WinApp1&quot;, and &quot;WinApp2&quot; are valid sources.
If the source is not found, the &quot;Application
Log&quot; is used.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>Return value:</term>
<listitem><para>The method returns:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The open succeeded.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The open failed.
</para></listitem></varlistentry>
</variablelist></para></listitem>
</varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following two code snippets are equivalent.  They both open
the Application log on the local machine if they succeed:
</para>
<programlisting>
event_log1 = .WindowsEventLog~new
rc = event_log1~open
if rc == 1 then do
  say 'Failed to open the event log'
  ...
end

event_log = .WindowsEventLog~new
rc = event_log~open(,"Application")
if rc == 1 then do
  say 'Failed to open the event log'
  ...
end
</programlisting>
<para>The following example opens the System log on SERVER01:</para>
<programlisting>

event_log = .WindowsEventLog~new
rc = event_log~open("\\SERVER01","System")
if rc == 0 then do
  -- Do something with the event log
  ...
  event_log~close
  ...
end
else do
  -- Handle the error in some way
  ...
end
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>

<section id="closewel"><title>close</title>
<indexterm><primary>close method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>close method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-close-------------------------------------------------------><
]]>
</programlisting>

<para>Closes an open event log.</para>
</section>

<section id="readwel"><title>read</title>
<indexterm><primary>read method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>read method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-read--+---------------------------------------------------+-->
         |    +-FORWARDS--+                                  |
         +-(--+-----------+--,--+--------+--,--+--------+--,-+
              +-BACKWARDS-+     +-server-+     +-source-+

>--+--------------------------+--------------------------------><
   +-+-------+--,--+-----+--)-+
     +-start-+     +-num-+
]]>
</programlisting>

<para>Reads an event log and returns an array containing the event records. If
the event log was not opened with the OPEN method, the event log specified by
the <emphasis role="italic">server</emphasis> and <emphasis
role="italic">source</emphasis> is opened and closed after processing.
</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>server</term>
<listitem><para>The UNC (universal naming convention) name of the server on which
the event log is to be opened. If this argument is not specified, the log is
opened at the local machine.</para>
<para>This argument is only used if the event log was not
opened before.</para>
</listitem></varlistentry>
<varlistentry><term>source</term>
<listitem><para>The name of the source of the event log. It must be a subkey of
a log file entry under the EventLog key in the registry. If, for example, the
registry looks as follows:
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
      EventLog
        Application
          WinApp1
        Security
          WinApp2
        System
</programlisting>
&quot;Application&quot;, &quot;Security&quot;, &quot;System&quot;,
&quot;WinApp1&quot;, and &quot;WinApp2&quot; are valid sources. If the source is
not found, the &quot;Application Log&quot; is used.</para>
<para>This argument is only used if the event log was not opened
before.</para>
</listitem></varlistentry>
<varlistentry><term>start</term>
<listitem><para>The record number of the event log record to be started.
The oldest record is always the first record regardless of the direction
specified.
</para></listitem></varlistentry>
<varlistentry><term>num</term>
<listitem><para>The number of the event log record to be read.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
evl = .WindowsEventLog~new

if evl~InitCode \= 0 then exit

say " reading complete System log forwards without opening it before "

records = evl~read("FORWARDS", ,"System")

if records \= .nil then
  call DisplayRecords
else
  say "==> Error reading complete System event log"

evl~deinstall

exit 0   /* leave program */

DisplayRecords:

say records~items "records read"

do i=1 to records~items
  say "============================================================="
  temp = records[i]
  parse var temp type date time "&apos;" sourcename"&apos;" id,
  userid computer "&apos;" string "&apos;" "&apos;" data "&apos;"
  say "Type	: "type
  say "Date	: "date
  say "Time	: "time
  say "Source	: "sourcename
  say "ID	: "id
  say "UserId	: "userid
  say "Computer : "computer
  say "Detail	: "string
  say "Data 	: "data
end
return

::requires "winsystm.cls"
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="writewel"><title>write</title>
<indexterm><primary>write method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>write method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-write--+-------------------------------------------------------------+-->
          |                                  +-1--+     +-0--------+    |
          +-(--+--------+--,--+--------+--,--+----+--,--+----------+--,-+
               +-server-+     +-source-+     +-0--+     +-category-+
                                             +-2--+
                                             +-4--+
                                             +-8--+
                                             +-10-+

>--+---------------------------------------+-------------------><
   | +-0--.                                |
   +-+----+--,--+------+--,--+--------+--)-+
     +-id-+     +-data-+     +-string-+
]]>
</programlisting>

<para>Writes event log records. If the event log was not opened with the Open
method, the event log specified by the <emphasis role="italic">server</emphasis>
and <emphasis role="italic">source</emphasis> is
opened and closed after processing.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>server</term>
<listitem><para>The UNC (universal naming convention) name of the server on
which the event log is to be opened. If this argument is not specified, the
log is opened at the local machine.
</para></listitem></varlistentry>
<varlistentry><term>source</term>
<listitem><para>The name of the source of the event log. It must be a subkey of
a log file entry under the EventLog key in the registry. If, for example, the
registry looks as follows:
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
      EventLog
        Application
          WinApp1
        Security
          WinApp2
        System
</programlisting>
&quot;Application&quot;, &quot;Security&quot;, &quot;System&quot;,
&quot;WinApp1&quot;, and &quot;WinApp2&quot; are valid sources. If the source
is not found, the &quot;Application Log&quot; is used.
</para></listitem></varlistentry>
<varlistentry><term>type</term>
<listitem><para>The type of the events to be logged. It can be one of the
numbers listed in the syntax diagram:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>SUCCESS
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>ERROR, which is the default
</para></listitem></varlistentry>
<varlistentry><term>2</term>
<listitem><para>WARNING
</para></listitem></varlistentry>
<varlistentry><term>4</term>
<listitem><para>INFORMATION
</para></listitem></varlistentry>
<varlistentry><term>8</term>
<listitem><para>AUDIT SUCCESS
</para></listitem></varlistentry>
<varlistentry><term>10</term>
<listitem><para>AUDIT FAILURE
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>category</term>
<listitem><para>The event category. This is source-specific information that
can have any value. The default is 0.
</para></listitem></varlistentry>
<varlistentry><term>id</term>
<listitem><para>The event identifier specifying the message that, together with
the event, is an entry in the message file associated with the event source.
The default is 0.
</para></listitem></varlistentry>
<varlistentry><term>data</term>
<listitem><para>The binary data. This is source-specific information and can
be omitted.
</para></listitem></varlistentry>
<varlistentry><term>string</term>
<listitem><para>The strings merged into the message.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example writes the strings and the data to the
system log. &quot;MyApplication&quot; must be a subkey of a log file entry
under the EventLog key in the registry. If the source name cannot be found,
event logging uses the Application log file.</para>
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
        EventLog
        Application
        Security
          System
            MyApplication
	    </programlisting>
<programlisting>
evl~Write(,"MyApplication", , , ,"1A 1B 1C 0000 00"x, ,
"First String", "Second String")
</programlisting>
<para>See the <computeroutput>EventLog.REX</computeroutput> for
more examples.</para>
</listitem></varlistentry>
</variablelist>
</section>

<section id="clearwel"><title>clear</title>
<indexterm><primary>clear method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>clear method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-clear-+------------------------------------------------------------+-><
         +-(--+--------------------------------------------------+--)-+
              +-server--+--------------------------------------+-+
                        +-,--+--------+--+-------------------+-+
                             +-source-+  +-,--backupFileName-+
]]>
</programlisting>

<para>Clears the specified event log and, optionally, saves a copy of the
current log file as a backup file. If the event log was not opened with the
Open method, the event log specified by the
<emphasis role="italic">server</emphasis> and
<emphasis role="italic">source</emphasis> is opened.
The event log is closed after it is cleared.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>server</term>
<listitem><para>The UNC (universal naming convention) name of the server on
which the event log is to be opened. If this argument is not specified, the
log is opened at the local machine.</para>
<para>This argument is only used if the event log was not
opened before.</para>
</listitem></varlistentry>
<varlistentry><term>source</term>
<listitem><para>The name of the source of the event log. It must be a subkey
of a log file entry under the EventLog key in the registry. If, for example,
the registry looks as follows:
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
      EventLog
        Application
          WinApp1
        Security
          WinApp2
        System
</programlisting>
&quot;Application&quot;, &quot;Security&quot;, &quot;System&quot;,
&quot;WinApp1&quot;, and &quot;WinApp2&quot; are valid sources. If the source
is not found, the &quot;Application Log&quot; is used.</para>
<para>This argument is only used if the event log was not opened
before.</para>
</listitem></varlistentry>
<varlistentry><term>backupFileName</term>
<listitem><para>The name of a file to which the copy of the current event log
file is to be written. If this file already exists, the function fails.
The file can reside on a remote server. </para>
<para>If you omit this argument, the current event
log file is not backed up but cleared.</para>
</listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example creates a backup of the Application event log
of the local machine and clears it:</para>
<programlisting>
event_log~CLEAR(, ,"e:\evlbackup\application.evt")
</programlisting>
<para>The following example creates a backup of the System event log on
the server \\SERVER01 and clears it:</para>
<programlisting>
event_log~CLEAR("\\SERVER01","System","e:\evlbackup\system_server01.evt")
</programlisting>
<para>The following example clears the Application log on the local
machine without a backup:</para>
<programlisting>
event_log~CLEAR
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>

<section id="getnumberwel"><title>getNumber</title>
<indexterm><primary>getNumber method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getNumber method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getNumber-+---------------------------------+---------------><
             +-(--+-----------------------+--)-+
                  +-server--+-----------+-+
                            +-,--source-+
]]>
</programlisting>

<para>Retrieves the number of records in the specified event log. If the event
log was not opened with the Open method, the event log specified by the
<emphasis role="italic">server</emphasis> and
<emphasis role="italic">source</emphasis> is opened and closed after processing.
</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>server</term>
<listitem><para>The UNC (universal naming convention) name of the server on
which the event log is to be opened. If this argument is not specified, the log
is opened at the local machine.</para>
<para>This argument is only used if the event log was not
opened before.</para>
</listitem></varlistentry>
<varlistentry><term>source</term>
<listitem><para>The name of the source of the event log. It must be a subkey of
a log file entry under the EventLog key in the registry. If, for example, the
registry looks as follows:
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
      EventLog
        Application
          WinApp1
        Security
          WinApp2
        System
</programlisting>
&quot;Application&quot;, &quot;Security&quot;, &quot;System&quot;,
&quot;WinApp1&quot;, and &quot;WinApp2&quot; are valid sources. If the source
is not found, the &quot;Application Log&quot; is used.</para>
<para>This argument is only used if the event log was not opened
before.</para>
</listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example returns the number of event log records
in the Application log of the local machine:
<programlisting>
num = event_log~getNumber
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="clsWinManager"><title>The WindowsManager Class</title>
<indexterm><primary>WindowsManager class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsManager class</secondary></indexterm>
<para>
  The WindowsManager class provides methods to query, manipulate, and interact with windows on your
  desktop. This class is specifically for the Windows operating sytsem and is not available on other
  operating systems.
</para>
<para>The WindowsManager class is not a built-in class; it is defined in the
file <computeroutput>WINSYSTM.CLS</computeroutput>. Use a
<computeroutput>::requires</computeroutput> statement to activate
its function: </para>
<programlisting>
::requires "winsystm.cls"
</programlisting>
<para><emphasis role="bold">Methods the WindowsManager Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>desktopWindow</para></listitem>
<listitem><para>find</para></listitem>
<listitem><para>foregroundWindow</para></listitem>
<listitem><para>windowAtPosition</para></listitem>
<listitem><para>consoleTitle</para></listitem>
<listitem><para>consoleTitle=</para></listitem>
<listitem><para>sendTextToWindow</para></listitem>
<listitem><para>pushButtonInWindow</para></listitem>
<listitem><para>processWindowCommand</para></listitem>
<listitem><para>broadcastSettingChanged</para></listitem></itemizedlist>

<section id="mthDesktopWindow"><title>desktopWindow</title>
<indexterm><primary>desktopWindow method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>desktopWindow method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-desktopWindow-----------------------------------------------><
]]>
</programlisting>

<para>
  Returns an instance of the <link linkend="clsWinObject">WindowObject</link> class that represents
  the Desktop window.  The Desktop window is the parent of all top-level windows and therefore the
  ancestor of every window on the system.  If some error happens,
  <computeroutput>.nil</computeroutput> is returned.  (This is extremely unlikely.)
</para>
</section>

<section id="findwm"><title>find</title>
<indexterm><primary>find method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>find method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-find--(--title--)-------------------------------------------><
]]>
</programlisting>

<para>Searches for a top-level window (not a child window) on your desktop with
the specified <emphasis role="italic">title</emphasis>.</para>
<para>If this window already exists, an instance of the WindowObject class is
returned. Otherwise, .Nil is returned.</para>
</section>

<section id="foregroundwindowwm"><title>foregroundWindow</title>
<indexterm><primary>foregroundWindow method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>foregroundWindow method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-foregroundWindow--------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class that is associated with the
current foreground window.</para>
</section>

<section id="windowatpositionwm"><title>windowAtPosition</title>
<indexterm><primary>windowAtPosition method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>windowAtPosition method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-windowAtPosition--(--x--,--y--)-----------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class that is associated with the
window at the specified position (<emphasis role="italic">x,y</emphasis>). The
coordinates are specified
in screen pixels. This method does not retrieve hidden or disabled windows.
If you are interested in a particular child window, use method
<link linkend="childatpositionwo">childAtPosition</link>.</para>
</section>

<section id="consoletitlewm"><title>consoleTitle</title>
<indexterm><primary>consoleTitle method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>consoleTitle method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-consoleTitle------------------------------------------------><
]]>
</programlisting>

<para>Returns the title of the current console.</para>
</section>

<section id="consoletitlenewwm"><title>consoleTitle=</title>
<indexterm><primary>consoleTitle= method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>consoleTitle= method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-consoleTitle=title------------------------------------------><
]]>
</programlisting>

<para>Sets the title of the current console.</para>
</section>

<section id="sendtexttowindowwm"><title>sendTextToWindow</title>
<indexterm><primary>sendTextToWindow method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendTextToWindow method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendTextToWindow--(--title--,--text--)----------------------><
]]>
</programlisting>

<para>Sends a case-sensitive <emphasis role="italic">text</emphasis> to the
window with the specified <emphasis role="italic">title.</emphasis>.</para>
</section>

<section id="pushbuttoninwindowwm"><title>pushButtonInWindow</title>
<indexterm><primary>pushButtonInWindow method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>pushButtonInWindow method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-pushButtonInWindow--(--title--,--text--)--------------------><
]]>
</programlisting>

<para>Selects the button with label <emphasis role="italic">text</emphasis>
in the window with the specified <emphasis role="italic">title</emphasis>.
If the button's label contains a mnemonic (underscored letter),
you must specify an ampersand (&amp;) in front of it. You can also use this
method to select radio buttons and to check or uncheck check boxes.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
winmgr~pushButtonInWindow("Testwindow","List &amp;Employees")
</programlisting>
</section>

<section id="processmenucommandwm"><title>processMenuCommand</title>
<indexterm><primary>processMenuCommand method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>processMenuCommand method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-processMenuCommand--(--+-------+--,--+-------+--,------------>
                          +-title-+     +-popup-+

   +-,-------+
   V         |
>----submenu-+--,--menuItem--)---------------------------------><
]]>
</programlisting>

<para>Selects an item of the menu or submenu of the specified window
<emphasis role="italic">title</emphasis>. You can specify as many submenus as
necessary to get to the required item.</para>
</section>

<section id="broadcastsettingchanged"><title>broadcastSettingChanged</title>
<indexterm><primary>broadcastSettingChanged method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>broadcastSettingChanged method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-broadcastSettingChanged--+-----------+----------------------><
                            +-(timeOut)-+
]]>
</programlisting>

<para>Causes the Windows operating system to send a message, (the
WM_SETTINGCHANGE message,) to every top-level window on the Desktop informing
them that a system-wide setting has changed.  Well-written applications will
then reload any system settings that they use.</para>
<para>An example of one use for this might be an installer program setting an
environment variable, such as the PATH.  Then a call to broadcastSettingChanged
would cause all open applications to update their reference to the environment,
without the necessity of a reboot.</para>
<para>There are two variations of calling this method.  When called with no
arguments, the message is broadcast and returns immediately.  When called with
the time out parameter, the message is broadcast and does not return until
every window on the Desktop has acknowledged the message, or timed out.</para>
<para>The problem with using a time out and waiting for acknowledgment is that,
if a window is not responding, or several windows are slow to respond, it
may take a very long time to return.  The problem with not using a time out
and returning immediately is that the caller will have no way of knowing when
every window has received the message.  Generally this is not a problem, but
it is up to the programmer to decide how she wants to use this method.</para>
<para>The time out value is specified in milliseconds.  For each window, the
operating system will wait up to the time out for a response before going
on to the next window.  Typically a time out value of 5000 (5 seconds) is
used, and this is the default.</para>
<para>The single optional argument is:</para>
<variablelist>
<varlistentry><term><emphasis role="italic">timeOut</emphasis></term>
<listitem><para>The time, in milliseconds, to wait for each window to
acknowledge it received the setting changed message. Specifying 0 or a negative
number will cause the default time out of 5000 to be used.  (5000 is a typical
value used by applications.)
</para></listitem></varlistentry>
</variablelist>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The setting changed message was broadcast successfully.  If no
time out argument was used, then this is all it means.  If a time out value was
used, then all top-level windows have acknowledged receiving the message.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>The setting changed message was broadcast, but one or more
windows timed out.  This return can only happen when the time out parameter
is used.
</para></listitem></varlistentry>
<varlistentry><term>-x</term>
<listitem><para>A number less than -1 indicates a system error occurred.
This value is the negation of the system error code.  I.e., if the return is
-1400, the system error code was 1400.  System error codes can be looked up in
the MSDN library or the Windows Platform SDK.  Microsoft makes these references
available on the Internet.
</para></listitem></varlistentry>
<varlistentry><term>+x</term>
<listitem><para>A number greater than 0 would be a window result of broadcasting
the setting changed message and would not be an error.  It is unlikely that this
would occur.
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
ret = winmgr~broadcastSettingChanged(1000)
</programlisting>
</section>
</section>

<section id="clsWinObject"><title>The WindowObject Class</title>
<indexterm><primary>WindowsObject class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsObject class</secondary></indexterm>
<para>
  The WindowObject class provides methods to query, manipulate, and interact with a particular window or
  one of its child windows.
</para>
<para>
  Access to WindowObjects requires that the following directive appear in the Rexx program.
</para>
<programlisting>
::requires 'winsystm.cls'
</programlisting>
<para>
  <emphasis role="bold">Note.</emphasis> Prior to the release of ooRexx 4.0.0, the WindowsObject class
  was implemented using the original external function API. That API required that the external functions
  be registered with the interpreter. For the most part this was done transparently to the Rexx
  programmer. However, with the WindowsObject class there was one scenario where the registration was not
  done and prior documentation provided a work around.
</para>
<para>
  Starting with ooRexx 4.0.0, that work around is not needed.  There no longer is any need for the
  programmer to register external functions at all. Requiring
  <computeroutput>winsystm.cls</computeroutput> is all that is needed from ooRexx 4.0.0 and on. Disregard
  the previous documentation concerning this.
</para>

<para><emphasis role="bold">Methods the WindowObject Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>assocWindow</para></listitem>
<listitem><para>childAtPosition</para></listitem>
<listitem><para>coordinates</para></listitem>
<listitem><para>disable</para></listitem>
<listitem><para>enable</para></listitem>
<listitem><para>enumerateChildren</para></listitem>
<listitem><para>findChild</para></listitem>
<listitem><para>first</para></listitem>
<listitem><para>firstChild</para></listitem>
<listitem><para>focusItem</para></listitem>
<listitem><para>focusNextItem</para></listitem>
<listitem><para>focusPreviousItem</para></listitem>
<listitem><para>getStyle</para></listitem>
<listitem><para>handle</para></listitem>
<listitem><para>hide</para></listitem>
<listitem><para>id</para></listitem>
<listitem><para>isMenu</para></listitem>
<listitem><para>last</para></listitem>
<listitem><para>maximize</para></listitem>
<listitem><para>menu</para></listitem>
<listitem><para>minimize</para></listitem>
<listitem><para>moveTo</para></listitem>
<listitem><para>next</para></listitem>
<listitem><para>owner</para></listitem>
<listitem><para>previous</para></listitem>
<listitem><para>processMenuCommand</para></listitem>
<listitem><para>pushButton</para></listitem>
<listitem><para>resize</para></listitem>
<listitem><para>restore</para></listitem>
<listitem><para>sendChar</para></listitem>
<listitem><para>sendCommand</para></listitem>
<listitem><para>sendKey</para></listitem>
<listitem><para>sendKeyDown</para></listitem>
<listitem><para>sendKeyUp</para></listitem>
<listitem><para>sendMenuCommand</para></listitem>
<listitem><para>sendMessage</para></listitem>
<listitem><para>sendMouseClick</para></listitem>
<listitem><para>sendSyscommand</para></listitem>
<listitem><para>sendText</para></listitem>
<listitem><para>state</para></listitem>
<listitem><para>systemMenu</para></listitem>
<listitem><para>title</para></listitem>
<listitem><para>title=</para></listitem>
<listitem><para>toForeground</para></listitem>
<listitem><para>wclass</para></listitem></itemizedlist>

<section id="assocwindowwo"><title>assocWindow</title>
<indexterm><primary>assocWindow method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>assocWindow method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-assocWindow--(--handle--)-----------------------------------><
]]>
</programlisting>

<para>Assigns a new window <emphasis role="italic">handle</emphasis> to the
WindowObject instance.</para>
</section>

<section id="handlewo"><title>handle</title>
<indexterm><primary>handle method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>handle method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-handle------------------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the associated window.</para>
</section>

<section id="titlewo"><title>title</title>
<indexterm><primary>title method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>title method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-title-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the title of the window.</para>
</section>

<section id="titlenewwo"><title>title=</title>
<indexterm><primary>title= method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>title= method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-title=newTitle----------------------------------------------><
]]>
</programlisting>

<para>Sets a new title for the window.</para>
</section>

<section id="wclasswo"><title>wclass</title>
<indexterm><primary>wclass method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>wclass method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-wclass------------------------------------------------------><
]]>
</programlisting>

<para>Returns the class of the window associated with the WindowObject instance.
</para>
</section>

<section id="idwo"><title>id</title>
<indexterm><primary>id method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>id method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-id----------------------------------------------------------><
]]>
</programlisting>

<para>Returns the numeric ID of the window.</para>
</section>

<section id="coordinateswo"><title>coordinates</title>
<indexterm><primary>coordinates method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>coordinates method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-coordinates-------------------------------------------------><
]]>
</programlisting>

<para>Returns the upper left and the lower right corner positions of the window
in the format &quot;left,top,right,bottom&quot;.</para>
</section>

<section id="statewo"><title>state</title>
<indexterm><primary>state method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>state method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-state-------------------------------------------------------><
]]>
</programlisting>

<para>Returns information about the window state. The returned state can contain
one or more of the following constants:</para>
<itemizedlist>
<listitem><para>&quot;Enabled&quot; or &quot;Disabled&quot;</para></listitem>
<listitem><para>&quot;Visible&quot; or &quot;Invisible&quot;</para></listitem>
<listitem><para>&quot;Zoomed&quot; or &quot;Minimized&quot;</para></listitem>
<listitem><para>&quot;Foreground&quot;</para></listitem></itemizedlist>
</section>

<section id="getstylewo"><title>getStyle</title>
<indexterm><primary>getStyle method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getStyle method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>--getStyle---------------------------------------------------><
]]>
</programlisting>

<para>
  Returns the style and extended style flags of the window. This method is intended for use by
  programmers that have some knowledge of the Windows API and would not be much use to Rexx programmers
  that do not have any understanding of that API.
</para>
<para>
  The styles are returned in a string of two words. The first word is the window style and the second
  word is the extend window style. Each word is in the format:
  <computeroutput>0xAAAAAAAA</computeroutput> where A represents any hexadecimal digit. If an error
  happens, the numerical system error code is returned instead of a string with two words.
</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[

-- This function will return an array with all matching windows.  An empty array
-- signals no match.
windows = fuzzyFindWindows(deskTop, text)

if windows~items > 0 then do wnd over windows
  say 'Found this window.'
  say '  Title:   ' wnd~title
  say '  Class:   ' wnd~wClass
  say '  Position:' wnd~coordinates
  say '  Styles:  ' wnd~getStyle
  say
end

/* Output might be:

Found this window.
  Title:    GetMenuState Function - MSDN Library - Microsoft Document Explorer
  Class:    wndclass_desked_gsk
  Position: 0,0,1152,800
  Styles:   0x16cf0000 0xc0040900

Found this window.
  Title:    C:\work.ooRexx\3.x\main
  Class:    ExploreWClass
  Position: 0,25,1150,804
  Styles:   0x16cf0000 0xc0000900

*/
]]>
</programlisting>

</section>

<section id="restorewo"><title>restore</title>
<indexterm><primary>restore method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>restore method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-restore-----------------------------------------------------><
]]>
</programlisting>

<para>Activates and displays the associated window. If the window is minimized
or maximized, it is restored to its original size and position.</para>
</section>

<section id="hidewo"><title>hide</title>
<indexterm><primary>hide method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hide method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hide--------------------------------------------------------><
]]>
</programlisting>

<para>Hides the associated window and activates another window.</para>
</section>

<section id="minimizewo"><title>minimize</title>
<indexterm><primary>minimize method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>minimize method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-minimize----------------------------------------------------><
]]>
</programlisting>

<para>Minimizes the associated window and activates the next higher-level
window.</para>
</section>

<section id="maximizewo"><title>maximize</title>
<indexterm><primary>maximize method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>maximize method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-maximize----------------------------------------------------><
]]>
</programlisting>

<para>Maximizes the associated window.</para>
</section>

<section id="resizewo"><title>resize</title>
<indexterm><primary>resize method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>resize method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-resize--(--width--,--height--)------------------------------><
]]>
</programlisting>

<para>Resizes the associated window to the specified width and height. The width
and height are specified in screen coordinates.</para>
</section>

<section id="enablewo"><title>enable</title>
<indexterm><primary>enable method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>enable method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-enable------------------------------------------------------><
]]>
</programlisting>

<para>Enables the associated window if it was disabled.</para>
</section>

<section id="disablewo"><title>disable</title>
<indexterm><primary>disable method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>disable method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-disable-----------------------------------------------------><
]]>
</programlisting>

<para>Disables the associated window.</para>
</section>

<section id="movetowo"><title>moveTo</title>
<indexterm><primary>moveTo method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>moveTo method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-moveTo--(--x--,--y--)---------------------------------------><
]]>
</programlisting>

<para>Moves the associated window to the specified position
(<emphasis role="italic">x,y</emphasis>). Specify
the new position in screen pixels.</para>
</section>

<section id="toforegroundwo"><title>toForeground</title>
<indexterm><primary>toForeground method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>toForeground method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-toForeground------------------------------------------------><
]]>
</programlisting>

<para>Makes the associated window the foreground window.</para>
</section>

<section id="focusnextitemwo"><title>focusNextItem</title>
<indexterm><primary>focusNextItem method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>focusNextItem method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-focusNextItem-----------------------------------------------><
]]>
</programlisting>

<para>Sets the input focus to the next child window of the associated window.
</para>
</section>

<section id="focuspreviousitemwo"><title>focusPreviousItem</title>
<indexterm><primary>focusPreviousItem method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>focusPreviousItem method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-focusPreviousItem-------------------------------------------><
]]>
</programlisting>

<para>Sets the input focus to the previous child window of the associated
window.</para>
</section>

<section id="focusitemwo"><title>focusItem</title>
<indexterm><primary>focusItem method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>focusItem method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-focusItem--(--wndObject--)----------------------------------><
]]>
</programlisting>

<para>Sets the input focus to the child window associated with the specified
WindowObject instance <emphasis role="italic">wndObject</emphasis>.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<para>The following example sets the input focus to the last child window:
</para>
<programlisting>
 dlg = wndmgr~find("TestDialog")
    if dlg \= .Nil then do
        fChild = dlg~firstChild
        lChild = fChild~last
        dlg~focusItem(lChild)
    end
</programlisting>
</section>

<section id="findchildwo"><title>findChild</title>
<indexterm><primary>findChild method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>findChild method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-findChild--(--label--)--------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the child
window with the specified <emphasis role="italic">label</emphasis>. If the
associated window does not
own such a window, the .Nil object is returned.</para>
</section>

<section id="childatpositionwo"><title>childAtPosition</title>
<indexterm><primary>childAtPosition method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>childAtPosition method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-childAtPosition--(--x--,--y--)------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the child
window at the specified client position (<emphasis role="italic">x,y</emphasis>).
The coordinates that are relative to the upper left corner of the associated
window must be specified
in screen pixels. To retrieve top-level windows,
use method <link linkend="windowatpositionwm">windowAtPosition</link>.</para>
</section>

<section id="nextwo"><title>next</title>
<indexterm><primary>next method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>next method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-next--------------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the next
window of the same level as the associated window. If the associated window
is the last window of a level, the .Nil object is returned.</para>
</section>

<section id="previouswo"><title>previous</title>
<indexterm><primary>previous method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>previous method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-previous----------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the previous
window of the same level as the associated window. If the associated window
is the first window of a level, the .Nil object is returned.</para>
</section>

<section id="firstwo"><title>first</title>
<indexterm><primary>first method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>first method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-first-------------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the first
window of the same level as the associated window.</para>
</section>

<section id="lastwo"><title>last</title>
<indexterm><primary>last method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>last method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-last--------------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the last
window of the same level as the associated window.</para>
</section>

<section id="ownerwo"><title>owner</title>
<indexterm><primary>owner method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>owner method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-owner-------------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the window
that owns the associated window (parent). If the associated window is a
top-level window, the .Nil object is returned.</para>
</section>

<section id="firstchildwo"><title>firstChild</title>
<indexterm><primary>firstChild method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>firstChild method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-firstChild--------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the first
child window of the associated window. If no child window exists, the .NIL
object is returned.</para>
</section>

<section id="enumeratechildrenwo"><title>enumerateChildren</title>
<indexterm><primary>enumerateChildren method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>enumerateChildren method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-enumerateChildren-------------------------------------------><
]]>
</programlisting>

<para>Returns a stem that stores information about the
child windows of the associated
window. &quot;Stem.0&quot; contains the number of child windows. The returned
stem contains as many records as child windows. The first record is stored
at &quot;Stem.1&quot; continued by increments of 1. Each record contains the
following entries, where each entry starts with an exclamation mark (!):</para>
<variablelist>
<varlistentry><term>!Handle</term>
<listitem><para>The handle of the window.
</para></listitem></varlistentry>
<varlistentry><term>!Title</term>
<listitem><para>
</para></listitem></varlistentry>
<varlistentry><term>!Class</term>
<listitem><para>The window class.
</para></listitem></varlistentry>
<varlistentry><term>!State</term>
<listitem><para>
</para></listitem></varlistentry>
<varlistentry><term>!Coordinates</term>
<listitem><para>
</para></listitem></varlistentry>
<varlistentry><term>!Children</term>
<listitem><para>1 if the window has child windows, 0 if is has none.
</para></listitem></varlistentry>
<varlistentry><term>!Id</term>
<listitem><para>
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
      wo = winmgr~find("TestDialog")
        enum. = wo~enumerateChildren
        do i = 1 to enum.0   /* number of children */
           say "---"
           say "Handle:" enum.i.!Handle
           say "Title:" enum.i.!Title
           say "Class:" enum.i.!Class
           say "Id:" enum.i.!Id
           say "Children:" enum.i.!Children
           say "State:" enum.i.!State
           say "Rect:" enum.i.!Coordinates
        end
</programlisting>
</section>

<section id="sendmessagewo"><title>sendMessage</title>
<indexterm><primary>sendMessage method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendMessage method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendMessage--(--message--,--wParam--,--lParam--)------------><
]]>
</programlisting>

<para>Sends a message to the associated window.</para>
</section>

<section id="sendcommandwo"><title>sendCommand</title>
<indexterm><primary>sendCommand method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendCommand method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendCommand--(--command--)----------------------------------><
]]>
</programlisting>

<para>Sends a WM_COMMAND message to the associated window. WM_COMMAND is
sent, for example, when a button is pressed, where
<emphasis role="italic">command</emphasis> is the button ID.</para>
</section>

<section id="sendmenucommandwo"><title>sendMenuCommand</title>
<indexterm><primary>sendMenuCommand method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendMenuCommand method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendMenuCommand--(--id--)-----------------------------------><
]]>
</programlisting>

<para>Selects the menu item <emphasis role="italic">id</emphasis> of the
associated window. Method <link linkend="idofmo">idOf</link> returns the
ID of a menu item.</para>
</section>

<section id="sendmouseclickwo"><title>sendMouseClick</title>
<indexterm><primary>sendMouseClick method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendMouseClick method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
                      +-"LEFT"---+     +-"DBLCLK"-+
>>-sendMouseClick--(--+-"RIGHT"--+--,--+-"UP"-----+----,--x--,--y-->
                      +-"MIDDLE"-+     +-"DOWN"---+

>--+-----------------------------+--)--------------------------><
   |       +----------------+    |
   |       V                |    |
   +-,--"----+-LEFTDOWN---+-+--"-+
             +-RIGHTDOWN--+
             +-MIDDLEDOWN-+
             +-SHIFT------+
             +-CONTROL----+
]]>
</programlisting>

<para>Simulates a mouse click event in the associated window.</para>
<para>Arguments:</para>
<para>The arguments are:</para>
<variablelist>
<varlistentry><term><emphasis role="italic">which</emphasis></term>
<listitem><para>Specifies which mouse button is simulated. LEFT is the default.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="italic">kind</emphasis></term>
<listitem><para>Selects the simulated mouse action. DBLCLK is the default.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="italic">x,y</emphasis></term>
<listitem><para>Specifies the coordinates of the mouse click event, in screen
coordinates, relative to the upper left corner of the window.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="italic">ext</emphasis></term>
<listitem><para>Can be one or more of the following strings:
<variablelist>
<varlistentry><term>LEFTDOWN</term>
<listitem><para>Simulates the pressed left mouse button.
</para></listitem></varlistentry>
<varlistentry><term>RIGHTDOWN</term>
<listitem><para>Simulates the pressed right mouse button.
</para></listitem></varlistentry>
<varlistentry><term>MIDDLEDOWN</term>
<listitem><para>Simulates the pressed middle mouse button.
</para></listitem></varlistentry>
<varlistentry><term>SHIFT</term>
<listitem><para>Simulates the pressed Shift key.
</para></listitem></varlistentry>
<varlistentry><term>CONTROL</term>
<listitem><para>Simulates the pressed Control key.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="sendsyscommandwo"><title>sendSyscommand</title>
<indexterm><primary>sendSyscommand method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendSyscommand method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendSyscommand--(--"--+-SIZE--------+--"--)-----------------><
                         +-MOVE--------+
                         +-MINIMIZE----+
                         +-MAXIMIZE----+
                         +-NEXTWINDOW--+
                         +-PREVWINDOW--+
                         +-CLOSE-------+
                         +-VSCROLL-----+
                         +-HSCROLL-----+
                         +-ARRANGE-----+
                         +-RESTORE-----+
                         +-TASKLIST----+
                         +-SCREENSAVE--+
                         +-CONTEXTHELP-+
]]>
</programlisting>

<para>Sends a WM_SYSCOMMAND message to the associated window. These messages
are normally sent when the user selects a command in the Window menu.</para>
<para>Argument:</para>
<para>The only argument is:</para>
<variablelist>
<varlistentry><term><emphasis role="italic">command</emphasis></term>
<listitem><para>One of the commands listed in the syntax diagram:
<variablelist>
<varlistentry><term>SIZE</term>
<listitem><para>Puts the window in size mode.
</para></listitem></varlistentry>
<varlistentry><term>MOVE</term>
<listitem><para>Puts the window in move mode.
</para></listitem></varlistentry>
<varlistentry><term>MINIMIZE</term>
<listitem><para>Minimizes the window.
</para></listitem></varlistentry>
<varlistentry><term>MAXIMIZE</term>
<listitem><para>Maximizes the window.
</para></listitem></varlistentry>
<varlistentry><term>NEXTWINDOW</term>
<listitem><para>Moves to the next window.
</para></listitem></varlistentry>
<varlistentry><term>PREVWINDOW</term>
<listitem><para>Moves to the previous window.
</para></listitem></varlistentry>
<varlistentry><term>CLOSE</term>
<listitem><para>Closes the window.
</para></listitem></varlistentry>
<varlistentry><term>VSCROLL</term>
<listitem><para>Scrolls vertically.
</para></listitem></varlistentry>
<varlistentry><term>HSCROLL</term>
<listitem><para>Scrolls horizontally.
</para></listitem></varlistentry>
<varlistentry><term>ARRANGE</term>
<listitem><para>Arranges the window.
</para></listitem></varlistentry>
<varlistentry><term>RESTORE</term>
<listitem><para>Restores the window to its normal position and size.
</para></listitem></varlistentry>
<varlistentry><term>TASKLIST</term>
<listitem><para>Activates the Start menu.
</para></listitem></varlistentry>
<varlistentry><term>SCREENSAVE</term>
<listitem><para>Executes the screen-saver application specified in the [boot]
section of the SYSTEM.INI file.
</para></listitem></varlistentry>
<varlistentry><term>CONTEXTHELP</term>
<listitem><para>Changes the cursor to a question mark with a pointer. If the
user then clicks on a control in the dialog box, the control receives a
WM_HELP message.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="pushbuttonwo"><title>pushButton</title>
<indexterm><primary>pushButton method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>PushButton method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-pushButton--(--label--)-------------------------------------><
]]>
</programlisting>

<para>Selects the button with the specified
<emphasis role="italic">label</emphasis> within the associated
window and sends the corresponding WM_COMMAND message. If the button's
label contains a mnemonic (underscored letter), you must specify an ampersand
(&amp;) in front of it. You can also use this method to select radio buttons
and check or uncheck check boxes.</para>
</section>

<section id="sendkeywo"><title>sendKey</title>
<indexterm><primary>sendKey method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendKey method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendKey--(--keyName--+------------------------+--)----------><
                        +-,--+-----+--+--------+-+
                             +-alt-+  +-,--ext-+
]]>
</programlisting>

<para>Sends all messages (CHAR, KEYDOWN, and KEYUP) that would be sent by
pressing a specific key on the keyboard. Character keys (a to z) are not
case-sensitive.</para>
<para>If the <emphasis role="italic">alt</emphasis> argument is 1, the Alt key
flag is set, which is equal
to pressing the specified key together with the Alt key.</para>
<para>The <emphasis role="italic">Ext</emphasis> argument must be 1 if the key
is an extended key, such as a right Ctrl or a right Shift.</para>
<para>For a list of key names, refer to
<link linkend="virtualkeys">Symbolic Names for Virtual Keys</link>.</para>
</section>

<section id="sendcharwo"><title>sendChar</title>
<indexterm><primary>sendChar method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendChar method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendChar--(--character--+--------+--)-----------------------><
                           +-,--alt-+
]]>
</programlisting>

<para>Sends a WM_CHAR message to the associated window. If the
<emphasis role="italic">alt</emphasis> argument
is 1, a pressed Alt key is simulated.</para>
</section>

<section id="sendkeydownwo"><title>sendKeyDown</title>
<indexterm><primary>sendKeyDown method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendKeyDown method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendKeyDown--(--keyName--+--------+--)----------------------><
                            +-,--ext-+
]]>
</programlisting>

<para>Sends a WM_KEYDOWN message to the associated window. The
<emphasis role="italic">ext</emphasis> argument
must be 1 if the key is an extended key, such as a right Ctrl or a right Shift.
</para>
<para>For a list of key names, refer to
<link linkend="virtualkeys">Symbolic Names for Virtual Keys</link>.</para>
</section>

<section id="sendkeyupwo"><title>sendKeyUp</title>
<indexterm><primary>sendKeyUp method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendKeyUp method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendKeyUp--(--keyName--+--------+--)------------------------><
                          +-,--ext-+
]]>
</programlisting>

<para>Sends a WM_KEYUP message to the associated window. The
<emphasis role="italic">ext</emphasis> argument
must be 1 if the key is an extended key, such as a right Ctrl or a right Shift.
</para>
<para>For a list of key names, refer to
<link linkend="virtualkeys">Symbolic Names for Virtual Keys</link>.</para>
</section>

<section id="sendtextwo"><title>sendText</title>
<indexterm><primary>sendText method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendText method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendText--(--text--)----------------------------------------><
]]>
</programlisting>

<para>Sends a (case-sensitive) text to the associated window by sending a
sequence of WM_CHAR, WM_KEYDOWN, and WM_KEYUP messages.</para>
</section>

<section id="menuwo"><title>menu</title>
<indexterm><primary>menu method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>menu method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-menu--------------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the MenuObject class that refers to the menu of
the associated window.</para>
</section>

<section id="systemmenuwo"><title>systemMenu</title>
<indexterm><primary>systemMenu method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>systemMenu method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-systemMenu--------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the MenuObject class that refers to the system
menu of the associated window.</para>
</section>

<section id="ismenuwo"><title>isMenu</title>
<indexterm><primary>isMenu method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isMenu method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isMenu------------------------------------------------------><
]]>
</programlisting>

<para>Returns 1 if the associated window is a menu, otherwise 0.</para>
</section>

<section id="processmenucommandwo"><title>processMenuCommand</title>
<indexterm><primary>processMenuCommand method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ProcessMenuCommand method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
                                       +-,-------+
                                       V         |
>>-processMenuCommand--(--+------+--,----submenu-+--,--menuItem--)-><
                          +-menu-+
]]>
</programlisting>

<para>Selects an item of the menu or submenu of the associated window. You can
specify as many submenus as necessary to get to the required item.</para>
</section>
</section>

<section id="clsWinProgramManager"><title>The WindowsProgramManager Class</title>
<indexterm><primary>WindowsProgramManager class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsProgramManager class</secondary></indexterm>
<para>Object Rexx provides a class for interaction with the Windows Program
Manager. You can use this class to create program groups and shortcuts to
access your programs. This class is specifically for Windows systems
and may not be available on other systems.</para>
<para>The WindowsProgramManager class is defined in the file WINSYSTM.CLS. Use
a <computeroutput>::requires</computeroutput> statement to activate its
function: </para>
<programlisting>
::requires "winsystm.cls"
</programlisting>
<para>A sample program <computeroutput>DESKTOP.REX</computeroutput> is provided
in the <computeroutput>ooRexx\SAMPLES</computeroutput> directory.</para>
<para>Methods of the WindowsProgramManager class are:</para>

<table frame="all">
<title>Methods Available to the WindowsProgramManager Class</title>
<tgroup cols="2">
<thead>
<row>
<entry>Method...</entry>
<entry>...link</entry>
</row>
</thead>
<tbody>
<row>
<entry>new (Class method)</entry>
<entry><link linkend="wpinit">init</link> (Class method)</entry>
</row>
<row>
<entry>addDeskTopIcon</entry>
<entry><link linkend="adddesktopicon">addDesktopIcon</link></entry>
</row>
<row>
<entry>addGroup</entry>
<entry><link linkend="wpadgr">addGroup</link></entry>
</row>
<row>
<entry>addItem</entry>
<entry><link linkend="wpadit">addItem</link></entry>
</row>
<row>
<entry>addShortCut</entry>
<entry><link linkend="addshortcut">addShortCut</link></entry>
</row>
<row>
<entry>deleteDesktopIcon</entry>
<entry><link linkend="deldskic">deleteDesktopIcon</link></entry>
</row>
<row>
<entry>deleteGroup</entry>
<entry><link linkend="wpdegr">deleteGroup</link></entry>
</row>
<row>
<entry>deleteItem</entry>
<entry><link linkend="wpdeit">deleteItem</link></entry>
</row>
<row>
<entry>showGroup</entry>
<entry><link linkend="wpshgr">showGroup</link></entry>
</row>
</tbody>
</tgroup>
</table>

<section id="wpinit"><title>new (Class method)</title>
<indexterm><primary>new method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>--new--------------------------------------------------------><
]]>
</programlisting>

<para>
  Creates an instance of the WindowsProgramManager class.
</para>
</section>

<section id="adddesktopicon"><title>addDesktopIcon</title>
<indexterm><primary>addDesktopIcon method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>AddDesktopIcon method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addDesktopIcon--(--name--,--program--+--------------------------------+-->
                                        |                     +-0------+ |
                                        +-,--+----------+--,--+--------+-+
                                             +-iconfile-+     +-iconnr-+

>--+--------------------------------------------------------------------------+-)-><
   |                 +-"PERSONAL"-+                           +-"NORMAL"----+ |
   +-,-+---------+-,-+------------+-,-+------+-,-+--------+-,-+-------------+-+
       +-workdir-+   +-"COMMON"---+   +-args-+   +-hotkey-+   +-"MAXIMIZED"-+
                                                              +-"MINIMIZED"-+
]]>
</programlisting>

<para>Adds a shortcut to the Windows desktop. A sample program
<computeroutput>DESKICON.REX</computeroutput> is provided in the
<computeroutput>ooRexx\SAMPLES</computeroutput> directory.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>name</term>
<listitem><para>The name of the shortcut, displayed below the icon.
</para></listitem></varlistentry>
<varlistentry><term>program</term>
<listitem><para>The program file launched by the shortcut.
</para></listitem></varlistentry>
<varlistentry><term>iconfile</term>
<listitem><para>The name of the icon used for the shortcut. If not specified,
the icon of <emphasis role="italic">program</emphasis> is used.
</para></listitem></varlistentry>
<varlistentry><term>iconnr</term>
<listitem><para>The number of the icon within the
<emphasis role="italic">iconfile</emphasis>. The default is 0.
</para></listitem></varlistentry>
<varlistentry><term>workdir</term>
<listitem><para>The working directory of the shortcut.
</para></listitem></varlistentry>
<varlistentry><term>location</term>
<listitem><para>Either of the following locations:
<variablelist>
<varlistentry><term>&quot;PERSONAL&quot;</term>
<listitem><para>The shortcut is personal and displayed only on the desktop of
the user.</para></listitem></varlistentry>
<varlistentry><term>&quot;COMMON&quot;</term>
<listitem><para>The shortcut is common to all users and displayed on the
desktop of all users.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>args</term>
<listitem><para>The arguments passed to the program that the shortcut refers to.
</para></listitem></varlistentry>
<varlistentry><term>hotkey</term>
<listitem><para>The virtual key to be used as a hotkey to open the shortcut.
For a list of the key names, see
<link linkend="virtualkeys">Symbolic Names for Virtual Keys</link>.
</para></listitem></varlistentry>
<varlistentry><term>run</term>
<listitem><para>Specifies one of the options listed in the syntax diagram. The
default is &quot;NORMAL&quot;.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="addshortcut"><title>addShortCut</title>
<indexterm><primary>addShortCut method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addShortCut method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addShortCut--(--name--,--program--------------------------------------->

>--+---------------------------------------------------------------------->
   |                  +-0------+
   +-,-+----------+-,-+--------+-,-+---------+-,-+------+-,-+--------+-,-->
       +-iconfile-+   +-iconnr-+   +-workdir-+   +-args-+   +-hotkey-+

>-------------------+--)-------------------------------------------------><
    +-"NORMAL"----+ |
>---+-------------+-+
    +-"MAXIMIZED"-+
    +-"MINIMIZED"-+
]]>
</programlisting>

<para>Creates a shortcut within the specified folder.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>name</term>
<listitem><para>The full name of the shortcut.
</para></listitem></varlistentry>
<varlistentry><term>program</term>
<listitem><para>The program file launched by the shortcut.
</para></listitem></varlistentry>
<varlistentry><term>iconfile</term>
<listitem><para>The name of the icon used for the shortcut. If not specified,
the icon of <emphasis role="italic">program</emphasis> is used.
</para></listitem></varlistentry>
<varlistentry><term>iconnr</term>
<listitem><para>The number of the icon within the
<emphasis role="italic">iconfile</emphasis>. The default is
0.
</para></listitem></varlistentry>
<varlistentry><term>workdir</term>
<listitem><para>The working directory of the shortcut.
</para></listitem></varlistentry>
<varlistentry><term>args</term>
<listitem><para>The arguments passed to the program that the shortcut refers to.
</para></listitem></varlistentry>
<varlistentry><term>hotkey</term>
<listitem><para>The virtual key to be used as a hotkey to open the shortcut.
For a list of the key names, see
<link linkend="virtualkeys">Symbolic Names for Virtual Keys</link>.
</para></listitem></varlistentry>
<varlistentry><term>run</term>
<listitem><para>Specifies one of the options listed in the syntax diagram.
The default is &quot;NORMAL&quot;.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>Example:</term>
<listitem><para>The following example creates a shortcut named
&quot;My NotePad&quot;
to the Notepad editor within the directory c:\temp:
<programlisting>
pm = .WindowsProgramManager~new
	if pm~InitCode \= 0 then exit
	pm~addShortCut("c:\temp\My Notepad","%SystemRoot%\system32\notepad.exe")
	::requires "winsystm.cls"
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="wpadgr"><title>addGroup</title>
<indexterm><primary>addGroup method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addGroup method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addGroup(-group-)-------------------------------------------><
]]>
</programlisting>

<para>Adds a program group to the Programs group of the desktop. If the group
already exists, it is opened. The <emphasis role="italic">group</emphasis>
argument specifies the name of the program group to be added. Example:</para>
<programlisting>
addGroup("Object Rexx Redbook")
</programlisting>

<note><title>Note</title>
<para>The name that you specify for the
<emphasis role="italic">group</emphasis> argument
must not contain any brackets or parenthesis. Otherwise, this method fails.
</para></note>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The method was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="wpadit"><title>addItem</title>
<indexterm><primary>addItem method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addItem method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addItem--(--shortcut,program--------------------------------->

>--+------------------------------------------------------+----->
   +-,--+----------+--+---------------------------------+-+
        +-iconfile-+  +-,--+------------+--+----------+-+
                           +-iconnumber-+  +-,workdir-+

>--)-----------------------------------------------------------><
]]>
</programlisting>

<para>Adds a shortcut to a program group. The shortcut is placed into the last
group used with either AddGroup or ShowGroup. Example: </para>
<programlisting>
AddItem("OODialog Samples", ,
"rexx oodialog\samples\sample.rex", ,
"oodialog\samples\oodialog.ico")
</programlisting>

<note><title>Note</title>
<para>The name that you specify for the <emphasis role="italic">group</emphasis>
argument must not contain characters that are not valid, such as brackets or
parenthesis. Otherwise, this method fails. Some characters are changed,
for example / to _.</para></note>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The method was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="deldskic"><title>deleteDesktopIcon</title>
<indexterm><primary>deleteDesktopIcon method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>deleteDesktopIcon method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>

<programlisting>
<![CDATA[
                                   +-"PERSONAL"-+
>>-deleteDesktopIcon--(--name--,---+------------+-)------------><
                                   +-"COMMON"---+
]]>
</programlisting>

<para>Deletes a shortcut from the Windows desktop that was previously
created with AddDesktopIcon.</para>

<para>The arguments are:</para>

<variablelist>
<varlistentry><term><emphasis>name</emphasis></term>
<listitem><para>The name of the shortcut to be deleted.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>location</emphasis></term>
<listitem><para>Either of the following locations:</para>
<variablelist>
<varlistentry><term><emphasis>"PERSONAL"</emphasis></term>
<listitem><para>The shortcut was previously created with AddDesktopIcon
and the location option "PERSONAL". This is the default.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>"COMMON"</emphasis></term>
<listitem><para>The shortcut was previously created with AddDesktopIcon
and the location option "COMMON".
</para></listitem></varlistentry>
</variablelist>
</listitem></varlistentry>
</variablelist>

<para><emphasis role="bold">Return codes:</emphasis></para>

<variablelist>
<varlistentry><term><emphasis>0</emphasis></term>
<listitem><para>Shortcut deleted successfully.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>2</emphasis></term>
<listitem><para>Shortcut not found.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>3</emphasis></term>
<listitem><para>Path to shortcut not found.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>5</emphasis></term>
<listitem><para>Access denied or busy.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>26</emphasis></term>
<listitem><para>Not a DOS disk.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>32</emphasis></term>
<listitem><para>Sharing violation.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>36</emphasis></term>
<listitem><para>Sharing buffer exceeded.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>87</emphasis></term>
<listitem><para>Does not exist.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>206</emphasis></term>
<listitem><para>Shortcut name exceeds range error.
</para></listitem></varlistentry>
</variablelist>

<note><title>Note:</title>
<para>Return code 2 is also returned when a "PERSONAL" should be
deleted that was previously created with "COMMON" and vice
versa.</para></note>

<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[
pm = .WindowsProgramManager~new
if pm~InitCode \= 0 then exit

rc = pm~deleteDesktopIcon("MyNotepad1", ,
     "%SystemRoot%\system32\notepad.exe")
if rc \= 0 then do
  say "Error deleting shortcut: My Notepad 1"
  exit
end

exit

::requires "winsystm.cls"
]]>
</programlisting>

</section>

<section id="wpdegr"><title>deleteGroup</title>
<indexterm><primary>deleteGroup method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>deleteGroup method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-deleteGroup(-group-)----------------------------------------><
]]>
</programlisting>

<para>Deletes a program group from the desktop. The
<emphasis role="italic">group</emphasis> argument specifies
the name of the program group to be deleted.</para>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The method was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="wpdeit"><title>deleteItem</title>
<indexterm><primary>deleteItem method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>deleteItem method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-deleteItem(shortcut)----------------------------------------><
]]>
</programlisting>

<para>Deletes a shortcut from a program group.</para>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The method was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="wpshgr"><title>showGroup</title>
<indexterm><primary>showGroup method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>showGroup method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-showGroup(-group,-+-----+-)---------------------------------><
                     +-MIN-+
                     +-MAX-+
]]>
</programlisting>

<para>Opens a program group. The
<emphasis role="italic">group</emphasis> argument specifies the name of
the program group to be opened. If MIN or MAX is specified, the program group
is opened minimized or maximized.</para>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The method was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="virtualkeys"><title>Symbolic Names for Virtual Keys</title>
<indexterm><primary>virtual keys</primary></indexterm>
<para><link linkend="t000033">Table 3</link> shows the symbolic names and the
keyboard equivalents for the virtual keys used by Object Rexx.</para>

<table id="t000033" frame="all">
<title>Symbolic Names for Virtual Keys</title>
<tgroup cols="2">
<thead>
<row>
<entry>Symbolic Name</entry>
<entry>Mouse or Keyboard Equivalent</entry>
</row>
</thead>
<tbody>
<row>
<entry>LBUTTON</entry>
<entry>Left mouse button</entry>
</row>
<row>
<entry>RBUTTON</entry>
<entry>Right mouse button</entry>
</row>
<row>
<entry>CANCEL</entry>
<entry>Control-break processing</entry>
</row>
<row>
<entry>MBUTTON</entry>
<entry>Middle mouse button (three-button mouse)</entry>
</row>
<row>
<entry>BACK</entry>
<entry>BACKSPACE key</entry>
</row>
<row>
<entry>TAB</entry>
<entry>TAB key</entry>
</row>
<row>
<entry>CLEAR</entry>
<entry>CLEAR key</entry>
</row>
<row>
<entry>RETURN</entry>
<entry>ENTER key</entry>
</row>
<row>
<entry>SHIFT</entry>
<entry>SHIFT key</entry>
</row>
<row>
<entry>CONTROL</entry>
<entry>CRTL key</entry>
</row>
<row>
<entry>MENU</entry>
<entry>ALT key</entry>
</row>
<row>
<entry>PAUSE</entry>
<entry>PAUSE key</entry>
</row>
<row>
<entry>CAPITAL</entry>
<entry>CAPS LOCK key</entry>
</row>
<row>
<entry>ESCAPE</entry>
<entry>ESC key</entry>
</row>
<row>
<entry>SPACE</entry>
<entry>SPACEBAR</entry>
</row>
<row>
<entry>PRIOR</entry>
<entry>PAGE UP key</entry>
</row>
<row>
<entry>NEXT</entry>
<entry>PAGE DOWN key</entry>
</row>
<row>
<entry>END</entry>
<entry>END key</entry>
</row>
<row>
<entry>HOME</entry>
<entry>HOME key</entry>
</row>
<row>
<entry>LEFT</entry>
<entry>LEFT ARROW key</entry>
</row>
<row>
<entry>UP</entry>
<entry>UP ARROW key</entry>
</row>
<row>
<entry>RIGHT</entry>
<entry>RIGHT ARROW key</entry>
</row>
<row>
<entry>DOWN</entry>
<entry>DOWN ARROW key</entry>
</row>
<row>
<entry>SELECT</entry>
<entry>SELECT key</entry>
</row>
<row>
<entry>EXECUTE</entry>
<entry>EXECUTE key</entry>
</row>
<row>
<entry>SNAPSHOT</entry>
<entry>PRINT SCREEN key</entry>
</row>
<row>
<entry>INSERT</entry>
<entry>INS key</entry>
</row>
<row>
<entry>DELETE</entry>
<entry>DEL key</entry>
</row>
<row>
<entry>HELP</entry>
<entry>HELP key</entry>
</row>
<row>
<entry>0</entry>
<entry>0 key</entry>
</row>
<row>
<entry>1</entry>
<entry>1 key</entry>
</row>
<row>
<entry>2</entry>
<entry>2 key</entry>
</row>
<row>
<entry>3</entry>
<entry>3 key</entry>
</row>
<row>
<entry>4</entry>
<entry>4 key</entry>
</row>
<row>
<entry>5</entry>
<entry>5 key</entry>
</row>
<row>
<entry>6</entry>
<entry>6 key</entry>
</row>
<row>
<entry>7</entry>
<entry>7 key</entry>
</row>
<row>
<entry>8</entry>
<entry>8 key</entry>
</row>
<row>
<entry>9</entry>
<entry>9 key</entry>
</row>
<row>
<entry>A</entry>
<entry>A key</entry>
</row>
<row>
<entry>B</entry>
<entry>B key</entry>
</row>
<row>
<entry>C</entry>
<entry>C key</entry>
</row>
<row>
<entry>D</entry>
<entry>D key</entry>
</row>
<row>
<entry>E</entry>
<entry>E key</entry>
</row>
<row>
<entry>F</entry>
<entry>F key</entry>
</row>
<row>
<entry>G</entry>
<entry>G key</entry>
</row>
<row>
<entry>H</entry>
<entry>H key</entry>
</row>
<row>
<entry>I</entry>
<entry>I key</entry>
</row>
<row>
<entry>J</entry>
<entry>J key</entry>
</row>
<row>
<entry>K</entry>
<entry>K key</entry>
</row>
<row>
<entry>L</entry>
<entry>L key</entry>
</row>
<row>
<entry>M</entry>
<entry>M key</entry>
</row>
<row>
<entry>N</entry>
<entry>N key</entry>
</row>
<row>
<entry>O</entry>
<entry>O key</entry>
</row>
<row>
<entry>Q</entry>
<entry>Q key</entry>
</row>
<row>
<entry>R</entry>
<entry>R key</entry>
</row>
<row>
<entry>S</entry>
<entry>S key</entry>
</row>
<row>
<entry>T</entry>
<entry>T key</entry>
</row>
<row>
<entry>U</entry>
<entry>U key</entry>
</row>
<row>
<entry>V</entry>
<entry>V key</entry>
</row>
<row>
<entry>W</entry>
<entry>W key</entry>
</row>
<row>
<entry>X</entry>
<entry>X key</entry>
</row>
<row>
<entry>Y</entry>
<entry>Y key</entry>
</row>
<row>
<entry>Z</entry>
<entry>Z key</entry>
</row>
<row>
<entry>NUMPAD0</entry>
<entry>Numeric keypad 0 key</entry>
</row>
<row>
<entry>NUMPAD1</entry>
<entry>Numeric keypad 1 key</entry>
</row>
<row>
<entry>NUMPAD2</entry>
<entry>Numeric keypad 2 key</entry>
</row>
<row>
<entry>NUMPAD3</entry>
<entry>Numeric keypad 3 key</entry>
</row>
<row>
<entry>NUMPAD4</entry>
<entry>Numeric keypad 4 key</entry>
</row>
<row>
<entry>NUMPAD5</entry>
<entry>Numeric keypad 5 key</entry>
</row>
<row>
<entry>NUMPAD6</entry>
<entry>Numeric keypad 6 key</entry>
</row>
<row>
<entry>NUMPAD7</entry>
<entry>Numeric keypad 7 key</entry>
</row>
<row>
<entry>NUMPAD8</entry>
<entry>Numeric keypad 8 key</entry>
</row>
<row>
<entry>NUMPAD9</entry>
<entry>Numeric keypad 9 key</entry>
</row>
<row>
<entry>MULTIPLY</entry>
<entry>Multiply key</entry>
</row>
<row>
<entry>ADD</entry>
<entry>Add key</entry>
</row>
<row>
<entry>SEPARATOR</entry>
<entry>Separator key</entry>
</row>
<row>
<entry>SUBTRACT</entry>
<entry>Subtract key</entry>
</row>
<row>
<entry>DECIMAL</entry>
<entry>Decimal key</entry>
</row>
<row>
<entry>DIVIDE</entry>
<entry>Divide key</entry>
</row>
<row>
<entry>F1</entry>
<entry>F1 key</entry>
</row>
<row>
<entry>F2</entry>
<entry>F2 key</entry>
</row>
<row>
<entry>F3</entry>
<entry>F3 key</entry>
</row>
<row>
<entry>F4</entry>
<entry>F4 key</entry>
</row>
<row>
<entry>F5</entry>
<entry>F5 key</entry>
</row>
<row>
<entry>F6</entry>
<entry>F6 key</entry>
</row>
<row>
<entry>F7</entry>
<entry>F7 key</entry>
</row>
<row>
<entry>F8</entry>
<entry>F8 key</entry>
</row>
<row>
<entry>F9</entry>
<entry>F9 key</entry>
</row>
<row>
<entry>F10</entry>
<entry>F10 key</entry>
</row>
<row>
<entry>F11</entry>
<entry>F11 key</entry>
</row>
<row>
<entry>F12</entry>
<entry>F12 key</entry>
</row>
<row>
<entry>F13</entry>
<entry>F13 key</entry>
</row>
<row>
<entry>F14</entry>
<entry>F14 key</entry>
</row>
<row>
<entry>F15</entry>
<entry>F15 key</entry>
</row>
<row>
<entry>F16</entry>
<entry>F16 key</entry>
</row>
<row>
<entry>F17</entry>
<entry>F17 key</entry>
</row>
<row>
<entry>F18</entry>
<entry>F18 key</entry>
</row>
<row>
<entry>F19</entry>
<entry>F19 key</entry>
</row>
<row>
<entry>F20</entry>
<entry>F20 key</entry>
</row>
<row>
<entry>F21</entry>
<entry>F21 key</entry>
</row>
<row>
<entry>F22</entry>
<entry>F22 key</entry>
</row>
<row>
<entry>F23</entry>
<entry>F23 key</entry>
</row>
<row>
<entry>F24</entry>
<entry>F24 key</entry>
</row>
<row>
<entry>NUMLOCK</entry>
<entry>NUM LOCK key</entry>
</row>
<row>
<entry>SCROLL</entry>
<entry>SCROLL LOCK key</entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>

<section id="clsWinRegistry"><title>The WindowsRegistry Class</title>
<indexterm><primary>WindowsRegistry class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsProgramManager class</secondary></indexterm>
<para>Object Rexx provides a class for interaction with the WindowsRegistry.
You can use this class to query the registry and modify, add, and delete entries.
This class is specifically for Windows systems and may not be available
on other systems.</para>
<para>The WindowsRegistry class is not a built-in class; it is defined in the
file WINSYSTM.CLS.</para>
<para>Use a <computeroutput>::requires</computeroutput> statement to activate
its function: </para>
<programlisting>
::requires "winsystm.cls"
</programlisting>
<para>A sample program, <computeroutput>REGISTRY.REX</computeroutput>, is
provided in the <computeroutput>ooRexx\SAMPLES</computeroutput> directory
</para>
<para><emphasis role="bold">Methods the WindowsRegistry Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>new (Class method)</para></listitem>
<listitem><para>classes_root</para></listitem>
<listitem><para>classes_root=</para></listitem>
<listitem><para>close</para></listitem>
<listitem><para>create</para></listitem>
<listitem><para>current_key</para></listitem>
<listitem><para>current_key=</para></listitem>
<listitem><para>current_user</para></listitem>
<listitem><para>current_user=</para></listitem>
<listitem><para>delete</para></listitem>
<listitem><para>deleteValue</para></listitem>
<listitem><para>flush</para></listitem>
<listitem><para>getValue</para></listitem>
<listitem><para>list</para></listitem>
<listitem><para>listValues</para></listitem>
<listitem><para>load</para></listitem>
<listitem><para>local_machine</para></listitem>
<listitem><para>local_machine=</para></listitem>
<listitem><para>open</para></listitem>
<listitem><para>query</para></listitem>
<listitem><para>replace</para></listitem>
<listitem><para>restore</para></listitem>
<listitem><para>save</para></listitem>
<listitem><para>setValue</para></listitem>
<listitem><para>unload</para></listitem>
<listitem><para>users</para></listitem>
<listitem><para>users=</para></listitem></itemizedlist>

<section id="wrinit"><title>new (Class method)</title>
<indexterm><primary>new method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>new method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-new---------------------------------------------------------><
]]>
</programlisting>

<para>
  Creates an instance of the WindowsRegistry class. The current key is set to HKEY_LOCAL_MACHINE.
</para>
</section>

<section id="wrclro"><title>classes_root</title>
<indexterm><primary>classes_root method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>classes_root method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-classes_root------------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the root key HKEY_CLASSES_ROOT.</para>
</section>

<section id="wrclroe"><title>classes_root=</title>
<indexterm><primary>classes_root= method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>classes_root= method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-classes_root=-----------------------------------------------><
]]>
</programlisting>

<para>This method is used by INIT to set the attribute CLASSES_ROOT to
HKEY_CLASSES_ROOT. Do not modify this attribute.</para>
</section>

<section id="wrclse"><title>close</title>
<indexterm><primary>close method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>close method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-close(-+------------+-)-------------------------------------><
          +-key_handle-+
]]>
</programlisting>

<para>Closes a previously opened key specified by its handle. Example:</para>
<programlisting>
rg~close(objectrexxkey)
</programlisting>
<para>It can take several seconds before all data is written to disk. You can
use FLUSH to empty the cache.</para>
<para>If <emphasis role="italic">key_handle</emphasis> is omitted,
CURRENT_KEY is closed.</para>
</section>

<section id="wrconn"><title>connect</title>
<indexterm><primary>connect method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>connect method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-connect(-key,computer-)-------------------------------------><
]]>
</programlisting>

<para>Opens a key on a remote computer. This is supported only for
HKEY_LOCAL_MACHINE and HKEY_USERS.</para>
</section>

<section id="wrcrt"><title>create</title>
<indexterm><primary>create method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>create method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-create(-+--------+-,subkey)---------------------------------><
           +-parent-+
]]>
</programlisting>

<para>Adds a new named subkey to the registry and returns its handle. The
parent key handle <emphasis role="italic">parent</emphasis> can be a root key
or a key retrieved using OPEN. If the <emphasis role="italic">parent</emphasis>
key is omitted, CURRENT_KEY is used. Example:</para>
<programlisting>
newkey = rg~create(rg~local_machine,"MyOwnKey")
</programlisting>
</section>

<section id="wrcuky"><title>current_key</title>
<indexterm><primary>current_key method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>current_key method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-current_key-------------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the current key. The current key is set by INIT,
CREATE, and OPEN. It is used as a default value if the key is omitted in other
methods.</para>
</section>

<section id="wrcukye"><title>current_key=</title>
<indexterm><primary>current_key= method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>current_key= method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-current_key=------------------------------------------------><
]]>
</programlisting>

<para>Sets the handle of the current key.</para>
</section>

<section id="wrcuus"><title>current_user</title>
<indexterm><primary>current_user method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>current_user method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-current_user------------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the root key HKEY_CURRENT_USER.</para>
</section>

<section id="wrcuuse"><title>current_user=</title>
<indexterm><primary>current_user= method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>current_user= method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-current_user=-----------------------------------------------><
]]>
</programlisting>

<para>This method is used by INIT to set the attribute CURRENT_USER to
HKEY_CURRENT_USER. Do not modify this attribute.</para>
</section>

<section id="wrdele"><title>delete</title>
<indexterm><primary>delete method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>delete method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-delete(-+------------+-,subkeyname)-------------------------><
           +-key_handle-+
]]>
</programlisting>

<para>Deletes a given named subkey of an open key specified by its handle and
all its subkeys and values. If <emphasis role="italic">key_handle</emphasis>
is omitted, CURRENT_KEY is used.</para>
</section>

<section id="wrdeva"><title>deleteValue</title>
<indexterm><primary>deleteValue method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>deleteValue method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-deleteValue(-+------------+-+--------+-)--------------------><
                +-key_handle-+ +-,value-+
]]>
</programlisting>

<para>Deletes the named value for a given key. If
<emphasis role="italic">key_handle</emphasis> is omitted,
CURRENT_KEY is used. If <emphasis role="italic">value</emphasis>
is blank or omitted, the default value is deleted.</para>
</section>

<section id="wrflus"><title>flush</title>
<indexterm><primary>flush method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>flush method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-flush(-+------------+-)-------------------------------------><
          +-key_handle-+
]]>
</programlisting>

<para>Forces the system to write the cache buffer of a given key to disk. If
<emphasis role="italic">key_handle</emphasis> is omitted, CURRENT_KEY is
flushed.</para>
</section>

<section id="wrgtva"><title>getValue</title>
<indexterm><primary>getValue method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getValue method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getValue(-+------------+-+--------+-)-----------------------><
             +-key_handle-+ +-,value-+
]]>
</programlisting>

<para>Retrieves the data and type for a named value of a given key. The result
is a compound variable with suffixes data and type. If
<emphasis role="italic">key_handle</emphasis> is
omitted, CURRENT_KEY is used. If named <emphasis role="italic">value</emphasis>
is blank or omitted, the default value is retrieved. Example: </para>
<programlisting>
myval. = rg~getvalue(,"filesystem")        /* current key */
say "Type is" myval.type
if myval.type = "NORMAL" then say "Value is" myval.data
myval. = rg~getvalue(mykey)
say "my default value is:" myval.data
myval. = rg~getvalue(mykey,"")
say "my default value is:" myval.data
</programlisting>
<para>Possible types: NORMAL, EXPAND, MULTI, NUMBER, BINARY, NONE,
OTHER.</para>
</section>

<section id="wrlist"><title>list</title>
<indexterm><primary>list method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>list method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-list(-+------------+-,stem.)--------------------------------><
         +-key_handle-+
]]>
</programlisting>

<para>Retrieves the list of subkeys for a given key in a stem variable. The name
of the stem variable must include the period. The keys are returned as stem.1,
stem.2, and so on. Example: </para>
<programlisting>
rg~LIST(objectrexxkey,orexxkeys.)
do i over orexxkeys.
say orexxkeys.i
end
</programlisting>
</section>

<section id="wrliva"><title>listValues</title>
<indexterm><primary>listValues method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>listValues method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-listValues(-+------------+-,variable.)----------------------><
               +-key_handle-+
]]>
</programlisting>

<para>Retrieves all value entries of a given key into a compound variable. The
name of the variable must include the period. The suffixes of the compound
variable are numbered starting with 1, and for each number the three values
are the name (var.i.name), the data (var.i.data), and the type (var.i.type).
The type is NORMAL for alphabetic values, EXPAND for expandable strings such
as a path, NONE for no specified type, MULTI for multiple strings, NUMBER
for a 4-byte value, and BINARY for any data format.</para>
<para>If <emphasis role="italic">key_handle</emphasis> is omitted, the values
of CURRENT_KEY are listed.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
qstem. = rg~QUERY(objectrexxkey)
rg~LISTVALUES(objectrexxkey,lv.)
do i=1 to qstem.values
say "name of value:" lv.i.name "(type="lv.i.type")"
if lv.i.type = "NORMAL" then
say "data of value:" lv.i.data
end
</programlisting>
</section>

<section id="wrload"><title>load</title>
<indexterm><primary>load method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>load method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-load(-+------------+-,subkeyname, filename)-----------------><
         +-key_handle-+
]]>
</programlisting>

<para>Load creates a named subkey under the open key key_handle and loads
registry data from the file filename (created by
<link linkend="wrsave">SAVE</link>) and stores the
data under the newly created subkey.</para>
<para>key_handle can only be HKEY_USERS or HKEY_LOCAL_MACHINE.
Registry information is stored in the form of a hive - a discrete body
of keys, subkeys, and values that is rooted at the top of the registry
hierarchy. A hive is backed by a single file.</para>
<para>If <emphasis role="italic">key_handle</emphasis> is omitted, the subkey
is created under HKEY_LOCAL_MACHINE.</para>
<para>Use <link linkend="wrunld">UNLOAD</link> to delete the subkey and to
unlock the registry data file filename.</para>
</section>

<section id="wrloma"><title>local_machine</title>
<indexterm><primary>local_machine method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>local_machine method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-local_machine-----------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the root key HKEY_LOCAL_MACHINE.</para>
</section>

<section id="wrlomae"><title>local_machine=</title>
<indexterm><primary>local_machine= method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>local_machine= method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-local_machine=----------------------------------------------><
]]>
</programlisting>

<para>This method is used by INIT to set the attribute LOCAL_MACHINE to
HKEY_LOCAL_MACHINE. Do not modify this attribute.</para>
</section>

<section id="wropen"><title>open</title>
<indexterm><primary>open method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>open method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-open(-+---------------+-,subkey-+--------------+-)----------><
         +-parent_handle-+         +-,-| access |-+

access:

   +-ALL-+
|--+-----+------------------------------------------------------>

   +--------------------------------------------------------------+
   V                                                              |
>----+-------+-+------+-+-------+-+---------+-+--------+-+------+-+--|
     +-WRITE-+ +-READ-+ +-QUERY-+ +-EXECUTE-+ +-NOTIFY-+ +-LINK-+
]]>
</programlisting>

<para>Opens a named subkey and return its handle. See
<link linkend="wrcrt">CREATE</link> for
more information about <emphasis role="italic">parent_handle</emphasis>.
Possible values for <emphasis role="italic">access</emphasis> are:</para>
<variablelist>
<varlistentry><term>ALL</term>
<listitem><para>Default
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>Create subkeys, set values
</para></listitem></varlistentry>
<varlistentry><term>READ</term>
<listitem><para>Query subkeys and values
</para></listitem></varlistentry>
<varlistentry><term>QUERY</term>
<listitem><para>Values
</para></listitem></varlistentry>
<varlistentry><term>EXECUTE</term>
<listitem><para>Key access, no subkey access
</para></listitem></varlistentry>
<varlistentry><term>NOTIFY</term>
<listitem><para>Change notification
</para></listitem></varlistentry>
<varlistentry><term>LINK</term>
<listitem><para>Create symbolic links
</para></listitem></varlistentry>
</variablelist><para> More than one value can be specified separated by blanks.
</para>
<para>Notice that on Windows NT some keys require certain access
rights and do not allow to open the key with all but only with certain access
values.</para>
</section>

<section id="wrquer"><title>query</title>
<indexterm><primary>query method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>query method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-query--(--+------------+--)---------------------------------><
             +-key_handle-+
]]>
</programlisting>

<para>Retrieves information about a given key in a compound variable. The
values returned are <emphasis role="italic">class</emphasis> (class name),
<emphasis role="italic">subkeys</emphasis> (number of subkeys)
<emphasis role="italic">values</emphasis> (number of value entries),
<emphasis role="italic">date</emphasis> and
<emphasis role="italic">time</emphasis> of
last modification. If <emphasis role="italic">key_handle</emphasis> is omitted,
CURRENT_KEY is queried. Example:</para>
<programlisting>
myquery. = rg~query(objectrexxkey)
say "class="myquery.class "at" myquery.date
say "subkeys="myquery.subkeys "values="myquery.values
</programlisting>
</section>

<section id="wrrepl"><title>replace</title>
<indexterm><primary>replace method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>replace method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-replace(-+------------+-,-+------------+-,newfilename,oldfilename-)-><
            +-key_handle-+   +-subkeyname-+
]]>
</programlisting>

<para>Replaces the backup file of a key or subkey with a new file. Key must be
an immediate descendant of HKEY_LOCAL_MACHINE or HKEY_USERS. If
<emphasis role="italic">key_handle</emphasis> is omitted, the backup file of
CURRENT_KEY is replaced. The values in the new file become active when the
system is restarted. If <emphasis role="italic">subkeyname</emphasis> is
omitted, the key and all its subkeys will be replaced.</para>
</section>

<section id="wrrest"><title>restore</title>
<indexterm><primary>restore method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>restore method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-restore(-+------------+-,filename-+-------------+-)---------><
            +-key_handle-+           +-,"VOLATILE"-+
]]>
</programlisting>

<para>Restores a key from a file. If
<emphasis role="italic">key_handle</emphasis> is omitted, CURRENT_KEY
is restored. Example:</para>
<programlisting>
rg~restore(objectrexxkey,"\objrexx\orexx")
</programlisting>
<para>The VOLATILE keyword creates a new memory-only set of registry
information that is valid only until the system is restarted.</para>
</section>

<section id="wrsave"><title>save</title>
<indexterm><primary>save method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>save method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-save(-+------------+-,filename)-----------------------------><
         +-key_handle-+
]]>
</programlisting>

<para>Saves the entries of a given key into a file. If
<emphasis role="italic">key_handle</emphasis> is
omitted, CURRENT_KEY is saved. Example: </para>
<programlisting>
rg~SAVE(objectrexxkey,"\objrexx\orexx")
</programlisting>
<para>On a FAT system, do not use a file extension in
<emphasis role="italic">filename</emphasis>.</para>
</section>

<section id="wrstva"><title>setValue</title>
<indexterm><primary>setValue method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>setValue method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-setValue(-+------------+-,-+------+-,value-+---------+-)----><
             +-key_handle-+   +-name-+        +-,NORMAL-+
                                              +-,EXPAND-+
                                              +-,MULTI--+
                                              +-,NUMBER-+
                                              +-,BINARY-+
                                              +-,NONE---+
]]>
</programlisting>

<para>Sets a named value of a given key. If
<emphasis role="italic">name</emphasis> is blank or omitted,
the default value is set. Examples: </para>
<programlisting>
rg~SETVALUE(objectrexxkey, ,"My default","NORMAL")
rg~SETVALUE(objectrexxkey,"Product_Name","Object Rexx")
rg~SETVALUE(objectrexxkey,"VERSION","1.0")
</programlisting>
</section>

<section id="wrunld"><title>unload</title>
<indexterm><primary>unload method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>unload method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-unload(-+------------+-,subkey)-----------------------------><
           +-key_handle-+
]]>
</programlisting>

<para>Removes a named subkey (created with <link linkend="wrload">LOAD</link>)
and its dependents from the registry, but does not modify the file containing
the registry information. If <emphasis role="italic">key_handle</emphasis>
is omitted, the subkey under CURRENT_KEY is unloaded. Unload also unlocks the
registry information file.</para>
</section>

<section id="wruse"><title>users</title>
<indexterm><primary>users method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>users method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-users-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the root key HKEY_USERS.</para>
</section>

<section id="wrusee"><title>users=</title>
<indexterm><primary>users= method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>users= method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-users=------------------------------------------------------><
]]>
</programlisting>

<para>This method is used by INIT to set the attribute USERS to HKEY_USERS. Do
not modify this attribute.</para>
</section>
</section>

</chapter>

