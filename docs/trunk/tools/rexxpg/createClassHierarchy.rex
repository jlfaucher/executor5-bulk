#!/usr/bin/env rexx
/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 2005-2020 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                                         */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/*
This tool creates the ooRexx class hierarchy for the "rexxpg" book, chapter "provide.xml".

The settings as is will create the Dcobook XML rendering.

To generate the ASCII text only, change the value to "pkgLocal~bCreateXML=.false"

Usage:

   createClassHierarchy > classHierarchy.xml

Then use "classHierarchy.txt" to replace the GENERATED section in "provide.xml"
*/

dt="<!-- GENERATED by 'docs/trunk/tools/rexxpg/createClassHierarchy.rex' on [".dateTime~new"] -->"

pkgLocal=.context~package~local
pkgLocal~bCreateXML   = .true       -- .true->XML/Docbook, .false->string

--
pkgLocal~bShowAdditionalInfos=.true -- .false   -- true: show mixin and inherits
pkgLocal~bIgnoreMixinInherits=.true -- .false   -- true: show only mixin subclasses that directly specialize the mixin
pkgLocal~bShowAdded50 = .true
pkgLocal~bShowChanged50 = .true

pkgLocal~added50="&added50;"        -- from rexxpg.ent
pkgLocal~changed50="&changed50;"    -- from rexxpg.ent

pkgLocal~ignoreClasses=.set~of("ArgUtil", "OLEObject", "OLEVariant" )

pkgLocal~classesAdded50=.set~of("StringTable", "AlarmNotification",  -
        "EventSemaphore", "MessageNotification", "MutexSemaphore",   -
        "RexxInfo", "Ticker", "Validate", "VariableReference")

pkgLocal~classesChanged50=.set~of("RegularExpression")

pkgLocal~crlf="0d0a"x
pkgLocal~mb=.MutableBuffer~new(,2048)

pkgLocal~itemizedListBegin = '<itemizedlist mark="none" spacing="compact">'
pkgLocal~itemizedListEnd   = '</itemizedlist>'
pkgLocal~blanks            = '    '    --

if .bCreateXML then .mb~append(.crlf, dt, .crlf, "<para>", .crlf)

call tree .object, 0                -- create the class tree, start out with level=0
if .bCreateXML then .mb~append(.crlf, "</para>", .crlf, dt, .crlf)
say .mb~string                      -- show as string


::routine tree
  use arg clz, level

  clzId=clz~id                      -- get class name

  if clz~package \= .object~package then return    -- ignore any classes that are not part of the the Rexx package
  if .object~package~findPublicClass(clzId) == .nil then return -- ignore any of the non-public Rexx package classes
  -- and finally, there are a few specific classes we ignore because they are package specific or deprecated.
  if .ignoreClasses~hasIndex(clzId) then return    -- ignore this class

  indent=.blanks~copies(level)
  .mb~append(indent)
  if .bCreateXML then
  do
     if level=0 then
     do
        .mb~append(.crlf, indent, .itemizedListBegin, .crlf, indent, .blanks, "<listitem><para>")
     end
     else
     do
        .mb~append(.crlf, indent, .blanks, "<listitem><para>")
     end
     .mb~append("<classname>", clzId, "</classname>")
     if .bShowAdded50,   .classesAdded50~hasIndex(clzId) then .mb~append(" ", .added50)
     if .bShowChanged50, .classesChanged50~hasIndex(clzId) then .mb~append(" ", .changed50)
  end
  else
  do
     if .bShowAdded50,   .classesAdded50~hasIndex(clzId) then .mb~append(.added50)
     if .bShowChanged50, .classesChanged50~hasIndex(clzId) then .mb~append(.changeed50)
     .mb~append("<classname>", clzId, "</classname>")
  end

  mixinClass?=clz~queryMixinClass

  if clz<>.object then
  do
     if .bShowAdditionalInfos=.true then
     do
        if mixinClass? then
        do
           if .bCreateXML then
              .mb~append('<emphasis role="italic"> (mixin)</emphasis>')
           else
              .mb~append(" (mixin)")
        end

        superClasses=clz~superClasses
        if superClasses~items>1 then
        do
           if .bCreateXML then
              .mb~append('<emphasis role="italic"> (inherit<classname>')
           else
              .mb~append(" (inherit")
           do counter i sc over superClasses
              if i=1 then iterate   -- do not show immediate superclass as inherited class!
              .mb~append(" ", sc~id)
           end

           if .bCreateXML then
             .mb~append('</classname>)</emphasis>')
           else
              .mb~append(")")
        end
     end
  end

  if .bCreateXML then
     .mb~append("</para></listitem>",.crlf)  -- add cr-lf
  else
     .mb~append(.crlf)              -- add cr-lf

  bItemizedListCreated=.false       -- if subclasses listed, set to .true
  comparator=.ClassNameComparator~new -- use id value, sort case-independently
  do subClz over clz~subClasses~sortWith(comparator)
     -- if a mixin class only show the subclass if clz is the direct superclass
     if mixinClass?, .bIgnoreMixinInherits, subClz~superclasses[1]<>clz then return

     if .bCreateXML, bItemizedListCreated=.false then
     do
        .mb~append(.crlf, indent, .blanks, "<listitem>", .itemizedListBegin, .crlf)
        bItemizedListCreated=.true
     end

     call tree subClz, level+1      -- process subclass
  end

  if .bCreateXML, bItemizedListCreated then  -- close subclasses itemizedlist
     .mb~append(indent, .blanks, .itemizedListEnd, "</listitem>", .crlf, .crlf)

  if .bCreateXML, level=0 then      -- close root itemizedlist
     .mb~append(.itemizedListEnd, .crlf)  -- add cr-lf


-- compare two classes by id (caselessly)
::class "ClassNameComparator"
::METHOD compare
use strict arg left, right

return left~id~caselessCompareTo(right~id)

::routine pp
  return "["arg(1)"]"
