<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "rexxpg.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: Programming Guide XML file.
    #
    # Copyright (c) 2005-2019, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<chapter id="api4x">
<title>Rexx C++ Application Programming Interfaces</title>
<para>This chapter describes how to interface applications to Rexx or extend
the Rexx language by using Rexx C++ application programming interfaces (APIs).
As used here, the term application refers to programs
written in C++.
</para>
<para>The features described here let a C++ application extend many parts of the
Rexx language or extend an application with Rexx. This includes creating handlers
for Rexx methods, external functions, and system exits.</para>
<variablelist>
<varlistentry><term>Rexx methods</term>
<listitem><para>are methods for Rexx classes written in C++. The methods reside in dynamically
loaded external shared libraries.
</para></listitem></varlistentry>
<varlistentry><term>Functions</term>
<listitem><para>are function extensions of the Rexx language written in C++.  Like the native
methods, functions are packaged in external libraries.
Functions can be general-purpose
extensions or specific to an application.
</para></listitem></varlistentry>
<varlistentry><term>Command Handlers</term>
<listitem><para>are programmer-defined handlers for named command environments.
The application programmer can tailor the Rexx interpreter behavior by
creating named command environments to interfacing with
application environments.
</para></listitem></varlistentry>
<varlistentry><term>System exits</term>
<listitem><para>are programmer-defined variations of the interpreter.
The application programmer can tailor the Rexx interpreter behavior by
using the defined exit points to control Rexx resources.
</para></listitem></varlistentry>
</variablelist>
<para>Methods, functions, system exit handlers, and command handlers have similar coding,
compilation, and packaging characteristics.
</para>
<para>In addition, applications can call methods defined of Rexx objects and
execute them from externally defined methods and functions.</para>

<section id="intertreterapi"><title>Rexx Interpreter API</title>
<para>Rexx programs run in an environment controlled by an interpreter instance.
An interpreter instance environment is created with an enable set of exit handlers and
a customized environment.  An instance may have multiple active threads
and each interpreter instance has a unique version of the .local environment
directory, allowing programs to run with some degree of isolation.
</para>
<para>If you use the older RexxStart (<xref linkend="rexxstartfu" />) API to run
a Rexx program, the Rexx environment initializes, runs a single program, and the
environment is terminated.  With the RexxCreateInterpreter() API, you have fine grain
control over how the environment is used.  You are able to create a tailored environment, perform
multiple operations (potentially, on multiple threads), create objects that persist for longer
than the life of a single program, etc.  An application can create an interpreter instance once, and
reuse it to run multiple programs.
</para>
<para>Interpreter environments are created using the
<xref linkend="createinterpreter" xrefstyle="select:title"/> API:</para>
<example>
<title>API &mdash; Rexx CreateInterpreter</title>
<programlisting language="C++">
RexxInstance *instance;
RexxThreadContext *threadContext;
RexxOption options[25];

if (RexxCreateInterpreter(&amp;instance, &amp;threadContext, options)) {
&hellip;
}
</programlisting>
</example>
<para>Once you've created an interpreter instance, you can use the APIs provided by the
RexxInstance or RexxThreadContext interface to perform operations
like running programs, loading class packages, etc.  For example, the following
code will run a program using a created instance, checking for syntax errors upon completion:</para>
<example>
<title>API &mdash; RexxInstance and RexxThreadContext</title>
<programlisting language="C++">
<![CDATA[
    // create an Array object to hold the program arguments
    RexxArrayObject args = threadContext->NewArray(instanceInfo->argCount);
    // we're passing a variable number of arguments, so we need to create
    // String objects and insert them into the array
    for (size_t i = 0; i < argCount; i++)
    {
        if (arguments[i] != NULL)
        {
            // add the argument to the array, if specified.  Note that ArrayPut() requires an
            // index that is origin-1, unlike C arrays which are origin-0.
            threadContext->ArrayPut(args, threadContext->String(arguments[i]), i + 1);
        }
    }

    // call our program, using the provided arguments.
    RexxObjectPtr result = threadContext->CallProgram("myprogram.rex", args);
    // if an error occurred, get the decoded exception information
    if (threadContext->CheckCondition())
    {
        RexxCondition condition;

        // retrieve the error information and get it into a decoded form
        RexxDirectoryObject cond = threadContext->GetConditionInfo();
        threadContext->DecodeConditionInfo(cond, &condition);
        // display the errors
        printf("error %d: %s\n%s\n", condition.code, threadContext->CString(condition.errortext),
           threadContext->CString(condition.message));
    }
    else
    {
        // Copy any return value as a string
        if (result != NULLOBJECT)
        {
            CSTRING resultString = threadContext->CString(result);
            strncpy(returnResult, resultString, sizeof(returnResult));
        }
    }
    // make sure we terminate this first
    instance->Terminate();
]]>
</programlisting>
</example>
<para>The example above creates a Rexx String object for each program argument
stores them in a Rexx array.  It then uses
<xref linkend="mthCallProgram" xrefstyle="select:title"/> to call "myprogram.rex", passing the array object
as the program arguments.  On return, if the program terminated with a Rexx SYNTAX error, it
displays the error message to the console.  Finally, if the program
exited normally and returned a value, the ASCII-Z value of that result is copied to a buffer.  As
a final step, the interpreter instance is destroyed once we're finished using it.</para>
<section id="createinterpreter"><title>RexxCreateInterpreter</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>RexxCreateInterpreter</secondary></indexterm>
<indexterm><primary>RexxCreateInterpreter</primary></indexterm>
<para>RexxCreateInterpreter creates an interpreter instance and an associated
thread context interface for the current thread.</para>
<example>
<title>API &mdash; RexxInstance and RexxThreadContext</title>
<programlisting language="C++">
RexxInstance *instance;
RexxThreadContext *threadContext;
RexxOption options[25];

if (RexxCreateInterpreter(&amp;instance, &amp;threadContext, options)) {
&hellip;
}
</programlisting>
</example>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1">
    <tgroup cols="2">
    <colspec colnum="1" colwidth="1*" />
    <colspec colnum="2" colwidth="5*" />
    <tbody>
    <row><entry><emphasis role="italic">instance</emphasis></entry>
    <entry><para>The returned RexxInstance interface vector.  The interface
    vector provides access to APIs that apply to the global interpreter environment.</para></entry>
    </row>
    <row><entry><emphasis role="italic">threadContext</emphasis></entry>
    <entry><para>The returned RexxThreadContext interface vector for the thread that creates the
    interpreter instance.  The thread context vector provides access to thread-specific services.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">options</emphasis></entry>
    <entry><para>An array of RexxOption structures that control the interpreter
    instance initialization.  See <xref linkend="instanceoptions" /> for details on
    the available options.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 (TRUE) if the interpreter instance was successfully created, 0 (FALSE) for any
failure to create the interpreter.</para>
</section>

<section id="instanceoptions"><title>Interpreter Instance Options</title>
<para>The third argument to RexxCreateInterpreter is an options array
that sets characteristics of the interpreter instance.  The
<emphasis role="bold">options</emphasis>
argument points to an array of RexxOption structures, and can be NULL if no options are required.
Each RexxOption instance
contains information for named options that can be specified in any order and even multiple times.
The oorexxapi.h include file
contains a #define for each option name.  The information required by an option
varies with each option type, and is specified using a ValueDescriptor struct to
handle a variety of data types.
An entry with a NULL option
name terminates the option list.  The available interpreter options are:</para>
<variablelist>
<varlistentry><term>INITIAL_ADDRESS_ENVIRONMENT</term>
<listitem><para>Contains the ASCII-Z name of the initial address environment
that will be used for all Rexx programs run under this instance.</para>
<example>
<title>API &mdash; RexxOption INITIAL_ADDRESS_ENVIRONMENT</title>
<programlisting language="C++">
RexxOption options[2];

options[0].optionName = INITIAL_ADDRESS_ENVIRONMENT;
options[0].option = "EDITOR";
options[1].optionName = NULL;
</programlisting>
</example>
</listitem></varlistentry>
<varlistentry><term>APPLICATION_DATA</term>
<listitem><para>Contains a void * value that will be stored with the interpreter
instance.  The application data can be retrieved using the
<xref linkend="mthGetApplicationData" xrefstyle="select:title"/> API.  The application
data pointer allows methods, functions, exits, and command handlers to recover
access to globally defined application data.
</para>
<example>
<title>API &mdash; RexxOption APPLICATION_DATA</title>
<programlisting language="C++">
RexxOption options[2];

options[0].optionName = APPLICATION_DATA;
options[0].option = (void *)editorInfo;
options[1].optionName = NULL;
</programlisting>
</example>
</listitem></varlistentry>
<varlistentry><term>EXTERNAL_CALL_PATH</term>
<listitem><para>Contains an ASCII-Z string defining an additional search path that
is used when searching for Rexx program files.  The call path string uses the
format appropriate for the host platform environment.  On Windows, the path elements
are separated by semicolons (;).  On Unix-based systems, a colon (:) is used.
</para>
<example>
<title>API &mdash; RexxOption EXTERNAL_CALL_PATH</title>
<programlisting language="C++">
RexxOption options[2];

options[0].optionName = EXTERNAL_CALL_PATH;
options[0].option = myCallPath;
options[1].optionName = NULL;
</programlisting>
</example>
</listitem></varlistentry>
<varlistentry><term>EXTERNAL_CALL_EXTENSIONS</term>
<listitem><para>Contains an ASCII-Z string defining a list of extensions that will
be used when searching for Rexx program files.  The specified extensions must include
the extension ".".  Multiple extensions are separated by a comma (,).
</para>
<example>
<title>API &mdash; RexxOption EXTERNAL_CALL_EXTENSIONS</title>
<programlisting language="C++">
RexxOption options[2];

options[0].optionName = EXTERNAL_CALL_EXTENSIONS;
options[0].option = ".ed,.mac";  // add ".ed" and ".mac" to search path.
options[1].optionName = NULL;
</programlisting>
</example>
</listitem></varlistentry>
<varlistentry><term>LOAD_REQUIRED_LIBRARY</term>
<listitem><para>Specifies the name of an external native library that will be loaded
once the interpreter instance is created.  The library name is an ASCII-Z string
with the library name in the same format used for ::REQUIRES LIBRARY.  Multiple libraries
can be loaded by specifying this option multiple times.
</para>
<example>
<title>API &mdash; RexxOption LOAD_REQUIRED_LIBRARY</title>
<programlisting language="C++">
RexxOption options[2];

options[0].optionName = LOAD_REQUIRED_LIBRARY;
options[0].option = "rxmath";
options[1].optionName = NULL;
</programlisting>
</example>
</listitem></varlistentry>
<varlistentry><term>REGISTER_LIBRARY</term>
<listitem><para>Specifies a package that will be registered with the Rexx environment
without loading an external library.  The library is specified with a RexxLibraryPackage
structure that gives the library name and a pointer to the associated
RexxPackageEntry (<xref linkend="buildinglibs" />)
table that describes the package contents.
The library name is an ASCII-Z string
with the library name in the same format used for ::REQUIRES LIBRARY.  Multiple libraries
can be registered by specifying this option multiple times.
</para>
<example>
<title>API &mdash; RexxOption REGISTER_LIBRARY</title>
<programlisting language="C++">
RexxOption options[2];
RexxLibraryPackage package;

package.registeredName = "mypackage";
package.table = packageTable;

options[0].optionName = REGISTER_LIBRARY;
options[0].option = (void *)&amp;package;
options[1].optionName = NULL;
</programlisting>
</example>
</listitem></varlistentry>
<varlistentry><term>DIRECT_EXITS</term>
<listitem><para>Specifies a list of system exits that will be used with this interpreter
instance.  The exits are a list of RexxContextExit structs.  Each enabled exit is
specified in a single RexxContextExit struct that identifies exit type and
handler entry point.
The list is terminated by an instance using an
exit type of 0.  The direct exits are called using the RexxExitContext calling convention.
See <xref linkend="exitsapi" /> for details.
</para>
<example>
<title>API &mdash; RexxOption DIRECT_EXITS</title>
<programlisting language="C++">
RexxContextExit exits[2];
RexxOption options[2];


exits[0].handler = functionExit;
exits[0].sysexit_code = RXOFNC;
exits[1].sysexit_code = 0;

options[0].optionName = DIRECT_EXITS;
options[0].option = (void *)exits;
options[1].optionName = NULL;
</programlisting>
</example>
</listitem></varlistentry>
<varlistentry><term id="instanceoptionDirect">DIRECT_ENVIRONMENTS</term>
<listitem><para>Registers one or more direct subcommand handler environments with the interpreter
instance.  The handlers are a list of RexxContextEnvironment structs.  Each enabled handler is
specified in a single RexxContextEnvironment struct identifying the handler name and
entry point.
The list is terminated by an instance using a handler entry point of NULL or a
handler name of NULL.  The direct environment handlers are called using the calling convention
described in <xref linkend="commandapi" />.
</para>
<example>
<title>API &mdash; RexxOption DIRECT_ENVIRONMENTS</title>
<programlisting language="C++">
RexxContextEnvironment environments[2];
RexxOption options[2];


environments[0].handler = editorHandler;
environments[0].name = "EDITOR";
environments[1].handler = NULL;
environments[1].name = NULL;

options[0].optionName = DIRECT_ENVIRONMENTS;
options[0].option = (void *)environments;
options[1].optionName = NULL;
</programlisting>
</example>
</listitem></varlistentry>
<varlistentry><term id="instanceoptionRedirecting">REDIRECTING_ENVIRONMENTS</term>
<listitem><para>Registers one or more redirecting subcommand handler environments with the interpreter
instance.  The handlers are a list of RexxRedirectingEnvironment structs.  Each enabled handler is
specified in a single RexxRedirectingEnvironment struct identifying the handler name and
entry point.
The list is terminated by an instance using a handler entry point of NULL or a
handler name of NULL.
The redirecting environment handlers are called using the calling convention
described in <xref linkend="commandapi" />.
</para>
<example>
<title>API &mdash; RexxOption REDIRECTING_ENVIRONMENTS</title>
<programlisting language="C++">
RexxRedirectingEnvironment environments[2];
RexxOption options[2];


environments[0].handler = redirectingCommandHandler;
environments[0].name = "SYSTEM";
environments[1].handler = NULL;
environments[1].name = NULL;

options[0].optionName = REDIRECTING_ENVIRONMENTS;
options[0].option = (void *)environments;
options[1].optionName = NULL;
</programlisting>
</example>
</listitem></varlistentry>
<varlistentry><term>REGISTERED_EXITS</term>
<listitem><para>Specifies a list of system exits that will be used with this interpreter
instance.  The exits are a list of RexxContextExit structs.  Each enabled exit is
specified in a single RexxContextExit struct identifying the type of the exit and the
name of the registered exit handler.
The list is terminated by an instance using an
exit type of 0.  The registered exits are called using the RexxExitHandler calling convention.
See <xref linkend="sysex" /> for details.
</para>
<example>
<title>API &mdash; RexxOption REGISTERED_EXITS</title>
<programlisting language="C++">
RXSYSEXIT exits[2];
RexxOption options[2];


exits[0].sysexit_name = "MyFunctionExit";
exits[0].sysexit_code = RXOFNC;
exits[1].sysexit_code = 0;

options[0].optionName = REGISTERED_EXITS;
options[0].option = (void *)exits;
options[1].optionName = NULL;
</programlisting>
</example>
</listitem></varlistentry>
<varlistentry><term>REGISTERED_ENVIRONMENTS</term>
<listitem><para>Registers one or more subcommand handler environments with the interpreter
instance.  The handlers are a list of RexxRegisteredEnvironment structs.  Each enabled handler is
specified in a single RexxRegisteredEnvironment struct identifying the name of the environment and the
registered subcom handler name.
The list is terminated by an instance using a
handler name of NULL.  The direct environment handlers are called using the calling convention
described in <xref linkend="subcom" />.
</para>
<example>
<title>API &mdash; RexxOption REGISTERED_ENVIRONMENTS</title>
<programlisting language="C++">
RexxRegisteredEnvironment environments[2];
RexxOption options[2];


environments[0].registeredName = "MyEditorName";
environments[0].name = "EDITOR";
environments[1].name = NULL;

options[0].optionName = REGISTERED_ENVIRONMENTS;
options[0].option = (void *)environments;
options[1].optionName = NULL;
</programlisting>
</example>
</listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="apitypes"><title>Data Types Used in APIs</title>
<para>The ooRexx APIs rely on a variety of special C++ types for interfacing with
the interpreter.  Some of these types are specific to the Rexx language, while
others are standard types defined by C++.  Many of the APIs involve conversion
between types, while others require values of a specific type as arguments.
This section explains the different types and the rules for using these types.
</para>
<section id="objecttypes" revisionflag="changed"><title>&changed50;Rexx Object Types</title>
<para>Open Object Rexx is fundamentally an object-oriented language.  All data in
the language (including strings and numbers) are represented by object instances.
The ooRexx APIs use a number of opaque types that represent instances
of Rexx built-in objects.  The defined object types are:
</para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup cols="2">
<colspec colnum="1" colwidth="1*" />
<colspec colnum="2" colwidth="3*" />
<tbody>
<row><entry>RexxObjectPtr</entry>
<entry><para>a reference to a Rexx object instance.  This is the root of object
hierarchy and can represent any type of object.
</para></entry></row>
<row><entry>RexxStringObject</entry>
<entry><para>an instance of the Rexx String class.  The API set allows String objects
to be created and manipulated.
</para></entry></row>
<row><entry>RexxBufferStringObject</entry>
<entry><para>an instance of the Rexx String class that can be written into.
Buffer strings are used for constructing String objects "in-place" to avoid
needing to create a String from a separate buffer.
RexxBufferStringObject instances must be finalized to be converted into a usable
Rexx String object.
</para></entry></row>
<row><entry>RexxArrayObject</entry>
<entry><para>An instance of a Rexx &singledimarray;.  Arrays are used
in many places, and there are interfaces provided for direct array manipulation.
</para></entry></row>
<row><entry>RexxDirectoryObject</entry>
<entry><para>An instance of Rexx Directory class.  Like arrays, there are
APIs provided for access and manipulating data stored in a directory.
</para></entry></row>
<row><entry>RexxStringTableObject</entry>
<entry><para>An instance of Rexx StringTable class.  Like for directories, there are
APIs provided for access and manipulating data stored in a StringTable.
</para></entry></row>
<row><entry>RexxStemObject</entry>
<entry><para>An instance of the Rexx Stem class.  The APIs include a number of
utility routines for accessing and manipulating data in Stem objects.
</para></entry></row>
<row><entry>RexxSupplierObject</entry>
<entry><para>An instance of the Rexx Supplier class.
</para></entry></row>
<row><entry>RexxClassObject</entry>
<entry><para>An instance of the Rexx Class class.
</para></entry></row>
<row><entry>RexxPackageObject</entry>
<entry><para>An instance of the Rexx Package class.
</para></entry></row>
<row><entry>RexxMethodObject</entry>
<entry><para>An instance of the Rexx Method class.
</para></entry></row>
<row><entry>RexxRoutineObject</entry>
<entry><para>An instance of the Rexx Routine class.  Routine objects
can be invoked directly from C++ code.
</para></entry></row>
<row><entry>RexxPointerObject</entry>
<entry><para>A wrapper around a pointer value.  Pointer objects are designed
for constructing Rexx classes that interface with native code subsystems.
</para></entry></row>
<row><entry>RexxBufferObject</entry>
<entry><para>An allocatable storage object that can be used for storing native
C++ data.  Buffer objects and the contained data are managed using the Rexx object
garbage collector.
</para></entry></row>
<row><entry>RexxMutableBufferObject</entry>
<entry><para>An instance of the Rexx MutableBuffer class.
</para></entry></row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="numerictypes"><title>Rexx Numeric Types</title>
<para>The Routine and Method interfaces support a very complete set of C numeric types as
arguments and return values.  In addition, there are also APIs provided for converting between
Rexx Objects and numeric types (and the reverse transformation as well).  It is recommended that
you allow the Rexx runtime and APIs to handle conversions between Rexx strings and numeric types to
give behavior consistent with the Rexx built-in methods and functions.
</para>
<para>In addition to a full set of standard numeric types, there are special types
provided that implement the standard Rexx rules for numbers used internally by Rexx.
These types are:</para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup cols="2">
<colspec colnum="1" colwidth="1*" />
<colspec colnum="2" colwidth="2*" />
<tbody>
<row><entry>wholenumber_t</entry>
<entry><para>conversions involving the wholenumber_t conform to the Rexx whole number
rules.  Values are converted using the same internal digits value used by the built-in functions.
For 32-bit versions, this is numeric digits 9, giving a range of 999,999,999 to -999,999,999.
On 64-bit systems, numeric digits 18 is used, giving a range of 999,999,999,999,999,999 to
-999,999,999,999,999,999.
</para></entry></row>
<row><entry>positive_wholenumber_t</entry>
<entry><para>very similar to above wholenumber_t, but with the added restriction that the value must be equal to or larger than one.
For 32-bit versions, this gives a range of 999,999,999 to 1.
On 64-bit systems, the range is 999,999,999,999,999,999 to 1.
</para></entry></row>
<row><entry>nonnegative_wholenumber_t</entry>
<entry><para>very similar to above wholenumber_t, but with the added restriction that the value must be equal to or larger than zero.
For 32-bit versions, this gives a range of 999,999,999 to 0.
On 64-bit systems, the range is 999,999,999,999,999,999 to 0.
</para></entry></row>
<row><entry>stringsize_t</entry>
<entry><para>stringsize_t conversions also conform to the Rexx whole number
rules, with the added restriction that the value must be a non-negative whole number value.  The
stringsize_t type is useful for arguments such as string lengths where only a non-negative value is
allowed.  The range for 32-bit versions is 999,999,999 to 0, and
999,999,999,999,999,999 to 0 on 64-bit platforms.
</para></entry></row>
<row><entry>logical_t</entry>
<entry><para>a Rexx logical value.  On conversion from a string value, this must be
either '1' (true) or '0' (false).  On conversion back to a string value,
a non-zero binary value will be converted
to '1' (true) and zero will become '0' (false).
</para></entry></row>
</tbody>
</tgroup>
</informaltable>
<para>A subset of the integer numeric types are of differing sizes depending on the
addressing mode of the system you are compiling on.  These types will be either 32-bits
or 64-bits.  The variable size types are: </para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup cols="2">
<colspec colnum="1" colwidth="1*" />
<colspec colnum="2" colwidth="4*" />
<tbody>
<row><entry>size_t</entry>
<entry><para>An unsigned "size" value.  This is the value type returned by pointer subtraction.
</para></entry></row>
<row><entry>ssize_t</entry>
<entry><para>The signed equivalent to size_t.
</para></entry></row>
<row><entry>uintptr_t</entry>
<entry><para>An unsigned integer value that's guaranteed to be the same size as a pointer value.
Use an uintptr_t type if you wish to return a pointer value as a Rexx number.
</para></entry></row>
<row><entry>intptr_t</entry>
<entry><para>A signed equivalent to uintptr_t.
</para></entry></row>
</tbody>
</tgroup>
</informaltable>
<para>The remainder of the numeric types have fixed sizes regardless of the addressing mode.</para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup cols="2">
<colspec colnum="1" colwidth="1*" />
<colspec colnum="2" colwidth="4*" />
<tbody>
<row><entry>int</entry>
<entry><para>A 32-bit signed integer.
</para></entry></row>
<row><entry>int32_t</entry>
<entry><para>A 32-bit signed integer.  This is equivalent to int.
</para></entry></row>
<row><entry>uint32_t</entry>
<entry><para>An unsigned 32-bit integer.
</para></entry></row>
<row><entry>int64_t</entry>
<entry><para>A signed 64-bit integer.
</para></entry></row>
<row><entry>uint64_t</entry>
<entry><para>An unsigned 64-bit integer.
</para></entry></row>
<row><entry>int16_t</entry>
<entry><para>A signed 16-bit integer.
</para></entry></row>
<row><entry>uint16_t</entry>
<entry><para>An unsigned 16-bit integer.
</para></entry></row>
<row><entry>int8_t</entry>
<entry><para>A signed 8-bit integer.
</para></entry></row>
<row><entry>uint8_t</entry>
<entry><para>An unsigned 8-bit integer.
</para></entry></row>
<row><entry>float</entry>
<entry><para>A 32-bit floating point number.  When used as an
argument to a routine or method, the strings "nan", "+infinity", and
"-infinity" will be converted into the appropriate floating-point values.  The
reverse conversion is used when converting floating-point values back into
Rexx objects.
</para></entry></row>
<row><entry>double</entry>
<entry><para>A 64-bit floating point number.  The Rexx runtime applies the
same special processing for nan, +infinity, and -infinity values as float types.
</para></entry></row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>

<section id="apiconcepts"><title>Introduction to API Vectors</title>
<para>The Rexx APIs operate through a set of interface vectors that define a
set of interpreter services that are available.  There are different interface
vectors used for different contexts, but they use very similar calling concepts.
</para>
<para>The first interface vector you'll encounter with the programming interfaces is
the RexxInstance value returned by RexxCreateInterpreter.  The RexxInstance type is defined
as a struct when compiled for C code, or a C++ class when compiled for ++.  The
struct version looks like this:</para>
<example>
<title>API &mdash; RexxInstance</title>
<programlisting language="C++">
struct RexxInstance_
{
    RexxInstanceInterface *functions;   // the interface function vector
    void *applicationData;              // creator defined data pointer
};
</programlisting>
</example>
<para>The field <emphasis role="italic">applicationData</emphasis> contains any
value that was specified via the APPLICATION_DATA option on the RexxCreateInterpreter call.
This provides easy access to any application-specific data needed to interact with the interpreter.
All other interface contexts will include a pointer to the RexxInstance structure, so it is
always possible to recover this data pointer.</para>
<para>The <emphasis role="italic">functions</emphasis> field is a pointer to a second structure
that defines the RexxInstance programming interfaces.  The RexxInstance services are ones that
may be called from any thread and in any context.  The services are called using C function pointer
fields in the interface structure.  The RexxInstanceInterface looks like this:</para>
<example>
<title>API &mdash; RexxInstanceInterface</title>
<programlisting language="C++">
typedef struct
{
    wholenumber_t interfaceVersion;    // The interface version identifier

    void        (RexxEntry *Terminate)(RexxInstance *);
    logical_t   (RexxEntry *AttachThread)(RexxInstance *, RexxThreadContext **);
    size_t      (RexxEntry *InterpreterVersion)(RexxInstance *);
    size_t      (RexxEntry *LanguageLevel)(RexxInstance *);
    void        (RexxEntry *Halt)(RexxInstance *);
    void        (RexxEntry *SetTrace)(RexxInstance *, logical_t);
} RexxInstanceInterface;
</programlisting>
</example>
<para>The first thing to note is the interface struct contains a field named
<emphasis role="italic">interfaceVersion</emphasis>.  The interfaceVersion field
is a version marker that defines the services the interpreter version supports.
This interface version is incremented any time new functions are added to the interface.
Using the interface version allows application code to reliably check that required
interface functions are available.</para>
<para>The remainder of the fields are functions that can be called to perform RexxInstance
operations.  Note that the first argument to all of the functions is a pointer to a RexxInstance
structure.  A call to the InterpreterVersion API from C code would look like this:</para>
<programlisting language="C++">
size_t version = context->functions->InterpreterVersion(context);
</programlisting>
<para>When using C++ code, the RexxThreadContext struct has convenience methods that simplify calling
these functions:</para>
<programlisting language="C++">
size_t version = context->InterpreterVersion();
</programlisting>
<para>Note that in the C++ call, it is no longer necessary to pass the RexxInstance as the
first object.  That's handled automatically by the C++ method.</para>
<para>The RexxThreadContext pointer returned from RexxCreateInterpreter() functions the same way.
RexxThreadContext looks like this:</para>
<example>
<title>API &mdash; RexxThreadContext</title>
<programlisting language="C++">
struct RexxThreadContext_
{
    RexxInstance *instance;             // the owning instance
    RexxThreadInterface *functions;     // the interface function vector
}
</programlisting>
</example>
<para>The RexxThreadContext struct contains an embedded RexxInstance pointer for the associated interpreter instance.
It also contains an interface vector for the functions available with a
RexxThreadContext.  The RexxThreadInterface vector has its own version identifier and
function pointer for each of the defined services.
The RexxThreadContext functions all require a RexxThreadContext pointer as
the first argument.  The RexxThreadContext class also defines C++ convenience methods for accessing its
own functions and the functions for the RexxInstance as well.  For example, to call the
<xref linkend="mthInterpreterVersion" xrefstyle="select:title"/>
API using a RexxThreadContext from C code, it is necessary to code</para>
<programlisting language="C++">
size_t version = context->instance->functions->InterpreterVersion(context->instance);
</programlisting>
<para>The C++ version is simply</para>
<programlisting language="C++">
// context is a RexxThreadContext *
size_t version = context->InterpreterVersion();
</programlisting>
<para>When the Rexx interpreter makes calls to native code routines and methods, or invokes
exit handlers, the calls use context structures specific to the call context.  These
are the <xref linkend="callcontext" xrefstyle="template:RexxCallContext" />,
<xref linkend="methodcontext" xrefstyle="template:RexxMethodContext" />, and
<xref linkend="exitcontext" xrefstyle="template:RexxExitContext" /> structures.  Each structure
contains a pointer to a RexxThreadContext instance that's valid until the call returns.
Through the embedded RexxThreadContext, each call may use any of the
RexxThreadContext or RexxInstance
functions in addition to the context-specific functions.  Each context defines
C++ methods for the embedded RexxInstance and RexxThreadContext functions.</para>
<para>Note that the RexxInstance interface can be used at any time and on any thread.  The
RexxThreadContext returned by RexxCreateInterpreter() can only be used on the same thread
as the RexxCreateInterpreter() call, but is not valid for use in the context of a method, routine,
or exit call-out.  In those contexts, the RexxThreadContext instance passed to the call-out
must be used.  A RexxThreadContext instance created for a call-out is only valid until the
call returns to the interpreter.</para>
</section>

<section id="instancethread"><title>Threading Considerations</title>
<para>When using <xref linkend="createinterpreter" xrefstyle="select:title"/> to create a new
interpreter instances, a RexxThreadContext pointer is returned with the interpreter instance.  The thread
context vector allows you to perform operations such as running Rexx programs while in the same thread
context as the RexxCreateInterpreter() call.
</para>
<para>A given interpreter instance can process calls from multiple threads, but a RexxThreadContext instance
must be obtained for each additional thread you wish to use.  A new thread context is obtained
by calling AttachThread() using the RexxInstance API vector returned from RexxCreateInterpreter().  Once
a valid RexxThreadContext interface has been created for the thread, any of the thread context operations
may be used from that thread.  Before the thread terminates,
the <xref linkend="mthDetachThread" xrefstyle="select:title"/>
API must be called to remove the attached thread from the interpreter instance.</para>
<para>The interpreter is capable of asynchronous calls to interpreter APIs from signal or event
handlers.  When called in this manner, it is possible that AttachThread will be called while
running on a thread that is already attached to the interpreter instance.  When a nested
<xref linkend="mthAttachThread" xrefstyle="select:title"/> call is made, the previous thread context is
suspended and the newly created thread context is the active context for the source thread.  It is very
important that DetachThread() be called to restore the original thread context before you return from the
signal handler.
</para>
</section>
<section id="gcmodel"><title>Garbage Collection Considerations</title>
<para>When any context API has a return result that is a Rexx object instance,
the source API context will protect that object instance from garbage collection
for as long as the context is valid.  Once the API context is destroyed,
the accessed objects might become eligible for garbage collection and be reclaimed
by the interpreter runtime.
These object references are only
valid until the current context is destroyed.  They cannot be stored in native code
control blocks and be used in other thread contexts.  If you wish to store object references so
that they can be accessed by other thread contexts, you can create a globally valid object
reference using the <xref linkend="mthRequestGlobalReference" xrefstyle="select:title"/>
API.  A global reference will protect the
object from the garbage collector until the interpreter instance is terminated.  Protecting
the object will also protect any objects referenced by the protected object.  For example,
using RequestGlobalReference() to protect a Directory object will also protect all of the
directory keys and values.
The global reference can be used with any API context valid for the same interpreter instance. Once you
are finished with a locked object,
<xref linkend="mthReleaseGlobalReference" xrefstyle="select:title"/> removes
the object lock and makes the object eligible for garbage collection.
</para>
<para>On the flip side of this, sometimes it is desirable to remove the local API context
protection from an object.  For example, if you use the ArrayAt() API to iterate through all
of the elements of an Array, each object ArrayAt() returns will be added to the API context's protection
table. There is a small overhead associated with each protected reference, so iterating through a large
array would accumulate that overhead for each array element.
Using <xref linkend="mthReleaseLocalReference" xrefstyle="select:title"/> on an object reference you no longer
require will remove the local lock, and thus limit the overhead associated with tracking the object references.
</para>
</section>

<section id="instanceapi"><title>Rexx Interpreter Instance Interface</title>
<para>The Interpreter Instance API is defined by the RexxInstance interface vector.  The RexxInstance
defines methods that affect the global state of the interpreter instance.  Most of the instance APIs can
be called from any thread without requiring any extra steps to access the instance. The two most
important instance operations are <xref linkend="mthAttachThread" xrefstyle="select:title"/>
and <xref linkend="mthTerminate" xrefstyle="select:title" />.
AttachThread() allows additional externally identified
threads to be included in the interpreter instance threadpool.  AttachThread returns a
<xref linkend="threadcontext" xrefstyle="template:RexxThreadContext"/> interface vector that enables a wider range of
capability for the attached thread. The Terminate() API shuts down an interpreter instance when it is no
longer needed.
</para>
</section>

<section id="threadcontext"><title>Rexx Thread Context Interface</title>
<para>The RexxThreadContext interface vector provides a very wide range of functions
to your application code.  There are more than 170 functions defined on a RexxThreadContext.
Among the services provided are:
</para>
<itemizedlist>
<listitem><para>Running Rexx programs</para></listitem>
<listitem><para>Loading Rexx packages</para></listitem>
<listitem><para>Invoking methods of Rexx objects</para></listitem>
<listitem><para>Converting between objects and various C++ types</para></listitem>
<listitem><para>Creating and manipulating common Rexx object types</para></listitem>
<listitem><para>Raising/handling Rexx syntax errors</para></listitem>
</itemizedlist>
<para>The C++ methods defined on a RexxThreadContext C++ object include the methods defined
by the <xref linkend="instanceapi" xrefstyle="template:RexxInstance" /> class,
so the single context vector is used to access both thread context
and interpreter instance APIs.</para>
<para>A RexxThreadContext instance is returned with the original
<xref linkend="createinterpreter" xrefstyle="select:title"/> call that created the
interpreter instance.  The <xref linkend="mthAttachThread" xrefstyle="select:title"/> method
will create a RexxThreadContext instance for additional threads that you add to an interpreter
instance.
Additionally, the <xref linkend="methodcontext" xrefstyle="template:RexxMethodContext" />,
<xref linkend="callcontext" xrefstyle="template:RexxCallContext" />, and
<xref linkend="exitcontext" xrefstyle="template:RexxExitContext" />
objects embed a RexxThreadContext object the same way that a RexxThreadContext object embeds
a RexxInstance object.</para>
</section>

<section id="methodcontext"><title>Rexx Method Context Interface</title>
<para>A RexxMethodContext object is included as an argument
to any native C++ method (<xref linkend="methodapi" />)
defined in external libraries.  The method context provides services that are specific to
a method call, including:
</para>
<itemizedlist>
<listitem><para>Accessing method-specific values such as SELF, SUPER, etc.</para></listitem>
<listitem><para>Manipulating object instance variables</para></listitem>
<listitem><para>Forwarding messages</para></listitem>
<listitem><para>Manipulating GUARD state</para></listitem>
<listitem><para>Locating classes defined in the method's package scope</para></listitem>
</itemizedlist>
<para>In addition to the method-specific functions, the RexxMethodContext object has an embedded
a <xref linkend="threadcontext" xrefstyle="template:RexxThreadContext"/>
object created specifically for this environment.  The RexxThreadContext provides a large number of
additional methods to the method environment.
</para>
<para>API calls made using the RexxMethodContext APIs may cause Rexx
syntax errors or other conditions to be raised.  These calls
are invoked as if the current context is operating with SIGNAL ON ANY enabled.  Any
conditions will be trapped and
held in a pending condition until the current context returns.  At the return, if a
condition is still pending, the appropriate condition is reraised in the caller's context.
These
errors can be checked using the <xref linkend="mthCheckCondition" xrefstyle="select:title"/> API, and
pending conditions can be cancelled using <xref linkend="mthClearCondition" xrefstyle="select:title"/>.
</para>
</section>

<section id="callcontext"><title>Rexx Call Context Interface</title>
<para>A RexxCallContext object is included as an argument to any
native C++ routine (<xref linkend="functionapi" />)
defined in external libraries.  The call context provides services that are specific to
a routine call, including:
</para>
<itemizedlist>
<listitem><para>Accessing caller context specific values such as the current numeric settings</para></listitem>
<listitem><para>Manipulating variables in the caller's variable context</para></listitem>
<listitem><para>Locating classes defined in the routine's package scope</para></listitem>
</itemizedlist>
<para>In addition to the call-specific functions, the RexxCallContext object has an embedded
a <xref linkend="threadcontext" xrefstyle="template:RexxThreadContext"/>
object created specifically for this environment.  The RexxThreadContext provides a large number of
additional methods to the call environment.</para>
<para>API calls made using the RexxCallContext APIs may cause Rexx
syntax errors or other conditions to be raised.  These calls are invoked
as if the current context is operating with SIGNAL ON ANY enabled.  Any
conditions will be trapped and
held in a pending condition until the current context returns.  At the return, if a
condition is still pending, the appropriate condition is reraised in the caller's context.
These
errors can be checked using the <xref linkend="mthCheckCondition" xrefstyle="select:title"/> API, and
pending conditions can be cancelled using <xref linkend="mthClearCondition" xrefstyle="select:title"/>.
</para>
</section>

<section id="exitcontext"><title>Rexx Exit Context Interface</title>
<para>A RexxExitContext object is included as an argument to any
<xref linkend="contextexitdef" xrefstyle="template:system exit" /> or
<xref linkend="commandapi" xrefstyle="template:command handler "/>.
The exit context provides services that are specific to
an exit call, including:
</para>
<itemizedlist>
<listitem><para>Accessing caller context specific values such as the current numeric settings</para></listitem>
<listitem><para>Manipulating variables in the caller's variable context</para></listitem>
</itemizedlist>
<para>In addition to the exit-specific functions, the RexxExitContext object has an embedded
a <xref linkend="threadcontext" xrefstyle="template:RexxThreadContext"/>
object created specifically for this environment.  The RexxThreadContext provides a large number of
additional methods to the exit environment.</para>
<para>API calls made using the RexxExitContext APIs may cause Rexx
syntax errors or other conditions to be raised.  These calls are invoked
as if the current context is operating with SIGNAL ON ANY enabled.  Any
conditions will be trapped and
held in a pending condition until the current context returns.  At the return, if a
condition is still pending, the appropriate condition is reraised in the caller's context.
These
errors can be checked using the <xref linkend="mthCheckCondition" xrefstyle="select:title"/> API, and
pending conditions can be cancelled using <xref linkend="mthClearCondition" xrefstyle="select:title"/>.
</para>
</section>

<section id="redirectorcontext"><title>&added50;Rexx I/O Redirector Context Interface</title>
<para>A RexxIORedirectorContext object is included as the last argument to any
redirecting <xref linkend="commandapi" xrefstyle="template:command handler "/>.
The I/O Redirector context provides services that are specific to
the redirection of STDIN, STDOUT, and STDERR of external commands, including:
</para>
<itemizedlist>
<listitem><para>Providing information whether redirection was requested, and for which standard stream</para></listitem>
<listitem><para>Retrieving input data for STDIN redirection</para></listitem>
<listitem><para>Returning output data from STDOUT and STDERR redirection</para></listitem>
</itemizedlist>
<para>API calls made using the RexxIORedirectorContext APIs may cause Rexx
syntax errors or other conditions to be raised.  These calls are invoked
as if the current context is operating with SIGNAL ON ANY enabled.  Any
conditions will be trapped and
held in a pending condition until the current context returns.  At the return, if a
condition is still pending, the appropriate condition is reraised in the caller's context.
These
errors can be checked using the <xref linkend="mthCheckCondition" xrefstyle="select:title"/> API, and
pending conditions can be cancelled using <xref linkend="mthClearCondition" xrefstyle="select:title"/>.
</para>
</section>

<section id="buildinglibs"><title>Building an External Native Library</title>
<para>External libraries written in compiled languages (typically C or C++)
provide a means to
interface Rexx programs with other subsystems intended for compiled languages.
These libraries are packaged as Dynamic Link Libraries on Windows or shared libraries on
Unix-based systems.
A named library can be loaded using the ::REQUIRES directive, the
loadLibrary() method on the Package class, or by using the EXTERNAL keyword on
a ::ROUTINE, ::METHOD, or ::ATTRIBUTE directive.
</para>
<para>When the library is loaded, the interpreter searches for an entry point
in the library named RexxGetPackage().  An external library package is required
to provide a RexxGetPackage() function that returns a pointer to the descriptor
structure defining the methods and routines contained within the library.
The RexxGetPackage() routine takes no arguments and has a RexxPackageEntry *return value.
This is normally created using the OOREXX_GET_PACKAGE()
macro defined in the oorexxapi.h include file.</para>
<programlisting language="C++">
// package loading stub.
OOREXX_GET_PACKAGE(package);
</programlisting>
<para>Where <emphasis role="italic">package</emphasis> is the name
of the RexxPackageEntry table for this library.  The package
entry table is a descriptor contained within the library.
Note that on Windows, it is necessary to explicitly export the
RexxPackageEntry() function when the library is linked.  This is the
only name you are required to export.  Calls are made to the library
routines and methods using addresses stored in the RexxPackageEntry table.</para>
<para>The RexxPackageEntry structure contains information about the
package and descriptors of any methods and/or routines defined within
the package.  The structure looks like this:</para>
<example>
<title>API &mdash; RexxPackageEntry</title>
<programlisting language="C++">
typedef struct _RexxPackageEntry
{
    int size;                      // size of the structure...helps compatibility
    int apiVersion;                // version this was compiled with
    int requiredVersion;           // minimum required interpreter version (0 means any)
    const char *packageName;       // package identifier
    const char  *packageVersion;   // package version #
    RexxPackageLoader loader;      // the package loader
    RexxPackageUnloader unloader;  // the package unloader
    struct _RexxRoutineEntry *routines; // routines contained in this package
    struct _RexxMethodEntry *methods;   // methods contained in this package
} RexxPackageEntry;
</programlisting>
</example>
<para>The fields in the RexxPackageEntry have the following functions:</para>
<variablelist>
<varlistentry><term><emphasis role="italic">size</emphasis>
and <emphasis role="italic">apiVersion</emphasis></term>
<listitem><para>these fields give the size of the received table and identify
the interpreter level this library has been compiled against.  These indicators
will allow additional information to be added to the RexxPackageEntry in the future without causing
compatibility issues for older libraries.  Normally, these two fields are defined using the
STANDARD_PACKAGE_HEADER macro, which sets both values.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="italic">requiredVersion</emphasis></term>
<listitem><para>a library can specify the minimum interpreter level it requires.
The interpreter will only load libraries that match the minimum compatibility
requirement of the library package.  A zero value in this field indicates there is no
minimum level requirement.  The macro REXX_CURRENT_INTERPRETER_VERSION will set
the level of interpreter you are compiling against.  If REXX_CURRENT_INTERPRETER_VERSION
is specified, then the library package will not load with older releases.  The
API header files will be updated with a macro for each interpreter version.  The
version macros are of the form
REXX_INTERPRETER_<emphasis role="italic">version</emphasis>_<emphasis role="italic">level</emphasis>_<emphasis role="italic">revision</emphasis>,
where <emphasis role="italic">version</emphasis>, <emphasis role="italic">level</emphasis>,
and <emphasis role="italic">revision</emphasis> refer to the corresponding values in an
interpreter release number.  For example, REXX_INTERPRETER_4_0_0 would indicate that the
4.0.0 interpreter level is the minimum this library requires.
</para></listitem></varlistentry>
<varlistentry><term>packageName</term>
<listitem><para>a descriptive name for this library package.
</para></listitem></varlistentry>
<varlistentry><term>packageVersion</term>
<listitem><para>a version string for this package.  The version can be
in whatever form is appropriate for the package.
</para></listitem></varlistentry>
<varlistentry><term>packageLoader</term>
<listitem><para>a function that will be called when the library package is
first loaded by the interpreter.  The package loader function is passed a
RexxThreadContext pointer, which will give the package access to Rexx
interpreter services at initialization time.  The package loader is optional
and is indicated by a NULL value in the descriptor.
</para></listitem></varlistentry>
<varlistentry><term>packageUnloader</term>
<listitem><para>a function that will be called when the library package is
unloaded by the interpreter.  The unloading process happens when the last
interpreter instance is destroyed during the last cleanup stages.  This gives
the loaded library an opportunity to clean up any global resources such as
cached Rexx object references.
The package loader is optional
and is indicated by a NULL value in the descriptor.
</para></listitem></varlistentry>
<varlistentry><term>routines</term>
<listitem><para>a pointer to an array of RexxRoutineEntry structures that define
the routines provided by this package.  If there are no routines, this field should be NULL.
See <xref linkend="functionapi" /> for details on
creating the exported routine table.
</para></listitem></varlistentry>
<varlistentry><term>method</term>
<listitem><para>a pointer to an array of RexxMethodEntry structures that define
the methods provided by this package.  If there are no methods, this field should be NULL.
See <xref linkend="methodapi" /> for details on
creating the exported method table.
</para></listitem></varlistentry>
</variablelist>
<para>Here is an example of a RexxPackageEntry table taken from the rxmath
library package:</para>
<example>
<title>API &mdash; RexxPackageEntry and RexxRoutineEntry</title>
<programlisting language="C++">
// now build the actual entry list
RexxRoutineEntry rxmath_functions[] =
{
    REXX_TYPED_ROUTINE(MathLoadFuncs, MathLoadFuncs),
    REXX_TYPED_ROUTINE(MathDropFuncs, MathDropFuncs),
    REXX_TYPED_ROUTINE(RxCalcPi,      RxCalcPi),
    REXX_TYPED_ROUTINE(RxCalcSqrt,    RxCalcSqrt),
    REXX_TYPED_ROUTINE(RxCalcExp,     RxCalcExp),
    REXX_TYPED_ROUTINE(RxCalcLog,     RxCalcLog),
    REXX_TYPED_ROUTINE(RxCalcLog10,   RxCalcLog10),
    REXX_TYPED_ROUTINE(RxCalcSinH,    RxCalcSinH),
    REXX_TYPED_ROUTINE(RxCalcCosH,    RxCalcCosH),
    REXX_TYPED_ROUTINE(RxCalcTanH,    RxCalcTanH),
    REXX_TYPED_ROUTINE(RxCalcPower,   RxCalcPower),
    REXX_TYPED_ROUTINE(RxCalcSin,     RxCalcSin),
    REXX_TYPED_ROUTINE(RxCalcCos,     RxCalcCos),
    REXX_TYPED_ROUTINE(RxCalcTan,     RxCalcTan),
    REXX_TYPED_ROUTINE(RxCalcCotan,   RxCalcCotan),
    REXX_TYPED_ROUTINE(RxCalcArcSin,  RxCalcArcSin),
    REXX_TYPED_ROUTINE(RxCalcArcCos,  RxCalcArcCos),
    REXX_TYPED_ROUTINE(RxCalcArcTan,  RxCalcArcTan),
    REXX_LAST_ROUTINE()
};

RexxPackageEntry rxmath_package_entry =
{
    STANDARD_PACKAGE_HEADER
    REXX_INTERPRETER_4_0_0,              // anything after 4.0.0 will work
    "RXMATH",                            // name of the package
    "4.0",                               // package information
    NULL,                                // no load/unload functions
    NULL,
    rxmath_functions,                    // the exported functions
    NULL                                 // no methods in rxmath.
};

// package loading stub.
OOREXX_GET_PACKAGE(rxmath);
</programlisting>
</example>
</section>

<section id="functionapi"><title>Defining Library Routines</title>
<para>The RexxRoutineEntry table defines routines that are exported by a library package.
This table is an array of RexxRoutineEntry structures, terminated by an entry that
contains nothing but zero values in the fields.  The REXX_LAST_ROUTINE() macro
will generate a suitable table terminator entry.
</para>
<para>The remainder of the table will be entries generated via either the
REXX_CLASSIC_ROUTINE() or REXX_TYPED_ROUTINE() macros.  REXX_CLASSIC_ROUTINE()
entries are for routines created using the older string-oriented function style.
The classic routines allow packages to be migrated to the new package loading system
without requiring a rewrite of all of the contained functions.
See <xref linkend="os2xfun" /> for details on
creating the functions in the classic style.</para>
<para>Routine table entries defined using REXX_TYPED_ROUTINE() use the new
object-oriented interfaces for creating routines.  These routines can use
the interpreter runtime to convert call arguments from Rexx objects into primitive
types and return values converted from primitive types back into Rexx objects.  These
routines are also given access to a rich set of services through the
<xref linkend="callcontext" xrefstyle="template:RexxCallContext" />
interface vector.</para>
<para>The REXX_CLASSIC_ROUTINE() and REXX_TYPED_ROUTINE() macros take two arguments.  The
first entry is the package table name for this routine.  The second argument is the
entry point name of the real native code routine that implements the function.
These names are frequently the same, but need not be.  The package table name is the
name this routine will be called with from Rexx code.
</para>
<para>Smaller function packages frequently place all of the contained functions
and the package definition tables in the same file, with the package tables
placed near the end of the source file so all of the functions are visible.  For
larger packages, it may be desirable to place the functions in more than
one source file.  For functions packaged as multiple source files, it is necessary
to create prototype declarations so the routine entry table can be generated.
The oorexxapi.h header file includes REXX_CLASSIC_ROUTINE_PROTOTYPE() and
REXX_TYPED_ROUTINE_PROTOTYPE() macros to generate the appropriate declarations.
For example,</para>
<example>
<title>API &mdash; REXX_TYPED_ROUTINE_PROTYPE</title>
<programlisting language="C++">
// create function declarations for the linker
REXX_TYPED_ROUTINE_PROTOTYPE(RxCalcPi);
REXX_TYPED_ROUTINE_PROTOTYPE(RxCalcSqrt);

// now build the actual entry list
RexxRoutineEntry rxmath_functions[] =
{
    REXX_TYPED_ROUTINE(RxCalcPi,      RxCalcPi),
    REXX_TYPED_ROUTINE(RxCalcSqrt,    RxCalcSqrt),
    REXX_LAST_ROUTINE()
};
</programlisting>
</example>

<section id="routinedcl"><title>Routine Declarations</title>
<para>Library routines are created using a series of macros that
create the body of the function.  These macros define the routine
arguments and return value in a form that allows the Rexx runtime
to perform argument checking and conversions before calling the
target routine.
These macros are named "RexxRoutine<emphasis role="italic">n</emphasis>, where
<emphasis role="italic">n</emphasis> is the number of arguments
passed to your routine.  For example,</para>
<example>
<title>API &mdash; RexxRoutine2</title>
<programlisting language="C++">
RexxRoutine2(int, beep, wholenumber_t, frequency, wholenumber_t, duration)
{
    return Beep(frequency, duration);  /* sound beep                 */
}
</programlisting>
</example>
<para>defines a <emphasis role="italic">beep</emphasis> routine that will be
passed two <emphasis role="italic">wholenumber_t</emphasis> arguments
(<emphasis role="italic">frequency</emphasis>
and <emphasis role="italic">duration</emphasis>).
The return value is an <emphasis role="italic">int</emphasis> value.
</para>
<para>An argument can be made optional by prefixing the type with "OPTIONAL_".  For example,</para>
<example>
<title>API &mdash; RexxRoutine2</title>
<programlisting language="C++">
RexxRoutine2(int, beep, wholenumber_t, frequency, OPTIONAL_wholenumber_t, duration)
{
    return Beep(frequency, duration);  /* sound beep                 */
}
</programlisting>
</example>
<para>would define a routine that takes two arguments.  The first argument is required, but the
second is optional.  Any optional arguments, when omitted on a call, will be passed using a zero
value appropriate to the type.  The macros argumentExists(n) or argumentOmitted(n) can reliably test if
an argument was passed.  For example, argumentExists(2) tests if the
<emphasis role="italic">duration</emphasis> argument was specified when beep() was called.
The <emphasis role="italic">n</emphasis> value is origin 1.</para>
<para>In addition to the arguments passed by the caller, there are some special argument types
that provide your routine with additional information.  These special types will add
additional arguments to your native routine implementation.
The argument value specified with argumentExists() or argumentOmitted() maps to the
arguments passed to your C++ routine rather than the arguments in the originating Rexx call.
See <xref linkend="routinetypes" /> for details on the special argument types.
</para>
<para>All routine declarations have an undeclared special argument passed to the routine.  This
special argument is named <emphasis role="italic">context</emphasis>.  The
<emphasis role="italic">context</emphasis> is a pointer to a RexxCallContext value and
provides access to all API functions valid from a routine context.</para>
<note><title>Note</title><para>
void is not a valid return type for a routine.  There must be a real return
type specified on the routine declaration.  If you wish to have a routine without
a return value, declare the routine with a return type of RexxObjectPtr and
return the value NULLOBJECT.  Routines that do not return a real value may not
be invoked as functions.  Only the CALL instruction allows a return without a
value.
</para></note>
</section>

<section id="routinetypes"><title>Routine Argument Types</title>
<para>A routine argument or return value may be a
numeric type (<xref linkend="numerictypes" />) or an
object type (<xref linkend="objecttypes" />).  For numeric types,
the call arguments must be convertible from a Rexx object equivalent into the
primitive value or an error will be raised.  For optional numeric arguments, a zero
value is passed for omitted values.  When used as a return type, the
numeric values are translated into an appropriate Rexx object value.
</para>
<para>If an argument is an object type, some additional validation is performed
on the arguments being passed.  If an argument does not meet the requirements for
a given object type, an error will be raised.  If an object-type argument is
optional and a value is not specified on the call, the value NULLOBJECT is
passed to your routine.
The supported object types and the special processing
rules are as follows:</para>
<variablelist>
<varlistentry><term>RexxObjectPtr</term>
<listitem><para>a reference to any Rexx object instance.  Any arbitrary object type may
be passed for a RexxObjectPtr argument.
</para></listitem></varlistentry>
<varlistentry><term>RexxStringObject</term>
<listitem><para>an instance of the Rexx String class.  The argument value must be
a Rexx String value or convertible to a Rexx String value using the request('String')
mechanism.
</para></listitem></varlistentry>
<varlistentry><term>RexxArrayObject</term>
<listitem><para>An instance of a Rexx &singledimarray;.
</para></listitem></varlistentry>
<varlistentry><term>RexxClassObject</term>
<listitem><para>An instance of Rexx Class class.
</para></listitem></varlistentry>
<varlistentry><term>RexxMutableBufferObject</term>
<listitem><para>An instance of Rexx MutableBuffer class.
</para></listitem></varlistentry>
<varlistentry><term>RexxStemObject</term>
<listitem><para>An instance of the Rexx Stem class.  For routine calls, a stem argument
may be specified either using the stem variable name directly or giving the stem
variable name as a quoted string.  For example, for a routine defined using</para>
<programlisting language="C++">
RexxRoutine1(int, MyRoutine, RexxStemObject, stem)
</programlisting>
<para>the following calls are equivalent:</para>
<programlisting>
x = MyRoutine(a.)
x = MyRoutine('a.')
</programlisting>
<para>This special processing allows routines that currently access
stem variables using the RexxVariablePool API to be more easily converted to the
newer API set.
</para></listitem></varlistentry>
</variablelist>
<para>In addition to the numeric and object types, there are additional special
types that provide additional information to the calling routine or perform common
special conversions on argument values.  The special types available to routines are:</para>
<variablelist>
<varlistentry><term>CSTRING</term>
<listitem><para>The argument is passed as an ASCII-Z string.  The source argument must be
one that is valid as a RexxStringObject value.  The RexxStringObject is converted into a
pointer to an ASCII-Z string.  This is equivalent to the value returned from the
<xref linkend="mthObjectToStringValue" xrefstyle="select:title"/> API
from a RexxStringObject value.  For an optional CSTRING argument, a NULL pointer
is provided when the argument is omitted.</para>
<para>When CSTRING is used as a return value, the ASCII-Z string value will be
converted into a Rexx String object.
The Rexx runtime does not free any
memory associated with a CSTRING return value, so care must be taken to avoid
memory leaks.  Also, locally declared character buffers cannot be returned as
the storage associated with buffer is no longer valid once your routine returns to
the Rexx interpreter.
CSTRING return values are best confined to
returning C literal values.
For example, the following is not valid:</para>
<example>
<title>API &mdash; CString</title>
<programlisting language="C++">
RexxRoutine0(CSTRING, MyRoutine)
{
   ....
   char buffer[32];
   sprintf(buffer, "%d:%d", major, minor);
   return buffer;     // buffer is not valid once return executes
}
</programlisting>
</example>
<para>A RexxStringObject return value and the
<xref linkend="mthString" xrefstyle="select:title"/> API is more appropriate in this
situation.</para>
<example>
<title>API &mdash; RexxStringObject</title>
<programlisting language="C++">
RexxRoutine0(RexxStringObject, MyRoutine)
{
   ....
   char buffer[32];
   sprintf(buffer, "%d:%d", major, minor);
   return context->String(buffer);     // creates a string object and returns it.
}
</programlisting>
</example>
</listitem></varlistentry>
<varlistentry><term>POINTER</term>
<listitem><para>an "unwrapped" Pointer or Buffer string object.  If the argument is a
Pointer object, the wrapped pointer value is returned as a void * value..  If the argument is a Buffer object,
then a pointer to the buffer's data area is returned.  A NULL pointer is returned for
an omitted OPTIONAL_POINTER argument.</para>
<para>When POINTER is used as a routine return value, any pointer value can be
returned.  The Rexx runtime will wrap the pointer value in a Rexx Pointer object.
</para></listitem></varlistentry>
<varlistentry><term>POINTERSTRING</term>
<listitem><para>a pointer value that has been encoded in string form.  The string value must
be in the format "0xnnnnnnnn", where the digits are valid hexadecimal digits.  On 64-bit platforms,
the pointer value must be 16 digits long.  The string value is converted into a void * value.
A NULL pointer is returned for
an omitted optional POINTERSTRING argument.</para>
<para>When POINTERSTRING is used as a routine return value, any pointer value can be
returned.  The Rexx runtime will convert the pointer value back into an encoded string value.
</para></listitem></varlistentry>
<varlistentry><term>NAME</term>
<listitem><para>The name of the invoked routine, passed as a CSTRING.  NAME is not valid as a
return value.
</para></listitem></varlistentry>
<varlistentry><term>ARGLIST</term>
<listitem><para>A RexxArrayObject containing all arguments passed to the routine.  This is
equivalent to using Arg(1, 'A') from Rexx code.  The returned array contains all of the routine
arguments that were specified in the original call.  Omitted arguments are empty slots in the
returned array.  In addition, if a routine has an ARGLIST argument specified, the normal
check for the maximum number of arguments is bypassed.  This makes possible routines with an
open-ended number of arguments.
ARGLIST is not valid as a return value.
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="methodapi"><title>Defining Library Methods</title>
<para>The RexxMethodEntry table defines method that are exported by a library package.
This table is an array of RexxMethodEntry structures, terminated by an entry that
contains nothing but zero values in the fields.  The REXX_LAST_METHOD() macro
will generate a suitable table terminator entry.
</para>
<para>The remainder of the table will be entries generated via
the REXX_METHOD() macro.
Routine table entries defined using REXX_METHOD() use the
object-oriented interfaces for creating methods that can be defined on Rexx classes.
These methods can use
the interpreter runtime to convert call arguments from Rexx objects into primitive
types and return values from primitive types back into Rexx objects.  Native
methods are also given access to a rich set of services via the RexxMethodContext
interface vector.</para>
<para>The REXX_METHOD() macro take two arguments.  The
first entry is the package table name for this method.  The second argument is the
entry point name of the real native code method that implements the function.
These names are frequently the same, but need not be.</para>
<para>Smaller function packages frequently place all of the contained functions
and the package definition tables in the same file, with the package tables
placed near the end of the source file so all of the methods are visible.  For
larger packages, it may be desirable to place the methods in more than
one source file.  For libraries packaged as multiple source files, it is necessary
to create a prototype declarations so the method entry table can be generated.
The oorexxapi.h header file includes
a REXX_METHOD_PROTOTYPE() macro to generate the appropriate declarations.
For example,</para>
<example>
<title>API &mdash; REXX_METHOD_PROTOTYPE</title>
<programlisting language="C++">
// create function declarations for the linker
REXX_METHOD_PROTOTYPE(point_init);
REXX_METHOD_PROTOTYPE(point_add);

// now build the actual entry list
RexxMethodEntry point_methods[] =
{
    REXX_METHOD(point_init, point_init),
    REXX_METHOD(point_add,  point_add),
    REXX_LAST_METHOD()
};
</programlisting>
</example>

<section id="methoddcl"><title>Method Declarations</title>
<para>Library methods are created using a series of macros that
create the body of the method.  These macros define the method
arguments and return value in a form that allows the Rexx runtime
to perform argument checking and conversions before calling the
target method.
These macros are named "RexxMethod<emphasis role="italic">n</emphasis>, where
<emphasis role="italic">n</emphasis> is the number of arguments you wish to
be passed to your method.  For example,</para>
<example>
<title>API &mdash; RexxMethod2</title>
<programlisting language="C++">
RexxMethod2(int, beep, wholenumber_t, frequency, wholenumber_t, duration)
{
    return Beep(frequency, duration);  /* sound beep                 */
}
</programlisting>
</example>
<para>defines a <emphasis role="italic">beep</emphasis> method that will be
passed two <emphasis role="italic">wholenumber_t</emphasis> arguments
(<emphasis role="italic">frequency</emphasis>
and <emphasis role="italic">duration</emphasis>).
The return value is an <emphasis role="italic">int</emphasis> value.
</para>
<para>An argument can be made optional by prefixing the type with "OPTIONAL_".  For example,</para>
<example>
<title>API &mdash; RexxMethod2</title>
<programlisting language="C++">
RexxMethod2(int, beep, wholenumber_t, frequency, OPTIONAL_wholenumber_t, duration)
{
    return Beep(frequency, duration);  /* sound beep                 */
}
</programlisting>
</example>
<para>would define a method that takes two arguments.  The first argument is required, but the
second is optional.  Any omitted optional arguments will be passed using a zero
value appropriate for the type.  The macros argumentExists(n) or argumentOmitted(n) can reliably test if
an argument was passed.  For example, argumentExists(2) tests if the
<emphasis role="italic">duration</emphasis> argument was specified when calling the beep() method.
The <emphasis role="italic">n</emphasis> value is origin 1.</para>
<para>In addition to the arguments passed by the caller, there are some special argument types
that provide your routine with additional information.  These special types will add
additional arguments to your native routine implementation.
The argument position specified with argumentExists() or argumentOmitted() maps to the
arguments passed to your C++ routine rather than the arguments in the originating Rexx call.
See below for details on the special argument types.
</para>
<para>All method declarations have an undeclared special argument passed to the routine.  This
special argument is named <emphasis role="italic">context</emphasis>.  The
<emphasis role="italic">context</emphasis> is a pointer to a
<xref linkend="methodcontext" xrefstyle="template:RexxMethodContext" /> value and
provides access to all APIs valid from a method context.</para>
<note><title>Note</title><para>
void is not a valid return type for a method.  There must be a real return
type specified on the method declaration.  If you wish to have a method without
a return value, declare the method with a return type of RexxObjectPtr and
return the value NULLOBJECT.  Methods that do not return a real value may not
be invoked within expressions, but may be used as standalone message instructions.
</para></note>
</section>

<section id="methodtypes"><title>Method Argument Types</title>
<para>A method argument or return value may be a
numeric type (<xref linkend="numerictypes" />) or an
object type (<xref linkend="objecttypes" />).  For numeric types,
the arguments must be convertible from a Rexx object equivalent into the
primitive value or an error will be raised.  For optional numeric arguments, a zero
value is passed for omitted values.  When used as a return type, the
numeric values are translated into an appropriate Rexx object value.
</para>
<para>If an argument is an object type, some additional validation is performed
on the arguments being passed.  If an argument does not meet the requirements for
a given object type, an error will be raised.  If an object-type argument is
optional and a value is not specified on the call, the value NULLOBJECT is
passed to your routine.
The supported object types and the special processing
rules are as follows:</para>
<variablelist>
<varlistentry><term>RexxObjectPtr</term>
<listitem><para>a reference to any Rexx object instance.  Any arbitrary object type may
be passed for a RexxObjectPtr argument.
</para></listitem></varlistentry>
<varlistentry><term>RexxStringObject</term>
<listitem><para>an instance of the Rexx String class.  The argument value must be
a Rexx String value or convertible to a Rexx String value using the request('String')
mechanism.
</para></listitem></varlistentry>
<varlistentry><term>RexxArrayObject</term>
<listitem><para>An instance of a Rexx &singledimarray;.
</para></listitem></varlistentry>
<varlistentry><term>RexxClassObject</term>
<listitem><para>An instance of Rexx Class class.
</para></listitem></varlistentry>
<varlistentry><term>RexxMutableBufferObject</term>
<listitem><para>An instance of Rexx MutableBuffer class.
</para></listitem></varlistentry>
<varlistentry><term>RexxStemObject</term>
<listitem><para>An instance of Rexx Stem class.  To pass a Stem to a method, a stem argument
must be specified using a stem variable name directly.
For example, for a method defined using</para>
<programlisting language="C++">
RexxMethod1(int, MyMethod, RexxStemObject, stem)
</programlisting>
<para>the following call passes a stem object associated with a stem variable to the method:</para>
<programlisting>
x = o~myMethod(a.)
</programlisting>
</listitem></varlistentry>
</variablelist>
<para>In addition to the numeric and object types, there are additional special
types that provide additional information to the calling routine or perform common
special conversions on argument values.  The special types available to routines are:</para>
<variablelist>
<varlistentry><term>CSTRING</term>
<listitem><para>The argument is passed as an ASCII-Z string.  The source argument must be
one that is valid as a RexxStringObject value.  The RexxStringObject is converted into a
 pointer to an ASCII-Z string.  This is equivalent to the value returned from the
<xref linkend="mthObjectToStringValue" xrefstyle="select:title"/> API
from a RexxStringObject value.  For an optional CSTRING argument, a NULL pointer
is provided when the argument is omitted.</para>
<para>When CSTRING is used as a return value, the ASCII-Z string value will be
converted into a Rexx String object.
CSTRING return values are best confined to
returning C literal values.
The Rexx runtime does not free any
memory associated with a CSTRING return value, so care must be taken to avoid
memory leaks.  Also, locally declared character buffers cannot be returned as
the storage associated with buffer is no longer valid once your method returns to
the Rexx interpreter.
CSTRING return values are best confined to
returning C literal values.
For example, the following is not valid:</para>
<example>
<title>API &mdash; CString</title>
<programlisting language="C++">
RexxMethod0(CSTRING, MyMethod)
{
   ....
   char buffer[32];
   sprintf(buffer, "%d:%d", major, minor);
   return buffer;     // buffer is not valid once return executes
}
</programlisting>
</example>
<para>A RexxStringObject return value and the
<xref linkend="mthString" xrefstyle="select:title"/> API is more appropriate in this
situation.</para>
<example>
<title>API &mdash; RexxStringObject</title>
<programlisting language="C++">
RexxMethod0(RexxStringObject, MyMethod)
{
   ....
   char buffer[32];
   sprintf(buffer, "%d:%d", major, minor);
   return context->String(buffer);     // creates a string object and returns it.
}
</programlisting>
</example>
</listitem></varlistentry>
<varlistentry><term>POINTER</term>
<listitem><para>an "unwrapped" Pointer or Buffer string object.  If the argument is a
Pointer object, the wrapped pointer value is returned as a void * value..  If the argument is a Buffer object,
then a pointer to buffer's storage area is returned.  A NULL pointer is returned for
an omitted optional POINTER argument.</para>
<para>When POINTER is used as a method return value, any pointer value can be
returned.  The Rexx runtime will wrap the pointer value in a Rexx Pointer object.
</para></listitem></varlistentry>
<varlistentry><term>POINTERSTRING</term>
<listitem><para>a pointer value that has been encoded in string form.  The string value must
be in the format "0xnnnnnnnn", where the digits are valid hexadecimal digits.  On 64-bit platforms,
the pointer value must be 16 digits long.  The string value is converted into a void * value.
A NULL pointer is returned for
an omitted optional POINTERSTRING argument.</para>
<para>When POINTERSTRING is used as a method return value, any pointer value can be
returned.  The Rexx runtime will convert the pointer value back into an encoded string value.
</para></listitem></varlistentry>
<varlistentry><term>NAME</term>
<listitem><para>The name of the invoked method, passed as a CSTRING.  This is the
message name that was used to invoke the method.
NAME is not valid as a
return value.
</para></listitem></varlistentry>
<varlistentry><term>ARGLIST</term>
<listitem><para>A RexxArrayObject containing all arguments passed to the method.  This is
equivalent to using Arg(1, 'A') from Rexx code.  The returned array contains all of the method
arguments that were specified in the original call.  Omitted arguments are empty slots in the
returned array.  In addition, if a method has an ARGLIST argument specified, the normal
check for the maximum number of arguments is bypassed.  This makes possible methods with an
open-ended number of arguments.
ARGLIST is not valid as a return value.
</para></listitem></varlistentry>
<varlistentry><term>OSELF</term>
<listitem><para>A RexxObjectPtr containing a reference to the object that was the message target for the current method.
This is equivalent to the SELF variable that is available in Rexx method code.  OSELF is not valid as a return value.
</para></listitem></varlistentry>
<varlistentry><term>SUPER</term>
<listitem><para>A RexxClassObject containing a reference to the super scope object for the current method.
This is equivalent to the SUPER variable that is set in Rexx method code.  SUPER is not valid as a return value.
</para></listitem></varlistentry>
<varlistentry><term>SCOPE</term>
<listitem><para>A RexxObjectPtr containing a reference to the current method's owning scope.  This
is normally the class that defined the method currently being executed.
SCOPE is not valid as a return value.
</para></listitem></varlistentry>
<varlistentry><term>CSELF</term>
<listitem><para>CSELF is a special argument type used for classes to store native pointers or structures inside an
object instance.  When a CSELF type is encountered, the runtime will search all of the object's variable
scopes for an instance variable named CSELF.  If a CSELF variable is located and the value is an instance
of either the Pointer or Buffer class, the POINTER value will be passed to the method as a void * value.
Objects that rely on CSELF values typically set the variable CSELF inside an init method for the object.  For
example:</para>
<example>
<title>API &mdash; CSELF</title>
<programlisting language="C++">
RexxMethod2(RexxObjectPtr, stream_init, OSELF, self, CSTRING, name)
{
    // create a new stream info member
    StreamInfo *stream_info = new StreamInfo(self, name);
    RexxPointerObject streamPtr = context->NewPointer(stream_info);
    context->SetObjectVariable("CSELF", streamPtr);

    return NULLOBJECT;
}
</programlisting>
</example>

<para>
Then, within other methods for the object, when the CSELF variable is used as an argument to the method, the void *
is retrieved and cast to the correct type:
</para>

<example>
<title>API &mdash; CSELF</title>
<programlisting language="C++">
RexxMethod3(size_t, stream_charout, CSELF, streamPtr, OPTIONAL_RexxStringObject, data, OPTIONAL_int64_t, position)
{
    StreamInfo *stream_info = (StreamInfo *)streamPtr;
    stream_info->setContext(context, context->False());

    ...
}
</programlisting>
</example>
<para>CSELF is not valid as a return value.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="cselfetal"><title>Pointer, Buffer, and CSELF</title>
<para>Methods written in C++ frequently need to acquire access to data that is associated
with an object instance.  ooRexx provides two classes, Buffer and Pointer, that allow
these associations to be made.  Both classes are real Rexx classes that can be passed
as arguments, returned as method results, and assigned to object instance variables.  For
the Rexx programmer who might encounter one of these instances, these are opaque objects that
don't appear to be of much use.  To the native library writer, the usefulness derives from
what is stored inside these objects.</para>
<section id="clsBuffer"><title>The Buffer class</title>
<para>The Buffer class allows the library writer to allocate blocks of memory from the
Rexx object space.  The memory is a part of the Buffer object instance, and will be reclaimed
automatically when the Buffer object is garbage collected.  This means the programmer does not
need to explicitly release a Buffer object.  It does, however,
require that steps be taken to protect the Buffer object from garbage collection while it is
still needed.  The usual protection mechanism is to store the buffer object in an object
instance variable using <xref linkend="mthSetObjectVariable" xrefstyle="select:title"/>.  Once
assigned to a variable, the Buffer is protected from garbage collection until its associated
object instance is also reclaimed.  The buffer is part of the internal state of the
the object.</para>
<para>Buffer objects are allocated using the <xref linkend="mthNewBuffer" xrefstyle="select:title"/> function that's part
of the RexxThreadContext interface.  Once created, you can access the Buffer's data area using
<xref linkend="mthBufferData" xrefstyle="select:title"/>, which returns a pointer to the beginning of the
data buffer.  The data buffer area is writeable storage, into which any data may be placed.  This
is frequently used to allocate a C++ struct or class instance that is the native embodiment of the
class implementation.  For example</para>
<example>
<title>API &mdash; RexxBufferObject</title>
<programlisting language="C++">
<![CDATA[
RexxMethod0(RexxObjectPtr, myclass_init)
{
    // create a buffer for my internal data.
    RexxBufferObject data = context->NewBuffer(sizeof(MyDataClass));
    // store this someplace safe
    context->SetObjectVariable("MYDATA", data);
    // get access to the data area
    void *dataPtr = context->BufferData(data);
    // construct a C++ object to place in the buffer
    MyDataClass *myData = new (dataPtr) MyDataClass();
    // initialize the data below
    ...

    return NULLOBJECT;
}
]]>
</programlisting>
</example>
<para>This example allocates a Buffer object instance, creates a C++ class in its data area, and
stores a reference to the Buffer in the MYDATA object variable.  Other C++ methods can access
this instance by using the C++ equivalent to the Rexx EXPOSE instruction.</para>
<example>
<title>API &mdash; RexxBufferObject</title>
<programlisting language="C++">
<![CDATA[
RexxMethod0(RexxObjectPtr, myclass_dosomething)
{
    // retrieve my instance buffer
    RexxBufferObject data = (RexxBufferObject)context->GetObjectVariable("MYDATA");
    // Get the data pointer and cast it back to my class type
    MyDataClass *myData = (MyDataClass *)context->BufferData(data);
    // perform the operation below
    ...
}
]]>
</programlisting>
</example>
<para>Since Buffer object instances are reclaimed automatically when the object
is garbage collected, no additional steps are required to cleanup that memory.
However, if there are additional dymanically allocated resources associated with
the Buffer, such as pointers to system allocated resources or dynamically allocated
memory, it may be necessary to add an UNINIT method to your class to ensure the
resources are not leaked.</para>
<example>
<title>API &mdash; RexxBufferObject</title>
<programlisting language="C++">
<![CDATA[
RexxMethod0(RexxObjectPtr, myclass_uninit)
{
    // retrieve my instance buffer
    RexxBufferObject data = context->GetObjectVariable("MYDATA");
    // Get the data pointer and cast it back to my class type
    MyDataClass *myData = (MyDataClass *)context->BufferData(data);
    // delete any resources I've obtained (but not the MyDataClass
    // instance itself
    delete ((void *)myData) myData;
}
]]>
</programlisting>
</example>
</section>
<section id="clsPointer"><title>The Pointer class</title>
<para>The Pointer class has uses similar to the Buffer class, but Pointer instances
only hold a single pointer value to native C/C++ resources.  A Pointer instance is
effectively a Buffer object where the buffer data area is a single void * pointer.
Like Buffer objects, Pointers can be stored in Rexx variables and retrieved in
native methods.  Pointer object instances are garbage collected just like Buffer
objects, but when a Pointer is reclaimed, whatever value referenced by the
Pointer instance are not cleaned up.  If additional cleanup is required, then
it will be necessary to implement an UNINIT method to handle the cleanup.  Here
are the Buffer examples above reworked for the Pointer class:</para>
<example>
<title>API &mdash; RexxObjectPtr</title>
<programlisting language="C++">
<![CDATA[
RexxMethod0(RexxObjectPtr, myclass_init)
{
    // construct a C++ object to associate with the object
    MyDataClass *myData = new MyDataClass();
    // create a Pointer to store this in the object
    RexxPointerObject data = context->NewPointer(myData);
    // store this someplace safe
    context->SetObjectVariable("MYDATA", data);
    // initialize the data below
    ...

    return NULLOBJECT;
}


RexxMethod0(RexxObjectPtr, myclass_dosomething)
{
    // retrieve my instance data
    RexxPointerObject data = (RexxPointerObject)context->GetObjectVariable("MYDATA");
    // Get the data pointer and cast it back to my class type
    MyDataClass *myData = (MyDataClass *)context->PointerValue(data);
    // perform the operation below
    ...
}


RexxMethod0(RexxObjectPtr, myclass_uninit)
{
    // retrieve my instance data
    RexxPointerObject data = (RexxPointerObject)context->GetObjectVariable("MYDATA");
    // Get the data pointer and cast it back to my class type
    MyDataClass *myData = (MyDataClass *)context->PointerValue(data);
    // delete the backing instance
    delete myData;
}
]]>
</programlisting>
</example>
</section>
<section id="clsPointerType"><title>The POINTER method type</title>
<para>The Rexx runtime has some special support for Pointer and Buffer objects
when they are passed as method arguments and also when used as return values.  The
RexxMethod macros used to define method instances support the POINTER special argument
type.  When an argument is defined as a POINTER, then the argument value must be either
a Buffer object or a Pointer object.  The Rexx runtime will automatically pass this
argument to the native method as the Buffer BufferData() value or the Pointer PointerValue()
value, thus removing the need to unwrapper these in the method code.  The POINTER type
is generally used for private methods of a class where the Rexx versions of the methods
pass Pointer or Buffer references to the private native code.  For example, the Rexx
code might look like this:</para>
<example>
<title>API &mdash; RexxObjectPtr</title>
<programlisting>
::method setTitle
  expose title prefix handle
  use arg title
  // set the title to the title concatenated to the prefix
  self~privateSetTitle(handle, prefix title)

::method privateSetTitle PRIVATE EXTERNAL "LIBRARY mygui setTitle"
</programlisting>
</example>
<para>The corresponding C++ method would look like this:</para>
<example>
<title>API &mdash; RexxObjectPtr</title>
<programlisting language="C++">
<![CDATA[
RexxMethod2(RexxObjectPtr, setTitle, POINTER, handle, CSTRING, title)
{
    // the pointer object was unwrapped for me
    MyWindowHandle *myHandle = (MyWindowHandle *)handle;

    // other stuff here
}
]]>
</programlisting>
</example>
<para>When POINTER is used as a method return type, the runtime will automatically
create a Pointer object instance that wrappers the returned void *value.  The created
Pointer instance is the result returned to the Rexx code.</para>
</section>
<section id="cself"><title>The CSELF method type</title>
<para>There's one additional concept using Pointer and Buffer objects supported by the
C++ APIs.  When a method definition specifies the special type CSELF, the runtime will
look for an object variable named CSELF.  If the variable is found, and if the variable
is assigned to an instance of Pointer or Buffer, then the corresponding data pointer
is returned as the argument.  The CSELF type is most useful when just a single anchor to
native C++ data is backing an object instance and the backing data is created in the
object INIT method.  Here's the Pointer example above reworked to use CSELF:</para>
<example>
<title>API &mdash; CSELF</title>
<programlisting language="C++">
<![CDATA[
RexxMethod0(RexxObjectPtr, myclass_init)
{
    // construct a C++ object to associate with the object
    MyDataClass *myData = new MyDataClass();
    // create a Pointer to store this in the object
    RexxPointerObject data = context->NewPointer(myData);
    // assign this to the special CSELF variable
    context->SetObjectVariable("CSELF", data);
    // initialize the data below
    ...

    return NULLOBJECT;
}


RexxMethod1(RexxObjectPtr, myclass_dosomething, CSELF, cself)
{
    // We can just cast this to our data value
    MyDataClass *myData = (MyDataClass *)cself;
    // perform the operation below
    ...
}


RexxMethod1(RexxObjectPtr, myclass_uninit, CSELF, cself)
{
    // We can just cast this to our data value
    MyDataClass *myData = (MyDataClass *)cself;
    // delete the backing instance
    delete myData;
}
]]>
</programlisting>
</example>
<para>Using the CSELF argument type eliminates the need to directly
access the Rexx variable used to anchor the value in every method except
the INIT method.  This produces generally smaller, more reliable code,
since the runtime is managing the retrieval.</para>
<para>There are other advantages to using the CSELF convention.
The example above is equivalent to the examples using Pointer and Buffer
objects.  If, however, you were to create a subclass of the Buffer example and
try to access the value stored in MYDATA from a subclass method, you'll find that
GetObjectVariable("MYDATA") will return NULLOBJECT.
The <xref linkend="mthGetObjectVariable" xrefstyle="select:title"/> method
retrieves variables from the current method's variable scope.  Since the INIT method
that set MYDATA originally and the subclass method that wishes to access the data
are defined at different class scopes, GetObjectVariable() will access different variable
pools and MYDATA will not be found.  One solution would be to create a private
attribute method in the base class:</para>
<programlisting>
::attribute mydata get private
</programlisting>
<para>The subclass method can then access the method using
<xref linkend="mthSendMessage0" xrefstyle="select:title"/>
to access the value.</para>
<programlisting language="C++">
RexxObjectPtr self = context->GetSelf()
RexxPointerObject = context->SendMessage0(self, "MYDATA");
</programlisting>
<para>The CSELF type handles this detail automatically.  When used as an argument,
all variable scopes of the object's class hiearchy are searched for a variable named CSELF.
if one is located, it will be used for the value passed to the method.  This allows all subclasses
of a class using the CSELF convention to access the backing native data.
</para>
<para>Frequently, one class instance might need access to the native information associated with another
object instance.  The other object instance might be of the same class or another class that is designed
to interoperate with the current class.  The <xref linkend="mthObjectToCSelf" xrefstyle="select:title"/> allows
the CSELF information for an object other than the current active object to be retrieved.</para>
</section>
</section>
</section>

<section id="exitsapi"><title>Rexx Exits Interface</title>
<indexterm><primary>exits</primary></indexterm>
<indexterm><primary>application programming interfaces</primary>
<secondary>exit interface</secondary></indexterm>
<indexterm><primary>application programming interfaces</primary>
<secondary>exit handler</secondary></indexterm>
<para>The Rexx system exits let the programmer create a customized Rexx operating
environment. You can set up user-defined exit handlers to process specific
Rexx activities.</para>
<para>Applications can create exits for:</para>
<itemizedlist>
<listitem><para>The administration of resources at the beginning and the end
of interpretation</para></listitem>
<listitem><para>Linkages to external functions and subcommand handlers</para></listitem>
<listitem><para>Special language features; for example, input and output to
standard resources</para></listitem>
<listitem><para>Polling for halt and external trace events</para></listitem>
</itemizedlist>
<para>Direct exit handlers are specified when the interpreter instance is created, and
reside as entry points within the application that creates the interpreter instance.
</para>

<section id="writedirexithandler"><title>Writing Context Exit Handlers</title>
<indexterm><primary>RexxContextExitHandler interface</primary>
<secondary>definition</secondary></indexterm>
<para>The following is a sample exit handler
declaration: </para>
<example>
<title>API &mdash; Rexx_IO_Exit</title>
<programlisting language="C++">
<![CDATA[
int REXXENTRY Rexx_IO_exit(
     RexxExitContext *context,   // the exit context API vector
     int   exitNumber,           // code defining the exit function
     int   subfunction,          // code defining the exit subfunction
     PEXIT parmBlock);           // function-dependent control block
]]>
</programlisting>
</example>
<para>where:</para>
<variablelist>
<varlistentry><term>context</term>
<listitem><para>is the RexxExitContext vector that provides access to interpreter services
for this exit handler.
</para></listitem></varlistentry>
<varlistentry><term>exitNumber</term>
<listitem><para>is the major function code defining the type of exit call.
</para></listitem></varlistentry>
<varlistentry><term>subfunction</term>
<listitem><para>is the subfunction code defining the exit event for the call.
</para></listitem></varlistentry>
<varlistentry><term>parmBlock</term>
<listitem><para>is a pointer to the exit parameter list. </para>
<para>The exit parameter list
contains exit-specific information. See the exit descriptions following the
parameter list formats. </para>

<note>
<para>Some exit subfunctions do not have
parameters. <emphasis role="italic">parmBlock</emphasis> is set to NULL for exit subfunctions without
parameters.</para></note>
</listitem></varlistentry>
</variablelist>

<section id="ooexitrc"><title>Exit Return Codes</title>
<para>Exit handlers return an integer value that signals one of the following
actions:</para>
<variablelist>
<varlistentry><term>RXEXIT_HANDLED</term>
<listitem><para>The exit handler processed the exit subfunction and updated the subfunction
parameter list as required. The Rexx interpreter continues with processing
as usual.
</para></listitem></varlistentry>
<varlistentry><term>RXEXIT_NOT_HANDLED</term>
<listitem><para>The exit handler did not process the exit subfunction. The Rexx interpreter
processes the subfunction as if the exit handler were not called.
</para></listitem></varlistentry>
<varlistentry><term>RXEXIT_RAISE_ERROR</term>
<listitem><para>A fatal error occurred in the exit handler. The Rexx interpreter raises
Rexx error 48 (&quot;Failure in system service&quot;).  Other errors can be
raised using the <xref linkend="mthRaiseException" xrefstyle="select:title"/> API provided
by the exit context.
</para></listitem></varlistentry>
</variablelist>
<para>For example, if an application creates an input/output exit handler, one
of the following happens: </para>
<itemizedlist>
<listitem><para>When the exit handler returns RXEXIT_NOT_HANDLED for an RXSIOSAY
subfunction, the Rexx interpreter writes the output line to STDOUT.</para></listitem>
<listitem><para>When the exit handler returns RXEXIT_HANDLED for an RXSIOSAY subfunction,
the Rexx interpreter assumes the exit handler has handled all required output.
The interpreter does not write the output line to STDOUT.</para></listitem>
<listitem><para>When the exit handler returns RXEXIT_RAISE_ERROR for an RXSIOSAY
subfunction, the interpreter raises Rexx error 48, &quot;Failure in system
service&quot;.</para></listitem>
</itemizedlist>
</section>

<section id="ooexitparm"><title>Exit Parameters</title>
<para>Each exit subfunction has a different parameter list. All RXSTRING exit
subfunction parameters are passed as null-terminated strings. The terminating
null is not included in the length stored in the RXSTRING structures.
The string values pointed to by the RXSTRING structs
may also contain null characters.</para>
<para>For some exit subfunctions, the exit handler can return an RXSTRING
character result in the parameter list. The interpreter provides a default 256-byte
RXSTRING for the result string. If the result is longer than 256 bytes,
a new RXSTRING can be allocated using
<computeroutput>RexxAllocateMemory(size)</computeroutput>. The Rexx interpreter
will release the allocated storage after the exit handler returns.</para>
</section>

<section id="ooidentifyexithandl"><title>Identifying Exit Handlers to Rexx</title>
<para>System exit handlers are specified using the DIRECT_EXITS option when
the interpreter instance is created.
The exits are specified using a RexxContextExit structure identifying which
exits will be enabled.
</para>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RexxContextExit data structure</secondary></indexterm>

</section>
</section>

<section id="contextexitdef"><title>Context Exit Definitions</title>
<para>The Rexx interpreter supports the following system exits: </para>
<variablelist>
<varlistentry><term>RXFNC
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXFNC exit</secondary></indexterm>
</term>
<listitem><para>External function call exit.
<variablelist>
<varlistentry><term>RXFNCCAL</term>
<listitem><para>Call an external function.  This exit is
called at the beginning of the search for external functions, allowing
external functions calls to be intercepted.
The RXFNCCAL converts all function arguments to RXSTRING values and
can only return RXSTRING values as a function result.  For full object access,
the RXOFNC exit is also provided.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXOFNC
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXOFNC exit</secondary></indexterm>
</term>
<listitem><para>Object oriented external function call exit.
<variablelist>
<varlistentry><term>RXOFNCCAL</term>
<listitem><para>Call an external function.  This exit is
called at the beginning of the search for external functions, allowing
external functions calls to be intercepted.  This is an extended version of
the RXFNC exit that passes arguments as object references and allows object return
values.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXEXF
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXEXF exit</secondary></indexterm>
</term>
<listitem><para>Scripting external function call exit.
<variablelist>
<varlistentry><term>RXEXFCAL</term>
<listitem><para>Call an external function.  This exit is
called at the end of the search for external functions if no suitable call target
has been found.  This allows applications to extend the external function search order.
Like the RXOFNC exit, the RXEXF exit will pass function arguments and return values
as Rexx objects.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXCMD
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXCMD exit</secondary></indexterm>
</term>
<listitem><para>Subcommand call exit.
<variablelist>
<varlistentry><term>RXCMDHST</term>
<listitem><para>Call a subcommand handler.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXMSQ
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXMSQ exit</secondary></indexterm>
</term>
<listitem><para>External data queue exit.
<variablelist>
<varlistentry><term>RXMSQPLL</term>
<listitem><para>Pull a line from the external data queue.
</para></listitem></varlistentry>
<varlistentry><term>RXMSQPSH</term>
<listitem><para>Place a line in the external data queue.
</para></listitem></varlistentry>
<varlistentry><term>RXMSQSIZ</term>
<listitem><para>Return the number of lines in the external data queue.
</para></listitem></varlistentry>
<varlistentry><term>RXMSQNAM</term>
<listitem><para>Set the active external data queue name.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXSIO
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXSIO exit</secondary></indexterm>
</term>
<listitem><para>Standard input and output exit.
<variablelist>
<varlistentry><term>RXSIOSAY</term>
<listitem><para>Write a line to the standard output stream for the SAY instruction.
</para></listitem></varlistentry>
<varlistentry><term>RXSIOTRC</term>
<listitem><para>Write a line to the standard error stream for the Rexx trace or Rexx
error messages.
</para></listitem></varlistentry>
<varlistentry><term>RXSIOTRD</term>
<listitem><para>Read a line from the standard input stream for PULL or PARSE PULL.
</para></listitem></varlistentry>
<varlistentry><term>RXSIODTR</term>
<listitem><para>Read a line from the standard input stream for interactive debugging.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXNOVAL
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXNOVAL exit</secondary></indexterm>
</term>
<listitem><para>NOVALUE exit.
<variablelist>
<varlistentry><term>RXNOVALCALL</term>
<listitem><para>Process a variable NOVALUE condition.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXVALUE
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXVALUE exit</secondary></indexterm>
</term>
<listitem><para>VALUE built-in function extension.
<variablelist>
<varlistentry><term>RXVALUECALL</term>
<listitem><para>Process a VALUE() built-in function call for an unknown named environment.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXHLT
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXHLT exit</secondary></indexterm>
</term>
<listitem><para>Halt processing exit.
<variablelist>
<varlistentry><term>RXHLTTST</term>
<listitem><para>Test for a HALT condition.
</para></listitem></varlistentry>
<varlistentry><term>RXHLTCLR</term>
<listitem><para>Clear a HALT condition.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXTRC
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXTRC exit</secondary></indexterm>
</term>
<listitem><para>External trace exit.
<variablelist>
<varlistentry><term>RXTRCTST</term>
<listitem><para>Test for an external trace event.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXINI
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXINI exit</secondary></indexterm>
</term>
<listitem><para>Initialization exit.
<variablelist>
<varlistentry><term>RXINIEXT</term>
<listitem><para>Allow additional Rexx procedure initialization.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXTER
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXTER exit</secondary></indexterm>
</term>
<listitem><para>Termination exit.
<variablelist>
<varlistentry><term>RXTEREXT</term>
<listitem><para>Process Rexx procedure termination.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
<para>The following sections describe each exit subfunction, including: </para>
<itemizedlist>
<listitem><para>The service the subfunction provides</para></listitem>
<listitem><para>When Rexx calls the exit handler</para></listitem>
<listitem><para>The default action when the exit is not provided or the exit handler does
not process the subfunction</para></listitem>
<listitem><para>The exit action</para></listitem>
<listitem><para>The subfunction parameter list</para></listitem>
</itemizedlist>

<section id="oorxofnch"><title>RXOFNC</title>
<indexterm><primary>external function exit</primary></indexterm>
<indexterm><primary>RXOFNC exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXOFNC exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>external function exit</secondary></indexterm>
<para>Processes calls to external functions.</para>
<para></para>
<variablelist>
<varlistentry><term>RXOFNCCAL</term>
<listitem><para>Processes calls to external functions.</para>
<itemizedlist>
<listitem><para>When called: At beginning of the search for an external routine or
function.</para></listitem>
<listitem><para>Default action: Call the external routine using
the usual external function search order.</para></listitem>
<listitem><para>Exit action: Call the external routine, if possible.</para></listitem>
<listitem><para>Continuation: If necessary, raise Rexx error 40
(&quot;Incorrect call to routine&quot;), 43 (&quot;Routine not found&quot;),
or 44 (&quot;Function or message did not return data&quot;).</para></listitem>
<listitem><para>Parameter list: </para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[

typedef  struct _RXOFNC_FLAGS {        /* fl */
   unsigned rxfferr  : 1;              /* Invalid call to routine.   */
   unsigned rxffnfnd : 1;              /* Function not found.        */
   unsigned rxffsub  : 1;              /* Called as a subroutine     */
}  RXOFNC_FLAGS ;

typedef  struct _RXOFNCCAL_PARM {      /* fnc */
   RXOFNC_FLAGS      rxfnc_flags ;     /* function flags             */
   CONSTRXSTRING     rxfnc_name;       // the called function name
   size_t            rxfnc_argc;       /* Number of args in list.    */
   RexxObjectPtr    *rxfnc_argv;       /* Pointer to argument list.  */
   RexxObjectPtr     rxfnc_retc;       /* Return value.              */
}  RXOFNCCAL_PARM;
]]>
</programlisting>
</example>
<para>The name of the external function is defined
by the <emphasis role="italic">rxfnc_name</emphasis> CONSTRXSTRING (<xref linkend="rxstrings" />) value.
The arguments to the
function are in <emphasis role="italic">rxfnc_argv</emphasis> array and
<emphasis role="italic">rxfnc_argc</emphasis> gives the number of arguments.
If you
call the named external function with the Rexx CALL instruction (rather than
using a function call), the flag <emphasis role="italic">rxffsub</emphasis>
is TRUE.</para>
<para>The exit
handler can set <emphasis role="italic">rxfnc_flags</emphasis>
to indicate whether the external function
call was successful. If neither <emphasis role="italic">rxfferr</emphasis> nor
<emphasis role="italic">rxffnfnd</emphasis> is
TRUE, the exit handler successfully called the external function. The error
flags are checked only when the exit handler handles the request.</para>
<para>The exit handler sets <emphasis role="italic">rxffnfnd</emphasis>
to TRUE when the exit handler cannot locate
the external function. The interpreter raises Rexx error 43, &quot;Routine not
found&quot;. The exit handler sets <emphasis role="italic">rxfferr</emphasis>
to TRUE when the exit handler
locates the external function, but the external function returned an error
return code. The Rexx interpreter raises error 40,
&quot;Incorrect call to routine.&quot;</para>
<para>The exit handler returns the external function result in the
<emphasis role="italic">rxfnc_retc</emphasis> RexxObjectPtr.
The Rexx interpreter raises error 44, &quot;Function
or method did not return data,&quot; when the external routine is called as
a function and the exit handler does not return a result. When the external
routine is called with the Rexx CALL instruction, a result is not
required.
</para></listitem></itemizedlist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="oorxexfh"><title>RXEXF</title>
<indexterm><primary>scripting function exit</primary></indexterm>
<indexterm><primary>RXEXF exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXEXF exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>scripting function exit</secondary></indexterm>
<para>Processes calls to external functions.</para>
<para></para>
<variablelist>
<varlistentry><term>RXEXFCAL</term>
<listitem><para>Processes calls to external functions.</para>
<itemizedlist>
<listitem><para>When called: At end of the search for an external routine or
function when no suitable call target has been located.</para></listitem>
<listitem><para>Default action: Raise error 43 (&quot;Routine not found&quot;).
</para></listitem>
<listitem><para>Exit action: Call the external routine, if possible.</para></listitem>
<listitem><para>Continuation: If necessary, raise Rexx error 40
(&quot;Incorrect call to routine&quot;), 43 (&quot;Routine not found&quot;),
or 44 (&quot;Function or message did not return data&quot;).</para></listitem>
<listitem><para>Parameter list: </para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[

typedef  struct _RXEXF_FLAGS {         /* fl */
   unsigned rxfferr  : 1;              /* Invalid call to routine.   */
   unsigned rxffnfnd : 1;              /* Function not found.        */
   unsigned rxffsub  : 1;              /* Called as a subroutine     */
}  RXEXF_FLAGS ;

typedef  struct _RXEXFCAL_PARM {       /* fnc */
   RXEXF_FLAGS       rxfnc_flags ;     /* function flags             */
   CONSTRXSTRING     rxfnc_name;       // the called function name
   size_t            rxfnc_argc;       /* Number of args in list.    */
   RexxObjectPtr    *rxfnc_argv;       /* Pointer to argument list.  */
   RexxObjectPtr     rxfnc_retc;       /* Return value.              */
}  RXEXFCAL_PARM;
]]>
</programlisting>
</example>
<para>The name of the external function is defined by the <emphasis role="italic">rxfnc_name</emphasis>
CONSTRXSTRING value.
The arguments to the
function are in <emphasis role="italic">rxfnc_argv</emphasis> array and
<emphasis role="italic">rxfnc_argc</emphasis> gives the number of arguments.
If you
call the named external function with the Rexx CALL instruction (rather than
using a function call), the flag <emphasis role="italic">rxffsub</emphasis>
is TRUE.</para>
<para>The exit
handler can set <emphasis role="italic">rxfnc_flags</emphasis>
to indicate whether the external function
call was successful. If neither <emphasis role="italic">rxfferr</emphasis> nor
<emphasis role="italic">rxffnfnd</emphasis> is
TRUE, the exit handler successfully called the external function. The error
flags are checked only when the exit handler handles the request.</para>
<para>The exit handler sets <emphasis role="italic">rxffnfnd</emphasis>
to TRUE when the exit handler cannot locate
the external function. The interpreter raises Rexx error 43, &quot;Routine not
found&quot;. The exit handler sets <emphasis role="italic">rxfferr</emphasis>
to TRUE when the exit handler
locates the external function, but the external function returned an error
return code. The Rexx interpreter raises error 40,
&quot;Incorrect call to routine.&quot;</para>
<para>The exit handler returns the external function result in the
<emphasis role="italic">rxfnc_retc</emphasis> RexxObjectPtr. The Rexx interpreter raises error 44,
&quot;Function or method did not return data,&quot; when the external routine is called as a function and
the exit handler does not return a result. When the external routine is called with the Rexx CALL
instruction, a result is not required.
</para></listitem></itemizedlist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="oorxfnch"><title>RXFNC</title>
<indexterm><primary>external function exit</primary></indexterm>
<indexterm><primary>RXFNC exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXFNC exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>external function exit</secondary></indexterm>
<para>Processes calls to external functions.</para>
<para></para>
<variablelist>
<varlistentry><term>RXFNCCAL</term>
<listitem><para>Processes calls to external functions.</para>
<itemizedlist>
<listitem><para>When called: At beginning of the search for an external routine or
function.</para></listitem>
<listitem><para>Default action: Call the external routine using
the usual external function search order.</para></listitem>
<listitem><para>Exit action: Call the external routine, if possible.</para></listitem>
<listitem><para>Continuation: If necessary, raise Rexx error 40
(&quot;Incorrect call to routine&quot;), 43 (&quot;Routine not found&quot;),
or 44 (&quot;Function or message did not return data&quot;).</para></listitem>
<listitem><para>Parameter list: </para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   struct {
      unsigned rxfferr  : 1;           /* Invalid call to routine.    */
      unsigned rxffnfnd : 1;           /* Function not found.         */
      unsigned rxffsub  : 1;           /* Called as a subroutine if   */
                                       /* TRUE.  Return values are    */
                                       /* optional for subroutines,   */
                                       /* required for functions.     */
   } rxfnc_flags ;

   const char *      rxfnc_name;       /* Pointer to function name.   */
   unsigned short    rxfnc_namel;      /* Length of function name.    */
   const char *      rxfnc_que;        /* Current queue name.         */
   unsigned short    rxfnc_quel;       /* Length of queue name.       */
   unsigned short    rxfnc_argc;       /* Number of args in list.     */
   PCONSTRXSTRING    rxfnc_argv;       /* Pointer to argument list.   */
                                       /* List mimics argv list for   */
                                       /* function calls, an array of */
                                       /* RXSTRINGs.                  */
   RXSTRING          rxfnc_retc;       /* Return value.               */
} RXFNCCAL_PARM;
]]>
</programlisting>
</example>
<para>The name of the external function is defined
by <emphasis role="italic">rxfnc_name</emphasis> and
<emphasis role="italic">rxfnc_namel</emphasis>. The arguments to the
function are in <emphasis role="italic">rxfnc_argc</emphasis> and
<emphasis role="italic">rxfnc_argv</emphasis>. If you
call the named external function with the Rexx CALL instruction (rather than
using a function call), the flag <emphasis role="italic">rxffsub</emphasis>
is TRUE.</para>
<para>The exit
handler can set <emphasis role="italic">rxfnc_flags</emphasis>
to indicate whether the external function
call was successful. If neither <emphasis role="italic">rxfferr</emphasis> nor
<emphasis role="italic">rxffnfnd</emphasis> is
TRUE, the exit handler successfully called the external function. The error
flags are checked only when the exit handler handles the request.</para>
<para>The exit handler sets <emphasis role="italic">rxffnfnd</emphasis>
to TRUE when the exit handler cannot locate
the external function. The interpreter raises Rexx error 43, &quot;Routine not
found&quot;. The exit handler sets <emphasis role="italic">rxfferr</emphasis>
to TRUE when the exit handler
locates the external function, but the external function returned an error
return code. The Rexx interpreter raises error 40,
&quot;Incorrect call to routine.&quot;</para>
<para>The exit handler returns the external function result in the
<emphasis role="italic">rxfnc_retc</emphasis> RXSTRING.
The Rexx interpreter raises error 44, &quot;Function
or method did not return data,&quot; when the external routine is called as
a function and the exit handler does not return a result. When the external
routine is called with the Rexx CALL instruction, a result is not
required.</para>
<para>The RXFNC translates all call arguments to string values and only allows a
string value as a return value.  To access call arguments as Rexx objects, use
the RXOFNC exit.
</para></listitem></itemizedlist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="oorxcmdh"><title>RXCMD</title>
<indexterm><primary>external command exit</primary></indexterm>
<indexterm><primary>host command exit</primary></indexterm>
<indexterm><primary>RXCMD exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXCMD exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>host command exit</secondary></indexterm>
<para>Processes calls to subcommand handlers. </para>
<para></para>
<variablelist>
<varlistentry><term>RXCMDHST</term>
<listitem><para>Calls a named subcommand handler.</para>
<itemizedlist>
<listitem><para>When called: When Rexx procedure issues a command.</para></listitem>
<listitem><para>Default action: Call the named subcommand handler
specified by the current Rexx ADDRESS setting.</para></listitem>
<listitem><para>Exit action: Process the call to a named subcommand
handler.</para></listitem>
<listitem><para>Continuation: Raise the ERROR or FAILURE condition
when indicated by the parameter list flags.</para></listitem>
<listitem><para>Parameter list: </para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   struct {                            /* Condition flags             */
      unsigned rxfcfail : 1;           /* Command failed.  Trap with  */
                                       /* CALL or SIGNAL on FAILURE.  */
      unsigned rxfcerr  : 1;           /* Command ERROR occurred.     */
                                       /* Trap with CALL or SIGNAL on */
                                       /* ERROR.                      */
   } rxcmd_flags;
   const char *      rxcmd_address;    /* Pointer to address name.    */
   unsigned short    rxcmd_addressl;   /* Length of address name.     */
   const char *      rxcmd_dll;        /* dll name for command.       */
   unsigned short    rxcmd_dll_len;    /* Length of dll name.  0 ==>  */
                                       /* executable file.            */
   CONSTRXSTRING     rxcmd_command;    /* The command string.         */
   RXSTRING          rxcmd_retc;       /* Pointer to return code      */
                                       /* buffer.  User allocated.    */
} RXCMDHST_PARM;
]]>
</programlisting>
</example>
<para>The <emphasis role="italic">rxcmd_command</emphasis> field contains
the issued command. <emphasis role="italic">Rxcmd_address</emphasis>,
<emphasis role="italic">rxcmd_addressl</emphasis>,
<emphasis role="italic">rxcmd_dll</emphasis>, and
<emphasis role="italic">rxcmd_dll_len</emphasis> fully define the current
ADDRESS setting. <emphasis role="italic">Rxcmd_retc</emphasis> is an RXSTRING
for the return code value assigned to Rexx special variable RC.</para>
<para>The exit handler can set <emphasis role="italic">rxfcfail</emphasis>
or <emphasis role="italic">rxfcerr</emphasis>
to TRUE to raise an ERROR or FAILURE condition.</para></listitem>
</itemizedlist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="oorxmsqh"><title>RXMSQ</title>
<indexterm><primary>external queue exit</primary></indexterm>
<indexterm><primary>queue exit</primary></indexterm>
<indexterm><primary>RXMSQ exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXMSQ exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>queue exit</secondary></indexterm>
<para>External data queue exit. </para>
<variablelist>
<varlistentry><term>RXMSQPLL</term>
<listitem><para>Pulls a line from the external data queue. </para>
<itemizedlist>
<listitem><para>When called: When a Rexx PULL instruction, PARSE
PULL instruction, or LINEIN built-in function reads a line from the external
data queue.</para></listitem>
<listitem><para>Default action: Remove a line from the current Rexx
data queue.</para></listitem>
<listitem><para>Exit action: Return a line from the data queue that
the exit handler provided.</para></listitem>
<listitem><para>Parameter list: </para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   RXSTRING          rxmsq_retc;       /* Pointer to dequeued entry   */
                                       /* buffer.  User allocated.    */
} RXMSQPLL_PARM;
]]>
</programlisting>
</example>
<para>The exit handler returns the queue line in
the <emphasis role="italic">rxmsq_retc</emphasis> RXSTRING.</para>
</listitem></itemizedlist>
</listitem></varlistentry>
<varlistentry><term>RXMSQPSH</term>
<listitem><para>Places a line in the external data queue. </para>
<itemizedlist>
<listitem><para>When called: When a Rexx PUSH instruction, QUEUE
instruction, or LINEOUT built-in function adds a line to
the data queue.</para></listitem>
<listitem><para>Default action: Add the line to the current Rexx
data queue.</para></listitem>
<listitem><para>Exit action: Add the line to the data queue that
the exit handler provided.</para></listitem>
<listitem><para>Parameter list: </para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   struct {                            /* Operation flag              */
      unsigned rxfmlifo : 1;           /* Stack entry LIFO when TRUE, */
                                       /* FIFO when FALSE.            */
   } rxmsq_flags;
   CONSTRXSTRING     rxmsq_value;      /* The entry to be pushed.     */
} RXMSQPSH_PARM;
]]>
</programlisting>
</example>
<para>The <emphasis role="italic">rxmsq_value</emphasis> RXSTRING contains
the line added to the queue. It is the responsibility of the exit handler
to truncate the string if the exit handler data queue has a maximum length
restriction. <emphasis role="italic">Rxfmlifo</emphasis>
is the stacking order (LIFO or FIFO).</para></listitem></itemizedlist>
</listitem></varlistentry>
<varlistentry><term>RXMSQSIZ</term>
<listitem><para>Returns the number of lines in the external data queue.</para>
<itemizedlist>
<listitem><para>When called: When the Rexx QUEUED built-in function
requests the size of the external data queue.</para></listitem>
<listitem><para>Default action: Request the size of the current
Rexx data queue.</para></listitem>
<listitem><para>Exit action: Return the size of the data queue that
the exit handler provided.</para></listitem>
<listitem><para>Parameter list: </para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   size_t            rxmsq_size;       /* Number of Lines in Queue    */
} RXMSQSIZ_PARM;
]]>
</programlisting>
</example>
<para>The exit handler returns the number of queue
lines in <emphasis role="italic">rxmsq_size</emphasis>.</para>
</listitem></itemizedlist>
</listitem></varlistentry>
<varlistentry><term>RXMSQNAM</term>
<listitem><para>Sets the name of the active external data queue.
<itemizedlist>
<listitem><para>When called: Called by
the RXQUEUE("SET", <emphasis role="italic">newname</emphasis>)
 built-in function.</para></listitem>
<listitem><para>Default action: Change the current default queue
to <emphasis role="italic">newname</emphasis>.</para></listitem>
<listitem><para>Exit action: Change the default queue name for the
data queue that the exit handler provided.</para></listitem>
<listitem><para>Parameter list:</para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   RXSTRING     rxmsq_name;       /* RXSTRING containing         */
                                  /* queue name.                 */
} RXMSQNAM_PARM;
]]>
</programlisting>
</example>
<para><emphasis role="italic">rxmsq_name</emphasis> contains the new queue
name.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="oorxsioh"><title>RXSIO</title>
<indexterm><primary>external I/O exit</primary></indexterm>
<indexterm><primary>session I/O exit</primary></indexterm>
<indexterm><primary>RXSIO exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXSIO exit</secondary></indexterm>
<para>Standard input and output. </para>
<note>
<para>The PARSE LINEIN instruction
and the LINEIN, LINEOUT, LINES, CHARIN, CHAROUT, and CHARS built-in functions
do not call the RXSIO exit handler.</para></note>
<para></para>
<variablelist>
<varlistentry><term>RXSIOSAY</term>
<listitem><para>Writes a line to the standard output stream. </para>
<itemizedlist>
<listitem><para>When called: When the SAY instruction writes a line
to the standard output stream.</para></listitem>
<listitem><para>Default action: Write a line to the standard output
stream (STDOUT).</para></listitem>
<listitem><para>Exit action: Write a line to the output stream that
the exit handler provided.</para></listitem>
<listitem><para>Parameter list:</para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   CONSTRXSTRING      rxsio_string;     /* String to display.          */
} RXSIOSAY_PARM;
]]>
</programlisting>
</example>
<para>The output line is contained in
<emphasis role="italic">rxsio_string</emphasis>. The output line can be of any
length. It is the responsibility of the
exit handler to truncate or split the line if necessary.</para></listitem>
</itemizedlist>
</listitem></varlistentry>
<varlistentry><term>RXSIOTRC</term>
<listitem><para>Writes trace and error message output to the standard error
stream.
<itemizedlist>
<listitem><para>When called: To output lines of trace output and
Rexx error messages.</para></listitem>
<listitem><para>Default action: Write a line to the standard error
stream (.ERROR).</para></listitem>
<listitem><para>Exit action: Write a line to the error output stream
that the exit handler provided.</para></listitem>
<listitem><para>Parameter list:</para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   CONSTRXSTRING       rxsio_string;     /* Trace line to display.      */
} RXSIOTRC_PARM;
]]>
</programlisting>
</example>
<para>The output line is contained in
<emphasis role="italic">rxsio_string</emphasis>. The output line can be of any
length. It is the responsibility of the
exit handler to truncate or split the line if necessary.</para></listitem>
</itemizedlist>
</para></listitem></varlistentry>
<varlistentry><term>RXSIOTRD</term>
<listitem><para>Reads from standard input stream.
<itemizedlist>
<listitem><para>When called: To read from the standard input stream
for the Rexx PULL and PARSE PULL instructions.</para></listitem>
<listitem><para>Default action: Read a line from the standard input
stream (STDIN).</para></listitem>
<listitem><para>Exit action: Return a line from the standard input
stream that the exit handler provided.</para></listitem>
<listitem><para>Parameter list:</para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   RXSTRING          rxsiotrd_retc;    /* RXSTRING for input.         */
} RXSIOTRD_PARM;
]]>
</programlisting>
</example>
<para>The input stream line is returned in the
<emphasis role="italic">rxsiotrd_retc</emphasis> RXSTRING.</para>
</listitem></itemizedlist>
</para></listitem></varlistentry>
<varlistentry><term>RXSIODTR</term>
<listitem><para>Interactive debug input.
<itemizedlist>
<listitem><para>When called: To read from the debug input stream
for interactive debug prompts.</para></listitem>
<listitem><para>Default action: Read a line from the standard input
stream (STDIN).</para></listitem>
<listitem><para>Exit action: Return a line from the standard debug
stream that the exit handler provided.</para></listitem>
<listitem><para>Parameter list: </para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   RXSTRING          rxsiodtr_retc;    /* RXSTRING for input.         */
} RXSIODTR_PARM;
]]>
</programlisting>
</example>
<para>The input stream line is returned in the
<emphasis role="italic">rxsiodtr_retc</emphasis> RXSTRING.</para>
</listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="oorxnoval"><title>RXNOVAL</title>
<indexterm><primary>NOVALUE exit</primary></indexterm>
<indexterm><primary>RXNOVAL exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXNOVAL exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>NOVALUE exit</secondary></indexterm>
<para>Processes NOVALUE variable conditions. </para>
<para></para>
<variablelist>
<varlistentry><term>RXNOVALCALL</term>
<listitem><para>Processes a Rexx NOVALUE condition.</para>
<itemizedlist>
<listitem><para>When called: Before the interpreter raises a NOVALUE condition.
The exit is given the opportunity to provide a value to the unassigned variable.</para></listitem>
<listitem><para>Default action: Raise a NOVALUE condition for an unassigned variable. </para></listitem>
<listitem><para>Exit action: Return an initial value for an unassigned variable.
</para></listitem>
<listitem><para>Continuation: If the exit provides a value for the unassigned variable,
that value is assigned to the indicated variable.  The exit will not be called for the
same variable on the next reference unless the variable is dropped.  If a value is not
returned, a NOVALUE condition will be raised.  If SIGNAL ON NOVALUE is not enabled,
the variable name will be returned as the value.
</para></listitem>
<listitem><para>Parameter list:</para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[

typedef  struct _RXVARNOVALUE_PARM {   /* var */
   RexxStringObject  variable_name;    // the request variable name
   RexxObjectPtr     value;            // returned variable value
}  RXVARNOVALUE_PARM;
]]>
</programlisting>
</example>
</listitem>
</itemizedlist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="oorxvalue"><title>RXVALUE</title>
<indexterm><primary>VALUE exit</primary></indexterm>
<indexterm><primary>RXVALUE exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXVALUE exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>NOVALUE exit</secondary></indexterm>
<para>Extends the environments available to the VALUE() built-in function.</para>
<para></para>
<variablelist>
<varlistentry><term>RXVALUECALL</term>
<listitem><para>Processes an extended call to the VALUE() built-in function.</para>
<itemizedlist>
<listitem><para>When called: When the VALUE() built-in function is called with an unknown
environment name.
The exit is given the opportunity to provide a value for the given environment selector.</para></listitem>
<listitem><para>Default action: Raise a SYNTAX error for an unknown environment name. </para></listitem>
<listitem><para>Exit action: Return a value for the given name/environment pair.
</para></listitem>
<listitem><para>Continuation: If the exit provides a value for the VALUE() call, that value is
returned as a result.
.</para></listitem>
<listitem><para>Parameter list:</para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[

typedef  struct _RXVALCALL_PARM {      /* val */
   RexxStringObject  selector;         // the environment selector name
   RexxStringObject  variable_name;    // the request variable name
   RexxObjectPtr     value;            // returned variable value
}  RXVALCALL_PARM;
]]>
</programlisting>
</example>
<para>
If the newValue argument is specified on the VALUE() built-in function, that value
is assigned to <emphasis role="italic">value</emphasis> on the call to the exit.
</para>
</listitem>
</itemizedlist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="oohltcon"><title>RXHLT</title>
<indexterm><primary>external HALT exit</primary></indexterm>
<indexterm><primary>RXHLT exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXHLT exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>external HALT exit</secondary></indexterm>
<para>HALT condition processing. </para>
<para>Because the RXHLT exit handler
is called after every Rexx instruction, enabling this exit slows Rexx program
execution. The RexxSetHalt() function can halt a Rexx program without
between-instruction polling.</para>
<variablelist>
<varlistentry><term>RXHLTTST</term>
<listitem><para>Tests the HALT indicator.
<itemizedlist>
<listitem><para>When called: When the interpreter polls externally
raises HALT conditions. The exit will be called after completion of every
Rexx instruction.</para></listitem>
<listitem><para>Default action: The interpreter uses the system
facilities for trapping Cntrl-Break signals.</para></listitem>
<listitem><para>Exit action: Return the current state of the HALT
condition (either TRUE or FALSE).</para></listitem>
<listitem><para>Continuation: Raise the Rexx HALT condition if the
exit handler returns TRUE.</para></listitem>
<listitem><para>Parameter list:</para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   struct {                            /* Halt flag                   */
      unsigned rxfhhalt : 1;           /* Set if HALT occurred.       */
   } rxhlt_flags;
} RXHLTTST_PARM;
]]>
</programlisting>
</example>
<para>If the exit handler sets <emphasis role="italic">rxfhhalt</emphasis> to
TRUE, the HALT condition is raised in the Rexx program.</para>
<para>The Rexx program can retrieve the reason string using the CONDITION("D")
built-in function.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
<varlistentry><term>RXHLTCLR</term>
<listitem><para>Clears the HALT condition.
<itemizedlist>
<listitem><para>When called: When the interpreter has recognized
and raised a HALT condition, to acknowledge processing of the HALT condition.</para></listitem>
<listitem><para>Default action: The interpreter resets the Cntrl-Break
signal handlers.</para></listitem>
<listitem><para>Exit action: Reset exit handler HALT state to FALSE.</para></listitem>
<listitem><para>Parameters: None.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="oorxtrch"><title>RXTRC</title>
<indexterm><primary>external trace exit</primary></indexterm>
<indexterm><primary>RXTRC exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXTRC exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>tracing exit</secondary></indexterm>
<para>Tests the external trace indicator. </para>
<note>
<para>Because the RXTRC exit
is called after every Rexx instruction, enabling this exit slows Rexx procedure
execution. The <xref linkend="mthSetThreadTrace" xrefstyle="select:title"/>
method can turn on Rexx tracing without the
between-instruction polling.</para></note>
<para></para>
<variablelist>
<varlistentry><term>RXTRCTST</term>
<listitem><para>Tests the external trace indicator.
<itemizedlist>
<listitem><para>When called: When the interpreter polls for an external
trace event. The exit is called after completion of every Rexx instruction.</para></listitem>
<listitem><para>Default action: None.</para></listitem>
<listitem><para>Exit action: Return the current state of external
tracing (either TRUE or FALSE).</para></listitem>
<listitem><para>Continuation: When the exit handler switches from
FALSE to TRUE, the Rexx interpreter enters the interactive Rexx debug mode
using TRACE ?R level of tracing. When the exit handler switches from TRUE
to FALSE, the Rexx interpreter exits the interactive debug mode.</para></listitem>
<listitem><para>Parameter list:</para>
<example>
<title>API &mdash; Rexx_IO_Exit parameter list</title>
<programlisting language="C++">
<![CDATA[
typedef struct {
   struct {
      unsigned rxftrace : 1;        /* External trace setting        */
   } rxtrc_flags;
} RXTRCTST_PARM;
]]>
</programlisting>
</example>
<para>If the exit handler switches <emphasis role="italic">rxftrace</emphasis>
to TRUE, Rexx switches on the interactive debug mode. If the exit handler
switches <emphasis role="italic">rxftrace</emphasis> to FALSE, Rexx switches
off the interactive debug mode.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="oorxinih"><title>RXINI</title>
<indexterm><primary>RXINI exit</primary></indexterm>
<indexterm><primary>initialization exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXINI exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>initialization exit</secondary></indexterm>
<para>Initialization processing. This exit is called as the last step of Rexx
program initialization. </para>
<variablelist>
<varlistentry><term>RXINIEXT</term>
<listitem><para>Initialization exit.
<itemizedlist>
<listitem><para>When called: Before the first instruction of the
Rexx procedure is interpreted.</para></listitem>
<listitem><para>Default action: None.</para></listitem>
<listitem><para>Exit action: The exit handler can perform additional
initialization. For example:
<itemizedlist>
<listitem><para>Use <xref linkend="mthSetContextVariable" xrefstyle="select:title"/>
API to initialize application-specific
variables.</para></listitem>
<listitem><para>Use <xref linkend="mthSetThreadTrace" xrefstyle="select:title"/> API
to switch on the interactive Rexx debug mode.
</para></listitem>
</itemizedlist>
</para></listitem>
<listitem><para>Parameters: None.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="oorxterh"><title>RXTER</title>
<indexterm><primary>RXTER exit</primary></indexterm>
<indexterm><primary>termination exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXTER exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>termination exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>exit functions</secondary></indexterm>
<para>Termination processing.</para>
<para>The RXTER exit is called as the first step of Rexx program termination.</para>
<variablelist>
<varlistentry><term>RXTEREXT</term>
<listitem><para>Termination exit.
<itemizedlist>
<listitem><para>When called: After the last instruction of the Rexx
procedure has been interpreted.</para></listitem>
<listitem><para>Default action: None.</para></listitem>
<listitem><para>Exit action: The exit handler can perform additional
termination activities. For example, the exit handler can use
<xref linkend="mthSetContextVariable" xrefstyle="select:title"/>
to retrieve the Rexx variable values.</para></listitem>
<listitem><para>Parameters: None.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>
</section>

<section id="commandapi"><title>Command Handler Interface</title>
<para>Applications can create custom command handlers that function like operating system command shell environments.
These named evironments can be invoked with the Rexx ADDRESS instruction and applications can create
Rexx instances that direct commands to custom application command handlers by default.
</para>
<para>There are two types of command handlers: in addition to standard
&quot;direct&quot; command handlers, &quot;redirecting&quot; command handlers
offer optional redirection of STDIN from Rexx objects and redirection
of STDOUT and STDERR to Rexx objects.
Redirection is requested by using the WITH subkeyword of the ADDRESS instruction.
</para>
<para>Command handlers can be registered by using interpreter instance options
<xref linkend="instanceoptionDirect" xrefstyle="select:title"/> or
<xref linkend="instanceoptionRedirecting" xrefstyle="select:title"/>
when the interpreter instance is created, or through the
<xref linkend="mthAddCommandEnvironment" xrefstyle="select:title"/> API.
</para>
<para>The command handlers are registered as a function pointer to a handler routine.
When a Rexx program issues a command to the named ADDRESS target, the handler is
called with the evaluated command string and the name of the address environment.
The handler is responsible for executing the command, returning a
return code value back to the Rexx program, and, if requested, providing
redirected input to the command and capturing command output.
</para>
<para>Handlers are called using two different function signatures, the first
for direct handlers, and the second signature for redirecting command handlers:
</para>
<programlisting language="C++">
RexxObjectPtr RexxEntry DirectCommandHandler(RexxExitContext *context,
     RexxStringObject address, RexxStringObject command)

RexxObjectPtr RexxEntry RedirectingCommandHandler(RexxExitContext *context,
     RexxStringObject address, RexxStringObject command, RexxIORedirectorContext *ioContext)
</programlisting>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1">
    <tgroup cols="2">
    <colspec colnum="1" colwidth="1*" />
    <colspec colnum="2" colwidth="5*" />
    <tbody>
    <row><entry><emphasis role="italic">context</emphasis></entry>
    <entry><para>A <xref linkend="exitcontext" xrefstyle="template:RexxExitContext" /> interface vector for the handler call.
    The RexxExitContext provides access to runtime services appropriate to a command handler.  For example, the
    exit context can set or get Rexx variables, invoke methods on objects, and raise ERROR or FAILURE conditions.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">address</emphasis></entry>
    <entry><para>A String object containing the target command environment name.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">command</emphasis></entry>
    <entry><para>A String object containing the issued command string.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">ioContext</emphasis></entry>
    <entry><para>(For redirecting command handlers only.)
    A <xref linkend="redirectorcontext" xrefstyle="template:RexxIORedirectorContext" />
    interface vector that provides access to redirection API methods
    <xref linkend="mthAreOutputAndErrorSameTarget" xrefstyle="select:title"/>,
    <xref linkend="mthIsErrorRedirected" xrefstyle="select:title"/>,
    <xref linkend="mthIsInputRedirected" xrefstyle="select:title"/>,
    <xref linkend="mthIsOutputRedirected" xrefstyle="select:title"/>,
    <xref linkend="mthIsRedirectionRequested" xrefstyle="select:title"/>,
    <xref linkend="mthReadInput" xrefstyle="select:title"/>,
    <xref linkend="mthReadInputBuffer" xrefstyle="select:title"/>,
    <xref linkend="mthWriteError" xrefstyle="select:title"/>,
    <xref linkend="mthWriteErrorBuffer" xrefstyle="select:title"/>,
    <xref linkend="mthWriteOutput" xrefstyle="select:title"/>, and
    <xref linkend="mthWriteOutputBuffer" xrefstyle="select:title"/>.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Any object that should be used as the command return code.  This value will be assigned to the
variable RC upon return.  If NULLOBJECT is returned, a 0 is used as the return code.  The return
code value is traditionally a numeric value, but any value can be returned, including more complex object
return values, if desired.
</para>
<para>For normal commands, the command is processed and a return code is given back to the Rexx program.
The interpreter recognizes two different abnormal return states for commands, ERROR and FAILURE.
An ERROR condition indicates there was some sort of error return state involved with executing a command.
These could be command syntax errors, semantic errors, etc.  FAILURE conditions are more serious conditions.
One traditional FAILURE condition is the unknown command error.</para>
<para>Command handlers raise ERROR and FAILURE conditions using the
<xref linkend="mthRaiseCondition" xrefstyle="select:title"/> API provided by the RexxExitContext.  For
example:</para>
<example>
<title>API &mdash; Command handler interface</title>
<programlisting language="C++">
<![CDATA[
// if this was an unknown command, give our generic unknown command return code
if (errorStatus == COMMAND_FAILURE) {
    // Note:  The return code needs to be included with the FAILURE condition
    context->RaiseCondition("FAILURE", command, NULLOBJECT, context->WholeNumber(-1));
    // just return null...the RC value is picked up from the condition.
    return NULLOBJECT;
}
else if (errorStatus == COMMAND_ERROR) {
    // Note:  The return code needs to be included with the ERROR condition
    context->RaiseCondition("ERROR", command, NULLOBJECT, context->WholeNumber(rc));
    // just return null...the RC value is picked up from the condition.
    return NULLOBJECT;
}
// return the RC value for the command, which need not be 0
return context->WholeNumber(rc);
]]>
</programlisting>
</example>
</section>

<section id="apilisting"><title>Rexx Interface Methods Listing</title>

<para>This section describes each available method and its associated context.</para>

<section id="mthAddCommandEnvironment"><title>&added50;AddCommandEnvironment</title>
<indexterm><primary>AddCommandEnvironment</primary></indexterm>
<indexterm><primary>Rexx instance context methods</primary>
<secondary>AddCommandEnvironment</secondary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>AddCommandEnvironment</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>AddCommandEnvironment</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>AddCommandEnvironment</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>AddCommandEnvironment</secondary></indexterm>
<!-- AddCommandEnvironment --><para>&contexts_instance_thread_method_call_exit; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING name;
REXXPFN handler;
size_t type;

// Method Syntax Form(s)

context->AddCommandEnvironment(name, handler, type);
]]>
</programlisting>

<para>Adds a <xref linkend="commandapi" xrefstyle="template:command handler "/>
to the Rexx interpreter instance.
If a command handler with the specified <emphasis role="italic">name</emphasis>
already exists, it is overwritten.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The ASCII-Z name of the command handler's environment name.</para></entry>
    </row>
    <row><entry><emphasis role="italic">handler</emphasis></entry>
    <entry><para>The address of the subcommand handler entry point within the application
    executable code.
    For a description of the required handler function signature see
    <xref linkend="commandapi" xrefstyle="select:title"/>.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">type</emphasis></entry>
    <entry><para>The type of command handler to add.
      DIRECT_COMMAND_ENVIRONMENT for a command handler with no support for redirection.
      REDIRECTING_COMMAND_ENVIRONMENT for a command handler that supports redirection.
      </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.
</para>
</section>

<section id="mthAllocateObjectMemory"><title>&added50;AllocateObjectMemory</title>
<indexterm><primary>AllocateObjectMemory</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>AllocateObjectMemory</secondary></indexterm>
<!-- AllocateObjectMemory --><para>&contexts_method; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
size_t bytes;
POINTER ptr;

// Method Syntax Form(s)

ptr = context->AllocateObjectMemory(bytes);
]]>
</programlisting>

<para>Allocates object memory similar to malloc(), where the allocated
memory is garbage-collected together with the object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">bytes</emphasis></entry>
    <entry><para>The number of bytes of memory to allocate.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A POINTER to the allocated object memory.
</para>
<para>See also methods
<xref linkend="mthReallocateObjectMemory" xrefstyle="select:title"/> and
<xref linkend="mthFreeObjectMemory" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthAreOutputAndErrorSameTarget"><title>&added50;AreOutputAndErrorSameTarget</title>
<indexterm><primary>AreOutputAndErrorSameTarget</primary></indexterm>
<indexterm><primary>I/O Redirector context methods</primary>
<secondary>AreOutputAndErrorSameTarget</secondary></indexterm>
<!-- AreOutputAndErrorSameTarget --><para>&contexts_ioredirector; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
logical_t flag;

// Method Syntax Form(s)

flag = context->AreOutputAndErrorSameTarget();
]]>
</programlisting>
<para>Tests whether for the current command the output object and the
error object specified by the WITH subkeyword of an ADDRESS instruction
are the same objects.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para><literal>1</literal> if the output and the error object are te same,
<literal>0</literal> otherwise.
</para>
<para>See also methods
<xref linkend="mthIsErrorRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsInputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsOutputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsRedirectionRequested" xrefstyle="select:title"/>,
<xref linkend="mthReadInput" xrefstyle="select:title"/>,
<xref linkend="mthReadInputBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteError" xrefstyle="select:title"/>,
<xref linkend="mthWriteErrorBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteOutput" xrefstyle="select:title"/>, and
<xref linkend="mthWriteOutputBuffer" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthArray"><title>Array</title>
<indexterm><primary>Array</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Array</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>Array</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Array</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Array</secondary></indexterm>
<!-- Array --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj1, obj2, obj3, obj4;

// Method Syntax Form(s)

arr = context->Array(obj1);

arr = context->Array(obj1, obj2);

arr = context->Array(obj1, obj2, obj3);

arr = context->Array(obj1, obj2, obj3, obj4);
]]>
</programlisting>
<para>This method has four forms.
It creates a new &singledimarray; with the specified objects.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj1</emphasis></entry>
    <entry><para>The first object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj2</emphasis></entry>
    <entry><para>The second object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj3</emphasis></entry>
    <entry><para>The third object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj4</emphasis></entry>
    <entry><para>The fourth object to be added.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Array object.</para>
</section>

<section id="mthArrayAppend"><title>ArrayAppend</title>
<indexterm><primary>ArrayAppend</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayAppend</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ArrayAppend</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayAppend</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayAppend</secondary></indexterm>
<!-- ArrayAppend --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj;
size_t n;

// Method Syntax Form(s)

n = context->ArrayAppend(arr, obj);
]]>
</programlisting>
<para>Append an Object to the end of an Array.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The target Array object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be appended.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The index of the appended object.</para>
</section>

<section id="mthArrayAppendString"><title>ArrayAppendString</title>
<indexterm><primary>ArrayAppendString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayAppendString</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ArrayAppendString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayAppendString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayAppendString</secondary></indexterm>
<!-- ArrayAppendString --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxArrayObject arr;
CSTRING str;
size_t n, len;

// Method Syntax Form(s)

n = context->ArrayAppendString(arr, str, len);
]]>
</programlisting>
<para>Append an object to the end of an Array.  The appended object is
a String object created from a pointer and length.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The target Array object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>A pointer to the string data to be appended.</para></entry>
    </row>
    <row><entry><emphasis role="italic">len</emphasis></entry>
    <entry><para>The length of the string value in characters.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Array index of the appended object.</para>
</section>

<section id="mthArrayAt"><title>ArrayAt</title>
<indexterm><primary>ArrayAt</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayAt</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ArrayAt</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayAt</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayAt</secondary></indexterm>
<!-- ArrayAt --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj;
size_t idx;

// Method Syntax Form(s)

obj = context->ArrayAt(arr, idx);
]]>
</programlisting>
<para>Retrieve an object from a specified Array index.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The source Array object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">idx</emphasis></entry>
    <entry><para>The index of the required object.  This argument is 1-based.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object at the specified index.
Returns NULLOBJECT if there is no value at the specified index.</para>
</section>

<section id="mthArrayDimension"><title>ArrayDimension</title>
<indexterm><primary>ArrayDimension</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayDimension</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ArrayDimension</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayDimension</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayDimension</secondary></indexterm>
<!-- ArrayDimension --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxArrayObject arr;
size_t sz;

// Method Syntax Form(s)

sz = context->ArrayDimension(arr);
]]>
</programlisting>
<para>Returns number of dimensions of an Array.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The target Array object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The number of Array dimensions.</para>
</section>

<section id="mthArrayItems"><title>ArrayItems</title>
<indexterm><primary>ArrayItems</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayItems</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ArrayItems</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayItems</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayItems</secondary></indexterm>
<!-- ArrayItems --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxArrayObject arr;
size_t sz;

// Method Syntax Form(s)

sz = context->ArrayItems(arr);
]]>
</programlisting>
<para>Returns number of elements in an Array.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The source Array object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The number of Array elements.</para>
</section>

<section id="mthArrayOfFour"><title>ArrayOfFour</title>
<indexterm><primary>ArrayOfFour</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayOfFour</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ArrayOfFour</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayOfFour</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayOfFour</secondary></indexterm>
<!-- ArrayOfFour --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj1, obj2, obj3, obj4;

// Method Syntax Form(s)

arr = context->ArrayOfFour(obj1, obj2, obj3, obj4);
]]>
</programlisting>
<para>Create a new &singledimarray; with the specified objects.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj1</emphasis></entry>
    <entry><para>The first object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj2</emphasis></entry>
    <entry><para>The second object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj3</emphasis></entry>
    <entry><para>The third object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj4</emphasis></entry>
    <entry><para>The fourth object to be added.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Array object.</para>
</section>

<section id="mthArrayOfOne"><title>ArrayOfOne</title>
<indexterm><primary>ArrayOfOne</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayOfOne</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ArrayOfOne</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayOfOne</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayOfOne</secondary></indexterm>
<!-- ArrayOfOne --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj;

// Method Syntax Form(s)

arr = context->ArrayOfOne(obj);
]]>
</programlisting>
<para>Create a new &singledimarray; with the specified object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be added.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Array object.</para>
</section>

<section id="mthArrayOfThree"><title>ArrayOfThree</title>
<indexterm><primary>ArrayOfThree</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayOfThree</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ArrayOfThree</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayOfThree</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayOfOne</secondary></indexterm>
<!-- ArrayOfThree --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj1, obj2, obj3;

// Method Syntax Form(s)

arr = context->ArrayOfThree(obj1, obj2, obj3);
]]>
</programlisting>
<para>Create a new &singledimarray; with the specified objects.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj1</emphasis></entry>
    <entry><para>The first object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj2</emphasis></entry>
    <entry><para>The second object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj3</emphasis></entry>
    <entry><para>The third object to be added.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Array object.</para>
</section>

<section id="mthArrayOfTwo"><title>ArrayOfTwo</title>
<indexterm><primary>ArrayOfTwo</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayOfTwo</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ArrayOfTwo</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayOfTwo</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayOfOne</secondary></indexterm>
<!-- ArrayOfTwo --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj1, obj2;

// Method Syntax Form(s)

arr = context->ArrayOfTwo(obj1, obj2);
]]>
</programlisting>
<para>Create a new &singledimarray; with the specified objects..
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj1</emphasis></entry>
    <entry><para>The first object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj2</emphasis></entry>
    <entry><para>The second object to be added.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Array object.</para>
</section>

<section id="mthArrayPut"><title>ArrayPut</title>
<indexterm><primary>ArrayPut</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayPut</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ArrayPut</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayPut</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayPut</secondary></indexterm>
<!-- ArrayPut --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj;
size_t idx;

// Method Syntax Form(s)

context->ArrayPut(arr, obj, idx);
]]>
</programlisting>
<para>Replace/add an Object to an Array.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The target Array object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">idx</emphasis></entry>
    <entry><para>The index into the Array object. This argument is 1-based.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthArraySize"><title>ArraySize</title>
<indexterm><primary>ArraySize</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArraySize</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ArraySize</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArraySize</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArraySize</secondary></indexterm>
<!-- ArraySize --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxArrayObject arr;
size_t sz;

// Method Syntax Form(s)

sz = context->ArraySize(arr);
]]>
</programlisting>
<para>Returns the size of an Array.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The source Array object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Array size.</para>
</section>

<section id="mthAttachThread"><title>AttachThread</title>
<indexterm><primary>AttachThread</primary></indexterm>
<indexterm><primary>Rexx instance context methods</primary>
<secondary>AttachThread</secondary></indexterm>
<!-- AttachThread --><para>&contexts_instance;.</para>
<programlisting language="C++">
<![CDATA[
RexxThreadContext *tc;

// Method Syntax Form(s)

success = context->AttachThread(&tc);
]]>
</programlisting>
<para>Attaches the current thread to the Rexx interpreter instance
<emphasis role="italic">context</emphasis> pointer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">tc</emphasis></entry>
    <entry><para>Pointer to a RexxThreadContext pointer used to return a RexxThreadContext for the attached thread.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Boolean value. 1 = success, 0 = failure.  If the call was successful,
a RexxThreadContext object valid for the current context is returned via the
<emphasis role="italic">tc</emphasis> argument.
</para>
</section>

<section id="mthBufferData"><title>BufferData</title>
<indexterm><primary>BufferData</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>BufferData</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>BufferData</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>BufferData</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>BufferData</secondary></indexterm>
<!-- BufferData --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxBufferObject obj;
POINTER str;

// Method Syntax Form(s)

str = context->BufferData(obj);
]]>
</programlisting>
<para>Returns a pointer to a Buffer object's data area.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source Buffer object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The C pointer to the Buffer object's data area.</para>
</section>

<section id="mthBufferLength"><title>BufferLength</title>
<indexterm><primary>BufferLength</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>BufferLength</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>BufferLength</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>BufferLength</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>BufferLength</secondary></indexterm>
<!-- BufferLength --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxBufferObject obj;
size_t sz;

// Method Syntax Form(s)

sz = context->BufferLength(obj);
]]>
</programlisting>
<para>Return the length of a Buffer object's data area.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source Buffer object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The length of the Buffer object's data area.</para>
</section>

<section id="mthBufferStringData"><title>BufferStringData</title>
<indexterm><primary>BufferStringData</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>BufferStringData</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>BufferStringData</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>BufferStringData</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>BufferStringData</secondary></indexterm>
<!-- BufferStringData --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxBufferStringObject obj;
POINTER str;

// Method Syntax Form(s)

str = context->BufferStringData(obj);
]]>
</programlisting>
<para>Returns a pointer to a RexxBufferString object's data area.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The C pointer to the RexxBufferString's data area.  This is a writable
data area, but the RexxBufferString must be finalized using
<xref linkend="mthFinishBufferString" xrefstyle="select:title"/> before
it can be used in any other context.
</para>
</section>

<section id="mthBufferStringLength"><title>BufferStringLength</title>
<indexterm><primary>BufferStringLength</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>BufferStringLength</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>BufferStringLength</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>BufferStringLength</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>BufferStringLength</secondary></indexterm>
<!-- BufferStringLength --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxBufferStringObject obj;
size_t sz;

// Method Syntax Form(s)

sz = context->BufferStringLength(obj);
]]>
</programlisting>
<para>Return the length of a RexxBufferStringObject instance.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source RexxBufferStringObject.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The length of the RexxBufferStringObject.</para>
</section>

<section id="mthCallProgram"><title>CallProgram</title>
<indexterm><primary>CallProgram</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>CallProgram</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>CallProgram</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>CallProgram</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>CallProgram</secondary></indexterm>
<!-- CallProgram --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING name;
RexxObjectPtr ret;
RexxArrayObject arr;

// Method Syntax Form(s)

ret = context->CallProgram(name, arr);
]]>
</programlisting>
<para>Returns the result object of the routine.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The ASCII-Z path/name of the Rexx program to call.</para></entry>
    </row>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>An Array of object program arguments.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Any result object returned by the program.  NULLOBJECT is returned if the
program does not return a value.
Any errors involved with calling the program
will will return a NULLOBJECT result.  The
<xref linkend="mthCheckCondition" xrefstyle="select:title"/>
can be used to check if any errors occurred during the call.
</para>
</section>

<section id="mthCallRoutine"><title>CallRoutine</title>
<indexterm><primary>CallRoutine</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>CallRoutine</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>CallRoutine</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>CallRoutine</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>CallRoutine</secondary></indexterm>
<!-- CallRoutine --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj, ret;
RexxArrayObject arr;

// Method Syntax Form(s)

ret = context->CallRoutine(obj, arr);
]]>
</programlisting>
<para>Returns the result object of the routine.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The routine object to call.</para></entry>
    </row>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>An Array of routine argument objects.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Any result object returned by the Routine.  NULLOBJECT is returned if the
program does not return a value.
Any errors involved with calling the program
will will return a NULLOBJECT result.  The
<xref linkend="mthCheckCondition" xrefstyle="select:title"/>
can be used to check if any errors occurred during the call.
</para>
</section>

<section id="mthCheckCondition"><title>CheckCondition</title>
<indexterm><primary>CheckCondition</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>CheckCondition</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>CheckCondition</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>CheckCondition</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>CheckCondition</secondary></indexterm>
<!-- CheckCondition --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
logical_t flag;

// Method Syntax Form(s)

flag = context->CheckCondition();
]]>
</programlisting>
<para>Checks to see if any conditions have resulted from a call to a Rexx API.  .
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.
</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = if a condition has been raised, 0 = no condition raised.</para>
</section>

<section id="mthClearCondition"><title>ClearCondition</title>
<indexterm><primary>ClearCondition</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ClearCondition</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ClearCondition</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ClearCondition</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ClearCondition</secondary></indexterm>
<!-- ClearCondition --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
// Method Syntax Form(s)

context->ClearCondition();
]]>
</programlisting>
<para>Clears any pending condition status.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.
</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthCString"><title>CString</title>
<indexterm><primary>CString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>CString</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>CString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>CString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>CString</secondary></indexterm>
<!-- CString --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
RexxStringObject ostr;
CSTRING str;

// Method Syntax Form(s)

str = context->CString(obj);

ostr = context->CString(str);
]]>
</programlisting>
<para>There are two forms of this method.
The first converts an Object into a C ASCII-Z string.
The second converts C ASCII-Z string into a String object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object for the conversion.</para></entry>
    </row>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The source C ASCII-Z string for the conversion.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>For the first method form, a CSTRING representation of the object is returned.
For the second form, a String object is created from the ASCII-Z string data..</para>
</section>

<section id="mthDecodeConditionInfo"><title>DecodeConditionInfo</title>
<indexterm><primary>DecodeConditionInfo</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DecodeConditionInfo</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>DecodeConditionInfo</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DecodeConditionInfo</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DecodeConditionInfo</secondary></indexterm>
<!-- DecodeConditionInfo --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxDirectoryObject dir;
RexxCondition cond;

// Method Syntax Form(s)

context->DecodeConditionInfo(dir, &cond);
]]>
</programlisting>
<para>Decodes the condition information into a RexxCondition structure, which
is defined as follows:
<programlisting language="C++">
<![CDATA[
typedef struct
{
  wholenumber_t code;                // full condition code
  wholenumber_t rc;                  // return code value
  size_t           position;         // line number position
  RexxStringObject conditionName;    // name of the condition
  RexxStringObject message;          // fully filled in message
  RexxStringObject errortext;        // major error text
  RexxStringObject program;          // program name
  RexxStringObject description;      // description text
  RexxArrayObject  additional;       // additional information
} RexxCondition;
]]>
</programlisting>
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">dir</emphasis></entry>
    <entry><para>The source Directory object containing the condition information.</para></entry>
    </row>
    <row><entry><emphasis role="italic">cond</emphasis></entry>
    <entry><para>A pointer to the RexxCondition structure.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.  The <emphasis role="bold">cond</emphasis> structure is updated with information from
<emphasis role="italic">dir</emphasis>.
</para>
</section>

<section id="mthDetachThread"><title>DetachThread</title>
<indexterm><primary>DetachThread</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DetachThread</secondary></indexterm>
<!-- DetachThread --><para>&contexts_thread;.</para>
<programlisting language="C++">
<![CDATA[
// Method Syntax Form(s)

context->DetachThread();
]]>
</programlisting>
<para>Detaches the thread represented by the RexxThreadContext object from it's
interpreter instance.  Once DetachThread() is called, the RexxThreadContext object
issuing the call is no longer a valid, active interface.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthDirectoryAt"><title>DirectoryAt</title>
<indexterm><primary>DirectoryAt</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DirectoryAt</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>DirectoryAt</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DirectoryAt</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DirectoryAt</secondary></indexterm>
<!-- DirectoryAt --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxDirectoryObject dirobj;
RexxObjectPtr obj;
CSTRING str;

// Method Syntax Form(s)

obj = context->DirectoryAt(dirobj, str);
]]>
</programlisting>
<para>Return the object at the specified index.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">dirobj</emphasis></entry>
    <entry><para>The source Directory object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The index into the Directory object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object at the specified index.  Returns NULLOBJECT if the given index does not exist.
</para>
</section>

<section id="mthDirectoryPut"><title>DirectoryPut</title>
<indexterm><primary>DirectoryPut</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DirectoryPut</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>DirectoryPut</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DirectoryPut</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DirectoryPut</secondary></indexterm>
<!-- DirectoryPut --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxDirectoryObject dirobj;
RexxObjectPtr item;
CSTRING index;

// Method Syntax Form(s)

context->DirectoryPut(dirobj, item, index);
]]>
</programlisting>
<para>Replace/add an Object at the specified Directory index.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">dirobj</emphasis></entry>
    <entry><para>The source Directory object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">item</emphasis></entry>
    <entry><para>The object instance to be stored at the index.</para></entry>
    </row>
    <row><entry><emphasis role="italic">index</emphasis></entry>
    <entry><para>The ASCII-Z string index into the Directory object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthDirectoryRemove"><title>DirectoryRemove</title>
<indexterm><primary>DirectoryRemove</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DirectoryRemove</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>DirectoryRemove</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DirectoryRemove</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DirectoryRemove</secondary></indexterm>
<!-- DirectoryRemove --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxDirectoryObject dirobj;
RexxObjectPtr obj;
CSTRING str;

// Method Syntax Form(s)

obj = context->DirectoryRemove(dirobj, str);
]]>
</programlisting>
<para>Removes and returns the object at the specified Directory index.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">dirobj</emphasis></entry>
    <entry><para>The source Directory object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The ASCII-Z index into the Directory object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object removed at the specified index.  Returns NULLOBJECT if the index
did not exist in the target Directory.
</para>
</section>

<section id="mthDisplayCondition"><title>DisplayCondition</title>
<indexterm><primary>DisplayCondition</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DisplayCondition</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>DisplayCondition</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DisplayCondition</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DisplayCondition</secondary></indexterm>
<!-- DisplayCondition --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
wholenumber_t rc;

// Method Syntax Form(s)

rc = context->DisplayCondition();
]]>
</programlisting>
<para>If any syntax conditions are currently pending in the Rexx context, then
error information will be output to the current .error stream.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.
</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>If there is syntax information to display, the return code will be the
major error number for the syntax error.  Returns 0 if there is no current syntax condition.</para>
</section>

<section id="mthDouble"><title>Double</title>
<indexterm><primary>Double</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Double</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>Double</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Double</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Double</secondary></indexterm>
<!-- Double --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
double n;
logical_t flag;

// Method Syntax Form(s)

obj = context->Double(n);

flag = context->Double(obj, &n);
]]>
</programlisting>
<para>There are two forms of this method.
The first form converts C double value to an Object.
The second form converts an Object to a C double value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>For the first method form, the double value to be converted.
       For the second method form, the target of the conversion.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted..</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>For the first method form, returns an Object version of the double value.
For the second method form, 0 - success, 1 = failure.
If successful, the converted value is placed in
<emphasis role="bold">n</emphasis>.</para>
</section>

<section id="mthDoubleToObject"><title>DoubleToObject</title>
<indexterm><primary>DoubleToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DoubleToObject</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>DoubleToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DoubleToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DoubleToObject</secondary></indexterm>
<!-- DoubleToObject --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
double n;

// Method Syntax Form(s)

obj = context->DoubleToObject(n);
]]>
</programlisting>
<para>Converts C double value to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The double value to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>An Object representation of the double value.</para>
</section>

<section id="mthDoubleToObjectWithPrecision"><title>DoubleToObjectWithPrecision</title>
<indexterm><primary>DoubleToObjectWithPrecision</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DoubleToObjectWithPrecision</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>DoubleToObjectWithPrecision</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DoubleToObjectWithPrecision</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DoubleToObjectWithPrecision</secondary></indexterm>
<!-- DoubleToObjectWithPrecision --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
size_t p;
double n;

// Method Syntax Form(s)

obj = context->DoubleToObject(n, p);
]]>
</programlisting>
<para>Converts C double value to an Object with a specific precision.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The double value to be converted.</para></entry>
    </row>
    <row><entry><emphasis role="italic">p</emphasis></entry>
    <entry><para>The precision to be used for the conversion.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>An Object representation of the double value.</para>
</section>

<section id="mthDropContextVariable"><title>DropContextVariable</title>
<indexterm><primary>DropContextVariable</primary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>DropContextVariable</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DropContextVariable</secondary></indexterm>
<!-- DropContextVariable --><para>&contexts_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING name;

// Method Syntax Form(s)

context->DropContextVariable(name);
]]>
</programlisting>
<para>Drops a Rexx variable in the current routine's caller variable context.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The name of the Rexx variable.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthDropObjectVariable"><title>DropObjectVariable</title>
<indexterm><primary>DropObjectVariable</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DropObjectVariable</secondary></indexterm>
<!-- DropObjectVariable --><para>&contexts_method;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING str;

// Method Syntax Form(s)

context->DropObjectVariable(str);
]]>
</programlisting>
<para>Drops an instance variable in the current method's scope.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The name of the object variable.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthDropStemArrayElement"><title>DropStemArrayElement</title>
<indexterm><primary>DropStemArrayElement</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DropStemArrayElement</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>DropStemArrayElement</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DropStemArrayElement</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DropStemArrayElement</secondary></indexterm>
<!-- DropStemArrayElement --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxStemObject sobj;
size_t n;

// Method Syntax Form(s)

context->DropStemArrayElement(sobj, n);
]]>
</programlisting>
<para>Drops an element of the Stem object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The target Stem object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The Stem object element number.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthDropStemElement"><title>DropStemElement</title>
<indexterm><primary>DropStemElement</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DropStemElement</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>DropStemElement</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DropStemElement</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DropStemElement</secondary></indexterm>
<!-- DropStemElement --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxStemObject sobj;
CSTRING name;

// Method Syntax Form(s)

context->DropStemElement(sobj, name);
]]>
</programlisting>
<para>Drops an element of the Stem object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The target Stem object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The Stem object element name.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthFalse"><title>False</title>
<indexterm><primary>False</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>False</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>False</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>False</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>False</secondary></indexterm>
<!-- False --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;

// Method Syntax Form(s)

obj = context->False();
]]>
</programlisting>
<para>This method returns the Rexx .false ( 0 ) object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Rexx .false object.</para>
</section>

<section id="mthFindClass"><title>FindClass</title>
<indexterm><primary>FindClass</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>FindClass</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>FindClass</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>FindClass</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>FindClass</secondary></indexterm>
<!-- FindClass --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxClassObject class;
CSTRING name;

// Method Syntax Form(s)

class = context->FindClass(name);
]]>
</programlisting>
<para>Locates a Class object in the current thread context.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>An ASCII-Z string containing the name of the class.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The located Class object.  Returns NULLOBJECT if the class is not found.</para>
</section>

<section id="mthFindContextClass"><title>FindContextClass</title>
<indexterm><primary>FindContextClass</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>FindContextClass</secondary></indexterm>
<!-- FindContextClass --><para>&contexts_method_call;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING name;
RexxClassObject obj;

// Method Syntax Form(s)

obj = context->FindContextClass(name);
]]>
</programlisting>
<para>Locate a Class object in the current Method or Routine Package context.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The class name to be located.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The located Class object.  Returns NULLOBJECT if the class is not found.</para>
</section>

<section id="mthFindPackageClass"><title>FindPackageClass</title>
<indexterm><primary>FindPackageClass</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>FindPackageClass</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>FindPackageClass</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>FindPackageClass</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>FindPackageClass</secondary></indexterm>
<!-- FindPackageClass --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxPackageObject pkg;
RexxClassObject class;
CSTRING name;

// Method Syntax Form(s)

class = context->FindPackageClass(pkg, name);
]]>
</programlisting>
<para>Locate a class object in a given Package object's context.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">pkg</emphasis></entry>
    <entry><para>The Package object used to resolve the class.</para></entry>
    </row>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>An ASCII-Z string containing the name of the class.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The located Class object.  Returns NULLOBJECT if the class is not found.</para>
</section>

<section id="mthFinishBufferString"><title>FinishBufferString</title>
<indexterm><primary>FinishBufferString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>FinishBufferString</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>FinishBufferString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>FinishBufferString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>FinishBufferString</secondary></indexterm>
<!-- FinishBufferString --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxBufferStringObject obj;
RexxStringObject str;
size_t len;

// Method Syntax Form(s)

str = context->FinishBufferString(obj, len);
]]>
</programlisting>
<para>Converts a RexxBufferStringObject into a completed, immutable String object of the
given length and returns a reference to the completed String object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The working RexxBufferStringObject.</para></entry>
    </row>
    <row><entry><emphasis role="italic">len</emphasis></entry>
    <entry><para>The final length of the constructed string.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The finalized Rexx string object.</para>
</section>

<section id="mthForwardMessage"><title>ForwardMessage</title>
<indexterm><primary>ForwardMessage</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ForwardMessage</secondary></indexterm>
<!-- ForwardMessage --><para>&contexts_method;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING str;
RexxObjectPtr obj, ret;
RexxClassObject sobj;
RexxArrayObject arr;

// Method Syntax Form(s)

ret = context->ForwardMessage(obj, str, cobj, arr);
]]>
</programlisting>
<para>Forwards a message to a different object or method.  This is
equivalent to using a FORWARD CONTINUE instruction from Rexx code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to receive the message.  If NULL, the object
    that is the target of the current method call is used.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The message name to use.  If NULL, then the name of the current method
    is used.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">cobj</emphasis></entry>
    <entry><para>The class scope used to locate the method.  If NULL, this will be an unscoped method
    call.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The Array of message arguments.  If NULL, the same arguments
    that were used on the current method invocation will be used.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The invoked message result.  NULLOBJECT will be returned if the
target method does not return a result.</para>
</section>

<section id="mthFreeObjectMemory"><title>&added50;FreeObjectMemory</title>
<indexterm><primary>FreeObjectMemory</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>FreeObjectMemory</secondary></indexterm>
<!-- FreeObjectMemory --><para>&contexts_method; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
POINTER ptr;

// Method Syntax Form(s)

context->FreeObjectMemory(ptr);
]]>
</programlisting>

<para>Frees object memory allocated with
<xref linkend="mthAllocateObjectMemory" xrefstyle="select:title"/>.
Object memory is also automatically freed at the time the object gets
garbage-collected.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">ptr</emphasis></entry>
    <entry><para>A POINTER to object memory allocated with
    <xref linkend="mthAllocateObjectMemory" xrefstyle="select:title"/> or
    reallocated with
    <xref linkend="mthReallocateObjectMemory" xrefstyle="select:title"/>.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
<para>See also methods
<xref linkend="mthAllocateObjectMemory" xrefstyle="select:title"/> and
<xref linkend="mthReallocateObjectMemory" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthGetAllContextVariables"><title>GetAllContextVariables</title>
<indexterm><primary>GetAllContextVariables</primary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetAllContextVariables</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetAllContextVariables</secondary></indexterm>
<!-- GetAllContextVariables --><para>&contexts_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxDirectoryObject obj;

// Method Syntax Form(s)

obj = context->GetAllContextVariables();
]]>
</programlisting>
<para>Returns all the Rexx variables in the current routine's caller's context as
a Directory.  Only simple variables and stem variables are included in the Directory.
Stem variable entries will have a Stem object as the value.  Compound variables
may be accessed via the Stem object values.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A RexxDirectoryObject with the variable names and values.</para>
</section>

<section id="mthGetAllStemElements"><title>GetAllStemElements</title>
<indexterm><primary>GetAllStemElements</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetAllStemElements</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetAllStemElements</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetAllStemElements</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetAllStemElements</secondary></indexterm>
<!-- GetAllStemElements --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxStemObject sobj;
RexxDirectoryObject obj;

// Method Syntax Form(s)

obj = context->GetAllStemElements(sobj);
]]>
</programlisting>
<para>Returns all elements of a Stem object as a Directory object.
Each assigned Stem tail element will be an entry in the Directory.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source Stem object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Directory object containing the Stem variable values.</para>
</section>

<section id="mthGetApplicationData"><title>GetApplicationData</title>
<indexterm><primary>GetApplicationData</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetApplicationData</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetApplicationData</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetApplicationData</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetApplicationData</secondary></indexterm>
<!-- GetApplicationData --><para>&contexts_thread_method_call_exit;.</para>
<programlisting>
<![CDATA[
// Method Syntax Form(s)

ptr = context->GetApplicationData();
]]>
</programlisting>
<para>Returns the application data pointer that was set via the APPLICATION_DATA
option when the intepreter instance was created.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The application instance data set when the interpreter instance was created.</para>
</section>

<section id="mthGetArgument"><title>GetArgument</title>
<indexterm><primary>GetArgument</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetArgument</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetArgument</secondary></indexterm>
<!-- GetArgument --><para>&contexts_method_call;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
size_t n;

// Method Syntax Form(s)

obj = context->GetArgument(n);
]]>
</programlisting>
<para>Returns the specified argument to the method or routine.  This
is equivalent to calling Arg(n) from within Rexx code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The argument number (1-based).</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object corresponding to the given argument position.  Returns
NULLOBJECT if the argument was not specified.
</para>
</section>

<section id="mthGetArguments"><title>GetArguments</title>
<indexterm><primary>GetArguments</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetArguments</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetArguments</secondary></indexterm>
<!-- GetArguments --><para>&contexts_method_call;.</para>
<programlisting language="C++">
<![CDATA[
RexxArrayObject arr;

// Method Syntax Form(s)

arr = context->GetArguments();
]]>
</programlisting>
<para>Returns an Array object of the arguments to the method or routine.
This is the same argument Array returned by the ARGLIST argument type.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Array object containing the method or routine arguments.</para>
</section>

<section id="mthGetCallerContext"><title>GetCallerContext</title>
<indexterm><primary>GetCallerContext</primary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetCallerContext</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetCallerContext</secondary></indexterm>
<!-- GetCallerContext --><para>&contexts_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;

// Method Syntax Form(s)

obj = context->GetCallerContext();
]]>
</programlisting>
<para>Get the RexxContext object corresponding to the routine or exit's
calling context.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current exit or routine caller's RexxContext object.</para>
</section>

<section id="mthGetConditionInfo"><title>GetConditionInfo</title>
<indexterm><primary>GetConditionInfo</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetConditionInfo</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetConditionInfo</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetConditionInfo</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetConditionInfo</secondary></indexterm>
<!-- GetConditionInfo --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxDirectoryObject dir;

// Method Syntax Form(s)

dir = context->GetConditionInfo();
]]>
</programlisting>
<para>Returns a Directory object containing the condition information.
This is equivalent to calling Condition('O') from within Rexx code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The RexxDirectoryObject containing the condition information.  If
there are no pending conditions, NULLOBJECT is returned.
</para>
</section>

<section id="mthGetContextDigits"><title>GetContextDigits</title>
<indexterm><primary>GetContextDigits</primary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetContextDigits</secondary></indexterm>
<!-- GetContextDigits --><para>&contexts_call;.</para>
<programlisting language="C++">
<![CDATA[
stringsize_t sz;

// Method Syntax Form(s)

sz = context->GetContextDigits();
]]>
</programlisting>
<para>Get the routine caller's current NUMERIC DIGITS setting.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current NUMERIC DIGITS setting.</para>
</section>

<section id="mthGetContextForm"><title>GetContextForm</title>
<indexterm><primary>GetContextForm</primary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetContextForm</secondary></indexterm>
<!-- GetContextForm --><para>&contexts_call;.</para>
<programlisting language="C++">
<![CDATA[
stringsize_t sz;

// Method Syntax Form(s)

sz = context->GetContextForm();
]]>
</programlisting>
<para>Get the routine caller's current NUMERIC FORM setting.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current NUMERIC FORM setting.</para>
</section>

<section id="mthGetContextFuzz"><title>GetContextFuzz</title>
<indexterm><primary>GetContextFuzz</primary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetContextFuzz</secondary></indexterm>
<!-- GetContextFuzz --><para>&contexts_call;.</para>
<programlisting language="C++">
<![CDATA[
stringsize_t sz;

// Method Syntax Form(s)

sz = context->GetContextFuzz();
]]>
</programlisting>
<para>Get the routine caller's current NUMERIC FUZZ setting.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current NUMERIC FUZZ setting.</para>
</section>

<section id="mthGetContextVariable"><title>GetContextVariable</title>
<indexterm><primary>GetContextVariable</primary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetContextVariable</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetContextVariable</secondary></indexterm>
<!-- GetContextVariable --><para>&contexts_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
CSTRING name;

// Method Syntax Form(s)

obj = context->GetContextVariable(name);
]]>
</programlisting>
<para>Gets the value of a Rexx variable in the routine or exit caller's variable context.
Only simple variables and stem variables can be retrieved with GetContextVariable().
The value returned for a stem variable will be the corresponding Stem object.
Compound variable values can be retrieved from the corresponding Stem values.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The name of the Rexx variable.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The value of the named variable.  Returns NULLOBJECT if the variable
has not been assigned a value.</para>
</section>


<section id="mthGetContextVariableReference" revisionflag="added"><title>&added50;GetContextVariableReference</title>
<indexterm><primary>GetContextVariableReference</primary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetContextVariableReference</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetContextVariableReference</secondary></indexterm>
<!-- GetContextVariableReference --><para>&contexts_call_exit; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING name;
RexxVariableReferenceObject obj;

// Method Syntax Form(s)

obj = context->GetContextVariableReference(name);
]]>
</programlisting>
<para>Creates a VariableReference instance from a context variable name.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The name of a simple or a stem context variable for which
    a reference should be created.
    A compound variable name is not allowed.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A VariableReference object referencing
<emphasis role="italic">name</emphasis>.
</para>
<para>See also methods
<xref linkend="mthGetObjectVariableReference" xrefstyle="select:title"/>,
<xref linkend="mthIsVariableReference" xrefstyle="select:title"/>,
<xref linkend="mthSetVariableReferenceValue" xrefstyle="select:title"/>,
<xref linkend="mthVariableReferenceName" xrefstyle="select:title"/>, and
<xref linkend="mthVariableReferenceValue" xrefstyle="select:title"/>.
</para>
</section>


<section id="mthGetCSelf"><title>&changed50;GetCSelf</title>
<indexterm><primary>GetCSelf</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetCSelf</secondary></indexterm>
<!-- GetSelf --><para>&contexts_method;.</para>
<programlisting language="C++">
<![CDATA[
POINTER ptr;

// Method Syntax Form(s)

ptr = context->GetCSelf();
]]>
</programlisting>
<para>Returns a pointer to the CSELF value for the current object.
CSELF is a special argument type used for classes to store native
pointers or structures inside an object instance.
GetCSelf() will search all of the object's variable scopes for
a variable named CSELF.
If a CSELF variable is located and the value is an instance of either the
Pointer or the Buffer class, the corresponding POINTER value will be
returned as a void * value.
Objects that rely on CSELF values typically set the variable CSELF inside
an INIT method for the class.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The CSELF value for the current object,
or NULL if no CSELF value was found.
</para>
<para>See also method
<xref linkend="mthObjectToCSelf" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthGetGlobalEnvironment"><title>GetGlobalEnvironment</title>
<indexterm><primary>GetGlobalEnvironment</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetGlobalEnvironment</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetGlobalEnvironment</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetGlobalEnvironment</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetGlobalEnvironment</secondary></indexterm>
<!-- GetGlobalEnvironment --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxDirectoryObject dir;

// Method Syntax Form(s)

dir = context->GetGlobalEnvironment();
]]>
</programlisting>
<para>Returns a reference to the .environment Directory.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A RexxDirectoryObject pointer to the .environment Directory.</para>
</section>

<section id="mthGetLocalEnvironment"><title>GetLocalEnvironment</title>
<indexterm><primary>GetLocalEnvironment</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetLocalEnvironment</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetLocalEnvironment</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetLocalEnvironment</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetLocalEnvironment</secondary></indexterm>
<!-- GetLocalEnvironment --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxDirectoryObject dir;

// Method Syntax Form(s)

dir = context->GetLocalEnvironment();
]]>
</programlisting>
<para>Returns a reference to the interpreter instance .local Directory.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A RexxDirectoryObject pointer to the .local Directory.</para>
</section>

<section id="mthGetMessageName"><title>GetMessageName</title>
<indexterm><primary>GetMessageName</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetMessageName</secondary></indexterm>
<!-- GetMessageName --><para>&contexts_method;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING str;

// Method Syntax Form(s)

str = context->GetMessageName(obj);
]]>
</programlisting>
<para>Returns the message name used to invoke the current method.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current method message name.</para>
</section>

<section id="mthGetMethod"><title>GetMethod</title>
<indexterm><primary>GetMethod</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetMethod</secondary></indexterm>
<!-- GetMethod --><para>&contexts_method;.</para>
<programlisting language="C++">
<![CDATA[
RexxMethodObject obj;

// Method Syntax Form(s)

obj = context->GetMethod();
]]>
</programlisting>
<para>Returns the Method object for the currently executing method.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current Method object.</para>
</section>

<section id="mthGetMethodPackage"><title>GetMethodPackage</title>
<indexterm><primary>GetMethodPackage</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetMethodPackage</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetMethodPackage</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetMethodPackage</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetMethodPackage</secondary></indexterm>
<!-- GetMethodPackage --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxMethodObject obj;
RexxPackageObject pkg;

// Method Syntax Form(s)

pkg = context->GetMethodPackage(obj);
]]>
</programlisting>
<para>Returns the Package object associated with the specified Method instance.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source Method object..</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Method's defining Package object.</para>
</section>

<section id="mthGetObjectVariable"><title>GetObjectVariable</title>
<indexterm><primary>GetObjectVariable</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetObjectVariable</secondary></indexterm>
<!-- GetObjectVariable --><para>&contexts_method;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING str;
RexxObjectPtr obj;

// Method Syntax Form(s)

obj = context->GetObjectVariable(str);
]]>
</programlisting>
<para>Retrieves a Rexx instance variable value from the current object's method scope context.
Only simple variables and stem variables can be retrieved with GetObjectVariable().
The value returned for a stem variable will be the corresponding Stem object.
Compound variable values can be retrieved from the corresponding Stem values.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The name of the object variable.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object assigned to the named object variable.  Returns NULLOBJECT if the
variable has not been assigned a value.</para>
</section>


<section id="mthGetObjectVariableReference" revisionflag="added"><title>&added50;GetObjectVariableReference</title>
<indexterm><primary>GetObjectVariableReference</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetObjectVariableReference</secondary></indexterm>
<!-- GetObjectVariableReference --><para>&contexts_method; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING name;
RexxVariableReferenceObject obj;

// Method Syntax Form(s)

obj = context->GetObjectVariableReference(name);
]]>
</programlisting>
<para>Creates a VariableReference instance from an object variable name.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The name of a simple or a stem object variable for which
    a reference should be created.
    A compound variable name is not allowed.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A VariableReference object referencing
<emphasis role="italic">name</emphasis>.
</para>
<para>See also methods
<xref linkend="mthGetObjectVariableReference" xrefstyle="select:title"/>,
<xref linkend="mthIsVariableReference" xrefstyle="select:title"/>,
<xref linkend="mthSetVariableReferenceValue" xrefstyle="select:title"/>,
<xref linkend="mthVariableReferenceName" xrefstyle="select:title"/>, and
<xref linkend="mthVariableReferenceValue" xrefstyle="select:title"/>.
</para>
</section>


<section id="mthGetPackageClasses"><title>GetPackageClasses</title>
<indexterm><primary>GetPackageClasses</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetPackageClasses</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetPackageClasses</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetPackageClasses</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetPackageClasses</secondary></indexterm>
<!-- GetPackageClasses --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxDirectoryObject dir;
RexxPackageObject pkg;

// Method Syntax Form(s)

dir = context->GetPackageClasses(pkg);
]]>
</programlisting>
<para>Returns a Directory object containing the Package public and private classes, indexed by class name.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The package object to query.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A Directory object containing the package classes.</para>
</section>

<section id="mthGetPackageMethods"><title>GetPackageMethods</title>
<indexterm><primary>GetPackageMethods</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetPackageMethods</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetPackageMethods</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetPackageMethods</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetPackageMethods</secondary></indexterm>
<!-- GetPackageMethods --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxDirectoryObject dir;
RexxPackageObject pkg;

// Method Syntax Form(s)

dir = context->GetPackageMethods(pkg);
]]>
</programlisting>
<para>Returns a Directory object containing the Package unattached methods, indexed by Method name.
This is equivalent to
using the .methods environment symbol from Rexx code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The package routine object to query.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A Directory object containing the Package's unattached methods.</para>
</section>

<section id="mthGetPackagePublicClasses"><title>GetPackagePublicClasses</title>
<indexterm><primary>GetPackagePublicClasses</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetPackagePublicClasses</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetPackagePublicClasses</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetPackagePublicClasses</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetPackagePublicClasses</secondary></indexterm>
<!-- GetPackagePublicClasses --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxDirectoryObject dir;
RexxPackageObject pkg;

// Method Syntax Form(s)

dir = context->GetPackagePublicClasses(pkg);
]]>
</programlisting>
<para>Returns a Directory object containing the Package public classes, indexed by class name.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The package object to query.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A Directory object containing the public classes.</para>
</section>

<section id="mthGetPackagePublicRoutines"><title>GetPackagePublicRoutines</title>
<indexterm><primary>GetPackagePublicRoutines</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetPackagePublicRoutines</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetPackagePublicRoutines</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetPackagePublicRoutines</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetPackagePublicRoutines</secondary></indexterm>
<!-- GetPackagePublicRoutines --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxDirectoryObject dir;
RexxPackageObject pkg;

// Method Syntax Form(s)

dir = context->GetPackagePublicRoutines(pkg);
]]>
</programlisting>
<para>Returns a Directory object containing the Package public routines, indexed by routine name.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The package object to query.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A Directory object containing the public routines.</para>
</section>

<section id="mthGetPackageRoutines"><title>GetPackageRoutines</title>
<indexterm><primary>GetPackageRoutines</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetPackageRoutines</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetPackageRoutines</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetPackageRoutines</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetPackageRoutines</secondary></indexterm>
<!-- GetPackageRoutines --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxDirectoryObject dir;
RexxPackageObject pkg;

// Method Syntax Form(s)

dir = context->GetPackageRoutines(pkg);
]]>
</programlisting>
<para>Returns a Directory object containing the Package public and private routines, indexed by routine name.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The package routine object to query.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A Directory object containing the routines.</para>
</section>

<section id="mthGetRoutine"><title>GetRoutine</title>
<indexterm><primary>GetRoutine</primary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetRoutine</secondary></indexterm>
<!-- GetRoutine --><para>&contexts_call;.</para>
<programlisting language="C++">
<![CDATA[
RexxRoutineObject obj;

// Method Syntax Form(s)

obj = context->GetRoutine();
]]>
</programlisting>
<para>Returns current Routine object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current Routine object.</para>
</section>

<section id="mthGetRoutineName"><title>GetRoutineName</title>
<indexterm><primary>GetRoutineName</primary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetRoutineName</secondary></indexterm>
<!-- GetRoutineName --><para>&contexts_call;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING name;

// Method Syntax Form(s)

name = context->GetRoutineName();
]]>
</programlisting>
<para>Returns the name of the current routine.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A pointer ASCII-Z routine name.</para>
</section>

<section id="mthGetRoutinePackage"><title>GetRoutinePackage</title>
<indexterm><primary>GetRoutinePackage</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetRoutinePackage</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetRoutinePackage</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetRoutinePackage</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetRoutinePackage</secondary></indexterm>
<!-- GetRoutinePackage --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxRoutineObject obj;
RexxPackageObject pkg;

// Method Syntax Form(s)

pkg = context->GetRoutinePackage(obj);
]]>
</programlisting>
<para>Returns Routine object's associated Package object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The routine object to query.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Package object instance.</para>
</section>

<section id="mthGetScope"><title>GetScope</title>
<indexterm><primary>GetScope</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetScope</secondary></indexterm>
<!-- GetScope --><para>&contexts_method;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;

// Method Syntax Form(s)

obj = context->GetScope();
]]>
</programlisting>
<para>Return the current active method's scope.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current Method's scope.</para>
</section>

<section id="mthGetSelf"><title>GetSelf</title>
<indexterm><primary>GetSelf</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetSelf</secondary></indexterm>
<!-- GetSelf --><para>&contexts_method;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;

// Method Syntax Form(s)

obj = context->GetSelf();
]]>
</programlisting>
<para>Returns the Object that is the current method's message target.  This
is equivalent to the SELF variable in a Rexx method.  The same value can be accessed as a method
argument using the OSELF type.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current SELF object.</para>
</section>

<section id="mthGetStemArrayElement"><title>GetStemArrayElement</title>
<indexterm><primary>GetStemArrayElement</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetStemArrayElement</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetStemArrayElement</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetStemArrayElement</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetStemArrayElement</secondary></indexterm>
<!-- GetStemArrayElement --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxStemObject sobj;
RexxObjectPtr obj;
size_t n;

// Method Syntax Form(s)

obj = context->GetStemArrayElement(sobj, n);
]]>
</programlisting>
<para>Retrieves an element of a Stem object using a numeric index.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source Stem object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The Stem object element number.  The numeric index is
       translated into the corresponding String tail.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Object stored at the target index or NULLOBJECT if the target index has not been assigned a value.</para>
</section>

<section id="mthGetStemElement"><title>GetStemElement</title>
<indexterm><primary>GetStemElement</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetStemElement</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetStemElement</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetStemElement</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetStemElement</secondary></indexterm>
<!-- GetStemElement --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxStemObject sobj;
RexxObjectPtr obj;
CSTRING name;

// Method Syntax Form(s)

obj = context->GetStemElement(sobj, name);
]]>
</programlisting>
<para>Retrieves an element of a Stem object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source Stem object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The Stem object element name.  This is a fully
    resolved tail name, taken as a constant.  No variable substitution is
    performed on the tail.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object at the target index or NULLOBJECT if the target index
has not been assigned a value.</para>
</section>

<section id="mthGetStemValue"><title>GetStemValue</title>
<indexterm><primary>GetStemValue</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetStemValue</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>GetStemValue</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetStemValue</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetStemValue</secondary></indexterm>
<!-- GetStemValue --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxStemObject sobj;
RexxObjectPtr obj;
CSTRING name;

// Method Syntax Form(s)

obj = context->GetStemValue(sobj);
]]>
</programlisting>
<para>Retrieves the base name value of a Stem object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source Stem object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Stem object's default base value.</para>
</section>

<section id="mthGetSuper"><title>GetSuper</title>
<indexterm><primary>GetSuper</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetSuper</secondary></indexterm>
<!-- GetSuper --><para>&contexts_method;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;

// Method Syntax Form(s)

obj = context->GetSuper();
]]>
</programlisting>
<para>Returns the current method's super class scope.  This is equivalent to the
SUPER variable used from Rexx code.  This value can also be obtained via the SUPER method
argument type.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current method's SUPER scope.</para>
</section>

<section id="mthHalt"><title>Halt</title>
<indexterm><primary>Halt</primary></indexterm>
<indexterm><primary>Rexx instance context methods</primary>
<secondary>Halt</secondary></indexterm>
<!-- Halt --><para>&contexts_instance;.</para>
<programlisting language="C++">
<![CDATA[
// Method Syntax Form(s)

context->Halt();
]]>
</programlisting>
<para>Raise a HALT condition on all threads associated with the interpreter instance.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthHaltThread"><title>HaltThread</title>
<indexterm><primary>HaltThread</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>HaltThread</secondary></indexterm>
<!-- HaltThread --><para>&contexts_thread;.</para>
<programlisting language="C++">
<![CDATA[
// Method Syntax Form(s)

context->HaltThread();
]]>
</programlisting>
<para>Raises a HALT condition on the thread corresponding to the current
<emphasis role="italic">context</emphasis> pointer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthHasMethod"><title>HasMethod</title>
<indexterm><primary>HasMethod</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>HasMethod</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>HasMethod</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>HasMethod</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>HasMethod</secondary></indexterm>
<!-- HasMethod --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
logical_t flag;
RexxObjectPtr obj;
CSTRING name;

// Method Syntax Form(s)

flag = context->HasMethod(obj, name);
]]>
</programlisting>
<para>Tests if an object supports the specified method name.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The target object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>An ASCII-Z method name.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = the method exists, 0 = the method does not exist.</para>
</section>

<section id="mthInt32"><title>Int32</title>
<indexterm><primary>Int32</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Int32</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>Int32</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Int32</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Int32</secondary></indexterm>
<!-- Int32 --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;
int32_t n;

// Method Syntax Form(s)

obj = context->Int32(n);

flag = context->Int32(obj, &n);
]]>
</programlisting>
<para>There a two forms of this method.
The first form converts a C 32-bit integer <emphasis role="italic">n</emphasis> to an Object.
The second form converts an Object to a C 32-bit integer, returning it in <emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>For the first form, the value to be converted.  For the second form, the converted result.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>For the first form, n Object representation of the integer value.
For the second form,  returns 1 = success, 0 = failure.  If successful, the converted value is
placed in <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthInt32ToObject"><title>Int32ToObject</title>
<indexterm><primary>Int32ToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Int32ToObject</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>Int32ToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Int32ToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Int32ToObject</secondary></indexterm>
<!-- Int32ToObject --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
int32_t n;

// Method Syntax Form(s)

obj = context->Int32ToObject(n);
]]>
</programlisting>
<para>Convert a C 32-bit integer <emphasis role="italic">n</emphasis> to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The integer to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>An Object representation of the integer value.</para>
</section>

<section id="mthInt64"><title>Int64</title>
<indexterm><primary>Int64</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Int64</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>Int64</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Int64</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Int64</secondary></indexterm>
<!-- Int64 --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;
int64_t n;

// Method Syntax Form(s)

obj = context->Int64(n);

flag = context->Int64(obj, &n);
]]>
</programlisting>
<para>There a two forms of this method.
The first form converts a C 64-bit integer <emphasis role="italic">n</emphasis> to an Object.
The second form converts an Object to a C 64-bit integer and returns in <emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>For the first form, the integer to be converted.  For the second form, the converted integer.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>For the first form, an Object representation of the integer value.
For the second form,  returns 1 = success, 0 = failure.  If successful, the converted value is
placed in <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthInt64ToObject"><title>Int64ToObject</title>
<indexterm><primary>Int64ToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Int64ToObject</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>Int64ToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Int64ToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Int64ToObject</secondary></indexterm>
<!-- Int64ToObject --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
int64_t n;

// Method Syntax Form(s)

obj = context->Int64ToObject(n);
]]>
</programlisting>
<para>Convert the C 64-bit integer <emphasis role="italic">n</emphasis> to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The integer to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>An Object representing the integer value.</para>
</section>

<section id="mthInterpreterVersion"><title>InterpreterVersion</title>
<indexterm><primary>InterpreterVersion</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>InterpreterVersion</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>InterpreterVersion</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>InterpreterVersion</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>InterpreterVersion</secondary></indexterm>
<indexterm><primary>Rexx instance context methods</primary>
<secondary>InterpreterVersion</secondary></indexterm>
<!-- InterpreterVersion --><para>&contexts_instance_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
size_t version;

// Method Syntax Form(s)

version = context->InterpreterVersion();
]]>
</programlisting>
<para>Returns the version of the interpreter.  The returned version
is encoded in the 3 least significant bytes of the returned value, using
1 byte each for the interpreter version, release, and revision values.
For example, on a 32-bit platform, this value would be 0x00040000 for
version 4.0.0.  The oorexxapi.h header file will have a define matching
these values using the naming convention REXX_INTERPRETER_4_0_0 and the
macro REXX_CURRENT_INTERPRETER_VERSION will give the interpreter version
used to compile your code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The interpreter version number.</para>
</section>

<section id="mthIntptr"><title>Intptr</title>
<indexterm><primary>Intptr</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Intptr</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>Intptr</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Intptr</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Intptr</secondary></indexterm>
<!-- Intptr --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;
intptr_t n;

// Method Syntax Form(s)

obj = context->Intptr(&n);

flag = context->Intptr(obj, &n);
]]>
</programlisting>
<para>There are two forms of this method.
The first form converts the C signed integer <emphasis role="italic">n</emphasis> to an Object.
The second form converts an Object to a C signed integer and returns it in
<emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>For the first form, the value to be converted.
       For the second form, the conversion result.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>For the first form, an Object version of the integer value.
For the second form, returns 1 = success, 0 = failure.  If successful, the converted value is
placed in <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthIntptrToObject"><title>IntptrToObject</title>
<indexterm><primary>IntptrToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IntptrToObject</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>IntptrToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IntptrToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IntptrToObject</secondary></indexterm>
<!-- IntptrToObject --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
intptr_t n;

// Method Syntax Form(s)

obj = context->IntptrToObject(&n);
]]>
</programlisting>
<para>Convert the C signed integer <emphasis role="italic">n</emphasis> to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The signed integer to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>An Object representing the integer value.</para>
</section>

<section id="mthInvalidRoutine"><title>InvalidRoutine</title>
<indexterm><primary>InvalidRoutine</primary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>InvalidRoutine</secondary></indexterm>
<!-- InvalidRoutine --><para>&contexts_call;.</para>
<programlisting language="C++">
<![CDATA[
RexxDirectoryObject obj;

// Method Syntax Form(s)

context->InvalidRoutine();
]]>
</programlisting>
<para>Raises the standard Error 40, "Incorrect call to routine" syntax error for the
current routine.  This error will be raised by the Rexx runtime once the routine
returns.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthIsArray"><title>IsArray</title>
<indexterm><primary>IsArray</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsArray</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsArray</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>IsArray</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsArray</secondary></indexterm>
<!-- IsArray --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

// Method Syntax Form(s)

flag = context->IsArray(obj);
]]>
</programlisting>
<para>Tests if an Object is an Array.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxArrayObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is an Array object, 0 = not an Array object.</para>
</section>

<section id="mthIsBuffer"><title>IsBuffer</title>
<indexterm><primary>IsBuffer</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsBuffer</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsBuffer</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>IsBuffer</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsBuffer</secondary></indexterm>
<!-- IsBuffer --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

// Method Syntax Form(s)

flag = context->IsBuffer(obj);
]]>
</programlisting>
<para>Tests if an Object is a Buffer object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxBufferObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a Buffer object, 0 = not a Buffer object.</para>
</section>

<section id="mthIsDirectory"><title>IsDirectory</title>
<indexterm><primary>IsDirectory</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsDirectory</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsDirectory</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>IsDirectory</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsDirectory</secondary></indexterm>
<!-- IsDirectory --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

// Method Syntax Form(s)

flag = context->IsDirectory(obj);
]]>
</programlisting>
<para>Tests if an Object is a Directory object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxDirectoryObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a Directory object, 0 = not a Directory object.</para>
</section>

<section id="mthIsErrorRedirected"><title>&added50;IsErrorRedirected</title>
<indexterm><primary>IsErrorRedirected</primary></indexterm>
<indexterm><primary>I/O Redirector context methods</primary>
<secondary>IsErrorRedirected</secondary></indexterm>
<!-- IsErrorRedirected --><para>&contexts_ioredirector; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
logical_t flag;

// Method Syntax Form(s)

flag = context->IsErrorRedirected();
]]>
</programlisting>
<para>Tests whether for the current command error output redirection was
requested using the WITH subkeyword of an ADDRESS instruction.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para><literal>1</literal> if error redirection was requested,
<literal>0</literal> otherwise.
</para>
<para>See also methods
<xref linkend="mthAreOutputAndErrorSameTarget" xrefstyle="select:title"/>,
<xref linkend="mthIsInputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsOutputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsRedirectionRequested" xrefstyle="select:title"/>,
<xref linkend="mthReadInput" xrefstyle="select:title"/>,
<xref linkend="mthReadInputBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteError" xrefstyle="select:title"/>,
<xref linkend="mthWriteErrorBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteOutput" xrefstyle="select:title"/>, and
<xref linkend="mthWriteOutputBuffer" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthIsInputRedirected"><title>&added50;IsInputRedirected</title>
<indexterm><primary>IsInputRedirected</primary></indexterm>
<indexterm><primary>I/O Redirector context methods</primary>
<secondary>IsInputRedirected</secondary></indexterm>
<!-- IsInputRedirected --><para>&contexts_ioredirector; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
logical_t flag;

// Method Syntax Form(s)

flag = context->IsInputRedirected();
]]>
</programlisting>
<para>Tests whether for the current command input redirection was requested
using the WITH subkeyword of an ADDRESS instruction.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para><literal>1</literal> if input redirection was requested,
<literal>0</literal> otherwise.
</para>
<para>See also methods
<xref linkend="mthAreOutputAndErrorSameTarget" xrefstyle="select:title"/>,
<xref linkend="mthIsErrorRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsOutputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsRedirectionRequested" xrefstyle="select:title"/>,
<xref linkend="mthReadInput" xrefstyle="select:title"/>,
<xref linkend="mthReadInputBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteError" xrefstyle="select:title"/>,
<xref linkend="mthWriteErrorBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteOutput" xrefstyle="select:title"/>, and
<xref linkend="mthWriteOutputBuffer" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthIsInstanceOf"><title>IsInstanceOf</title>
<indexterm><primary>IsInstanceOf</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsInstanceOf</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsInstanceOf</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>IsInstanceOf</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsInstanceOf</secondary></indexterm>
<!-- IsInstanceOf --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
RexxClassObj class;
logical_t flag;

// Method Syntax Form(s)

flag = context->IsInstanceOf(obj, class);
]]>
</programlisting>
<para>Tests if an Object is an instance of the specified class.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The Object to be tested.</para></entry>
    </row>
    <row><entry><emphasis role="italic">class</emphasis></entry>
    <entry><para>The Class object for the instance test.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is an instance, 0 = not an instance.</para>
</section>

<section id="mthIsMethod"><title>IsMethod</title>
<indexterm><primary>IsMethod</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsMethod</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsMethod</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>IsMethod</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsMethod</secondary></indexterm>
<!-- IsMethod --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

// Method Syntax Form(s)

flag = context->IsMethod(obj);
]]>
</programlisting>
<para>Tests if an Object is a Method object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxMethodObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a Method object, 0 = not a Method object.</para>
</section>

<section id="mthIsMutableBuffer"><title>IsMutableBuffer</title>
<indexterm><primary>IsMutableBuffer</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsMutableBuffer</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsMutableBuffer</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>IsMutableBuffer</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsMutableBuffer</secondary></indexterm>
<!-- IsMutableBuffer --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

// Method Syntax Form(s)

flag = context->IsMutableBuffer(obj);
]]>
</programlisting>
<para>Tests if an Object is a MutableBuffer object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxMutableBufferObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a MutableBuffer object, 0 = not a MutableBuffer object.</para>
</section>

<section id="mthIsOfType"><title>IsOfType</title>
<indexterm><primary>IsOfType</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsOfType</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsOfType</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>IsOfType</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsOfType</secondary></indexterm>
<!-- IsOfType --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
CSTRING class;
logical_t flag;

// Method Syntax Form(s)

flag = context->IsOfType(obj, class);
]]>
</programlisting>
<para>Tests an object to see if it is an instance of the named class.
This method combines the operations of the FindClass() and IsInstanceOf() methods in a single call.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
    <row><entry><emphasis role="italic">class</emphasis></entry>
    <entry><para>An ASCII-Z string containing the name of the Rexx class.  The named class will
    be located in the current context and used in an IsInstanceOf() test.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is an instance, 0 = not an instance or the named class cannot be located.</para>
</section>

<section id="mthIsOutputRedirected"><title>&added50;IsOutputRedirected</title>
<indexterm><primary>IsOutputRedirected</primary></indexterm>
<indexterm><primary>I/O Redirector context methods</primary>
<secondary>IsOutputRedirected</secondary></indexterm>
<!-- IsOutputRedirected --><para>&contexts_ioredirector; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
logical_t flag;

// Method Syntax Form(s)

flag = context->IsOutputRedirected();
]]>
</programlisting>
<para>Tests whether for the current command output redirection was requested
using the WITH subkeyword of an ADDRESS instruction.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para><literal>1</literal> if output redirection was requested,
<literal>0</literal> otherwise.
</para>
<para>See also methods
<xref linkend="mthAreOutputAndErrorSameTarget" xrefstyle="select:title"/>,
<xref linkend="mthIsErrorRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsInputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsRedirectionRequested" xrefstyle="select:title"/>,
<xref linkend="mthReadInput" xrefstyle="select:title"/>,
<xref linkend="mthReadInputBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteError" xrefstyle="select:title"/>,
<xref linkend="mthWriteErrorBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteOutput" xrefstyle="select:title"/>, and
<xref linkend="mthWriteOutputBuffer" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthIsPointer"><title>IsPointer</title>
<indexterm><primary>IsPointer</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsPointer</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsPointer</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>IsRPointer</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsPointer</secondary></indexterm>
<!-- IsPointer --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

// Method Syntax Form(s)

flag = context->IsPointer(obj);
]]>
</programlisting>
<para>Tests if an Object is a Pointer object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxPointerObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a Pointer object, 0 = not a Pointer object.</para>
</section>

<section id="mthIsRedirectionRequested"><title>&added50;IsRedirectionRequested</title>
<indexterm><primary>IsRedirectionRequested</primary></indexterm>
<indexterm><primary>I/O Redirector context methods</primary>
<secondary>IsRedirectionRequested</secondary></indexterm>
<!-- IsRedirectionRequested --><para>&contexts_ioredirector; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
logical_t flag;

// Method Syntax Form(s)

flag = context->IsRedirectionRequested();
]]>
</programlisting>
<para>Tests whether for the current command any redirection was requested
using the WITH subkeyword of an ADDRESS instruction.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para><literal>1</literal> if any redirection was requested,
<literal>0</literal> otherwise.
</para>
<para>See also methods
<xref linkend="mthAreOutputAndErrorSameTarget" xrefstyle="select:title"/>,
<xref linkend="mthIsErrorRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsInputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsOutputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthReadInput" xrefstyle="select:title"/>,
<xref linkend="mthReadInputBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteError" xrefstyle="select:title"/>,
<xref linkend="mthWriteErrorBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteOutput" xrefstyle="select:title"/>, and
<xref linkend="mthWriteOutputBuffer" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthIsRoutine"><title>IsRoutine</title>
<indexterm><primary>IsRoutine</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsRoutine</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsRoutine</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>IsRoutine</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsRoutine</secondary></indexterm>
<!-- IsRoutine --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

// Method Syntax Form(s)

flag = context->IsRoutine(obj);
]]>
</programlisting>
<para>Tests if an Object a Routine object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxPointerObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a Routine object, 0 = not a Routine object.</para>
</section>

<section id="mthIsStem"><title>IsStem</title>
<indexterm><primary>IsStem</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsStem</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsStem</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>IsStem</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsStem</secondary></indexterm>
<!-- IsStem --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

// Method Syntax Form(s)

flag = context->IsStem(obj);
]]>
</programlisting>
<para>Tests if an Object is a Stem object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxStemObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a Stem object, 0 = not a Stem object.</para>
</section>

<section id="mthIsString"><title>IsString</title>
<indexterm><primary>IsString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsString</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>IsString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsString</secondary></indexterm>
<!-- IsString --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

// Method Syntax Form(s)

flag = context->IsString(obj);
]]>
</programlisting>
<para>Tests if an Object is a String object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxStringObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a String object, 0 = not a String object.</para>
</section>


<section id="mthIsStringTable" revisionflag="added"><title>&added50;IsStringTable</title>
<indexterm><primary>IsStringTable</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsStringTable</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsStringTable</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>IsStringTable</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsStringTable</secondary></indexterm>
<!-- IsStringTable --><para>&contexts_thread_method_call_exit; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

// Method Syntax Form(s)

flag = context->IsStringTable(obj);
]]>
</programlisting>
<para>Tests if an Object is a StringTable object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxStringTableObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a StringTable object, 0 = not a StringTable object.</para>
<para>See also methods
<xref linkend="mthNewStringTable" xrefstyle="select:title"/>,
<xref linkend="mthStringTableAt" xrefstyle="select:title"/>,
<xref linkend="mthStringTablePut" xrefstyle="select:title"/>, and
<xref linkend="mthStringTableRemove" xrefstyle="select:title"/>.
</para>
</section>


<section id="mthIsVariableReference" revisionflag="added"><title>&added50;IsVariableReference</title>
<indexterm><primary>IsVariableReference</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsVariableReference</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsVariableReference</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>IsVariableReference</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsVariableReference</secondary></indexterm>
<!-- IsVariableReference --><para>&contexts_thread_method_call_exit; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

// Method Syntax Form(s)

flag = context->IsVariableReference(obj);
]]>
</programlisting>
<para>Tests if an Object is a VariableReference object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxVariableReferenceObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a VariableReference object, 0 = not a VariableReference object.</para>
<para>See also methods
<xref linkend="mthGetContextVariableReference" xrefstyle="select:title"/>,
<xref linkend="mthGetObjectVariableReference" xrefstyle="select:title"/>,
<xref linkend="mthSetVariableReferenceValue" xrefstyle="select:title"/>,
<xref linkend="mthVariableReferenceName" xrefstyle="select:title"/>, and
<xref linkend="mthVariableReferenceValue" xrefstyle="select:title"/>.
</para>
</section>


<section id="mthLanguageLevel"><title>LanguageLevel</title>
<indexterm><primary>Language Level</primary></indexterm>
<indexterm><primary>Rexx instance context methods</primary>
<secondary>LanguageLevel</secondary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>LanguageLevel</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>LanguageLevel</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>LanguageLevel</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>LanguageLevel</secondary></indexterm>
<!-- LanguageLevel --><para>&contexts_instance_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
size_t langlevel;

// Method Syntax Form(s)

langlevel = context->LanguageLevel();
]]>
</programlisting>
<para>Returns the language level of the interpreter.
The returned language level
is encoded in the 2 least significant bytes of the returned value, using
1 byte each for the interpreter version, release, and revision values.
For example, on a 32-bit platform, this value would be 0x00000605 for
language level 6.05.  The oorexxapi.h header file will have a define matching
these values using a the naming convention REXX_LANGUAGE_6_05 and the
macro REXX_CURRENT_LANGUAGE_LEVEL will give the interpreter version
used to compile your code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The interpreter language level number.</para>
</section>

<section id="mthLoadLibrary"><title>LoadLibrary</title>
<indexterm><primary>LoadLibrary</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>LoadLibrary</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>LoadLibrary</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>LoadLibrary</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>LoadLibrary</secondary></indexterm>
<!-- LoadLibrary --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING name;
logical_t success;

// Method Syntax Form(s)

success = context->LoadLibrary(name);
]]>
</programlisting>
<para>Loads an external library with the given name and adds it to the global Rexx environment.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The ASCII-Z path/name of the library package, in format required
    by the ::REQUIRES LIBRARY directive.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>True if the library was successfully loaded or the library had been previously loaded.
False is returned for any errors in loading the package.
</para>
</section>

<section id="mthLoadPackage"><title>LoadPackage</title>
<indexterm><primary>LoadPackage</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>LoadPackage</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>LoadPackage</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>LoadPackage</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>LoadPackage</secondary></indexterm>
<!-- LoadPackage --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING name;
RexxPackageObject pkg;

// Method Syntax Form(s)

pkg = context->LoadPackage(name);
]]>
</programlisting>
<para>Returns the Package object loaded from the specified file path/name.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The ASCII-Z path/name of the Rexx package source file.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The loaded Package object.
Any errors resulting from loading
the package will return a NULLOBJECT value.  Information about errors
can be retrieved using <xref linkend="mthGetConditionInfo" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthLoadPackageFromData"><title>LoadPackageFromData</title>
<indexterm><primary>LoadPackageFromData</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>LoadPackageFromData</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>LoadPackageFromData</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>LoadPackageFromData</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>LoadPackageFromData</secondary></indexterm>
<!-- LoadPackageFromData --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING name, data;
size_t sz;
RexxPackageObject pkg;

// Method Syntax Form(s)

pkg = context->LoadPackageFromData(name, data, sz);
]]>
</programlisting>
<para>Returns the loaded package object  from the specified file path/name.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The ASCII-Z name assigned to the package.</para></entry>
    </row>
    <row><entry><emphasis role="italic">data</emphasis></entry>
    <entry><para>Data buffer containing the package Rexx.</para></entry>
    </row>
    <row><entry><emphasis role="italic">sz</emphasis></entry>
    <entry><para>The size of the <emphasis role="italic">data</emphasis> buffer.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The loaded Package object.
Any errors resulting from loading
the package will return a NULLOBJECT value.  Information about errors
can be retrieved using <xref linkend="mthGetConditionInfo" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthLogical"><title>Logical</title>
<indexterm><primary>Logical</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Logical</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>Logical</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Logical</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Logical</secondary></indexterm>
<!-- Logical --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag, n;

// Method Syntax Form(s)

flag = context->Logical(obj, &n);

obj = context->Logical(n);
]]>
</programlisting>
<para>This method has two forms.
The first form converts an Object to a C logical value (0 or 1).
The second form converts a C logical value to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>For the first method form, a C pointer to a logical_t to receive the conversion result.
       For the second form, a logical_t to be converted to an Object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>For the first method form, 1 = success and 0 = conversion error,  with the converted value placed in
<emphasis role="italic">n</emphasis>
For the second form,
an Object version of the logical value.</para>
</section>

<section id="mthLogicalToObject"><title>LogicalToObject</title>
<indexterm><primary>LogicalToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>LogicalToObject</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>LogicalToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>LogicalToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>LogicalToObject</secondary></indexterm>
<!-- LogicalToObject --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag, n;

// Method Syntax Form(s)

obj = context->LogicalToObject(n);
]]>
</programlisting>
<para>Converts a C logical value to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The logical_t value to be converted..</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Either the .false or .true object is returned.</para>
</section>

<section id="mthMutableBufferCapacity"><title>MutableBufferCapacity</title>
<indexterm><primary>MutableBufferCapacity</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>MutableBufferCapacity</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>MutableBufferCapacity</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>MutableBufferCapacity</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>MutableBufferCapacity</secondary></indexterm>
<!-- MutableBufferCapacity --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxMutableBufferObject obj;
size_t sz;

// Method Syntax Form(s)

sz = context->MutableBufferCapacity(obj);
]]>
</programlisting>
<para>Return the current buffer size of the MutableBuffer.  The capacity is the total
size of the buffer.  The length value is the amount of data currently contained in the buffer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source MutableBuffer object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The size of the MutableBuffer object's data area.</para>
</section>

<section id="mthMutableBufferData"><title>MutableBufferData</title>
<indexterm><primary>MutableBufferData</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>MutableBufferData</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>MutableBufferData</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>MutableBufferData</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>MutableBufferData</secondary></indexterm>
<!-- MutableBufferData --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxMutableBufferObject obj;
POINTER str;

// Method Syntax Form(s)

str = context->MutableBufferData(obj);
]]>
</programlisting>
<para>Returns a pointer to a MutableBuffer object's data area.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source MutableBuffer object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The C pointer to the MutableBuffer object's data area.</para>
</section>

<section id="mthMutableBufferLength"><title>MutableBufferLength</title>
<indexterm><primary>MutableBufferLength</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>MutableBufferLength</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>MutableBufferLength</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>MutableBufferLength</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>MutableBufferLength</secondary></indexterm>
<!-- MutableBufferLength --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxMutableBufferObject obj;
size_t sz;

// Method Syntax Form(s)

sz = context->MutableBufferLength(obj);
]]>
</programlisting>
<para>Return the current length of the data in a MutableBuffer object's data area.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source MutableBuffer object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The length of data in the MutableBuffer object's data area.</para>
</section>

<section id="mthNewArray"><title>NewArray</title>
<indexterm><primary>NewArray</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewArray</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>NewArray</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewArray</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewArray</secondary></indexterm>
<!-- NewArray --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxArrayObject obj;
size_t len;

// Method Syntax Form(s)

obj = context->NewArray(d);
]]>
</programlisting>
<para>Create an Array object of the specified size.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">d</emphasis></entry>
    <entry><para>The size of the Array.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Array object.</para>
</section>

<section id="mthNewBuffer"><title>NewBuffer</title>
<indexterm><primary>NewBuffer</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewBuffer</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>NewBuffer</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewBuffer</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewBuffer</secondary></indexterm>
<!-- NewBuffer --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxBufferObject obj;
size_t len;

// Method Syntax Form(s)

obj = context->NewBuffer(len);
]]>
</programlisting>
<para>Create a Buffer object with a specific data size.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">len</emphasis></entry>
    <entry><para>The maximum length of the buffer.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Buffer object.</para>
</section>

<section id="mthNewBufferString"><title>NewBufferString</title>
<indexterm><primary>NewBufferString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewBufferString</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>NewBufferString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewBufferString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewBufferString</secondary></indexterm>
<!-- NewBufferString --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxBufferStringObject obj;
size_t len;

// Method Syntax Form(s)

obj = context->NewBufferString(len);
]]>
</programlisting>
<para>Create a RexxBufferString with the indicated buffer size.  A RexxBufferString
is a mutable String object that can be used to construct return values.  You
must use <xref linkend="mthFinishBufferString" xrefstyle="select:title"/> to
transform this into a completed String object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">len</emphasis></entry>
    <entry><para>The maximum length of the final String object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A new RexxBufferString value.</para>
</section>

<section id="mthNewDirectory"><title>NewDirectory</title>
<indexterm><primary>NewDirectory</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewDirectory</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>NewDirectory</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewBDirectory</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewDirectory</secondary></indexterm>
<!-- NewDirectory --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxDirectoryObject obj;

// Method Syntax Form(s)

obj = context->NewDirectory();
]]>
</programlisting>
<para>Create a Directory object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Directory object.</para>
</section>

<section id="mthNewMethod"><title>NewMethod</title>
<indexterm><primary>NewMethod</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewMethod</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>NewMethod</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewMethod</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewMethod</secondary></indexterm>
<!-- NewMethod --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxMethodObject obj;
CSTRING name, code;
size_t sz;

// Method Syntax Form(s)

obj = context->NewMethod(name, code, sz);
]]>
</programlisting>
<para>Create a new Method object from an in-memory buffer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>ASCII-Z name of the method.</para></entry>
    </row>
    <row><entry><emphasis role="italic">code</emphasis></entry>
    <entry><para>A data buffer containing the new method's Rexx code.</para></entry>
    </row>
    <row><entry><emphasis role="italic">sz</emphasis></entry>
    <entry><para>Size of the <emphasis role="italic">code</emphasis> buffer.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The created Method object.
Any errors resulting from creating the method
will return a NULLOBJECT value.  Information about any error
can be retrieved using <xref linkend="mthGetConditionInfo" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthNewMutableBuffer"><title>NewMutableBuffer</title>
<indexterm><primary>NewMutableBuffer</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewMutableBuffer</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>NewMutableBuffer</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewMutableBuffer</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewMutableBuffer</secondary></indexterm>
<!-- NewMutableBuffer --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxMutableBufferObject obj;
size_t len;

// Method Syntax Form(s)

obj = context->NewMutableBuffer(len);
]]>
</programlisting>
<para>Create a MutableBuffer object with a specific initial capacity.  The new buffer will
have an initial length of 0.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">len</emphasis></entry>
    <entry><para>The initial capacity of the buffer.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new MutableBuffer object.</para>
</section>

<section id="mthNewPointer"><title>NewPointer</title>
<indexterm><primary>NewPointer</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewPointer</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>NewPointer</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewPointer</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewPointer</secondary></indexterm>
<!-- NewPointer --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxPointerObject obj;
POINTER p;

// Method Syntax Form(s)

obj = context->NewPointer(p);
]]>
</programlisting>
<para>Create a new Pointer object from a C pointer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">p</emphasis></entry>
    <entry><para>The source C pointer.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The created Pointer object.</para>
</section>

<section id="mthNewRoutine"><title>NewRoutine</title>
<indexterm><primary>NewRoutine</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewRoutine</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>NewRoutine</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewRoutine</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewRoutine</secondary></indexterm>
<!-- NewRoutine --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxRoutineObject obj;
CSTRING name, code;
size_t sz;

// Method Syntax Form(s)

obj = context->NewRoutine(name, code, sz);
]]>
</programlisting>
<para>Create a new Routine object from an in-memory buffer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>ASCII-Z name of the routine.</para></entry>
    </row>
    <row><entry><emphasis role="italic">code</emphasis></entry>
    <entry><para>Buffer containing the routine Rexx code.</para></entry>
    </row>
    <row><entry><emphasis role="italic">sz</emphasis></entry>
    <entry><para>Size of the <emphasis role="italic">code</emphasis> buffer.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Routine object.
Any errors resulting from creating the
the routine will return a NULLOBJECT value.  Information about errors
can be retrieved using <xref linkend="mthGetConditionInfo" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthNewStem"><title>NewStem</title>
<indexterm><primary>NewStem</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewStem</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>NewStem</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewStem</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewStem</secondary></indexterm>
<!-- NewStem --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxStemObject obj;
CSTRING str;

// Method Syntax Form(s)

obj = context->NewStem(str);
]]>
</programlisting>
<para>Create an new Stem object with the specified base name.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The base name for the new Stem object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Stem object.</para>
</section>

<section id="mthNewString"><title>NewString</title>
<indexterm><primary>NewString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewString</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>NewString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewString</secondary></indexterm>
<!-- NewString --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxStringObject obj;
CSTRING str;
size_t len;

// Method Syntax Form(s)

obj = context->NewString(str, len);
]]>
</programlisting>
<para>Create a new String object from program data.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>A pointer to a data buffer containing the string data.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">len</emphasis></entry>
    <entry><para>Length of the <emphasis role="italic">str</emphasis> data buffer.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new String object.</para>
</section>


<section id="mthNewStringFromAsciiz"><title>NewStringFromAsciiz</title>
<indexterm><primary>NewStringFromAsciiz</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewStringFromAsciiz</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>NewStringFromAsciiz</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewStringFromAsciiz</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewStringFromAsciiz</secondary></indexterm>
<!-- NewStringFromAsciiz --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxStringObject obj;
CSTRING str;

// Method Syntax Form(s)

obj = context->NewStringFromAsciiz(str);
]]>
</programlisting>
<para>Create a new String object from a C string.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>A pointer to a null-terminated ASCII-Z string.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new String object.</para>
</section>


<section id="mthNewStringTable" revisionflag="added"><title>&added50;NewStringTable</title>
<indexterm><primary>NewStringTable</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewStringTable</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>NewStringTable</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewBStringTable</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewStringTable</secondary></indexterm>
<!-- NewStringTable --><para>&contexts_thread_method_call_exit; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
RexxStringTableObject obj;

// Method Syntax Form(s)

obj = context->NewStringTable();
]]>
</programlisting>
<para>Create a StringTable object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new StringTable object.</para>
<para>See also methods
<xref linkend="mthIsStringTable" xrefstyle="select:title"/>,
<xref linkend="mthStringTableAt" xrefstyle="select:title"/>,
<xref linkend="mthStringTablePut" xrefstyle="select:title"/>, and
<xref linkend="mthStringTableRemove" xrefstyle="select:title"/>.
</para>
</section>


<section id="mthNewSupplier"><title>NewSupplier</title>
<indexterm><primary>NewSupplier</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewSupplier</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>NewSupplier</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewSupplier</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewSupplier</secondary></indexterm>
<!-- NewSupplier --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxSupplierObject obj;
RexxArrayObject arr1, arr2;

// Method Syntax Form(s)

obj = context->NewSupplier(arr1, arr2);
]]>
</programlisting>
<para>This method returns a Supplier object based on the supplied argument Arrays.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">arr1</emphasis></entry>
    <entry><para>The Array of supplier items.</para></entry>
    </row>
    <row><entry><emphasis role="italic">arr2</emphasis></entry>
    <entry><para>The Array of supplier item indexes.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Supplier object.</para>
</section>

<section id="mthNil"><title>Nil</title>
<indexterm><primary>Nil</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Nil</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>Nil</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Nil</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Nil</secondary></indexterm>
<!-- Nil --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;

// Method Syntax Form(s)

obj = context->Nil();
]]>
</programlisting>
<para>Returns the Rexx Nil object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Rexx Nil object.</para>
</section>

<section id="mthNullString"><title>NullString</title>
<indexterm><primary>NullString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NullString</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>NullString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NullString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NullString</secondary></indexterm>
<!-- NullString --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxStringObject obj;

// Method Syntax Form(s)

obj = context->NullString();
]]>
</programlisting>
<para>This method returns a string object of zero length.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A null String object.</para>
</section>

<section id="mthObjectToCSelf"><title>&changed50;ObjectToCSelf</title>
<indexterm><primary>ObjectToCSelf</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToCSelf</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToCSelf</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ObjectToCSelf</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToCSelf</secondary></indexterm>
<!-- ObjectToCSelf --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj, scope;
POINTER ptr;

// Method Syntax Form(s)

ptr = context->ObjectToCSelf(obj);

ptr = context->ObjectToCSelf(obj, scope);
]]>
</programlisting>
<para>Returns a pointer to the CSELF value for another object.
CSELF is a special argument type used for classes to store native
pointers or structures inside an object instance.
Objects that rely on CSELF values typically set the variable CSELF inside
an INIT method for the class.
</para>
<para>This method has two forms.
The first form searches all of the object's variable scopes for
a variable named CSELF.
The second form searches for a variable named CSELF, beginning with the
indicated <emphasis role="italic">scope</emphasis> level.
If a CSELF variable is located and the value is an instance of either the
Pointer or the Buffer class, the corresponding POINTER value will be
returned as a void * value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">scope</emphasis></entry>
    <entry><para>A class object indicating the starting scope.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The CSELF value for the object.  Returns NULL if no CSELF value was found in the target object.</para>
<para>See also method
<xref linkend="mthGetCSelf" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthObjectToDouble"><title>ObjectToDouble</title>
<indexterm><primary>ObjectToDouble</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToDouble</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ObjectToDouble</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToDouble</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToDouble</secondary></indexterm>
<!-- ObjectToDouble --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
double n;
logical_t flag;

// Method Syntax Form(s)

flag = context->ObjectToDouble(obj, &n);
]]>
</programlisting>
<para>Converts an Object to a C double value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object for the conversion.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>A returned converted value.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is placed in
<emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToInt32"><title>ObjectToInt32</title>
<indexterm><primary>ObjectToInt32</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToInt32</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ObjectToInt32</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToInt32</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToInt32</secondary></indexterm>
<!-- ObjectToInt32 --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
int32_t n;
logical_t flag;

// Method Syntax Form(s)

flag = context->ObjectToInt32(obj, &n);
]]>
</programlisting>
<para>Convert an Object into a 32-bit integer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is placed in
<emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToInt64"><title>ObjectToInt64</title>
<indexterm><primary>ObjectToInt64</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToInt64</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ObjectToInt64</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToInt64</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToInt64</secondary></indexterm>
<!-- ObjectToInt64 --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
int64_t n;
logical_t flag;

// Method Syntax Form(s)

flag = context->ObjectToInt64(obj, &n);
]]>
</programlisting>
<para>Convert an Object into a 64-bit integer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is placed in
<emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToIntptr"><title>ObjectToIntptr</title>
<indexterm><primary>ObjectToIntptr</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToIntptr</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ObjectToIntptr</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToIntptr</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToIntptr</secondary></indexterm>
<!-- ObjectToIntptr --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
intptr_t n;
logical_t flag;

// Method Syntax Form(s)

flag = context->ObjectToIntptr(obj, &n);
]]>
</programlisting>
<para>Convert an Object to an intptr_t value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is placed in
<emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToLogical"><title>ObjectToLogical</title>
<indexterm><primary>ObjectToLogical</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToLogical</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ObjectToLogical</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToLogical</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToLogical</secondary></indexterm>
<!-- ObjectToLogical --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag, n;

// Method Syntax Form(s)

flag = context->ObjectToLogical(obj, &n);
]]>
</programlisting>
<para>Converts an Object to a C logical value (0 or 1).
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is placed in
<emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToString"><title>ObjectToString</title>
<indexterm><primary>ObjectToString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToString</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ObjectToString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToString</secondary></indexterm>
<!-- ObjectToString --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
RexxStringObject str;

// Method Syntax Form(s)

str = context->ObjectToString(obj);
]]>
</programlisting>
<para>Convert an Object to a String object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object for the conversion.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The String object.</para>
</section>

<section id="mthObjectToStringSize"><title>ObjectToStringSize</title>
<indexterm><primary>ObjectToStringSize</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToStringSize</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ObjectToStringSize</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToStringSize</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToStringSize</secondary></indexterm>
<!-- ObjectToStringSize --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
size_t n;
logical_t flag;

// Method Syntax Form(s)

flag = context->ObjectToStringSize(obj, &n);
]]>
</programlisting>
<para>Convert an Object to a stringsize_t number value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is placed in
<emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToStringValue"><title>ObjectToStringValue</title>
<indexterm><primary>ObjectToStringValue</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToStringValue</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ObjectToStringValue</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToStringValue</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToStringValue</secondary></indexterm>
<!-- ObjectToStringValue --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
CSTRING str;

// Method Syntax Form(s)

str = context->ObjectToStringValue(obj);
]]>
</programlisting>
<para>Convert an Object to a C ASCII-Z string.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object for the conversion.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The C ASCII-Z string representation of the object.</para>
</section>

<section id="mthObjectToUintptr"><title>ObjectToUintptr</title>
<indexterm><primary>ObjectToUintptr</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToUintptr</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ObjectToUintptr</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToUintptr</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToUintptr</secondary></indexterm>
<!-- ObjectToUintptr --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
uintptr_t n;
logical_t flag;

// Method Syntax Form(s)

flag = context->ObjectToUintptr(obj, &n);
]]>
</programlisting>
<para>Convert an Object to an uintptr_t value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is placed in
<emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToUnsignedInt32"><title>ObjectToUnsignedInt32</title>
<indexterm><primary>ObjectToUnsignedInt32</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToUnsignedInt32</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ObjectToUnsignedInt32</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToUnsignedInt32</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToUnsignedInt32</secondary></indexterm>
<!-- ObjectToUnsignedInt32 --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
uint32_t n;
logical_t flag;

// Method Syntax Form(s)

flag = context->ObjectToUnsignedInt32(obj, &n);
]]>
</programlisting>
<para>Convert an Object to an uint32_t value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is placed in
<emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToUnsignedInt64"><title>ObjectToUnsignedInt64</title>
<indexterm><primary>ObjectToUnsignedInt64</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToUnsignedInt64</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ObjectToUnsignedInt64</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToUnsignedInt64</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToUnsignedInt64</secondary></indexterm>
<!-- ObjectToUnsignedInt64 --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
uint64_t n;
logical_t flag;

// Method Syntax Form(s)

flag = context->ObjectToUnsignedInt64(obj, &n);
]]>
</programlisting>
<para>Convert an Object to an uint64_t value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is placed in
<emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToValue"><title>ObjectToValue</title>
<indexterm><primary>ObjectToValue</primary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ObjectToValue</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToValue</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToValue</secondary></indexterm>
<!-- ObjectToValue --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
ValueDescriptor desc;
logical_t flag;

// Method Syntax Form(s)

flag = context->ObjectToValue(obj, &desc);
]]>
</programlisting>
<para>Convert a Rexx object to another type.  The target type is identified
by the ValueDescriptor structure, and can be any of the types that may be
used as a method or routine return type.  For many conversions, it may be
more appropriate to use more targeted routines such as
<xref linkend="mthObjectToWholeNumber" xrefstyle="select:title"/>.
ObjectToValue() is capable
of conversions to types such as int8_t for which there are no specific conversion APIs.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
    <row><entry><emphasis role="italic">desc</emphasis></entry>
    <entry><para>A C pointer to a ValueDescriptor struct that identifies
    the conversion type.  The converted value will be stored in the ValueDescriptor if successful.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  If successful,
<emphasis role="italic">desc</emphasis> is updated with the converted
value of the requested type.
</para>
</section>

<section id="mthObjectToWholeNumber"><title>ObjectToWholeNumber</title>
<indexterm><primary>ObjectToWholeNumber</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToWholeNumber</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ObjectToWholeNumber</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToWholeNumber</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToWholeNumber</secondary></indexterm>
<!-- ObjectToWholeNumber --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
wholenumber_t n;
logical_t flag;

// Method Syntax Form(s)

flag = context->ObjectToWholeNumber(obj, &n);
]]>
</programlisting>
<para>Convert an Object to a whole number value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is placed in
<emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthPointerValue"><title>PointerValue</title>
<indexterm><primary>NPointerValue</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>PointerValue</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>PointerValue</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>PointerValue</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>PointerValue</secondary></indexterm>
<!-- PointerValue --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxPointerObject obj;
POINTER p;

// Method Syntax Form(s)

p = context->PointerValue(obj);
]]>
</programlisting>
<para>Return the wrappered C pointer value from a RexxPointerObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source RexxPointerObject.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The wrappered C pointer value.</para>
</section>

<section id="mthRaiseCondition"><title>RaiseCondition</title>
<indexterm><primary>RaiseCondition</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>RaiseCondition</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>RaiseCondition</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>RaiseCondition</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>RaiseCondition</secondary></indexterm>
<!-- RaiseCondition --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING str;
RexxStringObject sobj;
RexxArrayObject arr;
RexxObjectPtr obj;

// Method Syntax Form(s)

context->RaiseCondition(str, sobj, add, obj);
]]>
</programlisting>
<para>Raise a condition.  The raised condition is held in a pending
state until the method, routine, or exit returns to the Rexx runtime.
This is similar to using the RAISE instruction to raise a condition from
Rexx code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The condition name.</para></entry>
    </row>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The optional condition description as a String object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">add</emphasis></entry>
    <entry><para>A optional object containing additional condition information.</para></entry> </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>A Object that will be returned as a routine or
    method result if the raised condition is not trapped by the caller.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthRaiseException"><title>RaiseException</title>
<indexterm><primary>RaiseException</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>RaiseException</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>RaiseException</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>RaiseException</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>RaiseException</secondary></indexterm>
<!-- RaiseException --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
size_t n;
RexxObjectPtr obj;

// Method Syntax Form(s)

context->RaiseException(n, obj);
]]>
</programlisting>
<para>Raise a SYNTAX condition.  The raised condition is held in a pending
state until the method, routine, or exit returns to the Rexx runtime.
This is similar to using the RAISE instruction to raise a SYNTAX condition from
Rexx code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The exception condition number.  There are #defines for the
    recognized condition errors in the oorexxerrors.h include file.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>An Array of error message substitution values.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthRaiseException0"><title>RaiseException0</title>
<indexterm><primary>RaiseException0</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>RaiseException0</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>RaiseException0</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>RaiseException0</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>RaiseException0</secondary></indexterm>
<!-- RaiseException0 --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
size_t n;

// Method Syntax Form(s)

context->RaiseException0(n);
]]>
</programlisting>
<para>Raise an exception condition with no message substitution values.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The exception condition number.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthRaiseException1"><title>RaiseException1</title>
<indexterm><primary>RaiseException1</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>RaiseException1</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>RaiseException1</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>RaiseException1</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>RaiseException1</secondary></indexterm>
<!-- RaiseException1 --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
size_t n;
RexxObjectPtr obj;

// Method Syntax Form(s)

context->RaiseException1(n, obj);
]]>
</programlisting>
<para>Raise an exception condition with a single message substitution value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The exception condition number.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>A substitution value for the condition error message.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthRaiseException2"><title>RaiseException2</title>
<indexterm><primary>RaiseException2</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>RaiseException2</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>RaiseException2</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>RaiseException2</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>RaiseException2</secondary></indexterm>
<!-- RaiseException2 --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
size_t n;
RexxObjectPtr obj1, obj2;

// Method Syntax Form(s)

context->RaiseException2(n, obj1, obj2);
]]>
</programlisting>
<para>Raise an exception condition with two message substitution values.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The exception condition number.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj1</emphasis></entry>
    <entry><para>The first substitution value.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj2</emphasis></entry>
    <entry><para>The second substitution value.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthReadInput"><title>&added50;ReadInput</title>
<indexterm><primary>ReadInput</primary></indexterm>
<indexterm><primary>I/O Redirector context methods</primary>
<secondary>ReadInput</secondary></indexterm>
<!-- ReadInput --><para>&contexts_ioredirector; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING data;
size_t  length;

// Method Syntax Form(s)

context->ReadInput(&data, &length);
]]>
</programlisting>
<para>Returns the next item or line of data from an input redirection Rexx
object that was specified using the WITH subkeyword of an ADDRESS instruction.
Items are converted to strings and missing items are replaced by a null string.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">data</emphasis></entry>
    <entry><para>The returned string.
    If no more items or lines are available, NULL is returned.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">length</emphasis></entry>
    <entry><para>The returned length of <emphasis role="italic">data</emphasis>.
    If an item is missing, or no more items or lines are available,
    <literal>0</literal> is returned.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.
Arguments <emphasis role="italic">data</emphasis> and
<emphasis role="italic">length</emphasis> are updated.
</para>
<para>See also methods
<xref linkend="mthAreOutputAndErrorSameTarget" xrefstyle="select:title"/>,
<xref linkend="mthIsErrorRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsInputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsOutputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsRedirectionRequested" xrefstyle="select:title"/>,
<xref linkend="mthReadInputBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteError" xrefstyle="select:title"/>,
<xref linkend="mthWriteErrorBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteOutput" xrefstyle="select:title"/>, and
<xref linkend="mthWriteOutputBuffer" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthReadInputBuffer"><title>&added50;ReadInputBuffer</title>
<indexterm><primary>ReadInputBuffer</primary></indexterm>
<indexterm><primary>I/O Redirector context methods</primary>
<secondary>ReadInputBuffer</secondary></indexterm>
<!-- ReadInputBuffer --><para>&contexts_ioredirector; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING data;
size_t  length;

// Method Syntax Form(s)

context->ReadInputBuffer(&data, &length);
]]>
</programlisting>
<para>Returns a string of all items or lines from an input redirection Rexx
object that was specified using the WITH subkeyword of an ADDRESS instruction.
Items are converted to strings and separated by the platform-specfic line-end
characters.
Missing items are replaced by a null string.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">data</emphasis></entry>
    <entry><para>The returned string.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">length</emphasis></entry>
    <entry><para>The returned length of <emphasis role="italic">data</emphasis>.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.
Arguments <emphasis role="italic">data</emphasis> and
<emphasis role="italic">length</emphasis> are updated.
</para>
<para>See also methods
<xref linkend="mthAreOutputAndErrorSameTarget" xrefstyle="select:title"/>,
<xref linkend="mthIsErrorRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsInputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsOutputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsRedirectionRequested" xrefstyle="select:title"/>,
<xref linkend="mthReadInput" xrefstyle="select:title"/>,
<xref linkend="mthWriteError" xrefstyle="select:title"/>,
<xref linkend="mthWriteErrorBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteOutput" xrefstyle="select:title"/>, and
<xref linkend="mthWriteOutputBuffer" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthReallocateObjectMemory"><title>&added50;ReallocateObjectMemory</title>
<indexterm><primary>ReallocateObjectMemory</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ReallocateObjectMemory</secondary></indexterm>
<!-- ReallocateObjectMemory --><para>&contexts_method; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
POINTER ptr;
size_t bytes;

// Method Syntax Form(s)

ptr = context->ReallocateObjectMemory(ptr, bytes);
]]>
</programlisting>

<para>Reallocates object memory allocated with
<xref linkend="mthAllocateObjectMemory" xrefstyle="select:title"/>.
The current memory contents are copied to the new allocation and the
current allocation will be automatically freed.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">ptr</emphasis></entry>
    <entry><para>A POINTER to object memory allocated with
    <xref linkend="mthAllocateObjectMemory" xrefstyle="select:title"/> or
    reallocated with
    <xref linkend="mthReallocateObjectMemory" xrefstyle="select:title"/>.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">bytes</emphasis></entry>
    <entry><para>The new memory size in bytes.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A POINTER to the reallocated object memory.
If the new size is not larger than the currently allocated memory size,
the current object memory pointer is returned.
</para>
<para>See also methods
<xref linkend="mthAllocateObjectMemory" xrefstyle="select:title"/> and
<xref linkend="mthFreeObjectMemory" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthRegisterLibrary"><title>RegisterLibrary</title>
<indexterm><primary>RegisterLibrary</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>RegisterLibrary</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>RegisterLibrary</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>RegisterLibrary</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>RegisterLibrary</secondary></indexterm>
<!-- RegisterLibrary --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING name;
logical_t success;

// Method Syntax Form(s)

success = context->RegisterLibrary(name, table);
]]>
</programlisting>
<para>Registers an in-process library package with the global Rexx environment.  The package is
processed as if it is loaded from an external library, but without requiring the library packaging.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The ASCII-Z path/name of the library package, in format required
    by the ::REQUIRES LIBRARY directive.</para></entry>
    </row>
    <row><entry><emphasis role="italic">table</emphasis></entry>
    <entry><para>A pointer to a
RexxPackageEntry (<xref linkend="buildinglibs" />) table defining the contents of the package.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>True if the library was successfully registered.
False is returned if a package has already be loaded or registered with the given name.
</para>
</section>

<section id="mthReleaseGlobalReference"><title>ReleaseGlobalReference</title>
<indexterm><primary>ReleaseGlobalReference</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ReleaseGlobalReference</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ReleaseGlobalReference</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ReleaseGlobalReference</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ReleaseGlobalReference</secondary></indexterm>
<!-- ReleaseGlobalReference --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr ref;

// Method Syntax Form(s)

context->ReleaseGlobalReference(ref);
]]>
</programlisting>
<para>Release access to a global object reference.  This removes the global
garbage collection protection from the object reference.  Once released,
<emphasis role="italic">ref</emphasis> should no longer be used for object operations.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">ref</emphasis></entry>
    <entry><para>A global Rexx object reference.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthReleaseLocalReference"><title>ReleaseLocalReference</title>
<indexterm><primary>ReleaseLocalReference</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ReleaseLocalReference</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ReleaseLocalReference</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ReleaseLocalReference</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ReleaseLocalReference</secondary></indexterm>
<!-- ReleaseLocalReference --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr ref;

// Method Syntax Form(s)

context->ReleaseLocalReference(ref);
]]>
</programlisting>
<para>Removes local context protection from an object reference.
Once released,
<emphasis role="italic">ref</emphasis> should no longer be used for object operations.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">ref</emphasis></entry>
    <entry><para>The local Rexx object reference.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthRequestGlobalReference"><title>RequestGlobalReference</title>
<indexterm><primary>RequestGlobalReference</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>RequestGlobalReference</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>RequestGlobalReference</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>RequestGlobalReference</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>RequestGlobalReference</secondary></indexterm>
<!-- RequestGlobalReference --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr ref, obj;

// Method Syntax Form(s)

ref = context->RequestGlobalReference(obj);
]]>
</programlisting>
<para>Requests global garbage collection protection for an object reference.
The returned value may be saved in native code control blocks and used as an object reference
in any API context.  The <emphasis role="italic">obj</emphasis> will be protected
from garbage collection until the global reference is released with
<xref linkend="mthReleaseGlobalReference" xrefstyle="select:title"/>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The Rexx object to be protected.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A global reference to this object that can be saved and used in any
API context.</para>
</section>

<section id="mthResolveStemVariable"><title>ResolveStemVariable</title>
<indexterm><primary>ResolveStemVariable</primary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ResolveStemVariable</secondary></indexterm>
<!-- ResolveStemVariable --><para>&contexts_call;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
RexxStemObject stem;

// Method Syntax Form(s)

stem = context->ResolveStemVariable(obj);
]]>
</programlisting>
<para>Resolves a stem variable object using the same mechanism applied to
RexxStemObject arguments passed to routines.  If
<emphasis role="italic">obj</emphasis> is a Stem object, the same Stem
object will be returned.  If <emphasis role="italic">obj</emphasis>
is a String object, the string value is used to resolve a stem variable
from the caller's variable context.  The Stem object value of the referenced
stem variable is returned as a result.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object to be resolved to a Stem object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The resolved Stem object.</para>
</section>

<section id="mthSendMessage"><title>SendMessage</title>
<indexterm><primary>SendMessage</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SendMessage</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>SendMessage</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SendMessage</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SendMessage</secondary></indexterm>
<!-- SendMessage --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj, ret;
RexxArrayObject arr;

// Method Syntax Form(s)

ret = context->SendMessage(obj, meg, arr);
]]>
</programlisting>
<para>Send a message to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to receive the message.</para></entry>
    </row>
    <row><entry><emphasis role="italic">msg</emphasis></entry>
    <entry><para>An ASCII-Z string containing the message name. This argument will be converted to upper case automatically.</para></entry>
    </row>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The Array of message arguments.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The returned object. If the method does not return an object
then NULLOBJECT is returned.
Any errors resulting from invoking the method
will return a NULLOBJECT value.  The
<xref linkend="mthCheckCondition" xrefstyle="select:title"/>
can be used to check if an error occurred during the call.
</para>
</section>

<section id="mthSendMessage0"><title>SendMessage0</title>
<indexterm><primary>SendMessage0</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SendMessage0</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>SendMessage0</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SendMessage0</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SendMessage0</secondary></indexterm>
<!-- SendMessage0 --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj, ret;

// Method Syntax Form(s)

ret = context->SendMessage0(obj, meg);
]]>
</programlisting>
<para>Send a message to an Object.
This is a short cut method when no arguments are needed by the receiving object method.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to receive the message.</para></entry>
    </row>
    <row><entry><emphasis role="italic">msg</emphasis></entry>
    <entry><para>An ASCII-Z string containing the message name. This argument will be converted to upper case automatically.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The returned object. If the method does not return an object
then NULLOBJECT is returned.
Any errors resulting from invoking the method
will return a NULLOBJECT value.  The
<xref linkend="mthCheckCondition" xrefstyle="select:title"/>
can be used to check if an error occurred during the call.
</para>
</section>

<section id="mthSendMessage1"><title>SendMessage1</title>
<indexterm><primary>SendMessage1</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SendMessage1</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>SendMessage1</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SendMessage1</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SendMessage1</secondary></indexterm>
<!-- SendMessage1 --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj, ret, arg1;

// Method Syntax Form(s)

ret = context->SendMessage2(obj, meg, arg1);
]]>
</programlisting>
<para>Send a message to an Object.
This is a short cut method when only one argument is needed by the receiving object method.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to receive the message.</para></entry>
    </row>
    <row><entry><emphasis role="italic">msg</emphasis></entry>
    <entry><para>An ASCII-Z string containing the message name. This argument will be converted to upper case automatically.</para></entry>
    </row>
    <row><entry><emphasis role="italic">arg1</emphasis></entry>
    <entry><para>The first argument to the receiving method.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The returned object. If the method does not return an object
then NULLOBJECT is returned.
Any errors resulting from invoking the method
will return a NULLOBJECT value.  The
<xref linkend="mthCheckCondition" xrefstyle="select:title"/>
can be used to check if an error occurred during the call.
</para>
</section>

<section id="mthSendMessage2"><title>SendMessage2</title>
<indexterm><primary>SendMessage2</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SendMessage2</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>SendMessage2</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SendMessage2</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SendMessage2</secondary></indexterm>
<!-- SendMessage2 --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj, ret, arg1, arg2;

// Method Syntax Form(s)

ret = context->SendMessage2(obj, meg, arg1, arg2);
]]>
</programlisting>
<para>Send a message to an Object.
This is a short cut method when only two arguments are needed by the receiving object method.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to receive the message.</para></entry>
    </row>
    <row><entry><emphasis role="italic">msg</emphasis></entry>
    <entry><para>An ASCII-Z string containing the message name. This argument will be converted to upper case automatically.</para></entry>
    </row>
    <row><entry><emphasis role="italic">arg1</emphasis></entry>
    <entry><para>The first argument to the receiving method.</para></entry>
    </row>
    <row><entry><emphasis role="italic">arg2</emphasis></entry>
    <entry><para>The second argument to the receiving method.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The returned object. If the method does not return an object
then NULLOBJECT is returned.
Any errors resulting from invoking the method
will return a NULLOBJECT value.  The
<xref linkend="mthCheckCondition" xrefstyle="select:title"/>
can be used to check if an error occurred during the call.
</para>
</section>

<section id="mthSetContextVariable"><title>SetContextVariable</title>
<indexterm><primary>SetContextVariable</primary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>SetContextVariable</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SetContextVariable</secondary></indexterm>
<!-- SetContextVariable --><para>&contexts_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
CSTRING name;

// Method Syntax Form(s)

context->SetContextVariable(name, obj);
]]>
</programlisting>
<para>Sets the value of a Rexx variable in the current call context.
Only simple and stem variables may be set using SetContextVariable().
Compound variable values may be set by retrieving the Stem object associated
with a stem variable and using <xref linkend="mthSetStemElement" xrefstyle="select:title"/>
to set the associated compound variable.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The name of the Rexx variable.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to assign to the variable.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthSetGuardOff"><title>SetGuardOff</title>
<indexterm><primary>SetGuardOff</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SetGuardOff</secondary></indexterm>
<!-- SetGuardOff --><para>&contexts_method;.</para>
<programlisting language="C++">
<![CDATA[
// Method Syntax Form(s)

context->SetGuardOff();
]]>
</programlisting>
<para>Release the guard lock for this method scope.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
<para>See also methods
<xref linkend="mthSetGuardOn" xrefstyle="select:title"/>,
<xref linkend="mthSetGuardOnWhenUpdated" xrefstyle="select:title"/>, and
<xref linkend="mthSetGuardOffWhenUpdated" xrefstyle="select:title"/>.
</para>
</section>


<section id="mthSetGuardOffWhenUpdated" revisionflag="added"><title>&added50;SetGuardOffWhenUpdated</title>
<indexterm><primary>SetGuardOffWhenUpdated</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SetGuardOffWhenUpdated</secondary></indexterm>
<!-- SetGuardOffWhenUpdated --><para>&contexts_method; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING name;
RexxObjectPtr ret;

// Method Syntax Form(s)

ret = context->SetGuardOffWhenUpdated(name);
]]>
</programlisting>
<para>Waits for an object variable to be updated and returns the new value.
The guard state will be OFF on return.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
  <row><entry><emphasis role="italic">name</emphasis></entry>
  <entry><para>The name of the variable to wait for.
  Only simple variables or stem variables are allowed, no compound variables.
  </para></entry>
  </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new value of the variable.
Returns a NULLOBJECT if an error occurs.
</para>
<para>See also methods
<xref linkend="mthSetGuardOn" xrefstyle="select:title"/>,
<xref linkend="mthSetGuardOnWhenUpdated" xrefstyle="select:title"/>, and
<xref linkend="mthSetGuardOff" xrefstyle="select:title"/>.
</para>
</section>


<section id="mthSetGuardOn"><title>SetGuardOn</title>
<indexterm><primary>SetGuardOn</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SetGuardOn</secondary></indexterm>
<!-- SetGuardOn --><para>&contexts_method;.</para>
<programlisting language="C++">
<![CDATA[
// Method Syntax Form(s)

context->SetGuardOn();
]]>
</programlisting>
<para>Obtain the guard lock for this object scope.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
<para>See also methods
<xref linkend="mthSetGuardOnWhenUpdated" xrefstyle="select:title"/>,
<xref linkend="mthSetGuardOff" xrefstyle="select:title"/>, and
<xref linkend="mthSetGuardOffWhenUpdated" xrefstyle="select:title"/>.
</para>
</section>


<section id="mthSetGuardOnWhenUpdated" revisionflag="added"><title>&added50;SetGuardOnWhenUpdated</title>
<indexterm><primary>SetGuardOnWhenUpdated</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SetGuardOnWhenUpdated</secondary></indexterm>
<!-- SetGuardOnWhenUpdated --><para>&contexts_method; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING name;
RexxObjectPtr ret;

// Method Syntax Form(s)

ret = context->SetGuardOnWhenUpdated(name);
]]>
</programlisting>
<para>Waits for an object variable to be updated and returns the new value.
The guard state will be ON on return.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
  <row><entry><emphasis role="italic">name</emphasis></entry>
  <entry><para>The name of the variable to wait for.
  Only simple variables or stem variables are allowed, no compound variables.
  </para></entry>
  </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new value of the variable.
Returns a NULLOBJECT if an error occurs.
</para>
<para>See also methods
<xref linkend="mthSetGuardOn" xrefstyle="select:title"/>,
<xref linkend="mthSetGuardOff" xrefstyle="select:title"/>, and
<xref linkend="mthSetGuardOffWhenUpdated" xrefstyle="select:title"/>.
</para>
</section>


<section id="mthSetMutableBufferCapacity"><title>SetMutableBufferCapacity</title>
<indexterm><primary>SetMutableBufferCapacity</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SetMutableBufferCapacity</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>SetMutableBufferCapacity</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SetMutableBufferCapacity</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SetMutableBufferCapacity</secondary></indexterm>
<!-- SetMutableBufferCapacity --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxMutableBufferObject obj;
size_t len;
POINTER data;

// Method Syntax Form(s)

data = context->SetMutableBufferCapacity(obj,len);
]]>
</programlisting>
<para>Ensure the MutableBuffer object's data area is at least the indicated size.  If necessary,
the internal data area will be reallocated.  SetMutableBufferCapacity will only change the capacity
if <emphasis role="italic">len</emphasis> is larger than the current buffer capacity.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source MutableBuffer object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">len</emphasis></entry>
    <entry><para>The required buffer capacity.  If <emphasis role="italic">len</emphasis>
is larger than the current data area, the internal data area will be reallocated to the larger size and
any existing buffer data will be copied to the new data area.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A pointer to the MutableBuffer's data area.  Because SetMutableBufferCapacity()
may reallocate the data area, the return value should replace any previous buffer pointers.</para>
</section>

<section id="mthSetMutableBufferLength"><title>SetMutableBufferLength</title>
<indexterm><primary>SetMutableBufferLength</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SetMutableBufferLength</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>SetMutableBufferLength</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SetMutableBufferLength</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SetMutableBufferLength</secondary></indexterm>
<!-- SetMutableBufferLength --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxMutableBufferObject obj;
size_t len;
size_t newLen;

// Method Syntax Form(s)

newLen = context->SetMutableBufferLength(obj,len);
]]>
</programlisting>
<para>Sets the length of the data in the MutableBuffer's data area.  If the length is greater than
the current capacity, then it will be capped at the current capacity.
If <emphasis role="italic">len</emphasis> is longer than the buffer's current data length, data will be
padded with '00'x characters for the additional length.  When adding characters to the buffer's data area, you
should call SetMutableBufferLength() before copying the additional data into the buffer.  If additional capacity
is required, use <xref linkend="mthSetMutableBufferCapacity" xrefstyle="select:title"/>
to increase the buffer size.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source MutableBuffer object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">len</emphasis></entry>
    <entry><para>The new data length.  If <emphasis role="italic">len</emphasis>
is larger than the current data area, the new length will be capped at the length of the data area.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new data length, which may be less than the indicated length if the buffer capacity is smaller.
</para>
</section>

<section id="mthSetObjectVariable"><title>SetObjectVariable</title>
<indexterm><primary>SetObjectVariable</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SetObjectVariable</secondary></indexterm>
<!-- SetObjectVariable --><para>&contexts_method;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING str;
RexxObjectPtr obj;

// Method Syntax Form(s)

context->SetObjectVariable(str, obj);
]]>
</programlisting>
<para>Sets an instance variable in the current method's variable scope to a new value.
Only simple and stem variables may be set using this API.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The name of the object variable.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to assign to the object variable.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthSetStemArrayElement"><title>SetStemArrayElement</title>
<indexterm><primary>SetStemArrayElement</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SetStemArrayElement</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>SetStemArrayElement</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SetStemArrayElement</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SetStemArrayElement</secondary></indexterm>
<!-- SetStemArrayElement --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxStemObject sobj;
RexxObjectPtr obj;
size_t n;

// Method Syntax Form(s)

context->SetStemArrayElement(sobj, n, obj);
]]>
</programlisting>
<para>Sets an element of the Stem object. If the element exists it is replaced.
This method uses a numeric index as the element name.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The target Stem object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The Stem object element number.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object value assigned to the Stem object element.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthSetStemElement"><title>SetStemElement</title>
<indexterm><primary>SetStemElement</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SetStemElement</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>SetStemElement</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SetStemElement</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SetStemElement</secondary></indexterm>
<!-- SetStemElement --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxStemObject sobj;
RexxObjectPtr obj;
CSTRING name;

// Method Syntax Form(s)

context->SetStemElement(sobj, name, obj);
]]>
</programlisting>
<para>Sets an element of the Stem object. If the element exists it is replaced.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The target Stem object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The Stem object element name.  This is a fully resolve Stem tail element.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object value assigned to the Stem object element.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthSetThreadTrace"><title>SetThreadTrace</title>
<indexterm><primary>SetThreadTrace</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SetThreadTrace</secondary></indexterm>
<!-- SetThreadTrace --><para>&contexts_thread;.</para>
<programlisting language="C++">
<![CDATA[
logical_t flag;

// Method Syntax Form(s)

context->SetThreadTrace(flag);
]]>
</programlisting>
<para>Sets the interactive trace state for the current thread.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">flag</emphasis></entry>
    <entry><para>New state for interactive trace.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthSetTrace"><title>SetTrace</title>
<indexterm><primary>SetTrace</primary></indexterm>
<indexterm><primary>Rexx instance context methods</primary>
<secondary>SetTrace</secondary></indexterm>
<!-- SetTrace --><para>&contexts_instance;.</para>
<programlisting language="C++">
<![CDATA[
logical_t flag;

// Method Syntax Form(s)

context->SetTrace(flag);
]]>
</programlisting>
<para>Sets the interactvive trace state for the interpreter instance.  This will enable tracing in
all active threads for the interpreter instance.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">flag</emphasis></entry>
    <entry><para>The new trace state.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>


<section id="mthSetVariableReferenceValue" revisionflag="added"><title>&added50;SetVariableReferenceValue</title>
<indexterm><primary>SetVariableReferenceValue</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SetVariableReferenceValue</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SetVariableReferenceValue</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>SetVariableReferenceValue</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SetVariableReferenceValue</secondary></indexterm>
<!-- SetVariableReferenceValue --><para>&contexts_thread_method_call_exit; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
RexxVariableReferenceObject ref;
RexxObjectPtr value;

// Method Syntax Form(s)

context->SetVariableReferenceValue(ref, value);
]]>
</programlisting>
<para>Sets the value of VariableReference object
<emphasis role="italic">ref</emphasis> to
<emphasis role="italic">value</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">ref</emphasis></entry>
    <entry><para>The VariableReference object.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">value</emphasis></entry>
    <entry><para>The object instance to be set as the value.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
<para>See also methods
<xref linkend="mthGetContextVariableReference" xrefstyle="select:title"/>,
<xref linkend="mthGetObjectVariableReference" xrefstyle="select:title"/>,
<xref linkend="mthIsVariableReference" xrefstyle="select:title"/>,
<xref linkend="mthVariableReferenceName" xrefstyle="select:title"/>, and
<xref linkend="mthVariableReferenceValue" xrefstyle="select:title"/>.
</para>
</section>


<section id="mthString"><title>String</title>
<indexterm><primary>String</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>String</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>String</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>String</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>String</secondary></indexterm>
<!-- String --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxRoutineObject obj;
CSTRING str;
size_t len;

// Method Syntax Form(s)

obj = context->String(str, len);

obj = context->String(str);
]]>
</programlisting>
<para>There are two forms of this method. Both create a new String object from a C string.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The ASCII-Z string to be converted.</para></entry>
    </row>
    <row><entry><emphasis role="italic">len</emphasis></entry>
    <entry><para>Length of the <emphasis role="italic">str</emphasis> string.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A new String object.</para>
</section>

<section id="mthStringData"><title>StringData</title>
<indexterm><primary>StringData</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringData</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>StringData</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringData</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringData</secondary></indexterm>
<!-- StringData --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
CSTRING str;

// Method Syntax Form(s)

str = context->StringData(obj);
]]>
</programlisting>
<para>Returns a pointer to the String object's string data (for read-only).
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source String object for the data.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A pointer to the String object's string data.</para>
<para>The data pointed to does have a trailing <literal>\0</literal> character,
but note that also the data itself (like any Rexx string) may
contain embedded <literal>\0</literal> characters.
The program <emphasis role="bold">must not</emphasis> modify the data
the returned pointer points to.
</para>
</section>

<section id="mthStringGet"><title>StringGet</title>
<indexterm><primary>StringGet</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringGet</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>StringGet</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringGet</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringGet</secondary></indexterm>
<!-- StringGet --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
POINTER str;
size_t c, len1, len2;

// Method Syntax Form(s)

c = context->StringGet(obj, len1, str, len2);
]]>
</programlisting>
<para>Copies all or part of the String object to a C string buffer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source String object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">len1</emphasis></entry>
    <entry><para>The starting position within the String.
       This argument is 1-based</para></entry>
    </row>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>A pointer to the target buffer for the copy. Note that the buffer is
       NOT zero-terminated.</para></entry>
    </row>
    <row><entry><emphasis role="italic">len2</emphasis></entry>
    <entry><para>The number of characters to copy. This argument should be less than or equal the
       size of the <emphasis role="italic">str</emphasis> buffer or a buffer overrun will result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The number of characters actually copied.</para>
</section>

<section id="mthStringLength"><title>StringLength</title>
<indexterm><primary>StringLength</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringLength</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>StringLength</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringLength</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringLength</secondary></indexterm>
<!-- StringLength --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
size_t sz;

// Method Syntax Form(s)

sz = context->StringLength(obj);
]]>
</programlisting>
<para>Return the length a String object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source String object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The string length of the String object.</para>
</section>

<section id="mthStringLower"><title>StringLower</title>
<indexterm><primary>StringLower</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringLower</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>StringLower</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringLower</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringLower</secondary></indexterm>
<!-- StringLower --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr srcobj, newobj;

// Method Syntax Form(s)

newobj = context->StringLower(srcobj);
]]>
</programlisting>
<para>Convert a String object to lower case, returning a new String object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">srcobj</emphasis></entry>
    <entry><para>The source String object to be converted to lower case.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A new String object with the string value lower cased.</para>
</section>

<section id="mthStringSize"><title>StringSize</title>
<indexterm><primary>StringSize</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringSize</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>StringSize</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringSize</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringSize</secondary></indexterm>
<!-- StringSize --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;
stringsize_t n;

// Method Syntax Form(s)

obj = context->StringSize(n);

flag = context->StringSize(obj, &n);
]]>
</programlisting>
<para>There are two forms of this method.
The first converts the stringsize_t value <emphasis role="italic">n</emphasis> to an Object.
The second converts an Object to a stringsize_t value and returns it in
<emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>For the first form, the stringsize_t value to be converted.
       For the second form, the target of the conversion.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>For the first form, an Object representation of the integer value.
For the second form, 1 = success, 0 = failure.  If successful, the converted value is
placed in <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthStringSizeToObject"><title>StringSizeToObject</title>
<indexterm><primary>StringSizeToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringSizeToObject</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>StringSizeToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringSizeToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringSizeToObject</secondary></indexterm>
<!-- StringSizeToObject --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
size_t sz;

// Method Syntax Form(s)

obj = context->StringSizeToObject(sz);
]]>
</programlisting>
<para>Convert a stringsize_t value to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">sz</emphasis></entry>
    <entry><para>The stringsize_t value to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object that represents the C stringsize_t value.</para>
</section>


<section id="mthStringTableAt" revisionflag="added"><title>&added50;StringTableAt</title>
<indexterm><primary>StringTableAt</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringTableAt</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>StringTableAt</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringTableAt</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringTableAt</secondary></indexterm>
<!-- StringTableAt --><para>&contexts_thread_method_call_exit; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
RexxStringTableObject strtab_obj;
RexxObjectPtr obj;
CSTRING str;

// Method Syntax Form(s)

obj = context->StringTableAt(strtab_obj, str);
]]>
</programlisting>
<para>Return the object at the specified index.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">strtab_obj</emphasis></entry>
    <entry><para>The source StringTable object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The index into the StringTable object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object at the specified index.  Returns NULLOBJECT if the given index does not exist.
</para>
<para>See also methods
<xref linkend="mthIsStringTable" xrefstyle="select:title"/>,
<xref linkend="mthNewStringTable" xrefstyle="select:title"/>,
<xref linkend="mthStringTablePut" xrefstyle="select:title"/>, and
<xref linkend="mthStringTableRemove" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthStringTablePut" revisionflag="added"><title>&added50;StringTablePut</title>
<indexterm><primary>StringTablePut</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringTablePut</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>StringTablePut</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringTablePut</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringTablePut</secondary></indexterm>
<!-- StringTablePut --><para>&contexts_thread_method_call_exit; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
RexxStringTableObject strtab_obj;
RexxObjectPtr item;
CSTRING index;

// Method Syntax Form(s)

context->StringTablePut(strtab_obj, item, index);
]]>
</programlisting>
<para>Replace/add an Object at the specified StringTable index.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">strtab_obj</emphasis></entry>
    <entry><para>The source StringTable object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">item</emphasis></entry>
    <entry><para>The object instance to be stored at the index.</para></entry>
    </row>
    <row><entry><emphasis role="italic">index</emphasis></entry>
    <entry><para>The ASCII-Z string index into the StringTable object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
<para>See also methods
<xref linkend="mthIsStringTable" xrefstyle="select:title"/>,
<xref linkend="mthNewStringTable" xrefstyle="select:title"/>,
<xref linkend="mthStringTableAt" xrefstyle="select:title"/>, and
<xref linkend="mthStringTableRemove" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthStringTableRemove" revisionflag="added"><title>&added50;StringTableRemove</title>
<indexterm><primary>StringTableRemove</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringTableRemove</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>StringTableRemove</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringTableRemove</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringTableRemove</secondary></indexterm>
<!-- StringTableRemove --><para>&contexts_thread_method_call_exit; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
RexxStringTableObject strtab_obj;
RexxObjectPtr obj;
CSTRING str;

// Method Syntax Form(s)

obj = context->StringTableRemove(strtab_obj, str);
]]>
</programlisting>
<para>Removes and returns the object at the specified StringTable index.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">strtab_obj</emphasis></entry>
    <entry><para>The source StringTable object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The ASCII-Z index into the StringTable object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object removed at the specified index.  Returns NULLOBJECT if the index
did not exist in the target StringTable.
</para>
<para>See also methods
<xref linkend="mthIsStringTable" xrefstyle="select:title"/>,
<xref linkend="mthNewStringTable" xrefstyle="select:title"/>,
<xref linkend="mthStringTableAt" xrefstyle="select:title"/>, and
<xref linkend="mthStringTablePut" xrefstyle="select:title"/>.
</para>
</section>


<section id="mthStringUpper"><title>StringUpper</title>
<indexterm><primary>StringUpper</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringUpper</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>StringUpper</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringUpper</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringUpper</secondary></indexterm>
<!-- StringUpper --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr srcobj, newobj;

// Method Syntax Form(s)

newobj = context->StringUpper(srcobj);
]]>
</programlisting>
<para>Convert a String object upper case, returning a new String object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">srcobj</emphasis></entry>
    <entry><para>The source String object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A new String object with the string value upper cased.</para>
</section>

<section id="mthSupplierAvailable"><title>SupplierAvailable</title>
<indexterm><primary>SupplierAvailable</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SupplierAvailable</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>SupplierAvailable</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SupplierAvailable</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SupplierAvailable</secondary></indexterm>
<!-- SupplierAvailable --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxSupplierObjectPtr sobj;
logical_t flag;

// Method Syntax Form(s)

flag = context->SupplierAvailable(sobj);
]]>
</programlisting>
<para>Returns 1 if there is another supplier item available.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source supplier object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = another item available, 0 = no item available.</para>
</section>

<section id="mthSupplierIndex"><title>SupplierIndex</title>
<indexterm><primary>SupplierIndex</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SupplierIndex</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>SupplierIndex</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SupplierIndex</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SupplierIndex</secondary></indexterm>
<!-- SupplierIndex --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxSupplierObjectPtr sobj;
RexxObjectPtr obj;

// Method Syntax Form(s)

obj = context->SupplierIndex(sobj);
]]>
</programlisting>
<para>Return the current supplier object index value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source supplier object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The index object at the current supplier position.</para>
</section>

<section id="mthSupplierItem"><title>SupplierItem</title>
<indexterm><primary>SupplierItem</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SupplierItem</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>SupplierItem</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SupplierItem</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SupplierItem</secondary></indexterm>
<!-- SupplierItem --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxSupplierObjectPtr sobj;
RexxObjectPtr obj;

// Method Syntax Form(s)

obj = context->SupplierItem(sobj);
]]>
</programlisting>
<para>Return the current supplier item object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source supplier object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object item at the current supplier position.</para>
</section>

<section id="mthSupplierNext"><title>SupplierNext</title>
<indexterm><primary>SupplierNext</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SupplierNext</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>SupplierNext</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SupplierNext</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SupplierNext</secondary></indexterm>
<!-- SupplierNext --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxSupplierObjectPtr sobj;

// Method Syntax Form(s)

context->SupplierNext(sobj);
]]>
</programlisting>
<para>Advance a Supplier object to the next enumeration position.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source supplier object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthTerminate"><title>Terminate</title>
<indexterm><primary>Terminate</primary></indexterm>
<indexterm><primary>Rexx instance context methods</primary>
<secondary>Terminate</secondary></indexterm>
<!-- Terminate --><para>&contexts_instance;.</para>
<programlisting language="C++">
<![CDATA[
// Method Syntax Form(s)

context->Terminate();
]]>
</programlisting>
<para>Terminates the current Rexx interpreter instance.  Terminate() may
only be called from the thread context that originally created the interpreter
instance.  This call will wait for all threads to complete processing before
returning.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthTrue"><title>True</title>
<indexterm><primary>True</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>True</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>True</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>True</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>True</secondary></indexterm>
<!-- True --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;

// Method Syntax Form(s)

obj = context->True();
]]>
</programlisting>
<para>This method returns the Rexx .true object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Rexx .true object.</para>
</section>

<section id="mthUintptr"><title>Uintptr</title>
<indexterm><primary>Uintptr</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Uintptr</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>Uintptr</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Uintptr</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Uintptr</secondary></indexterm>
<!-- Uintptr --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;
uintptr_t n;

// Method Syntax Form(s)

obj = context->Uintptr(&n);

flag = context->Uintptr(obj, &n);
]]>
</programlisting>
<para>There are two forms of this method.
The first converts the uintptr_t value <emphasis role="italic">n</emphasis> to an Object.
The second converts an Object to a uintptr_t value and returns it in
<emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>For the first form, the uintptr_t value to be converted.
    For the second form, the target of the conversion.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>For the first form, an Object version of the integer.
The second form returns 1 = success, 0 = failure.
If successful, the converted value is placed in
<emphasis role="bold">n</emphasis>.</para>
</section>

<section id="mthUintptrToObject"><title>UintptrToObject</title>
<indexterm><primary>UintptrToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>UintptrToObject</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>UintptrToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>UintptrToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>UintptrToObject</secondary></indexterm>
<!-- UintptrToObject --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
uintptr_t n;

// Method Syntax Form(s)

obj = context->UintptrToObject(&n);
]]>
</programlisting>
<para>Convert a uintptr_t value <emphasis role="italic">n</emphasis> to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The uintptr_t value to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>An Object that represents the uintptr_t value.</para>
</section>

<section id="mthUnsignedInt32"><title>UnsignedInt32</title>
<indexterm><primary>UnsignedInt32</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>UnsignedInt32</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>UnsignedInt32</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>UnsignedInt32</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>UnsignedInt32</secondary></indexterm>
<!-- UnsignedInt32 --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;
uint32_t n;

// Method Syntax Form(s)

obj = context->UnsignedInt32(n);

flag = context->UnsignedInt32(obj, &n);
]]>
</programlisting>
<para>There are two forms of this method.
The first converts a C 32-bit unsigned integer <emphasis role="italic">n</emphasis> to an Object.
The second converts an Object to a uint32_t value and returns it in
<emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>For the first form, the uint32_t value to be converted.
       For the second form, the target of the conversion.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The object to be converted to a uint32_t value.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>For the first form, an Object version of the integer value.
For the second form, returns 1 = success, 0 = failure.  If successful, the converted value is
placed in <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthUnsignedInt32ToObject"><title>UnsignedInt32ToObject</title>
<indexterm><primary>UnsignedInt32ToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>UnsignedInt32ToObject</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>UnsignedInt32ToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>UnsignedInt32ToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>UnsignedInt32ToObject</secondary></indexterm>
<!-- UnsignedInt32ToObject --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
uint32_t n;

// Method Syntax Form(s)

obj = context->UnsignedInt32ToObject(n);
]]>
</programlisting>
<para>Convert a C 32-bit unsigned integer <emphasis role="italic">n</emphasis> to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The uint32_t value to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>An Object that represents the C unsigned integer.</para>
</section>

<section id="mthUnsignedInt64"><title>UnsignedInt64</title>
<indexterm><primary>UnsignedInt64</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>UnsignedInt64</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>UnsignedInt64</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>UnsignedInt64</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>UnsignedInt64</secondary></indexterm>
<!-- UnsignedInt64 --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
logical_t flag;
uint64_t n;

// Method Syntax Form(s)

obj = context->UnsignedInt64(n);

flag = context->UnsignedInt64(obj, &n);
]]>
</programlisting>
<para>There are two forms of this method.
The first converts a C 64-bit unsigned integer <emphasis role="italic">n</emphasis> to an Object.
The second converts an Object to a uint64_t value and returns it in
<emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>For the first form, the uint64_t value to be converted.
       For the second form, the target of the conversion.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>For the first form, an Object version of the integer value.
For the second form, returns 1 = success, 0 = failure.  If successful, the converted value is
placed in <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthUnsignedInt64ToObject"><title>UnsignedInt64ToObject</title>
<indexterm><primary>UnsignedInt64ToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>UnsignedInt64ToObject</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>UnsignedInt64ToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>UnsignedInt64ToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>UnsignedInt64ToObject</secondary></indexterm>
<!-- UnsignedInt64ToObject --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
uint64_t n;

// Method Syntax Form(s)

obj = context->UnsignedInt64ToObject(n);
]]>
</programlisting>
<para>Convert a C 64-bit unsigned integer <emphasis role="italic">n</emphasis> to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The uint64_t value to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>An Object that represents the C unsigned integer.</para>
</section>

<section id="mthValuesToObject"><title>ValuesToObject</title>
<indexterm><primary>ValuesToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ValuesToObject</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ValuesToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ValuesToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ValuesToObject</secondary></indexterm>
<!-- ValuesToObject --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxArrayObj obj;
ValueDescriptor desc[3];

// Method Syntax Form(s)

obj = context->ValuesToObject(desc);
]]>
</programlisting>
<para>Converts an array of ValueDescriptor structs to an Array of objects.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">desc</emphasis></entry>
    <entry><para>A C pointer to the ValueDescriptor struct array to be converted.  The end of the
    array is marked by a ValueDescriptor struct with all fields set to zero.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A Array object containing the converted objects.</para>
</section>

<section id="mthValueToObject"><title>ValueToObject</title>
<indexterm><primary>ValueToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ValueToObject</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>ValueToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ValueToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ValueToObject</secondary></indexterm>
<!-- ValueToObject --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
ValueDescriptor desc;;

// Method Syntax Form(s)

obj = context->ValueToObject(&desc);
]]>
</programlisting>
<para>Convert a type to an Object representation.  The source type is identified
by the ValueDescriptor structure, and can be any of the types that may be
used as a method or routine return types.  For many conversions, it may be
more appropriate to use more targeted routines such as
<xref linkend="mthWholeNumberToObject" xrefstyle="select:title"/>.
ValueToObject() is capable of converting to types such as int8_t for which
there are no specific conversion APIs.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">desc</emphasis></entry>
    <entry><para>A C pointer to the ValueDescriptor struct describing the source value.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object representing the converted value.</para>
</section>


<section id="mthVariableReferenceName" revisionflag="added"><title>&added50;VariableReferenceName</title>
<indexterm><primary>VariableReferenceName</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>VariableReferenceName</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>VariableReferenceName</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>VariableReferenceName</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>VariableReferenceName</secondary></indexterm>
<!-- VariableReferenceName --><para>&contexts_thread_method_call_exit; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
RexxVariableReferenceObject ref;
RexxStringObject name;

// Method Syntax Form(s)

name = context->VariableReferenceName(ref);
]]>
</programlisting>
<para>Returns the name of VariableReference object
<emphasis role="italic">ref</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">ref</emphasis></entry>
    <entry><para>The VariableReference object instance.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The name of the VariableReference as a String.</para>
<para>See also methods
<xref linkend="mthGetContextVariableReference" xrefstyle="select:title"/>,
<xref linkend="mthGetObjectVariableReference" xrefstyle="select:title"/>,
<xref linkend="mthIsVariableReference" xrefstyle="select:title"/>,
<xref linkend="mthSetVariableReferenceValue" xrefstyle="select:title"/>, and
<xref linkend="mthVariableReferenceValue" xrefstyle="select:title"/>.
</para>
</section>


<section id="mthVariableReferenceValue" revisionflag="added"><title>&added50;VariableReferenceValue</title>
<indexterm><primary>VariableReferenceValue</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>VariableReferenceValue</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>VariableReferenceValue</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>VariableReferenceValue</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>VariableReferenceValue</secondary></indexterm>
<!-- VariableReferenceValue --><para>&contexts_thread_method_call_exit; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
RexxVariableReferenceObject ref;
RexxObjectPtr value;

// Method Syntax Form(s)

value = context->VariableReferenceValue(ref);
]]>
</programlisting>
<para>Returns the name of VariableReference object
<emphasis role="italic">ref</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">ref</emphasis></entry>
    <entry><para>The VariableReference object instance.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The value of the VariableReference.</para>
<para>See also methods
<xref linkend="mthGetContextVariableReference" xrefstyle="select:title"/>,
<xref linkend="mthGetObjectVariableReference" xrefstyle="select:title"/>,
<xref linkend="mthIsVariableReference" xrefstyle="select:title"/>,
<xref linkend="mthSetVariableReferenceValue" xrefstyle="select:title"/>, and
<xref linkend="mthVariableReferenceName" xrefstyle="select:title"/>.
</para>
</section>


<section id="mthWholeNumber"><title>WholeNumber</title>
<indexterm><primary>WholeNumber</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>WholeNumber</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>WholeNumber</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>WholeNumber</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>WholeNumber</secondary></indexterm>
<!-- WholeNumber --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
wholenumber_t n;
logical_t flag;

// Method Syntax Form(s)

obj = context->WholeNumber(n);

flag = context->WholeNumber(obj, &n);
]]>
</programlisting>
<para>There are two forms of this method.
The first form converts a wholenumber_t value to an Object.
The second form converts an Object to a wholenumber_t value and returns it in
<emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>For the first form, the wholenumber_t value to be converted.
       For the second form, the target of the conversion.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object for the conversion.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>For the first form, an Object version of the integer value.
For the second form, returns 1 = success, 0 = failure.  If successful, the converted value is
placed in <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthWholeNumberToObject"><title>WholeNumberToObject</title>
<indexterm><primary>WholeNumberToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>WholeNumberToObject</secondary></indexterm>
<indexterm><primary>Call context methods</primary>
<secondary>WholeNumberToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>WholeNumberToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>WholeNumberToObject</secondary></indexterm>
<!-- WholeNumberToObject --><para>&contexts_thread_method_call_exit;.</para>
<programlisting language="C++">
<![CDATA[
RexxObjectPtr obj;
wholenumber_t n;

// Method Syntax Form(s)

obj = context->WholeNumberToObject(n);
]]>
</programlisting>
<para>Convert a C wholenumber_t value to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The C whole number to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>An Object that represents the C whole number.</para>
</section>

<section id="mthWriteError"><title>&added50;WriteError</title>
<indexterm><primary>WriteError</primary></indexterm>
<indexterm><primary>I/O Redirector context methods</primary>
<secondary>WriteError</secondary></indexterm>
<!-- WriteError --><para>&contexts_ioredirector; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING data;
size_t  length;

// Method Syntax Form(s)

context->WriteError(data, length);
]]>
</programlisting>
<para>Adds a string to an error output redirection Rexx object that was
specified using the WITH subkeyword of an ADDRESS instruction.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">data</emphasis></entry>
    <entry><para>The string to be written.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">length</emphasis></entry>
    <entry><para>The length of <emphasis role="italic">data</emphasis>.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
<para>See also methods
<xref linkend="mthAreOutputAndErrorSameTarget" xrefstyle="select:title"/>,
<xref linkend="mthIsErrorRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsInputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsOutputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsRedirectionRequested" xrefstyle="select:title"/>,
<xref linkend="mthReadInput" xrefstyle="select:title"/>,
<xref linkend="mthReadInputBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteErrorBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteOutput" xrefstyle="select:title"/>, and
<xref linkend="mthWriteOutputBuffer" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthWriteErrorBuffer"><title>&added50;WriteErrorBuffer</title>
<indexterm><primary>WriteErrorBuffer</primary></indexterm>
<indexterm><primary>I/O Redirector context methods</primary>
<secondary>WriteErrorBuffer</secondary></indexterm>
<!-- WriteErrorBuffer --><para>&contexts_ioredirector; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING data;
size_t  length;

// Method Syntax Form(s)

context->WriteErrorBuffer(data, length);
]]>
</programlisting>
<para>Adds a string composed of strings separated by the platform-specfic
line-end characters as separate items or lines to an error output redirection
Rexx object that was specified using the WITH subkeyword of an ADDRESS
instruction.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">data</emphasis></entry>
    <entry><para>The string of line-end separated strings to be written.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">length</emphasis></entry>
    <entry><para>The length of <emphasis role="italic">data</emphasis>.
    <emphasis role="italic">data</emphasis> string.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
<para>See also methods
<xref linkend="mthAreOutputAndErrorSameTarget" xrefstyle="select:title"/>,
<xref linkend="mthIsErrorRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsInputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsOutputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsRedirectionRequested" xrefstyle="select:title"/>,
<xref linkend="mthReadInput" xrefstyle="select:title"/>,
<xref linkend="mthReadInputBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteError" xrefstyle="select:title"/>,
<xref linkend="mthWriteOutput" xrefstyle="select:title"/>, and
<xref linkend="mthWriteOutputBuffer" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthWriteOutput"><title>&added50;WriteOutput</title>
<indexterm><primary>WriteOutput</primary></indexterm>
<indexterm><primary>I/O Redirector context methods</primary>
<secondary>WriteOutput</secondary></indexterm>
<!-- WriteOutput --><para>&contexts_ioredirector; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING data;
size_t  length;

// Method Syntax Form(s)

context->WriteOutput(data, length);
]]>
</programlisting>
<para>Adds a string to an output redirection Rexx object that was
specified using the WITH subkeyword of an ADDRESS instruction.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">data</emphasis></entry>
    <entry><para>The string to be written.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">length</emphasis></entry>
    <entry><para>The length of <emphasis role="italic">data</emphasis>.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
<para>See also methods
<xref linkend="mthAreOutputAndErrorSameTarget" xrefstyle="select:title"/>,
<xref linkend="mthIsErrorRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsInputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsOutputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsRedirectionRequested" xrefstyle="select:title"/>,
<xref linkend="mthReadInput" xrefstyle="select:title"/>,
<xref linkend="mthReadInputBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteError" xrefstyle="select:title"/>,
<xref linkend="mthWriteErrorBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteOutputBuffer" xrefstyle="select:title"/>.
</para>
</section>

<section id="mthWriteOutputBuffer"><title>&added50;WriteOutputBuffer</title>
<indexterm><primary>WriteOutputBuffer</primary></indexterm>
<indexterm><primary>I/O Redirector context methods</primary>
<secondary>WriteOutputBuffer</secondary></indexterm>
<!-- WriteOutputBuffer --><para>&contexts_ioredirector; &context_since_50;.</para>
<programlisting language="C++">
<![CDATA[
CSTRING data;
size_t  length;

// Method Syntax Form(s)

context->WriteOutputBuffer(data, length);
]]>
</programlisting>
<para>Adds a string composed of strings separated by the platform-specfic
line-end characters as separate items or lines to an output redirection
Rexx object that was specified using the WITH subkeyword of an ADDRESS
instruction.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup cols="2"><colspec colnum="1" colwidth="1*" /><colspec colnum="2" colwidth="5*" /><tbody>
    <row><entry><emphasis role="italic">data</emphasis></entry>
    <entry><para>The string of line-end separated strings to be written.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">length</emphasis></entry>
    <entry><para>The length of <emphasis role="italic">data</emphasis>.
    <emphasis role="italic">data</emphasis> string.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
<para>See also methods
<xref linkend="mthAreOutputAndErrorSameTarget" xrefstyle="select:title"/>,
<xref linkend="mthIsErrorRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsInputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsOutputRedirected" xrefstyle="select:title"/>,
<xref linkend="mthIsRedirectionRequested" xrefstyle="select:title"/>,
<xref linkend="mthReadInput" xrefstyle="select:title"/>,
<xref linkend="mthReadInputBuffer" xrefstyle="select:title"/>,
<xref linkend="mthWriteError" xrefstyle="select:title"/>, and
<xref linkend="mthWriteOutput" xrefstyle="select:title"/>.
</para>
</section>

</section>
</chapter>
