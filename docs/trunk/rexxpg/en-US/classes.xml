<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "rexxpg.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: Programming Guide XML file.
    #
    # Copyright (c) 2005-2017, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<chapter id="classes"><title>A Closer Look at Objects</title>
<para>
<indexterm><primary>variables</primary>
<secondary>in objects</secondary></indexterm>
This chapter covers the mechanics of using objects in more
detail. First, a quick refresher.</para>
<para>A Rexx object consists
of:</para>
<itemizedlist>
<listitem><para>Actions coded as methods</para></listitem>
<listitem><para>Attributes, coded as variables, and their
values, sometimes referred to as &quot;state data&quot;</para></listitem>
</itemizedlist>
<para>Sending a message to an object causes it to perform a related action. The
method with the matching name performs the action. The message is
the interface to the object, and with information hiding, only methods
that belong to an object can access its variables.</para>
<para>Objects are grouped hierarchically into classes. The
class at the top of the hierarchy is the <classname>Object</classname> class. Everything below it
in the hierarchy belongs to the <classname>Object</classname> class and is therefore an object. As
a result, all classes are objects.</para>
<para>In a class hierarchy, classes, superclasses, and subclasses are relative
to one another. Unless designated otherwise, any class directly above a class
in the hierarchy is a superclass, and any class below is a subclass.</para>
<para>From a class you can create instances of the class. Instances
are merely similar objects that fit the template
of the class; they are "of" the class, but are not classes themselves.
</para>
<para>Both the classes
and their instances contain variables and methods. The methods a class provides
for use by its instances are called instance methods. The instance methods
define which messages an object can respond to.
</para>
<para>The methods available
to the class itself are called class methods.
Many of the methods
are actually the instance methods of the <classname>Class</classname> class, but a class many have its
own unique class methods.
They define messages
that only the class&mdash;and not its instances&mdash;can respond to.
</para>
<figure><title>Instance Methods and Class Methods</title>
<indexterm><primary>class methods</primary></indexterm>
<indexterm><primary>instance methods</primary></indexterm>
<mediaobject>
<imageobject>
<imagedata fileref="images/InstanceMethods.svg" align="center" scale="70" />
</imageobject>
</mediaobject>
</figure>

<section id="xclauses"><title>Using Objects in Rexx</title>
<para>
<indexterm><primary>clauses</primary>
<secondary>using object in</secondary></indexterm>
The following
examples with <emphasis role="italic">myarray</emphasis> illustrate how to use new objects in Rexx programs.</para>
<para></para>

<programlisting>
<![CDATA[
myarray=.array~new(5)   /* array with initial capacity of 5 items          */
]]>
</programlisting>

<para>creates a new instance of the Array
class, and assigns to the variable <emphasis role="italic">myarray</emphasis>. The period precedes a class name
in an expression, to distinguish
the class environment symbol from other variables.
The <emphasis role="italic">myarray</emphasis> <classname>array</classname> object has an initial capacity for five items.</para>
<para>After the array is created, you can assign values (items) to it. One way is with
the <methodname>PUT</methodname> method. The <methodname>PUT</methodname> has two arguments, which must be enclosed in parentheses.
The first argument is the value (item) added to the array, the second is
the index number, the number of the location at which to store the value (item) in the array object. Here, the string
object <code>Hello</code> is stored at the index numbered <code>3</code>
of <emphasis role="italic">myarray</emphasis>: </para>

<programlisting>
<![CDATA[
myarray~put("Hello",3)  /* storing "Hello" at position 3                   */
]]>
</programlisting>

<para>One way to retrieve values from an <classname>array</classname> object is by sending it an <methodname>AT</methodname> message.
In the next example, the <methodname>SAY</methodname> instruction displays the value (item) stored at position (index) <code>3</code> of <emphasis role="italic">myarray</emphasis>: </para>

<programlisting>
<![CDATA[
say myarray~at(3)       /* fetching item from position 3                   */

Results:

Hello
]]>
</programlisting>

<para>
<indexterm><primary>SAY instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>SAY instruction</secondary></indexterm>
<indexterm><primary>MAKESTRING method</primary></indexterm>
<indexterm><primary>STRING method</primary></indexterm>
The <methodname>SAY</methodname>
instruction expects a <classname>string</classname> object as input, which is what <methodname>AT</methodname> returns in this case.
If you try to display a non-string object in the <methodname>SAY</methodname> instruction,
<methodname>SAY</methodname> requests a <classname>string</classname> object, which will cause the <methodname>MAKESTRING</methodname>
message to be sent to the object if present, and if not the <methodname>STRING</methodname> message instead (the exact procedure is
documented in the <citetitle pubwork="book">Open Object Rexx: Reference</citetitle>, section <emphasis role="italic">4.2.11 Required String Values</emphasis>
and applies to any instruction or built-in function that requires a string value).

In this example, the <methodname>MAKESTRING</methodname> method for an <classname>Array</classname> object returns the items currently
stored in the array, in this case the string <literal>Hello</literal>.
</para>

<programlisting>
<![CDATA[
say myarray            /* SAY causes the MAKESTRING message to be sent to myarray   */

Results:

Hello
]]>
</programlisting>

<para>By contrast the <methodname>STRING</methodname> method of the <classname>Array</classname> class returns the string
&quot;<computeroutput>an Array</computeroutput>&quot;:</para>

<programlisting>
<![CDATA[
say myarray~string     /* sending explicitly the STRING message            */

Results:

an Array
]]>
</programlisting>

<para>Whenever a method returns a string, you can use it within expressions that
require a string. Here, the element of the array that <methodname>AT</methodname> returns is a string, so you can put an
expression containing the <methodname>AT</methodname> method inside a string function like <methodname>COPIES()</methodname>:</para>

<programlisting>
<![CDATA[
say copies(myarray~at(3),4)   /* fetching item from position 3, copying it 4 times  */

Results:

HelloHelloHelloHello
]]>
</programlisting>

<para>This example produces the same result using only messages that cause the appropriate methods to be run: </para>

<programlisting>
<![CDATA[
say myarray~at(3)~copies(4)   /* fetching item from position 3, copying it 4 times  */

Results:

HelloHelloHelloHello
]]>
</programlisting>

<para>Notice that the expression is evaluated from left to right. You can also
use parentheses to enforce an order of evaluation.</para>
<para>Almost all messages are sent using the twiddle, but there are exceptions.
The exceptions are to improve the readability of the language. The following
example uses the <methodname>[]=</methodname> (left-bracket right-bracket equal-sign) and <methodname>[]</methodname>
methods to set and retrieve array elements: </para>

<programlisting>
<![CDATA[
myarray[4]="the fourth element"  /* storing string at position 4           */
say myarray[4]                /* fetching item (a string) from position 4  */

Results:

the fourth element
]]>
</programlisting>

<para>Although the previous instructions look like an ordinary array assignment
and array reference, they are actually messages to the Array object referenced by <emphasis role="italic">myarray</emphasis>. You
can prove this by executing these equivalent instructions, which use the twiddle
to send the messages: </para>

<programlisting>
<![CDATA[
myarray~"[]="("a new test",4)    /* storing string at position 4           */
say myarray~"[]"(4)           /* fetching item (a string) from position 4  */

Results:

a new test
]]>
</programlisting>

<para>Similarly, expression operators (such as +, -, /, and *) are actually methods,
but you do not have to use the twiddle to send them: </para>

<programlisting>
<![CDATA[
say 2+3              /* adds 3 to 2, displays result: 5 */
say 2~"+"(3)         /* message version: adds 3 to 2, displays result: 5 */
]]>
</programlisting>

<para>In the second <methodname>SAY </methodname>instruction, <methodname>"+"</methodname> must be a literal string because the message name
contains characters not allowed in a Rexx symbol.</para>
</section>

<section id="creo"><title>Common Methods</title>
<para>When running your program, four methods that Rexx looks for, and runs
automatically when appropriate, are <methodname>INIT</methodname>,  <xref linkend="destroy" xrefstyle="template:UNINIT" />,
<methodname>MAKESTRING</methodname> and  <methodname>STRING</methodname>.</para>

<section id="init"><title>Initializing Instances Using INIT</title>
<para>
<indexterm><primary>INIT method</primary>
<secondary>constructor method</secondary></indexterm>
<indexterm><primary>constructor</primary>
<secondary>INIT method</secondary></indexterm>
Object classes can create instances.
When these instances require initialization, you'll want to define an
<methodname>INIT</methodname> method to set a particular starting value or initiate some startup processing.
Rexx looks for an <methodname>INIT</methodname> method whenever a new object is created and runs it.</para>

<para>
The purpose of initialization is to ensure that the instance variables can be initialized, if needed,
before being used in an operation.
After the <methodname>NEW</methodname> method has created the new instance,
but before returning it, the new instance gets the <methodname>INIT</methodname> message sent to it.
Any (initialization) arguments specified with the
<methodname>NEW</methodname> message are passed on to the
<methodname>INIT</methodname> method in the same order, which can use them
to set the initial states of object variables. As the <methodname>INIT</methodname> method gets invoked automatically at
object creation time it is also known as the Rexx <emphasis role="italic">constructor method</emphasis>.</para>
<para>If a class overrides the <methodname>INIT</methodname> method it inherits from a superclass,
the new <methodname>INIT</methodname> method must forward the <methodname>INIT</methodname> message up the
hierarchy, to properly initialize the instance, using the <emphasis role="italic">SUPERCLASS overrides</emphasis>, so
that each inherited <methodname>INIT</methodname> method has the opportunity to run  (using e.g. the statement
<code>self~init:super</code>).
An example in the next section demonstrates the use of
the Rexx constructor method <methodname>INIT</methodname>.</para>
</section>

<section id="retstr"><title>The MAKESTRING and STRING Methods</title>
<para>
<indexterm><primary>Rexx</primary>
<secondary>MAKESTRING method</secondary></indexterm>
<indexterm><primary>MAKESTRING method</primary></indexterm>
The <methodname>MAKESTRING</methodname> method is optional and if present in a class allows
for rendering each of its instances as <classname>string</classname> objects. Each such rendering will usually encode
its attributes (object variables) as strings in one form or another.</para>

<para>Whenever an object is supplied as an argument to an instruction or built-in function that works on strings only,
a <emphasis role="italic">required string value</emphasis> gets requested. If a <methodname>MAKESTRING</methodname>
method is available it will be run and the resulting string will be used instead.</para>
<para>In the case that there is no <methodname>MAKESTRING</methodname> method, then the
<methodname>STRING</methodname> gets employed instead, which is guaranteed to exist as it gets defined in the
Rexx root class <classname>Object</classname>. The returned string value in this case will usually consist of the indefinite article for the
class name and gets concatenated with a blank and with the class name itself.</para>

<para>The exact procedure for getting at a required string value is documented in the
<citetitle pubwork="book">Open Object Rexx: Reference</citetitle>, section <emphasis role="italic">4.2.11 Required String Values</emphasis>
</para>

<para>
You can take advantage of this automatic use of <methodname>MAKESTRING</methodname> and
<methodname>STRING</methodname> by overriding (implementing) either or both methods in your own Rexx classes.
</para>

<para>
<indexterm><primary>directives</primary>
<secondary>sample program</secondary></indexterm>
The following programs
demonstrate <methodname>STRING</methodname> and <methodname>INIT</methodname>.
In the first program, the <classname>Part</classname> class is created,
and along with it, the two methods under discussion, <methodname>STRING</methodname> and <methodname>INIT</methodname>: </para>
<example>
<title>STRING and INIT Methods</title>

<programlisting>
<![CDATA[
/* partdef.rex - Class and method definition file */

/* Define the Part class as a public class */
::class Part public

/* Define the INIT method to initialize object variables */
::method init
   expose name description number
   use arg name, description, number

/* Define the STRING method to return a string with the part name */
::method string
   expose name
   return "Part name:" name
]]>
</programlisting>

</example>
<para>In the <methodname>::CLASS</methodname> directive, the
keyword <methodname>PUBLIC</methodname> indicates that the class can be shared with other programs.
The two <methodname>::METHOD</methodname> directives define
<methodname>INIT</methodname> and <methodname>STRING</methodname>. Whenever Rexx creates
a new instance of a class, it calls the <methodname>INIT</methodname> method of the new instance. The sample
<methodname>INIT</methodname> method uses an <methodname>EXPOSE</methodname> instruction to
allow the method direct access to the object variables (attributes)
<varname>name</varname>, <varname>description</varname>, and
<varname>number</varname>: </para>

<figure><title>Instances in the Part Class</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/PartClass.svg" align="center" scale="75" />
</imageobject>
</mediaobject>
</figure>

<para>
<indexterm><primary>Rexx</primary>
<secondary>USE ARG instruction</secondary></indexterm>
<indexterm><primary>USE ARG instruction</primary></indexterm>
The INIT method expects to be passed three arguments.
The <methodname>USE ARG</methodname> instruction assigns these three arguments to the
exposed object variables (attributes)
<varname>name</varname>, <varname>description</varname>, and
<varname>number</varname>, respectively. </para>

<para>
<indexterm><primary>EXPOSE instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>EXPOSE instruction</secondary></indexterm>
<indexterm><primary>variables</primary>
<secondary>exposing</secondary></indexterm>
The <methodname>STRING</methodname> method returns the string
<computeroutput>Part name:</computeroutput>, followed
by the name of a part. The <methodname>STRING</methodname> method (of the <classname>Part</classname> class)
does not expect any arguments.
It uses the <methodname>EXPOSE</methodname> instruction to be able to directly access the object variable (attribute)
<varname>name</varname>.
The <methodname>RETURN</methodname> instruction returns the result string.</para>

<para>The following example shows how to use the <classname>Part</classname> class: </para>
<example>
<title>How to use the Part class</title>

<programlisting>
<![CDATA[
/* usepart.rex - use the Part class */
mypartA=.part~new("Widget","A small widge",12345)
mypartB=.part~new("Framistat","Device to control frams",899)
say mypartA
say mypartB
exit
::requires partdef

Results:

Part name: Widget
Part name: Framistat
]]>
</programlisting>

</example>
<para>The <filename>usepart.rex</filename> program creates two parts, which are instances of the Part
class. It then displays the names of the two parts.</para>

<para>
<indexterm><primary>directives</primary>
<secondary>::REQUIRES</secondary></indexterm>
Rexx processes all directives before running your program.
The <methodname>::REQUIRES</methodname> directive indicates
that the program needs access to public class and public routine definitions that are in another
program. In this case, the <methodname>::REQUIRES</methodname> directive refers to the <filename>partdef.rex</filename> program,
which contains the <classname>Part</classname> definition.</para>

<para>The assignment instructions for
<emphasis role="italic">mypartA</emphasis> and <emphasis role="italic">mypartB</emphasis> create
two objects that are instances of the <classname>Part</classname> class.
The objects are created by sending a <methodname>NEW</methodname> message to the
<classname>Part</classname> class. The <methodname>NEW</methodname>
message causes the <methodname>NEW</methodname> method of the <classname>Part</classname> class
to be invoked, which sends the <methodname>INIT</methodname> message together with the three received arguments
to the newly created instance, which in turn runs the <methodname>INIT</methodname> method
as part of the object creation.
The <methodname>INIT</methodname> method takes the three arguments you provide and saves them in its
object's variables (attributes): <varname>name</varname>, <varname>description</varname>, and
<varname>number</varname>: </para>
<para>
<indexterm><primary>SAY instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>SAY instruction</secondary></indexterm>
<indexterm><primary>STRING method</primary></indexterm>
The <methodname>SAY</methodname>
instruction causes Rexx to create the required string value: as there is no
<methodname>MAKESTRING</methodname> method in the <classname>Part</classname> class
the <methodname>STRING</methodname> method gets invoked to return a string value.
The <methodname>STRING</methodname> method uses <methodname>EXPOSE</methodname> to become
able to directly access the <varname>name</varname> object variable (attribute) and returns it as part of the string
(<code>return &quot;Part name:&quot; name</code>).
</para>
</section>

<section id="destroy"><title>Uninitializing and Deleting Instances Using UNINIT</title>
<para>
<indexterm><primary>UNINIT method</primary>
<secondary>destructor method</secondary></indexterm>
<indexterm><primary>instances</primary>
<secondary>uninitializing and deleting</secondary></indexterm>
<indexterm><primary>destructor</primary>
<secondary>UNINIT method</secondary></indexterm>
Normally, object
classes can create instances but have no direct control over their deletion.
Once an object is no longer referenced in the program, it turns to garbage and
Rexx automatically reclaims the storage it occupies in the computer's memory
in a process called garbage collection.</para>
<para>
If the instance has allocated other system resources,
Rexx cannot automatically release these
resources because it is unaware that the instance has allocated them.
An <methodname>UNINIT</methodname> method gives an object the opportunity to perform resource cleanup before
the object is reclaimed by the garbage collector. This is done by the garbage collector for objects having an
<methodname>UNINIT</methodname> method  implemented right before the object gets
<emphasis role="italic">destroyed</emphasis> by sending it the <methodname>UNINIT</methodname> message.
Because this method runs at destruction time only it is called the Rexx <emphasis role="italic">desctructor method</emphasis>.
</para>
<para>In the following example the <methodname>NEW</methodname> message gets an argument supplied that
is meant to be used for setting the value of the object variable (attribute) <emphasis role="italic">text</emphasis> in the
<classname>scratchpad</classname> class. As mentioned above the <methodname>NEW</methodname> method, after
creating the instance, but before returning it gets the <methodname>INIT</methodname> message sent with the argument it
received and will save that value in its <emphasis role="italic">text</emphasis> object variable (attribute) and displays that value using.
the <methodname>SAY</methodname> instruction.</para>
<para>Once the program is finished and the objects get destroyed by the garbage collector, each
<classname>scratchpad</classname> object will get the <methodname>UNINIT</methodname> message sent to
it, which in turn runs <methodname>UNINIT</methodname> method.  The method directly accesses teh <emphasis role="italic">text</emphasis>
object variable (attribute) and displays its value with the <methodname>SAY</methodname> instruction:
</para>
<example>
<title>UNINIT Method</title>
<programlisting>
/* uninit.rex - example of UNINIT processing */

a=.scratchpad~new("Of all the things I&apos;ve lost")
a=.scratchpad~new("I miss my mind the most")
say "Exiting program."
exit

::class scratchpad

  ::method init
    expose text
    use arg text
    say "Remembering" text

  ::method uninit
    expose text
    say "Forgetting" text
    return
</programlisting>
</example>

<para>Whether uninitialization processing is needed depends on the circumstances,
If the object only contains references to normal Rexx objects, an <methodname>UNINIT</methodname> method
is generally not needed.  If the object contains references to external system
resources such as open network connections or database connections, an <methodname>UNINIT</methodname> method
might be required to release those resources.
If an object requires uninitialization, define an <methodname>UNINIT</methodname>
method to perform the cleanup processing you require.</para>
<para>If an object has an <methodname>UNINIT</methodname> method, Rexx runs it before reclaiming the object's storage.
If an instance overrides an <methodname>UNINIT</methodname> method of a superclass,
each <methodname>UNINIT</methodname> method is responsible for sending the <methodname>UNINIT</methodname>
message up the hierarchy, using the <emphasis role="italic">SUPERCLASS overrides</emphasis>
(by using the statement: <code>&quot;self~uninit:super&quot;</code>), so that each inherited <methodname>UNINIT</methodname> method
has the opportunity to run.</para>
</section>
</section>

<section id="spvar"><title>Special Method Variables</title>
<para>
<indexterm><primary>special variable</primary></indexterm>
<indexterm><primary>variables</primary>
<secondary>special</secondary></indexterm>
When writing methods, there are several special variables
that are set automatically when a method runs.
Rexx supports the following
variables: </para>
<variablelist>
<varlistentry><term><emphasis role="italic">SELF</emphasis>
<indexterm><primary>SELF special variable</primary></indexterm>
</term>
<listitem><para>is set when a method
is activated. Its value is the object that forms the execution context for
the method (that is, the object that received the activating message). </para>
<para>You
can use <emphasis role="italic">SELF</emphasis> to:</para>
<itemizedlist>
<listitem><para>Send messages to the currently active object.
For example, a <methodname>FIND_CLUES</methodname> method is running in an object called <emphasis role="italic">Mystery_Novel</emphasis>.
When <methodname>FIND_CLUES</methodname> finds a clue, it sends a <methodname>READ_LAST_PAGE</methodname>
message to <emphasis role="italic">Mystery_Novel</emphasis>:

<programlisting>
<![CDATA[
self~read_last_page
]]>
 </programlisting></para></listitem>

<listitem><para>Pass references regarding an object to the methods of other
objects. For example, a <methodname>SING</methodname> method is running in object <emphasis role="italic">Song</emphasis>. The code:

<programlisting>
<![CDATA[
Singer2~duet(self)
]]>
</programlisting>

would give the <methodname>DUET</methodname> method access to the same Song.</para>
</listitem></itemizedlist>
</listitem></varlistentry>
<varlistentry><term><emphasis role="italic">SUPER</emphasis>
<indexterm><primary>SUPER special variable</primary></indexterm>
</term>
<listitem><para>is set when a method
is activated. Its value is the class object that is the usual starting point
for a superclass method lookup for the <emphasis role="italic">SELF</emphasis> object. This is the first immediate
superclass of the class that defined the method currently running. </para>
<para>The
special variable <emphasis role="italic">SUPER</emphasis> lets you call a method in the superclass of an object.
For example, the following <classname>Savings</classname> class has <methodname>INIT</methodname> methods that the Savings
class, <classname>Account</classname> class, and <classname>Object</classname> class define. </para>
<example>
<title>SELF Variable</title>

<programlisting>
<![CDATA[
::class Account

  ::method INIT
    expose balance
    use arg balance
    self~init:super    /* Forwards to the Object INIT method */

  ::method TYPE
    return "an account"

  ::method name attribute

::class Savings subclass Account

  ::method INIT
    expose interest_rate
    use arg balance, interest_rate
    self~init:super(balance)  /* Forwards to the Account INIT method */

  ::method type
    return "a savings account"
]]>
</programlisting>

</example>
<para>When the <methodname>INIT</methodname> method of the <classname>Savings</classname>
class is called, the variable <emphasis role="italic">SUPER</emphasis> is set to the <classname>Account</classname> class object. For
example: </para>

<programlisting>
<![CDATA[
self~init:super(balance)
]]>
</programlisting>
<para>This instruction sends
the <methodname>INIT</methodname> message to the <classname>Account</classname>
class rather than recursively invoking the <methodname>INIT</methodname>
method of the <classname>Savings</classname> class. When the <methodname>INIT</methodname> method
of the <classname>Account</classname> class is
called, the variable <emphasis role="italic">SUPER</emphasis> is assigned to the <classname>Object</classname> class
as this is the <classname>Account</classname> class' direct super class: </para>

<programlisting>
<![CDATA[
self~init:super
]]>
</programlisting><para>calls the <methodname>INIT</methodname> method of the <classname>Object</classname>
class.</para>
</listitem></varlistentry>
</variablelist>
</section>

<section id="pubobj"><title>Public, Local, and Built-In Environment Objects</title>
<para>
<indexterm><primary>public objects</primary></indexterm>
<indexterm><primary>local objects</primary></indexterm>
<indexterm><primary>built-in objects</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>public objects</secondary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>local objects</secondary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>built-in objects</secondary></indexterm>
In addition to the special variables, Rexx provides
a unique set of objects, called <emphasis role="italic">environment objects</emphasis>.
Rexx makes the following environment objects available:</para>


<!-- =========================================================================== -->

<section id="publicenvobj"><title>The Global Environment Object (.environment)</title>
<para>
<indexterm><primary>Environment objects</primary></indexterm>
<indexterm><primary>symbols</primary>
<secondary>.environment symbol</secondary></indexterm>
<indexterm><primary>Global environment object</primary></indexterm>
The environment object <literal>.environment</literal> is a directory (an instance of the Rexx <classname>Directory</classname> class)
of public objects that are always accessible throughout the whole process. Each entry in this directory can itself be referred to by an environment symbol
that starts with a dot, immediately followed by its index name. All the public Rexx built-in classes are stored in the environment directory
<literal>.environment</literal>, therefore the public Rexx array class can be fetched by its environment symbol <code>.ARRAY</code> or
alternatively with <code>.environment~array</code>.
To place something in the environment directory, you use the form: </para>

<programlisting>
.environment~your.object = value
</programlisting>

<para> Include a period (<code>.</code>) in any index name you use, to avoid conflicts with current or future Rexx
entries to the environment directory <literal>.environment</literal>. In the above example the index name used for storing
<emphasis role="italic">value</emphasis> within the environment directory is <code>YOUR.OBJECT</code>.
To retrieve the <emphasis role="italic">value</emphasis>  stored with the index name <code>YOUR.OBJECT</code>
from the <literal>.environment</literal> directory, you use one of the following two forms: </para>

<programlisting>
say .environment~your.object
say .your.object        /* same as above        */
</programlisting>

<para>
<indexterm><primary>symbols</primary>
<secondary>.environment symbol</secondary></indexterm>
The scope of <literal>.environment</literal> is
the current process, which means it is shared among all interpreter instances
executing in this process.
</para>
<para>You use an environment symbol to access the entries of this
directory. An <emphasis role="italic">environment symbol</emphasis> starts with a period and has at least one
other character, and the symbol is not a valid numeric value. You have seen environment symbols
earlier; for example in: </para>

<programlisting>
<![CDATA[
asav = .savings~new
]]>
</programlisting>

<para> <literal>.savings</literal> is
an environment symbol, and refers to the <classname>Savings</classname> class. The classes
you create can be referenced with an environment symbol. There is an environment
symbol for each public Rexx-defined class, as well as for each of the unique environment objects
this section describes, such as <emphasis role="italic">The Nil Object</emphasis>.</para>

<section id="nilobject"><title>The NIL Object (.nil)</title>
<para>
<indexterm><primary>symbols</primary>
<secondary>.nil symbol</secondary></indexterm>
<indexterm><primary>.Nil object</primary></indexterm>
<emphasis role="italic">The NIL object</emphasis> <literal>.nil</literal> is
a special environment object that does not contain any data. It represents
the absence of an object, the way a null string represents a string with no
characters. Its only methods are those of the <classname>Object</classname> class. You can use
<emphasis role="italic">The NIL object</emphasis> (rather than the null string) to test for the absence
of data in an array entry: </para>

<programlisting>
<![CDATA[
if board[row,column] = .nil
then ...
]]>
</programlisting>
</section>

<section id="falseobject"><title>The False Environment Object (.false)</title>
<para>
<indexterm><primary>symbols</primary>
<secondary>.false symbol</secondary></indexterm>
<indexterm><primary>.false object</primary></indexterm>
The environment object <literal>.false</literal> simply allows for retrieving the value <literal>0</literal>
stored in the environment directory  <literal>.environment</literal>, which is the value used in Rexx to represent
the boolean value <emphasis role="italic">&quot;false&quot;</emphasis> (<emphasis role="italic">&quot;not true&quot;</emphasis>).
You can use the environment symbol <literal>.false</literal> instead of the
literal <literal>0</literal> to make clear that you are using a boolean value (and not a number or a string).
</para>
</section>

<section id="trueobject"><title>The True Environment Object (.true)</title>
<para>
<indexterm><primary>symbols</primary>
<secondary>.true symbol</secondary></indexterm>
<indexterm><primary>.true object</primary></indexterm>
The environment object <literal>.true</literal> simply allows for retrieving the value <literal>1</literal>
stored in the environment directory  <literal>.environment</literal>, which is the value used in Rexx to represent
the boolean value <emphasis role="italic">&quot;true&quot;</emphasis> (<emphasis role="italic">&quot;not false&quot;</emphasis>).
You can use the environment symbol <literal>.true</literal> instead of the
literal <literal>1</literal> to make clear that you are using a boolean value (and not a number or a string).
</para>
<para>All the environment objects Rexx provides are single symbols. Use
compound symbols when you create your own, to avoid conflicts with future
Rexx-defined entries.</para>
</section>

</section>

<!-- =========================================================================== -->

<section id="localenvobj"><title>The Local Environment Object (.local)</title>
<para>
<indexterm><primary>Environment objects</primary></indexterm>
<indexterm><primary>symbols</primary>
<secondary>.local symbol</secondary></indexterm>
<indexterm><primary>Local environment object</primary></indexterm>
The local environment object <literal>.local</literal> is a directory (an instance of the Rexx <classname>Directory</classname> class)
of interpreter instance-specific objects that are always accessible. To place something in the Local environment directory,
you use the form: </para>

<programlisting>
.local~your.object =  value
</programlisting>

<para> Include a period (<code>.</code>) in any index name you use, to avoid conflicts with current or future Rexx
entries to the local environment directory <literal>.local</literal>. In the above example the index name used for storing
<emphasis role="italic">value</emphasis> within the local environment directory is <code>YOUR.OBJECT</code>.
To retrieve the <emphasis role="italic">value</emphasis> stored with the index name <code>YOUR.OBJECT</code>
from the <literal>.local</literal> directory, you use one of the following two forms: </para>

<programlisting>
say .local~your.object
say .your.object        /* same as above        */
</programlisting>

<para>The scope of <literal>.local</literal> is the current interpreter instance.
Each Rexx interpreter instance has its own copy of the local environment
directory <literal>.local</literal>.
</para>
<para>You access objects in the <literal>.local</literal> directory like in the global <literal>.environment</literal>
directory. Rexx provides the following objects in the local environment: </para>

<variablelist>

<varlistentry><term><literal>.input</literal>
<indexterm><primary>symbols</primary>
<secondary>.input symbol</secondary></indexterm>
</term>
<listitem><para>is the input monitor (an instance of the Rexx class <classname>Monitor</classname>)
object which is the source for the <methodname>PARSE LINEIN</methodname> instruction,
the <methodname>LINEIN</methodname> method and <methodname>CHARIN</methodname> method
of the <classname>Stream</classname> class, and (if you do not specify a stream
name) the <methodname>LINEIN</methodname>, respectively <methodname>CHARIN</methodname> built-in functions.
It is also the source of the <methodname>PULL</methodname> and
<methodname>PARSE PULL</methodname> instructions if the external data queue is empty.
By default <literal>.input</literal> forwards the received messages to the <literal>.stdin</literal> stream object.
</para></listitem></varlistentry>

<varlistentry><term><literal>.output</literal>
<indexterm><primary>symbols</primary>
<secondary>.output symbol</secondary></indexterm>
</term>
<listitem><para>is the output monitor  (an instance of the Rexx class <classname>Monitor</classname>)
object, which is the destination of output from the <methodname>SAY</methodname> instruction,
the <methodname>LINEOUT</methodname> (<methodname>SAY</methodname>) and
<methodname>CHAROUT</methodname> methods of the <classname>Stream</classname> class, and
(if you do not specify a stream name) the <methodname>LINEOUT</methodname> built-in function. You can replace
this object's destination to redirect such output elsewhere, for example to a transcript window.
By default <literal>.output</literal> forwards the received messages to the <literal>.stdout</literal> stream object.
</para></listitem></varlistentry>

<varlistentry><term><literal>.error</literal>
<indexterm><primary>symbols</primary>
<secondary>.error symbol</secondary></indexterm>
</term>
<listitem><para>is the error monitor  (an instance of the Rexx class <classname>Monitor</classname>)
object to which Rexx writes error messages to. By default <literal>.error</literal> forwards the received
messages to the <literal>.stderr</literal> stream object.
</para></listitem></varlistentry>

<varlistentry><term><literal>.debuginput</literal>
<indexterm><primary>symbols</primary>
<secondary>.debuginput symbol</secondary></indexterm>
</term>
<listitem><para>is the debug input monitor (an instance of the Rexx class <classname>Monitor</classname>)
object from which the Rexx <methodname>TRACE</methodname>  instruction reads debug input while in interactive mode.
By default <literal>.debuginput</literal> forwards the received messages to the <literal>.input</literal> monitor object.
</para></listitem></varlistentry>

<varlistentry><term><literal>.traceoutput</literal>
<indexterm><primary>symbols</primary>
<secondary>.traceoutput symbol</secondary></indexterm>
</term>
<listitem><para>is the trace output monitor (an instance of the Rexx class <classname>Monitor</classname>)
object to which Rexx writes trace output to. By default <literal>.traceoutput</literal> forwards the
received messages to the <literal>.error</literal> monitor object.
</para></listitem></varlistentry>

<varlistentry><term><literal>.stdin</literal>
<indexterm><primary>symbols</primary>
<secondary>.stdin symbol</secondary></indexterm>
</term>
<listitem><para>is the operating system's standard input stream (an instance of the Rexx class <classname>Stream</classname>),
by default the keyboard input device. The standard input stream can be redirected via the operating system and has always the
file descriptor value <literal>0</literal>.
</para></listitem></varlistentry>

<varlistentry><term><literal>.stdout</literal>
<indexterm><primary>symbols</primary>
<secondary>.stdout symbol</secondary></indexterm>
</term>
<listitem><para>is the operating system's standard output stream (an instance of the Rexx class <classname>Stream</classname>),
by default the console (terminal) device.  The standard output stream can be redirected via the operating system and has always the
optional file descriptor value <literal>1</literal>.
</para></listitem></varlistentry>

<varlistentry><term><literal>.stderr</literal>
<indexterm><primary>symbols</primary>
<secondary>.stderr symbol</secondary></indexterm>
</term>
<listitem><para>is the operating system's standard error stream (an instance of the Rexx class <classname>Stream</classname>),
by default the console (terminal) device. The standard output stream can be redirected via the operating system and has always the
file descriptor value <literal>2</literal>.
</para></listitem></varlistentry>

<varlistentry><term><literal>.syscargs</literal>
<indexterm><primary>symbols</primary>
<secondary>.syscargs symbol</secondary></indexterm>
</term>
<listitem><para>is optional and will be set by Rexx if the Rexx program was called with arguments from the commandline. Rather than
returning the commandline argument as a single string like the <methodname>ARG()</methodname> built-in function does,
<literal>.syscargs</literal> array object will have the commandline argument string decomposed according to the rules of the programming
language <emphasis role="italic">C</emphasis>. If this environment object is not set, because there were no commandline arguments supplied,
the name of the environment symbol will be returned instead in uppercase letters, i.e. <literal>.SYSCARGS</literal> (note the leading dot which
makes this symbol an environment symbol).
</para>

<example>
<title>.SYSCARGS Environment Object</title>
<para>Invoking the following Rexx program from the command line with <code>rexx syscargs.rex one
&quot;second argument&quot;  three &quot;fourth argument&quot; five</code></para>
<programlisting>
<![CDATA[
/*  runnig this program from the command line:
      rexx syscargs.rex one "second argument" three "fourth argument" five
*/
/* syscargs.rex   */
if .sysCargs~isA(.array) then             -- command line arguments parsed?
do
   say "there are.sysCargs~items:" .sysCargs~items -- show number of arguments
   say
   do counter i val over .sysCargs        -- show parsed arguments
      say i":" val
   end
end

Results:

there are.sysCargs~items: 5

1: one
2: second argument
3: three
4: fourth argument
5: five
]]>
</programlisting>

</example>

</listitem></varlistentry>

</variablelist>
</section>

<section id="builtinenvobj"><title>Built-In Environment Objects</title>
<para>
<indexterm><primary>built-in environment objects</primary></indexterm>
Rexx provides environment
objects that all programs can use. To access these built-in
objects, you use their environment symbols whose first character
is a period (<literal>.</literal>).</para>
<variablelist>
<varlistentry><term><literal>.line</literal>
<indexterm><primary>symbols</primary>
<secondary>.line symbol</secondary></indexterm>
</term>
<listitem><para>The <literal>.line</literal> environment symbol returns the line number of the current
instruction being executed.  If the current instruction is defined within an <methodname>INTERPRET</methodname>
instruction, the value returned is the line number of <methodname>INTERPRET</methodname> instruction.
</para></listitem></varlistentry>

<varlistentry><term><literal>.rs</literal>
<indexterm><primary>symbols</primary>
<secondary>.rs symbol</secondary></indexterm>
</term>
<listitem><para><literal>.rs</literal> is set to the return status from any executed command, including
those submitted with the <methodname>ADDRESS</methodname> instruction. The <literal>.rs</literal> environment symbol has
a value of <code>-1</code> when a command returns a
<methodname>FAILURE</methodname> condition, a value of <code>1</code> when
a command returns an <methodname>ERROR</methodname> condition, and
a value of <code>0</code> when a command indicates
successful completion. The value of <literal>.rs</literal> is also available after trapping the
<methodname>ERROR</methodname> or <methodname>FAILURE</methodname> condition. </para>

<note>
<para>Tracing interactively does not
change the value of <literal>.rs</literal>. The initial value of <literal>.rs</literal> is <code>0</code>.</para></note>
</listitem></varlistentry>
</variablelist>
</section>

<section id="searchord"><title>The Default Search Order for Environment Objects</title>
<para>
<indexterm><primary>search order</primary>
<secondary>for environment symbols</secondary></indexterm>
When you
use an environment symbol, Rexx performs a series of searches to see if the
environment symbol has an assigned value. The search locations and their ordering
are: </para>

<orderedlist>

<listitem><para>The classes and routines maintained in the current package by the interpreter.
This package can be retrieved programmatically with the statement <code>.context~package</code>.
</para></listitem>

<listitem><para>"&added50;" The current package <emphasis role="italic">local</emphasis> directory.
The package local directory can be accessed programmatically with the statement <code>.context~package~local</code>.
</para></listitem>

<listitem><para>The program local environment directory <literal>.local</literal>, which includes interpreter instance-specific
objects such as the <literal>.input</literal> and <literal>.output</literal> objects. You can directly access the
local environment directory by using the <literal>.local</literal> environment symbol.</para></listitem>

<listitem><para>The global environment directory <literal>.environment</literal>, which includes all &quot;global&quot; Rexx
objects such as the Rexx-supplied classes (for example, <literal>.Array</literal>) and constants
such as <literal>.true</literal> and <literal>.false</literal>. You can directly access the global environment by
using the <literal>.environment</literal> symbol or using the <methodname>VALUE</methodname> built-in function with a
null string for the <emphasis role="italic">selector</emphasis> argument.</para></listitem>

<listitem><para>Rexx defined symbols. Other simple environment symbols are reserved for
use by Rexx for built-in objects.
</para></listitem>
</orderedlist>

<para>If an entry is not found for an environment symbol, the default character string value (uppercased) of the environment symbol is used including
its leading dot. </para>

<note>
<para>You can place entries in the <code>.context~package~local</code>, <literal>.local</literal>
and <literal>.environment</literal> directories for programs to use, but <literal>.local</literal> should be preferred over
<literal>.environment</literal> to avoid accidentally overwriting system-defined values.
To avoid conflicts with future Rexx-defined entries, it is recommended that entries you place in either
of these directories include at least one period in the entry name.</para></note>
<example>
<title>.Local Object</title>

<programlisting>
<![CDATA[
/* establish a settings directory in the local environment directory*/
.local~setentry("my.settings", .directory~new)
]]>
</programlisting>

</example>
</section>
</section>

<section id="scope"><title>Determining the Scope of Methods and Variables</title>
<para>
<indexterm><primary>scope</primary></indexterm>
<indexterm><primary>class scope</primary></indexterm>
<indexterm><primary>EXPOSE instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>EXPOSE instruction</secondary></indexterm>
Methods may interact with object variables (attributes) and their
associated data. But a method cannot directly interact with any object variable (attribute), only
with those object variables (attributes) that are defined in the same class as the method (encapsulation).
This protects the object variables' (attributes') data from being changed by &quot;unauthorized&quot;
methods belonging to other classes.
</para>
<para> All Methods of a particular class are able to directly access object variables (attributes) by
using as their very first instruction the <methodname>EXPOSE</methodname> instruction
followed by a blank delimited list of the object variable (attribute) names the method wishes to interact
directly.
</para>

<section id="objwclsc"><title>Objects with a Class Scope</title>
<para>Encapsulation usually takes place at the class level. The class is designed
as a template of methods and variables. The instances themselves retain only
the values of their object variables (attributes).</para>
<para>Within the hierarchy, the class structure ensures the integrity of a class's
object variables (attributes), controlling the methods allowed to operate on them. The class structure
also provides for easy updating of the method code. If a method requires a
change, you only have to change it once, at the class level. The change then
is acquired by all the instances sharing the method.</para>
<para>Associated methods and variables have a certain scope, which is the
class to which they belong:</para>

<figure><title>Scope of the Number Class</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/rxoq0s05.svg" align="center" scale="70" />
</imageobject>
</mediaobject>
</figure>

<para>Each class in a class hierarchy has a scope different from any other class.
This is what allows an object variable (attribute) in a subclass to have the same name as an object variable (attribute)
in a superclass, even though the methods that use the object variables (attributes) for completely unrelated
purposes.</para>
</section>

<section id="objwownsc"><title>Objects with Their Own Unique Scope</title>
<para>
<indexterm><primary>scope</primary></indexterm>
<indexterm><primary>methods</primary>
<secondary>scope</secondary></indexterm>
The methods and attributes (object variables) used by instances in a class are usually found
at the class level. But sometimes an instance differs in some respect from
the others in its class. It might perform an additional action or require
some unique handling. In this case one or more methods and related attributes (object variables)
can be added directly to the instance. These additional methods and attributes (object variables)
form a separate scope, independent of the class scopes found throughout the
rest of the hierarchy.</para>
<para>Methods can be added directly to an instance's collection of object
methods using <methodname>SETMETHOD</methodname>, a method of the
<classname>Object</classname> class. All subclasses of the
<classname>Object</classname> class inherit <methodname>SETMETHOD</methodname>. Alternately,
the <classname>Class</classname> class provides an <methodname>ENHANCED</methodname>
method that lets you create new instances of a class, whose object methods
are the instance methods of its class, but enhanced with the additional methods from a supplied collection of
methods.</para>
</section>
</section>

<section id="methna"><title>More about Methods</title>
<para><indexterm><primary>method names, specifying</primary></indexterm>
A method name can
be any character string. When an object receives a message, Rexx searches
for a method whose name matches the message name independent of its case.</para>

<para>You must surround a method name with quotation marks when it
is the same as an operator. The following example illustrates how to do this
correctly. It creates a new class (<classname>Cost</classname>),
defines a new method (<methodname>%</methodname>), creates an instance
of the <classname>Cost</classname> class (<emphasis role="italic">mycost</emphasis>), and sends
a <methodname>%</methodname> message to <emphasis role="italic">mycost</emphasis>:</para>
<example>
<title>Messages</title>

<programlisting>
<![CDATA[
say "Enter a price:"
pull p
mycost=.Cost~new(p)        /* Create a Cost instance        */

say "price:" mycost~price  /* ask current price             */
mycost~"%"                 /* send % (increase) message     */
say "price:" mycost~price  /* ask current price             */
say "%    :" mycost~"%"    /* send % (increase) message     */

::class Cost               /* Cost class                    */
::attribute price          /* allow access from others      */
::method init
  expose price increase    /* establish direct access to these attributes */
  use arg price            /* save argument with attribute  */
  increase=25              /* increase in percent           */

::method "%"               /* Increase price % method       */
  expose price increase    /* Produces: Enter a price.      */
  price=price*(100+increase)/100 /* increase                */
     return price             /* return increased price        */

Results (example

Enter a price:
100
price: 100
price: 125
%    : 156.25
]]>
</programlisting>

</example>

<section id="meths"><title>The Default Search Order for Selecting a Method</title>
<para>
<indexterm><primary>search order</primary>
<secondary>for methods, default</secondary></indexterm>
<indexterm><primary>methods</primary>
<secondary>selecting</secondary></indexterm>
<indexterm><primary>methods</primary>
<secondary>search order for</secondary></indexterm>
<indexterm><primary>default search order for methods</primary></indexterm>
When a message is sent to an object, Rexx looks for a method whose name
matches the message string ignoring case. If the message is <methodname>ADD</methodname>, for example, Rexx looks
for a method named <methodname>ADD</methodname>. Because, in the class hierarchy, there may be more
than one method with the same name, Rexx begins its search at the object specified
in the message. If the sought method is not found there, the search continues
up the hierarchy. Rexx searches in the following order: </para>
<orderedlist>
<listitem><para>A method the object defines itself
(with <methodname>SETMETHOD</methodname> or <methodname>ENHANCED</methodname>).</para></listitem>
<listitem><para>A method the object's class defines.</para>
<para>An object acquires the methods
of its parent class (that is, the class that created the object).
If the class subsequently receives new methods, objects predating the new
methods <emphasis role="italic">do not</emphasis> acquire them.</para></listitem>
<listitem><para>A method an object's superclass(es) define.</para>
<para>As with the object's
class, only methods that existed in the superclass when the object was created
are valid. Rexx searches the superclass method definitions in the order that
<methodname>INHERIT</methodname> messages were sent to an object's class.</para></listitem></orderedlist>

<para>
<indexterm><primary>UNKNOWN method</primary></indexterm>
If Rexx does not find a match
for the message name, Rexx checks the object for a method named <methodname>UNKNOWN</methodname>.
If it exists, Rexx calls the <methodname>UNKNOWN</methodname> method, and returns whatever the <methodname>UNKNOWN</methodname> method
returns. For more information on the <methodname>UNKNOWN</methodname> method, see
<xref linkend="unknown" />.
If the object does not have an <methodname>UNKNOWN</methodname> method, Rexx raises a <methodname>NOMETHOD</methodname> condition.
Any trapped information can then be inspected using Rexx's <methodname>CONDITION</methodname> built-in
function.</para>
<para>Rexx searches up the hierarchy so that methods
existing in classes at higher levels can be found. This search realizes the <emphasis role="italic">inheritance of methods</emphasis> from superclasses.
</para>

<figure><title>Searching the Hierarchy for a Method</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/rxoq0s06.svg" align="center" />
</imageobject>
</mediaobject>
</figure>

<para>For example, suppose you wrote a program that allows users to look up other
users' phone numbers. Your program includes a class called <classname>Phone_Directory</classname>,
and all its instances are users' names with phone numbers. You have included
a method in <classname>Phone_Directory</classname> called <methodname>NOTIFY</methodname> that reports some data to a file
whenever someone looks up a number. All instances of Phone_Directory use the
<methodname>NOTIFY</methodname> method.</para>
<para>Now you decide you want <methodname>NOTIFY</methodname>, in addition to its normal handling, to
personally inform you whenever anyone looks up your number.
To accommodate this special case for your name only, you create your own <methodname>NOTIFY</methodname>
method that adds the new task and replicates the file-handling task. You save
the new method as part of your own name instance, retaining the same name,
<methodname>NOTIFY</methodname>.</para>
<para>Now, when a <methodname>NOTIFY</methodname> message is sent to your name instance, the new version
of <methodname>NOTIFY</methodname> is found first. Rexx does not look further up the class hierarchy.
The instance-level version overrides the version at
the class level. This technique of overriding lets you change a method used
by one instance (&quot;one-off&quot; instance) without disturbing the common method used by all the other
instances. It is very powerful for that reason.</para>
</section>

<section id="xsearch"><title>Changing the Search Order for Methods</title>
<para>
<indexterm><primary>search order</primary>
<secondary>for methods, changing</secondary></indexterm>
<indexterm><primary>changing the search order for methods</primary></indexterm>
When composing a message, you
can change the default search order for methods by doing both of the following: </para>

<orderedlist>
<listitem><para>Making the receiver object the sender object.
<indexterm><primary>variables</primary>
<secondary>special</secondary></indexterm>
You usually do this by specifying the special variable
<emphasis role="italic">SELF</emphasis>. <emphasis role="italic">SELF</emphasis> holds the value of the object in which a method is running.
</para></listitem>

<listitem><para>Specifying a colon and a starting scope after the message name. The
starting scope is a variable or environment symbol that
identifies the scope object to use as the method search starting point.
This scope object can be:
<itemizedlist>
<listitem><para>A direct superclass of the class that defines the active method</para></listitem>
<listitem><para>The object itself (for example, the value of the variable <emphasis role="italic">SELF</emphasis>),
if you used <methodname>SETMETHOD</methodname> to add
methods to the object.
</para>

<para>
<indexterm><primary>variables</primary>
<secondary>special</secondary></indexterm>
The scope variable is usually the special variable
<emphasis role="italic">SUPER</emphasis>, but it can be any environment symbol
or variable name whose value is a valid superclass.</para></listitem>
</itemizedlist></para></listitem>
</orderedlist>

<para>
<indexterm><primary>SUBCLASS option</primary></indexterm>
In <xref linkend="sample" />, an <classname>Account</classname> subclass of the
<classname>Object</classname> superclass is created.
 It defines a <methodname>TYPE</methodname> method
for <classname>Account</classname>, and creates the <classname>Savings</classname> subclass
of <classname>Account.</classname>. The example defines
a <methodname>TYPE</methodname> method for the <classname>Savings</classname> subclass, as follows: </para>

<example>
<title>SUBCLASS Option</title>

<programlisting>
<![CDATA[
::class Savings subclass Account

  ::method "TYPE"
    return "a savings account"
]]>
</programlisting>
</example>
<para>To change
the search order so Rexx searches for <methodname>TYPE</methodname> in the <classname>Account</classname>
rather than <classname>Savings</classname>
subclass, enter this instead: </para>

<example>
<title>Changing the Subclass Method Search Order</title>

<programlisting>
<![CDATA[
  ::method "TYPE"
    return self~type:super -- returns the result of invoking the TYPE method of the superclass
]]>
</programlisting>
</example>
<para>When you create an <computeroutput>asav</computeroutput> instance of
the <classname>Savings</classname> subclass and send a <methodname>TYPE</methodname> message to
<computeroutput>asav</computeroutput>: </para>
<programlisting>
<![CDATA[
say asav~type
]]>
</programlisting>

<para>Rexx displays: </para>
<programlisting>
<![CDATA[
an account
]]>
</programlisting>
<para> rather than: </para>
<programlisting>
<![CDATA[
a savings account
]]>
</programlisting>
<para> because Rexx searches for <methodname>TYPE</methodname> in the <classname>Account</classname> class first.</para>
</section>

<section id="public"><title>Public versus Private Methods</title>
<para>
<indexterm><primary>search order</primary>
<secondary>for methods, changing</secondary></indexterm>
<indexterm><primary>public methods</primary></indexterm>
<indexterm><primary>methods</primary>
<secondary>public</secondary></indexterm>
<indexterm><primary>private methods</primary></indexterm>
<indexterm><primary>methods</primary>
<secondary>private</secondary></indexterm>
A method can be either public or private.
Any object can send a message that runs a <emphasis role="italic">public</emphasis> method.
A <emphasis role="italic">private</emphasis> method can only be invoked from specific calling contexts.
These contexts are:</para>
<orderedlist>
<listitem><para>From within a method owned by the same class as the target.  This is frequently
the same object, accessed via the special variable <emphasis role="italic">SELF</emphasis>.  Private methods of an object can also
be accessed from other instances of the same class (or subclass instances).
</para></listitem>
<listitem><para>From within a method defined at the same class scope as the method.  For example:</para>
<example>
<title>PUBLIC and PRIVATE options</title>

<programlisting>
<![CDATA[
::class Savings
::method newCheckingAccount CLASS
  instance = self~new
  instance~makeChecking
  return instance

::method makeChecking private
  expose checking
  checking = .true
]]>
</programlisting>
</example>
<para>The <methodname>newCheckingAccount</methodname> <methodname>CLASS</methodname> method
is able to invoke the <methodname>makeChecking</methodname> method because
the scope of the <methodname>makeChecking</methodname> method is <literal>.Savings</literal>.
</para></listitem>
<listitem><para>From within an instance (or subclass instance) of a class to a private class
method of its class.  For example:</para>
<example>
<title>PUBLIC and PRIVATE Options</title>

<programlisting>
<![CDATA[
::class Savings
::method init class
  expose counter
  counter = 0

::method allocateAccountNumber private class
  expose counter
  counter = counter + 1
  return counter

::method init
  expose accountNumber
  accountNumber = self~class~allocateAccountNumber
]]>
</programlisting>
</example>
<para>The instance <methodname>INIT</methodname> method of the <classname>Savings</classname> class is able to invoke the
<methodname>allocateAccountNumber</methodname> private
method of the <literal>.Savings</literal> class object because it is owned by an
instance of the <literal>.Savings</literal> class.</para>
</listitem>
</orderedlist>
<para>Private methods include methods at different scopes within the same object.
This allows superclasses to make methods available to their subclasses while
hiding those methods from other objects. A private method is like an internal
subroutine. It shields the internal information of an object to outsiders, but allowing
objects to share information with each other and their defining classes.
</para>
</section>

<section id="unknown"><title>Defining an UNKNOWN Method</title>
<para>
<indexterm><primary>UNKNOWN method</primary></indexterm>
When an object receives
a message that has no matching method, Rexx checks to see if the object has a method
named <methodname>UNKNOWN</methodname>. If it does, Rexx calls the <methodname>UNKNOWN</methodname> method, passing two arguments. The
first is the name of the method that was not located. The second is an array
containing the arguments passed with the original message.</para>
</section>
</section>

<section id="concur"><title>Concurrency</title>
<para>
<indexterm><primary>concurrency</primary></indexterm>
In object-oriented
programming, as in the real world, objects interact with each other. Assume,
for example, throngs of people interacting at rush hour in the business district
of a big city. A program that aspires to simulate the real world would have
to enable many objects to interact at any given time. That could mean thousands
of objects running simultaneously, all of them sending messages to each other.
In Rexx, the term for this simultaneous activity is called concurrency.
To be precise, the concurrency is <emphasis role="italic">object-oriented</emphasis>
concurrency because it involves objects, as opposed to, for example, processes or threads.</para>
<para>Rexx objects are inherently concurrent, and this concurrency takes the
following forms: </para>
<itemizedlist>
<listitem><para><emphasis role="italic">Inter-object concurrency</emphasis>, where several objects
are active (exchanging messages, synchronizing, running their methods, etc.) at
the same time</para></listitem>
<listitem><para><emphasis role="italic">Intra-object concurrency</emphasis>, where several methods
are able to run on the same object at the same time</para></listitem>
</itemizedlist>
<para>The default settings in Rexx allow full inter-object concurrency but limited
intra-object concurrency. Some situations, however, call for full intra-object
concurrency.</para>

<section id="interobjconcur"><title>Inter-Object Concurrency</title>
<para>
<indexterm><primary>inter-object concurrency</primary></indexterm>
Rexx provides for inter-object
concurrency, where several objects in a program can run at the same time,
in the following ways: </para>
<itemizedlist>
<listitem>
<para>
<indexterm><primary>REPLY instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>REPLY instruction</secondary></indexterm>
By early reply, using the
<methodname>REPLY</methodname> instruction</para></listitem>
<listitem><para>Using message objects</para></listitem></itemizedlist>
<para>Early reply allows
the object that sends a message to continue processing after the message is
sent. Meanwhile, the receiving object runs the method corresponding to the
message. This method contains the <methodname>REPLY</methodname> instruction, which returns any results
to the sender, interrupting the sender just long enough to reply. The sender
and receiver continue operating simultaneously.</para>
<para>Alternatively, an independent message object can
be created and sent to a receiver. One difference in this approach is that
any reply returned does not interrupt the sender. The reply waits until the
sender asks for it. In addition, message objects can notify the sender about
the completion of the method it sent, and even specify synchronous or asynchronous
method activation.</para>

<para>
<indexterm><primary>thread</primary></indexterm>
<indexterm><primary>activities</primary></indexterm>
The chains of execution represented by the sender and receiver methods
are called <emphasis role="italic">activities</emphasis>.
An <emphasis role="italic">activity</emphasis> is a thread of execution that
can run methods concurrently with methods on other activities. In other words,
<emphasis role="italic">activities</emphasis> can run at the same time.</para>
<para>An <emphasis role="italic">activity</emphasis> contains a stack of invocations that
represent the Rexx programs running on the <emphasis role="italic">activity</emphasis>. An invocation can be:</para>
<itemizedlist>
<listitem><para>A main program invocation</para></listitem>
<listitem><para>An internal function or subroutine call</para></listitem>
<listitem><para>An external function or subroutine call</para></listitem>
<listitem><para>An <methodname>INTERPRET</methodname> instruction</para></listitem>
<listitem><para>A message invocation</para></listitem></itemizedlist>
<para>An invocation is pushed onto an <emphasis role="italic">activity</emphasis> when an executable unit is invoked.
It is removed (or popped) when execution completes.</para>

<section id="objvarpools"><title>Object (Instance) Variables (Attributes)</title>
<para>
<indexterm><primary>object instance variables</primary></indexterm>
<indexterm><primary>object variables</primary>
<secondary>exposing</secondary></indexterm>
<indexterm><primary>instance variables</primary>
<secondary>exposing</secondary></indexterm>
<indexterm><primary>attributes</primary>
<secondary>exposing</secondary></indexterm>
Every object has its own set of instance variables, also known as attributes.
These are variables associated solely with the
object. When an object's method runs, it first identifies the instance variables (attributes)
it intends to work with.
Technically, it &quot;exposes&quot; these instance (object) variables, using
the Rexx instruction <methodname>EXPOSE</methodname>. Exposing the object's variables distinguishes
them from variables used by the method itself, which are not exposed. Every
method an object owns&mdash;that is, all the instance methods in the object's
class&mdash;can expose variables from the object's instance variables (attributes).</para>
<para>Therefore, an object's instance variables includes variables:</para>
<itemizedlist>
<listitem><para>Exposed by methods defined by the object's class. This set of instance variables is
called an object variable (attribute) pool.</para></listitem>
<listitem><para>Exposed by methods defined by other classes in the inheritance hierarchy.
The methods of each class share object variables (attributes) in a pool scoped to just that class.</para></listitem>
</itemizedlist>
<para>A class's object variable (attribute) pool, together with the methods that expose them,
is called a class scope. Rexx exploits this class
scope to achieve concurrency. To explain in more detail, the object's instance variables are contained
in a collection of instance variable (attribute) pools. Each instance variable (attribute) pool is at a different scope in the object's
inheritance chain. Methods defined at different class scopes do not directly share data,
and can therefore run simultaneously.</para>
<para>Scopes, like objects, hide and protect data from outside manipulation.
Methods of the same scope share the instance variable (attribute) pool of that scope. The scope
shields the instance variable (attribute) pool from methods operating at other scopes. This is why
you can reuse object variable (attribute) names from class to class, without the variables (attributes) being
accessed and possibly corrupted by a method outside their own class. So class
scopes serve to divide an object's instance variables (attributes) into pools that can operate
independently of each another. Several methods can use the same object instance variables (attributes)
concurrently, as long as they confine themselves to instance variables (attributes) in their own
scope.</para>
</section>

<section id="prioritizeaccess"><title>Prioritizing Access to Instance Variables (Attributes)</title>
<para>
<indexterm><primary>access to object variables, prioritizing</primary></indexterm>
<indexterm><primary>prioritizing access to object variables</primary></indexterm>
<indexterm><primary>access to attributes, prioritizing</primary></indexterm>
<indexterm><primary>prioritizing access to attributes</primary></indexterm>
<indexterm><primary>locking a scope</primary></indexterm>
Even with class scopes and subpools,
an object variable (attribute) is vulnerable if several methods within the scope try to access
it at the same time. To handle this, Rexx ensures that when a particular method
is activated and exposes object variables (attributes) from its scope, that method has exclusive
use of the scope variable (attribute) pool until processing is complete. Until then, Rexx delays the
execution of any other method that needs the same scope object variables (attributes).</para>
<para>Thus if different activities send several messages to the same object,
Rexx forces the methods to run sequentially within a single scope. This
&quot;first-in, first-out&quot; processing of methods in a scope
prevents them from simultaneously accessing one object variable (attribute), and possibly
corrupting the data.</para>
</section>

<section id="sendmsgwact"><title>Sending Messages within an Activity</title>
<para>
<indexterm><primary>sending messages within an activity</primary></indexterm>
Rexx makes one
exception to sequential processing&mdash;when a method sends a message to
itself. Assume that method <emphasis role="italic">M1</emphasis> has exclusive access to object <emphasis role="italic">O</emphasis>, and then tries
to run a second, internal method <emphasis role="italic">M2</emphasis>, also belonging
to <emphasis role="italic">O</emphasis>. Internal method <emphasis role="italic">M2</emphasis> would try to run, but Rexx would delay it until the
original method <emphasis role="italic">M1</emphasis> finished. Yet <emphasis role="italic">M1</emphasis> would be unable to proceed
until <emphasis role="italic">M2</emphasis> ran.
The two methods would become deadlocked. In actual practice Rexx intervenes
by treating internal method <emphasis role="italic">M2</emphasis> like a subroutine call. In this case, Rexx
runs method <emphasis role="italic">M2</emphasis> immediately, then continues processing method <emphasis role="italic">M1.</emphasis></para>
<para>The mechanism controlling this
is the <emphasis role="italic">activity</emphasis>. Typically, whenever a message is invoked on an object, the
<emphasis role="italic">activity</emphasis> acquires exclusive access by locking the
object's scope. Any other <emphasis role="italic">activity</emphasis> sending a message to the object whose
scope is locked must wait until the first activity releases the lock. The
situation is different, however, if the messages originate from the same
<emphasis role="italic">activity</emphasis>. When an invocation running on an <emphasis role="italic">activity</emphasis> sends another
message to the same object, the method is allowed
to run because the activity has already acquired the lock for the scope. Thus,
Rexx permits nested, nonconcurrent method invocations on a single activity.
No deadlocks occur because Rexx treats these additional messages as subroutine
calls.</para>
</section>
</section>

<section id="intraobjconcur"><title>Intra-Object Concurrency</title>
<para>
<indexterm><primary>intra-object concurrency</primary></indexterm>
Several methods can
access the same object at the same time only if they are operating at different
scopes. That is because they are working with separate variable (attribute) subpools.
If two methods in the same scope try to run on the object, Rexx by default
processes them on a &quot;first-in, first-out&quot; basis, while treating internal
methods as subroutines. You can, however, achieve full intra-object concurrency.
Rexx offers several mechanisms for this, including: </para>
<itemizedlist>
<listitem><para>The <methodname>UNGUARDED</methodname> option of
the <methodname>::METHOD</methodname> directive, which provide unconditional intra-object concurrency.
</para></listitem>

<listitem><para>
<indexterm><primary>GUARD instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>GUARD instruction</secondary></indexterm>
The <methodname>GUARD OFF</methodname> and <methodname>GUARD ON</methodname> instructions, which permit switching between
intra-object and default concurrency.</para></listitem></itemizedlist>

<para>When intra-object concurrency at the scope level is needed,
you must specifically employ these mechanisms (see the following section).
Otherwise, Rexx sequentially processes the methods when they are competing
for the same object variables (attributes).</para>

<section id="activat"><title>Activating Methods</title>
<para>By default, Rexx assumes that an active method requires exclusive use of
its scope variable (attribute) pool. If another method attempts access at that time,
it is locked out until the first method finishes.
This default intra-object serialization maintains the integrity of the instance variable (attribute)
pool and prevents unexpected results. Rexx manages queues for incoming requests
that result in messages being sent to the same object.</para>
<para>Some methods can run concurrently without affecting instance variable (attribute) pool integrity
or yielding unexpected results. When a method does not need exclusive use
of its object variable (attribute) pool, use the <methodname>UNGUARDED</methodname>
option of the <methodname>::METHOD</methodname> directive to provide unconditional intra-object concurrency.
These mechanisms control the locking of an object's scope when a method
is invoked.</para>
<para>Many methods cannot use the <methodname>UNGUARDED</methodname> option
because they sometimes require exclusive use of their object variable (attribute) pool. At other
times, they must perform some action that involves the concurrent use of the
same pool by a method on another activity. In this case, you can use the <methodname>GUARD</methodname>
keyword instruction. When the method reaches the point in its processing where
it no longer requires exclusive use of the object variable (attribute) pool, it can use the <methodname>GUARD OFF</methodname> instruction
to allow methods running on different activities to become active on the same scope.
If the method needs to regain exclusive
use, it uses the <methodname>GUARD ON</methodname> instruction.</para>
<para>For more flexibility when activating methods, you can use <methodname>GUARD ON/OFF</methodname>
with the &quot;<methodname>WHEN</methodname> <emphasis role="italic">expression</emphasis>&quot;
option. Add this instruction to the
method code at the point where exclusive use of the object variable (attribute) pool becomes
conditional. When processing reaches this point, Rexx evaluates
<emphasis role="italic">expression</emphasis> to determine if it is true
or false.</para>
<para>For example, if you specify &quot;<methodname>GUARD OFF WHEN</methodname>
<emphasis role="italic">expression</emphasis>&quot;, the
active method keeps running until <emphasis role="italic">expression</emphasis>
becomes true. To become true, another method must assign or drop an object
variable (attribute) that is named in <emphasis role="italic">expression</emphasis>.
Whenever an object variable (attribute) changes, Rexx reevaluates
<emphasis role="italic">expression.</emphasis> If
<emphasis role="italic">expression</emphasis> becomes true, <methodname>GUARD</methodname> is turned off,
exclusive use of the object variable (attribute) pool is released, and other methods needing
exclusive use can begin running. If
<emphasis role="italic">expression</emphasis> becomes false again,
<methodname>GUARD</methodname> is turned on and the active method regains exclusive use. </para>

<note>
<para>If <emphasis role="italic">expression</emphasis> cannot be met,
<methodname>GUARD ON WHEN</methodname> puts the program
in a continuous wait condition. This can occur in particular when several
activities run concurrently. A second activity can make
<emphasis role="italic">expression</emphasis> invalid
before <methodname>GUARD ON WHEN</methodname> can use it.</para></note>
</section>
</section>
</section>
</chapter>
