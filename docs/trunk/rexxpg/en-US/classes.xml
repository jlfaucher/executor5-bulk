<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "rexxpg.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: Programming Guide XML file.
    #
    # Copyright (c) 2005-2017, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<chapter id="classes"><title>A Closer Look at Objects</title>
<indexterm><primary>variables</primary>
<secondary>in objects</secondary></indexterm>
<para>This chapter covers the mechanics of using objects in more
detail. First, a quick refresher.</para>
<para>A Rexx object consists
of:</para>
<itemizedlist>
<listitem><para>Actions coded as methods</para></listitem>
<listitem><para>Attributes, coded as variables, and their
values, sometimes referred to as &quot;state data&quot;</para></listitem>
</itemizedlist>
<para>Sending a message to an object causes it to perform a related action. The
method with the matching name performs the action. The message is
the interface to the object, and with information hiding, only methods
that belong to an object can access its variables.</para>
<para>Objects are grouped hierarchically into classes. The
class at the top of the hierarchy is the Object class. Everything below it
in the hierarchy belongs to the Object class and is therefore an object. As
a result, all classes are objects.</para>
<para>In a class hierarchy, classes, superclasses, and subclasses are relative
to one another. Unless designated otherwise, any class directly above a class
in the hierarchy is a superclass, and any class below is a subclass.</para>
<para>From a class you can create instances of the class. Instances
are merely similar objects that fit the template
of the class; they are "of" the class, but are not classes themselves.
</para>
<para>Both the classes
and their instances contain variables and methods. The methods a class provides
for use by its instances are called instance methods. The instance methods
define which messages an object can respond to.
</para>
<para>The methods available
to the class itself are called class methods.
Many of the methods
are actually the instance methods of the Class class, but a class many have its
own unique class methods.
They define messages
that only the class&mdash;and not its instances&mdash;can respond to.
</para>

<figure><title>Instance Methods and Class Methods</title>
<indexterm><primary>class methods</primary></indexterm>
<indexterm><primary>instance methods</primary></indexterm>
<mediaobject>
<imageobject>
<imagedata fileref="images/InstanceMethods.svg" align="center" scale="70" />
</imageobject>
</mediaobject>
</figure>

<section id="xclauses"><title>Using Objects in Rexx</title>
<indexterm><primary>clauses</primary>
<secondary>using object in</secondary></indexterm>
<para>The following
examples with <emphasis role="italic">myarray</emphasis> illustrate how to use new objects in Rexx programs.</para>
<para></para>
<programlisting>
<![CDATA[
myarray=.array~new(5)
]]>
</programlisting>
<para>creates a new instance of the Array
class, and assigns to the variable <emphasis role="italic">myarray</emphasis>. The period precedes a class name
in an expression, to distinguish
the class environment symbol from other variables.
The <emphasis role="italic">myarray</emphasis> array object has five elements.</para>
<para>After the array is created, you can assign values to it. One way is with
the <emphasis role="italic">PUT</emphasis> method. <emphasis role="italic">PUT</emphasis> has two arguments, which must be enclosed in parentheses.
The first argument is the value added to the array, the second is
the number of the element in which to place the value. Here, the string
object <computeroutput>Hello</computeroutput> is associated with the third
element of <emphasis role="italic">myarray</emphasis>: </para>
<programlisting>
<![CDATA[
myarray~put("Hello",3)
]]>
</programlisting>
<para>One way to retrieve values from an array object is by sending it an <emphasis role="italic">AT</emphasis> message.
In the next example, the <emphasis role="italic">SAY</emphasis> instruction displays the third element of <emphasis role="italic">myarray</emphasis>: </para>
<programlisting>
<![CDATA[
say myarray~at(3)

Results:

Hello
]]>
</programlisting>
<indexterm><primary>SAY instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>SAY instruction</secondary></indexterm>
<para>The <emphasis role="italic">SAY</emphasis>
instruction expects a string object as input, which is what <emphasis role="italic">AT</emphasis> returns.
If you try to display a non-string object in the SAY instruction, <emphasis role="italic">SAY</emphasis> sends a <emphasis role="italic">STRING</emphasis> message
to the object.  The <emphasis role="italic">STRING</emphasis> method returns
a human-readable string representation for the object.
<indexterm><primary>STRING method</primary></indexterm>
In this example, the <emphasis role="italic">STRING</emphasis> method for an Array object returns the string
<computeroutput>an Array</computeroutput>: </para>
<programlisting>
<![CDATA[
say myarray  /* SAY sends STRING message to Myarray */

Results:

an Array
]]>
</programlisting>
<para>Whenever a method returns a string, you can use it within expressions that
require a string. Here, the element of the array that <emphasis role="italic">AT</emphasis> returns is a string, so you can put an
expression containing the <emphasis role="italic">AT</emphasis> method inside a string function like <emphasis role="italic">COPIES()</emphasis>:</para>
<programlisting>
<![CDATA[
say copies(myarray~at(3),4)

Results:
HelloHelloHelloHello
]]>
</programlisting>
<para>This example produces the same result using only methods: </para>
<programlisting>
<![CDATA[
say myarray~at(3)~copies(4)
]]>
</programlisting>
<para>Notice that the expression is evaluated from left to right. You can also
use parentheses to enforce an order of evaluation.</para>
<para>Almost all messages are sent using the twiddle, but there are exceptions.
The exceptions are to improve the reliability of the language. The following
example uses the <emphasis role="italic">[]=</emphasis> (left-bracket right-bracket equal-sign) and <emphasis role="italic">[]</emphasis>
methods to set and retrieve array elements: </para>
<programlisting>
<![CDATA[
myarray[4]="the fourth element"
say myarray[4]
]]>
</programlisting>
<para>Although the previous instructions look like an ordinary array assignment
and array reference, they are actually messages to the Array object referenced by <emphasis role="italic">myarray</emphasis>. You
can prove this by executing these equivalent instructions, which use the twiddle
to send the messages: </para>
<programlisting>
<![CDATA[
myarray~"[]="("a new test",4)
say myarray~"[]"(4)
]]>
</programlisting>
<para>Similarly, expression operators (such as +, -, /, and *) are actually methods,
but you do not have to use the twiddle to send them: </para>
<programlisting>
<![CDATA[
say 2+3      /* Displays 5 */
say 2~"+"(3) /* Displays 5 */
]]>
</programlisting>
<para>In the second <emphasis role="italic">SAY </emphasis>instruction, <emphasis role="italic">"+"</emphasis> must be a literal string because the message name
contains characters not allowed in a Rexx symbol.</para>
</section>

<section id="creo"><title>Common Methods</title>
<para>When running your program, three methods that Rexx looks for, and runs
automatically when appropriate, are <emphasis role="italic">INIT</emphasis>, <emphasis role="italic">UNINIT</emphasis>, and <emphasis role="italic">STRING</emphasis>.</para>

<section id="init"><title>Initializing Instances Using <emphasis role="italic">INIT</emphasis></title>
<para>Object classes can create instances.
When these instances require initialization, you'll want to define an
<emphasis role="italic">INIT</emphasis> method to set a particular starting value or initiate some startup processing.
Rexx looks for an <emphasis role="italic">INIT</emphasis> method whenever a new object is created and runs it.</para>
<para>The purpose of initialization is to ensure that the
instance variables are initialized correctly
before being used in an operation. If an <emphasis role="italic">INIT</emphasis> method is defined, Rexx runs it
after creating the instance.
<indexterm><primary>INIT method</primary></indexterm>
Any initialization arguments specified in the
<emphasis role="italic">NEW</emphasis> message are passed to the
<emphasis role="italic">INIT</emphasis> method, which can use them
to set the initial states of object variables.</para>
<para>If a class overrides the <emphasis role="italic">INIT</emphasis> method it inherits from a superclass,
the new <emphasis role="italic">INIT</emphasis> method must forward the <emphasis role="italic">INIT</emphasis> message up the
hierarchy, to properly initialize the
instance. An example in the next section demonstrates the use of <emphasis role="italic">INIT</emphasis>.</para>
</section>

<section id="retstr"><title>Returning String Data Using <emphasis role="italic">STRING</emphasis></title>
<indexterm><primary>SAY instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>SAY instruction</secondary></indexterm>
<indexterm><primary>STRING method</primary></indexterm>

<para>The <emphasis role="italic">STRING</emphasis> method
is a useful way to access object data and return it in string form for use
by your program. When a
<emphasis role="italic">SAY</emphasis> instruction is processed in Rexx, Rexx automatically
sends a <emphasis role="italic">STRING</emphasis> message to the object specified in the expression. Rexx uses
the <emphasis role="italic">STRING</emphasis> method of the Object class and returns a human-readable string
representation for the object. For example, if you instruct Rexx
to <computeroutput>say a</computeroutput>, and
<computeroutput>a</computeroutput> is an array object, Rexx returns an array.
<!-- TODO: needs a rewording as now a .endofline delimited list of  elements' string values -->
You can take advantage of this automatic use of <emphasis role="italic">STRING</emphasis> by overriding Rexx's
<emphasis role="italic">STRING</emphasis> method with your own, and extract the object data itself&mdash;in this
case, the actual array data.</para>
<para>The following programs
demonstrate <emphasis role="italic">STRING</emphasis> and <emphasis role="italic">INIT</emphasis>.
<indexterm><primary>directives</primary>
<secondary>sample program</secondary></indexterm>
In the first program, the Part class is created,
and along with it, the two methods under discussion, <emphasis role="italic">STRING</emphasis> and <emphasis role="italic">INIT</emphasis>: </para>
<example>
<title><emphasis role="italic">STRING</emphasis> and <emphasis role="italic">INIT</emphasis> Methods</title>
<programlisting>
<![CDATA[
/* partdef.rex - Class and method definition file */

/* Define the Part class as a public class */
::class Part public

/* Define the INIT method to initialize object variables */
::method init
expose name description number
use arg name, description, number

/* Define the STRING method to return a string with the part name */
::method string
expose name
return "Part name:" name
]]>
</programlisting>
</example>
<para>In the <emphasis role="italic">::CLASS</emphasis> directive, the
keyword <emphasis role="italic">PUBLIC</emphasis> indicates that the class can be shared with other programs.
The two <emphasis role="italic">::METHOD</emphasis> directives define
<emphasis role="italic">INIT</emphasis> and <emphasis role="italic">STRING</emphasis>. Whenever Rexx creates
a new instance of a class, it calls the <emphasis role="italic">INIT</emphasis> method of the new instance. The sample
<emphasis role="italic">INIT</emphasis> method uses an <emphasis role="italic">EXPOSE</emphasis> instruction to make the name, description, and
number variables available to other methods. These exposed variables are object
variables, and are associated with a single instance of a class:</para>

<figure><title>Instances in the <emphasis role="italic">Part</emphasis> Class</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/PartClass.svg" align="center" scale="75" />
</imageobject>
</mediaobject>
</figure>

<para>The INIT method expects to be passed three arguments.
<indexterm><primary>Rexx</primary>
<secondary>USE ARG instruction</secondary></indexterm>
<indexterm><primary>USE ARG instruction</primary></indexterm>
The <emphasis role="italic">USE ARG</emphasis> instruction assigns these three arguments to the name, description,
and number variables, respectively. Because those variables are exposed, the
values are available to other methods.</para>

<para>The <emphasis role="italic">STRING</emphasis> method returns the string
<computeroutput>Part name:</computeroutput>, followed
by the name of a part. The <emphasis role="italic">STRING</emphasis> method (of the Part class) does not expect any arguments.
<indexterm><primary>EXPOSE instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>EXPOSE instruction</secondary></indexterm>
<indexterm><primary>variables</primary>
<secondary>exposing</secondary></indexterm>
It uses the <emphasis role="italic">EXPOSE</emphasis> instruction to identify which object variables it requires.
The <emphasis role="italic">RETURN</emphasis> instruction returns the result string.</para>

<para>The following example shows how to use the <emphasis role="italic">Part</emphasis> class: </para>
<example>
<title>How to use the <emphasis role="italic">Part</emphasis> class</title>
<programlisting>
<![CDATA[
/* usepart.rex - use the Part class */
mypartA=.part~new("Widget","A small widge",12345)
mypartB=.part~new("Framistat","Device to control frams",899)
say mypartA
say mypartB
exit
::requires partdef
]]>
</programlisting>
</example>
<para>The <filename>usepart.rex</filename> program creates two parts, which are instances of the Part
class. It then displays the names of the two parts.</para>
<para>Rexx processes all directives before running your program.
<indexterm><primary>directives</primary>
<secondary>::REQUIRES</secondary></indexterm>
The <emphasis role="italic">::REQUIRES</emphasis> directive indicates
that the program needs access to public class definitions that are in another
program. In this case, the <emphasis role="italic">::REQUIRES</emphasis> directive refers to the <filename>partdef.rex</filename> program,
which contains the Part definition.</para>

<para>The assignment instructions for
<emphasis role="italic">mypartA</emphasis> and <emphasis role="italic">mypartB</emphasis> create two objects that are instances of the Part class.
The objects are created by sending a <emphasis role="italic">NEW</emphasis> message to the Part class. The <emphasis role="italic">NEW</emphasis>
message causes the <emphasis role="italic">INIT</emphasis> method to be invoked as part of object creation. The
<emphasis role="italic">INIT</emphasis> method takes the three arguments you provide and makes them part of the
object's own exclusive set of variables, called a variable pool. Each object
has its own variable pool (name, description, and number).</para>
<para>The <emphasis role="italic">SAY</emphasis>
instruction sends a <emphasis role="italic">STRING</emphasis> message to the object. In the first <emphasis role="italic">SAY</emphasis> instruction,
the <emphasis role="italic">STRING</emphasis> message is sent to <emphasis role="italic">MypartA</emphasis>.
<indexterm><primary>SAY instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>SAY instruction</secondary></indexterm>
<indexterm><primary>STRING method</primary></indexterm>

The <emphasis role="italic">STRING</emphasis> method accesses the Name
object variable for <emphasis role="italic">MypartA</emphasis> and returns it as part of a string. In the second
<emphasis role="italic">SAY</emphasis> instruction, the <emphasis role="italic">STRING</emphasis> message is sent again, but to a different object:
<emphasis role="italic">MypartB</emphasis>. Because the <emphasis role="italic">STRING</emphasis> method is invoked for <emphasis role="italic">MypartB</emphasis>, it automatically
accesses the variables for <emphasis role="italic">MypartB</emphasis>. You do not need to pass the name of the
object to the method in order to distinguish different sets of object variables;
Rexx keeps track of them for you.</para>
</section>

<section id="destroy"><title>Uninitializing and Deleting Instances Using <emphasis role="italic">UNINIT</emphasis></title>
<indexterm><primary>UNINIT method</primary></indexterm>
<indexterm><primary>instances</primary>
<secondary>uninitializing and deleting</secondary></indexterm>
<para>Normally, object
classes can create instances but have no direct control over their deletion.
Once an object is no longer referenced by any variables,
Rexx automatically reclaims the storage
for the old value in a process called garbage collection.</para>
<para>
If the instance has allocated other system resources,
Rexx cannot automatically release these
resources because it is unaware that the instance has allocated them.
An <emphasis role="italic">UNINIT</emphasis> method give an object the opportunity to perform resource cleanup before
the object is reclaimed by the garbage collector.
</para>
<para>In the following example, the value passed to
<emphasis role="italic">text</emphasis> is initialized
by Rexx using <emphasis role="italic">INIT</emphasis> and deleted by Rexx using <emphasis role="italic">UNINIT</emphasis>. This program makes visible
Rexx's automatic invocation of INIT and <emphasis role="italic">UNINIT</emphasis> by revealing its processing
on the screen using the <emphasis role="italic">SAY</emphasis> instruction: </para>
<example>
<title><emphasis role="italic">UNINIT</emphasis> Method</title>
<programlisting>
/* uninit.rex - example of UNINIT processing */

a=.scratchpad~new("Of all the things I&apos;ve lost")
a=.scratchpad~new("I miss my mind the most")
say "Exiting program."
exit

::class scratchpad

  ::method init
    expose text
    use arg text
    say "Remembering" text

  ::method uninit
    expose text
    say "Forgetting" text
    return
</programlisting>
</example>
<para>Whether uninitialization processing is needed depends on the circumstances,
If the object only contains references to normal Rexx objects, an <emphasis role="italic">UNINIT</emphasis> method
is generally not needed.  If the object contains references to external system
resources such as open network connections or database connections, an <emphasis role="italic">UNINIT</emphasis> method
might be required to release those resources.
If an object requires uninitialization, define an <emphasis role="italic">UNINIT</emphasis>
method to perform the cleanup processing you require.</para>
<para>If an object has an <emphasis role="italic">UNINIT</emphasis> method, Rexx runs it before reclaiming the object's storage.
If an instance overrides an <emphasis role="italic">UNINIT</emphasis> method of a superclass,
each <emphasis role="italic">UNINIT</emphasis> method is responsible for sending the <emphasis role="italic">UNINIT</emphasis>
message up the hierarchy, using the <emphasis role="italic">SUPERCLASS</emphasis> overrides, so that each inherited <emphasis role="italic">UNINIT</emphasis> method
has the opportunity to run.</para>
</section>
</section>

<section id="spvar"><title>Special Method Variables</title>
<indexterm><primary>special variable</primary></indexterm>
<indexterm><primary>variables</primary>
<secondary>special</secondary></indexterm>
<para>When writing methods, there are several special variables
that are set automatically when a method runs.
Rexx supports the following
variables: </para>
<variablelist>
<varlistentry><term><emphasis role="italic">SELF</emphasis>
<indexterm><primary>SELF special variable</primary></indexterm>
</term>
<listitem><para>is set when a method
is activated. Its value is the object that forms the execution context for
the method (that is, the object that received the activating message). </para>
<para>You
can use <emphasis role="italic">SELF</emphasis> to:</para>
<itemizedlist>
<listitem><para>Send messages to the currently active object.
For example, a <emphasis role="italic">FIND_CLUES</emphasis> method is running in an object called <emphasis role="italic">Mystery_Novel</emphasis>.
When <emphasis role="italic">FIND_CLUES</emphasis> finds a clue, it sends a <emphasis role="italic">READ_LAST_PAGE</emphasis>
message to <emphasis role="italic">Mystery_Novel</emphasis>:
<programlisting>
<![CDATA[
self~read_last_page
]]>
 </programlisting></para></listitem>
<listitem><para>Pass references regarding an object to the methods of other
objects. For example, a <emphasis role="italic">SING</emphasis> method is running in object <emphasis role="italic">Song</emphasis>. The code:
<programlisting>
<![CDATA[
Singer2~duet(self)
]]>
</programlisting>
would give the <emphasis role="italic">DUET</emphasis> method access to the same Song.</para>
</listitem></itemizedlist>
</listitem></varlistentry>
<varlistentry><term><emphasis role="italic">SUPER</emphasis>
<indexterm><primary>SUPER special variable</primary></indexterm>
</term>
<listitem><para>is set when a method
is activated. Its value is the class object that is the usual starting point
for a superclass method lookup for the <emphasis role="italic">SELF</emphasis> object. This is the first immediate
superclass of the class that defined the method currently running. </para>
<para>The
special variable <emphasis role="italic">SUPER</emphasis> lets you call a method in the superclass of an object.
For example, the following Savings class has <emphasis role="italic">INIT</emphasis> methods that the Savings
class, Account class, and Object class define. </para>
<example>
<title><emphasis role="italic">SELF</emphasis> Variable</title>
<programlisting>
<![CDATA[
::class Account

  ::method INIT
    expose balance
    use arg balance
    self~init:super    /* Forwards to the Object INIT method */

  ::method TYPE
    return "an account"

  ::method name attribute

::class Savings subclass Account

  ::method INIT
    expose interest_rate
    use arg balance, interest_rate
    self~init:super(balance)  /* Forwards to the Account INIT method */

  ::method type
    return "a savings account"
]]>
</programlisting>
</example>
<para>When the <emphasis role="italic">INIT</emphasis> method of the <emphasis role="italic">Savings</emphasis>
class is called, the variable <emphasis role="italic">SUPER</emphasis> is set to the <emphasis role="italic">Account</emphasis> class object. For
example: </para>
<programlisting>
<![CDATA[
self~init:super(balance)
]]>
</programlisting><para>This instruction calls
the <emphasis role="italic">INIT</emphasis> method of the <emphasis role="italic">Account</emphasis>
class rather than recursively calling the <emphasis role="italic">INIT</emphasis>
method of the <emphasis role="italic">Savings</emphasis> class. When the <emphasis role="italic">INIT</emphasis> method
of the <emphasis role="italic">Account</emphasis> class is
called, the variable <emphasis role="italic">SUPER</emphasis> is assigned to the <emphasis role="italic">Object</emphasis> class.
So in the <emphasis role="italic">Account</emphasis> class
<emphasis role="italic">INIT</emphasis>: </para>

<programlisting>
<![CDATA[
self~init:super
]]>
</programlisting><para>calls the <emphasis role="italic">INIT</emphasis> method of the Object
class.</para>
</listitem></varlistentry>
</variablelist>
</section>

<section id="pubobj"><title>Public, Local, and Built-In Environment Objects</title>
<indexterm><primary>public objects</primary></indexterm>
<indexterm><primary>local objects</primary></indexterm>
<indexterm><primary>built-in objects</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>public objects</secondary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>local objects</secondary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>built-in objects</secondary></indexterm>
<para>In addition to the special variables, Rexx provides
a unique set of objects, called environment objects. Environment
objects are members of the Object class only. Rexx makes the following environment
objects available:</para>

<section id="publicenvobj"><title>The Public Environment Object (<literal>.environment</literal>)</title>
<indexterm><primary>Environment objects</primary></indexterm>
<para>The Environment object is a directory of public objects that are always
accessible throughout the whole process.  The Rexx built-in classes are stored in the
Environment directory.
To place something in the Environment
directory, you use the form: </para>
<programlisting>
<literal>.environment</literal>~<emphasis role="italic">your.object</emphasis> = <emphasis role="italic">value</emphasis>
</programlisting>
<para> Include a period (<code>.</code>) in any object name you use, to avoid
conflicts with current or future Rexx entries to the Environment directory.
To retrieve your object, you use the form: </para>
<programlisting>
say <literal>.environment</literal>~<emphasis role="italic">your.object</emphasis>
</programlisting>

<para>The scope of <literal>.environment</literal> is
<indexterm><primary>symbols</primary>
<secondary>.environment symbol</secondary></indexterm>
the current process, which means it is shared among all interpreter instances
executing in this process.
</para>
<para>You use an environment symbol to access the entries of this
directory. An environment symbol starts with a period and has at least one
other character, and the symbol is not a valid numeric value. You have seen environment symbols
earlier; for example in: </para>
<programlisting>
<![CDATA[
asav = <literal>.savings</literal>~new
]]>
</programlisting><para> <literal>.Savings</literal> is
an environment symbol, and refers to the Savings class. The classes
you create can be referenced with an environment symbol. There is an environment
symbol for each Rexx-defined class, as well as for each of the unique objects
this section describes, such as the <emphasis role="italic">Nil</emphasis> object.</para>

<section id="nilobject"><title><emphasis role="italic">The NIL Object</emphasis> (<literal>.nil</literal>)</title>
<indexterm><primary>symbols</primary>
<secondary>.nil symbol</secondary></indexterm>
<indexterm><primary>.Nil object</primary></indexterm>
<para>The Nil object is
a special environment object that does not contain any data. It represents
the absence of an object, the way a null string represents a string with no
characters. Its only methods are those of the <emphasis role="italic">Object</emphasis> class. You use the NIL
object (rather than the null string) to test for the absence of data in an
array entry: </para>
<programlisting>
<![CDATA[
if board[row,column] = <literal>.nil</literal>
then ...
]]>
</programlisting>
<para>All the environment objects Rexx provides are single symbols. Use
compound symbols when you create your own, to avoid conflicts with future
Rexx-defined entries.</para>
</section>
</section>

<section id="localenvobj"><title>The Local Environment Object (<literal>.local</literal>)</title>
<indexterm><primary>symbols</primary>
<secondary>.local symbol</secondary></indexterm>
<indexterm><primary>Local environment object</primary></indexterm>
<para>The Local environment object is a directory of interpreter instance-specific objects
that are always accessible. To place something in the Local environment directory,
you use the form: </para>
<programlisting>
<literal>.local</literal>~<emphasis role="italic">your.object</emphasis> =  <emphasis role="italic">value</emphasis>
</programlisting><para> Be

sure to include a period (.) in any object name you use, to avoid conflicts
with current or future Rexx entries to the Local directory. To retrieve your
object, you use the form: </para>
<programlisting>
say <literal>.local</literal>~<emphasis role="italic">your.object</emphasis>
</programlisting>

<para>The scope of <literal>.local</literal> is the current interpreter instance.
Each Rexx interpreter instance has its own copy of <literal>.local</literal>.
</para>
<para>You access objects in the Local environment object like in the Environment
object. Rexx provides the following objects in the Local environment: </para>
<variablelist>
<varlistentry><term><literal>.error</literal>
<indexterm><primary>symbols</primary>
<secondary><literal>.error</literal> symbol</secondary></indexterm>
</term>
<listitem><para>is the Error
object (the default error stream) to which Rexx writes error messages and
trace output to.
</para></listitem></varlistentry>
<varlistentry><term><literal>.input</literal>
<indexterm><primary>symbols</primary>
<secondary>.input symbol</secondary></indexterm>
</term>
<listitem><para>is the Input object (the default input stream),
which is the source for the <emphasis role="italic">PARSE LINEIN</emphasis> instruction,
the <emphasis role="italic">LINEIN</emphasis> method of the Stream class, and (if you do not specify a stream
name) the <emphasis role="italic">LINEIN</emphasis> built-in function. It is also the source of the <emphasis role="italic">PULL</emphasis> and
<emphasis role="italic">PARSE PULL</emphasis> instructions if the external data queue is empty.
</para></listitem></varlistentry>
<varlistentry><term><literal>.output</literal>
<indexterm><primary>symbols</primary>
<secondary>.output symbol</secondary></indexterm>
</term>
<listitem><para>is the Output
object (the default output stream), which is the destination of output from
the <emphasis role="italic">SAY</emphasis> instruction, the <emphasis role="italic">LINEOUT</emphasis> method (<emphasis role="italic">.OUTPUT~LINEOUT</emphasis>), and (if
you do not specify a stream name) the <emphasis role="italic">LINEOUT</emphasis> built-in function. You can replace
this object in the environment to direct such output elsewhere, for example
to a transcript window.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="builtinenvobj"><title>Built-In Environment Objects</title>
<indexterm><primary>built-in objects</primary></indexterm>
<para>Rexx provides environment
objects that all programs can use. To access these built-in
objects, you use the special environment symbols whose first character
is a period (<literal>.</literal>).</para>
<variablelist>
<varlistentry><term><literal>.line</literal>
<indexterm><primary>symbols</primary>
<secondary>.line symbol</secondary></indexterm>
</term>
<listitem><para>The <literal>.line</literal> environment symbol returns the line number of the current
instruction being executed.  If the current instruction is defined within an <emphasis role="italic">INTERPRET</emphasis>
instruction, the value returned is the line number of <emphasis role="italic">INTERPRET</emphasis> instruction.
</para></listitem></varlistentry>
<varlistentry><term><literal>.rs</literal>
<indexterm><primary>symbols</primary>
<secondary>.rs symbol</secondary></indexterm>
</term>
<listitem><para><literal>.rs</literal> is set to the return status from any executed command, including
those submitted with the <emphasis role="italic">ADDRESS</emphasis> instruction. The <literal>.rs</literal> environment symbol has
a value of <emphasis role="italic">-1</emphasis> when a command returns a
<emphasis role="italic">FAILURE</emphasis> condition, a value of <emphasis role="italic">1</emphasis> when
a command returns an <emphasis role="italic">ERROR</emphasis> condition, and
a value of <emphasis role="italic">0</emphasis> when a command indicates
successful completion. The value of <literal>.rs</literal> is also available after trapping the
<emphasis role="italic">ERROR</emphasis> or <emphasis role="italic">FAILURE</emphasis> condition. </para>

<note>
<para>Tracing interactively does not
change the value of <literal>.rs</literal>. The initial value of <literal>.rs</literal> is <emphasis role="italic">0</emphasis>.</para></note>
</listitem></varlistentry>
</variablelist>
</section>

<section id="searchord"><title>The Default Search Order for Environment Objects</title>
<indexterm><primary>search order</primary>
<secondary>for environment symbols</secondary></indexterm>
<para>When you
use an environment symbol, Rexx performs a series of searches to see if the
environment symbol has an assigned value. The search locations and their ordering
are: </para>
<orderedlist>
<listitem><para>The directory of classes declared on <emphasis role="italic">::CLASS</emphasis> directives within the current
program file.</para></listitem>

<listitem><para>The directory of <emphasis role="italic">PUBLIC</emphasis> classes declared on
<emphasis role="italic">::CLASS</emphasis> directives of other
files included with a <emphasis role="italic">::REQUIRES</emphasis> directive.</para></listitem>

<listitem><para>The program local environment directory, which includes interpreter instance-specific
objects such as the <literal>.input</literal> and <literal>.output</literal> objects. You can directly access the
local environment directory by using the <literal>.local</literal> environment symbol.</para></listitem>
<listitem><para>The global environment directory, which includes all &quot;permanent&quot; Rexx
objects such as the Rexx-supplied classes (for example, <literal>.Array</literal>) and constants
such as <literal>.true</literal> and <literal>.false</literal>. You can directly access the global environment by
using the <literal>.environment</literal> symbol or using the <emphasis role="italic">VALUE</emphasis> built-in function with a
null string for the <emphasis role="italic">selector</emphasis> argument.</para></listitem>

<listitem><para>Rexx defined symbols. Other simple environment symbols are reserved for
use by Rexx for built-in objects.
</para></listitem>
</orderedlist>

<para>If an entry is not found for an environment symbol, the default character
string value is used. </para>

<note>
<para>You can place entries in both the <literal>.local</literal>
and <literal>.environment</literal> directories for programs to use, but .local should be preferred over
<literal>.environment</literal> to avoid accidentally overwriting system-defined values.
To avoid conflicts with
future Rexx-defined entries, it is recommended that entries you place in either
of these directories include at least one period in the entry name.</para></note>
<example>
<title>.Local Object</title>
<programlisting>
<![CDATA[
/* establish a global settings directory */
<literal>.local</literal>~setentry("MyProgram.settings", <literal>.directory</literal>~new)
]]>
</programlisting>
</example>
</section>
</section>

<section id="scope"><title>Determining the Scope of Methods and Variables</title>
<indexterm><primary>scope</primary></indexterm>
<indexterm><primary>class scope</primary></indexterm>
<indexterm><primary>EXPOSE instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>EXPOSE instruction</secondary></indexterm>
<para>Methods interact with variables and their
associated data. But a method cannot interact with any variable. Certain methods
and variables are designed to work together. A method designates the variables
it wants to work with by exposing them with an
<emphasis role="italic">EXPOSE</emphasis> instruction. The exposed
methods are called object variables. Exposing variables confines them to an
object; in object-oriented terms, they are encapsulated. This protects the
object variables' data from being changed by &quot;unauthorized&quot;
methods belonging to other objects.</para>

<section id="objwclsc"><title>Objects with a Class Scope</title>
<para>Encapsulation usually takes place at the class level. The class is designed
as a template of methods and variables. The instances themselves retain only
the values of their variables.</para>
<para>Within the hierarchy, the class structure ensures the integrity of a class's
variables, controlling the methods allowed to operate on them. The class structure
also provides for easy updating of the method code. If a method requires a
change, you only have to change it once, at the class level. The change then
is acquired by all the instances sharing the method.</para>
<para>Associated methods and variables have a certain scope, which is the
class to which they belong:</para>

<figure><title>Scope of the Number Class</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/rxoq0s05.svg" align="center" scale="70" />
</imageobject>
</mediaobject>
</figure>

<para>Each class in a class hierarchy has a scope different from any other class.
This is what allows a variable in a subclass to have the same name as a variable
in a superclass, even though the methods that use the variables for completely unrelated
purposes.</para>
</section>

<section id="objwownsc"><title>Objects with Their Own Unique Scope</title>
<indexterm><primary>scope</primary></indexterm>
<indexterm><primary>methods</primary>
<secondary>scope</secondary></indexterm>
<para>The methods and variables used by instances in a class are usually found
at the class level. But sometimes an instance differs in some respect from
the others in its class. It might perform an additional action or require
some unique handling. In this case one or more methods and related variables
can be added directly to the instance. These additional methods and variables
form a separate scope, independent of the class scopes found throughout the
rest of the hierarchy.</para>
<para>Methods can be added directly to an instance's collection of object
methods using <emphasis role="italic">SETMETHOD</emphasis>, a method of the Object class. All subclasses of the
Object class inherit <emphasis role="italic">SETMETHOD</emphasis>. Alternately, the Class class provides an <emphasis role="italic">ENHANCED</emphasis>
method that lets you create new instances of a class, whose object methods
are the instance methods of its class, but enhanced with the additional collection
methods.</para>
</section>
</section>

<section id="methna"><title>More about Methods</title>
<para>A method name can
<indexterm><primary>method names, specifying</primary></indexterm>
be any character string. When an object receives a message, Rexx searches
for a method whose name matches the message name.</para>

<para>You must surround a method name with quotation marks when it
is the same as an operator. The following example illustrates how to do this
correctly. It creates a new class (<computeroutput>Cost</computeroutput>),
defines a new method (<computeroutput>%</computeroutput>), creates an instance
of the Cost class (Mycost), and sends
a <computeroutput>%</computeroutput> message to Mycost:</para>
<example>
<title>Messages</title>
<programlisting>
<![CDATA[
mycost = Cost~new           /* Creates new instance mycost.*/
mycost~"%"                  /* Sends % message to mycost.  */

::class Cost subclass "Retail" /* Creates Cost, a sub-     */
                               /* class of "Retail" class. */
  ::method "%"                 /* Creates % method.        */
    expose p                   /* Produces: Enter a price. */
    say "Enter a price"        /* If the user specifies a  */
    pull p                     /* price of 100,            */
    say p*1.07                 /* produces: 107            */
    return 0
]]>
</programlisting>
</example>

<section id="meths"><title>The Default Search Order for Selecting a Method</title>
<indexterm><primary>search order</primary>
<secondary>for methods, default</secondary></indexterm>
<indexterm><primary>methods</primary>
<secondary>selecting</secondary></indexterm>
<indexterm><primary>methods</primary>
<secondary>search order for</secondary></indexterm>
<indexterm><primary>default search order for methods</primary></indexterm>

<para>When a message is sent to an object, Rexx looks for a method whose name
matches the message string. If the message is <emphasis role="italic">ADD</emphasis>, for example, Rexx looks
for a method named <emphasis role="italic">ADD.</emphasis> Because, in the class hierarchy, there may be more
than one method with the same name, Rexx begins its search at the object specified
in the message. If the sought method is not found there, the search continues
up the hierarchy. Rexx searches in the following order: </para>
<orderedlist>
<listitem><para>A method the object defines itself
(with <emphasis role="italic">SETMETHOD</emphasis> or <emphasis role="italic">ENHANCED</emphasis>).</para></listitem>
<listitem><para>A method the object's class defines.</para>
<para>An object acquires the methods
of its parent class (that is, the class for which the object was created).
If the class subsequently receives new methods, objects predating the new
methods <emphasis role="italic">do not</emphasis> acquire them.</para></listitem>
<listitem><para>A method an object's superclass(es) define.</para>
<para>As with the object's
class, only methods that existed in the superclass when the object was created
are valid. Rexx searches the superclass method definitions in the order that
<emphasis role="italic">INHERIT</emphasis> messages were sent to an object's class.</para></listitem></orderedlist>
<para>If Rexx does not find a match
for the message name, Rexx checks the object for a method named <emphasis role="italic">UNKNOWN</emphasis>.
<indexterm><primary>UNKNOWN method</primary></indexterm>
If it exists, Rexx calls the <emphasis role="italic">UNKNOWN</emphasis> method, and returns whatever the <emphasis role="italic">UNKNOWN</emphasis> method
returns. For more information on the <emphasis role="italic">UNKNOWN</emphasis> method, see
<xref linkend="unknown" />.
If the object does not have an <emphasis role="italic">UNKNOWN</emphasis> method, Rexx raises a <emphasis role="italic">NOMETHOD</emphasis> condition.
Any trapped information can then be inspected using Rexx's <emphasis role="italic">CONDITION</emphasis> built-in
function.</para>
<para>Rexx searches up the hierarchy so that methods
existing in higher levels can be supplemented or overridden by methods existing
in lower levels.</para>

<figure><title>Searching the Hierarchy for a Method</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/rxoq0s06.svg" align="center" />
</imageobject>
</mediaobject>
</figure>

<para>For example, suppose you wrote a program that allows users to look up other
users' phone numbers. Your program includes a class called <emphasis role="italic">Phone_Directory</emphasis>,
and all its instances are users' names with phone numbers. You have included
a method in <emphasis role="italic">Phone_Directory</emphasis> called <emphasis role="italic">NOTIFY</emphasis> that reports some data to a file
whenever someone looks up a number. All instances of Phone_Directory use the
<emphasis role="italic">NOTIFY</emphasis> method.</para>
<para>Now you decide you want <emphasis role="italic">NOTIFY</emphasis>, in addition to its normal handling, to
personally inform you whenever anyone looks up your number.
To accommodate this special case for your name only, you create your own <emphasis role="italic">NOTIFY</emphasis>
method that adds the new task and replicates the file-handling task. You save
the new method as part of your own name instance, retaining the same name,
<emphasis role="italic">NOTIFY</emphasis>.</para>
<para>Now, when a <emphasis role="italic">NOTIFY</emphasis> message is sent to your name instance, the new version
of <emphasis role="italic">NOTIFY</emphasis> is found first. Rexx does not look further up the class hierarchy.
The instance-level version overrides the version at
the class level. This technique of overriding lets you change a method used
by one instance without disturbing the common method used by all the other
instances. It is very powerful for that reason.</para>
</section>

<section id="xsearch"><title>Changing the Search Order for Methods</title>
<indexterm><primary>search order</primary>
<secondary>for methods, changing</secondary></indexterm>
<indexterm><primary>changing the search order for methods</primary></indexterm>
<para>When composing a message, you
can change the default search order for methods by doing both of the following: </para>

<orderedlist>
<listitem><para>Making the receiver object the sender object.
<indexterm><primary>variables</primary>
<secondary>special</secondary></indexterm>
You usually do this by specifying the special variable
<emphasis role="italic">SELF</emphasis>. <emphasis role="italic">SELF</emphasis> holds the value of the object in which a method is running.
</para></listitem>

<listitem><para>Specifying a colon and a starting scope after the message name. The
starting scope is a variable or environment symbol that
identifies the scope object to use as the method search starting point.
This scope object can be:
<itemizedlist>
<listitem><para>A direct superclass of the class that defines the active method</para></listitem>
<listitem><para>The object itself (for example, the value of the variable <emphasis role="italic">SELF</emphasis>),
if you used <emphasis role="italic">SETMETHOD</emphasis> to add
methods to the object.
</para>

<para>
<indexterm><primary>variables</primary>
<secondary>special</secondary></indexterm>
The scope variable is usually the special variable
<emphasis role="italic">SUPER</emphasis>, but it can be any environment symbol
or variable name whose value is a valid class.</para></listitem>
</itemizedlist></para></listitem>
</orderedlist>

<para>In <xref linkend="sample" />, an <emphasis role="italic">Account</emphasis> subclass of the
<emphasis role="italic">Object</emphasis> superclass is created.
<indexterm><primary>SUBCLASS option</primary></indexterm>
 It defines a <emphasis role="italic">TYPE</emphasis> method
for <emphasis role="italic">Account</emphasis>, and creates the <emphasis role="italic">Savings</emphasis> subclass
of <emphasis role="italic">Account.</emphasis> The example defines
a <emphasis role="italic">TYPE</emphasis> method for the <emphasis role="italic">Savings</emphasis> subclass, as follows: </para>
<example>
<title><emphasis role="italic">SUBCLASS</emphasis> Option</title>
<programlisting>
<![CDATA[
::class Savings subclass Account

  ::method "TYPE"
    return "a savings account"
]]>
</programlisting>
</example>
<para>To change
the search order so Rexx searches for <emphasis role="italic">TYPE</emphasis> in the <emphasis role="italic">Account</emphasis>
rather than <emphasis role="italic">Savings</emphasis>
subclass, enter this instead: </para>
<example>
<title>Changing the Subclass Method Search Order</title>
<programlisting>
<![CDATA[
  ::method "TYPE"
    return self~type:super -- returns the result of invoking the TYPE method of the superclass
]]>
</programlisting>
</example>
<para>When you create an <computeroutput>asav</computeroutput> instance of
the <emphasis role="italic">Savings</emphasis> subclass and send a <emphasis role="italic">TYPE</emphasis> message to
<computeroutput>asav</computeroutput>: </para>
<programlisting>
<![CDATA[
say asav~type
]]>
</programlisting>
<para>Rexx displays: </para>
<programlisting>
<![CDATA[
an account
]]>
</programlisting>
<para> rather than: </para>
<programlisting>
<![CDATA[
a savings account
]]>
</programlisting>
<para> because Rexx searches for <emphasis role="italic">TYPE</emphasis> in the <emphasis role="italic">Account</emphasis> class first.</para>
</section>

<section id="public"><title>Public versus Private Methods</title>
<indexterm><primary>search order</primary>
<secondary>for methods, changing</secondary></indexterm>
<indexterm><primary>public methods</primary></indexterm>
<indexterm><primary>methods</primary>
<secondary>public</secondary></indexterm>
<indexterm><primary>private methods</primary></indexterm>
<indexterm><primary>methods</primary>
<secondary>private</secondary></indexterm>

<para>A method can be either public or private.
Any object can send a message that runs a <emphasis role="italic">public</emphasis> method.
A <emphasis role="italic">private</emphasis> method can only be invoked from specific calling contexts.
These contexts are:</para>
<orderedlist>
<listitem><para>From within a method owned by the same class as the target.  This is frequently
the same object, accessed via the special variable <emphasis role="italic">SELF</emphasis>.  Private methods of an object can also
be accessed from other instances of the same class (or subclass instances).
</para></listitem>
<listitem><para>From within a method defined at the same class scope as the method.  For example:</para>
<example>
<title><emphasis role="italic">PUBLIC</emphasis> and <emphasis role="italic">PRIVATE</emphasis> options</title>
<programlisting>
<![CDATA[
::class Savings
::method newCheckingAccount CLASS
  instance = self~new
  instance~makeChecking
  return instance

::method makeChecking private
  expose checking
  checking = .true
]]>
</programlisting>
</example>
<para>The <emphasis role="italic">newCheckingAccount</emphasis> <emphasis role="italic">CLASS</emphasis> method
is able to invoke the <emphasis role="italic">makeChecking</emphasis> method because
the scope of the <emphasis role="italic">makeChecking</emphasis> method is <literal>.Savings</literal>.
</para></listitem>
<listitem><para>From within an instance (or subclass instance) of a class to a private class
method of its class.  For example:</para>
<example>
<title><emphasis role="italic">PUBLIC</emphasis> and <emphasis role="italic">PRIVATE</emphasis> Options</title>
<programlisting>
<![CDATA[
::class Savings
::method init class
  expose counter
  counter = 0

::method allocateAccountNumber private class
  expose counter
  counter = counter + 1
  return counter

::method init
  expose accountNumber
  accountNumber = self~class~allocateAccountNumber
]]>
</programlisting>
</example>
<para>The instance <emphasis role="italic">INIT</emphasis> method of the Savings class is able to invoke the
<emphasis role="italic">allocateAccountNumber</emphasis> private
method of the <literal>.Savings</literal> class object because it is owned by an
instance of the <literal>.Savings</literal> class.</para>
</listitem>
</orderedlist>
<para>Private methods include methods at different scopes within the same object.
This allows superclasses to make methods available to their subclasses while
hiding those methods from other objects. A private method is like an internal
subroutine. It shields the internal information of an object to outsiders, but allowing
objects to share information with each other and their defining classes.
</para>
</section>

<section id="unknown"><title>Defining an <emphasis role="italic">UNKNOWN</emphasis> Method</title>
<indexterm><primary>UNKNOWN method</primary></indexterm>
<para>When an object receives
a message that has no matching message name, Rexx checks to see if the object has a method
named <emphasis role="italic">UNKNOWN</emphasis>. If it does, Rexx calls the <emphasis role="italic">UNKNOWN</emphasis> method, passing two arguments. The
first is the name of the method that was not located. The second is an array
containing the arguments passed with the original message.</para>
</section>
</section>

<section id="concur"><title>Concurrency</title>
<indexterm><primary>concurrency</primary></indexterm>
<para>In object-oriented
programming, as in the real world, objects interact with each other. Assume,
for example, throngs of people interacting at rush hour in the business district
of a big city. A program that aspires to simulate the real world would have
to enable many objects to interact at any given time. That could mean thousands
of objects running simultaneously, all of them sending messages to each other.
In Rexx, the term for this simultaneous activity is called concurrency.
To be precise, the concurrency is <emphasis role="italic">object-oriented</emphasis>
concurrency because it involves objects, as opposed to, for example, processes or threads.</para>
<para>Rexx objects are inherently concurrent, and this concurrency takes the
following forms: </para>
<itemizedlist>
<listitem><para><emphasis role="italic">Inter-object concurrency</emphasis>, where several objects
are active (exchanging messages, synchronizing, running their methods, etc.) at
the same time</para></listitem>
<listitem><para><emphasis role="italic">Intra-object concurrency</emphasis>, where several methods
are able to run on the same object at the same time</para></listitem>
</itemizedlist>
<para>The default settings in Rexx allow full inter-object concurrency but limited
intra-object concurrency. Some situations, however, call for full intra-object
concurrency.</para>

<section id="interobjconcur"><title>Inter-Object Concurrency</title>
<indexterm><primary>inter-object concurrency</primary></indexterm>
<para>Rexx provides for inter-object
concurrency, where several objects in a program can run at the same time,
in the following ways: </para>
<itemizedlist>
<listitem><para>
<indexterm><primary>REPLY instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>REPLY instruction</secondary></indexterm>
By early reply, using the
<emphasis role="italic">REPLY</emphasis> instruction</para></listitem>
<listitem><para>Using message objects</para></listitem></itemizedlist>
<para>Early reply allows
the object that sends a message to continue processing after the message is
sent. Meanwhile, the receiving object runs the method corresponding to the
message. This method contains the <emphasis role="italic">REPLY</emphasis> instruction, which returns any results
to the sender, interrupting the sender just long enough to reply. The sender
and receiver continue operating simultaneously.</para>
<para>Alternatively, an independent message object can
be created and sent to a receiver. One difference in this approach is that
any reply returned does not interrupt the sender. The reply waits until the
sender asks for it. In addition, message objects can notify the sender about
the completion of the method it sent, and even specify synchronous or asynchronous
method activation.</para>

<para>The chains of execution represented by the sender and receiver methods
are called <emphasis role="italic">activities</emphasis>.
<indexterm><primary>thread</primary></indexterm>
<indexterm><primary>activities</primary></indexterm>
An <emphasis role="italic">activity</emphasis> is a thread of execution that
can run methods concurrently with methods on other activities. In other words,
<emphasis role="italic">activities</emphasis> can run at the same time.</para>
<para>An <emphasis role="italic">activity</emphasis> contains a stack of invocations that
represent the Rexx programs running on the <emphasis role="italic">activity</emphasis>. An invocation can be:</para>
<itemizedlist>
<listitem><para>A main program invocation</para></listitem>
<listitem><para>An internal function or subroutine call</para></listitem>
<listitem><para>An external function or subroutine call</para></listitem>
<listitem><para>An <emphasis role="italic"><emphasis role="italic">INTERPRET</emphasis></emphasis> instruction</para></listitem>
<listitem><para>A message invocation</para></listitem></itemizedlist>
<para>An invocation is pushed onto an <emphasis role="italic">activity</emphasis> when an executable unit is invoked.
It is removed (or popped) when execution completes.</para>

<section id="objvarpools"><title>Object Instance Variables</title>
<indexterm><primary>object instance variables</primary></indexterm>
<para>Every object has its own set of instance variables.
These are variables associated solely with the
object. When an object's method runs, it first identifies the object variables
it intends to work with.
<indexterm><primary>variables</primary>
<secondary>exposing</secondary></indexterm>
Technically, it &quot;exposes&quot; these variables, using
the Rexx instruction <emphasis role="italic">EXPOSE</emphasis>. Exposing the object's variables distinguishes
them from variables used by the method itself, which are not exposed. Every
method an object owns&mdash;that is, all the instance methods in the object's
class&mdash;can expose variables from the object's instance variables.</para>
<para>Therefore, an object's instance variables includes variables:</para>
<itemizedlist>
<listitem><para>Exposed by methods defined by the object's class. This set of variables is
called a variable pool.</para></listitem>
<listitem><para>Exposed by methods defined by other classes in the inheritance hierarchy.
The methods of each class share variables in a pool scoped to just that class.</para></listitem>
</itemizedlist>
<para>A class's variable pool, together with the methods that expose them,
is called a class scope. Rexx exploits this class
scope to achieve concurrency. To explain in more detail, the object's instance variables are contained
in a collection of variable pools. Each variable pool is at a different scope in the object's
inheritance chain. Methods defined at different class scopes do not directly share data,
and can therefore run simultaneously.</para>
<para>Scopes, like objects, hide and protect data from outside manipulation.
Methods of the same scope share the variable pool of that scope. The scope
shields the variable pool from methods operating at other scopes. This is why
you can reuse variable names from class to class, without the variables being
accessed and possibly corrupted by a method outside their own class. So class
scopes serve to divide an object's instance variables into pools that can operate
independently of each another. Several methods can use the same object instance variables
concurrently, as long as they confine themselves to variables in their own
scope.</para>
</section>

<section id="prioritizeaccess"><title>Prioritizing Access to Variables</title>
<indexterm><primary>access to variables, prioritizing</primary></indexterm>
<indexterm><primary>prioritizing access to variables</primary></indexterm>
<indexterm><primary>locking a scope</primary></indexterm>
<para>Even with class scopes and subpools,
a variable is vulnerable if several methods within the scope try to access
it at the same time. To handle this, Rexx ensures that when a particular method
is activated and exposes variables from its scope, that method has exclusive
use of the scope variable pool until processing is complete. Until then, Rexx delays the
execution of any other method that needs the same scope variables.</para>
<para>Thus if different activities send several messages to the same object,
Rexx forces the methods to run sequentially within a single scope. This
&quot;first-in, first-out&quot; processing of methods in a scope
prevents them from simultaneously accessing one variable, and possibly
corrupting the data.</para>
</section>

<section id="sendmsgwact"><title>Sending Messages within an <emphasis role="italic">Activity</emphasis></title>
<indexterm><primary>sending messages within an activity</primary></indexterm>
<para>Rexx makes one
exception to sequential processing&mdash;when a method sends a message to
itself. Assume that method <emphasis role="italic">M1</emphasis> has exclusive access to object <emphasis role="italic">O</emphasis>, and then tries
to run a second, internal method <emphasis role="italic">M2</emphasis>, also belonging
to <emphasis role="italic">O</emphasis>. Internal method <emphasis role="italic">M2</emphasis> would try to run, but Rexx would delay it until the
original method <emphasis role="italic">M1</emphasis> finished. Yet <emphasis role="italic">M1</emphasis> would be unable to proceed until <emphasis role="italic">M2</emphasis> ran.
The two methods would become deadlocked. In actual practice Rexx intervenes
by treating internal method <emphasis role="italic">M2</emphasis> like a subroutine call. In this case, Rexx
runs method <emphasis role="italic">M2</emphasis> immediately, then continues processing method <emphasis role="italic">M1.</emphasis></para>
<para>The mechanism controlling this
is the <emphasis role="italic">activity</emphasis>. Typically, whenever a message is invoked on an object, the
<emphasis role="italic">activity</emphasis> acquires exclusive access by locking the
object's scope. Any other <emphasis role="italic">activity</emphasis> sending a message to the object whose
scope is locked must wait until the first activity releases the lock. The
situation is different, however, if the messages originate from the same
<emphasis role="italic">activity</emphasis>. When an invocation running on an <emphasis role="italic">activity</emphasis> sends another
message to the same object, the method is allowed
to run because the activity has already acquired the lock for the scope. Thus,
Rexx permits nested, nonconcurrent method invocations on a single activity.
No deadlocks occur because Rexx treats these additional messages as subroutine
calls.</para>
</section>
</section>

<section id="intraobjconcur"><title>Intra-Object Concurrency</title>
<indexterm><primary>intra-object concurrency</primary></indexterm>
<para>Several methods can
access the same object at the same time only if they are operating at different
scopes. That is because they are working with separate variable subpools.
If two methods in the same scope try to run on the object, Rexx by default
processes them on a &quot;first-in, first-out&quot; basis, while treating internal
methods as subroutines. You can, however, achieve full intra-object concurrency.
Rexx offers several mechanisms for this, including: </para>
<itemizedlist>
<listitem><para>The <emphasis role="italic">UNGUARDED</emphasis> option of
the <emphasis role="italic">::METHOD</emphasis> directive, which provide unconditional intra-object concurrency.
</para></listitem>

<listitem><para>
<indexterm><primary>GUARD instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>GUARD instruction</secondary></indexterm>
The <emphasis role="italic">GUARD OFF</emphasis> and <emphasis role="italic">GUARD ON</emphasis> instructions, which permit switching between
intra-object and default concurrency.</para></listitem></itemizedlist>

<para>When intra-object concurrency at the scope level is needed,
you must specifically employ these mechanisms (see the following section).
Otherwise, Rexx sequentially processes the methods when they are competing
for the same object variables.</para>

<section id="activat"><title>Activating Methods</title>
<para>By default, Rexx assumes that an active method requires exclusive use of
its scope variable pool. If another method attempts access at that time,
it is locked out until the first method finishes.
This default intra-object serialization maintains the integrity of the variable
pool and prevents unexpected results. Rexx manages queues for incoming requests
that result in messages being sent to the same object.</para>
<para>Some methods can run concurrently without affecting variable pool integrity
or yielding unexpected results. When a method does not need exclusive use
of its object variable pool, use the <emphasis role="italic">UNGUARDED</emphasis>
option of the <emphasis role="italic">::METHOD</emphasis> directive to provide unconditional intra-object concurrency.
These mechanisms control the locking of an object's scope when a method
is invoked.</para>
<para>Many methods cannot use the <emphasis role="italic">UNGUARDED</emphasis> option
because they sometimes require exclusive use of their variable pool. At other
times, they must perform some action that involves the concurrent use of the
same pool by a method on another activity. In this case, you can use the <emphasis role="italic">GUARD</emphasis>
keyword instruction. When the method reaches the point in its processing where
it no longer requires exclusive use of the variable pool, it can use the <emphasis role="italic">GUARD OFF</emphasis> instruction
to allow methods running on different activities to become active on the same scope.
If the method needs to regain exclusive
use, it uses the <emphasis role="italic">GUARD ON</emphasis> instruction.</para>
<para>For more flexibility when activating methods, you can use <emphasis role="italic">GUARD ON/OFF</emphasis>
with the &quot;<emphasis role="italic">WHEN</emphasis> <emphasis role="italic">expression</emphasis>&quot;
option. Add this instruction to the
method code at the point where exclusive use of the variable pool becomes
conditional. When processing reaches this point, Rexx evaluates
<emphasis role="italic">expression</emphasis> to determine if it is true
or false.</para>
<para>For example, if you specify &quot;<emphasis role="italic">GUARD OFF WHEN</emphasis>
<emphasis role="italic">expression</emphasis>&quot;, the
active method keeps running until <emphasis role="italic">expression</emphasis>
becomes true. To become true, another method must assign or drop an object
variable that is named in <emphasis role="italic">expression</emphasis>.
Whenever an object variable changes, Rexx reevaluates
<emphasis role="italic">expression.</emphasis> If
<emphasis role="italic">expression</emphasis> becomes true, <emphasis role="italic">GUARD</emphasis> is turned off,
exclusive use of the variable pool is released, and other methods needing
exclusive use can begin running. If
<emphasis role="italic">expression</emphasis> becomes false again,
<emphasis role="italic">GUARD</emphasis> is turned on and the active method regains exclusive use. </para>

<note>
<para>If <emphasis role="italic">expression</emphasis> cannot be met,
<emphasis role="italic">GUARD ON WHEN</emphasis> puts the program
in a continuous wait condition. This can occur in particular when several
activities run concurrently. A second activity can make
<emphasis role="italic">expression</emphasis> invalid
before <emphasis role="italic">GUARD ON WHEN</emphasis> can use it.</para></note>
</section>
</section>
</section>
</chapter>
