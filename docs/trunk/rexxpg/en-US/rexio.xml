<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "rexxpg.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: Programming Guide XML file.
    #
    # Copyright (c) 2005-2017, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<chapter id="rexio"><title>Input and Output</title>
<indexterm><primary>I/O model</primary></indexterm>
<indexterm><primary>model, stream I/O</primary></indexterm>
<indexterm><primary>stream I/O model</primary></indexterm>
<indexterm><primary>stream object</primary></indexterm>
<para>Rexx supports a stream
I/O model. Using streams, your program reads data from various devices
(such as hard disks, CD-ROMs, and keyboards) as a continuous stream of characters.
Your program also writes data as a continuous stream of characters.</para>
<para>In the stream model, a text file is represented as a stream of characters
with special line-end characters marking the end of each line of text in the stream.</para>
<para>We use the expression &quot;line-end characters&quot; because they are
platform dependent, and may be a single character
(UNIX / Linux and Mac OS X use a single line feed character (<emphasis role="italic">'0D'x</emphasis>, <emphasis role="italic">13</emphasis> decimal),
classic Mac used a single carriage return character (<emphasis role="italic">'0A'x</emphasis>, <emphasis role="italic">10</emphasis> decimal)
or a character combination
(Windows / DOS uses a carriage-return and line-feed character pair (<emphasis role="italic">'0D 0A'x</emphasis>)).
Henceforth, when we use the expression &quot;line-end characters&quot;,
we mean whatever character sequence constitutes the line termination sequence
on whichever platform you are working with Rexx on.</para>
<para>A binary file is a stream of characters without an inherent line structure.
A Rexx stream object allows you read from a data stream using either the text-file
line methods or using a continuous data stream method.</para>
<para>The Rexx Stream class is the mechanism for accessing I/O streams.
To input or output data, you first create an instance of the Stream
class that represents the device or file you want to use. For example, the
following clause creates a stream object for the file <code>out.dat</code>:</para>
<programlisting>
<![CDATA[
/* Create a stream object for out.dat */
file=.stream~new("out.dat")
]]>
</programlisting>
<para>Then you use the appropriate stream methods to read and/or write the data.
<code>out.dat</code> is a text file, so you would normally use the <emphasis role="italic">LINES()</emphasis>, <emphasis role="italic">LINEIN</emphasis>, and
<emphasis role="italic">LINEOUT()</emphasis> methods that read or write data as delimited lines.
If the stream represents a binary file (such as a <code>wav</code>,
<code>gif</code>, <code>tif</code> or <code>exe</code>),
you would use the <emphasis role="italic">CHARS</emphasis>, <emphasis role="italic">CHARIN</emphasis>, and <emphasis role="italic">CHAROUT</emphasis> methods that read and write
data as characters.</para>
<para>The Stream class includes additional methods for opening and closing streams,
flushing buffers, seeking to specific file locations, retrieving stream status,
and other I/O operations.</para>

<section id="streamobj"><title>More about Stream Objects</title>
<para>To use streams in Rexx, you create new instances of the Stream class.
These stream objects represent the various data sources and destinations available
to your program, such as hard disks, CD-ROMs, keyboards, displays, printers,
serial interfaces or devices on a network.
</para>
<para>Stream objects can be transient or persistent.  An example of a transient
(or dynamic) stream object is a serial interface. Data can be sent or received
from serial interfaces, but the data is not stored permanently by the serial
interface itself.  Consequently, you cannot, for example, read from or write to
a random position in the data stream&ndash;it can only be read and/or written
as a sequential stream of characters.
Once you read from or write to the stream, the data cannot be re-accessed.</para>
<para>A disk file is an example of a persistent stream object.  Because the data
is stored on disk, you can search forward and backward in the stream and reread
data that you have previously read. Rexx maintains separate read and write
pointers to a stream that you can move independently of each other using arguments
on methods such as <emphasis role="italic">LINEIN</emphasis>, <emphasis role="italic">LINEOUT</emphasis>,
<emphasis role="italic">CHARIN</emphasis>, and <emphasis role="italic">CHAROUT</emphasis>.
The Stream class also provides
<emphasis role="italic">SEEK</emphasis> and <emphasis role="italic">POSITION</emphasis> methods for setting the read and write positions.</para>
</section>

<section id="readtxtfile"><title>Reading a Text File</title>
<indexterm><primary>reading</primary>
<secondary>text files</secondary></indexterm>
<indexterm><primary>text files</primary>
<secondary>reading</secondary></indexterm>
<para>The following shows an example of reading a file.
Program <code>count.rex</code> counts the words in a text file. To run it, enter<code> rexx count</code>
followed by the name of the file to be processed:</para>
<programlisting>
<![CDATA[
rexx count myfile.txt
rexx count r:\rexx\articles\devcon7.scr
]]>
</programlisting>

<indexterm><primary>counting words in a file</primary></indexterm>
<para><code>count.rex</code> uses the String method <emphasis role="italic">WORDS</emphasis> to count the words, so
<code>count.rex</code> actually counts whitespace-delimited tokens:</para>
<example>
<title><emphasis role="italic"><code>count.rex</code></emphasis> with automatic open</title>
<programlisting>
<![CDATA[
/* count.rex - counts the words in a file                          */
parse arg filename          /* Get file name from command line     */
count=0                     /* Initialize a counter                */
file=.stream~new(filename)  /* Create a stream object for the file */
do while file~lines<>0      /* Loop as long as there are lines     */
  text=file~linein          /* Read a line from the file           */
  count=count+(text~words)  /* Count words and add to counter      */
end
say count                   /* Display the count                   */
]]>
</programlisting>
</example>
<para>To read a file, <code>count.rex</code> first creates a Stream object for the file by sending
the <emphasis role="italic">NEW</emphasis> message to the Stream class. The file name (with or without a path)
is specified as an argument on the <emphasis role="italic">NEW</emphasis> method.</para>
<para>Within the <emphasis role="italic">DO</emphasis> loop,
<code>count.rex</code> reads the lines of the file by sending <emphasis role="italic">LINEIN</emphasis> messages
to the stream object (pointed to by the variable File). The first <emphasis role="italic">LINEIN</emphasis> message
causes Rexx to automatically open the file if it was not already open
(the <emphasis role="italic">NEW</emphasis> method does not open the file). <emphasis role="italic">LINEIN</emphasis>, by default, reads one line
from the file, starting at the current read position.</para>
<para>Rexx returns only the text of the line to your program
without any line-end characters.</para>
<para>The <emphasis role="italic">DO</emphasis> loop is controlled by the expression &quot;file~lines&lt;>0&quot;.
The <emphasis role="italic">LINES</emphasis> method returns the number of lines remaining to be read in
the file, so Rexx processes the loop until no lines remain to be read.</para>
<para>In the <code>count.rex</code> program, the <emphasis role="italic">LINEIN</emphasis> request forces Rexx to open the file, but you
can also open the file yourself using the <emphasis role="italic">OPEN</emphasis> method of the Stream class.
By using the <emphasis role="italic">OPEN</emphasis> method, you control the mode in which Rexx opens the file.
When Rexx implicitly opens a file because of a <emphasis role="italic">LINEIN</emphasis> request, it tries to
open the file for both reading and writing. If that fails, it tries to open the file
for reading. To ensure that the file is opened only for reading, you can modify
<code>count.rex</code> as follows:</para>
<example>
<title><emphasis role="italic"><code>count.rex</code></emphasis> with explicit open</title>
<programlisting>
<![CDATA[
/* count.rex - counts the words in a file                          */
parse arg filename          /* Get file name from command line     */
count=0                     /* Initialize a counter                */
file=.stream~new(filename)  /* Create a stream object for the file */
openrc=file~open("read")    /* Open the file for reading           */
if openrc<>"READY:" then do /* Check the return code               */
  say "Could not open" path||"~ RC="||openrc
  exit openrc               /* Bail out                            */
end
do while file~lines<>0      /* Loop as long as there are lines     */
  text=file~linein          /* Read a line from the file           */
  count=count+(text~words)  /* Count words and add to counter      */
end
file~close                  /* Close the file                      */
say count                   /* Display the count                   */
]]>
</programlisting>
</example>
<para>The <emphasis role="italic">CLOSE</emphasis> method, used near the end of the previous example, closes the
file. A <emphasis role="italic">CLOSE</emphasis> is not required. Rexx closes the stream for you when the program
ends. However, it is a good idea to <emphasis role="italic">CLOSE</emphasis> streams to make the resource available
for other uses.</para>
</section>

<section id="textfilearray"><title>Reading a Text File into an Array</title>
<indexterm><primary>ARRAYIN method, using</primary></indexterm>
<indexterm><primary>arrays, reading streams into</primary></indexterm>
<indexterm><primary>reading</primary>
<secondary>streams into arrays</secondary></indexterm>
<indexterm><primary>text files</primary>
<secondary>reading into an array</secondary></indexterm>
<para>Rexx
provides a Stream method, named <emphasis role="italic">ARRAYIN</emphasis>, that reads the contents of a stream
into an array object. <emphasis role="italic">ARRAYIN</emphasis> is convenient when you need to read an entire
file into memory for processing. You can read the entire file with a single
Rexx clause&ndash;no looping is necessary.</para>
<para>The following example (<code>cview.rex</code>) uses the <emphasis role="italic">ARRAYIN</emphasis> method
to read the entire <code>log.txt</code> file into an array object. <code>cview.rex</code> displays selected
lines from <code>log.txt</code>. A search argument can be specified when starting <code>cview.rex</code>:</para>
<programlisting>
<![CDATA[
rexx cview libpath
]]>
</programlisting>
<para><code>cview.rex</code> prompts for a search argument if you do not specify one.</para>
<para>If <code>cview.rex</code> finds the string, it displays the line(s) in which the string was
found. <code>cview.rex</code> continues to prompt for a new search string until you enter
<programlisting>Q</programlisting> in response to the prompt.</para>
<example>
<title><emphasis role="italic"><code>cview.rex</code></emphasis></title>
<programlisting>
<![CDATA[
/* cview.rex - display lines from file log.txt                               */
parse upper arg search_string      /* Get any command line argument  */
file=.stream~new("log.txt")  /* Create stream object */
lines=file~arrayin                 /* Read file into an array object */
                                   /* LINES points to the array obj. */
loop forever
   if search_string="" then do     /* Prompt for user input          */
      say "Enter a search string or Q to quit:"
      parse upper pull search_string
      if search_string="Q" then exit
   end
   loop i over lines                /* Scan the array                */
      if pos(search_string,translate(i))>0 then do
         say i                      /* Display any line that matches */
         say "="~copies(20)
      end
   end
   search_string=""                 /* Reset for next search         */
end
]]>
</programlisting>
</example>
</section>

<section id="textfilelines"><title>Reading Specific Lines of a Text File</title>
<indexterm><primary>text files</primary>
<secondary>reading specific lines</secondary></indexterm>
<indexterm><primary>reading</primary>
<secondary>specific lines of text files</secondary></indexterm>
<para>You can read
a specific line of a text file by entering a line number as an argument on
the <emphasis role="italic">LINEIN</emphasis> method. In this example, line 3 is read from <code>log.txt</code>:</para>
<example>
<title><emphasis role="italic">LINEIN</emphasis></title>
<programlisting>
<![CDATA[
/* Read and display line 3 of file log.txt */
infile=.stream~new("log.txt")
say infile~linein(3)
]]>
</programlisting>
</example>
<para>You do not reduce file I/O by using specific line numbers. Because text
files do not have a specific record length, Rexx must read through the file
counting occurrences of line-end characters to find the line number you want.</para>
</section>

<section id="writetextfile"><title>Writing a Text File</title>
<indexterm><primary>text files</primary>
<secondary>writing</secondary></indexterm>
<indexterm><primary>writing</primary>
<secondary>text files</secondary></indexterm>
<para>To write lines of text to a file, you use the <emphasis role="italic">LINEOUT</emphasis>
method. By default, <emphasis role="italic">LINEOUT</emphasis> appends to an existing file. The following example
adds an item to a to-do list that is maintained as a simple text file:</para>
<example>
<title><emphasis role="italic"><code>todo.rex</code></emphasis></title>
<programlisting>
<![CDATA[
/* todo.rex - add to a todo list                              */
parse arg text
file=.stream~new("todo.dat")      /* Create a stream object    */
file~lineout(date() time() text)  /* Append a line to the file */
exit
]]>
</programlisting>
</example>
<para>In <code>todo.rex</code>, a text string is provided as the only argument on <emphasis role="italic">LINEOUT</emphasis>. Rexx
writes the line of text to the file with line-end characters appended.
You do not have to provide line-end characters in the string to be written.</para>
<para>If you want to overwrite a file, specify a line number as a second argument
to position the write pointer:</para>
<programlisting>
<![CDATA[
file~lineout("13760-0006",35)  /* Replace line 35 */
]]>
</programlisting>
<para>Rexx does not prevent you from overwriting existing line-end characters
in the file. Consequently, if you want to replace a line of the file without
overlaying the following lines, the line you write must have the same length
as the line you are replacing. Writing a line that is shorter than an existing
line leaves part of the old line in the file.</para>
<para>Also, positioning the write pointer to line 1 does not replace the file.
Rexx starts writing over the existing data starting at line 1, but if you
happen to write fewer bytes than previously existed in the file, your data
is followed by the remainder of the old file.</para>
<para>To replace a file, use the <emphasis role="italic">OPEN</emphasis> method
with <emphasis role="italic">WRITE REPLACE</emphasis> or <emphasis role="italic">BOTH REPLACE</emphasis>
as an argument. In the following example, a file named <code>temp.dat</code> is replaced
with a random number of lines. <code>temp.dat</code> is then read and displayed. You can run the example
repeatedly to verify that <code>temp.dat</code> is replaced on each run.</para>
<example>
<title><emphasis role="italic"><code>repfile.rex</code></emphasis></title>
<programlisting>
<![CDATA[
/* repfile.rex - demonstrates file replacement */
testfile=.stream~new("temp.dat") /* Create a new stream object        */
testfile~open("both replace")    /* Open for read, write, and replace */
numlines=random(1,100)           /* Pick a number from 1 to 100       */
runid=random(1,9999)             /* Pick a run identifier             */
do i=1 to numlines               /* Write the lines                   */
   testfile~lineout("Run ID:"||runid "Line number" i)
end

/*
   Now read and display the file.  The read pointer is already at the
   beginning of the file.  MAKEARRAY reads from the read position to
   the end of the file and returns an array object containing the
   lines.
*/
filedata=testfile~makearray("line")
do i over filedata
   say i
end
testfile~close
]]>
</programlisting>
</example>
<para>The <code>repfile.rex</code> example also demonstrates that Rexx maintains separate read and
write pointers to a stream. The read pointer is still at the beginning of
the file while the write pointer is at the end of it.</para>
</section>

<section id="binaryfiles"><title>Reading Binary Files</title>
<indexterm><primary>reading</primary>
<secondary>binary files</secondary></indexterm>
<para>A binary file is a file whose data is not organized
into lines ending with line-end characters. In most cases, you use the character
I/O methods (such as <emphasis role="italic">CHARS</emphasis>,
<emphasis role="italic">CHARIN</emphasis>, <emphasis role="italic">CHAROUT</emphasis>) on these files.</para>
<para>Suppose, for example, that you want to read the data in the <code>chord.wav</code>
file (supplied with Windows in <code>C:\Windows\Media</code>) into a variable:</para>
<example>
<title><emphasis role="italic"><code>getchord.rex</code></emphasis></title>
<programlisting>
<![CDATA[
/* getchord.wav - reads chord.wav into a variable           */
chordf=.stream~new("C:\Windows\Media\chord.wav")
say "Number of characters in the file=" chordf~chars

/* Read the whole WAV file into a single Rexx variable. */
/* Rexx variables are limited by available memory.      */
mychord=chordf~charin(1,chordf~chars)
say "Number of characters read into variable" mychord~length
]]>
</programlisting>
</example>
<para>The <emphasis role="italic">CHARIN</emphasis> method returns a string of characters from the stream,
which in this case is <code>chord.wav</code>. <emphasis role="italic">CHARIN</emphasis> accepts two optional arguments. If no arguments
are specified, <emphasis role="italic">CHARIN</emphasis> reads one character from the current read position and
then advances the read pointer.</para>
<para>The first argument is a start position for reading the file. In the example,
1 is specified so that <emphasis role="italic">CHARIN</emphasis> begins reading with the first character of the
file. Omitting the first argument achieves the same result.</para>
<para>The second argument specifies how many characters are to be read. To read
all the characters, <computeroutput>chordf~chars</computeroutput> was specified as the second
argument. The <emphasis role="italic">CHARS</emphasis> method returns the number of characters remaining to be
read in the input stream receiving the message. <emphasis role="italic">CHARIN</emphasis> then returns all the
characters in the stream. <code>chord.wav</code> has about 114,000 characters.</para>
</section>

<section id="readtextfileatime"><title>Reading Text Files a Character at a Time</title>
<indexterm><primary>reading</primary>
<secondary>a text file, one character at a time</secondary></indexterm>
<indexterm><primary>binary files</primary>
<secondary>reading</secondary></indexterm>
<indexterm><primary>text files</primary>
<secondary>reading a character at a time</secondary></indexterm>
<indexterm><primary>line-end characters</primary></indexterm>

<para>You can use the <emphasis role="italic">CHARIN</emphasis> and other character methods on text files. Because
you read the file as characters, <emphasis role="italic">CHARIN</emphasis> returns the
line-end characters to your program.
Line methods, on the contrary, do not return the line-end characters to your
program. Rexx adds line-end characters to the end of every
line written using the <emphasis role="italic">LINEOUT</emphasis> method. Text-processing applications,
such as the Windows Notepad, also add line-end characters.
As a convenience, Rexx has an environment symbol name <code>.ENDOFLINE</code>
that returns the line-end characters used by the Stream class
on the current system. When reading a text file with <emphasis role="italic">CHARIN</emphasis>,
interpret the character sequence in <code>.ENDOFLINE</code> as the end of a line.
</para>
<para>As an example, run the following program. It writes lines to a file using
<emphasis role="italic">LINEOUT</emphasis> and then reads those lines using
<emphasis role="italic">CHARIN</emphasis>. You can mix line methods
and character methods. Rexx maintains separate read and write pointers, so
there is no need to close the file or search for another position before reading
the lines just written.</para>
<example>
<title><emphasis role="italic"><code>linechar.rex</code></emphasis></title>
<programlisting>
<![CDATA[
/* linechar.rex - demonstrate line end characters                   */
file=.stream~new("test.dat")  /* Create a new stream object         */

file~open("both replace")  /* Open the file for reading and writing */
do i=1 to 3                /* Write three lines to the file         */
   file~lineout("Line" i)
end /* do */

do while file~chars<>0     /* Read the file a character at a time   */
   byte=file~charin        /* Read a character                      */
   ascii_value=byte~c2d    /* Convert character to a decimal value  */
   if ascii_value=13 then        /* Carriage return?                */
      say "Carriage return"
   else if ascii_value=10 then   /* Line feed?                      */
      say "Line feed"
   else say byte ascii_value     /* Ordinary character              */
end /* do */
file~close                       /* Close the file                  */
]]>
</programlisting>
</example>
<para>It is not recommended to use line methods to read binary files. Your binary
file might not contain any new-line characters. And, if it did, the characters
probably are not meant to be interpreted as new-line characters.</para>
</section>

<section id="writebinaryfiles"><title>Writing Binary Files</title>
<indexterm><primary>writing</primary>
<secondary>binary files</secondary></indexterm>
<indexterm><primary>binary files</primary>
<secondary>writing</secondary></indexterm>
<para>To write a binary file, you use <emphasis role="italic">CHAROUT.</emphasis>
<emphasis role="italic">CHAROUT</emphasis> writes only the characters that you specify in an argument of the
method. <emphasis role="italic">CHAROUT</emphasis> does not add line-end
characters to
the end of the string. Here is an example:</para>
<example>
<title><emphasis role="italic"><code>jack.rex</code></emphasis></title>
<programlisting>
<![CDATA[
/* jack.rex - demonstrate that CHAROUT does not add line-end characters */
filebin=.stream~new("binary.dat")   /* Create a new stream object       */
filebin~open("replace")             /* Open the file for replacement    */
do i=1 to 50                        /* Write fifty strings              */
  filebin~charout("All work and no play makes Jack a dull boy. ")
end
filebin~close                  /* Close the file so we can display it   */
"type binary.dat"              /* Use the TYPE command to display file  */
]]>
</programlisting>
</example>
<para>Because line-end characters are not added, the text displayed
by the <emphasis role="italic">TYPE</emphasis> command is concatenated into one contiguous line.</para>
<para><emphasis role="italic">CHAROUT</emphasis> writes the string specified and advances the write pointer. If
you want to position the write pointer before writing the string, specify
the starting position as a second argument:</para>
<programlisting>
<![CDATA[
filebin~charout("Jack is losing it.",30) /* start writing at character 30 */
]]>
</programlisting>
<para>In the example, the file is explicitly opened and closed. If
you do not open the file, Rexx attempts to open the file for both reading
and writing. If you do not close the file, Rexx closes it when the procedure
ends.
</para>
</section>

<section id="closefiles"><title>Closing Files</title>
<indexterm><primary>closing files</primary></indexterm>
<indexterm><primary>binary files</primary>
<secondary>closing</secondary></indexterm>
<indexterm><primary>text files</primary>
<secondary>closing</secondary></indexterm>
<para>If
you do not explicitly close a file, Rexx closes the file when the Stream object
is reclaimed by the garbage collector.  This frequently does not occur until
your program exits, so it is good practice to
explicitly close
files when you are finished with them.</para>
</section>

<section id="directfileaccess"><title>Direct File Access</title>
<indexterm><primary>direct file access</primary></indexterm>
<indexterm><primary>binary files</primary>
<secondary>direct access</secondary></indexterm>
<indexterm><primary>text files</primary>
<secondary>direct access</secondary></indexterm>
<para>Rexx provides several ways for you to read records
of a file directly (that is, in random order). The following example,
<code>direct.rex</code>, shows several cases that illustrate some of your options.</para>
<para><code>direct.rex</code> opens a file for both reading and writing, which is indicated
by the <emphasis role="italic">BOTH</emphasis> argument of the <emphasis role="italic">OPEN</emphasis> method.
The <emphasis role="italic">REPLACE</emphasis> argument of the <emphasis role="italic">OPEN</emphasis>
method causes any existing <code>direct.dat</code> file to be replaced.</para>
<para>The <emphasis role="italic">OPEN</emphasis> method also has the arguments
<emphasis role="italic">BINARY</emphasis> and <emphasis role="italic">RECLENGTH</emphasis>, which are
useful for direct file access.</para>
<para>The <emphasis role="italic">BINARY</emphasis> argument opens the stream in binary mode, which means that line-end
characters are ignored. Binary mode is useful if you want to process binary
data using line methods. It is easier to use line methods for direct access.
With line methods, you can search a position in a file using line numbers.
With character methods, you must calculate the character displacement of
the file.</para>
<para>The <emphasis role="italic">RECLENGTH</emphasis> argument defines a record length of 50 for the file. It enables
you to use line methods in a binary-mode stream. Because Rexx now knows how
long each record is, it can calculate the displacement of the file for a given
record number and read the record directly.</para>
<example>
<title><emphasis role="italic"><code>direct.rex</code></emphasis></title>
<programlisting>
<![CDATA[
/* DIRECT.CMD - demonstration of direct file access       */
db=.stream~new("direct.dat")
db~open("both replace binary reclength 50")

/* Write three records of 50 bytes each using LINEOUT     */
db~lineout("Cole, Gary:  Blue")
db~lineout("McGuire, Rick: Red")
db~lineout("Pritko, Steve: Red. Oops.. I mean blue!")

/* Case 1: Read the records in order using LINEIN.        */
say "Case 1: Sequential reads with LINEIN..."
do i=1 to 3
   say db~linein
end
say "Press Enter to continue"; parse pull resp

/* Case 2: Read records in random order using LINEIN      */
say "Case 2: Random reads with LINEIN..."
do i=1 to 5
   lineno=random(1,3)
   say "Record" lineno "=" db~linein(lineno)
end
say "Press Enter to continue"; parse pull resp

/* Case 3: Read entire file with CHARIN                   */
say "Case 3: Read entire file with a single CHARIN..."
say db~charin(1,150)
say "Press Enter to continue"; parse pull resp

/* Case 4: Read file sequentially with CHARIN             */
say "Case 4: Sequential reads with CHARIN..."
db~seek(1 read)         /* Reposition read pointer        */
do i=1 to 3
   say db~charin(,50)
end
say "Press Enter to continue"; parse pull resp

/* Case 5: Read records in random order with CHARIN       */
say "Case 5: Random reads with CHARIN..."
do i=1 to 5
   lineno=random(1,3)
   charno=((lineno-1)*50)+1
   say "Record" lineno "Character" charno "=" db~charin(charno,50)
end
say "Press Enter to continue"; parse pull resp

/* Case 6: Write records in random order with LINEOUT     */
say "Case 6: Replace record 2 with LINEOUT"
db~lineout("This should replace line 2",2)
do i=1 to 3
   say db~linein(i)
end
say "Press Enter to continue"; parse pull resp

/* Case 7: Write records in random order with CHAROUT     */
say "Case 7: Replace record 2 with CHARIN..."
db~charout("New record 2 from CHAROUT"~left(50,"."),51)
db~seek(1 read)         /* Reposition read pointer        */
do i=1 to 3
   say db~charin(,50)
end
say "Press Enter to continue"; parse pull resp
db~close
]]>
</programlisting>
</example>
<para>After opening the file, <code>direct.rex</code> writes three records using
<emphasis role="italic">LINEOUT.</emphasis> The records are
not padded to 50 characters, Rexx itself handles that. Because the file is opened
in binary mode, Rexx does not write line-end characters at the end of each
line. It only writes the strings one after another to the stream.</para>
<para>In Case 1, the <emphasis role="italic">LINEIN</emphasis> method is used to read the file. Because the file
is open in binary mode, <emphasis role="italic">LINEIN</emphasis> does not look for line-end characters to mark
the end of a line. Instead, it relies on the record length that you specify
on open. In fact, if there were a carriage-return or line-feed sequence of
the line, Rexx would return those characters to your program.</para>

<para>Case 2 demonstrates how to read the file in random order. In this case,
the <emphasis role="italic">RANDOM</emphasis> function is used to choose a record to be retrieved. Then the desired
record number is specified as an argument on <emphasis role="italic">LINEIN.</emphasis> Note that records are
numbered starting from 1, not from 0. Because the file is opened in binary
mode, Rexx does not look for line-end characters.  It uses the <emphasis role="italic">RECLENGTH</emphasis> value to
determine where to begin reading. The <emphasis role="italic">LINEIN</emphasis> method can, therefore, retrieve a line
directly, without having to scan through the file counting line-end characters.</para>

<para>Case 3 proves that no line-end characters exist in the file. The <emphasis role="italic">CHARIN</emphasis>
method reads the entire file. <emphasis role="italic">SAY</emphasis> displays the returned string as one long
string. If Rexx inserted line-end characters, each record would be displayed
on a separate line.</para>

<para>Case 4 shows how to read the binary mode file sequentially using <emphasis role="italic">CHARIN.</emphasis>
But before reading the file, the read pointer must be reset to the beginning
of the file. (Case 3 leaves the read pointer at the end of the file.) The
<emphasis role="italic">SEEK</emphasis> method resets the read pointer to character 1, which is the beginning
of the file. As with lines, Rexx numbers characters starting with 1, not 0.
Position 1 is the first character of the file.</para>
<para>By default, the number specified with <emphasis role="italic">SEEK</emphasis> refers to a character position.
You can also search by line number or by offsets. <emphasis role="italic">SEEK</emphasis> allows offsets from
the current read or write position (a relative position), or from the beginning
or ending of the file (an absolute position).
If you prefer typing longer method names, you can use <emphasis role="italic">POSITION</emphasis> as a
synonym for <emphasis role="italic">SEEK</emphasis>.</para>
<para>In the loop of Case 4, the first argument on <emphasis role="italic">CHARIN</emphasis> is omitted. The first
argument tells where to position the read pointer. If it is omitted, Rexx
automatically advances the read pointer based on the number of characters
you are reading.</para>

<para>Case 5 demonstrates how to read records in random order with <emphasis role="italic">CHARIN</emphasis>. In
the loop, a random record number is selected and assigned to the variable
<computeroutput>lineno</computeroutput>. This record number is
then converted to a character number,
which can be used to specify the read position on <emphasis role="italic">CHARIN</emphasis>. Compare Case 5 with
Case 2. In Case 2, which uses line methods, it is not necessary to perform
a calculation, you just request the record you want.</para>

<para>Cases 6 and 7 write records in random order. Case 6 uses <emphasis role="italic">LINEOUT</emphasis>, while
Case 7 uses <emphasis role="italic">CHAROUT</emphasis>. Because the file is opened in binary mode, <emphasis role="italic">LINEOUT</emphasis> does
not write line-end characters. You can write over a line by specifying a line
number. With <emphasis role="italic">CHAROUT</emphasis>, you need to calculate the character position of the
line to be replaced. Unlike <emphasis role="italic">LINEOUT</emphasis>, you need to ensure that the string being
written with <emphasis role="italic">CHAROUT</emphasis> is padded to the appropriate record length. Otherwise,
part of the record being replaced remains in the file.</para>
<para>Consequently, for random reading of files with fixed length records, line
methods are often the better choice. However, one limitation of the line methods
is that you cannot use them to write sparse records. That is, if a file already
has 200 records, you can use <emphasis role="italic">LINEOUT</emphasis> to write record <emphasis role="italic">201</emphasis>, but you cannot use
<emphasis role="italic">LINEOUT</emphasis> to write record <emphasis role="italic">300</emphasis>.
With <emphasis role="italic">CHAROUT</emphasis>, however, you can open a new file
and start writing at character position <emphasis role="italic">5000</emphasis> if you choose.</para>
</section>

<section id="checkfileexistence"><title>Checking for the Existence of a File</title>
<indexterm><primary>checking for the existence of a file</primary></indexterm>
<indexterm><primary>binary files</primary>
<secondary>querying existence</secondary></indexterm>
<indexterm><primary>text files</primary>
<secondary>querying existence</secondary></indexterm>
<para>To check for the existence of a file, you use the
<emphasis role="italic">QUERY</emphasis> method of the Stream class. The following <code>isthere.rex</code> program
accepts a file name as a command line argument and checks for the existence
of that file.</para>
<example>
<title><emphasis role="italic"><code>isthere.rex</code></emphasis></title>
<programlisting>
<![CDATA[
/* isthere.rex - test for the existence of a file        */
parse arg fid                    /* Get the file name    */
qfile=.stream~new(fid)           /* Create stream object */
if qfile~query("exists")="" then /* Check for existence  */
   say fid "does not exist."
else
   say fid "exists."
]]>
</programlisting>
</example>
<para>In the example, a stream object is created for the file even though it
might not exist. This is acceptable because the file is not opened when the
stream object is created.</para>
<para>The <emphasis role="italic">QUERY</emphasis> method accepts one argument. To check for the existence of a
file, you specify the string <computeroutput>"exists"</computeroutput> as
previously shown. If the file exists, <emphasis role="italic">QUERY</emphasis> returns the full-path specification
of the stream object. Otherwise, <emphasis role="italic">QUERY</emphasis> returns a null string.</para>
</section>

<section id="getotherfileinfo"><title>Getting Other Information about a File</title>
<indexterm><primary>querying a file</primary></indexterm>
<indexterm><primary>binary files</primary>
<secondary>querying other information</secondary></indexterm>
<indexterm><primary>text files</primary>
<secondary>querying other information</secondary></indexterm>
<para>The <emphasis role="italic">QUERY</emphasis> method can also return date and time stamps,
read position, write position, the size of the file, and so on. The following
example shows most of the <emphasis role="italic">QUERY</emphasis> arguments.</para>
<example>
<title><emphasis role="italic"><code>infoon.rex</code></emphasis></title>
<programlisting>
<![CDATA[
/* infoon.rex - display information about a file */
parse arg fid
qfile=.stream~new(fid)
fullpath=qfile~query("exists")
if fullpath="" then do
   say fid "does not exist."
   exit
end
qfile~open("both")
say ""
say "Full path name:" fullpath
say "Date and time stamps (U.S. format):" qfile~query("datetime")
say "            (International format):" qfile~query("timestamp")
say ""
say "Handle associated with stream:" qfile~query("handle")
say "                  Stream type:" qfile~query("streamtype")
say ""
say "          Size of the file (characters):" qfile~query("size")
say " Read position (in terms of characters):" qfile~query("seek read")
say "Write position (in terms of characters):" qfile~query("seek write")
qfile~close
]]>
</programlisting>
</example>
</section>

<section id="standardio"><title>Using Standard I/O</title>
<indexterm><primary>I/O, standard (keyboard, displays, and error streams)</primary></indexterm>
<indexterm><primary>standard I/O (keyboard, displays, and error streams)</primary></indexterm>

<para>All of the preceding topics dealt with the reading and writing of files.
You can use the same methods to read from standard input (usually the keyboard)
and to write to standard output (usually the display). You can also use the
methods to write to the standard error stream. In Rexx, these default
streams are represented by public objects of the Monitor class: <code>.input</code>,
<code>.output</code>, and <code>.error</code>.</para>
<para>The streams <emphasis role="italic">STDIN</emphasis>,
<emphasis role="italic">STDOUT</emphasis>, and <emphasis role="italic">STDERR</emphasis> are transient streams. For transient
streams, you cannot use any method or method argument for positioning the
read and write pointers. You cannot, for example, use the <emphasis role="italic">SEEK</emphasis> method on
<emphasis role="italic">STDOUT</emphasis>.</para>

<para>Writing to <emphasis role="italic">STDOUT</emphasis> has the same effect as using
the <emphasis role="italic">SAY</emphasis> instruction. However,
the <emphasis role="italic">SAY</emphasis> instruction always writes line-end characters at the end of the string.
By using the <emphasis role="italic">CHAROUT</emphasis> method to write to <emphasis role="italic">STDOUT</emphasis>, you can control when line-end
characters are written.</para>
<para>The following example shows a modified <code>count.rex</code> program previously shown in
<xref linkend="readtxtfile" />. <code>count.rex</code> has been modified
to display a progress indicator. For every line processed, <code>count.rex</code> now uses
<emphasis role="italic">CHAROUT</emphasis> to display a single period. <code>count.rex</code> does not write any line-end
characters, so the periods wrap to the next line when they reach the end of
the line in the Windows window.</para>
<example>
<title>Modified <emphasis role="italic"><code>count.rex</code></emphasis></title>
<programlisting>
<![CDATA[
                            /* count counts the words in a file */
parse arg path                          /* Get the file name    */
count=0                                 /* Initialize the count */
file=.stream~new(path)        /* Create a stream object for the input file */
do while file~lines<>0        /* Process each line of the file */
   text=file~linein           /* Read a line                   */
   count=count+(text~words)   /* Count blank-delimited tokens  */
   .output~charout(".")       /* Write period to STDOUT        */
end
say ""
say count
]]>
</programlisting>
</example>
<para>Reading from <emphasis role="italic">STDIN</emphasis> using <emphasis role="italic">LINEIN</emphasis>
is similar to reading with the <emphasis role="italic">PARSE PULL</emphasis>
instruction:</para>
<example>
<title><emphasis role="italic"><code>inexam.rex</code></emphasis></title>
<programlisting>
<![CDATA[
/* inexam.rex - example of reading STDIN with LINEIN  */

/* Prompt for input with SAY and PARSE instructions   */
say "What is your name?"
parse pull response
say "Hi" response
say ""

/* Now prompt using LINEOUT and LINEIN                */
.output~lineout("What is your name?")
response=.input~linein
.output~lineout("Hi" response)
]]>
</programlisting>
</example>
<para>Using character methods with <emphasis role="italic">STDIN</emphasis> and <emphasis role="italic">STDOUT</emphasis> gives you more control over
the reading and writing of line-end characters. In the following example,
the prompting string is written to <emphasis role="italic">STDOUT</emphasis> using
<emphasis role="italic">CHAROUT</emphasis>. Because <emphasis role="italic">CHAROUT</emphasis> does
not add any line-end characters to the stream, the display cursor is positioned
after the prompt string on the same line.</para>
<example>
<title><emphasis role="italic"><code>inchar.rex</code></emphasis></title>
<programlisting>
<![CDATA[
/* inchar.rex - example of reading STDIN with CHARIN  */
.output~charout("What is your name? ")
response=.input~charin(,10)
.output~charout("Hi" response)
]]>
</programlisting>
</example>
<para><emphasis role="italic">CHARIN</emphasis> is used to read the user's response. The user's keystrokes
are not returned to your program until the user presses the Enter key. In
the example, a length of 10 is specified. If fewer characters than the specified
length are available, <emphasis role="italic">CHARIN</emphasis> waits until they become available. Otherwise,
the characters are returned to your program. <emphasis role="italic">CHARIN</emphasis> does not strip any carriage-return
or line-feed characters before returning the string to your program. You can
observe this with <code>inchar.rex</code> by typing several strings that have less than ten
characters and pressing Enter after each string:</para>
<programlisting>
<![CDATA[
[C:\>inchar.rex
What is your name? John
Q.
Public
Hi John
Q.
Pu
]]>
</programlisting>
</section>

<section id="usedevice"><title>Using Windows Devices</title>
<indexterm><primary>devices, sending information to</primary></indexterm>

<para>You can use Windows
devices by substituting a device name (such as <emphasis role="italic">PRN</emphasis>, <emphasis role="italic">LPT1</emphasis>,
<emphasis role="italic">LPT2</emphasis>, <emphasis role="italic">COM1</emphasis>, and
so on) for the file name when you create a stream object. Then use line or
character methods to read or write the device.</para>
<para>The following example sends data to a printer (device name <emphasis role="italic">PRN</emphasis> in the example).
In addition to sending text data, the example also sends a control character
for starting a new page. You can send other control characters or escape sequences
in a similar manner. (Generally, these are listed in the manual for the device.)</para>
<para>Usually the control characters are characters that you cannot type at the
keyboard. To use them in your program, send a <emphasis role="italic">D2C</emphasis> message to the character's
ASCII value as shown in the example.</para>
<example>
<title><emphasis role="italic"><code>printit.rex</code></emphasis></title>
<programlisting>
<![CDATA[
/* printit.rex - Prints a text file                                    */
say "Type file name: "           /* prompt for a file name */
pull filename                    /* ...and get it from the user        */
infile=.stream~new(filename)
printer=.stream~new("prn:")

newpage = 12~d2c                  /* save page-eject character         */

/* Repeat this loop until no lines remain in the file */
/* and keep track of the line count with COUNT        */

do count = 1 until filename~lines = 0
   if printer~lineout(infile~linein) <> 0 then do
      say "Error: unable to write to printer"
      leave
   end
   if count // 50 = 0 then                 /* if the line count is a */
      printer~charout(newpage)             /* multiple of 50, then   */
                                           /* start a new page by    */
                                           /* sending the form feed  */

end                               /* go back to the start of loop    */
                                  /* until no lines remain           */

infile~close                      /* close the file                  */
exit                              /* end the program normally        */
]]>
</programlisting>
</example>
</section>
</chapter>
