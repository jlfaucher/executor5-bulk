<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "rexxpg.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: Programming Guide XML file.
    #
    # Copyright (c) 2005-2014, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<chapter id="rexio"><title>Input and Output</title>
<indexterm><primary>I/O model</primary></indexterm>
<indexterm><primary>model, stream I/O</primary></indexterm>
<indexterm><primary>stream I/O model</primary></indexterm>
<indexterm><primary>stream object</primary></indexterm>
<para>Object Rexx supports a stream
I/O model. Using streams, your program reads data from various devices
(such as hard disks, CD-ROMs, and keyboards) as a continuous stream of characters.
Your program also writes data as a continuous stream of characters.</para>
<para>In the stream model, a text file is represented as a stream of characters
with special line-end characters marking the end of each line of text in the stream.</para>
<para>We use the expression &quot;line-end characters&quot; because they are
platform dependent, and may be a single character
(UNIX / Linux and Mac OS X use a single line feed character (0Dx, 13 decimal),
classic Mac uses a single carriage return character (0Ax, 10 decimal)
or a character combination
(Windows / DOS uses a carriage return \ line feed character pair (0D0Ax)).
Henceforth, when we use the expression &quot;line-end characters&quot;,
we mean whatever character sequence constitues the line termination sequence
on whichever platform you are working with Object Rexx on.</para>
<para>A binary file is a stream of characters without an inherent line structure.
An Object Rexx stream object allows you read from a data stream using either the text-file
line methods or using a continuous data stream method.</para>
<para>The Object Rexx Stream class is the mechanism for accessing I/O streams.
To input or output data, you first create an instance of the Stream
class that represents the device or file you want to use. For example, the
following clause creates a stream object for the file C:\out.dat:</para>
<programlisting>
<![CDATA[
/* Create a stream object for out.dat */
file=.stream~new("c:\out.dat")
]]>
</programlisting>
<para>Then you use the appropriate stream methods to read and/or write the data.
OUT.DAT is a text file, so you would normally use the LINES(), LINEIN, and
LINEOUT() methods that read or write data as delimited lines.
If the stream represents a binary file (such as a WAV,
GIF, TIF, AVI or EXE file), you would use the CHARS, CHARIN, and CHAROUT methods that read and write
data as characters.</para>
<para>The Stream class includes additional methods for opening and closing streams,
flushing buffers, seeking to specific file locations, retrieving stream status,
and other I/O operations.</para>

<section id="streamobj"><title>More about Stream Objects</title>
<para>To use streams in Object Rexx, you create new instances of the Stream class.
These stream objects represent the various data sources and destinations available
to your program, such as hard disks, CD-ROMs, keyboards, displays, printers,
serial interfaces or devices on a network.
</para>
<para>Stream objects can be transient or persistent.  An example of a transient
(or dynamic) stream object is a serial interface. Data can be sent or received
from serial interfaces, but the data is not stored permanently by the serial
interface itself.  Consequently, you cannot, for example, read from or write to
a random position in the data stream&ndash;it can only be read and/or written
as a sequential stream of characters.
Once you read from or write to the stream, the data cannot be re-accessed.</para>
<para>A disk file is an example of a persistent stream object.  Because the data
is stored on disk, you can search forward and backward in the stream and reread
data that you have previously read. Object Rexx maintains separate read and write
pointers to a stream that you can move independently of each other using arguments
on methods such as LINEIN, LINEOUT, CHARIN, and CHAROUT. The Stream class also provides
SEEK and POSITION methods for setting the read and write positions.</para>
</section>

<section id="readtxtfile"><title>Reading a Text File</title>
<indexterm><primary>reading</primary>
<secondary>text files</secondary></indexterm>
<indexterm><primary>text files</primary>
<secondary>reading</secondary></indexterm>
<para>The following shows an example of reading a file.
Program COUNT.CMD counts the words in a text file. To run it, enter Rexx COUNT
followed by the name of the file to be processed:</para>
<programlisting>
<![CDATA[
rexx count myfile.txt
rexx count r:\rexx\articles\devcon7.scr
]]>
</programlisting>
<para>COUNT uses the String method WORDS to count the words, so COUNT
actually counts whitespace-delimited tokens:</para>
<indexterm><primary>counting words in a file</primary></indexterm>
<example>
<title>COUNT.CMD with automatic open</title>
<programlisting>
<![CDATA[
/* COUNT.CMD - counts the words in a file                          */
parse arg path              /* Get file name from command line     */
count=0                     /* Initialize a counter                */
file=.stream~new(path)      /* Create a stream object for the file */
do while file~lines<>0      /* Loop as long as there are lines     */
  text=file~linein          /* Read a line from the file           */
  count=count+(text~words)  /* Count words and add to counter      */
end
say count                   /* Display the count                   */
]]>
</programlisting>
</example>
<para>To read a file, COUNT first creates a Stream object for the file by sending
the NEW message to the Stream class. The file name (with or without a path)
is specified as an argument on the NEW method.</para>
<para>Within the DO loop, COUNT reads the lines of the file by sending LINEIN messages
to the stream object (pointed to by the variable File). The first LINEIN message
causes Object Rexx to automatically open the file if it was not already open
(the NEW method does not open the file). LINEIN, by default, reads one line
from the file, starting at the current read position.</para>
<para>Object Rexx returns only the text of the line to your program
without any line-end characters.</para>
<para>The DO loop is controlled by the expression &quot;file~lines&lt;>0&quot;.
The LINES method returns the number of lines remaining to be read in
the file, so Object Rexx processes the loop until no lines remain to be read.</para>
<para>In the COUNT program, the LINEIN request forces Object Rexx to open the file, but you
can also open the file yourself using the OPEN method of the Stream class.
By using the OPEN method, you control the mode in which Object Rexx opens the file.
When Object Rexx implicitly opens a file because of a LINEIN request, it tries to
open the file for both reading and writing. If that fails, it tries to open the file
for reading. To ensure that the file is opened only for reading, you can modify
COUNT as follows:</para>
<example>
<title>COUNT.CMD with explicit open</title>
<programlisting>
<![CDATA[
/* COUNT.CMD - counts the words in a file                          */
parse arg path              /* Get file name from command line     */
count=0                     /* Initialize a counter                */
file=.stream~new(path)      /* Create a stream object for the file */
openrc=file~open("read")    /* Open the file for reading           */
if openrc<>"READY:" then do /* Check the return code               */
  say "Could not open" path||"~ RC="||openrc
  exit openrc               /* Bail out                            */
end
do while file~lines<>0      /* Loop as long as there are lines     */
  text=file~linein          /* Read a line from the file           */
  count=count+(text~words)  /* Count words and add to counter      */
end
file~close                  /* Close the file                      */
say count                   /* Display the count                   */
]]>
</programlisting>
</example>
<para>The CLOSE method, used near the end of the previous example, closes the
file. A CLOSE is not required. Object Rexx closes the stream for you when the program
ends. However, it is a good idea to CLOSE streams to make the resource available
for other uses.</para>
</section>

<section id="textfilearray"><title>Reading a Text File into an Array</title>
<indexterm><primary>ARRAYIN method, using</primary></indexterm>
<indexterm><primary>arrays, reading streams into</primary></indexterm>
<indexterm><primary>reading</primary>
<secondary>streams into arrays</secondary></indexterm>
<indexterm><primary>text files</primary>
<secondary>reading into an array</secondary></indexterm>
<para>Object Rexx
provides a Stream method, named ARRAYIN, that reads the contents of a stream
into an array object. ARRAYIN is convenient when you need to read an entire
file into memory for processing. You can read the entire file with a single
Object Rexx clause&ndash;no looping is necessary.</para>
<para>The following example (CVIEW.CMD) uses the ARRAYIN method
to read the entire CONFIG.SYS file into an array object. CVIEW displays selected
lines from CONFIG.SYS. A search argument can be specified when starting CVIEW:</para>
<programlisting>
<![CDATA[
rexx cview libpath
]]>
</programlisting>
<para>CVIEW prompts for a search argument if you do not specify one.</para>
<para>If CVIEW finds the string, it displays the line(s) in which the string was
found. CVIEW continues to prompt for a new search string until you enter
<programlisting>Q</programlisting> in response to the prompt.</para>
<example>
<title>CVIEW.CMD</title>
<programlisting>
<![CDATA[
/* CVIEW - display lines from CONFIG.SYS                               */
parse upper arg search_string      /* Get any command line argument  */
file=.stream~new("c:\config.sys")  /* Create stream object */
lines=file~arrayin                 /* Read file into an array object */
                                   /* LINES points to the array obj. */
loop forever
   if search_string="" then do     /* Prompt for user input          */
      say "Enter a search string or Q to quit:"
      parse upper pull search_string
      if search_string="Q" then exit
   end
   loop i over lines                /* Scan the array                */
      if pos(search_string,translate(i))>0 then do
         say i                      /* Display any line that matches */
         say "="~copies(20)
      end
   end
   search_string=""                 /* Reset for next search         */
end
]]>
</programlisting>
</example>
</section>

<section id="textfilelines"><title>Reading Specific Lines of a Text File</title>
<indexterm><primary>text files</primary>
<secondary>reading specific lines</secondary></indexterm>
<indexterm><primary>reading</primary>
<secondary>specific lines of text files</secondary></indexterm>
<para>You can read
a specific line of a text file by entering a line number as an argument on
the LINEIN method. In this example, line 3 is read from CONFIG.SYS:</para>
<example>
<title>LINEIN</title>
<programlisting>
<![CDATA[
/* Read and display line 3 of CONFIG.SYS */
infile=.stream~new("c:\config.sys")
say infile~linein(3)
]]>
</programlisting>
</example>
<para>You do not reduce file I/O by using specific line numbers. Because text
files do not have a specific record length, Object Rexx must read through the file
counting occurrences of line-end characters to find the line number you want.</para>
</section>

<section id="writetextfile"><title>Writing a Text File</title>
<indexterm><primary>text files</primary>
<secondary>writing</secondary></indexterm>
<indexterm><primary>writing</primary>
<secondary>text files</secondary></indexterm>
<para>To write lines of text to a file, you use the LINEOUT
method. By default, LINEOUT appends to an existing file. The following example
adds an item to a to-do list that is maintained as a simple text file:</para>
<example>
<title>TODO.CMD</title>
<programlisting>
<![CDATA[
/* TODO.CMD - add to a todo list                              */
parse arg text
file=.stream~new("todo.dat")      /* Create a stream object    */
file~lineout(date() time() text)  /* Append a line to the file */
exit
]]>
</programlisting>
</example>
<para>In TODO, a text string is provided as the only argument on LINEOUT. Object Rexx
writes the line of text to the file with line-end characters appended.
You do not have to provide line-end characters in the string to be written.</para>
<para>If you want to overwrite a file, specify a line number as a second argument
to position the write pointer:</para>
<programlisting>
<![CDATA[
file~lineout("13760-0006",35)  /* Replace line 35 */
]]>
</programlisting>
<para>Object Rexx does not prevent you from overwriting existing line-end characters
in the file. Consequently, if you want to replace a line of the file without
overlaying the following lines, the line you write must have the same length
as the line you are replacing. Writing a line that is shorter than an existing
line leaves part of the old line in the file.</para>
<para>Also, positioning the write pointer to line 1 does not replace the file.
Object Rexx starts writing over the existing data starting at line 1, but if you
happen to write fewer bytes than previously existed in the file, your data
is followed by the remainder of the old file.</para>
<para>To replace a file, use the OPEN method with WRITE REPLACE or BOTH REPLACE
as an argument. In the following example, a file named TEMP.DAT is replaced
with a random number of lines. TEMP.DAT is then read and displayed. You can run the example
repeatedly to verify that TEMP.DAT is replaced on each run.</para>
<example>
<title>REPFILE.CMD</title>
<programlisting>
<![CDATA[
/* REPFILE.CMD - demonstrates file replacement */
testfile=.stream~new("temp.dat") /* Create a new stream object        */
testfile~open("both replace")    /* Open for read, write, and replace */
numlines=random(1,100)           /* Pick a number from 1 to 100       */
runid=random(1,9999)             /* Pick a run identifier             */
do i=1 to numlines               /* Write the lines                   */
   testfile~lineout("Run ID:"||runid "Line number" i)
end

/*
   Now read and display the file.  The read pointer is already at the
   beginning of the file.  MAKEARRAY reads from the read position to
   the end of the file and returns an array object containing the
   lines.
*/
filedata=testfile~makearray("line")
do i over filedata
   say i
end
testfile~close
]]>
</programlisting>
</example>
<para>The REPFILE example also demonstrates that Object Rexx maintains separate read and
write pointers to a stream. The read pointer is still at the beginning of
the file while the write pointer is at the end of it.</para>
</section>

<section id="binaryfiles"><title>Reading Binary Files</title>
<indexterm><primary>reading</primary>
<secondary>binary files</secondary></indexterm>
<para>A binary file is a file whose data is not organized
into lines ending with line-end characters. In most cases, you use the character
I/O methods (such as CHARS, CHARIN, CHAROUT) on these files.</para>
<para>Suppose, for example, that you want to read the data in the CHORD.WAV
file (supplied with Windows in C:\Windows\Media) into a variable:</para>
<example>
<title>GETCHORD.CMD</title>
<programlisting>
<![CDATA[
/* GETCHORD - reads CHORD.WAV into a variable           */
chordf=.stream~new("C:\Windows\Media\chord.wav")
say "Number of characters in the file=" chordf~chars

/* Read the whole WAV file into a single Object Rexx variable. */
/* Object Rexx variables are limited by available memory.      */
mychord=chordf~charin(1,chordf~chars)
say "Number of characters read into variable" mychord~length
]]>
</programlisting>
</example>
<para>The CHARIN method returns a string of characters from the stream,
which in this case is CHORD.WAV. CHARIN accepts two optional arguments. If no arguments
are specified, CHARIN reads one character from the current read position and
then advances the read pointer.</para>
<para>The first argument is a start position for reading the file. In the example,
1 is specified so that CHARIN begins reading with the first character of the
file. Omitting the first argument achieves the same result.</para>
<para>The second argument specifies how many characters are to be read. To read
all the characters, <computeroutput>chordf~chars</computeroutput> was specified as the second
argument. The CHARS method returns the number of characters remaining to be
read in the input stream receiving the message. CHARIN then returns all the
characters in the stream. CHORD.WAV has about 25000 characters.</para>
</section>

<section id="readtextfileatime"><title>Reading Text Files a Character at a Time</title>
<indexterm><primary>reading</primary>
<secondary>a text file, one character at a time</secondary></indexterm>
<indexterm><primary>binary files</primary>
<secondary>reading</secondary></indexterm>
<indexterm><primary>text files</primary>
<secondary>reading a character at a time</secondary></indexterm>
<para>You can use the CHARIN and other character methods on text files. Because
you read the file as characters, CHARIN returns the
<indexterm><primary>line-end characters</primary></indexterm>
line-end characters to your program.
Line methods, on the contrary, do not return the line-end characters to your
program. Object Rexx adds line-end characters to the end of every
line written using the LINEOUT method. Text-processing applications,
such as the Windows Notepad, also add line-end characters.
As a convenience, Object Rexx has an environment symbol name .ENDOFLINE
that contains the line-end characters used by the Stream class
on the current system. When reading a text file with CHARIN,
interpret the character sequence in .ENDOFLINE as the end of a line.
</para>
<para>As an example, run the following program. It writes lines to a file using
LINEOUT and then reads those lines using CHARIN. You can mix line methods
and character methods. Object Rexx maintains separate read and write pointers, so
there is no need to close the file or search for another position before reading
the lines just written.</para>
<example>
<title>LINECHAR.CMD</title>
<programlisting>
<![CDATA[
/* LINECHAR.CMD - demonstrate line end characters                   */
file=.stream~new("test.dat")  /* Create a new stream object         */

file~open("both replace")  /* Open the file for reading and writing */
do i=1 to 3                /* Write three lines to the file         */
   file~lineout("Line" i)
end /* do */

do while file~chars<>0     /* Read the file a character at a time   */
   byte=file~charin        /* Read a character                      */
   ascii_value=byte~c2d    /* Convert character to a decimal value  */
   if ascii_value=13 then        /* Carriage return?                */
      say "Carriage return"
   else if ascii_value=10 then   /* Line feed?                      */
      say "Line feed"
   else say byte ascii_value     /* Ordinary character              */
end /* do */
file~close                       /* Close the file                  */
]]>
</programlisting>
</example>
<para>It is not recommended to use line methods to read binary files. Your binary
file might not contain any new-line characters. And, if it did, the characters
probably are not meant to be interpreted as new-line characters.</para>
</section>

<section id="writebinaryfiles"><title>Writing Binary Files</title>
<indexterm><primary>writing</primary>
<secondary>binary files</secondary></indexterm>
<indexterm><primary>binary files</primary>
<secondary>writing</secondary></indexterm>
<para>To write a binary file, you use CHAROUT.
CHAROUT writes only the characters that you specify in an argument of the
method. CHAROUT does not add line-end
characters to
the end of the string. Here is an example:</para>
<example>
<title>JACK.CMD</title>
<programlisting>
<![CDATA[
/* JACK.CMD - demonstrate that CHAROUT does not add line-end characters */
filebin=.stream~new("binary.dat")   /* Create a new stream object       */
filebin~open("replace")             /* Open the file for replacement    */
do i=1 to 50                        /* Write fifty strings              */
  filebin~charout("All work and no play makes Jack a dull boy. ")
end
filebin~close                  /* Close the file so we can display it   */
"type binary.dat"              /* Use the TYPE command to display file  */
]]>
</programlisting>
</example>
<para>Because line-end characters are not added, the text displayed
by the TYPE command is concatenated into one contiguous line.</para>
<para>CHAROUT writes the string specified and advances the write pointer. If
you want to position the write pointer before writing the string, specify
the starting position as a second argument:</para>
<programlisting>
<![CDATA[
filebin~charout("Jack is loosing it.",30) /* start writing at character 30 */
]]>
</programlisting>
<para>In the example, the file is explicitly opened and closed. If
you do not open the file, Object Rexx attempts to open the file for both reading
and writing. If you do not close the file, Object Rexx closes it when the procedure
ends.
</para>
</section>

<section id="closefiles"><title>Closing Files</title>
<indexterm><primary>closing files</primary></indexterm>
<indexterm><primary>binary files</primary>
<secondary>closing</secondary></indexterm>
<indexterm><primary>text files</primary>
<secondary>closing</secondary></indexterm>
<para>If
you do not explicitly close a file, Object Rexx closes the file when the Stream object
is reclaimed by the garbage collector.  This frequently does not occur until
your program exits, so it is good practice to
explicitly close
files when you are finished with them.</para>
</section>

<section id="directfileaccess"><title>Direct File Access</title>
<indexterm><primary>direct file access</primary></indexterm>
<indexterm><primary>binary files</primary>
<secondary>direct access</secondary></indexterm>
<indexterm><primary>text files</primary>
<secondary>direct access</secondary></indexterm>
<para>Object Rexx provides several ways for you to read records
of a file directly (that is, in random order). The following example,
DIRECT.CMD, shows several cases that illustrate some of your options.</para>
<para>DIRECT opens a file for both reading and writing, which is indicated
by the BOTH argument of the OPEN method. The REPLACE argument of the OPEN
method causes any existing DIRECT.DAT file to be replaced.</para>
<para>The OPEN method also has the arguments BINARY and RECLENGTH, which are
useful for direct file access.</para>
<para>The BINARY argument opens the stream in binary mode, which means that line-end
characters are ignored. Binary mode is useful if you want to process binary
data using line methods. It is easier to use line methods for direct access.
With line methods, you can search a position in a file using line numbers.
With character methods, you must calculate the character displacement of
the file.</para>
<para>The RECLENGTH argument defines a record length of 50 for the file. It enables
you to use line methods in a binary-mode stream. Because Object Rexx now knows how
long each record is, it can calculate the displacement of the file for a given
record number and read the record directly.</para>
<example>
<title>DIRECT.CMD</title>
<programlisting>
<![CDATA[
/* DIRECT.CMD - demonstration of direct file access       */
db=.stream~new("direct.dat")
db~open("both replace binary reclength 50")

/* Write three records of 50 bytes each using LINEOUT     */
db~lineout("Cole, Gary:  Blue")
db~lineout("McGuire, Rick: Red")
db~lineout("Pritko, Steve: Red. Oops.. I mean blue!")

/* Case 1: Read the records in order using LINEIN.        */
say "Case 1: Sequential reads with LINEIN..."
do i=1 to 3
   say db~linein
end
say "Press Enter to continue"; parse pull resp

/* Case 2: Read records in random order using LINEIN      */
say "Case 2: Random reads with LINEIN..."
do i=1 to 5
   lineno=random(1,3)
   say "Record" lineno "=" db~linein(lineno)
end
say "Press Enter to continue"; parse pull resp

/* Case 3: Read entire file with CHARIN                   */
say "Case 3: Read entire file with a single CHARIN..."
say db~charin(1,150)
say "Press Enter to continue"; parse pull resp

/* Case 4: Read file sequentially with CHARIN             */
say "Case 4: Sequential reads with CHARIN..."
db~seek(1 read)         /* Reposition read pointer        */
do i=1 to 3
   say db~charin(,50)
end
say "Press Enter to continue"; parse pull resp

/* Case 5: Read records in random order with CHARIN       */
say "Case 5: Random reads with CHARIN..."
do i=1 to 5
   lineno=random(1,3)
   charno=((lineno-1)*50)+1
   say "Record" lineno "Character" charno "=" db~charin(charno,50)
end
say "Press Enter to continue"; parse pull resp

/* Case 6: Write records in random order with LINEOUT     */
say "Case 6: Replace record 2 with LINEOUT"
db~lineout("This should replace line 2",2)
do i=1 to 3
   say db~linein(i)
end
say "Press Enter to continue"; parse pull resp

/* Case 7: Write records in random order with CHAROUT     */
say "Case 7: Replace record 2 with CHARIN..."
db~charout("New record 2 from CHAROUT"~left(50,"."),51)
db~seek(1 read)         /* Reposition read pointer        */
do i=1 to 3
   say db~charin(,50)
end
say "Press Enter to continue"; parse pull resp
db~close
]]>
</programlisting>
</example>
<para>After opening the file, DIRECT writes three records using LINEOUT. The records are
not padded to 50 characters, Object Rexx itself handles that. Because the file is opened
in binary mode, Object Rexx does not write line-end characters at the end of each
line. It only writes the strings one after another to the stream.</para>
<para>In Case 1, the LINEIN method is used to read the file. Because the file
is open in binary mode, LINEIN does not look for line-end characters to mark
the end of a line. Instead, it relies on the record length that you specify
on open. In fact, if there were a carriage-return or line-feed sequence of
the line, Object Rexx would return those characters to your program.</para>
<para>Case 2 demonstrates how to read the file in random order. In this case,
the RANDOM function is used to choose a record to be retrieved. Then the desired
record number is specified as an argument on LINEIN. Note that records are
numbered starting from 1, not from 0. Because the file is opened in binary
mode, Object Rexx does not look for line-end characters.  It uses the RECLENGTH value to
determine where to begin reading. The LINEIN method can, therefore, retrieve a line
directly, without having to scan through the file counting line-end characters.</para>
<para>Case 3 proves that no line-end characters exist in the file. The CHARIN
method reads the entire file. SAY displays the returned string as one long
string. If Object Rexx inserted line-end characters, each record would be displayed
on a separate line.</para>
<para>Case 4 shows how to read the binary mode file sequentially using CHARIN.
But before reading the file, the read pointer must be reset to the beginning
of the file. (Case 3 leaves the read pointer at the end of the file.) The
SEEK method resets the read pointer to character 1, which is the beginning
of the file. As with lines, Object Rexx numbers characters starting with 1, not 0.
Position 1 is the first character of the file.</para>
<para>By default, the number specified with SEEK refers to a character position.
You can also search by line number or by offsets. SEEK allows offsets from
the current read or write position (a relative position), or from the beginning
or ending of the file (an absolute position).
If you prefer typing longer method names, you can use POSITION as a
synonym for SEEK.</para>
<para>In the loop of Case 4, the first argument on CHARIN is omitted. The first
argument tells where to position the read pointer. If it is omitted, Object Rexx
automatically advances the read pointer based on the number of characters
you are reading.</para>
<para>Case 5 demonstrates how to read records in random order with CHARIN. In
the loop, a random record number is selected and assigned to the variable
<computeroutput>lineno</computeroutput>. This record number is
then converted to a character number,
which can be used to specify the read position on CHARIN. Compare Case 5 with
Case 2. In Case 2, which uses line methods, it is not necessary to perform
a calculation, you just request the record you want.</para>
<para>Cases 6 and 7 write records in random order. Case 6 uses LINEOUT, while
Case 7 uses CHAROUT. Because the file is opened in binary mode, LINEOUT does
not write line-end characters. You can write over a line by specifying a line
number. With CHAROUT, you need to calculate the character position of the
line to be replaced. Unlike LINEOUT, you need to ensure that the string being
written with CHAROUT is padded to the appropriate record length. Otherwise,
part of the record being replaced remains in the file.</para>
<para>Consequently, for random reading of files with fixed length records, line
methods are often the better choice. However, one limitation of the line methods
is that you cannot use them to write sparse records. That is, if a file already
has 200 records, you can use LINEOUT to write record 201, but you cannot use
LINEOUT to write record 300. With CHAROUT, however, you can open a new file
and start writing at character position 5000 if you choose.</para>
</section>

<section id="checkfileexistence"><title>Checking for the Existence of a File</title>
<indexterm><primary>checking for the existence of a file</primary></indexterm>
<indexterm><primary>binary files</primary>
<secondary>querying existence</secondary></indexterm>
<indexterm><primary>text files</primary>
<secondary>querying existence</secondary></indexterm>
<para>To check for the existence of a file, you use the
QUERY method of the Stream class. The following ISTHERE.CMD program
accepts a file name as a command line argument and checks for the existence
of that file.</para>
<example>
<title>ISTHERE.CMD</title>
<programlisting>
<![CDATA[
/* ISTHERE.CMD - test for the existence of a file        */
parse arg fid                    /* Get the file name    */
qfile=.stream~new(fid)           /* Create stream object */
if qfile~query("exists")="" then /* Check for existence  */
   say fid "does not exist."
else
   say fid "exists."
]]>
</programlisting>
</example>
<para>In the example, a stream object is created for the file even though it
might not exist. This is acceptable because the file is not opened when the
stream object is created.</para>
<para>The QUERY method accepts one argument. To check for the existence of a
file, you specify the string <computeroutput>"exists"</computeroutput> as
previously shown. If the file exists, QUERY returns the full-path specification
of the stream object. Otherwise, QUERY returns a null string.</para>
</section>

<section id="getotherfileinfo"><title>Getting Other Information about a File</title>
<indexterm><primary>querying a file</primary></indexterm>
<indexterm><primary>binary files</primary>
<secondary>querying other information</secondary></indexterm>
<indexterm><primary>text files</primary>
<secondary>querying other information</secondary></indexterm>
<para>The QUERY method can also return date and time stamps,
read position, write position, the size of the file, and so on. The following
example shows most of the QUERY arguments.</para>
<example>
<title>INFOON.CMD</title>
<programlisting>
<![CDATA[
/* INFOON.CMD - display information about a file */
parse arg fid
qfile=.stream~new(fid)
fullpath=qfile~query("exists")
if fullpath="" then do
   say fid "does not exist."
   exit
end
qfile~open("both")
say ""
say "Full path name:" fullpath
say "Date and time stamps (U.S. format):" qfile~query("datetime")
say "            (International format):" qfile~query("timestamp")
say ""
say "Handle associated with stream:" qfile~query("handle")
say "                  Stream type:" qfile~query("streamtype")
say ""
say "          Size of the file (characters):" qfile~query("size")
say " Read position (in terms of characters):" qfile~query("seek read")
say "Write position (in terms of characters):" qfile~query("seek write")
qfile~close
]]>
</programlisting>
</example>
</section>

<section id="standardio"><title>Using Standard I/O</title>
<indexterm><primary>I/O, standard (keyboard, displays, and error streams)</primary></indexterm>
<indexterm><primary>standard I/O (keyboard, displays, and error streams)</primary></indexterm>
<para>All of the preceding topics dealt with the reading and writing of files.
You can use the same methods to read from standard input (usually the keyboard)
and to write to standard output (usually the display). You can also use the
methods to write to the standard error stream. In Object Rexx, these default
streams are represented by public objects of the Monitor class: .input,
.output, and .error.</para>
<para>The streams STDIN, STDOUT, and STDERR are transient streams. For transient
streams, you cannot use any method or method argument for positioning the
read and write pointers. You cannot, for example, use the SEEK method on
STDOUT.</para>
<para>Writing to STDOUT has the same effect as using the SAY instruction. However,
the SAY instruction always writes line-end characters at the end of the string.
By using the CHAROUT method to write to STDOUT, you can control when line-end
characters are written.</para>
<para>The following example shows a modified COUNT program previously shown in
<xref linkend="readtxtfile" />. COUNT has been modified
to display a progress indicator. For every line processed, COUNT now uses
CHAROUT to display a single period. COUNT does not write any line-end
characters, so the periods wrap to the next line when they reach the end of
the line in the Windows window.</para>
<example>
<title>Modified COUNT.CMD</title>
<programlisting>
<![CDATA[
                            /* count counts the words in a file */
parse arg path                          /* Get the file name    */
count=0                                 /* Initialize the count */
file=.stream~new(path)        /* Create a stream object for the input file */
do while file~lines<>0        /* Process each line of the file */
   text=file~linein           /* Read a line                   */
   count=count+(text~words)   /* Count blank-delimited tokens  */
   .output~charout(".")       /* Write period to STDOUT        */
end
say ""
say count
]]>
</programlisting>
</example>
<para>Reading from STDIN using LINEIN is similar to reading with the PARSE PULL
instruction:</para>
<example>
<title>INEXAM.CMD</title>
<programlisting>
<![CDATA[
/* INEXAM.CMD - example of reading STDIN with LINEIN  */

/* Prompt for input with SAY and PARSE instructions   */
say "What is your name?"
parse pull response
say "Hi" response
say ""

/* Now prompt using LINEOUT and LINEIN                */
.output~lineout("What is your name?")
response=.input~linein
.output~lineout("Hi" response)
]]>
</programlisting>
</example>
<para>Using character methods with STDIN and STDOUT gives you more control over
the reading and writing of line-end characters. In the following example,
the prompting string is written to STDOUT using CHAROUT. Because CHAROUT does
not add any line-end characters to the stream, the display cursor is positioned
after the prompt string on the same line.</para>
<example>
<title>INCHAR.CMD</title>
<programlisting>
<![CDATA[
/* INCHAR.CMD - example of reading STDIN with CHARIN  */
.output~charout("What is your name? ")
response=.input~charin(,10)
.output~charout("Hi" response)
]]>
</programlisting>
</example>
<para>CHARIN is used to read the user's response. The user's keystrokes
are not returned to your program until the user presses the Enter key. In
the example, a length of 10 is specified. If fewer characters than the specified
length are available, CHARIN waits until they become available. Otherwise,
the characters are returned to your program. CHARIN does not strip any carriage-return
or line-feed characters before returning the string to your program. You can
observe this with INCHAR by typing several strings that have less than ten
characters and pressing Enter after each string:</para>
<programlisting>
<![CDATA[
[C:\]inchar
What is your name? John
Q.
Public
Hi John
Q.
Pu
]]>
</programlisting>
</section>

<section id="usedevice"><title>Using Windows Devices</title>
<indexterm><primary>devices, sending information to</primary></indexterm>
<para>You can use Windows
devices by substituting a device name (such as PRN, LPT1, LPT2, COM1, and
so on) for the file name when you create a stream object. Then use line or
character methods to read or write the device.</para>
<para>The following example sends data to a printer (device name PRN in the example).
In addition to sending text data, the example also sends a control character
for starting a new page. You can send other control characters or escape sequences
in a similar manner. (Generally, these are listed in the manual for the device.)</para>
<para>Usually the control characters are characters that you cannot type at the
keyboard. To use them in your program, send a D2C message to the character's
ASCII value as shown in the example.</para>
<example>
<title>PRINTIT.CMD</title>
<programlisting>
<![CDATA[
/* PRINTIT.CMD - Prints a text file                                    */
say "Type file name: "           /* prompt for a file name */
pull filename                    /* ...and get it from the user        */
infile=.stream~new(filename)
printer=.stream~new("prn:")

newpage = 12~d2c                  /* save page-eject character         */

/* Repeat this loop until no lines remain in the file */
/* and keep track of the line count with COUNT        */

do count = 1 until filename~lines = 0
   if printer~lineout(infile~linein) <> 0 then do
      say "Error: unable to write to printer"
      leave
   end
   if count // 50 = 0 then                 /* if the line count is a */
      printer~charout(newpage)             /* multiple of 50, then   */
                                           /* start a new page by    */
                                           /* sending the form feed  */

end                               /* go back to the start of loop    */
                                  /* until no lines remain           */

infile~close                      /* close the file                  */
exit                              /* end the program normally        */
]]>
</programlisting>
</example>
</section>
</chapter>
