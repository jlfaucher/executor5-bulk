<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "rexxpg.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: Programming Guide XML file.
    #
    # Copyright (c) 2005-2019, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<chapter id="provide"><title>The Basics of Classes</title>
<para>Similar objects in Rexx are grouped into classes, forming a hierarchy.
Rexx gives you a basic class hierarchy to start with. All of the classes in
the hierarchy are described in detail in the
<citetitle pubwork="book">Open Object Rexx: Reference</citetitle>.
</para>
<para>Rexx provides the following classes belonging to the
<classname>Object</classname> class.
</para>
<para>The classes are in a class hierarchy with an inheriting class indented below its
superclass or mixin class.
Classes inheriting from multiple mixin classes are only listed below one of these mixin classes.
</para>
<para>
  <!-- commented ArgUtil (deprecated, won't document) -->
  <!-- $GENERATED-20190301-START rexxrefClassHierarchy rexxpg -->
  <simplelist>
  <member>Alarm</member>
  <member>AlarmNotification</member>
<!--
  <member>ArgUtil</member>
-->
  <member>Buffer</member>
  <member>Class</member>
  <member>Collection</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MapCollection</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bag</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Directory</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Properties</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IdentityTable</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relation</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stem</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTable</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Table</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OrderedCollection</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CircularQueue</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetCollection</member>
  <member>Comparable</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DateTime</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimeSpan</member>
  <member>Comparator</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CaselessColumnComparator</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CaselessComparator</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CaselessDescendingComparator</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ColumnComparator</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DescendingComparator</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InvertingComparator</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NumericComparator</member>
  <member>InputStream</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputOutputStream</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream</member>
  <member>MessageNotification</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Message</member>
  <member>Method</member>
  <member>Monitor</member>
  <member>MutableBuffer</member>
  <member>Object</member>
  <member>Orderable</member>
  <member>OutputStream</member>
  <member>Package</member>
  <member>Pointer</member>
  <member>RexxContext</member>
  <member>RexxInfo</member>
  <member>RexxQueue</member>
  <member>Routine</member>
  <member>StackFrame</member>
  <member>Supplier</member>
  <member>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StreamSupplier</member>
  <member>Ticker</member>
  <member>Validate</member>
  <member>VariableReference</member>
  <member>WeakReference</member>
  </simplelist>
  <!-- $GENERATED-20190301-END rexxrefClassHierarchy rexxpg -->
</para>
<para>Note that there might also be other classes available, depending
on the operating system.
</para>

<section id="progcl"><title>Rexx Classes for Programming</title>
<para>The classes Rexx supplies provide the starting point for object-oriented
programming. Some key classes that you are likely to work with are described
in the following sections.</para>

<section id="clsAlarm"><title>The Alarm Class</title>
<indexterm><primary>classes</primary>
<secondary>Alarm class</secondary></indexterm>
<para>The Alarm class is used to create objects with timing and notification capability.
An alarm object is able to send a message to an object at any time in the
future, and until then, you can cancel the alarm.</para>
</section>

<section id="clsAlarmNotification" revisionflag="added"><title>&added50;AlarmNotification Class</title>
<indexterm><primary>classes</primary><secondary>AlarmNotification class</secondary></indexterm>
<para>Implements the notification interface for the
<xref linkend="clsAlarm" xrefstyle="template:Alarm"/> class.
</para>
</section>

<section id="buffercl"><title>The Buffer Class</title>
<indexterm><primary>classes</primary>
<secondary>Buffer class</secondary></indexterm>
<para>A Buffer instance is a Rexx interpreter managed block of storage.
This class is designed primarily for writing methods and functions in native code
and can only be created using the native code application programming interfaces.</para>
</section>

<section id="caselesscolumncomparatorcl"><title>The CaselessColumnComparator Class</title>
<indexterm><primary>classes</primary>
<secondary>CaselessColumnComparator class</secondary></indexterm>
<para>The CaselessColumnComparator class performs caseless orderings of specific substrings
of String objects.
</para>
</section>

<section id="caselesscomparatorcl"><title>The CaselessComparator Class</title>
<indexterm><primary>classes</primary>
<secondary>CaselessComparator class</secondary></indexterm>
<para>The CaselessComparator class performs caseless orderings of String objects.
</para>
</section>

<section id="caselessdescendingcomparatorcl"><title>The CaselessDescendingComparator Class</title>
<indexterm><primary>classes</primary>
<secondary>CaselessDescendingComparator class</secondary></indexterm>
<para>The CaselessDescendingComparator class performs caseless string sort orderings in descending order.
This is the inverse of a CaselessComparator sort order.
</para>
</section>

<section id="colcl"><title>The Collection Classes</title>
<indexterm><primary>classes</primary>
<secondary>Collection class</secondary></indexterm>
<para>The collection classes are
used to manipulate collections of objects. A collection is an object that
contains a number of <emphasis role="italic">items</emphasis>, which can be
any objects. These manipulations might include counting objects, organizing
them, or assigning them a supplier (for example, to indicate that a specific
assortment of baked goods is supplied by the Pie-by-Night Bakery).</para>
<para>Rexx includes classes, for example, for arrays, lists, queues, tables,
and directories. Each item stored in a Rexx collection has an associated index
that you can use to retrieve the item from the collection with the AT or []
(left and right bracket) methods, and each collection defines its own acceptable
index types: </para>
<variablelist>

<varlistentry><term>Array</term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Array class</secondary></indexterm>
<para>A sequenced collection of objects ordered by whole-number indexes.
</para></listitem></varlistentry>

<varlistentry><term>Bag</term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Bag class</secondary></indexterm>
<para>A collection where the index is equal to the value. Bag indexes can
be any object (as with the Table class) and each index can appear more than
once.
</para></listitem></varlistentry>

<varlistentry><term>CircularQueue</term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>CircularQueue class</secondary></indexterm>
<para>The CircularQueue class allows for storing objects in a circular queue
of a predefined size. Once the end of the queue has been reached, new item objects are
inserted from the beginning, replacing earlier entries. Any object can be placed in the
queue and the same object can occupy more than one position in the queue.
</para></listitem></varlistentry>

<varlistentry><term>Directory</term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Directory class</secondary></indexterm>
<para>A collection of character string indexes. Indexes are compared using
the string == comparison method to test for strict equality.
</para></listitem></varlistentry>

<varlistentry><term>IdentityTable</term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>IdentityTable class</secondary></indexterm>
<para>An identity table is a collection with indexes that can be any object.
In an identity table, each item is associated with a single index, and there can be only
one item for each index. Index and item matches in an identity table are made using an
object identity comparison. That is, an index will only match if the same instance is
used in the collection.
</para></listitem></varlistentry>

<varlistentry><term>List</term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>List class</secondary></indexterm>
<para>A sequenced collection that lets you add new items at any position in
the sequence. A list generates and returns an index value for each item placed
in the list. The returned index remains valid until the item is removed from
the list.
</para></listitem></varlistentry>

<varlistentry><term>Properties</term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Properties class</secondary></indexterm>
<para>A properties object is a collection with unique indexes that are character
strings representing names and items that are also restricted to character string values.
Properties objects are useful for processing bundles of application option values.
</para></listitem></varlistentry>

<varlistentry><term>Queue</term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Queue class</secondary></indexterm>
<para>A sequenced collection of items ordered as a queue. You can remove items
from the head of the queue and add items at either its tail or its head. Queues
index the items with whole-number indexes, in the order in which the items
would be removed. The current head of the queue has index 1, the item after
the head item has index 2, up to the number of items in the queue.
</para></listitem></varlistentry>

<varlistentry><term>Relation</term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Relation class</secondary></indexterm>
<para>A collection of indexes that can be any object (as with the Table class).
A relation can contain duplicate indexes.
</para></listitem></varlistentry>

<varlistentry><term>Set</term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Set class</secondary></indexterm>
<para>A collection where the indexes are equal to the values. Set indexes
can be any object (as with the Table class) and each index is unique.
</para></listitem></varlistentry>

<varlistentry><term>Stem</term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Stem class</secondary></indexterm>
<para>A stem object is a collection with unique indexes that are character strings.
</para></listitem></varlistentry>

<varlistentry><term>StringTable</term>
<listitem>
<indexterm><primary>classes</primary><secondary>StringTable class</secondary></indexterm>
<para>A collection using unique character string indexes.
The items of a StringTable can be any valid Rexx object.
</para></listitem></varlistentry>

<varlistentry><term>Table</term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Table class</secondary></indexterm>
<para>A collection of indexes that can be any object. For example, string
objects, array objects, alarm objects, or any user-created object can be a
table index.  The Table class determines an index match by using the == comparison
method to test for strict equality. A table contains no duplicate indexes.
</para></listitem></varlistentry>

</variablelist>
</section>

<section id="columncomparatorcl"><title>The ColumnComparator Class</title>
<indexterm><primary>classes</primary>
<secondary>ColumnComparator class</secondary></indexterm>
<para>The ColumnComparator class performs orderings based on specific substrings of String objects.
</para>
</section>

<section id="comparablecl"><title>The Comparable Class</title>
<indexterm><primary>classes</primary>
<secondary>Comparable class</secondary></indexterm>
<para>Any object that inherits the Comparable mixin class and implements a compareTo()
method can be sorted. The DateTime Class and TimeSpan Class are examples of built-in
Rexx classes that can be sorted. Any user created class may also implement a compareTo()
method to enable sorting.
</para>
</section>

<section id="comparatorcl"><title>The Comparator Class</title>
<indexterm><primary>classes</primary>
<secondary>Comparator class</secondary></indexterm>
<para>The Comparator class is the base class for implementing Comparator objects that can
be used with the Array sortWith() or stableSortWith() method. The compare() method implements
some form of comparison that determines the relative ordering of two objects. Many Comparator
implementations are specific to particular object types.
</para>
</section>

<section id="datetimecl"><title>The DateTime Class</title>
<indexterm><primary>classes</primary>
<secondary>DateTime class</secondary></indexterm>
<para>A DateTime object represents a point in between 1 January 0001 at 00:00.000000 and 31 December
9999 at 23:59:59.999999. A DateTime object has methods to allow formatting a date or time in various
formats, as well as allowing arithmetic operations between dates.
</para>
</section>

<section id="descendingcomparatorcl"><title>The DescendingComparator Class</title>
<indexterm><primary>classes</primary>
<secondary>DescendingComparator class</secondary></indexterm>
<para>The DescendingComparator class performs sort orderings in descending order.
This is the inverse of a Comparator sort order.
</para>
</section>

<section id="filecl"><title>The File Class</title>
<indexterm><primary>classes</primary>
<secondary>File class</secondary></indexterm>
<para>The File class provides services which are common to all the filesystems supported by ooRexx.
A File object represents a path to a file or directory. The path can be relative or absolute.
</para>
</section>

<section id="inputoutputstreamcl"><title>The InputOutputStream Class</title>
<indexterm><primary>classes</primary>
<secondary>InputOutputStream class</secondary></indexterm>
<para>This class is defined as an abstract mixin class. It must be implemented by subclassing it
or inheriting from it as a mixin. Many of the methods in this class are abstract and must be overridden
or they will throw a syntax error when invoked.
</para>
</section>

<section id="inputstreamcl"><title>The InputStream Class</title>
<indexterm><primary>classes</primary>
<secondary>InputStream class</secondary></indexterm>
<para>This class is defined as an abstract mixin class. It must be implemented by subclassing it
or inheriting from it as a mixin. Many of the methods in this class are abstract and must be overridden
or they will throw a syntax error when invoked.
</para>
</section>

<section id="invertingcomparatorcl"><title>The InvertingComparator Class</title>
<indexterm><primary>classes</primary>
<secondary>InvertingComparator class</secondary></indexterm>
<para>The InvertingComparator class inverts the comparison results of another
Comparator object to reverse the resulting sort order.
</para>
</section>

<section id="msgcl"><title>The Message Class</title>
<indexterm><primary>classes</primary>
<secondary>Message class</secondary></indexterm>
<para>Message objects allow you to run concurrently methods on other threads or to
invoke dynamically calculated messages.
Methods of
for this class are used, for example, to start a message on another thread, to notify the sender
object when an error occurs or when message processing is complete, or to return
the results of that processing to the sender or to some other object.
</para>
</section>

<section id="methodcl"><title>The Method Class</title>
<indexterm><primary>classes</primary>
<secondary>Method class</secondary></indexterm>
<para>The Method class creates method objects from Rexx source code.
</para>
</section>

<section id="moncl"><title>The Monitor Class</title>
<indexterm><primary>classes</primary>
<secondary>Monitor class</secondary></indexterm>
<para>The Monitor class provides a way to forward messages to a specified destination.
The Monitor creates a proxy that can dynamically route messages to different destinations.
Monitor methods change or restore a destination object.
</para>
</section>

<section id="mutablebuffercl"><title>The MutableBuffer Class</title>
<indexterm><primary>classes</primary>
<secondary>MutableBuffer class</secondary></indexterm>
<para>The MutableBuffer class is a buffer on which certain string operations such as concatenation can be
performed very efficiently. Unlike String objects, MutableBuffers can be altered without requiring a new
object allocation. A MutableBuffer object can provide better performance for algorithms that involve
frequent concatenations to build up longer string objects because it creates fewer intermediate objects.
</para>
</section>

<section id="outputstreamcl"><title>The OutputStream Class</title>
<indexterm><primary>classes</primary>
<secondary>OutputStream class</secondary></indexterm>
<para>This class is defined as an abstract mixin class. It must be implemented by subclassing it or inheriting
from it as a mixin. Many of the methods in this class are abstract and must be overridden or they will
throw a syntax error when invoked.
</para>
</section>

<section id="numericcomparatorcl"><title>The NumericComparator Class</title>
<indexterm><primary>classes</primary>
<secondary>NumericComparator class</secondary></indexterm>
<para>The NumericComparator class compares strings using numeric comparison rules to
determine sort order.
</para>
</section>

<section id="orderablecl"><title>The Orderable Class</title>
<indexterm><primary>classes</primary>
<secondary>Orderable class</secondary></indexterm>
<para>The Orderable class can be inherited by classes which wish to provide each of the comparison operator
methods without needing to implement each of the individual methods. The inheriting class need only
implement the Comparable compareTo() method. This class is defined as a mixin class.
</para>
</section>

<section id="packagecl"><title>The Package Class</title>
<indexterm><primary>classes</primary>
<secondary>Package class</secondary></indexterm>
<para>The Package class contains the source code for a package of Rexx code. A package instance holds all of
the routines, classes, and methods created from a source code unit and also manages external
dependencies referenced by ::REQUIRES directives. The files loaded by ::REQUIRES are also
contained in Package class instances.
</para>
</section>

<section id="pointercl"><title>The Pointer Class</title>
<indexterm><primary>classes</primary>
<secondary>Pointer class</secondary></indexterm>
<para>A Pointer instance is a wrapper around a native pointer value.
This class is designed primarily for writing methods and functions in native code and
can only be created using the native code application programming interfaces.
The Pointer class new method will raise an error if invoked.
</para>
</section>

<section id="regularexpressioncl"><title>The RegularExpression Class</title>
<indexterm><primary>classes</primary>
<secondary>RegularExpression class</secondary></indexterm>
<para>This class provides support for regular expressions.
A regular expression is a pattern you can use to match strings.
</para>
</section>

<section id="rexxcontextcl"><title>The RexxContext Class</title>
<indexterm><primary>classes</primary>
<secondary>RexxContext class</secondary></indexterm>
<para>The RexxContext class gives access to context information about the currently executing Rexx code.
Instances of the RexxContext class can only be obtained via the .CONTEXT environment symbol. They
cannot be directly created by the user.
</para>
</section>

<section id="rexxqueuecl"><title>The RexxQueue Class</title>
<indexterm><primary>classes</primary>
<secondary>RexxQueue class</secondary></indexterm>
<para>The RexxQueue class provides object-style access to Rexx external data queues.
</para>
</section>

<section id="routinecl"><title>The Routine Class</title>
<indexterm><primary>classes</primary>
<secondary>Routine class</secondary></indexterm>
<para>The Routine class creates routine objects from Rexx source code.
</para>
</section>

<section id="stackframecl"><title>The StackFrame Class</title>
<indexterm><primary>classes</primary>
<secondary>StackFrame class</secondary></indexterm>
<para>The StackFrame class provides debugging information about a Rexx activity's execution chain.
</para>
</section>

<section id="stemcl"><title>The Stem Class</title>
<indexterm><primary>classes</primary>
<secondary>Stem class</secondary></indexterm>
<para>A stem variable is a symbol that
must start with a letter and end with a period, like &quot;FRED.&quot; or &quot;A.&quot;.
The value of a stem variable is a Stem <emphasis role="italic">object</emphasis>. A stem object is a collection
of unique character string indexes. Stem objects are automatically
created when a Rexx stem variable or Rexx compound variable is used. In addition
to the items assigned to the collection indexes, a stem object also has a
default value that is used for all uninitialized indexes of the collection.
</para>
</section>

<section id="streacl"><title>The Stream Class</title>
<indexterm><primary>classes</primary>
<secondary>Stream class</secondary></indexterm>
<para>Input and output streams
let Rexx communicate with external objects, such as people, files, queues,
serial interfaces, displays, and networks. In programming there are many stream
actions that can be coded as methods for manipulating the various stream objects.
These methods and objects are organized in the Stream class.</para>
<para>The methods are used to open streams for reading or writing, close streams
at the end of an operation, move the line-read or line-write position within
a file stream, or get information about a stream. Methods are also provided
to get character strings from a stream or send them to a stream, count characters
in a stream, flush buffered data to a stream, query path specifications, time
stamps, size, and other information from a stream, or do any other I/O stream
manipulation (see <xref linkend="rexio" /> for examples).</para>
</section>

<section id="streamsuppliercl"><title>The StreamSupplier Class</title>
<indexterm><primary>classes</primary>
<secondary>StreamSupplier class</secondary></indexterm>
<para>A subclass of the Supplier class that will provide stream lines using
supplier semantics. This allows the programmer to iterate over the remaining
lines in a stream. A StreamSupplier object provides a snapshot of the stream
at the point in time it is created, including the current line read position.
In general, the iteration is not affected by later changes to the read and
write positioning of the stream. However, forces external to the iteration may
change the content of the remaining lines as the iteration progresses.
</para>
</section>

<section id="strincl"><title>The String Class</title>
<indexterm><primary>strings</primary></indexterm>
<indexterm><primary>classes</primary>
<secondary>String class</secondary></indexterm>
<para>Strings are data values that can have
any length and contain any characters. They are subject to logical operations
like AND, OR, exclusive OR, and logical NOT. Strings can be concatenated,
copied, reversed, joined, and split. When strings are numeric, there is the
need to perform arithmetic operations on them or find their absolute value
or convert them from binary to hexadecimal, and vice versa. All this and more
can be accomplished using the String class of objects.</para>
</section>

<section id="supplcl"><title>The Supplier Class</title>
<indexterm><primary>classes</primary>
<secondary>Supplier class</secondary></indexterm>
<para>All collections have suppliers. The Supplier class is used to enumerate
items that a collection contained when the supplier was created. The supplier
gives access to each index/value pair stored in the collection as a sequence.
</para>
</section>

<section id="clsTicker" revisionflag="added"><title>&added50;Ticker Class</title>
<indexterm><primary>class</primary><secondary>Ticker class</secondary></indexterm>
<para>Provides a repeating notification capability by sending a
notification message to a notification target each trigger interval.
</para>
</section>

<section id="timespancl"><title>The TimeSpan Class</title>
<indexterm><primary>classes</primary>
<secondary>TimeSpan class</secondary></indexterm>
<para>A TimeSpan object represents a point in between 1 January 0001 at 00:00.000000 and 31 December
9999 at 23:59:59.999999. A TimeSpan object has methods to allow formatting a date or time in various
formats, as well as allowing arithmetic operations between dates.
</para>
</section>

<section id="clsValidate" revisionflag="added"><title>&added50;Validate Class</title>
<indexterm><primary>classes</primary><secondary>Validate class</secondary></indexterm>
<para>A class that provides helper methods
to validate arguments being of correct class, logical or numeric type,
or within a numeric range.
</para>
</section>

<section id="clsVariableReference" revisionflag="added"><title>&added50;VariableReference Class</title>
<indexterm><primary>classes</primary><secondary>VariableReference class</secondary></indexterm>
<para>A object that maintains a reference to another object.
</para>
</section>

<section id="weakreferencecl"><title>The WeakReference Class</title>
<indexterm><primary>classes</primary>
<secondary>WeakReference class</secondary></indexterm>
<para>A WeakReference instance maintains a non-pinning reference to another object. A non-pinning reference
does not prevent an object from getting garbage collected or having its uninit method run when there are
no longer normal references maintained to the object. Once the referenced object is eligible for garbage
collection, the reference inside the WeakReference instance will be cleared and the VALUE method will
return .nil on all subsequent calls. WeakReferences are useful for maintaining caches of objects without
preventing the objects from being reclaimed by the garbage collector when needed.
</para>
</section>

</section>

<section id="orgcl"><title>Rexx Classes for Organizing Objects</title>
<para>Rexx provides several key classes that form the basis for building class
hierarchies.</para>

<section id="objcl"><title>The Object Class</title>
<para>Because the root class in the hierarchy
is the Object class, everything below it is an object.
To interact with each other, objects require their own actions, called methods.
These methods, which encode actions that are needed by all objects, belong
to the Object class.</para>
<para>Every other class in the hierarchy inherits the methods of the root class.
Inheritance is the handing down of methods from a &quot;parent&quot;
class&mdash;called a superclass&mdash;to
all of its &quot;descendent&quot; classes&mdash;called subclasses. Finally,
instances acquire methods from their own classes. Any method created for the Object
class is automatically made available to every other class in the hierarchy.</para>
</section>

<section id="classcl"><title>The Class Class</title>
<para>The Class class is used for generating new classes. If a class is like a
factory for producing instances, Class is like a factory
for producing factories. Class is the parent of every
new class in the hierarchy, and these all inherit Class-like characteristics.
Class-like characteristics are methods and related variables, which reside
in Class, to be used by all classes.</para>
<para>A class that can be used to create another class is called a
<indexterm><primary>metaclasses</primary></indexterm>
metaclass (<xref linkend="meta" />). The Class class
is unique among Rexx classes in that it is the only metaclass that Rexx provides.
As such, the Class's methods not only make
new classes, they make methods for use by the new class and its instances.
They also make methods that only the new class itself can use, but not its
instances. These are called class methods. They give
a new class some power that is denied to its instances.</para>
<para>Because each instance of Class is another class, that class inherits the
Class's instance methods as class methods.  Thus if Class generates a
Pizza factory instance, the factory-running actions (Class's instance methods)
become the class methods of
the Pizza factory. Factory operations are class methods, and any new methods
created to manipulate pizzas would be instance methods:</para>

<figure><title>How Subclasses Inherit Instance Methods from the Class Class</title>
<indexterm><primary>inheritance</primary></indexterm>
<mediaobject>
<imageobject>
<imagedata fileref="images/SubclassInheritance.svg" scale="75" />
</imageobject>
</mediaobject>
</figure>

<para>As a programmer, you typically create classes by using directives, rather
than the methods of the Class class. In particular,
you'll use the ::CLASS directive, described later in this section. The
::CLASS directive is a kind of Rexx clause that declares class definitions in a
simple, static form in your programs.
</para>
</section>
</section>

<!-- @@ this section was already broken in 4.2; completely removing it for now
<section id="bigpict"><title>Rexx Classes: The Big Picture</title>
<indexterm><primary>classes</primary>
<secondary>provided by Rexx</secondary></indexterm>
<para>The following are the supplied Rexx classes.</para>

<figure float="1">
<title id="meths1">Classes and Inheritance (part 1 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses1.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths2">Classes and Inheritance (part 2 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses2.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths3">Classes and Inheritance (part 3 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses3.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths4">Classes and Inheritance (part 4 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses4.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths5">Classes and Inheritance (part 5 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses5.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths6">Classes and Inheritance (part 6 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses6.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths7">Classes and Inheritance (part 7 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses7.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths8">Classes and Inheritance (part 8 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses8.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths9">Classes and Inheritance (part 9 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses9.png" scale="90" />
</imageobject>
</mediaobject>
</figure>
</section>
end of removed broken section @@ -->

<section id="created"><title>Creating Your Own Classes Using Directives</title>
<indexterm><primary>directives</primary>
<secondary>creating classes with</secondary></indexterm>
<para> By analyzing your problem in terms of objects, you
can determine what classes need to be created.  You can create a class using
messages or directives. Directives are a new kind of Rexx clause, and they
are preferred over messages because the code is easier to read and understand,
especially in large programs. They also provide an easy way for you to
share your class definitions with others using the PUBLIC option.</para>

<section id="whatdir"><title>What Are Directives?</title>
<indexterm><primary>directives</primary>
<secondary>definition</secondary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>directives</secondary></indexterm>
<indexterm><primary>creating classes</primary></indexterm>
<indexterm><primary>classes</primary>
<secondary>creating with directives</secondary></indexterm>
<para>A Rexx program is made up of one or more executable units. Directives
separate these units, which themselves are Rexx programs.
Rexx processes all directives first to set up any classes, methods, or routines
needed by the program. Then it runs any code that exists before the first
directive. The first directive in a program marks the end of the executable
part of the program. A directive is a kind of clause that begins with a double-colon
(::) and is non-executable (a directive cannot appear in the expression of
an INTERPRET instruction, for example).</para>
</section>

<section id="rexdir"><title>The Directives Rexx Provides</title>
<indexterm><primary>directives</primary></indexterm>

<para>The following is a short summary of all the Rexx directives. See the
<citetitle pubwork="book">Open Object Rexx: Reference</citetitle>
for more details on, or examples of, any of these Rexx directives.</para>

<section id="clasdir"><title>The ::CLASS Directive</title>
<indexterm><primary>directives</primary>
<secondary>::CLASS</secondary></indexterm>
<para>You use the ::CLASS directive to create a class. Programs can then use
the new class by specifying it as a Rexx environment symbol (the class name
preceded by a period) in the program. For example, in
<xref linkend="sample" />,
the Savings class is created using the ::CLASS directive. A program can then
use the new class by specifying it as an environment symbol, &quot;.savings&quot;.</para>
<para>The new class that you create acquires any methods defined by subsequent
::METHOD directives within the program, until either another ::CLASS directive
or the end of the program is reached.</para>
<para>You can use the ::CLASS directive's SUBCLASS option to make the new
class the subclass of another. In
<xref linkend="sample" />, the Savings class
is made a subclass of the Account class. A subclass inherits instance and
class methods from its specified superclass; in the sample, Savings inherits
from Account.</para>
<para>Additional ::CLASS directive options are available for: </para>
<itemizedlist>
<listitem><para>Inheriting instance methods from a specified metaclass
as class methods of the new class (the METACLASS option).
For more information on metaclasses, see
<xref linkend="meta" />.</para></listitem>
<listitem><para>Making the new class available to programs outside its containing Rexx
program (the PUBLIC option). The outside program must refer to the new class
by using a ::REQUIRES directive.</para></listitem>
<listitem><para>Subclassing the new class to a mixin class in order to inherit its instance
and class methods (the MIXINCLASS option).</para></listitem>
<listitem><para>Adding the instance and class methods of a mixin class to the new class,
without subclassing it (the INHERIT option).</para></listitem></itemizedlist>
<para>When you create a new class, it is always a subclass of an existing class.
If you do not specify the SUBCLASS or MIXINCLASS option on the ::CLASS directive,
the superclass for the new class is the Object class.</para>
<para>Your class definition can be in a file of its own, with no executable code
preceding it. For example, when you define classes and methods to be shared
by several programs, you put the executable code in another file and refer
to the class file using a ::REQUIRES directive.</para>
<para>Rexx processes ::CLASS directives in the order in which they appear, unless
there is a dependency on some later directive's processing. You cannot
create two classes that have the same class name in one program. If several
programs contain classes with the same name, the last ::CLASS directive processed
is used.</para>
</section>

<section id="methdir"><title>The ::METHOD Directive</title>
<indexterm><primary>directives</primary>
<secondary>::METHOD</secondary></indexterm>
<para>The ::CLASS directive is usually followed by a ::METHOD directive, which
is used to create a method for that class and define the method's attributes.
The next directive in the program, or the end of the program, ends the method.</para>
<para>Some classes you define have an INIT method. INIT is called whenever a
NEW message is sent to a class. The INIT method must contain whatever code
is needed to initialize the object.</para>
<para>The ::METHOD directive can be used for: </para>
<itemizedlist>
<listitem><para>Creating a class method for the most-recent ::CLASS
directive (the CLASS option).</para></listitem>
<listitem><para>Creating a private method; that is, a method that
works like a subroutine and can only be activated by the objects of the same type it belongs
to&mdash;otherwise the method is public by default, and any sender can activate
it.</para></listitem>
<listitem><para>Creating a method that can be called while other methods are active on
the same object, as described in
<xref linkend="activat" /> (the UNGUARDED option).
</para></listitem>
</itemizedlist>
</section>

<section id="attrdir"><title>The ::ATTRIBUTE Directive</title>
<indexterm><primary>directives</primary>
<secondary>::ATTRIBUTE</secondary></indexterm>
<para>A ::CLASS directive can also be followed by ::ATTRIBUTE directives, which
are used to create methods that directly access internal attributes of an object.
For example, the Account class could define</para>
<programlisting>
::attribute balance
</programlisting>
<para>Which would allow the account balance to be set or retrieved.</para>
<programlisting>
  anAccount~balance = 10000     -- set a new account balance
  say anAccount~balance         -- display the current account balance
</programlisting>
<para>The access methods can created as read-only, or given private scope.</para>
</section>

<section id="routdir"><title>The ::ROUTINE Directive</title>
<indexterm><primary>directives</primary>
<secondary>::ROUTINE</secondary></indexterm>
<para>You use the ::ROUTINE directive to create a named routine within a program.
The ::ROUTINE directive starts the named routine and another directive (or
the end of the program) ends the routine.</para>
<para>The ::ROUTINE directive is useful organizing functions that are not specific to
a particular class type.
</para>
<para>The ::ROUTINE directive includes a PUBLIC option for making the routine
available to programs outside its containing Rexx program. The outside program
must reference the routine by using a ::REQUIRES directive
for the program that contains the routine.</para>
</section>

<section id="requdir"><title>The ::REQUIRES Directive</title>
<indexterm><primary>directives</primary>
<secondary>::REQUIRES</secondary></indexterm>
<para>You use the ::REQUIRES directive when a program needs access to the classes
and objects of another program. This directive has the following form: </para>
<indexterm><primary>directives</primary>
<secondary>::REQUIRES example</secondary></indexterm>
<programlisting>
<![CDATA[
::REQUIRES program_name
]]>
</programlisting>
<para>::REQUIRES directives are processed before other directives and the order
of the ::REQUIRES directives determines the search order for the classes and
routines defined in the named programs.</para>
<para>Local routine or class definitions within a program override routines or
classes imported through ::REQUIRES
directives.
</para>
</section>
</section>

<section id="howdir"><title>How Directives Are Processed</title>
<indexterm><primary>directives</primary>
<secondary>order of processing</secondary></indexterm>
<para>You place a directive (and its method code) after the
program code. When you run a program containing directives, Rexx: </para>
<orderedlist>
<listitem><para>Processes the directives first, to set up the program's classes, methods,
and routines.</para></listitem>
<listitem><para>Runs any program code preceding the first directive. This code can use
any classes, methods, and routines set up by the directives. </para>
<para>Once Rexx
has processed the code preceding the directive, any public classes and objects
the program defines are available to programs having the appropriate ::REQUIRES
directive.</para></listitem></orderedlist>
</section>

<section id="sample"><title>A Sample Program Using Directives</title>
<indexterm><primary>directives</primary>
<secondary>sample program</secondary></indexterm>
<para>Here is a program that uses directives to create new classes and methods: </para>
<example>
<title>Using directives</title>
<programlisting>
<![CDATA[
asav = .savings~new              /* executable code begins */
say asav~type                    /* executable code        */
asav~name= "John Smith"          /* executable code ends   */

::class Account                  /* directives begin ...   */

  ::method type
    return "an account"

  ::attribute name

::class Savings subclass Account

  ::method type
    return "a savings account"   /* ... directives end     */
]]>
</programlisting>
</example>
<para>The preceding program uses the
::CLASS directive to create two classes, the Account class and its Savings
<indexterm><primary>SUBCLASS option</primary></indexterm>
subclass. In the <computeroutput>::class Account</computeroutput>
expression, the ::CLASS directive
precedes the name of the new class, Account.</para>
<para>The example program also uses the ::METHOD directive to create a TYPE method and
::ATTRIBUTE to create NAME and NAME= methods for Account. In the
<computeroutput>::method type</computeroutput> instruction, the
::METHOD directive precedes the method name, and is immediately followed by
the code for the method. Methods for any new class follow its ::CLASS directive
in the program, and precede the next ::CLASS directive.</para>
<para>In the <computeroutput>::attribute name</computeroutput>
directive, we're creating a pair of methods.  The NAME method returns the
current value of the NAME object variable.  The NAME= method can assign
a new value to the NAME object variable.
</para>
<para>You do not have to associate object variables with a specific object. Rexx
keeps track of object variables for you. Whenever you send a message to savings
account Asav, which points to the Name object, Rexx knows what internal object
value to use. If you assign another value to Asav (such as &quot;Mary Smith&quot;),
Rexx recovers the object that was associated with Asav (&quot;John Smith&quot;)
as part of its normal garbage-collection operations.</para>
<para>In the Savings subclass, a second TYPE method is created that supersedes
the TYPE method Savings would otherwise have inherited from Account. Note
that the directives appear after the program code.</para>
</section>

<section id="dire"><title>Another Sample Program</title>
<indexterm><primary>directives</primary>
<secondary>sample program</secondary></indexterm>
<para>A directive is nonexecutable code that begins with a double colon (::)
and follows the program code. The ::CLASS directive creates a class; in this
example, the Dinosaur class. The sample provides two methods for the Dinosaur
class, INIT and DIET. These are added to the Dinosaur class using the ::METHOD
<indexterm><primary>INIT method</primary></indexterm>
directives. After the line containing the ::METHOD directive, the code for
the method is specified. Methods are ended either by the start of the next
directive or by the end of the program.</para>
<para>Because directives must follow the executable code in your program, you
put that code first. In this case, the executable code creates a new dinosaur,
Dino, that is an instance of the Dinosaur class. Rexx then runs the INIT method.
Rexx runs any INIT method automatically whenever the NEW message is received.
Here the INIT method is used to identify the type of dinosaur. Then the program
runs the DIET method to determine whether the dinosaur eats meat or vegetables.
Rexx saves the information returned by INIT and DIET as variables in the Dino
object.</para>
<para>In the example, the Dinosaur class and its two methods are defined following
the executable program code: </para>
<example>
<title>Defining methods</title>
<programlisting>
<![CDATA[
dino=.dinosaur~new         /* Create a new dinosaur instance and
                                            /* initialize variables */
dino~diet                  /* Run the DIET method          */
exit
]]>
 </programlisting>

<programlisting>
<![CDATA[
::class Dinosaur           /* Create the Dinosaur class  */

  ::method init            /* Create the INIT method     */
    expose type
    say "Enter a type of dinosaur."
    pull type
    return

  ::method diet            /* Create the DIET method     */
    expose type
    select
    when type="T-REX" then string="Meat-eater"
    when type="TYRANNOSAUR" then string="Meat-eater"
    when type="TYRANNOSAURUS REX" then string="Meat-eater"
    when type="DILOPHOSAUR" then string="Meat-eater"
    when type="VELICORAPTOR" then string="Meat-eater"
    when type="RAPTOR" then string="Meat-eater"
    when type="ALLOSAUR" then string="Meat-eater"
    when type="BRONTOSAUR" then string="Plant-eater"
    when type="BRACHIOSAUR" then string="Plant-eater"
    when type="STEGOSAUR" then string="Plant-eater"
    otherwise string="Type of dinosaur or diet unknown"
    end
    say string
    return 0
]]>
</programlisting>
</example>
</section>
</section>

<section id="definei"><title>Defining an Instance</title>
<para>You use the NEW method to define an instance of the new class,
and then call methods that the instance inherited from its superclass. To
define an instance of the Savings class named &quot;John Smith,&quot; and send
John Smith the TYPE and NAME= messages to call the related methods, you enter: </para>
<programlisting>
<![CDATA[
newaccount = savings~new
say newaccount~type
newaccount~name = "John Smith"
]]>
</programlisting>
</section>

<section id="typcla"><title>Types of Classes</title>
<para>There are four kinds of classes: </para>
<itemizedlist>
<listitem><para>Object classes</para></listitem>
<listitem><para>Mixin classes</para></listitem>
<listitem><para>Abstract classes</para></listitem>
<listitem><para>Metaclasses</para></listitem></itemizedlist>
<para> The following sections explain these.</para>

<section id="objcla"><title>Object Classes</title>
<indexterm><primary>object classes</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>types</secondary>
<tertiary>object</tertiary></indexterm>
<para>An <emphasis>object class</emphasis> is a factory
for producing objects. An object class creates objects (instances) and provides
methods that these objects can use. An object acquires the instance methods
of the class to which it belongs at the time of its creation. If a class gains
additional methods, objects created before the definition of these methods
do not acquire the new or changed methods.</para>
<para>The instance variables within an object are created on demand whenever a method
EXPOSEs an object variable.  The class creates the object instance, defines the methods
the object has, and the object instance completes the job of constructing the object.
</para>
<para>
The String class and the
Array Class
are examples of object classes.</para>
</section>

<section id="xmixin"><title>Mixin Classes</title>
<indexterm><primary>mixin classes</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>types</secondary>
<tertiary>mixin</tertiary></indexterm>
<para>Classes can inherit from more than the single superclass from
which they were created. This is called
<emphasis>multiple inheritance</emphasis>. Classes designed
to add a set of instance and class
methods to other classes are called <emphasis>mixin classes</emphasis>,
or simply mixins.</para>
<para>You can add mixin methods to an existing class by sending an INHERIT
message or using the INHERIT option on the ::CLASS directive.
In either case, the class to be inherited must be a mixin. During both class
creation and multiple inheritance, subclasses inherit both class and instance
methods from their superclasses.</para>
<para>Mixins are always associated
<indexterm><primary>base class for mixins</primary></indexterm>
with a <emphasis>base class</emphasis>, which is the mixin's first non-mixin
superclass. Any subclass of the mixin's base class can (directly or indirectly)
inherit a mixin; other classes cannot.  For example, a mixin class created
as a subclass of the Array class can only be inherited by other Array subclasses.
Mixins that use the Object class as a base class can be inherited by any class.
</para>
<para>To create a new mixin class, you send a MIXINCLASS message to an existing
class or use the ::CLASS directive with the MIXINCLASS option. A mixin class
is also an object class and can create instances of the class.</para>
</section>

<section id="abscla"><title>Abstract Classes</title>
<indexterm><primary>abstract class, definition</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>types</secondary>
<tertiary>abstract</tertiary></indexterm>
<para><emphasis>Abstract classes</emphasis> provide definitions for instance
methods and class methods
but are not intended to create instances. Abstract classes often define the
message interfaces that subclasses should implement.</para>
<para>You create an abstract class like object or mixin classes. No extra
messages or keywords on the ::CLASS directive are necessary. Rexx does not
prevent users from creating instances of abstract classes.
It is possible to create abstract methods on a class.  An abstract method is a
placeholder that subclasses are expected to override.  Failing to provide a real
method implementation will result in an error when the abstract version is called.
</para>
</section>

<section id="meta"><title>Metaclasses</title>
<indexterm><primary>metaclasses</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>types</secondary>
<tertiary>metaclass</tertiary></indexterm>
<para>A <emphasis>metaclass</emphasis> is a class you
can use to create another class. The only metaclass that Rexx provides is
.Class, the Class class. The Class class is the metaclass of all the classes
Rexx provides. This means that instances of .Class are themselves classes.
The Class class is like a factory for producing the factories that produce
objects.</para>
<para>To change the behavior of an object that is an instance, you generally
use subclassing. For example, you can create Statarray, a subclass of the
Array class.
The statArray class can include a
method for computing a total of all the numeric elements of an array.</para>
<example>
<title>Creating an Array subclass</title>
<programlisting>
/* Creating an array subclass for statistics */

::class statArray subclass array public

::method init    /*  Initialize running total and forward to superclass */
  expose total
  total = 0
  forward class (super)

::method put     /*  Modify to increment running total */
  expose total
  use arg value
  total = total + value  /* Should verify that value is numeric!!! */
  forward class (super)

::method "[]="   /*  Modify to increment running total */
  forward message "PUT"

::method remove  /*  Modify to decrement running total */
  expose total
  use arg index
  forward message "AT" continue
  total = total - result
  forward class (super)

::method average /*  Return the average of the array elements */
  expose total
  return total / self~items

::method total   /*  Return the running total of the array elements */
  expose total
  return total
</programlisting>
</example>
<para>You can use this method on the individual array
<emphasis>instances</emphasis>, so it is an
<emphasis>instance method</emphasis>.</para>
<para>However, if you want to change the behavior of the factory producing the
arrays, you need a new class method. One way to do
this is to use the ::METHOD directive with the CLASS option. Another way to
add a <emphasis>class</emphasis> method is to create a new metaclass that
changes the behavior
of the Statarray class. A new metaclass is a subclass of .class.</para>
<para>You can use a metaclass by specifying it in a SUBCLASS or MIXINCLASS
message or on a ::CLASS directive with the METACLASS option.</para>
<para>If you are adding a highly specialized class method useful only for a
particular class, use the ::METHOD directive with the CLASS option. However,
if you are adding a class method that would be useful for many classes, such
as an instance counter that counts how many instances a class creates,
you use a metaclass.</para>
<para>The following examples add a class method that keeps a running total of
instances created. The first version uses the ::METHOD directive with the
CLASS option. The second version uses a metaclass.</para>
<para><emphasis role="bold">Version 1</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>metaclass</secondary></indexterm>
<example>
<title>Adding a class method</title>
<programlisting>
/* Adding a class method using ::METHOD */

a = .point~new(1,1)               /* Create some point instances  */
say "Created point instance" a
b = .point~new(2,2)               /* create another point instance */
say "Created point instance" b
c = .point~new(3,3)               /* create another point instance */
say "Created point instance" c
                                  /* ask the point class how many */
                                  /* instances it has created     */
say "The point class has created" .point~instances "instances."



::class point public                /* create Point class           */

::method init class
  expose instanceCount
  instanceCount = 0                 /* Initialize instanceCount     */
  forward class (super)             /* Forward INIT to superclass   */

::method new class
  expose instanceCount              /* Creating a new instance      */
  instanceCount = instanceCount + 1 /* Bump the count               */
  forward class (super)             /* Forward NEW to superclass    */

::method instances class
  expose instanceCount              /* Return the instance count    */
  return instanceCount


::method init
  expose xVal yVal                  /* Set object variables         */
  use arg xVal, yVal                /* as passed on NEW             */

::method string
  expose xVal yVal                  /* Use object variables         */
  return "("xVal","yVal")"          /* to return string value       */
</programlisting>
<para><emphasis role="bold">Version 2</emphasis></para>
<programlisting>
/* Adding a class method using a metaclass  */

a = .point~new(1,1)                    /* Create some point instances  */
say "Created point instance" a
b = .point~new(2,2)
say "Created point instance" b
c = .point~new(3,3)
say "Created point instance" c
                                       /* ask the point class how many */
                                       /* instances it has created     */
say "The point class has created" .point~instances "instances."

::class InstanceCounter subclass class /* Create a new metaclass that */
                                       /* will count its instances     */
::method init
  expose instanceCount
  instanceCount = 0                    /* Initialize instanceCount     */
  forward class (super)                /* Forward INIT to superclass   */

::method new
  expose instanceCount                 /* Creating a new instance      */
  instanceCount = instanceCount + 1    /* Bump the count               */
  forward class (super)                /* Forward NEW to superclass    */

::method instances
expose instanceCount                   /* Return the instance count    */
return instanceCount


::class point public metaclass InstanceCounter  /* Create Point class */
                                       /* using InstanceCounter metaclass */
::method init
  expose xVal yVal                     /* Set object variables         */
  use arg xVal, yVal                   /* as passed on NEW             */

::method string
  expose xVal yVal                     /* Use object variables         */
  return "("xVal","yVal")"             /* to return string value       */
</programlisting>
</example>
</section>
</section>
</chapter>
