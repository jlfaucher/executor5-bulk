<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "rexxpg.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: Programming Guide XML file.
    #
    # Copyright (c) 2005-2019, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->
<chapter id="provide"><title>The Basics of Classes</title>
<para>Similar objects in Rexx are grouped into classes, forming a hierarchy.
Rexx gives you a basic class hierarchy to start with. All of the classes in
the hierarchy are described in detail in the
<citetitle pubwork="book">Open Object Rexx: Reference</citetitle>.
</para>
<para>Rexx provides the following classes on all operating systems by default. The classes are
depicted in hierarchical order, subclasses get indented under their superclass. If a class can be used
for multiple inheritance it gets flagged with <emphasis role="italic">(mixin)</emphasis>. Classes
that inherit from mixin classes will list them in parantheses starting with the word
<emphasis role="italic">inherit</emphasis> followed by the blank delimited list of inherited mixin
classes.
</para>

<!-- GENERATED by 'docs/trunk/tools/createClassHierarchy.rex' on [2020-03-10T13:27:36.162000] -->
<para>

<itemizedlist mark="none" spacing="compact">
    <listitem><para>Object </para></listitem>

    <listitem><itemizedlist mark="none" spacing="compact">

        <listitem><para>Alarm </para></listitem>

        <listitem><para>AlarmNotification &added50; <emphasis role="italic"> (mixin)</emphasis></para></listitem>

        <listitem><para>Array <emphasis role="italic"> (inherit OrderedCollection)</emphasis></para></listitem>

        <listitem><para>Bag <emphasis role="italic"> (inherit MapCollection SetCollection)</emphasis></para></listitem>

        <listitem><para>Buffer </para></listitem>

        <listitem><para>Class </para></listitem>

        <listitem><para>Collection <emphasis role="italic"> (mixin)</emphasis></para></listitem>

        <listitem><itemizedlist mark="none" spacing="compact">

            <listitem><para>MapCollection <emphasis role="italic"> (mixin)</emphasis></para></listitem>

            <listitem><para>OrderedCollection <emphasis role="italic"> (mixin)</emphasis></para></listitem>

            <listitem><para>SetCollection <emphasis role="italic"> (mixin)</emphasis></para></listitem>
        </itemizedlist></listitem>


        <listitem><para>Comparable <emphasis role="italic"> (mixin)</emphasis></para></listitem>

        <listitem><para>Comparator <emphasis role="italic"> (mixin)</emphasis></para></listitem>

        <listitem><itemizedlist mark="none" spacing="compact">

            <listitem><para>CaselessColumnComparator <emphasis role="italic"> (mixin)</emphasis></para></listitem>

            <listitem><para>CaselessComparator <emphasis role="italic"> (mixin)</emphasis></para></listitem>

            <listitem><para>CaselessDescendingComparator <emphasis role="italic"> (mixin)</emphasis></para></listitem>

            <listitem><para>ColumnComparator <emphasis role="italic"> (mixin)</emphasis></para></listitem>

            <listitem><para>DescendingComparator <emphasis role="italic"> (mixin)</emphasis></para></listitem>

            <listitem><para>InvertingComparator <emphasis role="italic"> (mixin)</emphasis></para></listitem>

            <listitem><para>NumericComparator <emphasis role="italic"> (mixin)</emphasis></para></listitem>
        </itemizedlist></listitem>


        <listitem><para>DateTime <emphasis role="italic"> (inherit Comparable Orderable)</emphasis></para></listitem>

        <listitem><para>Directory <emphasis role="italic"> (inherit MapCollection)</emphasis></para></listitem>

        <listitem><itemizedlist mark="none" spacing="compact">

            <listitem><para>Properties </para></listitem>
        </itemizedlist></listitem>


        <listitem><para>EventSemaphore  &added50;</para></listitem>

        <listitem><para>File <emphasis role="italic"> (inherit Comparable Orderable)</emphasis></para></listitem>

        <listitem><para>IdentityTable <emphasis role="italic"> (inherit MapCollection)</emphasis></para></listitem>

        <listitem><para>InputOutputStream <emphasis role="italic"> (mixin)</emphasis><emphasis role="italic"> (inherit InputStream OutputStream)</emphasis></para></listitem>

        <listitem><itemizedlist mark="none" spacing="compact">

            <listitem><para>Stream <emphasis role="italic"> (mixin)</emphasis></para></listitem>
        </itemizedlist></listitem>


        <listitem><para>InputStream <emphasis role="italic"> (mixin)</emphasis></para></listitem>

        <listitem><para>List <emphasis role="italic"> (inherit OrderedCollection)</emphasis></para></listitem>

        <listitem><para>Message <emphasis role="italic"> (inherit MessageNotification AlarmNotification)</emphasis></para></listitem>

        <listitem><para>MessageNotification &added50; <emphasis role="italic"> (mixin)</emphasis></para></listitem>

        <listitem><para>Method </para></listitem>

        <listitem><para>Monitor </para></listitem>

        <listitem><para>MutableBuffer </para></listitem>

        <listitem><para>MutexSemaphore &added50;</para></listitem>

        <listitem><para>Orderable <emphasis role="italic"> (mixin)</emphasis></para></listitem>

        <listitem><para>OutputStream <emphasis role="italic"> (mixin)</emphasis></para></listitem>

        <listitem><para>Package </para></listitem>

        <listitem><para>Pointer </para></listitem>

        <listitem><para>Queue <emphasis role="italic"> (inherit OrderedCollection)</emphasis></para></listitem>

        <listitem><itemizedlist mark="none" spacing="compact">

            <listitem><para>CircularQueue </para></listitem>
        </itemizedlist></listitem>


        <listitem><para>Relation <emphasis role="italic"> (inherit MapCollection)</emphasis></para></listitem>

        <listitem><para>RexxContext </para></listitem>

        <listitem><para>RexxInfo &added50;</para></listitem>

        <listitem><para>RexxQueue </para></listitem>

        <listitem><para>Routine </para></listitem>

        <listitem><para>Set <emphasis role="italic"> (inherit MapCollection SetCollection)</emphasis></para></listitem>

        <listitem><para>StackFrame </para></listitem>

        <listitem><para>Stem <emphasis role="italic"> (inherit MapCollection)</emphasis></para></listitem>

        <listitem><para>String <emphasis role="italic"> (inherit Comparable)</emphasis></para></listitem>

        <listitem><para>StringTable &added50; <emphasis role="italic"> (inherit MapCollection)</emphasis></para></listitem>

        <listitem><para>Supplier </para></listitem>

        <listitem><itemizedlist mark="none" spacing="compact">

            <listitem><para>StreamSupplier </para></listitem>
        </itemizedlist></listitem>


        <listitem><para>Table <emphasis role="italic"> (inherit MapCollection)</emphasis></para></listitem>

        <listitem><para>Ticker &added50;</para></listitem>

        <listitem><para>TimeSpan <emphasis role="italic"> (inherit Comparable Orderable)</emphasis></para></listitem>

        <listitem><para>Validate &added50;</para></listitem>

        <listitem><para>VariableReference &added50;</para></listitem>

        <listitem><para>WeakReference </para></listitem>
    </itemizedlist></listitem>

</itemizedlist>
</para>
<!-- GENERATED by 'docs/trunk/tools/createClassHierarchy.rex' on [2020-03-10T13:27:36.162000] -->

<para>Note that there might also be other classes available, depending
on the operating system.
</para>


<section id="progcl"><title>Rexx Classes for Programming</title>
<para>The classes Rexx supplies provide the starting point for object-oriented
programming. Some key classes that you are likely to work with are described
in the following sections.</para>

<section id="clsAlarm"><title>The <emphasis role="italic">Alarm</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>Alarm class</secondary></indexterm>
<para>The <emphasis role="italic">Alarm</emphasis> class is used to create objects with timing and notification capability.
An alarm object is able to send a message to an object at any time in the
future, and until then, you can cancel the alarm.</para>
</section>

<section id="clsAlarmNotification" revisionflag="added"><title>&added50; <emphasis role="italic">AlarmNotification</emphasis> Class</title>
<indexterm><primary>classes</primary><secondary>AlarmNotification class</secondary></indexterm>
<para>Implements the notification interface for the
<xref linkend="clsAlarm" xrefstyle="template:Alarm"/> class.
</para>
</section>

<section id="buffercl"><title>The <emphasis role="italic">Buffer</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>Buffer class</secondary></indexterm>
<para>A <emphasis role="italic">Buffer</emphasis> instance is a Rexx interpreter managed block of storage.
This class is designed primarily for writing methods and functions in native code
and can only be created using the native code application programming interfaces.</para>
</section>

<section id="caselesscolumncomparatorcl"><title>The <emphasis role="italic">CaselessColumnComparator</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>CaselessColumnComparator class</secondary></indexterm>
<para>The <emphasis role="italic">CaselessColumnComparator</emphasis> class performs caseless orderings of specific substrings
of <emphasis role="italic">String</emphasis> objects.
</para>
</section>

<section id="caselesscomparatorcl"><title>The <emphasis role="italic">CaselessComparator</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>CaselessComparator class</secondary></indexterm>
<para>The <emphasis role="italic">CaselessComparator</emphasis> class performs caseless orderings of <emphasis role="italic">String</emphasis> objects.
</para>
</section>

<section id="caselessdescendingcomparatorcl"><title>The <emphasis role="italic">CaselessDescendingComparator</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>CaselessDescendingComparator class</secondary></indexterm>
<para>The <emphasis role="italic">CaselessDescendingComparator</emphasis> class performs caseless string sort orderings in descending order.
This is the inverse of a <emphasis role="italic">CaselessComparator</emphasis> sort order.
</para>
</section>

<section id="colcl"><title>The <emphasis role="italic">Collection</emphasis> Classes</title>
<indexterm><primary>classes</primary>
<secondary>Collection class</secondary></indexterm>
<para>The <emphasis role="italic">collection</emphasis> classes are
used to manipulate collections of objects. A <emphasis role="italic">collection</emphasis> is an object that
contains a number of <emphasis role="italic">items</emphasis>, which can be
any objects. These manipulations might include counting objects, organizing
them, or assigning them a supplier (for example, to indicate that a specific
assortment of baked goods is supplied by the Pie-by-Night Bakery).</para>
<para>Rexx includes classes, for example, for arrays, lists, queues, tables,
and directories. Each item stored in a Rexx <emphasis role="italic">collection</emphasis> has an associated index
that you can use to retrieve the item from the <emphasis role="italic">collection</emphasis>
with the <emphasis role="italic">AT</emphasis> or <emphasis role="italic">[]</emphasis>
(left and right bracket) methods, and each collection defines its own acceptable
index types: </para>
<variablelist>

<varlistentry><term><emphasis role="italic">Array</emphasis></term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Array class</secondary></indexterm>
<para>A sequenced collection of objects ordered by whole-number indexes.
</para></listitem></varlistentry>

<varlistentry><term><emphasis role="italic">Bag</emphasis></term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Bag class</secondary></indexterm>
<para>A collection where the index is equal to the value. <emphasis role="italic">Bag</emphasis> indexes can
be any object (as with the <emphasis role="italic">Table</emphasis> class) and each index can appear more than
once.
</para></listitem></varlistentry>

<varlistentry><term><emphasis role="italic">CircularQueue</emphasis></term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>CircularQueue class</secondary></indexterm>
<para>The <emphasis role="italic">CircularQueue</emphasis> class allows for storing objects in a circular queue
of a predefined size. Once the end of the queue has been reached, new item objects are
inserted from the beginning, replacing earlier entries. Any object can be placed in the
queue and the same object can occupy more than one position in the queue.
</para></listitem></varlistentry>

<varlistentry><term><emphasis role="italic">Directory</emphasis></term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Directory class</secondary></indexterm>
<para>A collection of character string indexes. Indexes are compared using
the string <emphasis role="italic">==</emphasis> comparison method to test for strict equality.
</para></listitem></varlistentry>

<varlistentry><term><emphasis role="italic">IdentityTable</emphasis></term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>IdentityTable class</secondary></indexterm>
<para>An <emphasis role="italic">IdentityTable</emphasis> is a collection with indexes that can be any object.
In an <emphasis role="italic">IdentityTable</emphasis>, each item is associated with a single index, and there can be only
one item for each index. Index and item matches in an identity table are made using an
object identity comparison. That is, an index will only match if the same instance is
used in the collection.
</para></listitem></varlistentry>

<varlistentry><term><emphasis role="italic">List</emphasis></term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>List class</secondary></indexterm>
<para>A sequenced collection that lets you add new items at any position in
the sequence. A list generates and returns an index value for each item placed
in the list. The returned index remains valid until the item is removed from
the list.
</para></listitem></varlistentry>

<varlistentry><term><emphasis role="italic">Properties</emphasis></term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Properties class</secondary></indexterm>
<para>A <emphasis role="italic">Properties</emphasis> object is a collection with unique indexes that are character
strings representing names and items that are also restricted to character string values.
<emphasis role="italic">Properties</emphasis> objects are useful for processing bundles of application option values.
</para></listitem></varlistentry>

<varlistentry><term><emphasis role="italic">Queue</emphasis></term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Queue class</secondary></indexterm>
<para>A sequenced collection of items ordered as a queue. You can remove items
from the head of the queue and add items at either its tail or its head. Queues
index the items with whole-number indexes, in the order in which the items
would be removed. The current head of the queue has index <emphasis role="italic">1</emphasis>, the item after
the head item has index <emphasis role="italic">2</emphasis>, up to the number of items in the queue.
</para></listitem></varlistentry>

<varlistentry><term><emphasis role="italic">Relation</emphasis></term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Relation class</secondary></indexterm>
<para>A collection of indexes that can be any object (as with the <emphasis role="italic">Table</emphasis> class).
A relation can contain duplicate indexes.
</para></listitem></varlistentry>

<varlistentry><term><emphasis role="italic">Set</emphasis></term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Set class</secondary></indexterm>
<para>A collection where the indexes are equal to the values. Set indexes
can be any object (as with the <emphasis role="italic">Table</emphasis> class) and each index is unique.
</para></listitem></varlistentry>

<varlistentry><term><emphasis role="italic">Stem</emphasis></term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Stem class</secondary></indexterm>
<para>A <emphasis role="italic">Stem</emphasis> object is a collection with unique indexes that are character strings.
</para></listitem></varlistentry>

<varlistentry><term><emphasis role="italic">StringTable</emphasis></term>
<listitem>
<indexterm><primary>classes</primary><secondary>StringTable class</secondary></indexterm>
<para>A collection using unique character string indexes.
The items of a <emphasis role="italic">StringTable</emphasis> can be any valid Rexx object.
</para></listitem></varlistentry>

<varlistentry><term><emphasis role="italic">Table</emphasis></term>
<listitem>
<indexterm><primary>classes</primary>
<secondary>Table class</secondary></indexterm>
<para>A collection of indexes that can be any object. For example, <emphasis role="italic">String</emphasis>
objects, <emphasis role="italic">Array</emphasis> objects, <emphasis role="italic">Alarm</emphasis> objects, or any user-created object can be a
table index.  The <emphasis role="italic">Table</emphasis> class determines an index match
by using <emphasis role="italic">the ==</emphasis> comparison
method to test for strict equality. A Table contains no duplicate indexes.
</para></listitem></varlistentry>

</variablelist>
</section>

<section id="columncomparatorcl"><title>The <emphasis role="italic">ColumnComparator</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>ColumnComparator class</secondary></indexterm>
<para>The <emphasis role="italic">ColumnComparator</emphasis> class performs orderings based
on specific substrings of <emphasis role="italic">String</emphasis> objects.
</para>
</section>

<section id="comparablecl"><title>The <emphasis role="italic">Comparable</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>Comparable class</secondary></indexterm>
<para>Any object that inherits the <emphasis role="italic">Comparable</emphasis> mixin class and
implements a <emphasis role="italic">compareTo() </emphasis>
method can be sorted. The <emphasis role="italic">DateTime</emphasis> Class and
<emphasis role="italic">TimeSpan</emphasis> Class are examples of built-in
Rexx classes that can be sorted. Any user created class may also implement a <emphasis role="italic">compareTo()</emphasis>
method to enable sorting.
</para>
</section>

<section id="comparatorcl"><title>The <emphasis role="italic">Comparator</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>Comparator class</secondary></indexterm>
<para>The <emphasis role="italic">Comparator</emphasis> class is the base class for implementing Comparator objects that can
be used with the <emphasis role="italic">Array</emphasis> <emphasis role="italic">sortWith()</emphasis>
or <emphasis role="italic">stableSortWith()</emphasis> method. The <emphasis role="italic">compare()</emphasis> method implements
some form of comparison that determines the relative ordering of two objects. Many <emphasis role="italic">Comparator</emphasis>
implementations are specific to particular object types.
</para>
</section>

<section id="datetimecl"><title>The <emphasis role="italic">DateTime</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>DateTime class</secondary></indexterm>
<para>A <emphasis role="italic">DateTime</emphasis> object represents a point in between
<emphasis role="italic">1 January 0001 at 00:00.000000</emphasis> and
<emphasis role="italic">31 December 9999 at 23:59:59.999999</emphasis>.
A <emphasis role="italic">DateTime</emphasis> object has methods to allow formatting a date or time in various
formats, as well as allowing arithmetic operations between dates.
</para>
</section>

<section id="descendingcomparatorcl"><title>The <emphasis role="italic">DescendingComparator</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>DescendingComparator class</secondary></indexterm>
<para>The <emphasis role="italic">DescendingComparator</emphasis> class performs sort orderings in descending order.
This is the inverse of a <emphasis role="italic">Comparator</emphasis> sort order.
</para>
</section>

<section id="filecl"><title>The <emphasis role="italic">File</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>File class</secondary></indexterm>
<para>The <emphasis role="italic">File</emphasis> class provides services which are common to all the filesystems supported by ooRexx.
A <emphasis role="italic">File</emphasis> object represents a path to a file or directory. The path can be relative or absolute.
</para>
</section>

<section id="inputoutputstreamcl"><title>The <emphasis role="italic">InputOutputStream</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>InputOutputStream class</secondary></indexterm>
<para>This class is defined as an abstract mixin class. It must be implemented by subclassing it
or inheriting from it as a mixin. Many of the methods in this class are abstract and must be overridden
or they will throw a syntax error when invoked.
</para>
</section>

<section id="inputstreamcl"><title>The <emphasis role="italic">InputStream</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>InputStream class</secondary></indexterm>
<para>This class is defined as an abstract mixin class. It must be implemented by subclassing it
or inheriting from it as a mixin. Many of the methods in this class are abstract and must be overridden
or they will throw a syntax error when invoked.
</para>
</section>

<section id="invertingcomparatorcl"><title>The <emphasis role="italic">InvertingComparator</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>InvertingComparator class</secondary></indexterm>
<para>The <emphasis role="italic">InvertingComparator</emphasis> class inverts the comparison results of another
<emphasis role="italic">Comparator</emphasis> object to reverse the resulting sort order.
</para>
</section>

<section id="msgcl"><title>The <emphasis role="italic">Message</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>Message class</secondary></indexterm>
<para><emphasis role="italic">Message</emphasis> objects allow you to run concurrently methods on other threads or to
invoke dynamically calculated messages.
Methods of
for this class are used, for example, to start a message on another thread, to notify the sender
object when an error occurs or when message processing is complete, or to return
the results of that processing to the sender or to some other object.
</para>
</section>

<section id="methodcl"><title>The <emphasis role="italic">Method</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>Method class</secondary></indexterm>
<para>The <emphasis role="italic">Method</emphasis> class creates method objects from Rexx source code.
</para>
</section>

<section id="moncl"><title>The <emphasis role="italic">Monitor</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>Monitor class</secondary></indexterm>
<para>The <emphasis role="italic">Monitor</emphasis> class provides a way to forward messages to a specified destination.
The <emphasis role="italic">Monitor</emphasis> creates a proxy that can dynamically route messages to different destinations.
<emphasis role="italic">Monitor</emphasis> methods change or restore a destination object.
</para>
</section>

<section id="mutablebuffercl"><title>The <emphasis role="italic">MutableBuffer</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>MutableBuffer class</secondary></indexterm>
<para>The <emphasis role="italic">MutableBuffer</emphasis> class is a buffer on which certain string operations such as concatenation can be
performed very efficiently. Unlike String objects, MutableBuffer<emphasis role="italic">s</emphasis> can be altered without requiring a new
object allocation. A <emphasis role="italic">MutableBuffer</emphasis> object can provide better performance for algorithms that involve
frequent concatenations to build up longer string objects because it creates fewer intermediate objects.
</para>
</section>

<section id="outputstreamcl"><title>The <emphasis role="italic">OutputStream</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>OutputStream class</secondary></indexterm>
<para>This class is defined as an abstract mixin class. It must be implemented by subclassing it or inheriting
from it as a mixin. Many of the methods in this class are abstract and must be overridden or they will
throw a syntax error when invoked.
</para>
</section>

<section id="numericcomparatorcl"><title>The <emphasis role="italic">NumericComparator</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>NumericComparator class</secondary></indexterm>
<para>The <emphasis role="italic">NumericComparator</emphasis> class compares strings using numeric comparison rules to
determine sort order.
</para>
</section>

<section id="orderablecl"><title>The <emphasis role="italic">Orderable</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>Orderable class</secondary></indexterm>
<para>The <emphasis role="italic">Orderable</emphasis> class can be inherited by classes which wish to provide each of the comparison operator
methods without needing to implement each of the individual methods. The inheriting class need only
implement the <emphasis role="italic">Comparable</emphasis> <emphasis role="italic">compareTo()</emphasis> method.
This class is defined as a mixin class.
</para>
</section>

<section id="packagecl"><title>The <emphasis role="italic">Package</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>Package class</secondary></indexterm>
<para>The <emphasis role="italic">Package</emphasis> class contains the source code for a package of Rexx code. A package instance holds all of
the routines, classes, and methods created from a source code unit and also manages external
dependencies referenced by <emphasis role="italic">::REQUIRES</emphasis> directives.
The files loaded by <emphasis role="italic">::REQUIRES</emphasis> are also
contained in Package class instances.
</para>
</section>

<section id="pointercl"><title>The <emphasis role="italic">Pointer</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>Pointer class</secondary></indexterm>
<para>A <emphasis role="italic">Pointer</emphasis> instance is a wrapper around a native pointer value.
This class is designed primarily for writing methods and functions in native code and
can only be created using the native code application programming interfaces.
The <emphasis role="italic">Pointer</emphasis> class <emphasis role="italic">new</emphasis> method will raise an error if invoked.
</para>
</section>

<!-- rgf, 2020-03-16: not available by default, needs to be required, hence not the right place to document
<section id="regularexpressioncl"><title>The <emphasis role="italic">RegularExpression</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>RegularExpression class</secondary></indexterm>
<para>This class provides support for regular expressions.
A regular expression is a pattern you can use to match strings.
</para>
</section>
-->

<section id="rexxcontextcl"><title>The <emphasis role="italic">RexxContext</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>RexxContext class</secondary></indexterm>
<para>The <emphasis role="italic">RexxContext</emphasis> class gives access to context information about the currently executing Rexx code.
Instances of the <emphasis role="italic">RexxContext</emphasis> class can only be obtained via the <literal>.CONTEXT</literal> environment symbol. They
cannot be directly created by the user.
</para>
</section>

<section id="rexxqueuecl"><title>The <emphasis role="italic">RexxQueue</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>RexxQueue class</secondary></indexterm>
<para>The <emphasis role="italic">RexxQueue</emphasis> class provides object-style access to Rexx external data queues.
</para>
</section>

<section id="routinecl"><title>The <emphasis role="italic">Routine</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>Routine class</secondary></indexterm>
<para>The <emphasis role="italic">Routine</emphasis> class creates routine objects from Rexx source code.
</para>
</section>

<section id="stackframecl"><title>The <emphasis role="italic">StackFrame</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>StackFrame class</secondary></indexterm>
<para>The <emphasis role="italic">StackFrame</emphasis> class provides debugging information about a Rexx activity's execution chain.
</para>
</section>

<section id="stemcl"><title>The <emphasis role="italic">Stem</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>Stem class</secondary></indexterm>
<para>A stem variable is a symbol that
must start with a letter and end with a period, like &quot;<literal>FRED.</literal>&quot; or &quot;<literal>A.</literal>&quot;.
The value of a stem variable is a  <emphasis role="italic">Stem</emphasis> object.
A <emphasis role="italic">Stem</emphasis> object is a collection
of unique character string indexes. <emphasis role="italic">Stem</emphasis> objects are automatically
created when a Rexx <emphasis role="italic">Stem</emphasis> variable or Rexx compound variable is used. In addition
to the items assigned to the collection indexes, a <emphasis role="italic">Stem</emphasis> object also has a
default value that is used for all uninitialized indexes of the collection.
</para>
</section>

<section id="streacl"><title>The <emphasis role="italic">Stream</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>Stream class</secondary></indexterm>
<para>Input and output <emphasis role="italic">Stream</emphasis>s
let Rexx communicate with external objects, such as people, files, queues,
serial interfaces, displays, and networks. In programming there are many stream
actions that can be coded as methods for manipulating the various <emphasis role="italic">Stream</emphasis> objects.
These methods and objects are organized in the <emphasis role="italic">Stream</emphasis> class.</para>
<para>The methods are used to open streams for reading or writing, close streams
at the end of an operation, move the line-read or line-write position within
a file stream, or get information about a stream. Methods are also provided
to get character strings from a stream or send them to a stream, count characters
in a stream, flush buffered data to a stream, query path specifications, time
stamps, size, and other information from a stream, or do any other I/O stream
manipulation (see <xref linkend="rexio" /> for examples).</para>
</section>

<section id="streamsuppliercl"><title>The StreamSupplier Class</title>
<indexterm><primary>classes</primary>
<secondary>StreamSupplier class</secondary></indexterm>
<para>A subclass of the Supplier class that will provide stream lines using
supplier semantics. This allows the programmer to iterate over the remaining
lines in a stream. A <emphasis role="italic">StreamSupplier</emphasis> object provides a snapshot of the stream
at the point in time it is created, including the current line read position.
In general, the iteration is not affected by later changes to the read and
write positioning of the stream. However, forces external to the iteration may
change the content of the remaining lines as the iteration progresses.
</para>
</section>

<section id="strincl"><title>The <emphasis role="italic">String</emphasis> Class</title>
<indexterm><primary>strings</primary></indexterm>
<indexterm><primary>classes</primary>
<secondary>String class</secondary></indexterm>
<para><emphasis role="italic">String</emphasis>s are data values that can have
any length and contain any characters. They are subject to logical operations
like AND, OR, exclusive OR, and logical NOT. <emphasis role="italic">String</emphasis>s can be concatenated,
copied, reversed, joined, and split. When <emphasis role="italic">String</emphasis>s are numeric, there is the
need to perform arithmetic operations on them or find their absolute value
or convert them from binary to hexadecimal, and vice versa. All this and more
can be accomplished using the <emphasis role="italic">String</emphasis> class of objects.</para>
</section>

<section id="supplcl"><title>The <emphasis role="italic">Supplier</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>Supplier class</secondary></indexterm>
<para>All collections have suppliers. The <emphasis role="italic">Supplier</emphasis> class is used to enumerate
items that a collection contained when the supplier was created. The supplier
gives access to each index/value pair stored in the collection as a sequence.
</para>
</section>

<section id="clsTicker" revisionflag="added"><title>&added50; <emphasis role="italic">Ticker</emphasis> Class</title>
<indexterm><primary>class</primary><secondary>Ticker class</secondary></indexterm>
<para>Provides a repeating notification capability by sending a
notification message to a notification target each trigger interval.
</para>
</section>

<section id="timespancl"><title>The <emphasis role="italic">TimeSpan</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>TimeSpan class</secondary></indexterm>
<para>A <emphasis role="italic">TimeSpan</emphasis> object represents a point in between
<emphasis role="italic">1 January 0001 at 00:00.000000</emphasis>
and <emphasis role="italic">31 December 9999 at 23:59:59.999999</emphasis>.
A <emphasis role="italic">TimeSpan</emphasis> object has methods to allow formatting a date or time in various
formats, as well as allowing arithmetic operations between dates.
</para>
</section>

<section id="clsValidate" revisionflag="added"><title>&added50; <emphasis role="italic">Validate</emphasis> Class</title>
<indexterm><primary>classes</primary><secondary>Validate class</secondary></indexterm>
<para>A class that provides helper methods
to validate arguments being of correct class, logical or numeric type,
or within a numeric range.
</para>
</section>

<section id="clsVariableReference" revisionflag="added"><title>&added50; <emphasis role="italic">VariableReference</emphasis> Class</title>
<indexterm><primary>classes</primary><secondary>VariableReference class</secondary></indexterm>
<para>An object that maintains a reference to a variable, its name and its value.
</para>
</section>

<section id="weakreferencecl"><title>The <emphasis role="italic">WeakReference</emphasis> Class</title>
<indexterm><primary>classes</primary>
<secondary>WeakReference class</secondary></indexterm>
<para>A <emphasis role="italic">WeakReference</emphasis> instance maintains a non-pinning reference to another object. A non-pinning reference
does not prevent an object from getting garbage collected or having its uninit method run when there are
no longer normal references maintained to the object. Once the referenced object is eligible for garbage
collection, the reference inside the <emphasis role="italic">WeakReference</emphasis> instance
will be cleared and the <emphasis role="italic">VALUE</emphasis> method will
return <literal>.nil</literal> on all subsequent calls. <emphasis role="italic">WeakReferences</emphasis>
are useful for maintaining caches of objects without
preventing the objects from being reclaimed by the garbage collector when needed.
</para>
</section>

</section>

<section id="orgcl"><title>Rexx Classes for Organizing Objects</title>
<para>Rexx provides several key classes that form the basis for building class
hierarchies.</para>

<section id="objcl"><title>The <emphasis role="italic">Object</emphasis> Class</title>
<para>Because the root class in the hierarchy
is the <emphasis role="italic">Object</emphasis> class, everything below it is an object.
To interact with each other, objects require their own actions, called methods.
These methods, which encode actions that are needed by all objects, belong
to the <emphasis role="italic">Object</emphasis> class.</para>
<para>Every other class in the hierarchy inherits the methods of the root class.
Inheritance is the handing down of methods from a &quot;parent&quot;
class&mdash;called a superclass&mdash;to
all of its &quot;descendent&quot; classes&mdash;called subclasses. Finally,
instances acquire methods from their own classes. Any method created for the <emphasis role="italic">Object</emphasis>
class is automatically made available to every other class in the hierarchy.</para>
</section>

<section id="classcl"><title>The <emphasis role="italic">Class</emphasis> Class</title>
<para>The <emphasis role="italic">Class</emphasis> class is used for generating new classes. If a class is like a
factory for producing instances, <emphasis role="italic">Class</emphasis> is like a factory
for producing factories. Class is the parent of every
new class in the hierarchy, and these all inherit Class-like characteristics.
Class-like characteristics are methods and related variables, which reside
in Class, to be used by all classes.</para>

<indexterm><primary>metaclasses</primary></indexterm>
<para>A class that can be used to create another class is called a
<emphasis role="italic">metaclass</emphasis> (<xref linkend="meta" />). The <emphasis role="italic">Class</emphasis> class
is unique among Rexx classes in that it is the only metaclass that Rexx provides.
As such, the <emphasis role="italic">Class</emphasis>'s methods not only make
new classes, they make methods for use by the new class and its instances.
They also make methods that only the new class itself can use, but not its
instances. These are called class methods. They give
a new class some power that is denied to its instances.</para>

<para>Because each instance of <emphasis role="italic">Class</emphasis> is another class, that class inherits the
<emphasis role="italic">Class</emphasis>'s instance methods as class methods.  Thus if <emphasis role="italic">Class</emphasis> generates a
Pizza factory instance, the factory-running actions (<emphasis role="italic">Class</emphasis>'s instance methods)
become the class methods of
the Pizza factory. Factory operations are class methods, and any new methods
created to manipulate pizzas would be instance methods:</para>

<figure><title>How Subclasses Inherit Instance Methods from the <emphasis role="italic">Class</emphasis> Class</title>
<indexterm><primary>inheritance</primary></indexterm>
<mediaobject>
<imageobject>
<imagedata fileref="images/SubclassInheritance.svg" align="center" scale="75" />
</imageobject>
</mediaobject>
</figure>

<para>As a programmer, you typically create classes by using directives, rather
than the methods of the <emphasis role="italic">Class</emphasis> class. In particular,
you'll use the <emphasis role="italic">::CLASS</emphasis> directive, described later in this section. The
<emphasis role="italic">::CLASS</emphasis> directive is a kind of Rexx clause that declares class definitions in a
simple, static form in your programs.
</para>
</section>
</section>

<!-- @@ this section was already broken in 4.2; completely removing it for now
<section id="bigpict"><title>Rexx Classes: The Big Picture</title>
<indexterm><primary>classes</primary>
<secondary>provided by Rexx</secondary></indexterm>
<para>The following are the supplied Rexx classes.</para>

<figure float="1">
<title id="meths1">Classes and Inheritance (part 1 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses1.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths2">Classes and Inheritance (part 2 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses2.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths3">Classes and Inheritance (part 3 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses3.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths4">Classes and Inheritance (part 4 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses4.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths5">Classes and Inheritance (part 5 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses5.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths6">Classes and Inheritance (part 6 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses6.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths7">Classes and Inheritance (part 7 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses7.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths8">Classes and Inheritance (part 8 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses8.png" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths9">Classes and Inheritance (part 9 of 9)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ooRexxClasses9.png" scale="90" />
</imageobject>
</mediaobject>
</figure>
</section>
end of removed broken section @@ -->

<section id="created"><title>Creating Your Own Classes Using Directives</title>
<indexterm><primary>directives</primary>
<secondary>creating classes with</secondary></indexterm>
<para> By analyzing your problem in terms of objects, you
can determine what classes need to be created.  You can create a class using
messages or directives. Directives are a new kind of Rexx clause, and they
are preferred over messages because the code is easier to read and understand,
especially in large programs. They also provide an easy way for you to
share your class definitions with others using the PUBLIC option.</para>

<section id="whatdir"><title>What Are Directives?</title>
<indexterm><primary>directives</primary>
<secondary>definition</secondary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>directives</secondary></indexterm>
<indexterm><primary>creating classes</primary></indexterm>
<indexterm><primary>classes</primary>
<secondary>creating with directives</secondary></indexterm>
<para>A Rexx program is made up of one or more executable units. Directives
separate these units, which themselves are Rexx programs.
Rexx processes all directives first to set up any classes, methods, or routines
needed by the program. Then it runs any code that exists before the first
directive. The first directive in a program marks the end of the executable
part of the program. A directive is a kind of clause that begins with a double-colon
(<emphasis role="italic">::</emphasis>) and is non-executable (a directive cannot appear in the expression of
an <emphasis role="italic">INTERPRET</emphasis> instruction, for example).</para>
</section>

<section id="rexdir"><title>The Directives Rexx Provides</title>
<indexterm><primary>directives</primary></indexterm>

<para>The following is a short summary of all the Rexx directives. See the
<citetitle pubwork="book">Open Object Rexx: Reference</citetitle>
for more details on, or examples of, any of these Rexx directives.</para>

<section id="clasdir"><title>The <emphasis role="italic">::CLASS</emphasis> Directive</title>
<indexterm><primary>directives</primary>
<secondary>::CLASS</secondary></indexterm>
<para>You use the <emphasis role="italic">::CLASS</emphasis> directive to create a class. Programs can then use
the new class by specifying it as a Rexx environment symbol (the class name
preceded by a period) in the program. For example, in
<xref linkend="sample" />,
the <emphasis role="italic">Savings</emphasis> class is created using the
<emphasis role="italic">::CLASS</emphasis> directive. A program can then
use the new class by specifying it as an environment symbol, &quot;<literal>.savings</literal>&quot;.</para>

<para>The new class that you create acquires any methods defined by subsequent
<emphasis role="italic">::METHOD</emphasis> directives within the program, until either another <emphasis role="italic">::CLASS</emphasis> directive
or the end of the program is reached.</para>
<para>You can use the <emphasis role="italic">::CLASS</emphasis> directive's <emphasis role="italic">SUBCLASS</emphasis> option to make the new
class the subclass of another. In
<xref linkend="sample" />, the <emphasis role="italic">Savings</emphasis> class
is made a subclass of the <emphasis role="italic">Account</emphasis> class. A subclass inherits instance and
class methods from its specified superclass; in the sample, <emphasis role="italic">Savings</emphasis> inherits
from <emphasis role="italic">Account</emphasis>.</para>
<para>Additional <emphasis role="italic">::CLASS</emphasis> directive options are available for: </para>

<itemizedlist>
<listitem><para>Inheriting instance methods from a specified metaclass
as class methods of the new class (the METACLASS option).
For more information on metaclasses, see
<xref linkend="meta" />.</para></listitem>

<listitem><para>Making the new class available to programs outside its containing Rexx
program (the <emphasis role="italic">PUBLIC</emphasis> option). The outside program must refer to the new class
by using a <emphasis role="italic">::REQUIRES</emphasis> directive.</para></listitem>
<listitem><para>Subclassing the new class to a mixin class in order to inherit its instance
and class methods (the <emphasis role="italic">MIXINCLASS</emphasis> option).</para></listitem>

<listitem><para>Adding the instance and class methods of a mixin class to the new class,
without subclassing it (the <emphasis role="italic">INHERIT</emphasis> option).</para></listitem></itemizedlist>
<para>When you create a new class, it is always a subclass of an existing class.
If you do not specify the <emphasis role="italic">SUBCLASS</emphasis> or
<emphasis role="italic">MIXINCLASS</emphasis> option on the
<emphasis role="italic">::CLASS</emphasis> directive,
the superclass for the new class is the Object class.</para>
<para>Your class definition can be in a file of its own, with no executable code
preceding it. For example, when you define classes and methods to be shared
by several programs, you put the executable code in another file and refer
to the class file using a <emphasis role="italic">::REQUIRES</emphasis> directive.</para>
<para>Rexx processes <emphasis role="italic">::CLASS</emphasis> directives in the order in which they appear, unless
there is a dependency on some later directive's processing. You cannot
create two classes that have the same class name in one program. If several
programs contain classes with the same name, the last <emphasis role="italic">::CLASS</emphasis> directive processed
is used.</para>
</section>

<section id="methdir"><title>The <emphasis role="italic">::METHOD</emphasis> Directive</title>
<indexterm><primary>directives</primary>
<secondary>::METHOD</secondary></indexterm>
<para>The <emphasis role="italic">::CLASS</emphasis> directive is usually followed by a <emphasis role="italic">::METHOD</emphasis> directive, which
is used to create a method for that class and define the method's attributes.
The next directive in the program, or the end of the program, ends the method.</para>
<para>Some classes you define have an <emphasis role="italic">INIT</emphasis> method.
<emphasis role="italic">INIT</emphasis> is called whenever a
<emphasis role="italic">NEW</emphasis> message is sent to a class. The <emphasis role="italic">INIT</emphasis> method must contain whatever code
is needed to initialize the object.</para>
<para>The <emphasis role="italic">::METHOD</emphasis> directive can be used for: </para>

<itemizedlist>
<listitem><para>Creating a class method for the most-recent <emphasis role="italic">::CLASS</emphasis>
directive (the <emphasis role="italic">CLASS</emphasis> option).</para></listitem>

<listitem><para>Creating a private method; that is, a method that
works like a subroutine and can only be activated by the objects of the same type it belongs
to&mdash;otherwise the method is public by default, and any sender can activate
it.</para></listitem>

<listitem><para>Creating a method that can be called while other methods are active on
the same object, as described in
<xref linkend="activat" /> (the <emphasis role="italic">UNGUARDED</emphasis> option).
</para></listitem>
</itemizedlist>
</section>

<section id="attrdir"><title>The <emphasis role="italic">::ATTRIBUTE</emphasis> Directive</title>
<indexterm><primary>directives</primary>
<secondary>::ATTRIBUTE</secondary></indexterm>
<para>A <emphasis role="italic">::CLASS</emphasis> directive can also be followed by <emphasis role="italic">::ATTRIBUTE</emphasis> directives, which
are used to create methods that directly access internal attributes of an object.
For example, the Account class could define</para>
<programlisting>
::attribute balance
</programlisting>

<para>Which would allow the account balance to be set or retrieved.</para>
<programlisting>
  anAccount~balance = 10000     -- set a new account balance
  say anAccount~balance         -- display the current account balance
</programlisting>
<para>The access methods can created as read-only, or given private scope.</para>
</section>

<section id="routdir"><title>The <emphasis role="italic">::ROUTINE</emphasis> Directive</title>
<indexterm><primary>directives</primary>
<secondary>::ROUTINE</secondary></indexterm>
<para>You use the <emphasis role="italic">::ROUTINE</emphasis> directive to create a named routine within a program.
The <emphasis role="italic">::ROUTINE</emphasis> directive starts the named routine and another directive (or
the end of the program) ends the routine.</para>
<para>The <emphasis role="italic">::ROUTINE</emphasis> directive is useful organizing functions that are not specific to
a particular class type.
</para>
<para>The <emphasis role="italic">::ROUTINE</emphasis> directive includes a <emphasis role="italic">PUBLIC</emphasis> option for making the routine
available to programs outside its containing Rexx program. The outside program
must reference the routine by using a <emphasis role="italic">::REQUIRES</emphasis> directive
for the program that contains the routine.</para>
</section>

<section id="requdir"><title>The <emphasis role="italic">::REQUIRES</emphasis> Directive</title>
<indexterm><primary>directives</primary>
<secondary>::REQUIRES</secondary></indexterm>
<para>You use the <emphasis role="italic">::REQUIRES</emphasis> directive when a program needs access to the classes
and objects of another program. This directive has the following form: </para>
<indexterm><primary>directives</primary>
<secondary>::REQUIRES example</secondary></indexterm>
<programlisting>
<![CDATA[
::REQUIRES program_name
]]>
</programlisting>

<para><emphasis role="italic">::REQUIRES</emphasis> directives are processed before other directives and the order
of the <emphasis role="italic">::REQUIRES</emphasis> directives determines the search order for the classes and
routines defined in the named programs.</para>
<para>Local routine or class definitions within a program override routines or
classes imported through <emphasis role="italic">::REQUIRES</emphasis>
directives.
</para>
</section>
</section>

<section id="howdir"><title>How Directives Are Processed</title>
<indexterm><primary>directives</primary>
<secondary>order of processing</secondary></indexterm>
<para>You place a directive (and its method code) after the
program code. When you run a program containing directives, Rexx: </para>
<orderedlist>
<listitem><para>Processes the directives first, to set up the program's classes, methods,
and routines.</para></listitem>
<listitem><para>Runs any program code preceding the first directive. This code can use
any classes, methods, and routines set up by the directives. </para>
<para>Once Rexx
has processed the code preceding the directive, any public classes and objects
the program defines are available to programs having the appropriate <emphasis role="italic">::REQUIRES</emphasis>
directive.</para></listitem></orderedlist>
</section>

<section id="sample"><title>A Sample Program Using Directives</title>
<indexterm><primary>directives</primary>
<secondary>sample program</secondary></indexterm>
<para>Here is a program that uses directives to create new classes and methods: </para>
<example>
<title>Using directives</title>
<programlisting>
<![CDATA[
asav = .savings~new              /* executable code begins */
say asav~type                    /* executable code        */
asav~name= "John Smith"          /* executable code ends   */

::class Account                  /* directives begin ...   */

  ::method type
    return "an account"

  ::attribute name

::class Savings subclass Account

  ::method type
    return "a savings account"   /* ... directives end     */
]]>
</programlisting>
</example>

<indexterm><primary>SUBCLASS option</primary></indexterm>
<para>The preceding program uses the
<emphasis role="italic">::CLASS</emphasis> directive to create two classes, the Account class and its Savings
subclass. In the <computeroutput>::class Account</computeroutput>
expression, the <emphasis role="italic">::CLASS</emphasis> directive
precedes the name of the new class, Account.</para>
<para>The example program also uses the <emphasis role="italic">::METHOD</emphasis>
directive to create a <emphasis role="italic">TYPE</emphasis> method and
<emphasis role="italic">::ATTRIBUTE</emphasis> to create <emphasis role="italic">NAME</emphasis> and
<emphasis role="italic">NAME=</emphasis> methods for Account. In the
<computeroutput>::method type</computeroutput> instruction, the
<emphasis role="italic">::METHOD</emphasis> directive precedes the method name, and is immediately followed by
the code for the method. Methods for any new class follow its <emphasis role="italic">::CLASS</emphasis> directive
in the program, and precede the next <emphasis role="italic">::CLASS</emphasis> directive.</para>
<para>In the <computeroutput>::attribute name</computeroutput>
directive, we're creating a pair of methods.  The <emphasis role="italic">NAME</emphasis> (&quot;getter&quot;) method returns the
current value of the <emphasis role="italic">NAME</emphasis> object variable.
The <emphasis role="italic">NAME=</emphasis> (&quot;setter&quot;) method can assign
a new value to the <emphasis role="italic">NAME</emphasis> object variable.
</para>

<para>You do not have to associate object variables with a specific object. Rexx
keeps track of object variables for you. Whenever you send a message to savings
account <literal>asav</literal>, which points to the Name object, Rexx knows what internal object
value to use. If you assign another value to <literal>asav</literal> (such as &quot;Mary Smith&quot;),
Rexx recovers the object that was associated with <literal>asav</literal> (&quot;John Smith&quot;)
as part of its normal garbage-collection operations.</para>
<para>In the Savings subclass, a second <emphasis role="italic">TYPE</emphasis> method is created that supersedes
the <emphasis role="italic">TYPE</emphasis> method Savings would otherwise have inherited from Account. Note
that the directives appear after the program code.</para>
</section>

<section id="dire"><title>Another Sample Program</title>
<indexterm><primary>directives</primary>
<secondary>sample program</secondary></indexterm>
<indexterm><primary>INIT method</primary></indexterm>
<para>A directive is nonexecutable code that begins with a double colon (<emphasis role="italic">::</emphasis>)
and follows the program code. The <emphasis role="italic">::CLASS</emphasis> directive creates a class; in this
example, the Dinosaur class. The sample provides two methods for the Dinosaur
class, <emphasis role="italic">INIT</emphasis> and <emphasis role="italic">DIET.</emphasis>
These are added to the Dinosaur class using the <emphasis role="italic">::METHOD</emphasis>
directives. After the line containing the <emphasis role="italic">::METHOD</emphasis> directive, the code for
the method is specified. Methods are ended either by the start of the next
directive or by the end of the program.</para>
<para>Because directives must follow the executable code in your program, you
put that code first. In this case, the executable code creates a new dinosaur,
Dino, that is an instance of the Dinosaur class. Rexx then runs the <emphasis role="italic">INIT</emphasis> method.
Rexx runs any <emphasis role="italic">INIT</emphasis> method automatically whenever the <emphasis role="italic">NEW</emphasis> message is received.
Here the <emphasis role="italic">INIT</emphasis> method is used to identify the type of dinosaur. Then the program
runs the <emphasis role="italic">DIET</emphasis> method to determine whether the dinosaur eats meat or vegetables.
Rexx saves the information returned by <emphasis role="italic">INIT</emphasis> and <emphasis role="italic">DIET</emphasis> as variables in the Dino
object.</para>
<para>In the example, the Dinosaur class and its two methods are defined following
the executable program code: </para>
<example>
<title>Defining methods</title>
<programlisting>
<![CDATA[
dino=.dinosaur~new         /* Create a new dinosaur instance and
                                            /* initialize variables */
dino~diet                  /* Run the DIET method          */
exit
]]>
 </programlisting>

<programlisting>
<![CDATA[
::class Dinosaur           /* Create the Dinosaur class  */

  ::method init            /* Create the INIT method     */
    expose type
    say "Enter a type of dinosaur."
    pull type
    return

  ::method diet            /* Create the DIET method     */
    expose type
    select
    when type="T-REX" then string="Meat-eater"
    when type="TYRANNOSAUR" then string="Meat-eater"
    when type="TYRANNOSAURUS REX" then string="Meat-eater"
    when type="DILOPHOSAUR" then string="Meat-eater"
    when type="VELICORAPTOR" then string="Meat-eater"
    when type="RAPTOR" then string="Meat-eater"
    when type="ALLOSAUR" then string="Meat-eater"
    when type="BRONTOSAUR" then string="Plant-eater"
    when type="BRACHIOSAUR" then string="Plant-eater"
    when type="STEGOSAUR" then string="Plant-eater"
    otherwise string="Type of dinosaur or diet unknown"
    end
    say string
    return 0
]]>
</programlisting>
</example>
</section>
</section>

<section id="definei"><title>Defining an Instance</title>
<para>You use the <emphasis role="italic">NEW</emphasis> method to define an instance of the new class,
and then call methods that the instance inherited from its superclass. To
define an instance of the Savings class named &quot;John Smith,&quot; and send
John Smith the <emphasis role="italic">TYPE</emphasis> and <emphasis role="italic">NAME=</emphasis>
messages to call the related methods, you enter: </para>
<programlisting>
<![CDATA[
newaccount = savings~new
say newaccount~type
newaccount~name = "John Smith"
]]>
</programlisting>
</section>

<section id="typcla"><title>Types of Classes</title>
<para>There are four kinds of classes: </para>
<itemizedlist>
<listitem><para>Object classes</para></listitem>
<listitem><para>Mixin classes</para></listitem>
<listitem><para>Abstract classes</para></listitem>
<listitem><para>Metaclasses</para></listitem></itemizedlist>
<para> The following sections explain these.</para>

<section id="objcla"><title>Object Classes</title>
<indexterm><primary>object classes</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>types</secondary>
<tertiary>object</tertiary></indexterm>

<para>An <emphasis><emphasis role="italic">Object</emphasis> class</emphasis> is a factory
for producing objects. An <emphasis role="italic">Object</emphasis> class creates objects (instances) and provides
methods that these objects can use. An object acquires the instance methods
of the class to which it belongs at the time of its creation. If a class gains
additional methods, objects created before the definition of these methods
do not acquire the new or changed methods.</para>
<para>The instance variables within an object are created on demand whenever a method
<emphasis role="italic">EXPOSE</emphasis>s an object variable.  The class creates the object instance, defines the methods
the object has, and the object instance completes the job of constructing the object.
</para>
<para>
The <emphasis role="italic">String</emphasis> class and the
<emphasis role="italic">Array</emphasis> Class
are examples of object classes.</para>
</section>

<section id="xmixin"><title>Mixin Classes</title>
<indexterm><primary>mixin classes</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>types</secondary>
<tertiary>mixin</tertiary></indexterm>
<para>Classes can inherit from more than the single superclass from
which they were created. This is called
<emphasis>multiple inheritance</emphasis>. Classes designed
to add a set of instance and class
methods to other classes are called <emphasis>mixin classes</emphasis>,
or simply mixins.</para>
<para>You can add mixin methods to an existing class by sending an <emphasis role="italic">INHERIT</emphasis>
message or using the <emphasis role="italic">INHERIT</emphasis> option on the <emphasis role="italic">::CLASS</emphasis> directive.
In either case, the class to be inherited must be a mixin. During both class
creation and multiple inheritance, subclasses inherit both class and instance
methods from their superclasses.</para>
<indexterm><primary>base class for mixins</primary></indexterm>
<para>Mixins are always associated
with a <emphasis>base class</emphasis>, which is the mixin's first non-mixin
superclass. Any subclass of the mixin's base class can (directly or indirectly)
inherit a mixin; other classes cannot.  For example, a mixin class created
as a subclass of the Array class can only be inherited by other Array subclasses.
Mixins that use the Object class as a base class can be inherited by any class.
</para>
<para>To create a new mixin class, you send a <emphasis role="italic">MIXINCLASS</emphasis> message to an existing
class or use the <emphasis role="italic">::CLASS</emphasis> directive with the <emphasis role="italic">MIXINCLASS</emphasis> option. A mixin class
is also an object class and can create instances of the class.</para>
</section>

<section id="abscla"><title>Abstract Classes</title>
<indexterm><primary>abstract class, definition</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>types</secondary>
<tertiary>abstract</tertiary></indexterm>
<para><emphasis>Abstract classes</emphasis> provide definitions for instance
methods and class methods
but are not intended to create instances. Abstract classes often define the
message interfaces that subclasses should implement.</para>
<para>You create an abstract class like object or mixin classes. No extra
messages or keywords on the <emphasis role="italic">::CLASS</emphasis> directive are necessary. Rexx does not
prevent users from creating instances of abstract classes.
It is possible to create abstract methods on a class.  An abstract method is a
placeholder that subclasses are expected to override.  Failing to provide a real
method implementation will result in an error when the abstract version is called.
</para>
</section>

<section id="meta"><title>Metaclasses</title>
<indexterm><primary>metaclasses</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>types</secondary>
<tertiary>metaclass</tertiary></indexterm>
<para>A <emphasis>metaclass</emphasis> is a class you
can use to create another class. The only metaclass that Rexx provides is
<literal>.Class</literal>, the <emphasis role="italic">Class</emphasis> class.
The <emphasis role="italic">Class</emphasis> class is the metaclass of all the classes
Rexx provides. This means that instances of <literal>.Class</literal> are themselves classes.
The <emphasis role="italic">Class</emphasis> class is like a factory for producing the factories that produce
objects.</para>
<para>To change the behavior of an object that is an instance, you generally
use subclassing. For example, you can create <emphasis role="italic">statArray</emphasis>, a subclass of the
<emphasis role="italic">Array</emphasis> class.
The <emphasis role="italic">statArray</emphasis> class can include a
method for computing a total of all the numeric elements of an array.</para>
<example>
<title>Creating an <emphasis role="italic">Array</emphasis> subclass</title>
<programlisting>
/* Creating an array subclass for statistics */

::class statArray subclass array public

::method init    /*  Initialize running total and forward to superclass */
  expose total
  total = 0
  forward class (super)

::method put     /*  Modify to increment running total */
  expose total
  use arg value
  total = total + value  /* Should verify that value is numeric!!! */
  forward class (super)

::method "[]="   /*  Modify to increment running total */
  forward message "PUT"

::method remove  /*  Modify to decrement running total */
  expose total
  use arg index
  forward message "AT" continue
  total = total - result
  forward class (super)

::method average /*  Return the average of the array elements */
  expose total
  return total / self~items

::method total   /*  Return the running total of the array elements */
  expose total
  return total
</programlisting>
</example>

<para>You can use this method on the individual array
<emphasis>instances</emphasis>, so it is an
<emphasis>instance method</emphasis>.</para>
<para>However, if you want to change the behavior of the factory producing the
arrays, you need a new class method. One way to do
this is to use the <emphasis role="italic">::METHOD</emphasis> directive with the
<emphasis role="italic">CLASS</emphasis> option. Another way to
add a <emphasis>class</emphasis> method is to create a new metaclass that
changes the behavior
of the <emphasis role="italic">statArray</emphasis> class. A new metaclass is a subclass of .class.</para>
<para>You can use a metaclass by specifying it in a <emphasis role="italic">SUBCLASS</emphasis> or
<emphasis role="italic">MIXINCLASS</emphasis>
message or on a <emphasis role="italic">::CLASS</emphasis> directive with the
<emphasis role="italic">METACLASS</emphasis> option.</para>
<para>If you are adding a highly specialized class method useful only for a
particular class, use the <emphasis role="italic">::METHOD</emphasis> directive
with the <emphasis role="italic">CLASS</emphasis> option. However,
if you are adding a class method that would be useful for many classes, such
as an instance counter that counts how many instances a class creates,
you use a metaclass.</para>
<para>The following examples add a class method that keeps a running total of
instances created. The first version uses the <emphasis role="italic">::METHOD</emphasis> directive with the
<emphasis role="italic">CLASS</emphasis> option. The second version uses a metaclass.</para>
<para><emphasis role="bold">Version 1</emphasis></para>
<indexterm><primary>examples</primary>
<secondary>metaclass</secondary></indexterm>
<example>
<title>Adding a class method</title>
<programlisting>
/* Adding a class method using ::METHOD */

a = .point~new(1,1)               /* Create some point instances  */
say "Created point instance" a
b = .point~new(2,2)               /* create another point instance */
say "Created point instance" b
c = .point~new(3,3)               /* create another point instance */
say "Created point instance" c
                                  /* ask the point class how many */
                                  /* instances it has created     */
say "The point class has created" .point~instances "instances."



::class point public                /* create Point class           */

::method init class
  expose instanceCount
  instanceCount = 0                 /* Initialize instanceCount     */
  forward class (super)             /* Forward INIT to superclass   */

::method new class
  expose instanceCount              /* Creating a new instance      */
  instanceCount = instanceCount + 1 /* Bump the count               */
  forward class (super)             /* Forward NEW to superclass    */

::method instances class
  expose instanceCount              /* Return the instance count    */
  return instanceCount


::method init
  expose xVal yVal                  /* Set object variables         */
  use arg xVal, yVal                /* as passed on NEW             */

::method string
  expose xVal yVal                  /* Use object variables         */
  return "("xVal","yVal")"          /* to return string value       */
</programlisting>

<para><emphasis role="bold">Version 2</emphasis></para>
<programlisting>
/* Adding a class method using a metaclass  */

a = .point~new(1,1)                    /* Create some point instances  */
say "Created point instance" a
b = .point~new(2,2)
say "Created point instance" b
c = .point~new(3,3)
say "Created point instance" c
                                       /* ask the point class how many */
                                       /* instances it has created     */
say "The point class has created" .point~instances "instances."

::class InstanceCounter subclass class /* Create a new metaclass that */
                                       /* will count its instances     */
::method init
  expose instanceCount
  instanceCount = 0                    /* Initialize instanceCount     */
  forward class (super)                /* Forward INIT to superclass   */

::method new
  expose instanceCount                 /* Creating a new instance      */
  instanceCount = instanceCount + 1    /* Bump the count               */
  forward class (super)                /* Forward NEW to superclass    */

::method instances
expose instanceCount                   /* Return the instance count    */
return instanceCount


::class point public metaclass InstanceCounter  /* Create Point class */
                                       /* using InstanceCounter metaclass */
::method init
  expose xVal yVal                     /* Set object variables         */
  use arg xVal, yVal                   /* as passed on NEW             */

::method string
  expose xVal yVal                     /* Use object variables         */
  return "("xVal","yVal")"             /* to return string value       */
</programlisting>
</example>
</section>
</section>
</chapter>
