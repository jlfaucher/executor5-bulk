<!--#########################################################################
    #
    # Description: Open Object Rexx: Programming Guide SGML file.
    #
    # Copyright (c) 2005-2009, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<chapter id="api4x">
<title>Rexx C++ Application Programming Interfaces</title>
<para>This chapter describes how to interface applications to Rexx or extend
the Rexx language by using Rexx C++ application programming interfaces (APIs).
As used here, the term application refers to programs
written in C++.
</para>
<para>The features described here let a C++ application extend many parts of the
Rexx language or extend an application with Rexx. This includes creating handlers
for Rexx methods, external functions, and system exits.</para>
<variablelist>
<varlistentry><term>Rexx methods</term>
<listitem><para>are methods for Rexx classes written in C++. The methods reside in dynamically
loaded external shared libraries.
</para></listitem></varlistentry>
<varlistentry><term>Functions</term>
<listitem><para>are function extensions of the Rexx language written in C++.  Like the native
methods, functions are packaged in external libraries.
Functions can be general-purpose
extensions or specific to an application.
</para></listitem></varlistentry>
<varlistentry><term>Command Handlers</term>
<listitem><para>are programmer-defined handlers for named command environments.
The application programmer can tailor the Rexx interpreter behavior by
creating named command environments to interfacing with
application environments.
</para></listitem></varlistentry>
<varlistentry><term>System exits</term>
<listitem><para>are programmer-defined variations of the interpreter.
The application programmer can tailor the Rexx interpreter behavior by
using the defined exit points to control Rexx resources.
</para></listitem></varlistentry>
</variablelist>
<para>Methods, functions, system exit handlers, and command handlers have similar coding,
compilation, and packaging characteristics.
</para>
<para>In addition, applications can call methods defined of Rexx objects and
execute them from externally defined methods and functions.</para>

<section id="intertreterapi"><title>Rexx Interpreter API</title>
<para>Rexx programs run in an environment controlled by an interpreter instance.
An interpreter instance environment is created with an enable set of exit handlers and
a customized environment.  An instance may have multiple active threads
and each interpreter instance has a unique version of the .local environment
directory, allowing programs to run with some degree of isolation.
</para>
<para>If you use the older <link linkend="rexxstartfu">RexxStart()</link> API to run
a Rexx program, the Rexx environment initializes, runs a single program, and the
environment is terminated.  With the RexxCreateInterpreter() API, you have fine grain
control over how the environment is used.  You are able to create a tailored environment, perform
multiple operations (potentially, on multiple threads), create objects that persist for longer
than the life of a single program, etc.  An application can create an interpreter instance once, and
reuse it to run multiple programs.
</para>
<para>Interpreter environments are created using the
<link linkend="createinterpreter">RexxCreateInterpreter()</link> API:</para>
<programlisting>
RexxInstance *instance;
RexxThreadContext *threadContext;
RexxOption options[25];

if (RexxCreateInterpreter(&amp;instance, &amp;threadContext, options)) {
&hellip;
}
</programlisting>
<para>Once you've created an interpreter instance, you can use the APIs provided by the
RexxInstance or RexxThreadContext interface to perform operations
like running programs, loading class packages, etc.  For example, the following
code will run a program using a created instance, checking for syntax errors upon completion:</para>
<programlisting>
<![CDATA[
    // create an Array object to hold the program arguments
    RexxArrayObject args = threadContext->NewArray(instanceInfo->argCount);
    // we're passing a variable number of arguments, so we need to create
    // String objects and insert them into the array
    for (size_t i = 0; i < argCount; i++)
    {
        if (arguments[i] != NULL)
        {
            // add the argument to the array, if specified.  Note that ArrayPut() requires an
            // index that is origin-1, unlike C arrays which are origin-0.
            threadContext->ArrayPut(args, threadContext->String(arguments[i]), i + 1);
        }
    }

    // call our program, using the provided arguments.
    RexxObjectPtr result = threadContext->CallProgram("myprogram.rex", args);
    // if an error occurred, get the decoded exception information
    if (threadContext->CheckCondition())
    {
        RexxCondition condition;

        // retrieve the error information and get it into a decoded form
        RexxDirectoryObject cond = threadContext->GetConditionInfo();
        threadContext->DecodeConditionInfo(cond, &condition);
        // display the errors
        printf("error %d: %s\n%s\n", condition.code, threadContext->CString(condition.errortext),
           threadContext->CString(condition.message));
    }
    else
    {
        // Copy any return value as a string
        if (result != NULLOBJECT)
        {
            CSTRING resultString = threadContext->CString(result);
            strncpy(returnResult, resultString, sizeof(returnResult));
        }
    }
    // make sure we terminate this first
    instance->Terminate();
]]>
</programlisting>
<para>The example above creates a Rexx String object for each program argument
stores them in a Rexx array.  It then uses
<link linkend="mthCallProgram">CallProgram()</link> to call "myprogram.rex", passing the array object
as the program arguments.  On return, if the program terminated with a Rexx SYNTAX error, it
displays the error message to the console.  Finally, if the program
exited normally and returned a value, the ASCII-Z value of that result is copied to a buffer.  As
a final step, the interpreter instance is destroyed once we're finished using it.</para>
<section id="createinterpreter"><title>RexxCreateInterpreter</title>
<indexterm><primary>application programming interfaces</primary>
<secondary>RexxCreateInterpreter</secondary></indexterm>
<indexterm><primary>RexxCreateInterpreter</primary></indexterm>
<para>RexxCreateInterpreter creates an interpreter instance and an associated
thread context interface for the current thread.</para>
<programlisting>
RexxInstance *instance;
RexxThreadContext *threadContext;
RexxOption options[25];

if (RexxCreateInterpreter(&amp;instance, &amp;threadContext, options)) {
&hellip;
}
</programlisting>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">instance</emphasis></entry>
    <entry><para>The returned RexxInstance interface vector.  The interface
    vector provides access to APIs that apply to the global interpreter environment.</para></entry>
    </row>
    <row><entry><emphasis role="italic">threadContext</emphasis></entry>
    <entry><para>The returned RexxThreadContext interface vector for the thread that creates the
    interpreter instance.  The thread context vector provides access to thread-specific services.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">options</emphasis></entry>
    <entry><para>An array of RexxOption structures that control the interpreter
    instance initialization.  See <link linkend="instanceoptions">Interpreter Instance Options</link> for details on
    the available options.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 (TRUE) if the interpreter instance was successfully created, 0 (FALSE) for any
failure to create the interpreter.</para>
</section>

<section id="instanceoptions"><title>Interpreter Instance Options</title>
<para>The third argument to RexxCreateInterpreter is an options array
that sets characteristics of the interpreter instance.  The
<emphasis role="bold">options</emphasis>
argument points to an array of RexxOption structures, and can be NULL if no options are required.
Each RexxOption instance
contains information for named options that can be specified in any order and even multiple times.
The oorexxapi.h include file
contains a #define for each option name.  The information required by an option
varies with each option type, and is specified using a ValueDescriptor struct to
handle a variety of data types.
An entry with a NULL option
name terminates the option list.  The available interpreter options are:</para>
<variablelist>
<varlistentry><term>INITIAL_ADDRESS_ENVIRONMENT</term>
<listitem><para>Contains the ASCII-Z name of the initial address environment
that will be used for all Rexx programs run under this instance.</para>
<programlisting>
RexxOption options[2];

options[0].optionName = INITIAL_ADDRESS_ENVIRONMENT;
options[0].option = "EDITOR";
options[1].optionName = NULL;
</programlisting>
</listitem></varlistentry>
<varlistentry><term>APPLICATION_DATA</term>
<listitem><para>Contains a void * value that will be stored with the interpreter
instance.  The application data can be retrieved using the
<link linkend="mthGetApplicationData">GetApplicationData()</link> API.  The application
data pointer allows methods, functions, exits, and command handlers to recover
access to globally defined application data.
</para>
<programlisting>
RexxOption options[2];

options[0].optionName = APPLICATION_DATA;
options[0].option = (void *)editorInfo;
options[1].optionName = NULL;
</programlisting>
</listitem></varlistentry>
<varlistentry><term>EXTERNAL_CALL_PATH</term>
<listitem><para>Contains an ASCII-Z string defining an additional search path that
is used when searching for Rexx program files.  The call path string uses the
format appropriate for the host platform environment.  On Windows, the path elements
are separated by semicolons (;).  On Unix-based systems, a colon (:) is used.
</para>
<programlisting>
RexxOption options[2];

options[0].optionName = EXTERNAL_CALL_PATH;
options[0].option = myCallPath;
options[1].optionName = NULL;
</programlisting>
</listitem></varlistentry>
<varlistentry><term>EXTERNAL_CALL_EXTENSIONS</term>
<listitem><para>Contains an ASCII-Z string defining a list of extensions that will
be used when searching for Rexx program files.  The specified extensions must include
the extension ".".  Multiple extensions are separated by a comma (,).
</para>
<programlisting>
RexxOption options[2];

options[0].optionName = EXTERNAL_CALL_EXTENSIONS;
options[0].option = ".ed,.mac";  // add ".ed" and ".mac" to search path.
options[1].optionName = NULL;
</programlisting>
</listitem></varlistentry>
<varlistentry><term>LOAD_REQUIRED_LIBRARY</term>
<listitem><para>Specifies the name of an external native library that will be loaded
once the interpreter instance is created.  The library name is an ASCII-Z string
with the library name in the same format used for ::REQUIRED LIBRARY.  Multiple libraries
can be loaded by specifying this option multiple times.
</para>
<programlisting>
RexxOption options[2];

options[0].optionName = LOAD_REQUIRED_LIBRARY;
options[0].option = "rxmath";
options[1].optionName = NULL;
</programlisting>
</listitem></varlistentry>
<varlistentry><term>DIRECT_EXITS</term>
<listitem><para>Specifies a list of system exits that will be used with this interpreter
instance.  The exits are a list of RexxContextExit structs.  Each enabled exit is
specified in a single RexxContextExit struct that identifies exit type and
handler entry point.
The list is terminated by an instance using an
exit type of 0.  The direct exits are called using the RexxExitContext calling convention.
See <link linkend="exitsapi">Rexx Exits Interface</link> for details.
</para>
<programlisting>

RexxContextExit exits[2];
RexxOption options[2];


exits[0].handler = functionExit;
exits[0].sysexit_code = RXOFNC;
exits[1].sysexit_code = 0;

options[0].optionName = DIRECT_EXITS;
options[0].option = (void *)exits;
options[1].optionName = NULL;
</programlisting>
</listitem></varlistentry>
<varlistentry><term>DIRECT_ENVIRONMENTS</term>
<listitem><para>Registers one or more subcommand handler environments with the interpreter
instance.  The handlers are a list of RexxContextEnvironment structs.  Each enabled handler is
specified in a single RexxContextEnvironment struct identifying the handler name and
entry point.
The list is terminated by an instance using a
handler name of NULL.  The direct environment handlers are called using the calling convention
described in <link linkend="commandapi">Command Handler Interface</link>.
</para>
<programlisting>

RexxContextEnvironment environments[2];
RexxOption options[2];


environments[0].handler = editorHandler;
environments[0].name = "EDITOR";
environments[1].name = NULL;

options[0].optionName = DIRECT_ENVIRONMENTS;
options[0].option = (void *)environments;
options[1].optionName = NULL;
</programlisting>
</listitem></varlistentry>
<varlistentry><term>REGISTERED_EXITS</term>
<listitem><para>Specifies a list of system exits that will be used with this interpreter
instance.  The exits are a list of RexxContextExit structs.  Each enabled exit is
specified in a single RexxContextExit struct identifying the type of the exit and the
name of the registered exit handler.
The list is terminated by an instance using an
exit type of 0.  The registered exits are called using the RexxExitHandler calling convention.
See <link linkend="sysex">Registered System Exits Interface</link> for details.
</para>
<programlisting>

RXSYSEXIT exits[2];
RexxOption options[2];


exits[0].sysexit_name = "MyFunctionExit";
exits[0].sysexit_code = RXOFNC;
exits[1].sysexit_code = 0;

options[0].optionName = REGISTERED_EXITS;
options[0].option = (void *)exits;
options[1].optionName = NULL;
</programlisting>
</listitem></varlistentry>
<varlistentry><term>REGISTERED_ENVIRONMENTS</term>
<listitem><para>Registers one or more subcommand handler environments with the interpreter
instance.  The handlers are a list of RexxRegisteredEnvironment structs.  Each enabled handler is
specified in a single RexxRegisteredEnvironment struct identifying the name of the environment and the
registered subcom handler name.
The list is terminated by an instance using a
handler name of NULL.  The direct environment handlers are called using the calling convention
described in <link linkend="subcom">Subcommand Interface</link>.
</para>
<programlisting>

RexxRegisteredEnvironment environments[2];
RexxOption options[2];


environments[0].registeredName = "MyEditorName";
environments[0].name = "EDITOR";
environments[1].name = NULL;

options[0].optionName = REGISTERED_ENVIRONMENTS;
options[0].option = (void *)environments;
options[1].optionName = NULL;
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="apitypes"><title>Data Types Used in APIs</title>
<para>The ooRexx APIs rely on a variety of special C++ types for interfacing with
the interpreter.  Some of these types are specific to the Rexx language, while
others are standard types defined by C++.  Many of the APIs involve conversion
between types, while others require values of a specific type as arguments.
This section explains the different types and the rules for using these types.
</para>
<section id="objecttypes"><title>Rexx Object Types</title>
<para>Open Object Rexx is fundamentally an object-oriented language.  All data in
the language (including strings and numbers) are represented by object instances.
The ooRexx APIs use a number of opaque types that represent instances
of Rexx built-in objects.  The defined object types are:
</para>
<informaltable frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colnum="1" colwidth="1*">
<colspec colnum="2" colwidth="3*">
<tbody>
<row><entry>RexxObjectPtr</entry>
<entry><para>a reference to a Rexx object instance.  This is the root of object
hierarchy and can represent any type of object.
</para></entry></row>
<row><entry>RexxStringObject</entry>
<entry><para>an instance of the Rexx String class.  The API set allows String objects
to be created and manipulated.
</para></entry></row>
<row><entry>RexxBufferStringObject</entry>
<entry><para>an instance of the Rexx String class that can be written into.
Buffer strings are used for constructing String objects "in-place" to avoid
needing to create a String from a separate buffer.
RexxBufferStringObject instances must be finalized to be converted into a usable
Rexx String object.
</para></entry></row>
<row><entry>RexxArrayObject</entry>
<entry><para>An instance of a Rexx single-dimension array.  Arrays are used
in many places, and there are interfaces provided for direct array manipulation.
</para></entry></row>
<row><entry>RexxDirectoryObject</entry>
<entry><para>An instance of Rexx Directory class.  Like arrays, there are
APIs provided for access and manipulating data stored in a directory.
</para></entry></row>
<row><entry>RexxStemObject</entry>
<entry><para>An instance of the Rexx Stem class.  The APIs include a number of
utility routines for accessing and manipulating data in Stem objects.
</para></entry></row>
<row><entry>RexxSupplierObject</entry>
<entry><para>An instance of the Rexx Supplier class.
</para></entry></row>
<row><entry>RexxClassObject</entry>
<entry><para>An instance of the Rexx Class class.
</para></entry></row>
<row><entry>RexxPackageObject</entry>
<entry><para>An instance of the Rexx Package class.
</para></entry></row>
<row><entry>RexxMethodObject</entry>
<entry><para>An instance of the Rexx Method class.
</para></entry></row>
<row><entry>RexxRoutineObject</entry>
<entry><para>An instance of the Rexx Routine class.  Routine objects
can be invoked directly from C++ code.
</para></entry></row>
<row><entry>RexxPointerObject</entry>
<entry><para>A wrapper around a pointer value.  Pointer objects are designed
for constructing Rexx classes that interface with native code subsystems.
</para></entry></row>
<row><entry>RexxBufferObject</entry>
<entry><para>An allocatable storage object that can be used for storing native
C++ data.  Buffer objects and the contained data are managed using the Rexx object
garbage collector.
</para></entry></row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="numerictypes"><title>Rexx Numeric Types</title>
<para>The Routine and Method interfaces support a very complete set of C numeric types as
arguments and return values.  In addition, there are also APIs provided for converting between
Rexx Objects and numeric types (and the reverse transformation as well).  It is recommended that
you allow the Rexx runtime and APIs to handle conversions between Rexx strings and numeric types to
give behavior consistent with the Rexx built-in methods and functions.
</para>
<para>In addition to a full set of standard numeric types, there are two special types
provided that implement the standard Rexx rules for numbers used internally by Rexx.
These types are:</para>
<informaltable frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colnum="1" colwidth="1*">
<colspec colnum="2" colwidth="4*">
<tbody>
<row><entry>wholenumber_t</entry>
<entry><para>conversions involving the wholenumber_t conform to the Rexx whole number
rules.  Values are converted using the same internal digits value used by the built-in functions.
For 32-bit versions, this is numeric digits 9, giving a range of 999,999,999 to -999,999,999.
On 64-bit systems, numeric digits 18 is used, giving a range of 999,999,999,999,999,999 to
-999,999,999,999,999,999.
</para></entry></row>
<row><entry>stringsize_t</entry>
<entry><para>stringsize_t conversions also conform to the Rexx whole number
rules, with the added restriction that the value must be a non-negative whole number value.  The
stringsize_t type is useful for arguments such as string lengths where only a non-negative value is
allowed.  The range for 32-bit versions is 999,999,999 to 0, and
999,999,999,999,999,999 to 0 on 64-bit platforms.
</para></entry></row>
<row><entry>logical_t</entry>
<entry><para>a Rexx logical value.  On conversion from a string value, this must be
either '1' (true) or '0' (false).  On conversion back to a string value,
a non-zero binary value will be converted
to '1' (true) and zero will become '0' (false).
</para></entry></row>
</tbody>
</tgroup>
</informaltable>
<para>A subset of the integer numeric types are of differing sizes depending on the
addressing mode of the system you are compiling on.  These types will be either 32-bits
or 64-bits.  The variable size types are: </para>
<informaltable frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colnum="1" colwidth="1*">
<colspec colnum="2" colwidth="4*">
<tbody>
<row><entry>size_t</entry>
<entry><para>An unsigned "size" value.  This is the value type returned by pointer subtraction.
</para></entry></row>
<row><entry>ssize_t</entry>
<entry><para>The signed equivalent to size_t.
</para></entry></row>
<row><entry>uintptr_t</entry>
<entry><para>An unsigned integer value that's guaranteed to be the same size as a pointer value.
Use an uintptr_t type if you wish to return a pointer value as a Rexx number.
</para></entry></row>
<row><entry>intptr_t</entry>
<entry><para>A signed equivalent to uintptr_t.
</para></entry></row>
</tbody>
</tgroup>
</informaltable>
<para>The remainder of the numeric types have fixed sizes regardless of the addressing mode.</para>
<informaltable frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colnum="1" colwidth="1*">
<colspec colnum="2" colwidth="4*">
<tbody>
<row><entry>int</entry>
<entry><para>A 32-bit signed integer.
</para></entry></row>
<row><entry>int32_t</entry>
<entry><para>A 32-bit signed integer.  This is equivalent to int.
</para></entry></row>
<row><entry>uint32_t</entry>
<entry><para>An unsigned 32-bit integer.
</para></entry></row>
<row><entry>int64_t</entry>
<entry><para>A signed 64-bit integer.
</para></entry></row>
<row><entry>uint64_t</entry>
<entry><para>An unsigned 64-bit integer.
</para></entry></row>
<row><entry>int16_t</entry>
<entry><para>A signed 16-bit integer.
</para></entry></row>
<row><entry>uint16_t</entry>
<entry><para>An unsigned 16-bit integer.
</para></entry></row>
<row><entry>int8_t</entry>
<entry><para>A signed 8-bit integer.
</para></entry></row>
<row><entry>uint8_t</entry>
<entry><para>An unsigned 8-bit integer.
</para></entry></row>
<row><entry>float</entry>
<entry><para>A 32-bit floating point number.  When used as an
argument to a routine or method, the strings "nan", "+infinity", and
"-infinity" will be converted into the appropriate floating-point values.  The
reverse conversion is used when converting floating-point values back into
Rexx objects.
</para></entry></row>
<row><entry>double</entry>
<entry><para>A 64-bit floating point number.  The Rexx runtime applies the
same special processing for nan, +infinity, and -infinity values as float types.
</para></entry></row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>

<section id="apiconcepts"><title>Introduction to API Vectors</title>
<para>The Rexx APIs operate through a set of interface vectors that define a
set of interpreter services that are available.  There are different interface
vectors used for different contexts, but they use very similar calling concepts.
</para>
<para>The first interface vector you'll encounter with the programming interfaces is
the RexxInstance value returned by RexxCreateInterpreter.  The RexxInstance type is defined
as a struct when compiled for C code, or a C++ class when compiled for ++.  The
struct version looks like this:</para>
<programlisting>
struct RexxInstance_
{
    RexxInstanceInterface *functions;   // the interface function vector
    void *applicationData;              // creator defined data pointer
};
</programlisting>
<para>The field <emphasis role="italic">applicationData</emphasis> contains any
value that was specified via the APPLICATION_DATA option on the RexxCreateInterpreter call.
This provides easy access any application-specific data needed to interact with the interpreter.
All other interface contexts will include a pointer to the RexxInstance structure, so it is
always possible to recover this data pointer.</para>
<para>The <emphasis role="italic">functions</emphasis> field is a pointer to a second structure
that defines the RexxInstance programming interfaces.  The RexxInstance services are ones that
may be called from any thread and in any context.  The services are called using C function pointer
fields in the interface structure.  The RexxInstanceInterface looks like this:</para>
<programlisting>
typedef struct
{
    wholenumber_t interfaceVersion;    // The interface version identifier

    void        (RexxEntry *Terminate)(RexxInstance *);
    logical_t   (RexxEntry *AttachThread)(RexxInstance *, RexxThreadContext **);
    size_t      (RexxEntry *InterpreterVersion)(RexxInstance *);
    size_t      (RexxEntry *LanguageLevel)(RexxInstance *);
    void        (RexxEntry *Halt)(RexxInstance *);
    void        (RexxEntry *SetTrace)(RexxInstance *, logical_t);
} RexxInstanceInterface;
</programlisting>
<para>The first thing to note is the interface struct contains a field named
<emphasis role="italic">interfaceVersion</emphasis>.  The interfaceVersion field
is a version marker that defines the services the called interpreter version supports.
This interface version is incremented any time new functions are added to the interface.
Using the interface version allows application code to reliably check that required
interface functions are available.</para>
<para>The remainder of the fields are functions that can be called to perform RexxInstance
operations.  Note that the first argument to all of the functions is a pointer to a RexxInstance
structure.  A call to the InterpreterVersion API from C code would look like this:</para>
<programlisting>
size_t version = context->functions->InterpreterVersion(context);
</programlisting>
<para>When using C++ code, the RexxThreadContext struct has convenience methods that simplify calling
these functions:</para>
<programlisting>
size_t version = context->InterpreterVersion();
</programlisting>
<para>Note that in the C++ call, it is no longer necessary to pass the RexxInstance as the
first object.  That's handled automatically be the C++ method.</para>
<para>The RexxThreadContext pointer returned from RexxCreateInterpreter() functions the same way.
RexxThreadContext looks like this:</para>
<programlisting>
struct RexxThreadContext_
{
    RexxInstance *instance;             // the owning instance
    RexxThreadInterface *functions;     // the interface function vector
}
</programlisting>
<para>The RexxThreadContext contains an embedded RexxInstance pointer for the instance it is
associated with.  It also contains an interface vector for the functions available with a
RexxThreadContext.  The RexxThreadInterface vector has its own version identifier and
function pointer for each of the defined services.
The RexxThreadContext functions all take a RexxThreadContext pointer as
the first argument.  The RexxThreadContext struct defines C++ convince methods for accessing
its own function and the functions for the RexxInstance as well.  For example, to call
the InterpreterVersion() API from C code, it is necessary to use</para>
<programlisting>
size_t version = context->instance->functions->InterpreterVersion(context->instance);
</programlisting>
<para>The C++ version is simply</para>
<programlisting>
// context is a RexxThreadContext *
size_t version = context->InterpreterVersion();
</programlisting>
<para>When the Rexx interpreter makes calls to native code routines and methods, or invokes
exit handlers, the call-outs use context structures specific to the type of callout.  These
are the RexxCallContext, RexxMethodContext, and RexxExitContext structures.  Each structure
contains a pointer to a RexxThreadContext instance that's valid for the until the call returns.
Because of the embedded RexxThreadContext, each calls may use any of the RexxThreadContext
functions in addition to the functions specific to the call-out type.  Each context defines
C++ methods for the embedded RexxInstance and RexxThreadContext functions.</para>
<para>Note that the RexxInstance interface can be used at any time and on any thread.  The
RexxThreadContext returned by RexxCreateInterpreter() can only be used on the same thread
as the RexxCreateInterpreter() call, but is not valid for use in the context of a method, routine,
or exit call-out.  In those contexts, the RexxThreadContext instance passed to the call-out
must be used.  A RexxThreadContext instance created for a call-out is only valid until the
call returns to the interpreter.</para>
</section>

<section id="instancethread"><title>Threading Considerations</title>
<para>When use RexxCreateInterpreter() to create a new interpreter instance, a RexxThreadContext
pointer is returned with the interpreter instance.  The thread context vector allows
you to perform operations such as running Rexx programs while in the same thread context as the
RexxCreateInterpreter() call.
</para>
<para>A given interpreter instance can process calls from multiple threads, but a RexxThreadContext instance
must be obtained for each additional thread you wish to use.  A new thread context is obtained
by calling AttachThread() using the RexxInstance API vector returned from RexxCreateInterpreter().  Once
a valid RexxThreadContext interface has been created for the thread, any of the operations defined
for a thread context are usable on that thread.  Before the thread terminates,
the <link linkend="mthDetachThread">DetachThread()</link>
API must be called to remove the attached thread from the interpreter instance.</para>
<para>The interpreter is capable of asynchronous calls to interpreter APIs from signal or event
handlers.  When called in this manner, it is possible that AttachThread will be called while
running on a thread that is already attached to the interpreter instance.  When a nested
AttachThread() call is made, the previous thread context is suspended and the newly created
thread context is now the active one for the source thread.  It is very important that
DetachThread() be called to restore the original thread context before you return from
the signal handler.</para>
</section>
<section id="gcmodel"><title>Garbage Collection Considerations</title>
<para>When any context API has a return result that is an instance of a Rexx object,
the source API context will protect that object instance from garbage collection
for as long as the source API context is valid.  Once the API context is destroyed,
the accessed objects might become eligible for garbage collection and be reclaimed
by the interpreter runtime.
These object references are only
valid until the current context is destroyed.  They cannot be stored in native code
control blocks and be used in other thread contexts.  If you wish to store object references so
that they can be accessed in other thread contexts, you can create a globally valid object
reference using the <link linkend="mthRequestGlobalReference">RequestGlobalReference()</link>
API.  A global reference will create a global lock for an object that will protect the
object from the garbage collector until the interpreter instance is terminated.  Protecting
the object will also protect any objects referenced by the protected object.  For example,
using RequestGlobalReference() to protect a Directory object will also protect all of the
directory keys and values.
The global
reference can be used with any API context valid for the same interpreter instance.
Once you are finished with a locked object,
<link linkend="mthReleaseGlobalReference">ReleaseGlobalReference()</link> will remove the
object lock and remove the garbage collection protection.
</para>
<para>On the flip side if this, sometimes it is desirable to remove the local API context
protection of an object.  For example, if you use the ArrayAt() API to iterate through all
of the elements of an Array object, each object returned by ArrayAt() will be added to the
API context's protection tables.  There is a small overhead associated with each reference
that is protected by the context, so iterating through a large array would accumulate that
overhead for each element of the array.  Using ReleaseLocalReference() on an object reference you are no longer using will
remove the local lock, and thus limit the overhead.
</para>
</section>

<section id="instanceapi"><title>Rexx Interpreter Instance Interface</title>
<para>The Interpreter Instance API is defined by the RexxInstance interface vector.  The RexxInstance
defines methods that affect the global state of the interpreter instance.  Most of the instance APIs
call be called from any thread without requiring any extra steps to access the instance.
The two most important instance operations are <link linkend="mthAttachThread">AttachThread()</link> and
<link linkend="mthTerminate">Terminate()</link>.  AttachThread()
allows additional externally identified threads to be included
in the interpreter instance threadpool.  AttachThread returns a
<link linkend="threadcontext">RexxThreadContext</link> interface vector
that enables a wider range of capability for the attached thread.
The Terminate() API shuts down an interpreter instance when it is no longer needed.
</para>
</section>

<section id="threadcontext"><title>Rexx Thread Context Interface</title>
<para>The RexxThreadContext interface vector provides a very wide range of functions
to your application code.  There are roughly 125 functions defined on a RexxThreadContext.
Among the services provide are:
</para>
<itemizedlist>
<listitem><para>Running Rexx programs</para></listitem>
<listitem><para>Loading Rexx packages</para></listitem>
<listitem><para>Invoking methods of Rexx objects</para></listitem>
<listitem><para>Converting between objects and various C++ types</para></listitem>
<listitem><para>Creating and manipulating some common Rexx object types</para></listitem>
<listitem><para>Raising/handling Rexx syntax errors</para></listitem>
</itemizedlist>
<para>The C++ methods defined on a RexxThreadContext C++ object include the methods defined
by the <link linkend="instanceapi">RexxInstance</link> class,
so the single context vector is used to access both thread context
and interpreter instance APIs.</para>
<para>A RexxThreadContext instance is returned with the original
<link linkend="createinterpreter">RexxCreateInterpreter()</link> call that create the
interpreter instance.  The <link linkend="mthAttachThread">AttachThread()</link> method
will create a RexxThreadContext instance for additional threads that you add to an interpreter
instance.  Additionally, the <link linkend="methodcontext">RexxMethodContext</link>,
<link linkend="callcontext">RexxCallContext</link>,
and <link linkend="exitcontext">RexxExitContext</link>
objects embed a RexxThreadContext object the same way that a RexxThreadContext object embeds
a RexxInstance object.</para>
</section>

<section id="methodcontext"><title>Rexx Method Context Interface</title>
<para>A RexxMethodContext object is included as an argument
to any <link linkend="methodapi">native C++ method</link>
defined in external libraries.  The method context provides services that are specific to
a method call, including:
</para>
<itemizedlist>
<listitem><para>Accessing method-specific values such as SELF, SUPER, etc.</para></listitem>
<listitem><para>Manipulating object instance variables</para></listitem>
<listitem><para>Forwarding messages</para></listitem>
<listitem><para>Manipulating GUARD state</para></listitem>
<listitem><para>Locating classes defined in the method's package scope</para></listitem>
</itemizedlist>
<para>In addition to the method-specific functions, the RexxMethodContext object has an embedded
a <link linkend="threadcontext">RexxThreadContext</link>
object created specifically for this environment.  The RexxThreadContext provides approximately 125
additional methods to the method environment.</para>
</section>

<section id="callcontext"><title>Rexx Call Context Interface</title>
<para>A RexxCallContext object is included as an argument to any
<link linkend="functionapi">native C++ routine</link>
defined in external libraries.  The method context provides services that are specific to
a routine call, including:
</para>
<itemizedlist>
<listitem><para>Accessing caller context specific values such as the current numeric settings</para></listitem>
<listitem><para>Manipulating variables in the caller's variable context</para></listitem>
<listitem><para>Locating classes defined in the routine's package scope</para></listitem>
</itemizedlist>
<para>In addition to the method-specific functions, the RexxCallContext object has an embedded
a <link linkend="threadcontext">RexxThreadContext</link>
object created specifically for this environment.  The RexxThreadContext provides approximately 125
additional methods to the method environment.</para>
</section>

<section id="exitcontext"><title>Rexx Exit Context Interface</title>
<para>A RexxExitContext object is included as an argument to any
<link linkend="contextexitdef">system exit</link> or
<link linkend="commandapi">command handler</link>.
The exit context provides services that are specific to
a exit call, including:
</para>
<itemizedlist>
<listitem><para>Accessing caller context specific values such as the current numeric settings</para></listitem>
<listitem><para>Manipulating variables in the caller's variable context</para></listitem>
</itemizedlist>
<para>In addition to the exit-specific functions, the RexxExitContext object has an embedded
a <link linkend="threadcontext">RexxThreadContext</link>
object created specifically for this environment.  The RexxThreadContext provides approximately 125
additional methods to the method environment.</para>
</section>

<section id="buildinglibs"><title>Building an External Native Library</title>
<para>External libraries written in compiled languages (typically C or C++)
provide a means to
interface Rexx programs with other subsystems intended for compile languages.
These libraries are packaged as Dynamic Link Libraries on Windows or shared libraries on
Unix-based systems.
A named library can be loaded using the ::REQUIRES directive, the
loadLibrary method on the Package class, or by using the EXTERNAL keyword on
a ::ROUTINE or ::METHOD directive.
</para>
<para>When the library is loaded, the interpreter looks for an entry point
in the library named RexxGetPackage().  An external library package is required
to provide a RexxGetPackage() function that returns a pointer to a descriptor
structure that defines the methods and routines contained within the library.
The RexxGetPackage() routine takes no arguments and has a return value of
RexxPackageEntry *.  This is normally created using the OOREXX_GET_PACKAGE()
macro defined in the oorexxapi.h include file.</para>
<programlisting>
// package loading stub.
OOREXX_GET_PACKAGE(package);
</programlisting>
<para>Where <emphasis role="italic">package</emphasis> is the name
of the RexxPackageEntry table defined for this library.  The package
entry table is a descriptor what is contained within the library.
Note that on Windows, it is necessary to explicitly export the
RexxPackageEntry() function when the library is linked.  This is the
only name that it's necessary to export.</para>
<para>The RexxPackageEntry structure contains information about the
package and descriptors of any methods and/or routines defined within
the package.  The structure looks like this:</para>
<programlisting>
typedef struct _RexxPackageEntry
{
    int size;                      // size of the structure...helps compatibility
    int apiVersion;                // version this was compiled with
    int requiredVersion;           // minimum required interpreter version (0 means any)
    const char *packageName;       // package identifier
    const char  *packageVersion;   // package version #
    RexxPackageLoader loader;      // the package loader
    RexxPackageUnloader unloader;  // the package unloader
    struct _RexxRoutineEntry *routines; // routines contained in this package
    struct _RexxMethodEntry *methods;   // methods contained in this package
} RexxPackageEntry;
</programlisting>
<para>The fields in the RexxPackageEntry have the following functions:</para>
<variablelist>
<varlistentry><term>size and apiVersion</term>
<listitem><para>these fields give the size of the received table and identify
the interpreter level this library has been compiled against.  These indicators
will allow additional information to be added to the RexxPackageEntry in the future
which out causing compatibility issues for older libraries.  Normally, these two
fields are defined using the STANDARD_PACKAGE_HEADER macro, which will fill in
both values.
</para></listitem></varlistentry>
<varlistentry><term>requiredVersion</term>
<listitem><para>a library can specify the minimum interpreter level required by this
library.  The interpreter will only load libraries that match the minimum compatibility
requirement of the library package.  A zero value in this field means there's no
minimum level requirement.  The macro REXX_CURRENT_INTERPRETER_VERSION will use
the level of interpreter you are compiling against.  If REXX_CURRENT_INTERPRETER_VERSION
is specified, then the library package will not load with previous releases.  The
API header files will be updated with a macro for each interpreter version.  The
version macros are of the form
REXX_INTERPRETER_<emphasis role="italic">version</emphasis>_<emphasis role="italic">level</emphasis>_<emphasis role="italic">revision</emphasis>,
where <emphasis role="italic">version</emphasis>, <emphasis role="italic">level</emphasis>,
and <emphasis role="italic">revision</emphasis> refer to the corresponding values in an
interpreter release number.  For example, REXX_INTERPRETER_4_0_0 would indicate that the
4.0.0 interpreter level is the minimum required for the package.
</para></listitem></varlistentry>
<varlistentry><term>packageName</term>
<listitem><para>a descriptive name for this library package.
</para></listitem></varlistentry>
<varlistentry><term>packageVersion</term>
<listitem><para>a version string for this package.  The version can be
in whatever form is appropriate for the package.
</para></listitem></varlistentry>
<varlistentry><term>packageLoader</term>
<listitem><para>a function that will be called when the library package is
first loaded by the interpreter.  The package loader function is passed a
RexxThreadContext pointer, which will give the package access to Rexx
interpreter services at initialization time.  The package loader is optional
and is indicated by a NULL value in the descriptor.
</para></listitem></varlistentry>
<varlistentry><term>packageUnloader</term>
<listitem><para>a function that will be called when the library package is
unloaded by the interpreter.  The unloading process happens when the last
interpreter instance is destroyed during the last cleanup stages.  This gives
the loaded library an opportunity to clean up any global resources such as
cached Rexx object references.
The package loader is optional
and is indicated by a NULL value in the descriptor.
</para></listitem></varlistentry>
<varlistentry><term>routines</term>
<listitem><para>a pointer to an array of RexxRoutineEntry structures that define
the routines provided by this package.  If there are no routines, NULL should
be specified.
See <link linkend="functionapi">Defining Library Routines</link> for details on
creating the exported routine table.
</para></listitem></varlistentry>
<varlistentry><term>method</term>
<listitem><para>a pointer to an array of RexxMethodEntry structures that define
the methods provided by this package.  If there are no methods, NULL should
be specified.
See <link linkend="methodapi">Defining Library Methods</link> for details on
creating the exported method table.
</para></listitem></varlistentry>
</variablelist>
<para>Here is an example of a RexxPackageEntry table taken from the rxmath
library package:</para>
<programlisting>
// now build the actual entry list
RexxRoutineEntry rxmath_functions[] =
{
    REXX_TYPED_ROUTINE(MathLoadFuncs, MathLoadFuncs),
    REXX_TYPED_ROUTINE(MathDropFuncs, MathDropFuncs),
    REXX_TYPED_ROUTINE(RxCalcPi,      RxCalcPi),
    REXX_TYPED_ROUTINE(RxCalcSqrt,    RxCalcSqrt),
    REXX_TYPED_ROUTINE(RxCalcExp,     RxCalcExp),
    REXX_TYPED_ROUTINE(RxCalcLog,     RxCalcLog),
    REXX_TYPED_ROUTINE(RxCalcLog10,   RxCalcLog10),
    REXX_TYPED_ROUTINE(RxCalcSinH,    RxCalcSinH),
    REXX_TYPED_ROUTINE(RxCalcCosH,    RxCalcCosH),
    REXX_TYPED_ROUTINE(RxCalcTanH,    RxCalcTanH),
    REXX_TYPED_ROUTINE(RxCalcPower,   RxCalcPower),
    REXX_TYPED_ROUTINE(RxCalcSin,     RxCalcSin),
    REXX_TYPED_ROUTINE(RxCalcCos,     RxCalcCos),
    REXX_TYPED_ROUTINE(RxCalcTan,     RxCalcTan),
    REXX_TYPED_ROUTINE(RxCalcCotan,   RxCalcCotan),
    REXX_TYPED_ROUTINE(RxCalcArcSin,  RxCalcArcSin),
    REXX_TYPED_ROUTINE(RxCalcArcCos,  RxCalcArcCos),
    REXX_TYPED_ROUTINE(RxCalcArcTan,  RxCalcArcTan),
    REXX_LAST_ROUTINE()
};

RexxPackageEntry rxmath_package_entry =
{
    STANDARD_PACKAGE_HEADER
    REXX_INTERPRETER_4_0_0,              // anything after 4.0.0 will work
    "RXMATH",                            // name of the package
    "4.0",                               // package information
    NULL,                                // no load/unload functions
    NULL,
    rxmath_functions,                    // the exported functions
    NULL                                 // no methods in rxmath.
};

// package loading stub.
OOREXX_GET_PACKAGE(rxmath);
</programlisting>

<section id="functionapi"><title>Defining Library Routines</title>
<para>The RexxRoutineEntry table defines routines that are exported by a library package.
This table is an array of RexxRoutineEntry structures, terminated by an entry that
contains nothing but zero values in the fields.  The REXX_LAST_ROUTINE() macro
will generate a suitable table terminator entry.
</para>
<para>The remainder of table will be entries generated via either the
REXX_CLASSIC_ROUTINE() or REXX_TYPED_ROUTINE() macros.  REXX_CLASSIC_ROUTINE()
entries are for routines created using the older string-oriented function style.
The classic routines allow packages to be migrated to the new package loading system
without requiring a rewrite of all of the contained functions.
See <link linkend="os2xfun">External Function Interface</link> for details on
creating the functions in the classic style.</para>
<para>Routine table entries defined using REXX_TYPED_ROUTINE() use the new
object-oriented interfaces for creating routines.  These routines can use
the interpreter runtime to convert call arguments from Rexx objects into primitive
types and return values from primitive types back into Rexx objects.  These
routines are also given access to a rich set of services via the RexxCallContext
interface vector.</para>
<para>The REXX_CLASSIC_ROUTINE() and REXX_TYPED_ROUTINE() macros take two arguments.  The
first entry is the package table name for this routine.  The second argument is the
entry point name of the real native code routine that implements the function.
These names are frequently the same, but need not be.</para>
<para>Smaller function packages frequently place all of the contained functions
and the package definition tables in the same file, with the package tables
placed near the end of the source file so all of the functions are visible.  For
larger packages, it may be desirable to place the functions in more than
one source file.  For functions packaged as multiple source files, it is necessary
to create a prototype declarations so the routine entry table can be generated.
The oorexxapi.h header file includes REXX_CLASSIC_ROUTINE_PROTOTYPE() and
REXX_TYPED_ROUTINE_PROTOTYPE() macros to generate the appropriate declarations.
For example,</para>
<programlisting>
// create function declarations for the linker
REXX_TYPED_ROUTINE(RxCalcPi);
REXX_TYPED_ROUTINE(RxCalcSqrt);

// now build the actual entry list
RexxRoutineEntry rxmath_functions[] =
{
    REXX_TYPED_ROUTINE(RxCalcPi,      RxCalcPi),
    REXX_TYPED_ROUTINE(RxCalcSqrt,    RxCalcSqrt),
    REXX_LAST_ROUTINE()
};
</programlisting>

<section id="routinedcl"><title>Routine Declarations</title>
<para>Library routines are created using a series of macros that
create the body of the function.  These macros define the routine
arguments and return value in a form that allows the Rexx runtime
to perform argument checking and conversions before calling the
target routine.
These macros are named "RexxRoutine<emphasis role="italic">n</emphasis>, where
<emphasis role="italic">n</emphasis> is the number of arguments you wish to
be passed to your routine.  For example,</para>
<programlisting>
RexxRoutine2(int, beep, wholenumber_t, frequency, wholenumber_t, duration)
{
    return Beep(frequency, duration);  /* sound beep                 */
}
</programlisting>
<para>defines a <emphasis role="italic">beep</emphasis> routine that will be
passed two <emphasis role="italic">wholenumber_t</emphasis> arguments
(<emphasis role="italic">frequency</emphasis>
and <emphasis role="italic">duration</emphasis>).
The return value is an <emphasis role="italic">int</emphasis> value.
</para>
<para>An argument can be made optional by prefixing the type with "OPTIONAL_".  For example,</para>
<programlisting>
RexxRoutine2(int, beep, wholenumber_t, frequency, OPTIONAL_wholenumber_t, duration)
{
    return Beep(frequency, duration);  /* sound beep                 */
}
</programlisting>
<para>would define a routine that takes two arguments.  The first argument is required, but the
second is optional.  Any optional arguments will be passed using an appropriate zero
value for the type.  The macros argumentExists(n) or argumentOmitted(n) can reliably test if
an argument was passed.  For example, argumentExists(2) tests if the
<emphasis role="italic">duration</emphasis> argument was specified when calling the beep() routine.
The <emphasis role="italic">n</emphasis> value is origin 1.</para>
<para>In addition to the arguments passed by the caller, there are some special argument types
that provide your routine with additional information.  These special types will add
additional arguments to your native routine implementation.
The argument value specified with argumentExists() or argumentOmitted() maps to the
arguments passed to your C++ routine rather than the arguments in the originating Rexx call.
See below for details on the special argument types.
</para>
<para>All routine declarations have an undeclared special argument passed to the routine.  This
special argument is named <emphasis role="italic">context</emphasis>.  The
<emphasis role="italic">context</emphasis> is a pointer to a RexxCallContext value and
provides access to all APIs that are valid from a routine context.</para>
<note><title>Note</title><para>
void is not a valid return type for a routine.  There must be a real return
type specified on the routine declaration.  If you wish to have a routine without
a return value, declare the routine with a return type of RexxObjectPtr and
return the value NULLOBJECT.  Routines that do not return a real value may not
be invoked as functions.  Only the CALL instruction allows a return without a
value.
</para></note>
</section>

<section id="routinetypes"><title>Routine Argument Types</title>
<para>A routine argument or return value may be a
<link linkend="numerictypes">numeric type</link> or an
<link linkend="objecttypes">object type</link>.  For numeric types,
the call arguments must be convertible from a Rexx object equivalent into the
primitive value or an error will be raised.  For optional numeric arguments, a zero
value is passed for omitted values.  When used as a return type, the
numeric values are translated into an appropriate Rexx object value.
</para>
<para>If an argument is an object type, some additional validation is performed
on the arguments being passed.  If an argument does not meet the requirements for
a given object type, an error will be raised.  If an object-type argument is
optional and a value is not specified on the call, the value NULLOBJECT is
passed to your routine.
The supported object types and the special processing
rules are as follows:</para>
<variablelist>
<varlistentry><term>RexxObjectPtr</term>
<listitem><para>a reference to any Rexx object instance.  Any arbitrary object type may
be passed for a RexxObjectPtr argument.
</para></listitem></varlistentry>
<varlistentry><term>RexxStringObject</term>
<listitem><para>an instance of the Rexx String class.  The argument value must be
a Rexx String value or convertible to a Rexx String value using the request('String')
mechanism.
</para></listitem></varlistentry>
<varlistentry><term>RexxArrayObject</term>
<listitem><para>An instance of a Rexx single-dimension array.
</para></listitem></varlistentry>
<varlistentry><term>RexxClassObject</term>
<listitem><para>An instance of Rexx Class class.
</para></listitem></varlistentry>
<varlistentry><term>RexxStemObject</term>
<listitem><para>An instance of Rexx Stem class.  For routine calls, a stem argument
may be specified either using the stem variable name directly or giving the stem
variable name as a quoted string.  For example, for a routine defined using</para>
<programlisting>
RexxRoutine1(int, MyRoutine, RexxStemObject, stem)
</programlisting>
<para>the following calls are equivalent:</para>
<programlisting>
x = MyRoutine(a.)
x = MyRoutine('a.')
</programlisting>
<para>This special processing allows routines that currently access
stem variables using the RexxVariablePool API to be more easily converted to the
more capable API set.
</para></listitem></varlistentry>
</variablelist>
<para>In addition to the numeric and object types, there are additional special
types that provide additional information to the calling routine or perform common
special conversions on argument values.  The special types available to routines are:</para>
<variablelist>
<varlistentry><term>CSTRING</term>
<listitem><para>The argument is passed as an ASCII-Z string.  The source argument must be
one that is valid as a RexxStringObject value.  The RexxStringObject is converted into a
 pointer to an ASCII-Z string.  This is equivalent to the value returned from the
<link linkend="mthObjectToStringValue">StringValue() API</link>
from a RexxStringObject value.  For an optional CSTRING argument, a NULL pointer
is provided when the argument is omitted.</para>
<para>When CSTRING is used as a return value, the ASCII-Z string value will be
converted into a Rexx String object.  CSTRING return values are best confined to
returning C literal values.
The Rexx runtime does not free any
memory associated with a CSTRING return value, so care must be taken to avoid
memory leaks.  Also, locally declared character buffers cannot be returned as
the storage associated with buffer is no longer valid once your routine returns to
the Rexx interpreter.  For example, the following is not valid:</para>
<programlisting>
RexxRoutine0(CSTRING, MyRoutine)
{
   ....
   char buffer[32];
   sprintf(buffer, "%d:%d", major, minor);
   return buffer;     // buffer is not valid once return executes
}
</programlisting>
<para>A RexxStringObject return value and the String() API is more appropriate in this
situation.</para>
<programlisting>
RexxRoutine0(RexxStringObject, MyRoutine)
{
   ....
   char buffer[32];
   sprintf(buffer, "%d:%d", major, minor);
   return context->String(buffer);     // creates a string object and returns it.
}
</programlisting>
</listitem></varlistentry>
<varlistentry><term>POINTER</term>
<listitem><para>an "unwrapped" Pointer or Buffer string object.  If the argument is a
Pointer object, the wrapped pointer value is returned as a void * value..  If the argument is a Buffer object,
then a pointer to buffer's storage area is returned.  A NULL pointer is returned for
an omitted optional POINTER argument.</para>
<para>When POINTER is used as a routine return value, any pointer value can be
returned.  The Rexx runtime will wrap the pointer value in a Rexx Pointer object.
</para></listitem></varlistentry>
<varlistentry><term>POINTERSTRING</term>
<listitem><para>a pointer value that has been encoded in string form.  The string value must
be in the format "0xnnnnnnnn", where the digits are valid hexadecimal digits.  On 64-bit platforms,
the pointer value must be 16 digits long.  The string value is converted into a void * value.
A NULL pointer is returned for
an omitted optional POINTERSTRING argument.</para>
<para>When POINTERSTRING is used as a routine return value, any pointer value can be
returned.  The Rexx runtime will convert the pointer value back into an encoded string value.
</para></listitem></varlistentry>
<varlistentry><term>NAME</term>
<listitem><para>The name of the invoked routine, passed as a CSTRING.  NAME is not valid as a
return value.
</para></listitem></varlistentry>
<varlistentry><term>ARGLIST</term>
<listitem><para>A RexxArrayObject containing all arguments passed to the routine.  This is
equivalent to using Arg(1, 'A') from Rexx code.  The returned array contains all of the routine
arguments that were specified in the original call.  Omitted arguments are empty slots in the
returned array.  In addition, if a routine has an ARGLIST argument specified, the normal
check for the maximum number of arguments is bypassed.  This makes possible routines with an
open-ended number of arguments.
ARGLIST is not valid as a return value.
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="methodapi"><title>Defining Library Methods</title>
<para>The RexxMethodEntry table defines method that are exported by a library package.
This table is an array of RexxMethodEntry structures, terminated by an entry that
contains nothing but zero values in the fields.  The REXX_LAST_METHOD() macro
will generate a suitable table terminator entry.
</para>
<para>The remainder of table will be entries generated via
the REXX_TYPED_METHOD() macro.
Routine table entries defined using REXX_TYPED_METHOD() use the
object-oriented interfaces for creating methods that can be defined on Rexx classes.
These methods can use
the interpreter runtime to convert call arguments from Rexx objects into primitive
types and return values from primitive types back into Rexx objects.  Native
methods are also given access to a rich set of services via the RexxMethodContext
interface vector.</para>
<para>The REXX_TYPED_METHOD() macro take two arguments.  The
first entry is the package table name for this method.  The second argument is the
entry point name of the real native code method that implements the function.
These names are frequently the same, but need not be.</para>
<para>Smaller function packages frequently place all of the contained functions
and the package definition tables in the same file, with the package tables
placed near the end of the source file so all of the methods are visible.  For
larger packages, it may be desirable to place the methods in more than
one source file.  For libraries packaged as multiple source files, it is necessary
to create a prototype declarations so the method entry table can be generated.
The oorexxapi.h header file includes
a REXX_TYPED_METHOD_PROTOTYPE() macro to generate the appropriate declarations.
For example,</para>
<programlisting>
// create function declarations for the linker
REXX_TYPED_METHOD(point_init);
REXX_TYPED_METHOD(point_add);

// now build the actual entry list
RexxMethodEntry point_methods[] =
{
    REXX_TYPED_METHOD(point_init, point_init),
    REXX_TYPED_METHOD(point_add,  point_add),
    REXX_LAST_METHOD()
};
</programlisting>

<section id="methoddcl"><title>Method Declarations</title>
<para>Library methods are created using a series of macros that
create the body of the method.  These macros define the method
arguments and return value in a form that allows the Rexx runtime
to perform argument checking and conversions before calling the
target method.
These macros are named "RexxMethod<emphasis role="italic">n</emphasis>, where
<emphasis role="italic">n</emphasis> is the number of arguments you wish to
be passed to your method.  For example,</para>
<programlisting>
RexxMethod2(int, beep, wholenumber_t, frequency, wholenumber_t, duration)
{
    return Beep(frequency, duration);  /* sound beep                 */
}
</programlisting>
<para>defines a <emphasis role="italic">beep</emphasis> method that will be
passed two <emphasis role="italic">wholenumber_t</emphasis> arguments
(<emphasis role="italic">frequency</emphasis>
and <emphasis role="italic">duration</emphasis>).
The return value is an <emphasis role="italic">int</emphasis> value.
</para>
<para>An argument can be made optional by prefixing the type with "OPTIONAL_".  For example,</para>
<programlisting>
RexxMethod2(int, beep, wholenumber_t, frequency, OPTIONAL_wholenumber_t, duration)
{
    return Beep(frequency, duration);  /* sound beep                 */
}
</programlisting>
<para>would define a method that takes two arguments.  The first argument is required, but the
second is optional.  Any optional arguments will be passed using an appropriate zero
value for the type.  The macros argumentExists(n) or argumentOmitted(n) can reliably test if
an argument was passed.  For example, argumentExists(2) tests if the
<emphasis role="italic">duration</emphasis> argument was specified when calling the beep() method.
The <emphasis role="italic">n</emphasis> value is origin 1.</para>
<para>In addition to the arguments passed by the caller, there are some special argument types
that provide your routine with additional information.  These special types will add
additional arguments to your native routine implementation.
The argument position specified with argumentExists() or argumentOmitted() maps to the
arguments passed to your C++ routine rather than the arguments in the originating Rexx call.
See below for details on the special argument types.
</para>
<para>All method declarations have an undeclared special argument passed to the routine.  This
special argument is named <emphasis role="italic">context</emphasis>.  The
<emphasis role="italic">context</emphasis> is a pointer to a RexxMethodContext value and
provides access to all APIs that are valid from a method context.</para>
<note><title>Note</title><para>
void is not a valid return type for a method.  There must be a real return
type specified on the method declaration.  If you wish to have a method without
a return value, declare the method with a return type of RexxObjectPtr and
return the value NULLOBJECT.  Methods that do not return a real value may not
be invoked within expression, but must be used as standalone method instructions.
</para></note>
</section>

<section id="methodtypes"><title>Method Argument Types</title>
<para>A method argument or return value may be a
<link linkend="numerictypes">numeric type</link> or an
<link linkend="objecttypes">object type</link>.  For numeric types,
the arguments must be convertible from a Rexx object equivalent into the
primitive value or an error will be raised.  For optional numeric arguments, a zero
value is passed for omitted values.  When used as a return type, the
numeric values are translated into an appropriate Rexx object value.
</para>
<para>If an argument is an object type, some additional validation is performed
on the arguments being passed.  If an argument does not meet the requirements for
a given object type, an error will be raised.  If an object-type argument is
optional and a value is not specified on the call, the value NULLOBJECT is
passed to your routine.
The supported object types and the special processing
rules are as follows:</para>
<variablelist>
<varlistentry><term>RexxObjectPtr</term>
<listitem><para>a reference to any Rexx object instance.  Any arbitrary object type may
be passed for a RexxObjectPtr argument.
</para></listitem></varlistentry>
<varlistentry><term>RexxStringObject</term>
<listitem><para>an instance of the Rexx String class.  The argument value must be
a Rexx String value or convertible to a Rexx String value using the request('String')
mechanism.
</para></listitem></varlistentry>
<varlistentry><term>RexxArrayObject</term>
<listitem><para>An instance of a Rexx single-dimension array.
</para></listitem></varlistentry>
<varlistentry><term>RexxClassObject</term>
<listitem><para>An instance of Rexx Class class.
</para></listitem></varlistentry>
<varlistentry><term>RexxStemObject</term>
<listitem><para>An instance of Rexx Stem class.  For method calls, a stem argument
must be specified using a stem variable name directly.
For example, for a method defined using</para>
<programlisting>
RexxMethod1(int, MyMethod, RexxStemObject, stem)
</programlisting>
<para>the following call passes a stem object associated with a stem variable to the method:</para>
<programlisting>
x = o~myMethod(a.)
</programlisting>
</listitem></varlistentry>
</variablelist>
<para>In addition to the numeric and object types, there are additional special
types that provide additional information to the calling routine or perform common
special conversions on argument values.  The special types available to routines are:</para>
<variablelist>
<varlistentry><term>CSTRING</term>
<listitem><para>The argument is passed as an ASCII-Z string.  The source argument must be
one that is valid as a RexxStringObject value.  The RexxStringObject is converted into a
 pointer to an ASCII-Z string.  This is equivalent to the value returned from the
<link linkend="mthObjectToStringValue">StringValue() API</link>
from a RexxStringObject value.  For an optional CSTRING argument, a NULL pointer
is provided when the argument is omitted.</para>
<para>When CSTRING is used as a return value, the ASCII-Z string value will be
converted into a Rexx String object.  CSTRING return values are best confined to
returning C literal values.
The Rexx runtime does not free any
memory associated with a CSTRING return value, so care must be taken to avoid
memory leaks.  Also, locally declared character buffers cannot be returned as
the storage associated with buffer is no longer valid once your method returns to
the Rexx interpreter.  For example, the following is not valid:</para>
<programlisting>
RexxMethod0(CSTRING, MyMethod)
{
   ....
   char buffer[32];
   sprintf(buffer, "%d:%d", major, minor);
   return buffer;     // buffer is not valid once return executes
}
</programlisting>
<para>A RexxStringObject return value and the String() API is more appropriate in this
situation.</para>
<programlisting>
RexxMethod0(RexxStringObject, MyMethod)
{
   ....
   char buffer[32];
   sprintf(buffer, "%d:%d", major, minor);
   return context->String(buffer);     // creates a string object and returns it.
}
</programlisting>
</listitem></varlistentry>
<varlistentry><term>POINTER</term>
<listitem><para>an "unwrapped" Pointer or Buffer string object.  If the argument is a
Pointer object, the wrapped pointer value is returned as a void * value..  If the argument is a Buffer object,
then a pointer to buffer's storage area is returned.  A NULL pointer is returned for
an omitted optional POINTER argument.</para>
<para>When POINTER is used as a method return value, any pointer value can be
returned.  The Rexx runtime will wrap the pointer value in a Rexx Pointer object.
</para></listitem></varlistentry>
<varlistentry><term>POINTERSTRING</term>
<listitem><para>a pointer value that has been encoded in string form.  The string value must
be in the format "0xnnnnnnnn", where the digits are valid hexadecimal digits.  On 64-bit platforms,
the pointer value must be 16 digits long.  The string value is converted into a void * value.
A NULL pointer is returned for
an omitted optional POINTERSTRING argument.</para>
<para>When POINTERSTRING is used as a method return value, any pointer value can be
returned.  The Rexx runtime will convert the pointer value back into an encoded string value.
</para></listitem></varlistentry>
<varlistentry><term>NAME</term>
<listitem><para>The name of the invoked method, passed as a CSTRING.  This is the
message name that was used to invoke the method.
NAME is not valid as a
return value.
</para></listitem></varlistentry>
<varlistentry><term>ARGLIST</term>
<listitem><para>A RexxArrayObject containing all arguments passed to the method.  This is
equivalent to using Arg(1, 'A') from Rexx code.  The returned array contains all of the method
arguments that were specified in the original call.  Omitted arguments are empty slots in the
returned array.  In addition, if a method has an ARGLIST argument specified, the normal
check for the maximum number of arguments is bypassed.  This makes possible methods with an
open-ended number of arguments.
ARGLIST is not valid as a return value.
</para></listitem></varlistentry>
<varlistentry><term>OSELF</term>
<listitem><para>A RexxObjectPtr containing a reference to the object the method is running on.
This is equivalent to the SELF variable that is set in Rexx method code.  OSELF is not valid as a return value.
</para></listitem></varlistentry>
<varlistentry><term>SUPER</term>
<listitem><para>A RexxClassObject containing a reference to the super object for the method scope.
This is equivalent to the SUPER variable that is set in Rexx method code.  SUPER is not valid as a return value.
</para></listitem></varlistentry>
<varlistentry><term>SCOPE</term>
<listitem><para>A RexxObjectPtr containing a reference to the owning scope for the current method.  This
is normally the class that defined the method currently being executed.
SCOPE is not valid as a return value.
</para></listitem></varlistentry>
<varlistentry><term>CSELF</term>
<listitem><para>CSELF is a special argument type used for classes to store native pointers or structures inside an
object instance.  When a CSELF type is encountered, the runtime will search all of the object's variable
scopes searching for a variable named CSELF.  If a CSELF variable is located and the value is an instance
of either the Pointer or Buffer class, the POINTER value will be passed to the method as a void * value.
Objects that rely on CSELF values typically set the variable CSELF inside an init method for the object.  For
example:</para>
<programlisting>

RexxMethod2(RexxObjectPtr, stream_init, OSELF, self, CSTRING, name)
{
    // create a new stream info member
    StreamInfo *stream_info = new StreamInfo(self, name);
    RexxPointerObject streamPtr = context->NewPointer(stream_info);
    context->SetObjectVariable("CSELF", streamPtr);

    return NULLOBJECT;
}

RexxMethod3(size_t, stream_charout, CSELF, streamPtr, OPTIONAL_RexxStringObject, data, OPTIONAL_int64_t, position)
{
    StreamInfo *stream_info = (StreamInfo *)streamPtr;
    stream_info->setContext(context, context->False());
</programlisting>
<para>CSELF is not valid as a return value.
</para></listitem></varlistentry>
</variablelist>
</section>
</section>
</section>

<section id="exitsapi"><title>Rexx Exits Interface</title>
<indexterm><primary>exits</primary></indexterm>
<indexterm><primary>application programming interfaces</primary>
<secondary>exit interface</secondary></indexterm>
<indexterm><primary>application programming interfaces</primary>
<secondary>exit handler</secondary></indexterm>
<para>The Rexx system exits let the programmer create a customized Rexx operating
environment. You can set up user-defined exit handlers to process specific
Rexx activities.</para>
<para>Applications can create exits for:</para>
<itemizedlist>
<listitem><para>The administration of resources at the beginning and the end
of interpretation</para></listitem>
<listitem><para>Linkages to external functions and subcommand handlers</para></listitem>
<listitem><para>Special language features; for example, input and output to
standard resources</para></listitem>
<listitem><para>Polling for halt and external trace events</para></listitem>
</itemizedlist>
<para>Direct exit handlers are specified when the interpreter instance is created, and
reside as entry points within the application that creates the interpreter instance.
</para>

<section id="writedirexithandler"><title>Writing Context Exit Handlers</title>
<indexterm><primary>RexxContextExitHandler interface</primary>
<secondary>definition</secondary></indexterm>
<para>The following is a sample exit handler
definition: </para>
<programlisting>
<![CDATA[
int REXXENTRY Rexx_IO_exit(
     RexxExitContext *context,   // the exit context API vector
     int   exitNumber,           // code defining the exit function
     int   subfunction,          // code defining the exit subfunction
     PEXIT parmBlock);           // function-dependent control block
]]>
</programlisting>
<para>where:</para>
<variablelist>
<varlistentry><term>context</term>
<listitem><para>is RexxExitContext vector that provides access to interpreter services
for this call out.
</para></listitem></varlistentry>
<varlistentry><term>exitNumber</term>
<listitem><para>is the major function code defining the type of exit call.
</para></listitem></varlistentry>
<varlistentry><term>subfunction</term>
<listitem><para>is the subfunction code defining the exit event for the call.
</para></listitem></varlistentry>
<varlistentry><term>parmBlock</term>
<listitem><para>is a pointer to the exit parameter list. </para>
<para>The exit parameter list
contains exit-specific information. See the exit descriptions following the
parameter list formats. </para>

<note>
<para>Some exit subfunctions do not have
parameters. <emphasis role="italic">parmBlock</emphasis> is set to null for exit subfunctions without
parameters.</para></note>
</listitem></varlistentry>
</variablelist>

<section id="ooexitrc"><title>Exit Return Codes</title>
<para>Exit handlers return an integer value that signals one of the following
actions:</para>
<variablelist>
<varlistentry><term>RXEXIT_HANDLED</term>
<listitem><para>The exit handler processed the exit subfunction and updated the subfunction
parameter list as required. The Rexx interpreter continues with processing
as usual.
</para></listitem></varlistentry>
<varlistentry><term>RXEXIT_NOT_HANDLED</term>
<listitem><para>The exit handler did not process the exit subfunction. The Rexx interpreter
processes the subfunction as if the exit handler were not called.
</para></listitem></varlistentry>
<varlistentry><term>RXEXIT_RAISE_ERROR</term>
<listitem><para>A fatal error occurred in the exit handler. The Rexx interpreter raises
Rexx error 48 (&quot;Failure in system service&quot;).  Other errors can be
raised using the <link linkend="mthRaiseException">RaiseException() API</link> provided
by the exit context.
</para></listitem></varlistentry>
</variablelist>
<para>For example, if an application creates an input/output exit handler, one
of the following happens: </para>
<itemizedlist>
<listitem><para>When the exit handler returns RXEXIT_NOT_HANDLED for an RXSIOSAY
subfunction, the Rexx interpreter writes the output line to STDOUT.</para></listitem>
<listitem><para>When the exit handler returns RXEXIT_HANDLED for an RXSIOSAY subfunction,
the Rexx interpreter assumes the exit handler has handled all required output.
The interpreter does not write the output line to STDOUT.</para></listitem>
<listitem><para>When the exit handler returns RXEXIT_RAISE_ERROR for an RXSIOSAY
subfunction, the interpreter raises Rexx error 48, &quot;Failure in system
service&quot;.</para></listitem>
</itemizedlist>
</section>

<section id="ooexitparm"><title>Exit Parameters</title>
<para>Each exit subfunction has a different parameter list. All RXSTRING exit
subfunction parameters are passed as null-terminated strings. The terminating
null is not included in the length stored in the RXSTRING structures.
The string values pointed to by the RXSTRING structs
may also contain null characters.</para>
<para>For some exit subfunctions, the exit handler can return an RXSTRING
character result in the parameter list. The interpreter provides a default 256-byte
RXSTRING for the result string. If the result is longer than 256 bytes,
a new RXSTRING can be allocated using
<computeroutput>RexxAllocateMemory(size)</computeroutput>. The Rexx interpreter
will release the allocated storage after the exit handler returns.</para>
</section>

<section id="ooidentifyexithandl"><title>Identifying Exit Handlers to Rexx</title>
<para>System exit handlers are specified using the DIRECT_EXITS option when
the interpreter instance is created.
The exits are specified using a RexxContextExit structure identifying which
exits will be enabled.
</para>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RexxContextExit data structure</secondary></indexterm>

</section>
</section>

<section id="contextexitdef"><title>Context Exit Definitions</title>
<para>The Rexx interpreter supports the following system exits: </para>
<variablelist>
<varlistentry><term>RXFNC
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXFNC exit</secondary></indexterm>
</term>
<listitem><para>External function call exit.
<variablelist>
<varlistentry><term>RXFNCCAL</term>
<listitem><para>Call an external function.  This exit is
called at the beginning of the search for external functions, allowing
external functions calls to be intercepted.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXOFNC
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXOFNC exit</secondary></indexterm>
</term>
<listitem><para>Object oriented external function call exit.
<variablelist>
<varlistentry><term>RXOFNCCAL</term>
<listitem><para>Call an external function.  This exit is
called at the beginning of the search for external functions, allowing
external functions calls to be intercepted.  This is an extended version of
the RXFNC exit that passes arguments as object references and allows object return
values.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXEXF
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXEXF exit</secondary></indexterm>
</term>
<listitem><para>Scripting external function call exit.
<variablelist>
<varlistentry><term>RXEXFCAL</term>
<listitem><para>Call an external function.  This exit is
called at the end of the search for external functions if no suitable call target
has been found.  This allows applications to extend the external function search order.
Like the RXOFNC exit, the RXEXF exit will pass function arguments and return values
as Rexx objects.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXCMD
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXCMD exit</secondary></indexterm>
</term>
<listitem><para>Subcommand call exit.
<variablelist>
<varlistentry><term>RXCMDHST</term>
<listitem><para>Call a subcommand handler.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXMSQ
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXMSQ exit</secondary></indexterm>
</term>
<listitem><para>External data queue exit.
<variablelist>
<varlistentry><term>RXMSQPLL</term>
<listitem><para>Pull a line from the external data queue.
</para></listitem></varlistentry>
<varlistentry><term>RXMSQPSH</term>
<listitem><para>Place a line in the external data queue.
</para></listitem></varlistentry>
<varlistentry><term>RXMSQSIZ</term>
<listitem><para>Return the number of lines in the external data queue.
</para></listitem></varlistentry>
<varlistentry><term>RXMSQNAM</term>
<listitem><para>Set the active external data queue name.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXSIO
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXSIO exit</secondary></indexterm>
</term>
<listitem><para>Standard input and output exit.
<variablelist>
<varlistentry><term>RXSIOSAY</term>
<listitem><para>Write a line to the standard output stream for the SAY instruction.
</para></listitem></varlistentry>
<varlistentry><term>RXSIOTRC</term>
<listitem><para>Write a line to the standard error stream for the Rexx trace or Rexx
error messages.
</para></listitem></varlistentry>
<varlistentry><term>RXSIOTRD</term>
<listitem><para>Read a line from the standard input stream for PULL or PARSE PULL.
</para></listitem></varlistentry>
<varlistentry><term>RXSIODTR</term>
<listitem><para>Read a line from the standard input stream for interactive debugging.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXNOVAL
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXNOVAL exit</secondary></indexterm>
</term>
<listitem><para>NOVALUE exit.
<variablelist>
<varlistentry><term>RXNOVALCALL</term>
<listitem><para>Process a variable NOVALUE condition.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXVALUE
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXVALUE exit</secondary></indexterm>
</term>
<listitem><para>VALUE built-in function extension.
<variablelist>
<varlistentry><term>RXVALUECALL</term>
<listitem><para>Process a VALUE() built-in function call for an unknown named environment.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXHLT
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXHLT exit</secondary></indexterm>
</term>
<listitem><para>Halt processing exit.
<variablelist>
<varlistentry><term>RXHLTTST</term>
<listitem><para>Test for a HALT condition.
</para></listitem></varlistentry>
<varlistentry><term>RXHLTCLR</term>
<listitem><para>Clear a HALT condition.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXTRC
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXTRC exit</secondary></indexterm>
</term>
<listitem><para>External trace exit.
<variablelist>
<varlistentry><term>RXTRCTST</term>
<listitem><para>Test for an external trace event.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXINI
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXINI exit</secondary></indexterm>
</term>
<listitem><para>Initialization exit.
<variablelist>
<varlistentry><term>RXINIEXT</term>
<listitem><para>Allow additional Rexx procedure initialization.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>RXTER
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXTER exit</secondary></indexterm>
</term>
<listitem><para>Termination exit.
<variablelist>
<varlistentry><term>RXTEREXT</term>
<listitem><para>Process Rexx procedure termination.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
<para>The following sections describe each exit subfunction, including: </para>
<itemizedlist>
<listitem><para>The service the subfunction provides</para></listitem>
<listitem><para>When Rexx calls the exit handler</para></listitem>
<listitem><para>The default action when the exit is not provided or the exit handler does
not process the subfunction</para></listitem>
<listitem><para>The exit action</para></listitem>
<listitem><para>The subfunction parameter list</para></listitem>
</itemizedlist>

<section id="oorxofnch"><title>RXOFNC</title>
<indexterm><primary>external function exit</primary></indexterm>
<indexterm><primary>RXOFNC exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXOFNC exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>external function exit</secondary></indexterm>
<para>Processes calls to external functions.</para>
<para></para>
<variablelist>
<varlistentry><term>RXOFNCCAL</term>
<listitem><para>Processes calls to external functions.</para>
<itemizedlist>
<listitem><para>When called: At beginning of the search for an external routine or
function.</para></listitem>
<listitem><para>Default action: Call the external routine using
the usual external function search order.</para></listitem>
<listitem><para>Exit action: Call the external routine, if possible.</para></listitem>
<listitem><para>Continuation: If necessary, raise Rexx error 40
(&quot;Incorrect call to routine&quot;), 43 (&quot;Routine not found&quot;),
or 44 (&quot;Function or message did not return data&quot;).</para></listitem>
<listitem><para>Parameter list: </para>
<programlisting>
<![CDATA[

typedef  struct _RXOFNC_FLAGS {        /* fl */
   unsigned rxfferr  : 1;              /* Invalid call to routine.   */
   unsigned rxffnfnd : 1;              /* Function not found.        */
   unsigned rxffsub  : 1;              /* Called as a subroutine     */
}  RXOFNC_FLAGS ;

typedef  struct _RXOFNCCAL_PARM {      /* fnc */
   RXOFNC_FLAGS      rxfnc_flags ;     /* function flags             */
   CONSTRXSTRING     rxfnc_name;       // the called function name
   size_t            rxfnc_argc;       /* Number of args in list.    */
   RexxObjectPtr    *rxfnc_argv;       /* Pointer to argument list.  */
   RexxObjectPtr     rxfnc_retc;       /* Return value.              */
}  RXOFNCCAL_PARM;
]]>
</programlisting>
<para>The name of the external function is defined
by <emphasis role="italic">rxfnc_name</emphasis> CONSTRXSTRING value.
The arguments to the
function are in <emphasis role="italic">rxfnc_argv</emphasis> array and
<emphasis role="italic">rxfnc_argc</emphasis> gives the number of arguments.
If you
call the named external function with the Rexx CALL instruction (rather than
using a function call), the flag <emphasis role="italic">rxffsub</emphasis>
is TRUE.</para>
<para>The exit
handler can set <emphasis role="italic">rxfnc_flags</emphasis>
to indicate whether the external function
call was successful. If neither <emphasis role="italic">rxfferr</emphasis> nor
<emphasis role="italic">rxffnfnd</emphasis> is
TRUE, the exit handler successfully called the external function. The error
flags are checked only when the exit handler handles the request.</para>
<para>The exit handler sets <emphasis role="italic">rxffnfnd</emphasis>
to TRUE when the exit handler cannot locate
the external function. The interpreter raises Rexx error 43, &quot;Routine not
found&quot;. The exit handler sets <emphasis role="italic">rxfferr</emphasis>
to TRUE when the exit handler
locates the external function, but the external function returned an error
return code. The Rexx interpreter raises error 40,
&quot;Incorrect call to routine.&quot;</para>
<para>The exit handler returns the external function result in the
<emphasis role="italic">rxfnc_retc</emphasis> RXSTRING.
The Rexx interpreter raises error 44, &quot;Function
or method did not return data,&quot; when the external routine is called as
a function and the exit handler does not return a result. When the external
routine is called with the Rexx CALL instruction, a result is not
required.
</para></listitem></itemizedlist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="oorxexfh"><title>RXEXF</title>
<indexterm><primary>scripting function exit</primary></indexterm>
<indexterm><primary>RXEXF exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXEXF exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>scripting function exit</secondary></indexterm>
<para>Processes calls to external functions.</para>
<para></para>
<variablelist>
<varlistentry><term>RXEXFCAL</term>
<listitem><para>Processes calls to external functions.</para>
<itemizedlist>
<listitem><para>When called: At end of the search for an external routine or
function when no suitable call target has been located.</para></listitem>
<listitem><para>Default action: Raise error 43 (&quot;Routine not found&quot;).
</para></listitem>
<listitem><para>Exit action: Call the external routine, if possible.</para></listitem>
<listitem><para>Continuation: If necessary, raise Rexx error 40
(&quot;Incorrect call to routine&quot;), 43 (&quot;Routine not found&quot;),
or 44 (&quot;Function or message did not return data&quot;).</para></listitem>
<listitem><para>Parameter list: </para>
<programlisting>
<![CDATA[

typedef  struct _RXEXF_FLAGS {         /* fl */
   unsigned rxfferr  : 1;              /* Invalid call to routine.   */
   unsigned rxffnfnd : 1;              /* Function not found.        */
   unsigned rxffsub  : 1;              /* Called as a subroutine     */
}  RXEXT_FLAGS ;

typedef  struct _RXEXFCAL_PARM {       /* fnc */
   RXEXF_FLAGS       rxfnc_flags ;     /* function flags             */
   CONSTRXSTRING     rxfnc_name;       // the called function name
   size_t            rxfnc_argc;       /* Number of args in list.    */
   RexxObjectPtr    *rxfnc_argv;       /* Pointer to argument list.  */
   RexxObjectPtr     rxfnc_retc;       /* Return value.              */
}  RXEXFCAL_PARM;
]]>
</programlisting>
<para>The name of the external function is defined
by <emphasis role="italic">rxfnc_name</emphasis> CONSTRXSTRING value.
The arguments to the
function are in <emphasis role="italic">rxfnc_argv</emphasis> array and
<emphasis role="italic">rxfnc_argc</emphasis> gives the number of arguments.
If you
call the named external function with the Rexx CALL instruction (rather than
using a function call), the flag <emphasis role="italic">rxffsub</emphasis>
is TRUE.</para>
<para>The exit
handler can set <emphasis role="italic">rxfnc_flags</emphasis>
to indicate whether the external function
call was successful. If neither <emphasis role="italic">rxfferr</emphasis> nor
<emphasis role="italic">rxffnfnd</emphasis> is
TRUE, the exit handler successfully called the external function. The error
flags are checked only when the exit handler handles the request.</para>
<para>The exit handler sets <emphasis role="italic">rxffnfnd</emphasis>
to TRUE when the exit handler cannot locate
the external function. The interpreter raises Rexx error 43, &quot;Routine not
found&quot;. The exit handler sets <emphasis role="italic">rxfferr</emphasis>
to TRUE when the exit handler
locates the external function, but the external function returned an error
return code. The Rexx interpreter raises error 40,
&quot;Incorrect call to routine.&quot;</para>
<para>The exit handler returns the external function result in the
<emphasis role="italic">rxfnc_retc</emphasis> RXSTRING.
The Rexx interpreter raises error 44, &quot;Function
or method did not return data,&quot; when the external routine is called as
a function and the exit handler does not return a result. When the external
routine is called with the Rexx CALL instruction, a result is not
required.
</para></listitem></itemizedlist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="oorxfnch"><title>RXFNC</title>
<indexterm><primary>external function exit</primary></indexterm>
<indexterm><primary>RXFNC exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXFNC exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>external function exit</secondary></indexterm>
<para>Processes calls to external functions.</para>
<para></para>
<variablelist>
<varlistentry><term>RXFNCCAL</term>
<listitem><para>Processes calls to external functions.</para>
<itemizedlist>
<listitem><para>When called: At beginning of the search for an external routine or
function.</para></listitem>
<listitem><para>Default action: Call the external routine using
the usual external function search order.</para></listitem>
<listitem><para>Exit action: Call the external routine, if possible.</para></listitem>
<listitem><para>Continuation: If necessary, raise Rexx error 40
(&quot;Incorrect call to routine&quot;), 43 (&quot;Routine not found&quot;),
or 44 (&quot;Function or message did not return data&quot;).</para></listitem>
<listitem><para>Parameter list: </para>
<programlisting>
<![CDATA[
typedef struct {
   struct {
      unsigned rxfferr  : 1;           /* Invalid call to routine.    */
      unsigned rxffnfnd : 1;           /* Function not found.         */
      unsigned rxffsub  : 1;           /* Called as a subroutine if   */
                                       /* TRUE.  Return values are    */
                                       /* optional for subroutines,   */
                                       /* required for functions.     */
   } rxfnc_flags ;

   const char *      rxfnc_name;       /* Pointer to function name.   */
   unsigned short    rxfnc_namel;      /* Length of function name.    */
   const char *      rxfnc_que;        /* Current queue name.         */
   unsigned short    rxfnc_quel;       /* Length of queue name.       */
   unsigned short    rxfnc_argc;       /* Number of args in list.     */
   PCONSTRXSTRING    rxfnc_argv;       /* Pointer to argument list.   */
                                       /* List mimics argv list for   */
                                       /* function calls, an array of */
                                       /* RXSTRINGs.                  */
   RXSTRING          rxfnc_retc;       /* Return value.               */
} RXFNCCAL_PARM;
]]>
</programlisting>
<para>The name of the external function is defined
by <emphasis role="italic">rxfnc_name</emphasis> and
<emphasis role="italic">rxfnc_namel</emphasis>. The arguments to the
function are in <emphasis role="italic">rxfnc_argc</emphasis> and
<emphasis role="italic">rxfnc_argv</emphasis>. If you
call the named external function with the Rexx CALL instruction (rather than
using a function call), the flag <emphasis role="italic">rxffsub</emphasis>
is TRUE.</para>
<para>The exit
handler can set <emphasis role="italic">rxfnc_flags</emphasis>
to indicate whether the external function
call was successful. If neither <emphasis role="italic">rxfferr</emphasis> nor
<emphasis role="italic">rxffnfnd</emphasis> is
TRUE, the exit handler successfully called the external function. The error
flags are checked only when the exit handler handles the request.</para>
<para>The exit handler sets <emphasis role="italic">rxffnfnd</emphasis>
to TRUE when the exit handler cannot locate
the external function. The interpreter raises Rexx error 43, &quot;Routine not
found&quot;. The exit handler sets <emphasis role="italic">rxfferr</emphasis>
to TRUE when the exit handler
locates the external function, but the external function returned an error
return code. The Rexx interpreter raises error 40,
&quot;Incorrect call to routine.&quot;</para>
<para>The exit handler returns the external function result in the
<emphasis role="italic">rxfnc_retc</emphasis> RXSTRING.
The Rexx interpreter raises error 44, &quot;Function
or method did not return data,&quot; when the external routine is called as
a function and the exit handler does not return a result. When the external
routine is called with the Rexx CALL instruction, a result is not
required.</para>
<para>The RXFNC translates all call arguments to string values and only allows a
string value as a return value.  To access call arguments as Rexx objects, use
the RXOFNC exit.
</para></listitem></itemizedlist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="oorxcmdh"><title>RXCMD</title>
<indexterm><primary>external command exit</primary></indexterm>
<indexterm><primary>host command exit</primary></indexterm>
<indexterm><primary>RXCMD exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXCMD exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>host command exit</secondary></indexterm>
<para>Processes calls to subcommand handlers. </para>
<para></para>
<variablelist>
<varlistentry><term>RXCMDHST</term>
<listitem><para>Calls a named subcommand handler.</para>
<itemizedlist>
<listitem><para>When called: When Rexx procedure issues a command.</para></listitem>
<listitem><para>Default action: Call the named subcommand handler
specified by the current Rexx ADDRESS setting.</para></listitem>
<listitem><para>Exit action: Process the call to a named subcommand
handler.</para></listitem>
<listitem><para>Continuation: Raise the ERROR or FAILURE condition
when indicated by the parameter list flags.</para></listitem>
<listitem><para>Parameter list: </para>
<programlisting>
<![CDATA[
typedef struct {
   struct {                            /* Condition flags             */
      unsigned rxfcfail : 1;           /* Command failed.  Trap with  */
                                       /* CALL or SIGNAL on FAILURE.  */
      unsigned rxfcerr  : 1;           /* Command ERROR occurred.     */
                                       /* Trap with CALL or SIGNAL on */
                                       /* ERROR.                      */
   } rxcmd_flags;
   const char *      rxcmd_address;    /* Pointer to address name.    */
   unsigned short    rxcmd_addressl;   /* Length of address name.     */
   const char *      rxcmd_dll;        /* dll name for command.       */
   unsigned short    rxcmd_dll_len;    /* Length of dll name.  0 ==>  */
                                       /* executable file.            */
   CONSTRXSTRING     rxcmd_command;    /* The command string.         */
   RXSTRING          rxcmd_retc;       /* Pointer to return code      */
                                       /* buffer.  User allocated.    */
} RXCMDHST_PARM;
]]>
</programlisting>
<para>The <emphasis role="italic">rxcmd_command</emphasis> field contains
the issued command. <emphasis role="italic">Rxcmd_address</emphasis>,
<emphasis role="italic">rxcmd_addressl</emphasis>,
<emphasis role="italic">rxcmd_dll</emphasis>, and
<emphasis role="italic">rxcmd_dll_len</emphasis> fully define the current
ADDRESS setting. <emphasis role="italic">Rxcmd_retc</emphasis> is an RXSTRING
for the return code value assigned to Rexx special variable RC.</para>
<para>The exit handler can set <emphasis role="italic">rxfcfail</emphasis>
or <emphasis role="italic">rxfcerr</emphasis>
to TRUE to raise an ERROR or FAILURE condition.</para></listitem>
</itemizedlist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="oorxmsqh"><title>RXMSQ</title>
<indexterm><primary>external queue exit</primary></indexterm>
<indexterm><primary>queue exit</primary></indexterm>
<indexterm><primary>RXMSQ exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXMSQ exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>queue exit</secondary></indexterm>
<para>External data queue exit. </para>
<variablelist>
<varlistentry><term>RXMSQPLL</term>
<listitem><para>Pulls a line from the external data queue. </para>
<itemizedlist>
<listitem><para>When called: When a Rexx PULL instruction, PARSE
PULL instruction, or LINEIN built-in function reads a line from the external
data queue.</para></listitem>
<listitem><para>Default action: Remove a line from the current Rexx
data queue.</para></listitem>
<listitem><para>Exit action: Return a line from the data queue that
the exit handler provided.</para></listitem>
<listitem><para>Parameter list: </para>
<programlisting>
<![CDATA[
typedef struct {
   RXSTRING          rxmsq_retc;       /* Pointer to dequeued entry   */
                                       /* buffer.  User allocated.    */
} RXMSQPLL_PARM;
]]>
</programlisting>
<para>The exit handler returns the queue line in
the <emphasis role="italic">rxmsq_retc</emphasis> RXSTRING.</para>
</listitem></itemizedlist>
</listitem></varlistentry>
<varlistentry><term>RXMSQPSH</term>
<listitem><para>Places a line in the external data queue. </para>
<itemizedlist>
<listitem><para>When called: When a Rexx PUSH instruction, QUEUE
instruction, or LINEOUT built-in function adds a line to
the data queue.</para></listitem>
<listitem><para>Default action: Add the line to the current Rexx
data queue.</para></listitem>
<listitem><para>Exit action: Add the line to the data queue that
the exit handler provided.</para></listitem>
<listitem><para>Parameter list: </para>
<programlisting>
<![CDATA[
typedef struct {
   struct {                            /* Operation flag              */
      unsigned rxfmlifo : 1;           /* Stack entry LIFO when TRUE, */
                                       /* FIFO when FALSE.            */
   } rxmsq_flags;
   CONSTRXSTRING     rxmsq_value;      /* The entry to be pushed.     */
} RXMSQPSH_PARM;
]]>
</programlisting>
<para>The <emphasis role="italic">rxmsq_value</emphasis> RXSTRING contains
the line added to the queue. It is the responsibility of the exit handler
to truncate the string if the exit handler data queue has a maximum length
restriction. <emphasis role="italic">Rxfmlifo</emphasis>
is the stacking order (LIFO or FIFO).</para></listitem></itemizedlist>
</listitem></varlistentry>
<varlistentry><term>RXMSQSIZ</term>
<listitem><para>Returns the number of lines in the external data queue.</para>
<itemizedlist>
<listitem><para>When called: When the Rexx QUEUED built-in function
requests the size of the external data queue.</para></listitem>
<listitem><para>Default action: Request the size of the current
Rexx data queue.</para></listitem>
<listitem><para>Exit action: Return the size of the data queue that
the exit handler provided.</para></listitem>
<listitem><para>Parameter list: </para>
<programlisting>
<![CDATA[
typedef struct {
   size_t            rxmsq_size;       /* Number of Lines in Queue    */
} RXMSQSIZ_PARM;
]]>
</programlisting>
<para>The exit handler returns the number of queue
lines in <emphasis role="italic">rxmsq_size</emphasis>.</para>
</listitem></itemizedlist>
</listitem></varlistentry>
<varlistentry><term>RXMSQNAM</term>
<listitem><para>Sets the name of the active external data queue.
<itemizedlist>
<listitem><para>When called: Called by
the RXQUEUE("SET", <emphasis role="italic">newname</emphasis>)
 built-in function.</para></listitem>
<listitem><para>Default action: Change the current default queue
to <emphasis role="italic">newname</emphasis>.</para></listitem>
<listitem><para>Exit action: Change the default queue name for the
data queue that the exit handler provided.</para></listitem>
<listitem><para>Parameter list:</para>
<programlisting>
<![CDATA[
typedef struct {
   CONSTRXSTRING     rxmsq_name;       /* RXSTRING containing         */
                                       /* queue name.                 */
} RXMSQNAM_PARM;
]]>
</programlisting>
<para><emphasis role="italic">rxmsq_name</emphasis> contains the new queue
name.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="oorxsioh"><title>RXSIO</title>
<indexterm><primary>external I/O exit</primary></indexterm>
<indexterm><primary>session I/O exit</primary></indexterm>
<indexterm><primary>RXSIO exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXSIO exit</secondary></indexterm>
<para>Standard input and output. </para>
<note>
<para>The PARSE LINEIN instruction
and the LINEIN, LINEOUT, LINES, CHARIN, CHAROUT, and CHARS built-in functions
do not call the RXSIO exit handler.</para></note>
<para></para>
<variablelist>
<varlistentry><term>RXSIOSAY</term>
<listitem><para>Writes a line to the standard output stream. </para>
<itemizedlist>
<listitem><para>When called: When the SAY instruction writes a line
to the standard output stream.</para></listitem>
<listitem><para>Default action: Write a line to the standard output
stream (STDOUT).</para></listitem>
<listitem><para>Exit action: Write a line to the output stream that
the exit handler provided.</para></listitem>
<listitem><para>Parameter list:</para>
<programlisting>
<![CDATA[
typedef struct {
   CONSTRXSTRING      rxsio_string;     /* String to display.          */
} RXSIOSAY_PARM;
]]>
</programlisting>
<para>The output line is contained in
<emphasis role="italic">rxsio_string</emphasis>. The output line can be of any
length. It is the responsibility of the
exit handler to truncate or split the line if necessary.</para></listitem>
</itemizedlist>
</listitem></varlistentry>
<varlistentry><term>RXSIOTRC</term>
<listitem><para>Writes trace and error message output to the standard error
stream.
<itemizedlist>
<listitem><para>When called: To output lines of trace output and
Rexx error messages.</para></listitem>
<listitem><para>Default action: Write a line to the standard error
stream (.ERROR).</para></listitem>
<listitem><para>Exit action: Write a line to the error output stream
that the exit handler provided.</para></listitem>
<listitem><para>Parameter list:</para>
<programlisting>
<![CDATA[
typedef struct {
   CONSTRXSTRING       rxsio_string;     /* Trace line to display.      */
} RXSIOTRC_PARM;
]]>
</programlisting>
<para>The output line is contained in
<emphasis role="italic">rxsio_string</emphasis>. The output line can be of any
length. It is the responsibility of the
exit handler to truncate or split the line if necessary.</para></listitem>
</itemizedlist>
</para></listitem></varlistentry>
<varlistentry><term>RXSIOTRD</term>
<listitem><para>Reads from standard input stream.
<itemizedlist>
<listitem><para>When called: To read from the standard input stream
for the Rexx PULL and PARSE PULL instructions.</para></listitem>
<listitem><para>Default action: Read a line from the standard input
stream (STDIN).</para></listitem>
<listitem><para>Exit action: Return a line from the standard input
stream that the exit handler provided.</para></listitem>
<listitem><para>Parameter list:</para>
<programlisting>
<![CDATA[
typedef struct {
   RXSTRING          rxsiotrd_retc;    /* RXSTRING for input.         */
} RXSIOTRD_PARM;
]]>
</programlisting>
<para>The input stream line is returned in the
<emphasis role="italic">rxsiotrd_retc</emphasis> RXSTRING.</para>
</listitem></itemizedlist>
</para></listitem></varlistentry>
<varlistentry><term>RXSIODTR</term>
<listitem><para>Interactive debug input.
<itemizedlist>
<listitem><para>When called: To read from the debug input stream
for interactive debug prompts.</para></listitem>
<listitem><para>Default action: Read a line from the standard input
stream (STDIN).</para></listitem>
<listitem><para>Exit action: Return a line from the standard debug
stream that the exit handler provided.</para></listitem>
<listitem><para>Parameter list: </para>
<programlisting>
<![CDATA[
typedef struct {
   RXSTRING          rxsiodtr_retc;    /* RXSTRING for input.         */
} RXSIODTR_PARM;
]]>
</programlisting>
<para>The input stream line is returned in the
<emphasis role="italic">rxsiodtr_retc</emphasis> RXSTRING.</para>
</listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="oorxnoval"><title>RXNOVAL</title>
<indexterm><primary>NOVALUE exit</primary></indexterm>
<indexterm><primary>RXNOVAL exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXNOVAL exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>NOVALUE exit</secondary></indexterm>
<para>Processes NOVALUE variable conditions. </para>
<para></para>
<variablelist>
<varlistentry><term>RXNOVALCALL</term>
<listitem><para>Processes a Rexx NOVALUE condition.</para>
<itemizedlist>
<listitem><para>When called: Before the interpreter raises a NOVALUE condition.
The exit is given the opportunity to provide a value to the unassigned variable.</para></listitem>
<listitem><para>Default action: Raise a NOVALUE condition for an unassigned variable. </para></listitem>
<listitem><para>Exit action: Return an initial value for an unassigned variable.
</para></listitem>
<listitem><para>Continuation: If the exit provides a value for the unassigned variable,
that value is assigned to the indicated variable.  The exit will not be called for the
same variable on the next reference unless the variable is dropped.  If a value is not
returned, a NOVALUE condition will be raised.  If SIGNAL ON NOVALUE is not enabled,
the variable name will be returned as the value.
</para></listitem>
<listitem><para>Parameter list:</para>
<programlisting>
<![CDATA[

typedef  struct _RXVARNOVALUE_PARM {   /* var */
   RexxStringObject  variable_name;    // the request variable name
   RexxObjectPtr     value;            // returned variable value
}  RXVARNOVALUE_PARM;
]]>
</programlisting>
</listitem>
</itemizedlist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="oorxvalue"><title>RXVALUE</title>
<indexterm><primary>VALUE exit</primary></indexterm>
<indexterm><primary>RXVALUE exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXVALUE exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>NOVALUE exit</secondary></indexterm>
<para>Extends the environments available to the VALUE() built-in function.</para>
<para></para>
<variablelist>
<varlistentry><term>RXVALUECALL</term>
<listitem><para>Processes an extended call to the VALUE() built-in function.</para>
<itemizedlist>
<listitem><para>When called: When the VALUE() built-in function is called with an unknown
environment name.
The exit is given the opportunity to provide a value for the given environment selector.</para></listitem>
<listitem><para>Default action: Raise a SYNTAX error for an unknown environment name. </para></listitem>
<listitem><para>Exit action: Return a value for the given name/environment pair.
</para></listitem>
<listitem><para>Continuation: If the exit provides a value for the VALUE() call, that value is
returned as a result.
.</para></listitem>
<listitem><para>Parameter list:</para>
<programlisting>
<![CDATA[

typedef  struct _RXVALCALL_PARM {      /* val */
   RexxStringObject  selector;         // the environment selector name
   RexxStringObject  variable_name;    // the request variable name
   RexxObjectPtr     value;            // returned variable value
}  RXVALCALL_PARM;
]]>
</programlisting>
<para>
If the newValue argument is specified on the VALUE() built-in function, that value
is assigned to <emphasis role="italic">value</emphasis> on the call to the exit.
</para>
</listitem>
</itemizedlist>
</listitem></varlistentry>
</variablelist>
</section>

<section id="oohltcon"><title>RXHLT</title>
<indexterm><primary>external HALT exit</primary></indexterm>
<indexterm><primary>RXHLT exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXHLT exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>external HALT exit</secondary></indexterm>
<para>HALT condition processing. </para>
<para>Because the RXHLT exit handler
is called after every Rexx instruction, enabling this exit slows Rexx program
execution. The RexxSetHalt function can halt a Rexx program without
between-instruction polling.</para>
<variablelist>
<varlistentry><term>RXHLTTST</term>
<listitem><para>Tests the HALT indicator.
<itemizedlist>
<listitem><para>When called: When the interpreter polls externally
raises HALT conditions. The exit will be called after completion of every
Rexx instruction.</para></listitem>
<listitem><para>Default action: The interpreter uses the system
facilities for trapping Cntrl-Break signals.</para></listitem>
<listitem><para>Exit action: Return the current state of the HALT
condition (either TRUE or FALSE).</para></listitem>
<listitem><para>Continuation: Raise the Rexx HALT condition if the
exit handler returns TRUE.</para></listitem>
<listitem><para>Parameter list:</para>
<programlisting>
<![CDATA[
typedef struct {
   struct {                            /* Halt flag                   */
      unsigned rxfhhalt : 1;           /* Set if HALT occurred.       */
   } rxhlt_flags;
} RXHLTTST_PARM;
]]>
</programlisting>
<para>If the exit handler sets <emphasis role="italic">rxfhhalt</emphasis> to
TRUE, the HALT condition is raised in the Rexx program.</para>
<para>The Rexx program can retrieve the reason string using the CONDITION("D")
built-in function.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
<varlistentry><term>RXHLTCLR</term>
<listitem><para>Clears the HALT condition.
<itemizedlist>
<listitem><para>When called: When the interpreter has recognized
and raised a HALT condition, to acknowledge processing of the HALT condition.</para></listitem>
<listitem><para>Default action: The interpreter resets the Cntrl-Break
signal handlers.</para></listitem>
<listitem><para>Exit action: Reset exit handler HALT state to FALSE.</para></listitem>
<listitem><para>Parameters: None.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="oorxtrch"><title>RXTRC</title>
<indexterm><primary>external trace exit</primary></indexterm>
<indexterm><primary>RXTRC exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXTRC exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>tracing exit</secondary></indexterm>
<para>Tests the external trace indicator. </para>
<note>
<para>Because the RXTRC exit
is called after every Rexx instruction, enabling this exit slows Rexx procedure
execution. The <link linkend="mthSetThreadTrace">SetThreadTrace()</link>
method can turn on Rexx tracing without the
between-instruction polling.</para></note>
<para></para>
<variablelist>
<varlistentry><term>RXTRCTST</term>
<listitem><para>Tests the external trace indicator.
<itemizedlist>
<listitem><para>When called: When the interpreter polls for an external
trace event. The exit is called after completion of every Rexx instruction.</para></listitem>
<listitem><para>Default action: None.</para></listitem>
<listitem><para>Exit action: Return the current state of external
tracing (either TRUE or FALSE).</para></listitem>
<listitem><para>Continuation: When the exit handler switches from
FALSE to TRUE, the Rexx interpreter enters the interactive Rexx debug mode
using TRACE ?R level of tracing. When the exit handler switches from TRUE
to FALSE, the Rexx interpreter exits the interactive debug mode.</para></listitem>
<listitem><para>Parameter list:</para>
<programlisting>
<![CDATA[
typedef struct {
   struct {
      unsigned rxftrace : 1;        /* External trace setting        */
   } rxtrc_flags;
} RXTRCTST_PARM;
]]>
</programlisting>
<para>If the exit handler switches <emphasis role="italic">rxftrace</emphasis>
to TRUE, Rexx switches on the interactive debug mode. If the exit handler
switches <emphasis role="italic">rxftrace</emphasis> to FALSE, Rexx switches
off the interactive debug mode.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="oorxinih"><title>RXINI</title>
<indexterm><primary>RXINI exit</primary></indexterm>
<indexterm><primary>initialization exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXINI exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>initialization exit</secondary></indexterm>
<para>Initialization processing. This exit is called as the last step of Rexx
program initialization. </para>
<variablelist>
<varlistentry><term>RXINIEXT</term>
<listitem><para>Initialization exit.
<itemizedlist>
<listitem><para>When called: Before the first instruction of the
Rexx procedure is interpreted.</para></listitem>
<listitem><para>Default action: None.</para></listitem>
<listitem><para>Exit action: The exit handler can perform additional
initialization. For example:
<itemizedlist>
<listitem><para>Use <link linkend="mthSetContextVariable">SetContextVariable()</link>
API to initialize application-specific
variables.</para></listitem>
<listitem><para>Use <link linkend="mthSetThreadTrace">SetThreadTrace()</link> API
to switch on the interactive Rexx debug mode.
</para></listitem>
</itemizedlist>
</para></listitem>
<listitem><para>Parameters: None.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="oorxterh"><title>RXTER</title>
<indexterm><primary>RXTER exit</primary></indexterm>
<indexterm><primary>termination exit</primary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>RXTER exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>termination exit</secondary></indexterm>
<indexterm><primary>RexxContextExit interface</primary>
<secondary>exit functions</secondary></indexterm>
<para>Termination processing.</para>
<para>The RXTER exit is called as the first step of Rexx program termination.</para>
<variablelist>
<varlistentry><term>RXTEREXT</term>
<listitem><para>Termination exit.
<itemizedlist>
<listitem><para>When called: After the last instruction of the Rexx
procedure has been interpreted.</para></listitem>
<listitem><para>Default action: None.</para></listitem>
<listitem><para>Exit action: The exit handler can perform additional
termination activities. For example, the exit handler can use
<link linkend="mthSetContextVariable">SetContextVariable()</link>
to retrieve the Rexx variable values.</para></listitem>
<listitem><para>Parameters: None.</para></listitem></itemizedlist>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>
</section>

<section id="commandapi"><title>Command Handler Interface</title>
<para>Applications can create custom command handlers that function like operating command shell environments.
These named evironments can be targetted with the Rexx ADDRESS instuction and applications can create
Rexx instances that direct commands to application command handlers by default.
</para>
<para>Command handlers are created by registering the handers with an interpreter instance when it is created.
See <link linkend="instanceoptions">Interpreter Instance Options</link> for how to register a handler with
an interpreter instance.</para>
<para>The command handlers are registered as a function pointer to a handler routine.  When a Rexx program
issues a command to the named ADDRESS target, the handler is called with the evaluated command string and the
name of the address environment.  The handler is responsible for executing the command and returning a
return code value back to the Rexx program.  Handlers are called using the following function signature:</para>

<programlisting>
RexxObjectPtr RexxEntry TestCommandHandler(RexxExitContext *context,
     RexxStringObject address, RexxStringObject command)
</programlisting>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">context</emphasis></entry>
    <entry><para>A <link linkend="exitcontext">RexxExitContext</link> interface vector for the handler call.
    The RexxExitContext provides access to runtime services appropriate to a command handler.  For example, the
    exit context can set or get Rexx variables, invoke methods on objects, and raise ERROR or FAILURE conditions.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">address</emphasis></entry>
    <entry><para>A String object containing the target command environment name.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">command</emphasis></entry>
    <entry><para>A String object containing the issued command string.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Any object that should be used as the command return code.  This value will be assigned to the
variable RC upon return.  If NULLOBJECT is returned, a 0 is used as the return code.  The return
code value is traditionally a numeric value, but any value can be returned, including more complex object
return values, if desired.
</para>
<para>For normal commands, the command is processed and a return code is given back to the Rexx program.
The interpreter recognizes two different abnormal return states for commands, ERROR and FAILURE.
An ERROR condition indicates there was some sort of error return state involved with executing a command.
These could be command syntax errors, semantic errors, etc.  FAILURE conditions are more serious conditions.
One traditional FAILURE condition is the unknown command error.</para>
<para>Command handlers raise ERROR and FAILURE conditions using the
<link linkend="mthRaiseCondition">RaiseCondition()</link> API provided by the RexxExitContext.  For
example:</para>
<programlisting>
<![CDATA[
// if this was an unknown command, give our generic unknown command return code
if (errorStatus == COMMAND_FAILURE) {
    // Note:  The return code needs to be included with the FAILURE condition
    context->RaiseCondition("FAILURE", command, NULLOBJECT, context->WholeNumber(-1));
    // just return null...the RC value is picked up from the condition.
    return NULLOBJECT;
}
else if (errorStatus == COMMAND_ERROR) {
    // Note:  The return code needs to be included with the ERROR condition
    context->RaiseCondition("ERROR", command, NULLOBJECT, context->WholeNumber(rc));
    // just return null...the RC value is picked up from the condition.
    return NULLOBJECT;
}
// return the RC value for the command, which need not be 0
return context->WholeNumber(rc);
]]>
</programlisting>
</section>

<section id="apilisting"><title>Rexx Interface Methods Listing</title>
<para>This section describes each available method and its associated context.</para>

<section id="mthArray"><title>Array</title>
<indexterm><primary>Array</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Array</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>Array</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Array</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Array</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj1, obj2, obj3, obj4;

>>--arr = context->Array(obj1);------------------------------------------><

>>--arr = context->Array(obj1, obj2);------------------------------------><

>>--arr = context->Array(obj1, obj2, obj3);------------------------------><

>>--arr = context->Array(obj1, obj2, obj3, obj4);------------------------><
]]>
</programlisting>
<para>This method has four forms.
It create a new one-dimension Array with the specified objects.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj1</emphasis></entry>
    <entry><para>The first object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj2</emphasis></entry>
    <entry><para>The second object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj3</emphasis></entry>
    <entry><para>The third object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj4</emphasis></entry>
    <entry><para>The fourth object to be added.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Array object.</para>
</section>

<section id="mthArrayAppend"><title>ArrayAppend</title>
<indexterm><primary>ArrayAppend</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayAppend</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ArrayAppend</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayAppend</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayAppend</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj;
size_t n;

>>--n = context->ArrayAppend(arr, obj);----------------------------------><
]]>
</programlisting>
<para>Append an Object to the end of an Array.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The target Array object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be appended.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The index of the appended object.</para>
</section>

<section id="mthArrayAppendString"><title>ArrayAppendString</title>
<indexterm><primary>ArrayAppendString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayAppendString</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ArrayAppendString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayAppendString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayAppendString</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxArrayObject arr;
CSTRING str;
size_t n, len;

>>--n = context->ArrayAppendString(arr, str, len);-----------------------><
]]>
</programlisting>
<para>Append an object to the end of an Array.  The appended object is
a String object created from a pointer and length.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The target Array object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>A pointer to the string data to be appended.</para></entry>
    </row>
    <row><entry><emphasis role="italic">len</emphasis></entry>
    <entry><para>The length of the string value in characters.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Array index of the appended object.</para>
</section>

<section id="mthArrayAt"><title>ArrayAt</title>
<indexterm><primary>ArrayAt</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayAt</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ArrayAt</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayAt</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayAt</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj;
size_t idx;

>>--obj = context->ArrayAt(arr, idx);------------------------------------><
]]>
</programlisting>
<para>Retrieve an object from a specified Array index.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The source Array object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">idx</emphasis></entry>
    <entry><para>The index of the required object.  This argument is 1-based.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object at the specified index.
Returns NULLOBJECT if there is no value at the specified index.</para>
</section>

<section id="mthArrayDimension"><title>ArrayDimension</title>
<indexterm><primary>ArrayDimension</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayDimension</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ArrayDimension</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayDimension</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayDimension</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxArrayObject arr;
size_t sz;

>>--sz = context->ArrayDimension(arr);-----------------------------------><
]]>
</programlisting>
<para>Returns number of dimensions of an Array.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The target Array object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The number of Array dimensions.</para>
</section>

<section id="mthArrayItems"><title>ArrayItems</title>
<indexterm><primary>ArrayItems</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayItems</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ArrayItems</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayItems</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayItems</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxArrayObject arr;
size_t sz;

>>--sz = context->ArrayItems(arr);---------------------------------------><
]]>
</programlisting>
<para>Returns number of elements in an Array.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The source Array object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The number of Array elements.</para>
</section>

<section id="mthArrayOfFour"><title>ArrayOfFour</title>
<indexterm><primary>ArrayOfFour</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayOfFour</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ArrayOfFour</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayOfFour</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayOfFour</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj1, obj2, obj3, obj4;

>>--arr = context->ArrayOfFour(obj1, obj2, obj3, obj4);------------------><
]]>
</programlisting>
<para>Create a new one-dimension Array with the specified objects.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj1</emphasis></entry>
    <entry><para>The first object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj2</emphasis></entry>
    <entry><para>The second object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj3</emphasis></entry>
    <entry><para>The third object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj4</emphasis></entry>
    <entry><para>The fourth object to be added.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Array object.</para>
</section>

<section id="mthArrayOfThree"><title>ArrayOfThree</title>
<indexterm><primary>ArrayOfThree</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayOfThree</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ArrayOfThree</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayOfThree</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayOfOne</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj1, obj2, obj3;

>>--arr = context->ArrayOfThree(obj1, obj2, obj3);-----------------------><
]]>
</programlisting>
<para>Create a new one-dimension Array with the specified objects.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj1</emphasis></entry>
    <entry><para>The first object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj2</emphasis></entry>
    <entry><para>The second object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj3</emphasis></entry>
    <entry><para>The third object to be added.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Array object.</para>
</section>

<section id="mthArrayOfTwo"><title>ArrayOfTwo</title>
<indexterm><primary>ArrayOfTwo</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayOfTwo</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ArrayOfTwo</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayOfTwo</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayOfOne</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj1, obj2;

>>--arr = context->ArrayOfTwo(obj1, obj2);-------------------------------><
]]>
</programlisting>
<para>Create a new one-dimension Array with the specified objects..
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj1</emphasis></entry>
    <entry><para>The first object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj2</emphasis></entry>
    <entry><para>The second object to be added.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Array object.</para>
</section>

<section id="mthArrayOfOne"><title>ArrayOfOne</title>
<indexterm><primary>ArrayOfOne</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayOfOne</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ArrayOfOne</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayOfOne</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayOfOne</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj;

>>--arr = context->ArrayOfOne(obj);--------------------------------------><
]]>
</programlisting>
<para>Create a new one-dimension Array with the specified object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be added.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Array object.</para>
</section>

<section id="mthArrayPut"><title>ArrayPut</title>
<indexterm><primary>ArrayPut</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArrayPut</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ArrayPut</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArrayPut</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArrayPut</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxArrayObject arr;
RexxObjectPtr obj;
size_t idx;

>>--context->ArrayPut(arr, obj, idx);------------------------------------><
]]>
</programlisting>
<para>Replace/add an Object to an Array.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The target Array object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be added.</para></entry>
    </row>
    <row><entry><emphasis role="italic">idx</emphasis></entry>
    <entry><para>The index into the Array object. This argument is 1-based.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthArraySize"><title>ArraySize</title>
<indexterm><primary>ArraySize</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ArraySize</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ArraySize</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ArraySize</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ArraySize</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxArrayObject arr;
size_t sz;

>>--sz = context->ArraySize(arr);----------------------------------------><
]]>
</programlisting>
<para>Returns the size of an Array.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The source Array object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Array size.</para>
</section>

<section id="mthAttachThread"><title>AttachThread</title>
<indexterm><primary>AttachThread</primary></indexterm>
<indexterm><primary>Rexx instance context methods</primary>
<secondary>AttachThread</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>Yes</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxThreadContext *tc

>>--success = context->AttachThread(&tc);-------------------------------><
]]>
</programlisting>
<para>Attaches the current thread to the Rexx interpreter instance
<emphasis role="italic">context</emphasis> pointer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">tc</emphasis></entry>
    <entry><para>Pointer to a RexxThreadContext pointer used to return a RexxThreadContext for the attached thread.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Boolean value. 1 = success, 0 = failure.  If the call was successful,
a RexxThreadContext object valid for the current context is returned via the
<emphasis role="italic">tc</emphasis> argument.
</para>
</section>

<section id="mthBufferData"><title>BufferData</title>
<indexterm><primary>BufferData</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>BufferData</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>BufferData</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>BufferData</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>BufferData</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxBufferObject obj;
POINTER str;

>>--str = context->BufferData(obj);--------------------------------------------><
]]>
</programlisting>
<para>Returns a pointer to a Buffer object's data area.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source Buffer object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The C pointer to the Buffer object's data area.</para>
</section>

<section id="mthBufferLength"><title>BufferLength</title>
<indexterm><primary>BufferLength</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>BufferLength</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>BufferLength</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>BufferLength</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>BufferLength</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxBufferObject obj;
size_t sz;

>>--sz = context->BufferLength(obj);-------------------------------------><
]]>
</programlisting>
<para>Return the length of a Buffer object's data area.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source Buffer object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The length of the Buffer object's data area.</para>
</section>

<section id="mthBufferStringData"><title>BufferStringData</title>
<indexterm><primary>BufferStringData</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>BufferStringData</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>BufferStringData</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>BufferStringData</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>BufferStringData</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxBufferStringObject obj;
POINTER str;

>>--str = context->BufferStringData(obj);--------------------------------------><
]]>
</programlisting>
<para>Returns a pointer to a RexxBufferString object's data area.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The C pointer to the RexxBufferString's data area.  This is a writable
data area, but the RexxBufferString must be finalized using
<link linkend="mthFinishBufferString">FinishBufferString()</link> before
it can be used in any other context.
</para>
</section>

<section id="mthBufferStringLength"><title>BufferStringLength</title>
<indexterm><primary>BufferStringLength</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>BufferStringLength</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>BufferStringLength</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>BufferStringLength</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>BufferStringLength</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxBufferStringObject obj;
size_t sz;

>>--sz = context->BufferStringLength(obj);-------------------------------><
]]>
</programlisting>
<para>Return the length of a RexxBufferStringObject instance.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source RexxBufferStringObject.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The length of the RexxBufferStringObject.</para>
</section>

<section id="mthCallProgram"><title>CallProgram</title>
<indexterm><primary>CallProgram</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>CallProgram</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>CallProgram</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>CallProgram</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>CallProgram</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
CSTRING name;
RexxObjectPtr ret;
RexxArrayObject arr;

>>--ret = context->CallProgram(name, arr);----------------------------><
]]>
</programlisting>
<para>Returns the result object of the routine.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The ASCII-Z path/name of the Rexx program to call.</para></entry>
    </row>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The Array of object arguments to the specified program.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Any result object returned by the program, if any.
Any errors involved with calling the program
will return a NULLOBJECT value.  The
<link linkend="mthCheckCondition">CheckCondition()</link>.
can be used to check if an error occurred during the call.
</para>
</section>

<section id="mthCallRoutine"><title>CallRoutine</title>
<indexterm><primary>CallRoutine</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>CallRoutine</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>CallRoutine</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>CallRoutine</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>CallRoutine</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj, ret;
RexxArrayObject arr;

>>--ret = context->CallRoutine(obj, arr);-----------------------------><
]]>
</programlisting>
<para>Returns the result object of the routine.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The routine object to call.</para></entry>
    </row>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The Array of object arguments to the specified routine.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Any result object returned by the routine, if any.
Any errors involved with calling the routine
will return a NULLOBJECT value.  The
<link linkend="mthCheckCondition">CheckCondition()</link>.
can be used to check if an error occurred during the call.
</para>
</section>

<section id="mthCheckCondition"><title>CheckCondition</title>
<indexterm><primary>CheckCondition</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>CheckCondition</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>CheckCondition</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>CheckCondition</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>CheckCondition</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
logical_t flag;

>>--flag = context->CheckCondition();------------------------------------><
]]>
</programlisting>
<para>Checks to see if any conditions have resulted from a call to a Rexx API.  .
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.
</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = if a condition has been raised, 0 = no condition raised.</para>
</section>

<section id="mthClearCondition"><title>ClearCondition</title>
<indexterm><primary>ClearCondition</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ClearCondition</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ClearCondition</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ClearCondition</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ClearCondition</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
>>--context->ClearCondition();-------------------------------------------><
]]>
</programlisting>
<para>Clears any pending condition status.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.
</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthCString"><title>CString</title>
<indexterm><primary>CString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>CString</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>CString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>CString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>CString</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
RexxStringObject ostr;
CSTRING str;

>>--str = context->CString(obj);-----------------------------------------><

>>--ostr = context->CString(str);----------------------------------------><
]]>
</programlisting>
<para>There are two forms of this method.
The first converts an Object into a C ASCII-Z string.
The second converts C ASCII-Z string into a String object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object for the conversion for the first form of the method.</para></entry>
    </row>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The source C ASCII-Z string for the conversion for the second form of the method.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>For the first method form, a CSTRING representation of the object is returned.
For the second form, a String object is created from the ASCII-Z string data..</para>
</section>

<section id="mthDecodeConditionInfo"><title>DecodeConditionInfo</title>
<indexterm><primary>DecodeConditionInfo</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DecodeConditionInfo</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>DecodeConditionInfo</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DecodeConditionInfo</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DecodeConditionInfo</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxDirectoryObject dirj;
RexxCondition cond;

>>--context->DecodeConditionInfo(dir, &cond);----------------------------><
]]>
</programlisting>
<para>Decodes the condition information into a RexxCondition structure.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">dir</emphasis></entry>
    <entry><para>The source Directory object containing the condition information.</para></entry>
    </row>
    <row><entry><emphasis role="italic">cond</emphasis></entry>
    <entry><para>A pointer to the RexxCondition structure.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthDetachThread"><title>DetachThread</title>
<indexterm><primary>DetachThread</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DetachThread</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>Nos</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
>>--context->DetachThread()-------------;-------------------------------><
]]>
</programlisting>
<para>Detaches the thread represented by the RexxThreadContext object from it's
interpreter instance.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthDirectoryAt"><title>DirectoryAt</title>
<indexterm><primary>DirectoryAt</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DirectoryAt</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>DirectoryAt</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DirectoryAt</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DirectoryAt</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxDirectoryObject dirobj;
RexxObjectPtr obj;
CSTRING str;

>>--obj = context->DirectoryAt(dirobj, str);-----------------------------><
]]>
</programlisting>
<para>Return the object at the specified index.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">dirobj</emphasis></entry>
    <entry><para>The source Directory object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The index into the Directory object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object at the specified index.  Returns NULLOBJECT if the given index does not exist.
</para>
</section>

<section id="mthDirectoryPut"><title>DirectoryPut</title>
<indexterm><primary>DirectoryPut</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DirectoryPut</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>DirectoryPut</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DirectoryPut</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DirectoryPut</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxDirectoryObject dirobj;
RexxObjectPtr index;
CSTRING str;

>>--context->DirectoryPut(dirobj, index, str);---------------------------><
]]>
</programlisting>
<para>Replace/add an Object to a Directory object at the specified index.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">dirobj</emphasis></entry>
    <entry><para>The source Directory object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">index</emphasis></entry>
    <entry><para>The ASCII-Z string index into the Directory object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The object instance to be stored at the index.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthDirectoryRemove"><title>DirectoryRemove</title>
<indexterm><primary>DirectoryRemove</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DirectoryRemove</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>DirectoryRemove</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DirectoryRemove</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DirectoryRemove</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxDirectoryObject dirobj;
RexxObjectPtr obj;
CSTRING str;

>>--obj = context->DirectoryRemove(dirobj, str);-------------------------><
]]>
</programlisting>
<para>Removes and returns the object at the specified index.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">dirobj</emphasis></entry>
    <entry><para>The source Directory object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The ASCII-Z index into the Directory object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object removed at the specified index.  Returns NULLOBJECT if the index
did not exist in the target Directory.
</para>
</section>

<section id="mthDouble"><title>Double</title>
<indexterm><primary>Double</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Double</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>Double</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Double</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Double</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
double n;
logical_t flag;

>>--obj = context->Double(n);--------------------------------------------><

>>--flag = context->Double(obj, &n);-------------------------------------><
]]>
</programlisting>
<para>There are two forms of this method.
The first form converts C double value to an Object.
The second form converts an Object to a C double value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The double value to be converted in the first form of the method.
       The target of the conversion in the second form of the method.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted..</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Returns an Object with the string value of the double value in the first form of the method.
0 - success, 1 = failure in the second form of the method.</para>
</section>

<section id="mthDoubleToObject"><title>DoubleToObject</title>
<indexterm><primary>DoubleToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DoubleToObject</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>DoubleToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DoubleToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DoubleToObject</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
double n;

>>--obj = context->DoubleToObject(n);------------------------------------><
]]>
</programlisting>
<para>Converts C double value to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The double value to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object with the string value of the double value.</para>
</section>

<section id="mthDoubleToObjectWithPrecision"><title>DoubleToObjectWithPrecision</title>
<indexterm><primary>DoubleToObjectWithPrecision</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DoubleToObjectWithPrecision</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>DoubleToObjectWithPrecision</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DoubleToObjectWithPrecision</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DoubleToObjectWithPrecision</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
size_t p;
double n;

>>--obj = context->DoubleToObject(n, p);---------------------------------><
]]>
</programlisting>
<para>Converts C double value to an Object with a specific precision.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The double value to be converted.</para></entry>
    </row>
    <row><entry><emphasis role="italic">p</emphasis></entry>
    <entry><para>The precision to be used for the conversion.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object with the string value of the double value.</para>
</section>

<section id="mthDropContextVariable"><title>DropContextVariable</title>
<indexterm><primary>DropContextVariable</primary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>DropContextVariable</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DropContextVariable</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
CSTRING name;

>>--context->DropContextVariable(name);-------------------------------><
]]>
</programlisting>
<para>Drops a Rexx variable in the current routines caller's variable context.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The name of the Rexx variable.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthDropObjectVariable"><title>DropObjectVariable</title>
<indexterm><primary>DropObjectVariable</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DropObjectVariable</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
CSTRING str;

>>--context->DropObjectVariable(str);------------------------------------><
]]>
</programlisting>
<para>Drops an instance variable in the current method's scope.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The name of the object variable.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthDropStemArrayElement"><title>DropStemArrayElement</title>
<indexterm><primary>DropStemArrayElement</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DropStemArrayElement</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>DropStemArrayElement</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DropStemArrayElement</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DropStemArrayElement</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxStemObject sobj;
size_t n;

>>--context->DropStemArrayElement(sobj, n);------------------------------><
]]>
</programlisting>
<para>Drops an element of the Stem object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The target Stem object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The Stem object element number.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthDropStemElement"><title>DropStemElement</title>
<indexterm><primary>DropStemElement</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>DropStemElement</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>DropStemElement</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>DropStemElement</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>DropStemElement</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxStemObject sobj;
CSTRING name;

>>--context->DropStemElement(sobj, name);--------------------------------><
]]>
</programlisting>
<para>Drops an element of the Stem object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The target Stem object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The Stem object element name.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthFalse"><title>False</title>
<indexterm><primary>False</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>False</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>False</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>False</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>False</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;

>>--obj = context->False();----------------------------------------------><
]]>
</programlisting>
<para>This method returns the Rexx .false ( 0 ) object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Rexx .false object.</para>
</section>

<section id="mthFindClass"><title>FindClass</title>
<indexterm><primary>FindClass</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>FindClass</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>FindClass</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>FindClass</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>FindClass</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxClassObject class;
CSTRING name;

>>--class = context->FindClass(name);---------------------------------><
]]>
</programlisting>
<para>Locates a Class object in the current thread context.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>An ASCII-Z string containing the name of the class.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The located Class object.  Returns NULLOBJECT if the class is not found.</para>
</section>

<section id="mthFindContextClass"><title>FindContextClass</title>
<indexterm><primary>FindContextClass</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>FindContextClass</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
CSTRING name;
RexxClassObject obj;

>>--obj = context->FindContextClass(name);-------------------------------><
]]>
</programlisting>
<para>Locate a Class object in the current Method or Routine Package context.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The class name to be located.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The located Class object.  Returns NULLOBJECT if the class is not found.</para>
</section>

<section id="mthFindPackageClass"><title>FindPackageClass</title>
<indexterm><primary>FindPackageClass</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>FindPClass</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>FindPackageClass</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>FindPackageClass</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>FindPackageClass</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxPackageObject pkg;
RexxClassObject class;
CSTRING name;

>>--class = context->FindPackageClass(pkg, name);---------------------><
]]>
</programlisting>
<para>Locate a class object in a given Package object's context.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">pkg</emphasis></entry>
    <entry><para>The Package object used to resolve the cllass.</para></entry>
    </row>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>An ASCII-Z string containing the name of the class.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The located Class object.  Returns NULLOBJECT if the class is not found.</para>
</section>

<section id="mthFinishBufferString"><title>FinishBufferString</title>
<indexterm><primary>FinishBufferString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>FinishBufferString</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>FinishBufferString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>FinishBufferString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>FinishBufferString</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxBufferStringObject obj;
RexxStringObject strobj;
size_t len;

>>--str = context->FinishBufferString(obj, len);---------------------------><
]]>
</programlisting>
<para>Converts a RexxBufferStringObject into a completed, immutable String object of the
given length and returns a reference to the completed String object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The working RexxBufferStringObject.</para></entry>
    </row>
    <row><entry><emphasis role="italic">len</emphasis></entry>
    <entry><para>The final length of the constructed string.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The finalized Rexx string object.</para>
</section>

<section id="mthForwardMessage"><title>ForwardMessage</title>
<indexterm><primary>ForwardMessage</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ForwardMessage</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
CSTRING str;
RexxObjectPtr obj, ret;
RexxClassObject sobj;
RexxArrayObject arr;

>>--ret = context->ForwardMessage(obj, str, cobj, arr);------------------><
]]>
</programlisting>
<para>Forwards a message to a different object or method.  This is
equivalent to using a FORWARD CONTINUE instruction from Rexx code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to receive the message.  If NULL, the object
    that is the target of the current method call is used.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The message name to use.  If NULL, then the name of the current method
    is used.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">cobj</emphasis></entry>
    <entry><para>The class scope used to located the method.  If NULL, this will be
    an unscoped method call.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The Array of message arguments.  If NULL, the same arguments
    that were used on the current method invocation will be used.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The invoked message result.  NULLOBJECT will be returned if the
target method does not return a result.</para>
</section>

<section id="mthGetAllContextVariables"><title>GetAllContextVariables</title>
<indexterm><primary>GetAllContextVariables</primary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetAllContextVariables</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetAllContextVariables</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxDirectoryObject obj;

>>--obj = context->GetAllContextVariables();--------------------------><
]]>
</programlisting>
<para>Returns all the Rexx variables in the current routine's caller's context as
a Directory.  Only simple variables and stem variables are included in the Directory.
Stem variable entries will have a Stem object as the value.  Compound variables
may be accessed via the Stem object values.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A RexxDirectoryObject with the variable names and values.</para>
</section>

<section id="mthGetAllStemElements"><title>GetAllStemElements</title>
<indexterm><primary>GetAllStemElements</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetAllStemElements</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetAllStemElements</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetAllStemElements</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetAllStemElements</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxStemObject sobj;
RexxDirectoryObject obj;

>>--obj = context->GetAllStemElements(sobj);-----------------------------><
]]>
</programlisting>
<para>Returns all elements of a Stem object as a Directory object.
Each assigned Stem tail element will be an entry in the Directory.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source Stem object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Directory object containing the Stem variable values.</para>
</section>

<section id="mthGetApplicationData"><title>GetApplicationData</title>
<indexterm><primary>GetApplicationData</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetApplicationData</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetApplicationData</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetApplicationData</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetApplicationData</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
>>--ptr = context->GetApplicationData();------------------------------><
]]>
</programlisting>
<para>Returns the application data pointer that was set via the APPLICATION_DATA
option when the intepreter instance was created.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The application instance data set when the interpreter instance was created.</para>
</section>

<section id="mthGetArgument"><title>GetArgument</title>
<indexterm><primary>GetArgument</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetArgument</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetArgument</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
size_t n;

>>--obj = context->GetArgument(n);------------------------------------><
]]>
</programlisting>
<para>Returns the specified argument to the method or routine.  This
is equivalent to calling Arg(n) from within Rexx code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The argument number (1-based).</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object corresponding to the given argument position.  Returns
NULLOBJECT if the argument was not specified.
</para>
</section>

<section id="mthGetArguments"><title>GetArguments</title>
<indexterm><primary>GetArguments</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetArguments</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetArguments</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxArrayObject arr;

>>--arr = context->GetArguments();------------------------------------><
]]>
</programlisting>
<para>Returns an Array object of the arguments to the method or routine.
This is the same argument Array returned by the ARGLIST argument type.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Array object containing the method or routine arguments.</para>
</section>

<section id="mthGetCallerContext"><title>GetCallerContext</title>
<indexterm><primary>GetCallerContext</primary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetCallerContext</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetCallerContext</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;

>>--obj = context->GetCallerContext();--------------------------------><
]]>
</programlisting>
<para>Get the RexxContext object corresponding to the routine or exit's
calling context.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current exit or routine caller's RexxContext object.</para>
</section>

<section id="mthGetConditionInfo"><title>GetConditionInfo</title>
<indexterm><primary>GetConditionInfo</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetConditionInfo</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetConditionInfo</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetConditionInfo</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetConditionInfo</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxDirectoryObject dir;

>>--dir = context->GetConditionInfo();--------------------------------><
]]>
</programlisting>
<para>Returns a Directory object containing the condition information.
This is equivalent to calling Condition('O') from within Rexx code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The RexxDirectoryObject containing the condition information.  If
there are no pending conditions, NULLOBJECT is returned.
</para>
</section>

<section id="mthGetContextDigits"><title>GetContextDigits</title>
<indexterm><primary>GetContextDigits</primary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetContextDigits</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
stringsize_t sz;

>>--sz = context->GetContextDigits();---------------------------------><
]]>
</programlisting>
<para>Get the routine caller's current NUMERIC DIGITS setting.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current NUMERIC DIGITS setting.</para>
</section>

<section id="mthGetContextForm"><title>GetContextForm</title>
<indexterm><primary>GetContextForm</primary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetContextForm</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
stringsize_t sz;

>>--sz = context->GetContextForm();-----------------------------------><
]]>
</programlisting>
<para>Get the routine caller's current NUMERIC FORM setting.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current NUMERIC FORM setting.</para>
</section>

<section id="mthGetContextFuzz"><title>GetContextFuzz</title>
<indexterm><primary>GetContextFuzz</primary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetContextFuzz</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
stringsize_t sz;

>>--sz = context->GetContextFuzz();-----------------------------------><
]]>
</programlisting>
<para>Get the routine caller's current NUMERIC FUZZ setting.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current NUMERIC FUZZ setting.</para>
</section>

<section id="mthGetContextVariable"><title>GetContextVariable</title>
<indexterm><primary>GetContextVariable</primary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetContextVariable</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetContextVariable</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
CSTRING name;

>>--obj = context->GetContextVariable(name);--------------------------><
]]>
</programlisting>
<para>Gets the value of a Rexx variable in the routine caller's variable context.
Only simple variables and stem variables can be retrieved with GetContextVariable().
The value returned for a stem variable will be the corresponding Stem object.
Compound variable values can be retrieved from the corresponding Stem values.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The name of the Rexx variable.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A the value of the named variable.  Returns NULLOBJECT if the variable
has not been assigned a value.</para>
</section>

<section id="mthGetGlobalEnvironment"><title>GetGlobalEnvironment</title>
<indexterm><primary>GetGlobalEnvironment</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetGlobalEnvironment</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetGlobalEnvironment</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetGlobalEnvironment</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetGlobalEnvironment</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxDirectoryObject dir;

>>--dir = context->GetGlobalEnvironment();----------------------------><
]]>
</programlisting>
<para>Returns a reference to the .environment Directory.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A RexxDirectoryObject pointer to the .environment Directory.</para>
</section>

<section id="mthGetLocalEnvironment"><title>GetLocalEnvironment</title>
<indexterm><primary>GetLocalEnvironment</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetLocalEnvironment</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetLocalEnvironment</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetLocalEnvironment</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetLocalEnvironment</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxDirectoryObject dir;

>>--dir = context->GetLocalEnvironment();-----------------------------><
]]>
</programlisting>
<para>Returns a reference to the interpreter instance .local Directory.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A RexxDirectoryObject pointer to the .local Directory.</para>
</section>

<section id="mthGetMessageName"><title>GetMessageName</title>
<indexterm><primary>GetMessageName</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetMessageName</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
CSTRING str;

>>--str = context->GetMessageName(obj);-------------------------------><
]]>
</programlisting>
<para>Returns the message name used to invoke the current Method.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current Method message name.</para>
</section>

<section id="mthGetMethod"><title>GetMethod</title>
<indexterm><primary>GetMethod</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetMethod</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxMethodObject obj;

>>--obj = context->GetMethod();---------------------------------------><
]]>
</programlisting>
<para>Returns the method object for the method currently being executed.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current Method object.</para>
</section>

<section id="mthGetMethodPackage"><title>GetMethodPackage</title>
<indexterm><primary>GetMethodPackage</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetMethodPackage</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetMethodPackage</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetMethodPackage</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetMethodPackage</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxMethodObject obj;
RexxPackageObject pkg;

>>--pkg = context->GetMethodPackage(obj);-----------------------------><
]]>
</programlisting>
<para>Returns the Package object associated with the specified method.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The Method object to query.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The method's defining Package object.</para>
</section>

<section id="mthGetObjectVariable"><title>GetObjectVariable</title>
<indexterm><primary>GetObjectVariable</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetObjectVariable</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
CSTRING str;
RexxObjectPtr obj;

>>--obj = context->GetObjectVariable(str);-------------------------------><
]]>
</programlisting>
<para>Gets the value of a Rexx instance variable from the current method's object scope context.
Only simple variables and stem variables can be retrieved with GetContextVariable().
The value returned for a stem variable will be the corresponding Stem object.
Compound variable values can be retrieved from the corresponding Stem values.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The name of the object variable.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object assigned to the object variable.  Returns NULLOBJECT if the
variable has not been assigned a value.</para>
</section>

<section id="mthGetPackageClasses"><title>GetPackageClasses</title>
<indexterm><primary>GetPackageClasses</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetPackageClasses</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetPackageClasses</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetPackageClasses</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetPackageClasses</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxDirectoryObject dir;
RexxPackageObject pkg;

>>--dir = context->GetPackageClasses(pkg);----------------------------><
]]>
</programlisting>
<para>Returns a Directory object containing all public and private classes (name and object) from the specified package object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The package object to query.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A Directory object containing the package classes.</para>
</section>

<section id="mthGetPackageMethods"><title>GetPackageMethods</title>
<indexterm><primary>GetPackageMethods</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetPackageMethods</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetPackageMethods</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetPackageMethods</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetPackageMethods</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxDirectoryObject dir;
RexxPackageObject pkg;

>>--dir = context->GetPackageMethods(pkg);----------------------------><
]]>
</programlisting>
<para>Returns a Directory object containing the unattached methods
(name and object) from the specified package object.  This is equivalent to
using the .methods environment symbol from Rexx code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The package routine object to query.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A Directory object containing the unattached methods.</para>
</section>

<section id="mthGetPackagePublicClasses"><title>GetPackagePublicClasses</title>
<indexterm><primary>GetPackagePublicClasses</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetPackagePublicClasses</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetPackagePublicClasses</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetPackagePublicClasses</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetPackagePublicClasses</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxDirectoryObject dir;
RexxPackageObject pkg;

>>--dir = context->GetPackagePublicClasses(pkg);----------------------><
]]>
</programlisting>
<para>Returns a Directory object containing the public classes (name and object) from the specified package object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The package object to query.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A Directory object containing the public classes.</para>
</section>

<section id="mthGetPackagePublicRoutines"><title>GetPackagePublicRoutines</title>
<indexterm><primary>GetPackagePublicRoutines</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetPackagePublicRoutines</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetPackagePublicRoutines</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetPackagePublicRoutines</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetPackagePublicRoutines</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxDirectoryObject dir;
RexxPackageObject pkg;

>>--dir = context->GetPackagePublicRoutines(pkg);---------------------><
]]>
</programlisting>
<para>Returns a Directory object containing the public routines (name and object) from the specified package object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The package object to query.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A Directory object containing the public routines.</para>
</section>

<section id="mthGetPackageRoutines"><title>GetPackageRoutines</title>
<indexterm><primary>GetPackageRoutines</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetPackageRoutines</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetPackageRoutines</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetPackageRoutines</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetPackageRoutines</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxDirectoryObject dir;
RexxPackageObject pkg;

>>--dir = context->GetPackageRoutines(pkg);---------------------------><
]]>
</programlisting>
<para>Returns a Directory object containing the public and private routines (name and object) from the specified package object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The package routine object to query.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A Directory object containing the routines.</para>
</section>

<section id="mthGetRoutine"><title>GetRoutine</title>
<indexterm><primary>GetRoutine</primary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetRoutine</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxRoutineObject obj;

>>--obj = context->GetRoutine();--------------------------------------><
]]>
</programlisting>
<para>Returns current Routine object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current Routine object.</para>
</section>

<section id="mthGetRoutineName"><title>GetRoutineName</title>
<indexterm><primary>GetRoutineName</primary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetRoutineName</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
CSTRING name;

>>--name = context->GetRoutineName();---------------------------------><
]]>
</programlisting>
<para>Returns name of the current routine.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A pointer ASCII-Z routine name.</para>
</section>

<section id="mthGetRoutinePackage"><title>GetRoutinePackage</title>
<indexterm><primary>GetRoutinePackage</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetRoutinePackage</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetRoutinePackage</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetRoutinePackage</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetRoutinePackage</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxRoutineObject obj;
RexxPackageObject pkg;

>>--pkg = context->GetRoutinePackage(obj);----------------------------><
]]>
</programlisting>
<para>Returns Package object for the specified Routine object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The routine object to query.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Package object instance.</para>
</section>

<section id="mthGetScope"><title>GetScope</title>
<indexterm><primary>GetScope</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetScope</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;

>>--obj = context->GetScope();----------------------------------------><
]]>
</programlisting>
<para>Return the scope of the currently active Method.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current Method's scope.</para>
</section>

<section id="mthGetSelf"><title>GetSelf</title>
<indexterm><primary>GetSelf</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetSelf</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;

>>--obj = context->GetSelf();-----------------------------------------><
]]>
</programlisting>
<para>Returns the Object that was the target of the current method invocation.  This
is equivalent to the SELF variable in a Rexx method.  The same value can be accessed as a method
argument by using the OSELF type.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current SELF object.</para>
</section>

<section id="mthGetStemArrayElement"><title>GetStemArrayElement</title>
<indexterm><primary>GetStemArrayElement</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetStemArrayElement</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetStemArrayElement</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetStemArrayElement</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetStemArrayElement</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxStemObject sobj;
RexxObjectPtr obj;
size_t n;

>>--obj = context->GetStemArrayElement(sobj, n);-------------------------><
]]>
</programlisting>
<para>Gets an element of the Stem object using a numeric index.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source Stem object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The Stem object element number.  The numeric index is
       translated into the corresponding String tail.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Stem object element or NULLOBJECT if the target name has not been assigned a value.</para>
</section>

<section id="mthGetStemElement"><title>GetStemElement</title>
<indexterm><primary>GetStemElement</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetStemElement</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetStemElement</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetStemElement</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetStemElement</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxStemObject sobj;
RexxObjectPtr obj;
CSTRING name;

>>--obj = context->GetStemElement(sobj, name);---------------------------><
]]>
</programlisting>
<para>Gets an element of the Stem object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source Stem object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The Stem object element name.  This is a fully
    resolved tail name, taken as a constant.  No variable substitution is
    performed on the tail.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Stem object element or NULLOBJECT if the target element
has not been assigned a value.</para>
</section>

<section id="mthGetStemValue"><title>GetStemValue</title>
<indexterm><primary>GetStemValue</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>GetStemValue</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>GetStemValue</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetStemValue</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>GetStemValue</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxStemObject sobj;
RexxObjectPtr obj;
CSTRING name;

>>--obj = context->GetStemValue(sobj);-----------------------------------><
]]>
</programlisting>
<para>Gets the base name value of the Stem object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source Stem object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Stem object's default base value.</para>
</section>

<section id="mthGetSuper"><title>GetSuper</title>
<indexterm><primary>GetSuper</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>GetSuper</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;

>>--obj = context->GetSuper();----------------------------------------><
]]>
</programlisting>
<para>Returns the current method's super class scope.  This is equivalent to the
SUPER variable used from Rexx code.  This value can also be obtained via the SUPER method
argument type.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The current method's SUPER scope.</para>
</section>

<section id="mthHalt"><title>Halt</title>
<indexterm><primary>Halt</primary></indexterm>
<indexterm><primary>Rexx instance context methods</primary>
<secondary>Halt</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>Yes</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
>>--context->Halt();-----------------------------------------------------><
]]>
</programlisting>
<para>Raise a HALT condition on all threads associated with the interpreter instance.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthHaltThread"><title>HaltThread</title>
<indexterm><primary>HaltThread</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>HaltThread</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>Nos</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
>>--context->HaltThread();----------------------------------------------><
]]>
</programlisting>
<para>Raises a HALT condition on the thread corresponding to the current
<emphasis role="italic">context</emphasis> pointer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthHasMethod"><title>HasMethod</title>
<indexterm><primary>HasMethod</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>HasMethod</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>HasMethod</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>HasMethod</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>HasMethod</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Tes</entry></row>
<row><entry>Function</entry><entry>Tes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
logical_t flag;
RexxObjectPtr obj;
CSTRING name;

>>--flag = context->HasMethod(obj, name);-------------------------------><
]]>
</programlisting>
<para>Returns a boolean indicating if an object has the specified method available.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to query.</para></entry>
    </row>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>An ASCII-Z string containing the name of the method.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = has the method available, 0 = does not have the method available.</para>
</section>

<section id="mthInvalidRoutine"><title>InvalidRoutine</title>
<indexterm><primary>InvalidRoutine</primary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>InvalidRoutine</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxDirectoryObject obj;

>>--context->InvalidRoutine();----------------------------------------><
]]>
</programlisting>
<para>Raises the standard Error 40 Invalid call to routine error for the
current routine.  This error will be raised by the Rexx runtime once your routine
returns.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthInt32"><title>Int32</title>
<indexterm><primary>Int32</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Int32</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>Int32</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Int32</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Int32</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag;
int32_t n;

>>--obj = context->Int32(n);---------------------------------------------><

>>--logical_t = context->Int32(obj, &n);---------------------------------><
]]>
</programlisting>
<para>There a two forms of this method.
The first converts a C 32-bit integer <emphasis role="italic">n</emphasis> to an Object.
The second converts an Object to a C 32-bit integer, returning it in the location pointed to by <emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The to be converted or a pointer to return the conversion result.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object that represents the C integer in the first form.
The second form returns 1 = success, 0 = failure.  If successful, the converted value is
stored at the location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthInt32ToObject"><title>Int32ToObject</title>
<indexterm><primary>Int32ToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Int32ToObject</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>Int32ToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Int32ToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Int32ToObject</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
int32_t n;

>>--obj = context->Int32ToObject(n);-------------------------------------><
]]>
</programlisting>
<para>Convert a C 32-bit integer <emphasis role="italic">n</emphasis> to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The integer to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object representing the integer value.</para>
</section>

<section id="mthInt64"><title>Int64</title>
<indexterm><primary>Int64</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Int64</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>Int64</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Int64</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Int64</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag;
int64_t n;

>>--obj = context->Int64(n);---------------------------------------------><

>>--logical_t = context->Int64(obj, &n);---------------------------------><
]]>
</programlisting>
<para>There a two forms of this method.
The first converts a C 64-bit integer <emphasis role="italic">n</emphasis> to an Object.
The second converts an Object to a C 64-bit integer and returns in the area pointed to by <emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The integer to be converted or the location for returning the converted integer.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object version of the integer value in the first form.
The second form returns 1 = success, 0 = failure.  If successful, the converted value is
stored at the location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthInt64ToObject"><title>Int64ToObject</title>
<indexterm><primary>Int64ToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Int64ToObject</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>Int64ToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Int64ToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Int64ToObject</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
int64_t n;

>>--obj = context->Int64ToObject(n);-------------------------------------><
]]>
</programlisting>
<para>Convert the C 64-bit integer <emphasis role="italic">n</emphasis> to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The integer to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>An Object representing the integer value.</para>
</section>

<section id="mthInterpreterVersion"><title>InterpreterVersion</title>
<indexterm><primary>InterpreterVersion</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>InterpreterVersion</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>InterpreterVersion</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>InterpreterVersion</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>InterpreterVersion</secondary></indexterm>
<indexterm><primary>Rexx instance context methods</primary>
<secondary>InterpreterVersion</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Tes</entry></row>
<row><entry>Function</entry><entry>Tes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>Yes</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
size_t version;

>>--version = context->InterpreterVersion();----------------------------><
]]>
</programlisting>
<para>Returns the version of the interpreter.  The returned version
is encoded in the 3 least significant bytes of the returned value, using
1 byte each for the interpreter version, release, and revision values.
For example, on a 32-bit platform, this value would be 0x00040000 for
version 4.0.0.  The oorexxapi.h header file will have a define matching
these values using a the naming convention REXX_INTERPRETER_4_0_0 and the
macro REXX_CURRENT_INTERPRETER_VERSION will give the interpreter version
used to compile your code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The interpreter version number.</para>
</section>

<section id="mthIntptr"><title>Intptr</title>
<indexterm><primary>Intptr</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Intptr</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>Intptr</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Intptr</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Intptr</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag;
intptr_t n;

>>--obj = context->Intptr(&n);-------------------------------------------><

>>--flag = context->Intptr(obj, &n);-------------------------------------><
]]>
</programlisting>
<para>There are two forms of this method.
The first converts the C signed integer <emphasis role="italic">n</emphasis> to an Object.
The second converts an Object to a C signed integer and returns it in the location
pointed to by <emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The C pointer to the signed integer to be converted in the first form.
       The target of the conversion in the second form.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>An Object version of the integer value in the first form.
The second form returns 1 = success, 0 = failure.  If successful, the converted value is
stored at the location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthIntptrToObject"><title>IntptrToObject</title>
<indexterm><primary>IntptrToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IntptrToObject</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>IntptrToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IntptrToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IntptrToObject</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
intptr_t n;

>>--obj = context->IntptrToObject(&n);-----------------------------------><
]]>
</programlisting>
<para>Convert the C signed integer <emphasis role="italic">n</emphasis> to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The signed integer to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object representing the integer value.</para>
</section>

<section id="mthIsArray"><title>IsArray</title>
<indexterm><primary>IsArray</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsArray</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsArray</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>IsArray</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsArray</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

>>--flag = context->IsArray(obj);---------------------------------------><
]]>
</programlisting>
<para>Tests if an Object is an Array.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxArrayObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is an Array object, 0 = not an Array object.</para>
</section>

<section id="mthIsBuffer"><title>IsBuffer</title>
<indexterm><primary>IsBuffer</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsBuffer</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsBuffer</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>IsBuffer</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsBuffer</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

>>--flag = context->IsBuffer(obj);--------------------------------------><
]]>
</programlisting>
<para>Tests if an Object is a Buffer object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxBufferObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a Buffer object, 0 = not a Buffer object.</para>
</section>

<section id="mthIsDirectory"><title>IsDirectory</title>
<indexterm><primary>IsDirectory</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsDirectory</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsDirectory</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>IsDirectory</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsDirectory</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

>>--flag = context->IsDirectory(obj);-----------------------------------><
]]>
</programlisting>
<para>Tests if an Object is a Directory object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxDirectoryObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a Directory object, 0 = not a Directory object.</para>
</section>

<section id="mthIsInstanceOf"><title>IsInstanceOf</title>
<indexterm><primary>IsInstanceOf</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsInstanceOf</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsInstanceOf</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>IsInstanceOf</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsInstanceOf</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
RexxClassObj class;
logical_t flag;

>>--flag = context->IsInstanceOf(obj, class);---------------------------><
]]>
</programlisting>
<para>Tests if an Object is an instance of the specified class.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The Object to be tested.</para></entry>
    </row>
    <row><entry><emphasis role="italic">class</emphasis></entry>
    <entry><para>The Class object for the instance test.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is an instance, 0 = not an instance.</para>
</section>

<section id="mthIsMethod"><title>IsMethod</title>
<indexterm><primary>IsMethod</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsMethod</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsMethod</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>IsMethod</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsMethod</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

>>--flag = context->IsMethod(obj);--------------------------------------><
]]>
</programlisting>
<para>Tests if an Object is a Method object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxMethodObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a Method object, 0 = not a Method object.</para>
</section>

<section id="mthIsOfType"><title>IsOfType</title>
<indexterm><primary>IsOfType</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsOfType</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsOfType</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>IsOfType</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsOfType</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
CSTRING class;
logical_t flag;

>>--flag = context->IsOfType(obj, class);-------------------------------><
]]>
</programlisting>
<para>Tests an object to see if is an of the named class.
This method combines the operations of the FindClass() and IsInstanceOf() methods in a single call.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
    <row><entry><emphasis role="italic">class</emphasis></entry>
    <entry><para>An ASCII-Z string containing the name of the Rexx class.  The named class will
    be located in the current context and used in an IsInstanceOf() test.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is an instance, 0 = not an instance or the named class cannot be located.</para>
</section>

<section id="mthIsPointer"><title>IsPointer</title>
<indexterm><primary>IsPointer</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsPointer</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsPointer</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>IsRPointer</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsPointer</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

>>--flag = context->IsPointer(obj);-------------------------------------><
]]>
</programlisting>
<para>Tests if an Object is a Pointer object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxPointerObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a Pointer object, 0 = not a Pointer object.</para>
</section>

<section id="mthIsRoutine"><title>IsRoutine</title>
<indexterm><primary>IsRoutine</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsRoutine</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsRoutine</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>IsRoutine</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsRoutine</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

>>--flag = context->IsRoutine(obj);-------------------------------------><
]]>
</programlisting>
<para>Tests if an Object a Routine object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxPointerObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a Routine object, 0 = not a Routine object.</para>
</section>

<section id="mthIsStem"><title>IsStem</title>
<indexterm><primary>IsStem</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsStem</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsStem</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>IsStem</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsStem</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

>>--flag = context->IsStem(obj);----------------------------------------><
]]>
</programlisting>
<para>Tests if an Object is a Stem object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxStemObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a Stem object, 0 = not a Stem object.</para>
</section>

<section id="mthIsString"><title>IsString</title>
<indexterm><primary>IsString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>IsString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>IsString</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>IsString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>IsString</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag;

>>--flag = context->IsString(obj);--------------------------------------><
]]>
</programlisting>
<para>Tests if an Object is a String object.
A true result indicates
the RexxObjectPtr value may be safely cast to a RexxStringObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be tested.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = is a String object, 0 = not a String object.</para>
</section>

<section id="mthLanguageLevel"><title>LanguageLevel</title>
<indexterm><primary>Language Level</primary></indexterm>
<indexterm><primary>Rexx instance context methods</primary>
<secondary>LanguageLevel</secondary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>LanguageLevel</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>LanguageLevel</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>LanguageLevel</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>LanguageLevel</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Tes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>Yes</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
size_t langlevel;

>>--langlevel = context->LanguageLevel();-------------------------------><
]]>
</programlisting>
<para>Returns the language blevel of the interpreter.
The returned language level
is encoded in the 2 least significant bytes of the returned value, using
1 byte each for the interpreter version, release, and revision values.
For example, on a 32-bit platform, this value would be 0x00000603 for
language level 6.03.  The oorexxapi.h header file will have a define matching
these values using a the naming convention REXX_LANGUAGE_6_03 and the
macro REXX_CURRENT_LANGUAGE_LEVEL will give the interpreter version
used to compile your code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The interpreter language level number.</para>
</section>

<section id="mthLoadPackage"><title>LoadPackage</title>
<indexterm><primary>LoadPackage</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>LoadPackage</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>LoadPackage</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>LoadPackage</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>LoadPackage</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
CSTRING name;
RexxPackageObject pkg;

>>--pkg = context->LoadPackage(name);---------------------------------><
]]>
</programlisting>
<para>Returns the package object loaded from the specified file path/name.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The ASCII-Z path/name of the Rexx package to load.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The loaded Package object.
Any errors involved with loading
the package will return a NULLOBJECT value.  Information about errors
can be retrieved using <link linkend="mthGetConditionInfo">GetConditionInfo()</link>.
</para>
</section>

<section id="mthLoadPackageFromData"><title>LoadPackageFromData</title>
<indexterm><primary>LoadPackageFromData</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>LoadPackageFromData</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>LoadPackageFromData</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>LoadPackageFromData</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>LoadPackageFromData</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
CSTRING name, data;
size_t sz;
RexxPackageObject pkg;

>>--pkg = context->LoadPackageFromData(name, data, sz);---------------><
]]>
</programlisting>
<para>Returns the loaded package object  from the specified file path/name.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The ASCII-Z name of the Rexx package to load.</para></entry>
    </row>
    <row><entry><emphasis role="italic">data</emphasis></entry>
    <entry><para>Data buffer containing the Rexx code to load.</para></entry>
    </row>
    <row><entry><emphasis role="italic">sz</emphasis></entry>
    <entry><para>The size of the <emphasis role="italic">data</emphasis> buffer.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The loaded Package object.
Any errors involved with loading
the package will return a NULLOBJECT value.  Information about errors
can be retrieved using <link linkend="mthGetConditionInfo">GetConditionInfo()</link>.
</para>
</section>

<section id="mthLogical"><title>Logical</title>
<indexterm><primary>Logical</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Logical</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>Logical</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Logical</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Logical</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag, n;

>>--flag = context->Logical(obj, &n);------------------------------------><

>>--obj = context->Logical(n);-------------------------------------------><
]]>
</programlisting>
<para>This method has two forms.
The first form converts an Object to a C logical value (0 or 1).
The second form converts a C logical value to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>For the first method form, a C pointer to a logical_t to receive the conversion result.
       For the second form, a logical_t to be converted to an Object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>For the first method form, 1 = success and 0 = conversion error,  with the converted value returned in the
location pointed to by <emphasis role="italic">n</emphasis>
For the second form,
an Object version of the logical value is returned.</para>
</section>

<section id="mthLogicalToObject"><title>LogicalToObject</title>
<indexterm><primary>LogicalToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>LogicalToObject</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>LogicalToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>LogicalToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>LogicalToObject</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag, n;

>>--obj = context->LogicalToObject(n);-----------------------------------><
]]>
</programlisting>
<para>Converts a C logical value to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The logical_t value to be converted..</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Either the .false or .true object is returned.</para>
</section>

<section id="mthNewArray"><title>NewArray</title>
<indexterm><primary>NewArray</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewArray</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>NewArray</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewArray</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewArray</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxArrayObject obj;
size_t len;

>>--obj = context->NewArray(d);------------------------------------------><
]]>
</programlisting>
<para>Create an Array object of the specified size.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">d</emphasis></entry>
    <entry><para>The size of the Array.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Array object.</para>
</section>

<section id="mthNewBuffer"><title>NewBuffer</title>
<indexterm><primary>NewBuffer</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewBuffer</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>NewBuffer</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewBuffer</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewBuffer</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxBufferObject obj;
size_t len;

>>--obj = context->NewBuffer(len);---------------------------------------><
]]>
</programlisting>
<para>Create a Buffer object with a specific data size.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">len</emphasis></entry>
    <entry><para>The maximum length of the buffer.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Buffer object.</para>
</section>

<section id="mthNewBufferString"><title>NewBufferString</title>
<indexterm><primary>NewBufferString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewBufferString</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>NewBufferString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewBufferString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewBufferString</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxBufferStringObject obj;
size_t len;

>>--obj = context->NewBufferString(len);---------------------------------><
]]>
</programlisting>
<para>Create a RexxBufferString with the indicated buffer size.  A RexxBufferString
is a mutable String object that can be used to construct return values.  You
must use <link linkend="mthFinishBufferString">FinishBufferString()</link> to
transform this into a completed String object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">len</emphasis></entry>
    <entry><para>The maximum length of the final String object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A new RexxBufferString value.</para>
</section>

<section id="mthNewDirectory"><title>NewDirectory</title>
<indexterm><primary>NewDirectory</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewDirectory</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>NewDirectory</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewBDirectory</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewDirectory</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxDirectoryObject obj;

>>--obj = context->NewDirectory();---------------------------------------><
]]>
</programlisting>
<para>Create a Directory object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Directory object.</para>
</section>

<section id="mthNewMethod"><title>NewMethod</title>
<indexterm><primary>NewMethod</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewMethod</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>NewMethod</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewMethod</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewMethod</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxMethodObject obj;
CSTRING name, code;
size_t sz;

>>--obj = context->NewMethod(name, code, sz);----------------------------><
]]>
</programlisting>
<para>Create a new Method object from an in-memory buffer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>ASCII-Z name of the method.</para></entry>
    </row>
    <row><entry><emphasis role="italic">code</emphasis></entry>
    <entry><para>A data buffer containing the new method's Rexx code.</para></entry>
    </row>
    <row><entry><emphasis role="italic">sz</emphasis></entry>
    <entry><para>Size of the <emphasis role="italic">code</emphasis> buffer.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The created Method object.
Any errors involved with creating the method
the package will return a NULLOBJECT value.  Information about errors
can be retrieved using <link linkend="mthGetConditionInfo">GetConditionInfo()</link>.
</para>
</section>

<section id="mthNewPointer"><title>NewPointer</title>
<indexterm><primary>NewPointer</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewPointer</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>NewPointer</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewPointer</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewPointer</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxPointerObject obj;
POINTER p;

>>--obj = context->NewPointer(p);----------------------------------------><
]]>
</programlisting>
<para>Create a new Pointer object from a C pointer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">p</emphasis></entry>
    <entry><para>The source C pointer.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The created Pointer object.</para>
</section>

<section id="mthNewRoutine"><title>NewRoutine</title>
<indexterm><primary>NewRoutine</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewRoutine</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>NewRoutine</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewRoutine</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewRoutine</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxRoutineObject obj;
CSTRING name, code;
size_t sz;

>>--obj = context->NewRoutine(name, code, sz);---------------------------><
]]>
</programlisting>
<para>Create a new Routine object from an in-memory buffer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>ASCII-Z name of the routine.</para></entry>
    </row>
    <row><entry><emphasis role="italic">code</emphasis></entry>
    <entry><para>Buffer containing the routine Rexx code.</para></entry>
    </row>
    <row><entry><emphasis role="italic">sz</emphasis></entry>
    <entry><para>Size of the <emphasis role="italic">code</emphasis> buffer.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Routine object.
Any errors involved with creating the method
the package will return a NULLOBJECT value.  Information about errors
can be retrieved using <link linkend="mthGetConditionInfo">GetConditionInfo()</link>.
</para>
</section>

<section id="mthNewStem"><title>NewStem</title>
<indexterm><primary>NewStem</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewStem</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>NewStem</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewStem</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewStem</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxStemObject obj;
CSTRING str;

>>--obj = context->NewStem(str);-----------------------------------------><
]]>
</programlisting>
<para>Create an new Stem object with the specified base name.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The base name for the new Stem object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Stem object.</para>
</section>

<section id="mthNewString"><title>NewString</title>
<indexterm><primary>NewString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewString</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>NewString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewString</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxStringObject obj;
CSTRING str;
size_t len;

>>--obj = context->NewString(str, len);----------------------------------><

>>--obj = context->NewString(str);---------------------------------------><
]]>
</programlisting>
<para>There are two forms of this method. Both create a new String object from program data.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>For the first form, a pointer to a null-terminated ASCII-Z string.
    For the second form, a pointer to a data buffer containing the string data.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">len</emphasis></entry>
    <entry><para>Length of the <emphasis role="italic">str</emphasis> string.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new String object.</para>
</section>

<section id="mthNewSupplier"><title>NewSupplier</title>
<indexterm><primary>NewSupplier</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NewSupplier</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>NewSupplier</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NewSupplier</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NewSupplier</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxSupplierObject obj;
RexxArrayObject arr1, arr2;

>>--obj = context->NewSupplier(arr1, arr2);------------------------------><
]]>
</programlisting>
<para>This method returns a Supplier object based on the supplied argument Arrays.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">arr1</emphasis></entry>
    <entry><para>The Array of supplier items.</para></entry>
    </row>
    <row><entry><emphasis role="italic">arr2</emphasis></entry>
    <entry><para>The Array of supplier item indexes.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The new Supplier object.</para>
</section>

<section id="mthNil"><title>Nil</title>
<indexterm><primary>Nil</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Nil</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>Nil</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Nil</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Nil</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;

>>--obj = context->Nil();------------------------------------------------><
]]>
</programlisting>
<para>Returns the Rexx Nil object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Rexx Nil object.</para>
</section>

<section id="mthNullString"><title>NullString</title>
<indexterm><primary>NullString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>NullString</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>NullString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>NullString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>NullString</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxStringObject obj;

>>--obj = context->NullString();-----------------------------------------><
]]>
</programlisting>
<para>This method returns a string object of zero length.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A null String object.</para>
</section>

<section id="mthObjectToCSelf"><title>ObjectToCSelf</title>
<indexterm><primary>ObjectToCSelf</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToCSelf</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToCSelf</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ObjectToCSelf</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToCSelf</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
POINTER ptr;

>>--ptr = context->ObjectToCSelf(obj);--------------------------------><
]]>
</programlisting>
<para>Returns a pointer to the CSELF value for another object.
CSELF is a special argument type used for classes to store native pointers or structures inside an
object instance.  ObjectToCSelf() will search all of the object's variable
scopes searching for a variable named CSELF.  If a CSELF variable is located and the value is an instance
of either the Pointer or the Buffer class, the corresponding POINTER value will be returned as a void * value.
Objects that rely on CSELF values typically set the variable CSELF inside an INIT method for the class.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The CSELF value for the object.  Returns NULL if no CSELF value was found in the target object.</para>
</section>

<section id="mthObjectToDouble"><title>ObjectToDouble</title>
<indexterm><primary>ObjectToDouble</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToDouble</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ObjectToDouble</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToDouble</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToDouble</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
double n;
logical_t flag;

>>--flag = context->ObjectToDouble(obj, &n);-----------------------------><
]]>
</programlisting>
<para>Converts an Object to a C double value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object for the conversion.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>A pointer to the location that receives the converted double result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is stored in the
location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToInt32"><title>ObjectToInt32</title>
<indexterm><primary>ObjectToInt32</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToInt32</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ObjectToInt32</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToInt32</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToInt32</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
int32_t n;
logical_t flag;

>>--flag = context->ObjectToInt32(obj, &n);------------------------------><
]]>
</programlisting>
<para>Convert an Object into a 32-bit integer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>A pointer to the location used to return the conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is stored in the
location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToInt64"><title>ObjectToInt64</title>
<indexterm><primary>ObjectToInt64</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToInt64</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ObjectToInt64</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToInt64</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToInt64</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
int64_t n;
logical_t flag;

>>--flag = context->ObjectToInt64(obj, &n);------------------------------><
]]>
</programlisting>
<para>Convert an Object into a 64-bit integer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>A pointer to the location used to return the conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is stored in the
location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToIntptr"><title>ObjectToIntptr</title>
<indexterm><primary>ObjectToIntptr</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToIntptr</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ObjectToIntptr</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToIntptr</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToIntptr</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
intptr_t n;
logical_t flag;

>>--flag = context->ObjectToIntptr(obj, &n);-----------------------------><
]]>
</programlisting>
<para>Convert an Object to an intptr_t value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>A pointer to the location used to return the conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is stored in the
location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToLogical"><title>ObjectToLogical</title>
<indexterm><primary>ObjectToLogical</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToLogical</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ObjectToLogical</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToLogical</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToLogical</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag, n;

>>--flag = context->ObjectToLogical(obj, &n);----------------------------><
]]>
</programlisting>
<para>Converts an Object to a C logical value (0 or 1).
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>A pointer to the location used to return the conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is stored in the
location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToString"><title>ObjectToString</title>
<indexterm><primary>ObjectToString</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToString</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ObjectToString</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToString</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToString</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
RexxStringObject str;

>>--str = context->ObjectToString(obj);----------------------------------><
]]>
</programlisting>
<para>Convert an Object to a String object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object for the conversion.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The String object.</para>
</section>

<section id="mthObjectToStringSize"><title>ObjectToStringSize</title>
<indexterm><primary>ObjectToStringSize</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToStringSize</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ObjectToStringSize</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToStringSize</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToStringSize</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
size_t n;
logical_t flag;

>>--flag = context->ObjectToStringSize(obj, &n);-------------------------><
]]>
</programlisting>
<para>Convert an Object to a stringsize_t number value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>A pointer to the location used to return the conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is stored in the
location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToStringValue"><title>ObjectToStringValue</title>
<indexterm><primary>ObjectToStringValue</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToStringValue</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ObjectToStringValue</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToStringValue</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToStringValue</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
CSTRING str;

>>--str = context->ObjectToStringValue(obj);-----------------------------><
]]>
</programlisting>
<para>Convert an Object to a C ASCII-Z string.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object for the conversion.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The C ASCII-Z string representation of the object.</para>
</section>

<section id="mthObjectToUintptr"><title>ObjectToUintptr</title>
<indexterm><primary>ObjectToUintptr</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToUintptr</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ObjectToUintptr</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToUintptr</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToUintptr</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
uintptr_t n;
logical_t flag;

>>--flag = context->ObjectToUintptr(obj, &n);----------------------------><
]]>
</programlisting>
<para>Convert an Object to an uintptr_t value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>A pointer to the location used to return the conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is stored in the
location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToUnsignedInt32"><title>ObjectToUnsignedInt32</title>
<indexterm><primary>ObjectToUnsignedInt32</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToUnsignedInt32</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ObjectToUnsignedInt32</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToUnsignedInt32</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToUnsignedInt32</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
uint32_t n;
logical_t flag;

>>--flag = context->ObjectToUnsignedInt32(obj, &n);----------------------><
]]>
</programlisting>
<para>Convert an Object to an uint32_t value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>A pointer to the location used to return the conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is stored in the
location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToUnsignedInt64"><title>ObjectToUnsignedInt64</title>
<indexterm><primary>ObjectToUnsignedInt64</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToUnsignedInt64</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ObjectToUnsignedInt64</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToUnsignedInt64</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToUnsignedInt64</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
uint64_t n;
logical_t flag;

>>--flag = context->ObjectToUnsignedInt64(obj, &n);----------------------><
]]>
</programlisting>
<para>Convert an Object to an uint64_t value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>A pointer to the location used to return the conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is stored in the
location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthObjectToValue"><title>ObjectToValue</title>
<indexterm><primary>ObjectToValue</primary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ObjectToValue</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToValue</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToValue</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
ValueDescriptor desc;
logical_t flag;

>>--flag = context->ObjectToValue(obj, &desc);---------------------------><
]]>
</programlisting>
<para>Convert a Rexx object to another type.  The target type is identified
by the ValueDescriptor structure, and can by any of the types that may be
used as a method or routine return types.  For many conversions, it may be
more appropriate to use more targetted routines such as ObjectToWholeNumber().
ObjectToValue() is capable of conversions to types such as int8_t for which
there are no specific conversion APIs.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
    <row><entry><emphasis role="italic">desc</emphasis></entry>
    <entry><para>A C pointer to a ValueDescriptor struct that identifies
    the conversion type.  The converted value will be stored in the ValueDescriptor if successful.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  If successful,
<emphasis role="italic">desc</emphasis> is updated with the converted
value of the requested type.
</para>
</section>

<section id="mthObjectToWholeNumber"><title>ObjectToWholeNumber</title>
<indexterm><primary>ObjectToWholeNumber</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ObjectToWholeNumber</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ObjectToWholeNumber</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ObjectToWholeNumber</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ObjectToWholeNumber</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
wholenumber_t wn;
logical_t flag;

>>--flag = context->ObjectToWholeNumber(obj, &wn);-----------------------><
]]>
</programlisting>
<para>Convert an Object to a whole number value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to convert.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>A pointer to the location used to return the conversion result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = success, 0 = conversion error.  The converted value is stored in the
location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthPointerValue"><title>PointerValue</title>
<indexterm><primary>NPointerValue</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>PointerValue</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>PointerValue</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>PointerValue</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>PointerValue</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxPointerObject obj;
POINTER p;

>>--p = context->PointerValue(obj);--------------------------------------><
]]>
</programlisting>
<para>Return the wrappered C pointer value from a RexxPointerObject.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source RexxPointerObject.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The wrappered C pointer value.</para>
</section>

<section id="mthRaiseCondition"><title>RaiseCondition</title>
<indexterm><primary>RaiseCondition</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>RaiseCondition</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>RaiseCondition</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>RaiseCondition</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>RaiseCondition</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
CSTRING str;
RexxStringObject sobj;
RexxArrayObject arr;
RexxObjectPtr obj[

>>--context->RaiseCondition(str, sobj, arr, obj);-------------------------><
]]>
</programlisting>
<para>Raise a condition.  The raised condition is held in a pending
state until the method, routine, or exit returns to the Rexx runtime.
This is similar to using the RAISE instruction to raise a condition from
Rexx code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The condition name.</para></entry>
    </row>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The condition description as a String object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>A Array object containing additional information for the condition.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>an Object object that will be returned as a routine or
    method result if the raised condition is not trapped by the caller.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthRaiseException"><title>RaiseException</title>
<indexterm><primary>RaiseException</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>RaiseException</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>RaiseException</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>RaiseException</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>RaiseException</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
size_t n;
RexxObjectPtr obj;

>>--context->RaiseException(n, obj);-------------------------------------><
]]>
</programlisting>
<para>Raise a SYNTAX condition.  The raised condition is held in a pending
state until the method, routine, or exit returns to the Rexx runtime.
This is similar to using the RAISE instruction to raise a SYNTAX condition from
Rexx code.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The exception condition number.  There are #defines for the
    recognized condition errors in the oorexxerrors.h include file.
    </para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>An Array of substitution values for the condition error message.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthRaiseException0"><title>RaiseException0</title>
<indexterm><primary>RaiseException0</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>RaiseException0</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>RaiseException0</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>RaiseException0</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>RaiseException0</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
size_t n;

>>--context->RaiseException0(n);-----------------------------------------><
]]>
</programlisting>
<para>Raise an exception condition with no message substitution values.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The exception condition number.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthRaiseException1"><title>RaiseException1</title>
<indexterm><primary>RaiseException1</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>RaiseException1</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>RaiseException1</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>RaiseException1</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>RaiseException1</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
size_t n;
RexxObjectPtr obj;

>>--context->RaiseException1(n, obj);------------------------------------><
]]>
</programlisting>
<para>Raise an exception condition with a single message substitution value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The exception condition number.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>A substitution value for the condition error message.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthRaiseException2"><title>RaiseException2</title>
<indexterm><primary>RaiseException2</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>RaiseException2</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>RaiseException2</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>RaiseException2</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>RaiseException2</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
size_t n;
RexxObjectPtr obj1, obj2;

>>--context->RaiseException2(n, obj1, obj2);-----------------------------><
]]>
</programlisting>
<para>Raise an exception condition with two message substitution values.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The exception condition number.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj1</emphasis></entry>
    <entry><para>The first substitution value.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj2</emphasis></entry>
    <entry><para>The second substitution value.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthReleaseGlobalReference"><title>ReleaseGlobalReference</title>
<indexterm><primary>ReleaseGlobalReference</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ReleaseGlobalReference</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ReleaseGlobalReference</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ReleaseGlobalReference</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ReleaseGlobalReference</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr ref;

>>--context->ReleaseGlobalReference(ref);--------------------------------><
]]>
</programlisting>
<para>Release access to a global object reference.  This removes the global
garbage collection protection from the object reference.  Once released,
<emphasis role="italic">ref</emphasis> should no longer be used for object operations.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">ref</emphasis></entry>
    <entry><para>A global Rexx object reference.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthReleaseLocalReference"><title>ReleaseLocalReference</title>
<indexterm><primary>ReleaseLocalReference</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>ReleaseLocalReference</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ReleaseLocalReference</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ReleaseLocalReference</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ReleaseLocalReference</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr ref;

>>--context->ReleaseLocalReference(ref);---------------------------------><
]]>
</programlisting>
<para>Removes local context protection from an object reference.
Once released,
<emphasis role="italic">ref</emphasis> should no longer be used for object operations.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">ref</emphasis></entry>
    <entry><para>The local Rexx object reference.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthRequestGlobalReference"><title>RequestGlobalReference</title>
<indexterm><primary>RequestGlobalReference</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>RequestGlobalReference</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>RequestGlobalReference</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>RequestGlobalReference</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>RequestGlobalReference</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr ref, obj;

>>--ref = context->RequestGlobalReference(obj);--------------------------><
]]>
</programlisting>
<para>Requests global garbage collection protection for an object reference.
The returned value may be saved in native code and used as an object reference
in any API context.  The <emphasis role="italic">obj</emphasis> will be protected
from garbage collection until the global reference is released with
<link linkend="mthReleaseGlobalReference">ReleaseGlobalReference()</link>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The Rexx object to be protected.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A global reference to this object that can be saved and used in any
API context.</para>
</section>

<section id="mthResolveStemVariable"><title>ResolveStemVariable</title>
<indexterm><primary>ResolveStemVariable</primary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ResolveStemVariable</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
RexxStemObject stem;

>>--stem = context->ResolveStemVariable(obj);-------------------------><
]]>
</programlisting>
<para>Resolves a stem variable object using the same mechanism applied to
RexxStemObject arguments passed to routines.  If
<emphasis role="italic">obj</emphasis> is a Stem object, the same Stem
object will be returned.  If <emphasis role="italic">obj</emphasis>
is a String object, the string value is used to resolve a stem variable
from the caller's variable context.  The Stem object value of the referenced
stem variable is returned as a result.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object to be resolved to a Stem object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The resolved Stem object.</para>
</section>

<section id="mthSendMessage"><title>SendMessage</title>
<indexterm><primary>SendMessage</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SendMessage</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>SendMessage</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SendMessage</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SendMessage</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj, ret;
RexxArrayObject arr;

>>--ret = context->SendMessage(obj, meg, arr);---------------------------><
]]>
</programlisting>
<para>Send a message to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to receive the message.</para></entry>
    </row>
    <row><entry><emphasis role="italic">msg</emphasis></entry>
    <entry><para>An ASCII-Z string containing the message name. This argument will be converted to upper case automatically.</para></entry>
    </row>
    <row><entry><emphasis role="italic">arr</emphasis></entry>
    <entry><para>The Array of message arguments.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The returned object. If the method does not return an object
then NULLOBJECT is returned.
Any errors involved with invoking the method
will return a NULLOBJECT value.  The
<link linkend="mthCheckCondition">CheckCondition()</link>.
can be used to check in an error occurred during the call.
</para>
</section>

<section id="mthSendMessage0"><title>SendMessage0</title>
<indexterm><primary>SendMessage0</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SendMessage0</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>SendMessage0</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SendMessage0</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SendMessage0</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj, ret;

>>--ret = context->SendMessage0(obj, meg);-------------------------------><
]]>
</programlisting>
<para>Send a message to an Object.
This is a short cut method when no arguments are needed by the receiving object method.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to receive the message.</para></entry>
    </row>
    <row><entry><emphasis role="italic">msg</emphasis></entry>
    <entry><para>An ASCII-Z string containing the message name. This argument will be converted to upper case automatically.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The returned object. If the method does not return an object
then NULLOBJECT is returned.
Any errors involved with invoking the method
will return a NULLOBJECT value.  The
<link linkend="mthCheckCondition">CheckCondition()</link>.
can be used to check in an error occurred during the call.
</para>
</section>

<section id="mthSendMessage1"><title>SendMessage1</title>
<indexterm><primary>SendMessage1</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SendMessage1</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>SendMessage1</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SendMessage1</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SendMessage1</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj, ret, arg1;

>>--ret = context->SendMessage2(obj, meg, arg1);-------------------------><
]]>
</programlisting>
<para>Send a message to an Object.
This is a short cut method when only one argument is needed by the receiving object method.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to receive the message.</para></entry>
    </row>
    <row><entry><emphasis role="italic">msg</emphasis></entry>
    <entry><para>An ASCII-Z string containing the message name. This argument will be converted to upper case automatically.</para></entry>
    </row>
    <row><entry><emphasis role="italic">arg1</emphasis></entry>
    <entry><para>The first argument to the receiving method.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The returned object. If the method does not return an object
then NULLOBJECT is returned.
Any errors involved with invoking the method
will return a NULLOBJECT value.  The
<link linkend="mthCheckCondition">CheckCondition()</link>.
can be used to check in an error occurred during the call.
</para>
</section>

<section id="mthSendMessage2"><title>SendMessage2</title>
<indexterm><primary>SendMessage2</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SendMessage2</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>SendMessage2</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SendMessage2</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SendMessage2</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj, ret, arg1, arg2;

>>--ret = context->SendMessage2(obj, meg, arg1, arg2);-------------------><
]]>
</programlisting>
<para>Send a message to an Object.
This is a short cut method when only two arguments are needed by the receiving object method.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to receive the message.</para></entry>
    </row>
    <row><entry><emphasis role="italic">msg</emphasis></entry>
    <entry><para>An ASCII-Z string containing the message name. This argument will be converted to upper case automatically.</para></entry>
    </row>
    <row><entry><emphasis role="italic">arg1</emphasis></entry>
    <entry><para>The first argument to the receiving method.</para></entry>
    </row>
    <row><entry><emphasis role="italic">arg2</emphasis></entry>
    <entry><para>The second argument to the receiving method.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The returned object. If the method does not return an object
then NULLOBJECT is returned.
Any errors involved with invoking the method
will return a NULLOBJECT value.  The
<link linkend="mthCheckCondition">CheckCondition()</link>.
can be used to check in an error occurred during the call.
</para>
</section>

<section id="mthSetContextVariable"><title>SetContextVariable</title>
<indexterm><primary>SetContextVariable</primary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>SetContextVariable</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SetContextVariable</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
CSTRING name;

>>--context->SetContextVariable(name, obj);---------------------------><
]]>
</programlisting>
<para>Sets the value of a Rexx variable in the current function context.
Only simple and stem variables may be set using SetContextVariable().
Compoune variable values may be set by retrieving the Stem object associated
with a stem variable and using <link linkend="mthSetStemElement">SetStemElement()</link>
to set the associated compound variable.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The name of the Rexx variable.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to assign to the variable.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthSetGuardOff"><title>SetGuardOff</title>
<indexterm><primary>SetGuardOff</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SetGuardOff</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
>>--context->SetGuardOff();----------------------------------------------><
]]>
</programlisting>
<para>Release the guard lock for this method scope.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthSetGuardOn"><title>SetGuardOn</title>
<indexterm><primary>SetGuardOnn</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SetGuardOn</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
>>--context->SetGuardOn();-----------------------------------------------><
]]>
</programlisting>
<para>Obtain the guard lock for this object scope.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthSetObjectVariable"><title>SetObjectVariable</title>
<indexterm><primary>SetObjectVariable</primary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SetObjectVariable</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
CSTRING str;
RexxObjectPtr obj;

>>--context->SetObjectVariable(str, obj);--------------------------------><
]]>
</programlisting>
<para>Sets an instance variable in the current method's variable scope to a new value.
Only simple and stem variables may be set using this API.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The name of the object variable.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to assign to the object variable.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthSetStemArrayElement"><title>SetStemArrayElement</title>
<indexterm><primary>SetStemArrayElement</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SetStemArrayElement</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>SetStemArrayElement</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SetStemArrayElement</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SetStemArrayElement</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxStemObject sobj;
RexxObjectPtr obj;
size_t n;

>>--context->SetStemArrayElement(sobj, n, obj);--------------------------><
]]>
</programlisting>
<para>Sets an element of the Stem object. If the element exists it is replaced.
This method strictly uses numerics as the element name.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The target Stem object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The Stem object element number.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object value assigned to the Stem object element.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthSetStemElement"><title>SetStemElement</title>
<indexterm><primary>SetStemElement</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SetStemElement</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>SetStemElement</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SetStemElement</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SetStemElement</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxStemObject sobj;
RexxObjectPtr obj;
CSTRING name;

>>--context->SetStemElement(sobj, name, obj);----------------------------><
]]>
</programlisting>
<para>Sets an element of the Stem object. If the element exists it is replaced.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The target Stem object.</para></entry>
    </row>
    <row><entry><emphasis role="italic">name</emphasis></entry>
    <entry><para>The Stem object element name.  This is a fully resolve Stem tail element.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object value assigned to the Stem object element.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthSetThreadTrace"><title>SetThreadTrace</title>
<indexterm><primary>SetThreadTrace</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SetThreadTrace</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
logical_t flag;

>>--context->SetThreadTrace(flag);---------------------------------------><
]]>
</programlisting>
<para>Sets the interactive trace state for the current thread.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">flag</emphasis></entry>
    <entry><para>New state for interactive trace.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthSetTrace"><title>SetTrace</title>
<indexterm><primary>SetTrace</primary></indexterm>
<indexterm><primary>Rexx instance context methods</primary>
<secondary>SetTrace</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>Yes</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
logical_t flag;

>>--context->SetTrace(flag);---------------------------------------------><
]]>
</programlisting>
<para>Sets the interactvive trace state for the interpreter instance.  This will enable tracing in
all active threads for the interpreter instance.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">flag</emphasis></entry>
    <entry><para>The new trace state.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthString"><title>String</title>
<indexterm><primary>String</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>String</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>String</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>String</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>String</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxRoutineObject obj;
CSTRING str;
size_t len;

>>--obj = context->String(str, len);-------------------------------------><

>>--obj = context->String(str);------------------------------------------><
]]>
</programlisting>
<para>There are two forms of this method. Both create a new object from a C string.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>The ASCII-Z string to be converted.</para></entry>
    </row>
    <row><entry><emphasis role="italic">len</emphasis></entry>
    <entry><para>Length of the <emphasis role="italic">str</emphasis> string.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A new String object.</para>
</section>

<section id="mthStringData"><title>StringData</title>
<indexterm><primary>StringData</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringData</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>StringData</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringData</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringData</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
CSTRING str;

>>--str = context->StringData(obj);--------------------------------------><
]]>
</programlisting>
<para>Returns a read-only pointer to the string data of a String object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source String object for the data.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A pointer to the String object's string data.</para>
</section>

<section id="mthStringGet"><title>StringGet</title>
<indexterm><primary>StringGet</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringGet</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>StringGet</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringGet</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringGet</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
POINTER str;
size_t c, len1, len2;

>>--c = context->StringGet(obj, len1, str, len2);------------------------><
]]>
</programlisting>
<para>Copies all or part of the object string value to the C string buffer.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source String object for the copy.</para></entry>
    </row>
    <row><entry><emphasis role="italic">len1</emphasis></entry>
    <entry><para>The starting position within the String for the copy.
       This argument is 1-based</para></entry>
    </row>
    <row><entry><emphasis role="italic">str</emphasis></entry>
    <entry><para>A pointer to the target buffer for the copy. Note that the buffer is
       NOT zero-terminated.</para></entry>
    </row>
    <row><entry><emphasis role="italic">len2</emphasis></entry>
    <entry><para>The number of characters to copy. This argument should be less than or equal the
       size of the <emphasis role="italic">str</emphasis> buffer or a buffer overrun will result.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The number of characters actually copied.</para>
</section>

<section id="mthStringLength"><title>StringLength</title>
<indexterm><primary>StringLength</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringLength</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>StringLength</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringLength</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringLength</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
size_t sz;

>>--sz = context->StringLength(obj);-------------------------------------><
]]>
</programlisting>
<para>Return the length a String object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source String object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The string length of the String object.</para>
</section>

<section id="mthStringLower"><title>StringLower</title>
<indexterm><primary>StringLower</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringLower</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>StringLower</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringLower</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringLower</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr srcobj, newobj;

>>--newobj = context->StringLower(srcobj);-------------------------------><
]]>
</programlisting>
<para>Convert a String object to lower case, returning a new String object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">srcobj</emphasis></entry>
    <entry><para>The source String object to be converted to lower case.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A new String object with the string value lower cased.</para>
</section>

<section id="mthStringSize"><title>StringSize</title>
<indexterm><primary>StringSize</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringSize</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>StringSize</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringSize</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringSize</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag;
stringsize_t n;

>>--obj = context->StringSize(&n);-------------------------------------------><

>>--flag = context->StringSize(obj, &n);-------------------------------------><
]]>
</programlisting>
<para>There are two forms of this method.
The first converts the stringsize_t value <emphasis role="italic">n</emphasis> to an Object.
The second converts an Object to a stringsize_t value and returns it in the location
pointed to by <emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The stringsize_t value to be converted in the first form.
       The target of the conversion in the second form.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object version of the integer value in the first form.
The second form returns 1 = success, 0 = failure.  If successful, the converted value is
stored at the location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthStringSizeToObject"><title>StringSizeToObject</title>
<indexterm><primary>StringSizeToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringSizeToObject</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>StringSizeToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringSizeToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringSizeToObject</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
size_t sz;

>>--obj = context->StringSizeToObject(sz);-------------------------------><
]]>
</programlisting>
<para>Convert a stringsize_t value to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">sz</emphasis></entry>
    <entry><para>The stringsize_t value to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object that represents the C stringsize_t value.</para>
</section>

<section id="mthStringUpper"><title>StringUpper</title>
<indexterm><primary>StringUpper</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>StringUpper</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>StringUpper</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>StringUpper</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>StringUpper</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr srcobj, newobj;

>>--newobj = context->StringUpper(srcobj);-------------------------------><
]]>
</programlisting>
<para>Convert a String object upper case, returning a new String object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">srcobj</emphasis></entry>
    <entry><para>The source String object to be converted to upper case.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A new String object with the string value upper cased.</para>
</section>

<section id="mthSupplierAvailable"><title>SupplierAvailable</title>
<indexterm><primary>SupplierAvailable</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SupplierAvailable</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>SupplierAvailable</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SupplierAvailable</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SupplierAvailable</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxSupplierObjectPtr sobj;
logical_t flag;

>>--flag = context->SupplierAvailable(sobj);-----------------------------><
]]>
</programlisting>
<para>Returns 1 if there is another supplier item available.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source supplier object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>1 = another item available, 0 = no item available.</para>
</section>

<section id="mthSupplierIndex"><title>SupplierIndex</title>
<indexterm><primary>SupplierIndex</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SupplierIndex</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>SupplierIndex</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SupplierIndex</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SupplierIndex</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxSupplierObjectPtr sobj;
RexxObjectPtr obj;

>>--obj = context->SupplierIndex(sobj);----------------------------------><
]]>
</programlisting>
<para>Return the current supplier object index value.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source supplier object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The index object at the current supplier position.</para>
</section>

<section id="mthSupplierItem"><title>SupplierItem</title>
<indexterm><primary>SupplierItem</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SupplierItem</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>SupplierItem</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SupplierItem</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SupplierItem</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxSupplierObjectPtr sobj;
RexxObjectPtr obj;

>>--obj = context->SupplierItem(sobj);-----------------------------------><
]]>
</programlisting>
<para>Return the current supplier item object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source supplier object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object item at the current supplier position.</para>
</section>

<section id="mthSupplierNext"><title>SupplierNext</title>
<indexterm><primary>SupplierNext</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>SupplierNext</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>SupplierNext</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>SupplierNext</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>SupplierNext</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxSupplierObjectPtr sobj;

>>--context->SupplierNext(sobj);-----------------------------------------><
]]>
</programlisting>
<para>Advance a Supplier object to the next enumeration position.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">sobj</emphasis></entry>
    <entry><para>The source supplier object.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthTerminate"><title>Terminate</title>
<indexterm><primary>Terminate</primary></indexterm>
<indexterm><primary>Rexx instance context methods</primary>
<secondary>Terminate</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>No</entry></row>
<row><entry>Method</entry><entry>No</entry></row>
<row><entry>Function</entry><entry>No</entry></row>
<row><entry>Exit</entry><entry>No</entry></row>
<row><entry>Interpreter</entry><entry>Yes</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
>>--context->Terminate();----------------------------------------------><
]]>
</programlisting>
<para>Terminates the current Rexx interpreter instance.  Terminate() may
only be called from the thread context that originally created the interpreter
instance.  This call will wait for all threads to complete processing before
returning.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>Void.</para>
</section>

<section id="mthTrue"><title>True</title>
<indexterm><primary>True</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>True</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>True</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>True</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>True</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;

>>--obj = context->True();-----------------------------------------------><
]]>
</programlisting>
<para>This method returns the Rexx .true object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<para>None.</para>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The Rexx .true object.</para>
</section>

<section id="mthUintptr"><title>Uintptr</title>
<indexterm><primary>Uintptr</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>Uintptr</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>Uintptr</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>Uintptr</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>Uintptr</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag;
uintptr_t n;

>>--obj = context->Uintptr(&n);------------------------------------------><

>>--flag = context->Uintptr(obj, &n);------------------------------------><
]]>
</programlisting>
<para>There are two forms of this method.
The first converts the uintptr_t value <emphasis role="italic">n</emphasis> to an Object.
The second converts an Object to a uintptr_t value and returns it in the location
pointed to by <emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The uintptr_t value to be converted in the first form or
    the target of the conversion in the second form of the method.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object version of the integer value in the first form.
The second form returns 1 = success, 0 = failure.  If successful, the converted value is
stored at the location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthUintptrToObject"><title>UintptrToObject</title>
<indexterm><primary>UintptrToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>UintptrToObject</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>UintptrToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>UintptrToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>UintptrToObject</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
uintptr_t n;

>>--obj = context->UintptrToObject(&n);----------------------------------><
]]>
</programlisting>
<para>Convert a uintptr_t value <emphasis role="italic">n</emphasis> to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The uintptr_t value to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object that represents the uintptr_t value.</para>
</section>

<section id="mthUnsignedInt32"><title>UnsignedInt32</title>
<indexterm><primary>UnsignedInt32</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>UnsignedInt32</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>UnsignedInt32</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>UnsignedInt32</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>UnsignedInt32</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag;
uint32_t n;

>>--obj = context->UnsignedInt32(n);-------------------------------------><

>>--flag = context->UnsignedInt32(obj, &n);------------------------------><
]]>
</programlisting>
<para>There are two forms of this method.
The first convert a C 32-bit unsigned integer <emphasis role="italic">n</emphasis> to an Object.
The second converts an Object to a uint32_t value and returns it in the location
pointed to by <emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The uint32_t value to be converted.for the first form of the method.
       For the second form this is the target of the conversion.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The object to be converted to a uint32_t value.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object version of the integer value in the first form.
The second form returns 1 = success, 0 = failure.  If successful, the converted value is
stored at the location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthUnsignedInt32ToObject"><title>UnsignedInt32ToObject</title>
<indexterm><primary>UnsignedInt32ToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>UnsignedInt32ToObject</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>UnsignedInt32ToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>UnsignedInt32ToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>UnsignedInt32ToObject</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
uint32_t n;

>>--obj = context->UnsignedInt32ToObject(n);-----------------------------><
]]>
</programlisting>
<para>Convert a C 32-bit unsigned integer <emphasis role="italic">n</emphasis> to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The uint32_t value to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object that represents the C unsigned integer.</para>
</section>

<section id="mthUnsignedInt64"><title>UnsignedInt64</title>
<indexterm><primary>UnsignedInt64</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>UnsignedInt64</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>UnsignedInt64</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>UnsignedInt64</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>UnsignedInt64</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
logical_t flag;
uint64_t n;

>>--obj = context->UnsignedInt64(n);-------------------------------------><

>>--flag = context->UnsignedInt64(obj, &n);------------------------------><
]]>
</programlisting>
<para>There are two forms of this method.
The first converts a C 64-bit unsigned integer <emphasis role="italic">n</emphasis> to an Object.
The second converts an Object to a uint64_t value and returns it in the location
pointed to by <emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The uint64_t value to be converted.for the first form of the method.
       For the second form this is the target of the conversion.</para></entry>
    </row>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The object to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object version of the integer value in the first form.
The second form returns 1 = success, 0 = failure.  If successful, the converted value is
stored at the location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthUnsignedInt64ToObject"><title>UnsignedInt64ToObject</title>
<indexterm><primary>UnsignedInt64ToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>UnsignedInt64ToObject</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>UnsignedInt64ToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>UnsignedInt64ToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>UnsignedInt64ToObject</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
uint64_t n;

>>--obj = context->UnsignedInt64ToObject(n);-----------------------------><
]]>
</programlisting>
<para>Convert a C 64-bit unsigned integer <emphasis role="italic">n</emphasis> to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The uint64_t value to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object that represents the C unsigned integer.</para>
</section>

<section id="mthValuesToObject"><title>ValuesToObject</title>
<indexterm><primary>ValuesToObject</primary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ValuesToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ValuesToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ValuesToObject</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxArrayObj obj;
ValueDescriptor desc[3];

>>--obj = context->ValuesToObject(desc);---------------------------------><
]]>
</programlisting>
<para>Converts an array of ValueDescriptor structs to an Array of objects.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">desc</emphasis></entry>
    <entry><para>A C pointer to the ValueDescriptor struct array to be converted.  The end of the
    array is marked by a ValueDescriptor struct with all fields set to zero.
    </para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>A Array object containing the converted objects.</para>
</section>

<section id="mthValueToObject"><title>ValueToObject</title>
<indexterm><primary>ValueToObject</primary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>ValueToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>ValueToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>ValueToObject</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
ValueDescriptor desc;;

>>--obj = context->ValueToObject(&desc);---------------------------------><
]]>
</programlisting>
<para>Convert a type to an Object representation.  The source type is identified
by the ValueDescriptor structure, and can by any of the types that may be
used as a method or routine return types.  For many conversions, it may be
more appropriate to use more targetted routines such as WholeNumberToObject().
ValueToObject() is capable of converting to types such as int8_t for which
there are no specific conversion APIs.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">desc</emphasis></entry>
    <entry><para>A C pointer to the ValueDescriptor struct describing the value to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>The object representing the converted value.</para>
</section>

<section id="mthWholeNumber"><title>WholeNumber</title>
<indexterm><primary>WholeNumber</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>WholeNumber</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>WholeNumber</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>WholeNumber</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>WholeNumber</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
wholenumber_t n;
logical_t flag;

>>--obj = context->WholeNumber(n);---------------------------------------><

>>--flag = context->WholeNumber(obj, &n);--------------------------------><
]]>
</programlisting>
<para>There are two forms of this method.
The second converts an Object to a wholenumber_t value and returns it in the location
pointed to by <emphasis role="italic">n</emphasis>.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The wholenumber_t value to be converted.for the first form of the method.
       For the second form this is the target of the conversion.</para></entry>
    </row>
    <row><entry><emphasis role="italic">obj</emphasis></entry>
    <entry><para>The source object for the conversion.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object version of the integer value in the first form.
The second form returns 1 = success, 0 = failure.  If successful, the converted value is
stored at the location pointed to by <emphasis role="italic">n</emphasis>.
</para>
</section>

<section id="mthWholeNumberToObject"><title>WholeNumberToObject</title>
<indexterm><primary>WholeNumberToObject</primary></indexterm>
<indexterm><primary>Thread context methods</primary>
<secondary>WholeNumberToObject</secondary></indexterm>
<indexterm><primary>Function context methods</primary>
<secondary>WholeNumberToObject</secondary></indexterm>
<indexterm><primary>Method context methods</primary>
<secondary>WholeNumberToObject</secondary></indexterm>
<indexterm><primary>Exit context methods</primary>
<secondary>WholeNumberToObject</secondary></indexterm>
<informaltable frame="all">
<tgroup cols="2">
<colspec colnum="1" colwidth="72pc">
<colspec colnum="2" colwidth="45pc">
<tbody>
<row>
<entry><emphasis role="bold">Context</emphasis></entry>
<entry><emphasis role="bold">Available</emphasis></entry>
</row>
<row><entry>Thread</entry><entry>Yes</entry></row>
<row><entry>Method</entry><entry>Yes</entry></row>
<row><entry>Function</entry><entry>Yes</entry></row>
<row><entry>Exit</entry><entry>Yes</entry></row>
<row><entry>Interpreter</entry><entry>No</entry></row>
</tbody>
</tgroup>
</informaltable>
<programlisting>
<![CDATA[
RexxObjectPtr obj;
wholenumber_t n;

>>--obj = context->WholeNumberToObject(n);-------------------------------><
]]>
</programlisting>
<para>Convert a C wholenumber_t value to an Object.
</para>
<para><emphasis role="bold">Arguments</emphasis></para>
<informaltable frame="none" colsep="0" rowsep="0"><tgroup cols="2"><colspec colnum="1" colwidth="1*"><colspec colnum="2" colwidth="5*"><tbody>
    <row><entry><emphasis role="italic">n</emphasis></entry>
    <entry><para>The C whole number to be converted.</para></entry>
    </row>
</tbody></tgroup></informaltable>
<para><emphasis role="bold">Returns</emphasis></para>
<para>an Object that represents the C whole number.</para>
</section>

</section>
</chapter>
