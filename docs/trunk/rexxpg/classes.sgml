<!--#########################################################################
    #
    # Description: Open Object Rexx: Programming Guide SGML file.
    #
    # Copyright (c) 2005-2006, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<chapter id="classes"><title>A Closer Look at Objects</title>
<indexterm><primary>variables</primary>
<secondary>in objects</secondary></indexterm>
<para>This chapter covers the mechanics of using objects and methods in more
detail. First, a quick refresher.</para>
<para>A Rexx object consists
of:</para>
<itemizedlist>
<listitem><para>Actions coded as methods</para></listitem>
<listitem><para>Characteristics, coded as variables, and their
values, sometimes referred to as &quot;state data&quot;</para></listitem>
</itemizedlist>
<para>Sending a message to an object causes it to perform a related action. The
method whose name matches the message performs the action. The message is
the interface to the object, and with information hiding, only methods
that belong to an object can access its variables.</para>
<para>Objects are grouped hierarchically into classes. The
class at the top of the hierarchy is the Object class. Everything below it
in the hierarchy belongs to the Object class and is therefore an object. As
a result, all classes are objects.</para>
<para>In a class hierarchy, classes, superclasses, and subclasses are relative
to one another. Unless designated otherwise, any class directly above a class
in the hierarchy is a superclass. And any class below is a subclass.</para>
<para>From a class you can create instances of the class. Instances
are merely similar objects that fit the template
of the class; they belong to the class, but are not classes themselves. Instances
are the most basic, most elemental of objects.</para>
<para>Both the classes
and their instances contain variables and methods. The methods a class provides
for use by its various instances are called instance methods. In effect,
these define which messages an instance can respond to. Instance
methods are the most common methods in Rexx, and are therefore called methods.</para>
<para>The methods available
to the class itself are called class methods. (They
are actually the instance methods of the Class class.) They define messages
that only the class--and not its instances--can respond to. Class
methods generally exist to create instances and are
much less common.</para>

<figure><title>Instance Methods and Class Methods</title>
<indexterm><primary>class methods</primary></indexterm>
<indexterm><primary>instance methods</primary></indexterm>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxoq0s03.jpg" scale="70">
</imageobject>
</mediaobject>
</figure>

<section id="xclauses"><title>Using Objects in Rexx Clauses</title>
<indexterm><primary>clauses</primary>
<secondary>using object in</secondary></indexterm>
<para>The following
examples with Myarray illustrate how to use new objects in Rexx clauses.</para>
<para></para>
<programlisting>
<![CDATA[
myarray=.array~new(5)
]]>
</programlisting>
<para>creates a new instance of the Array
class, Myarray. The period precedes a class name in an expression, to distinguish
the class from other variables. The Myarray array object has five elements.</para>
<para>After Myarray is created, you can assign values to it. One way is with
the PUT method. PUT has two arguments, which must be enclosed in parentheses.
The first argument is the string to be placed in the element. The second is
the number of the element in which to place the string. Here, the string
object <computeroutput>Hello</computeroutput> is associated with the third
element of Myarray: </para>
<programlisting>
<![CDATA[
myarray~put("Hello",3)
]]>
</programlisting>
<para>Rexx dynamically adjusts the size of the array to accommodate the new element.</para>
<para>One way to retrieve values from an array object is by sending it an AT message.
In the next example, the SAY instruction displays the third element of Myarray: </para>
<programlisting>
<![CDATA[
say myarray~at(3)

Results:

Hello
]]>
</programlisting>
<para>The SAY
<indexterm><primary>SAY instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>SAY instruction</secondary></indexterm>
instruction expects the string object as input, which is what AT returns. If you
put a nonstring object in the SAY instruction, SAY sends a STRING message
to the object.  The STRING method for Rexx's built-in objects returns
a human-readable string representation for the object. In this example, the
<indexterm><primary>STRING method</primary></indexterm>
STRING method for Myarray returns the string
<computeroutput>an array</computeroutput>: </para>
<programlisting>
<![CDATA[
say myarray  /* SAY sends STRING message to Myarray */

Results:

an array
]]>
</programlisting>
<para>Whenever a method returns a string, you can use it within expressions that
require a string. Here, the element of the array that AT returns is a string, so you can put an
expression containing the AT method inside a string function like COPIES():</para>
<programlisting>
<![CDATA[
say copies(myarray~at(3),4)

Results:
HelloHelloHelloHello
]]>
</programlisting>
<para>This example gets the same result using only methods: </para>
<programlisting>
<![CDATA[
say myarray~at(3)~copies(4)
]]>
</programlisting>
<para>Notice that the expression is evaluated from left to right. You can also
use parentheses to enforce an order of evaluation.</para>
<para>Almost all messages are sent using the twiddle, but there are exceptions.
The exceptions are to improve the reliability of the language. The following
example uses the []= (left-bracket right-bracket equal-sign) and []
methods to set and retrieve array elements: </para>
<programlisting>
<![CDATA[
myarray[4]="the fourth element"
say myarray[4]
]]>
</programlisting>
<para>Although the previous instructions look like an ordinary array assignment
and array reference, they are actually messages to the Myarray object. You
can prove this by executing these equivalent instructions, which use the twiddle
to send the messages: </para>
<programlisting>
<![CDATA[
myarray~"[]="("a new test",4)
say myarray~"[]"(4)
]]>
</programlisting>
<para>Similarly, expression operators (such as +, -, /, and *) are actually methods,
but you do not have to use the twiddle to send them: </para>
<programlisting>
<![CDATA[
say 2+3      /* Displays 5 */
say 2~"+"(3) /* Displays 5 */
]]>
</programlisting>
<para>In the second SAY instruction, quotes are needed around the + message because
it is a character not allowed in a Rexx symbol.</para>
</section>

<section id="creo"><title>Common Methods</title>
<para>When running your program, three methods that Rexx looks for, and runs
automatically when appropriate, are INIT, UNINIT, and STRING.</para>

<section id="init"><title>Initializing Instances Using INIT</title>
<para>Object classes can create instances.
When these instances require initialization, you'll want to define an
INIT method to set a particular starting value or initiate some startup processing.
Rexx looks for an INIT method whenever a new object is created and runs it.</para>
<para>The purpose of initialization is to ensure that the variable is set correctly
before using it in an operation. If an INIT method is defined, Rexx runs it
after creating the instance. Any initialization arguments specified in the
NEW or ENHANCED message are passed to the
<indexterm><primary>INIT instruction</primary></indexterm>
INIT method, which can use them
to set the initial state of object variables.</para>
<para>If an instance has more than one INIT method (for example, INIT is defined
in several classes), each INIT method must forward the INIT message up the
hierarchy and run the topmost version of INIT, to properly initialize the
instance. An example in the next section demonstrates the use of INIT.</para>
</section>

<section id="retstr"><title>Returning String Data Using STRING</title>
<para>The STRING method
<indexterm><primary>STRING method</primary></indexterm>
is a useful way to access object data and return it in string form for use
by your program. When a
<indexterm><primary>SAY instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>SAY instruction</secondary></indexterm>
SAY instruction is processed in Rexx, Rexx automatically
sends a STRING message to the object specified in the expression. Rexx uses
the STRING method of the Object class and returns a human-readable string
representation for the object. For example, if you instruct Rexx
to <computeroutput>say a,</computeroutput> and
<computeroutput>a</computeroutput> is an array object, Rexx returns an array.
You can take advantage of this automatic use of STRING by overriding Rexx's
STRING method with your own, and extract the object data itself--in this
case, the actual array data.</para>
<para>The following programs
demonstrate STRING and INIT. In the first program, the Part class is created,
and along with it, the two methods under discussion, STRING and INIT: </para>
<indexterm><primary>directives</primary>
<secondary>sample program</secondary></indexterm>
<programlisting>
<![CDATA[
/* PARTDEF.CMD - Class and method definition file */

/* Define the Part class as a public class */
::class part public

/* Define the INIT method to initialize object variables */
::method init
expose name description number
use arg name, description, number

/* Define the STRING method to return a string with the part name */
::method string
expose name
return "Part name:" name
]]>
</programlisting>
<para>In the ::CLASS directive, the
keyword PUBLIC indicates that the class can be shared with other programs.
The two ::METHOD directives define
<indexterm><primary>INIT instruction</primary></indexterm>
INIT and STRING. Whenever Rexx creates
a new instance of a class, it calls the INIT method for the class. The sample
INIT method uses an EXPOSE instruction to make the name, description, and
number variables available to other methods. These exposed variables are object
variables, and are associated with a particular instance of a class:</para>

<figure><title>Instances in the Part Class</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxoq0s04.jpg" scale="75">
</imageobject>
</mediaobject>
</figure>

<para>INIT expects to be passed three arguments.
<indexterm><primary>Rexx</primary>
<secondary>USE ARG instruction</secondary></indexterm>
<indexterm><primary>USE ARG instruction</primary></indexterm>
The USE ARG instruction assigns these three arguments to the name, description,
and number variables, respectively. Because those variables are exposed, the
values are available to other methods.</para>
<para>The STRING method returns the string
<computeroutput>Part name:</computeroutput>, followed
by the name of a part. The STRING method does not expect any arguments. It uses
<indexterm><primary>EXPOSE instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>EXPOSE instruction</secondary></indexterm>
<indexterm><primary>variables</primary>
<secondary>exposing</secondary></indexterm>
the EXPOSE instruction to tap the object variables.  The RETURN instruction
returns the result string.</para>
<para>The following
example shows how to use the Part class: </para>
<programlisting>
<![CDATA[
/* USEPART.CMD  - use the Part class */
myparta=.part~new("Widget","A small widge",12345)
mypartb=.part~new("Framistat","Device to control frams",899)
say myparta
say mypartb
exit
::requires partdef
]]>
</programlisting>
<para>The USEPART program creates two parts, which are instances of the Part
class. It then displays the names of the two parts.</para>
<para>Rexx processes all directives before running your program. The
<indexterm><primary>directives</primary>
<secondary>::REQUIRES</secondary></indexterm>
::REQUIRES directive indicates
that the program needs access to public class definitions that are in another
program. In this case, the ::REQUIRES directive refers to the PARTDEF program,
which contains the Part definition.</para>
<para>The assignment instructions for
Mypart A and Mypart B create two objects that are instances of the Part class.
The objects are created by sending a NEW message to the Part class. The NEW
message causes the INIT method to be invoked as part of object creation. The
INIT method takes the three arguments you provide and makes them part of the
object's own exclusive set of variables, called a variable pool. Each object
has its own variable pool (name, description, and number).</para>
<para>The SAY
<indexterm><primary>SAY instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>SAY instruction</secondary></indexterm>
<indexterm><primary>STRING method</primary></indexterm>
instruction sends a STRING message to the object. In the first SAY instruction,
the STRING message is sent to MypartA. The STRING method accesses the Name
object variable for MypartA and returns it as part of a string. In the second
SAY instruction, the STRING message is sent again, but to a different object:
MypartB. Because the STRING method is invoked for MypartB, it automatically
accesses the variables for MypartB. You do not need to pass the name of the
object to the method in order to distinguish different sets of object variables;
Rexx keeps track of them for you.</para>
<para>Another way to define classes
<indexterm><primary>SUBCLASS method</primary></indexterm>
is by using the SUBCLASS method. You can send a SUBCLASS method to any desired
superclass to create a class.</para>
</section>

<section id="destroy"><title>Uninitializing and Deleting Instances Using UNINIT</title>
<indexterm><primary>UNINIT method</primary></indexterm>
<indexterm><primary>instances</primary>
<secondary>uninitializing and deleting</secondary></indexterm>
<para> Object
classes can create instances but have no direct control over their deletion.
If you assign a new value to a variable, Rexx automatically reclaims the storage
for the old value in a process called garbage collection.</para>
<para>If variables of other objects
no longer reference an instance, Rexx automatically reclaims that instance.
If the instance has allocated other system resources, you must release them
at this time using an UNINIT method. Rexx cannot automatically release these
resources because it is unaware that the instance has allocated them.</para>
<para>In the following example, the value passed to
<emphasis role="italic">text</emphasis> is initialized
by Rexx using INIT and deleted by Rexx using UNINIT. This program makes visible
Rexx's automatic invocation of INIT and UNINIT by revealing its processing
on the screen using the SAY instruction: </para>
<programlisting>
/* UNINIT.CMD - example of UNINIT processing */

a=.scratchpad~new("Of all the things I&apos;ve lost")
a=.scratchpad~new("I miss my mind the most")
say "Exiting program."
exit

::class scratchpad

  ::method init
    expose text
    use arg text
    say "Remembering" text

  ::method uninit
    expose text
    say "Forgetting" text
    return
</programlisting>
<para>Whether uninitialization processing is needed depends on the circumstances,
for example when a message object holds an unreported error that should be
reported and cleared. If an object requires uninitialization, define an UNINIT
method to specify the processing you want.</para>
<para>If UNINIT is defined, Rexx runs it before reclaiming the object's storage.
If an instance has more than one UNINIT method (for example, UNINIT is defined
in several classes), each UNINIT method is responsible for sending the UNINIT
message up the hierarchy, using the SUPERCLASS overrides, to run the topmost
version of UNINIT.</para>
</section>
</section>

<section id="spvar"><title>Special Variables</title>
<indexterm><primary>special variable</primary></indexterm>
<indexterm><primary>variables</primary>
<secondary>special</secondary></indexterm>
<para>When writing methods, you
can use special variables available in Rexx. A special variable can be set
automatically during the processing of a Rexx program. Rexx supports the following
variables: </para>
<variablelist>
<varlistentry><term>RC
<indexterm><primary>RC special variable</primary></indexterm>
</term>
<listitem><para>is set to the return code from any executed command,
including those submitted with the ADDRESS instruction. After the trapping
of ERROR or FAILURE conditions, it is also set to the command return code.
When the SYNTAX condition is trapped, RC is set to the syntax error number
(1-99). RC is unchanged when any other condition is trapped.

<note>
<para>Tracing interactively does not change the value of RC.</para></note>
</para></listitem></varlistentry>
<varlistentry><term>RESULT
<indexterm><primary>RESULT special variable</primary></indexterm>
</term>
<listitem><para>is set by a RETURN
instruction in a subroutine that has been called, or a method that was activated
by a message instruction, if the RETURN instruction specifies an expression.
If the RETURN instruction has no expression on it, RESULT is dropped (becomes
uninitialized). RESULT is also set by an EXIT or REPLY instruction.
</para></listitem></varlistentry>
<varlistentry><term>SELF
<indexterm><primary>SELF special variable</primary></indexterm>
</term>
<listitem><para>is set when a method
is activated. Its value is the object that forms the execution context for
the method (that is, the receiver object of the activating message). </para>
<para>You
can use SELF to:</para>
<itemizedlist>
<listitem><para>Run a method in an object in which a method is already running.
For example, a FIND_CLUES method is running in an object called Mystery_Novel.
When FIND_CLUES finds a clue, it sends a READ_LAST_PAGE message to Mystery_Novel:
<programlisting>
<![CDATA[
self~read_last_page
]]>
 </programlisting></para></listitem>
<listitem><para>Pass references regarding an object to the methods of other
objects. For example, a SING method is running in object Song. The code:
<programlisting>
<![CDATA[
Singer2~duet(self)
]]>
</programlisting>
would give the DUET method access to the same Song.</para>
</listitem></itemizedlist>
</listitem></varlistentry>
<varlistentry><term>SIGL
<indexterm><primary>SIGL special variable</primary></indexterm>
</term>
<listitem><para>is set to the line
number of the last instruction that caused a transfer of control to a label
(that is, any SIGNAL, CALL, internal function call, or trapped condition).
</para></listitem></varlistentry>
<varlistentry><term>SUPER
<indexterm><primary>SUPER special variable</primary></indexterm>
</term>
<listitem><para>is set when a method
is activated. Its value is the class object that is the usual starting point
for a superclass method lookup for the SELF object. This is the first immediate
superclass of the class that defined the method currently running. </para>
<para>The
special variable SUPER lets you call a method in the superclass of an object.
For example, the following Savings class has INIT methods that the Savings
class, Account class, and Object class define. </para>
<programlisting>
<![CDATA[
::class Account

  ::method INIT
    expose balance
    use arg balance
    self~init:super    /* Forwards to the Object INIT method */

  ::method TYPE
    return "an account"

  ::method name attribute

::class Savings subclass Account

  ::method INIT
    expose interest_rate
    use arg balance, interest_rate
    self~init:super(balance)  /* Forwards to the Account INIT method */

  ::method type
    return "a savings account"
]]>
</programlisting>
<para>When the INIT method of the Savings
class is called, the variable SUPER is set to the Account class object. For
example: </para>
<programlisting>
<![CDATA[
self~init:super(balance)
]]>
</programlisting><para>This instruction calls
the INIT method of the Account class rather than recursively calling the INIT
method of the Savings class. When the INIT method of the Account class is
called, the variable SUPER is assigned to the Object class. For example: </para>
<programlisting>
<![CDATA[
self~init:super
]]>
</programlisting><para> This instruction calls the INIT method the Object
class defines.</para>
</listitem></varlistentry>
</variablelist>
<para>You can alter these variables, just like any other variable, but Rexx continues
to set RC, RESULT, and SIGL automatically when appropriate. EXPOSE, PROCEDURE,
USE, and DROP instructions affect these variables in their usual way.</para>
<para>Rexx also supplies functions that indirectly affect the execution
of a program. An example is the name that the program was called by and the
source of the program (which are available using the PARSE SOURCE instruction).
In addition, PARSE VERSION makes available the language version and date of
Rexx implementation that is running. The built-in functions ADDRESS, DIGITS,
FUZZ, FORM, and TRACE return other settings that affect the execution of a
program.</para>
</section>

<section id="pubobj"><title>Public, Local, and Built-In Environment Objects</title>
<indexterm><primary>public objects</primary></indexterm>
<indexterm><primary>local objects</primary></indexterm>
<indexterm><primary>built-in objects</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>public objects</secondary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>local objects</secondary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>built-in objects</secondary></indexterm>
<para>In addition to the special variables, Rexx provides
a unique set of objects, called environment objects. Environment
objects are members of the Object class only. Rexx makes the following environment
objects available:</para>

<section id="publicenvobj"><title>The Public Environment Object (.environment)</title>
<indexterm><primary>Environment objects</primary></indexterm>
<para>The Environment object is a directory of public objects that are always
accessible throughout the whole process. To place something in the Environment
directory, you use the form: </para>
<programlisting>
.environment~<emphasis role="italic">your.object</emphasis> = <emphasis role="italic">value</emphasis>
</programlisting>
<para> Include a period (.) in any object name you use, to avoid
conflicts with current or future Rexx entries to the Environment directory.
To retrieve your object, you use the form: </para>
<programlisting>
say .environment~<emphasis role="italic">your.object</emphasis>
</programlisting>
<para> The scope of <computeroutput>.environment</computeroutput> is
<indexterm><primary>symbols</primary>
<secondary>.environment symbol</secondary></indexterm>
the current process.</para>
<para>You use an environment symbol  to access the entries of this
directory. An environment symbol starts with a period and has at least one
other character, which must not be a digit. You have seen environment symbols
earlier; for example in: </para>
<programlisting>
<![CDATA[
asav = .savings~new
]]>
</programlisting><para> <computeroutput>.Savings</computeroutput> is
an environment symbol, and refers to the Savings class. The classes
you create can be referenced with an environment symbol. There is an environment
symbol for each Rexx-defined class, as well as for each of the unique objects
this section describes, such as the NIL object.</para>

<section id="nilobject"><title>The NIL Object (.nil)</title>
<indexterm><primary>symbols</primary>
<secondary>.nil symbol</secondary></indexterm>
<indexterm><primary>.NIL object</primary></indexterm>
<para>The NIL object is
a special environment object that does not contain any data. It represents
the absence of an object, the way a null string represents a string with no
characters. Its only methods are those of the Object class. You use the NIL
object (rather than the null string) to test for the absence of data in an
array entry: </para>
<programlisting>
<![CDATA[
if board[row,column] = .nil
then ...
]]>
</programlisting>
<para>All the environment objects Rexx provides are single symbols. Use
compound symbols when you create your own, to avoid conflicts with future
Rexx-defined entries.</para>
</section>
</section>

<section id="localenvobj"><title>The Local Environment Object (.local)</title>
<indexterm><primary>symbols</primary>
<secondary>.local symbol</secondary></indexterm>
<indexterm><primary>Local environment object</primary></indexterm>
<para>The Local environment object is a directory of process-specific objects
that are always accessible. To place something in the Local environment directory,
you use the form: </para>
<programlisting>
.local~<emphasis role="italic">your.object</emphasis> =  <emphasis role="italic">value</emphasis>
</programlisting><para> Be
sure to include a period (.) in any object name you use, to avoid conflicts
with current or future Rexx entries to the Local directory. To retrieve your
object, you use the form: </para>
<programlisting>
say .local~<emphasis role="italic">your.object</emphasis>
</programlisting><para> The
scope of <computeroutput>.local</computeroutput> is the current process.</para>
<para>You access objects in the Local environment object like in the Environment
object. Rexx provides the following objects in the Local environment: </para>
<variablelist>
<varlistentry><term>.error
<indexterm><primary>symbols</primary>
<secondary>.error symbol</secondary></indexterm>
</term>
<listitem><para>is the Error
object (the default error stream) to which Rexx writes error messages and
trace output to.
</para></listitem></varlistentry>
<varlistentry><term>.input
<indexterm><primary>symbols</primary>
<secondary>.input symbol</secondary></indexterm>
</term>
<listitem><para>is the Input object (the default input stream),
which is the source for the PARSE LINEIN instruction,
the LINEIN method of the Stream class, and (if you do not specify a stream
name) the LINEIN built-in function. It is also the source of the PULL and
PARSE PULL instructions if the external data queue is empty.
</para></listitem></varlistentry>
<varlistentry><term>.output
<indexterm><primary>symbols</primary>
<secondary>.output symbol</secondary></indexterm>
</term>
<listitem><para>is the Output
object (the default output stream), which is the destination of output from
the SAY instruction, the LINEOUT method (.OUTPUT~LINEOUT), and (if
you do not specify a stream name) the LINEOUT built-in function. You can replace
this object in the environment to direct such output elsewhere, for example
to a transcript window.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="builtinenvobj"><title>Built-In Environment Objects</title>
<indexterm><primary>built-in objects</primary></indexterm>
<para>Rexx provides environment
objects that all programs can use. To access these built-in
objects, you use the special environment symbols whose first character
is a period (.).</para>
<variablelist>
<varlistentry><term>.methods
<indexterm><primary>symbols</primary>
<secondary>.methods symbol</secondary></indexterm>
</term>
<listitem><para>The .methods environment symbol identifies a
directory of methods that ::METHOD directives in the currently running program
define. The directory indexes are the method names. The directory values are
the method objects. Only methods that are not preceded by a ::CLASS directive
are in the .methods directory. If there are no such methods, the .methods
symbol has the default value of ".METHODS". Here is an example:
<programlisting>
<![CDATA[
use arg class, methname
class~define(methname,.methods["a"])
::method a
use arg text
say text
]]>
</programlisting>
</para></listitem></varlistentry>
<varlistentry><term>.rs
<indexterm><primary>symbols</primary>
<secondary>.rs symbol</secondary></indexterm>
</term>
<listitem><para>.rs is set to the return status from any executed command, including
those submitted with the ADDRESS instruction. The .rs environment symbol has
a value of -1 when a command returns a FAILURE condition, a value of 1 when
a command returns an ERROR condition, and a value of 0 when a command indicates
successful completion. The value of .rs is also available after trapping the
ERROR or FAILURE condition. </para>

<note>
<para>Tracing interactively does not
change the value of .rs. The initial value of .rs is 0.</para></note>
</listitem></varlistentry>
</variablelist>
</section>

<section id="searchord"><title>The Default Search Order for Environment Objects</title>
<indexterm><primary>search order</primary>
<secondary>for environment symbols</secondary></indexterm>
<para>When you
use an environment symbol, Rexx performs a series of searches to see if the
environment symbol has an assigned value. The search locations and their ordering
are: </para>
<orderedlist>
<listitem><para>The directory of classes declared on ::CLASS directives within the current
program file.</para></listitem>
<listitem><para>The directory of PUBLIC classes declared on ::CLASS directives of other
files included with a ::REQUIRES directive.</para></listitem>
<listitem><para>The program local environment directory, which includes process-specific
objects such as the .INPUT and .OUTPUT objects. You can directly access the
local environment directory by using the .Local environment symbol.</para></listitem>
<listitem><para>The global environment directory, which includes all &quot;permanent&quot; Rexx
objects such as the Rexx-supplied classes (for example, .ARRAY) and constants
such as .TRUE and .FALSE. You can directly access the global environment by
using the .environment symbol or using the VALUE built-in function with a
null string for the <emphasis role="italic">selector</emphasis> argument.</para></listitem>
<listitem><para>Rexx defined symbols. Other simple environment symbols are reserved for
use by Rexx for built-in objects. The currently defined built-in objects are
.RS and .METHODS.</para></listitem>
</orderedlist>
<para>If an entry is not found for an environment symbol, the default character
string value is used. </para>

<note>
<para>You can place entries in both the .local
and .environment directories for programs to use. To avoid conflicts with
future Rexx-defined entries, it is recommended that entries you place in either
of these directories include at least one period in the entry name.</para></note>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[
/* establish a global settings directory */
.local~setentry("MyProgram.settings", .directory~new)
]]>
</programlisting>
</section>
</section>

<section id="scope"><title>Determining the Scope of Methods and Variables</title>
<indexterm><primary>scope</primary></indexterm>
<indexterm><primary>class scope</primary></indexterm>
<para>Methods interact with variables and their
associated data. But a method cannot interact with any variable. Certain methods
and variables are designed to work together. A method designates the variables
it wants to work with by exposing them with an
<indexterm><primary>EXPOSE instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>EXPOSE instruction</secondary></indexterm>
EXPOSE instruction. The exposed
methods are called object variables. Exposing variables confines them to an
object; in object-oriented terms, they are encapsulated. This protects the
object variables' data from being changed by &quot;unauthorized&quot;
methods belonging to other objects.</para>

<section id="objwclsc"><title>Objects with a Class Scope</title>
<para>Encapsulation usually takes place at the class level. The class is designed
as a template of methods and variables. The instances themselves retain only
the values of their variables.</para>
<para>Within the hierarchy, the class structure ensures the integrity of a class's
variables, controlling the methods allowed to operate on them. The class structure
also provides for easy updating of the method code. If a method requires a
change, you only have to change it once, at the class level. The change then
is acquired by all the instances sharing the method.</para>
<para>Associated methods and variables have a certain scope, which is the
class to which they belong:</para>

<figure><title>Scope of the Number Class</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxoq0s05.jpg" scale="70">
</imageobject>
</mediaobject>
</figure>

<para>Each class in a class hierarchy has a scope different from any other class.
This is what allows a variable in a subclass to have the same name as a variable
in a superclass, even though the methods that use the variables may be completely
different.</para>
</section>

<section id="objwownsc"><title>Objects with Their Own Unique Scope</title>
<indexterm><primary>scope</primary></indexterm>
<indexterm><primary>methods</primary>
<secondary>scope</secondary></indexterm>
<para>The methods and variables used by instances in a class are usually found
at the class level. But sometimes an instance differs in some respect from
the others in its class. It might perform an additional action or require
some unique handling. In this case one or more methods and related variables
can be added directly to the instance. These additional methods and variables
form a separate scope, independent of the class scopes found throughout the
rest of the hierarchy.</para>
<para>Methods can be added directly to an instance's collection of object
methods using SETMETHOD, a method of the Object class. All subclasses of the
Object class inherit SETMETHOD. Alternately, the Class class provides an ENHANCED
method that lets you create new instances of a class, whose object methods
are the instance methods of its class, but enhanced with the additional collection
methods.</para>
</section>
</section>

<section id="methna"><title>More about Methods</title>
<para>A method name can
<indexterm><primary>method names, specifying</primary></indexterm>
be any character string. When an object receives a message, Rexx searches
for a method whose name matches the message name.</para>

<para>You must surround a method name with quotation marks when it
is the same as an operator. The following example illustrates how to do this
correctly. It creates a new class (<computeroutput>Cost</computeroutput>),
defines a new method (<computeroutput>%</computeroutput>), creates an instance
of the Cost class (Mycost), and sends
a <computeroutput>%</computeroutput> message to Mycost:</para>
<para></para>
<programlisting>
<![CDATA[

mycost = Cost~new           /* Creates new instance mycost.*/
mycost~"%"                  /* Sends % message to mycost.  */

::class Cost subclass "Retail" /* Creates Cost, a sub-     */
                               /* class of "Retail" class. */
  ::method "%"                 /* Creates % method.        */
    expose p                   /* Produces: Enter a price. */
    say "Enter a price"        /* If the user specifies a  */
    pull p                     /* price of 100,            */
    say p*1.07                 /* produces: 107            */
    return 0
]]>
</programlisting>

<section id="meths"><title>The Default Search Order for Selecting a Method</title>
<indexterm><primary>search order</primary>
<secondary>for methods, default</secondary></indexterm>
<indexterm><primary>methods</primary>
<secondary>selecting</secondary></indexterm>
<indexterm><primary>methods</primary>
<secondary>search order for</secondary></indexterm>
<indexterm><primary>default search order for methods</primary></indexterm>
<para>When a message is sent to an object, Rexx looks for a method whose name
matches the message string. If the message is ADD, for example, Rexx looks
for a method named ADD. Because, in the class hierarchy, there may be more
than one method with the same name, Rexx begins its search at the object specified
in the message. If the sought method is not found there, the search continues
up the hierarchy. Rexx searches in the following order: </para>
<orderedlist>
<listitem><para> A method the object defines itself
(with SETMETHOD or ENHANCED).</para></listitem>
<listitem><para>A method the object's class defines. </para>
<para>An object acquires the methods
of its parent class; that is, the class for which the object was created.
If the class subsequently receives new methods, objects predating the new
methods do not acquire them.</para></listitem>
<listitem><para>A method an object's superclasses define. </para>
<para>As with the object's
class, only methods that existed in the superclass when the object was created
are valid. Rexx searches the superclass method definitions in the order that
INHERIT messages were sent to an object's class.</para></listitem></orderedlist>
<para>If Rexx does not find a match
for the message name, Rexx checks the object for method name UNKNOWN. If it
<indexterm><primary>UNKNOWN method</primary></indexterm>
exists, Rexx calls the UNKNOWN method, and returns whatever the UNKNOWN method
returns. For more information on the UNKNOWN method, see
<link linkend="unknown">Defining an UNKNOWN Method</link>.
If the object does not have an UNKNOWN method, Rexx raises a NOMETHOD condition.
Any trapped information can then be inspected using Rexx's CONDITION built-in
function.</para>
<para>Rexx searches up the hierarchy so that methods
existing in higher levels can be supplemented or overridden by methods existing
in lower levels.</para>

<figure><title>Searching the Hierarchy for a Method</title>
<mediaobject>
<imageobject>
<!-- Note! - if we include a /imagedata tag we get an error for DSSSL! -->
<imagedata fileref="rxoq0s06.jpg" scale="60">
</imageobject>
</mediaobject>
</figure>

<para>For example, suppose you wrote a program that allows users to look up other
users' phone numbers. Your program includes a class called Phone_Directory,
and all its instances are users' names with phone numbers. You have included
a method in Phone_Directory called NOTIFY that reports some data to a file
whenever someone looks up a number. All instances of Phone_Directory use the
NOTIFY method.</para>
<para>Now you decide you want NOTIFY, in addition to its normal handling, to
personally inform you whenever anyone looks up your number.
To accommodate this special case for your name only, you create your own NOTIFY
method that adds the new task and replicates the file-handling task. You save
the new method as part of your own name instance, retaining the same name,
NOTIFY.</para>
<para>Now, when a NOTIFY message is sent to your name instance, the new version
of NOTIFY is found first. Rexx does not look further up the class hierarchy.
The instance-level version overrides the version at
the class level. This technique of overriding lets you change a method used
by one instance without disturbing the common method used by all the other
instances. It is very powerful for that reason.</para>
</section>

<section id="xsearch"><title>Changing the Search Order for Methods</title>
<indexterm><primary>search order</primary>
<secondary>for methods, changing</secondary></indexterm>
<indexterm><primary>changing the search order for methods</primary></indexterm>
<para>When composing a message, you
can change the default search order for methods by doing both of the following: </para>
<orderedlist>
<listitem><para>Making the receiver
object the sender object. You usually do this by specifying the special variable
<indexterm><primary>variables</primary>
<secondary>special</secondary></indexterm>
SELF. SELF holds the value of the object in which a method is running. You
can use SELF to run another method in an object where a method is already
running or pass references about an object to the methods of other objects.</para></listitem>
<listitem><para>Specifying a colon and a class symbol after the message name. The class
symbol identifies the class object to use as the starting point for the search.
This class object must be:
<itemizedlist>
<listitem><para>A direct superclass of the class that defines the active method</para></listitem>
<listitem><para>The object's own class, if you used SETMETHOD to define the
active method</para>
<para>The class symbol is usually the special variable
<indexterm><primary>variables</primary>
<secondary>special</secondary></indexterm>
SUPER, but it can be any environment symbol
or variable name whose value is a valid class.</para></listitem>
</itemizedlist></para></listitem></orderedlist>
<para>In <link linkend="sample">A Sample Program Using Directives</link>, an
<indexterm><primary>SUBCLASS option</primary></indexterm>
Account subclass of the Object superclass is created. It defines a TYPE method
for Account, and creates the Savings subclass of Account. The example defines
a TYPE method for the Savings subclass, as follows: </para>
<programlisting>
<![CDATA[
::class Savings subclass Account

  ::method "TYPE"
    return "a savings account"
]]>
</programlisting>
<para>To change
the search order so Rexx searches for TYPE in the Account rather than Savings
subclass, enter this instead: </para>
<programlisting>
<![CDATA[
  ::method "TYPE"
    return self~type:super "(savings)"
]]>
</programlisting>
<para>When you create an <computeroutput>asav</computeroutput> instance of
the Savings subclass and send a TYPE message to
<computeroutput>asav</computeroutput>: </para>
<programlisting>
<![CDATA[
say asav~type
]]>
</programlisting>
<para>Rexx displays: </para>
<programlisting>
<![CDATA[
an account
]]>
</programlisting>
<para> rather than: </para>
<programlisting>
<![CDATA[
a savings account
]]>
</programlisting>
<para> because Rexx searches for TYPE in the Account class first.</para>
</section>

<section id="public"><title>Public versus Private Methods</title>
<indexterm><primary>search order</primary>
<secondary>for methods, changing</secondary></indexterm>
<indexterm><primary>public methods</primary></indexterm>
<indexterm><primary>methods</primary>
<secondary>public</secondary></indexterm>
<indexterm><primary>private methods</primary></indexterm>
<indexterm><primary>methods</primary>
<secondary>private</secondary></indexterm>
<para>A method can be public or private.
Any object can send a message that runs a public method.
Only a message an object sends to itself, using the special variable SELF
as the message receiver, can run  a private method.
Private methods include methods at different scopes within the same object.
This allows superclasses to make methods available to their subclasses while
hiding those methods from other objects. A private method is like an internal
subroutine. It shields the internal information of an object.</para>
</section>

<section id="unknown"><title>Defining an UNKNOWN Method</title>
<indexterm><primary>UNKNOWN method</primary></indexterm>
<para>When an object that receives
a message has no matching message name, Rexx checks if the object has a method
named UNKNOWN. If it does, Rexx calls UNKNOWN, passing two arguments. The
first is the name of the method that was not located. The second is an array
containing the arguments passed with the original message.</para>
<para>To define an UNKNOWN message, you specify: </para>
<programlisting>
UNKNOWN(<emphasis role="italic">message_name,message_args</emphasis>)
</programlisting>
</section>
</section>

<section id="concur"><title>Concurrency</title>
<indexterm><primary>concurrency</primary></indexterm>
<para>In object-oriented
programming, as in the real world, objects interact with each other. Assume,
for example, throngs of people interacting at rush hour in the business district
of a big city. A program that aspires to simulate the real world would have
to enable many objects to interact at any given time. That could mean thousands
of objects sending messages to each other, thousands of methods running at
once. In Rexx, this simultaneous activity is called concurrency.
To be precise, the concurrency is object-oriented concurrency because
it involves objects, as opposed to, for example, processes or threads.</para>
<para>Rexx objects are inherently concurrent, and this concurrency takes the
following forms: </para>
<itemizedlist>
<listitem><para>Inter-object concurrency, where several objects
are active--exchanging messages, synchronizing, running their methods--at
the same time</para></listitem>
<listitem><para>Intra-object concurrency, where several methods
are able to run on the same object at the same time</para></listitem>
</itemizedlist>
<para>The default settings in Rexx allow full inter-object concurrency but limited
intra-object concurrency. Some situations, however, call for full intra-object
concurrency.</para>

<section id="interobjconcur"><title>Inter-Object Concurrency</title>
<indexterm><primary>inter-object concurrency</primary></indexterm>
<para>Rexx provides for inter-object
concurrency, where several objects in a program can run at the same time,
in the following ways: </para>
<itemizedlist>
<listitem><para>By early reply, by means of the
<indexterm><primary>REPLY instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>REPLY instruction</secondary></indexterm>
REPLY instruction</para></listitem>
<listitem><para>Using message objects</para></listitem></itemizedlist>
<para>Early reply allows
the object that sends a message to continue processing after the message is
sent. Meanwhile, the receiving object runs the method corresponding to the
message. This method contains the REPLY instruction, which returns any results
to the sender, interrupting the sender just long enough to reply. The sender
and receiver continue operating simultaneously.</para>
<para>Alternatively, an independent message object can
be created and sent to a receiver. One difference in this approach is that
any reply returned does not interrupt the sender. The reply waits until the
sender asks for it. In addition, message objects can notify the sender about
the completion of the method it sent, and even specify synchronous or asynchronous
method activation.</para>
<para>The chains of execution represented by the sender and receiver methods
are called activities.  An activity is a thread of execution that
<indexterm><primary>thread</primary></indexterm>
can run methods concurrently with methods on other activities. In other words,
<indexterm><primary>activities</primary></indexterm>
<emphasis role="italic">activities</emphasis> can run at the same time.</para>
<para>An activity contains a stack of invocations that
represent the Rexx programs running on the activity. An invocation can be:</para>
<itemizedlist>
<listitem><para>A main program invocation</para></listitem>
<listitem><para>An internal function or subroutine call</para></listitem>
<listitem><para>An external function or subroutine call</para></listitem>
<listitem><para>An INTERPRET instruction</para></listitem>
<listitem><para>A message invocation</para></listitem></itemizedlist>
<para>An invocation is pushed onto an activity when an executable unit is invoked.
It is removed (or popped) when execution completes.</para>

<section id="objvarpools"><title>Object Variable Pools</title>
<indexterm><primary>variables</primary>
<secondary>in variable pools</secondary></indexterm>
<indexterm><primary>object variable pools</primary></indexterm>
<para>Every object has its own set of variables, called its object
variable pool. These are variables associated solely with the
object. When an object's method runs, it first identifies the object variables
it intends to work with. Technically, it &quot;exposes&quot; these variables, using
<indexterm><primary>variables</primary>
<secondary>exposing</secondary></indexterm>
the Rexx instruction EXPOSE. Exposing the object's variables distinguishes
them from variables used by the method itself, which are not exposed. Every
method an object owns--that is, all the instance methods in the object's
class--can expose variables from the object's variable pool.</para>
<para>Therefore, an object variable pool includes variables:</para>
<itemizedlist>
<listitem><para>Exposed by methods in the object's class. This set of variables is
called a subpool.</para></listitem>
<listitem><para>Inherited from classes elsewhere in the hierarchy (in the form
of additional subpools).</para></listitem>
</itemizedlist>
<para>All of a class's variables, together with the methods that expose them,
are called a class scope. Rexx exploits this class
scope to achieve concurrency. To explain, the object variable pool is a collection
of variable subpools. Each subpool is at a different scope in the object's
inheritance chain. As long as the methods running on the object are at different
scopes, they can run simultaneously.</para>
<para>Scopes, like objects, hide and protect data from outside manipulation.
Methods of the same scope share the variable subpools of that scope. The scope
shields the variable subpools from methods operating at other scopes. Thus,
you can reuse variable names from class to class, without the variables being
accessed and possibly corrupted by a method outside their own class. So class
scopes divide an object's variable pool into subpools that can operate
independently of one another. Several methods can use the same variable pool
concurrently, as long as they confine themselves to variables in their own
subpools.</para>
</section>

<section id="prioritizeaccess"><title>Prioritizing Access to Variables</title>
<indexterm><primary>access to variables, prioritizing</primary></indexterm>
<indexterm><primary>prioritizing access to variables</primary></indexterm>
<indexterm><primary>locking a scope</primary></indexterm>
<para>Even with class scopes and subpools,
a variable is vulnerable if several methods within the scope try to access
it at the same time. To handle this, Rexx ensures that when a particular method
is activated and exposes variables from its subpool, that method has exclusive
use of the subpool until processing is complete. Until then, Rexx delays the
execution of any other method that needs the same subpool.</para>
<para>Thus if different activities send several messages to the same object,
Rexx forces the methods to run sequentially within a single scope. This
&quot;first-in, first-out&quot; processing of methods in a scope
prevents them from simultaneously accessing one variable, and possibly
corrupting the data.</para>
</section>

<section id="sendmsgwact"><title>Sending Messages within an Activity</title>
<indexterm><primary>sending messages within an activity</primary></indexterm>
<para>Rexx makes one
exception to sequential processing--when a method sends a message to
itself. Assume that method M1 has exclusive access to object O, and then tries
to run a second, internal method M2, also belonging
to O. Internal method M2 would try to run, but Rexx would delay it until the
original method M1 finished. Yet M1 would be unable to proceed until M2 ran.
The two methods would become deadlocked. In actual practice Rexx intervenes
by treating internal method M2 like a subroutine call. In this case, Rexx
runs method M2 immediately, then continues processing method M1.</para>
<para>The mechanism controlling this
is the activity. Typically, whenever a message is invoked on an object, the
activity acquires exclusive access by locking the
object's scope. Any other activity sending a message to the object whose
scope is locked must wait until the first activity releases the lock. The
situation is different, however, if the messages originate from the same
activity. When an invocation running on an activity sends another
message to the same object, the method is allowed
to run because the activity has already acquired the lock for the scope. Thus,
Rexx permits nested, nonconcurrent method invocations on a single activity.
No deadlocks occur because Rexx treats these additional messages as subroutine
calls.</para>
</section>
</section>

<section id="intraobjconcur"><title>Intra-Object Concurrency</title>
<indexterm><primary>intra-object concurrency</primary></indexterm>
<para>Several methods can
access the same object at the same time only if they are operating at different
scopes. That is because they are working with separate variable subpools.
If two methods in the same scope try to run on the object, Rexx by default
processes them on a &quot;first-in, first-out&quot; basis, while treating internal
methods as subroutines. You can, however, achieve full intra-object concurrency.
Rexx offers several mechanisms for this, including: </para>
<itemizedlist>
<listitem><para>The SETUNGUARDED method of the Method class and the UNGUARDED option of
the ::METHOD directive, which provide unconditional intra-object concurrency.</para></listitem>
<listitem><para>The
<indexterm><primary>GUARD instruction</primary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>GUARD instruction</secondary></indexterm>
GUARD OFF and GUARD ON instructions, which permit switching between
intra-object and default concurrency.</para></listitem></itemizedlist>

<para>When intra-object concurrency at the scope level is needed,
you must specifically employ these mechanisms (see the following section).
Otherwise, Rexx sequentially processes the methods when they are competing
for the same object variables.</para>

<section id="activat"><title>Activating Methods</title>
<para>By default, Rexx assumes that an active method requires exclusive use of
its object variable pool. If another method attempts access at that time,
it is locked out until the first method is finished with the variable pool.
This default intra-object concurrency maintains the integrity of the variable
pool and prevents unexpected results. Rexx manages queues for incoming requests
that result in messages being sent to the same object.</para>
<para>Some methods can run concurrently without affecting variable pool integrity
or yielding unexpected results. When a method does not need exclusive use
of its object variable pool, you can use the SETUNGUARDED method or the UNGUARDED
option of the ::METHOD directive to provide unconditional intra-object concurrency.
These mechanisms control the locking of an object's scope when a method
is invoked.</para>
<para>Many methods cannot use SETUNGUARDED and UNGUARDED
because they sometimes require exclusive use of their variable pool. At other
times, they must perform some action that involves the concurrent use of the
same pool by a method on another activity. In this case, you can use the GUARD
built-in function. When the method reaches the point in its processing where
it requires concurrent use of the variable pool, this function calls the GUARD
OFF function. GUARD OFF lets another method that runs on a different activity
become active on the same object. If the method needs to regain exclusive
use, it calls GUARD ON.</para>
<para>For more flexibility when activating methods, you can use GUARD ON/OFF
with the &quot;WHEN <emphasis role="italic">expression</emphasis>&quot;
option. Add this instruction to the
method code at the point where exclusive use of the variable pool becomes
conditional. When processing reaches this point, Rexx evaluates
<emphasis role="italic">expression</emphasis> to determine if it is true
or false.</para>
<para>For example, if you specify &quot;GUARD OFF WHEN
<emphasis role="italic">expression</emphasis>,&quot; the
active method keeps running until <emphasis role="italic">expression</emphasis>
becomes true. To become true, another method must assign or drop an object
variable that is named in <emphasis role="italic">expression.</emphasis>
Whenever an object variable changes, Rexx reevaluates
<emphasis role="italic">expression.</emphasis> If
<emphasis role="italic">expression</emphasis> becomes true, GUARD is turned off,
exclusive use of the variable pool is released, and other methods needing
exclusive use can begin running. If
<emphasis role="italic">expression</emphasis> becomes false again,
GUARD is turned on and the active method regains exclusive use. </para>

<note>
<para>If <emphasis role="italic">expression</emphasis> cannot be met,
GUARD ON WHEN puts the program
in a continuous wait condition. This can occur in particular when several
activities run concurrently. A second activity can make
<emphasis role="italic">expression</emphasis> invalid
before GUARD ON WHEN can use it.</para></note>
</section>
</section>
</section>
</chapter>
