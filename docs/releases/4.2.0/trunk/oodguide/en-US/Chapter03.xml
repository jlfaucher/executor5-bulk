<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "oodguide.ent">
%BOOK_ENTITIES;
]>
<!--#########################################################################
    #
    # Description: Open Object Rexx: ooDialog User Guide XML file
    #
    # Copyright (c) 2012-2014 Rexx Language Association. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    #########################################################################
-->

<!-- Chapter03 - Re-Structuring the Code			  v01-00 12Mar13

     Changes:
     v01-00 31May12: First version.
            12Mar13: Changed emphasis of code terms to conform with conventions.
-->
<chapter id="chapThree"><title>Re-Structuring the Code</title>
<indexterm><primary>Code structure</primary></indexterm>
<para>The current code is not good. It works - but only because it's very simple. The problem is its
      design - its structure. There are three quite different concerns which, for
      all but he simplest of programs, should be separated. These are: the
      user interface (aka UI or GUI) including both presentation and user action; the data (in our
      case a set of text strings); and the "business" concept that we're implementing. And the
      "business" of this code is picking a single text string from a set of "words of wisdom"
      strings. The code in the <computeroutput>Exercise03</computeroutput> folder separates these
      concerns, with no change as far as the user's concerned. </para>
<para>The three areas of concern have a relationship with the Model-View-Controller or MVC
      concept (see
  <ulink url="http://en.wikipedia.org/wiki/model-view-controller"><citetitle>Model-View-Controller</citetitle></ulink>).
      However, the role of the Controller
      in classic MVC is handled largely by ooDialog and the underlying Windows UI platform. This
      leaves us with the View and the Model, where the Model is the "business" - that is, an
      implementation of the relevant part of the real business - and the View is the part
      that provides for user interaction. But these two concepts - View and
      Model - are insufficient. To these two must be added data - that is, data-on-disk
      (aka "persistent data"). So three areas of concern are required: View, Model, and Data.
</para>
   <para>
      <emphasis role="italic">At this point, the reader may wish to skip the next
      three paragraphs which
      provide a rationale for the View-Model-Data terminology, and introduce the
      concept of software "components". However, please come back here if later the
      use of the term "component" is not obvious.</emphasis>
      </para>
  <para>While the model-view-data scheme works well for the
      PC-resident single-user applications introduced in this Guide, it does not scale to
      distributed systems with multiple concurrent users where, aside from anything else, the
      data is on a remote server or available from a remote service. For such systems,
      additional architectural concepts are required. See, for example, chapters
      1 and 2 of "Enterprise Service Oriented Architectures" by McGovern, Sims,
      Jain &amp; Little; or "Business Component Factory" by Herzum &amp; Sims.
      <indexterm><primary>Component concepts</primary><secondary>Reference</secondary></indexterm>
      Dealing with large-scale distributed systems, both of these references use
      the terms "user", "workspace" and "workspace-resource" instead of "view",
      "model" and "data". Although the semantics are identical, this document uses
      the latter terms since they are both simpler and shorter.
    </para>
<para>Model components implement the essence of an application. Views
      enable the user to take action and see the result. Data components know where the data
      is, and handle the mechanics of reading and writing to disk. (For distributed multi-user
      applications, the Model would invoke some service on a back-end server, where there would
      probably be another kind of Model component which in turn would use a separate Data component
      that accesses a corporate database or remote service).</para>
<para>But why use the term "component" instead of "class"? The answer is (as will be seen in later
      exercises) that for industrial-strength apps, a component generally consists of a number of
      classes. And a single class can seldom be independently "plugged in" to a runtime environment
      without the other classes required fully to implement a single business concept in its View,
      Model or Data role. A component, however, is intended to be "pluggable" into the runtime,
      since it is all and only the implementation of one of the "view", "model", or "data" aspect of
      a business concept. This distinction between class and component is not so obvious using
      ooRexx as it is with compiled languages, where classes are seen by the developer in source
      code, but the artifact that is loaded into the runtime is a compiled *.exe or *.dll. Thus one
      of the purposes of a component is to extend the concept of low coupling and high cohesion into
      the runtime. Finally, the name given to the set of "view", "model" and "data" components that
      implement a given business concept such as "Customer" is "Business Component". The interface
      of a Business Component is defined as the interface of the "model" component. <indexterm>
        <primary>Business Component</primary>
      </indexterm>
      <indexterm>
        <primary>Component concepts</primary>
      </indexterm>
    </para>
<para>Let's now look at the implementation of each of these three areas of concern.
    In the second part of this chapter, we'll further reduce coupling.</para>

<section id="chap03-struc"><title>Fixing the Structure</title><!-- section 3.1 -->
<para>First, re-run <computeroutput>Wow2.rex</computeroutput> in the
          <computeroutput>Exercise02</computeroutput> folder, and then run
          <computeroutput>Wow3.rex</computeroutput> from the
          <computeroutput>Exercise03</computeroutput> folder. To the user, they're identical.
        However, in <computeroutput>Wow3.rex</computeroutput> the code has been re-structured so
        that there are now three different classes, each implementing one of the three areas of
        concern. We'll look at each class in turn, but first here's a whiteboard-level picture of
        how the three classes interact to produce a "words of wisdom" string on the screen.
        </para>
        <para>
        <figure id="fig0301">
          <title>Exercise03 Structure</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/Chapter03-Image1.jpg" scale="70" />
            </imageobject>
          </mediaobject>
        </figure>Now look at the <computeroutput>Wow3.rex</computeroutput> code. It
        consists of the three classes shown in the diagram: <computeroutput>WowView</computeroutput>,
          <computeroutput>WowPicker</computeroutput>, and <computeroutput>WowData</computeroutput>.
        "Wow" in the names is short for "words of wisdom". </para>

<section id="chap03-struc-ui"><title>The "View" Component</title><!-- section 3.1.1 -->
  <para>The <computeroutput>WowView</computeroutput> class implements the UI area of concern (it's a
    single-class component). The <computeroutput>init</computeroutput> method is
    identical to that of Exercise02's
    <computeroutput>Wow2</computeroutput> except that it also creates an instance of
    <computeroutput>WowPicker</computeroutput> called (unsurprisingly) <computeroutput>wowPicker</computeroutput>.
    There's also an <computeroutput>expose</computeroutput> statement
    to make the <computeroutput>wowPicker</computeroutput> object available to other methods.</para>
<para>
  The <computeroutput>defineDialog</computeroutput> method has not changed. But the
  <computeroutput>okClicked</computeroutput> method is different - and much shorter:
<programlisting><![CDATA[
    ::method okClicked
      expose wowPicker newText
      wow = wowPicker~pickWow
      newText~setText(wow)
      return
]]></programlisting>
To get the "words of wisdom" to display, it now merely asks
  <computeroutput>wowPicker</computeroutput> for a string to display.
</para>
<para>One other change is that instead of creating a new static text control every time the button
  is pressed, the control is created once in the new <computeroutput>initDialog</computeroutput>
  method and re-used in the <computeroutput>okClicked</computeroutput> method.
  The <computeroutput>initDialog</computeroutput> method is called automatically by ooDialog after
  the dialog has been created in order to allow controls to be initialized (the "init" in "initDialog"
  stands for "initialize").</para>
<para>In summary, all knowledge of picking a string, and of the set from which to pick, has been
          exported elsewhere. The <computeroutput>WowView</computeroutput> class now addresses only
          the areas of GUI display and GUI interaction. This is crucially important. A good way to
          make a complex task hopelessly complicated is to mix "model" and "data" concerns with the
          "view" concerns. </para>
</section>

<section id="chap03-struc-bus"><title>The "Model" Component</title><!-- section 3.1.2 -->
<para> The class implementing the model component - <computeroutput>WowPicker</computeroutput>
          - is very simple:
<programlisting><![CDATA[
    ::METHOD init
      expose wowSet
      dataSource = .WowData~new
      wowSet = dataSource~readWowSet
      return

    ::METHOD pickWow
      expose wowSet
      i = random(1,7)
      return wowSet[i]
]]></programlisting>
  The <computeroutput>init</computeroutput>method gets a reference to an
  instance of the class <computeroutput>WowData</computeroutput> - which handles the data
  area of concern - and then gets a set of Words of Wisdom into the array variable
  <computeroutput>wowSet</computeroutput>. Then in the method <computeroutput>pickWow</computeroutput>
  a Words of Wisdom string is picked randomly from <computeroutput>wowSet</computeroutput> and returned.
</para>
</section>

<section id="chap03-struc-dat"><title>The "Data" Component</title><!-- section 3.1.3 -->
  <para>The last (extremely simple) class in <computeroutput>Wow3.rex</computeroutput> is
    <computeroutput>WowData</computeroutput>. In its <computeroutput>init</computeroutput>
    method, it loads up an array of seven text strings into the instance variable
    <computeroutput>arrWow</computeroutput>, and in its <computeroutput>readWowSet</computeroutput>
    method returns that array to the caller. One can see how this it
    might be enhanced, for example by providing a method that renews the set of "words of
    wisdom" from a larger set in a disk file.
  </para>
</section>
</section>
<section id="chap03-cplg"><title id="reduce-cplg">Reducing Coupling</title><!-- section 3.2 -->
<indexterm><primary>Coupling</primary></indexterm>
<para>The three classes in <computeroutput>Wow3.rex</computeroutput> are reasonably decoupled: the
        dialog is in one class, the business logic (such as it is) in another, and the data in a
        third. Notice however that both <computeroutput>WowView</computeroutput> and
          <computeroutput>WowPicker</computeroutput> create a reference to another class
          (<computeroutput>WowPicker</computeroutput> and <computeroutput>WowData</computeroutput>
        respectively) in order to invoke them. Each of these three classes can be called a "main"
        class, since each is the main (and in this case only) class implementing a separate area of
        responsibility. In more complex applications, each component (area of responsibility)
        will have one main class and a
        number of subsidiary classes - for example, a (main) SalesOrder class with subsidiary
        OrderLine and DeliveryInstructions classes. The intent of a component is to be,
        as much as possible, a self-contained unit of business function. <indexterm>
          <primary>Component</primary>
        </indexterm>
      </para>
<para>Now, when considering more complex applications, it is arguable that it is not the
        responsibility of either class to know about the creation of instances of other classes.
        Later we will see that, for each important business concept (such as SalesOrder, Customer,
        or Product), each component (view, model, and data) will have a number of
        classes, and each will have one main class expressing the core of the business concept.
        If these three kinds of component are to be as independent as possible, then
        each should know as little as possible about the others. Such independence
        is usefully enhanced if a way is found to move the knowledge of
        how to get references to the main classes to a fourth area. And there is just such an area -
        the application. </para>
  <para>In ooDialog programs, there is often a block of code at the beginning of the program file
        that kicks off a dialog by instantiating an ooDialog class. From there, all the behavior is
        in the dialog classes. This "kick-off" block of code can be used to reduce coupling by
        pre-instantiating the main classes, and storing the object references in
        <computeroutput>.local</computeroutput>. Thus no main class has to know how to instantiate
        any other main class. But, when a main class gets the object reference for another main
        class instance, doesn't the first class have to know the correct name of the object
        reference in <computeroutput>.local</computeroutput>? Well, yes, but even that could be
        fixed - for example by providing a business-oriented instance reference such as Customer
        Number, and having some third party object handle the instantiation. </para>
  <para>An example of decoupling the three areas of concern is provided in the
          <computeroutput>Exercise03</computeroutput> folder. Try running
          <computeroutput>Startup.rex</computeroutput>. It behaves exactly as
          <computeroutput>Wow3.rex</computeroutput> does. However, the code is now structured into
        four *.rex files: <computeroutput>Startup</computeroutput>,
          <computeroutput>WowView</computeroutput>, <computeroutput>WowModel</computeroutput>, and
          <computeroutput>WowData</computeroutput>. The code in
          <computeroutput>Startup.rex</computeroutput> is very simple:
<programlisting><![CDATA[
    .local~my.idWowData = .WowData~new
    .local~my.idWowPicker = .WowPicker~new
     dlg = .WowView~new

    .local~my.idWowData~activate
    .local~my.idWowPicker~activate
    dlg~activate

    ::REQUIRES "WowView.rex"
    ::REQUIRES "WowModel.rex"
    ::REQUIRES "WowData.rex"
]]></programlisting>The first three statements create the three classes, with the ids of the
        first two being stored in <computeroutput>.local</computeroutput>. Creation of the dialog is
        done by the third statement (<computeroutput>dlg = .WowView~new</computeroutput>). The next
    three statements send an <computeroutput>activate</computeroutput> message to each of the
        three classes. This is because when dealing with complex applications with "main" classes
        (each in their own component),
        it is very useful to distinguish between two kinds of class setups: firstly the
        technical creation of a class (done by invoking the <computeroutput>init</computeroutput>
        method), and secondly the initial setup of various application-related things (done by
        invoking an <computeroutput>activate</computeroutput> method.</para>
  <para>
  Notice that <computeroutput>WowView</computeroutput>'s
    <computeroutput>init</computeroutput>>
    method returns to the caller. The <computeroutput>activate</computeroutput> method, on the other hand,
  does not return until the dialog is closed. This is because
  the statement that actually surfaces the dialog -
    <computeroutput>self~execute("SHOWTOP", IDI_DLG_OOREXX)</computeroutput> is the
  last statement in <computeroutput>WowView</computeroutput>'s
    <computeroutput>activate</computeroutput> method. And once the dialog is surfaced
  using <computeroutput>SHOWTOP</computeroutput>,
  control only returns to the application (that is, to <computeroutput>Startup.rex</computeroutput>)
  when the dialog is closed (although, as will be discussed later, there are ways
  to return control much sooner).
  </para>
  <para>But why move the <computeroutput>self~execute("SHOWTOP"...)</computeroutput> statement into
    the <computeroutput>activate</computeroutput> method of the
          <computeroutput>MyDialog</computeroutput> class? After all, it would work just as well if
        it were the last statement in the Startup file. The reason is that the business of surfacing
        the dialog window is arguably not that of the application; rather it's the business of the
        view's class object. Thus the application is reduced as much as possible to a simple "kickoff"
        script, while the real work is done by the classes that are kicked off. </para>
  <para>There is, however, one important consequence of this move. Since the
    <computeroutput>self~execute("SHOWTOP"...)</computeroutput> statement does not return
        until the dialog is closed, the method blocks on this statement, and there is potential for
        a hang. In <computeroutput>Wow3.rex</computeroutput>, this statement was at the end of the
        "application" part of the program, and as there was nothing after it, the block didn't
        matter. But re-factoring the classes into different files has moved it to the
    <computeroutput>activate</computeroutput> method of <computeroutput>WowView</computeroutput>. This
    introduces a concurrency issue. If not dealt with, then when the user clicks the
    <computeroutput>More wisdom</computeroutput> button, the <computeroutput>okClicked</computeroutput>
    method can not run until the <computeroutput>activate</computeroutput> method ends - that is,
    until the user closes the dialog window - a real catch 22, where the result is that no words
    of wisdom will appear.</para>
    <indexterm><primary>Concurrency issue</primary></indexterm>
    <indexterm><primary>Blocking</primary><secondary>concurrency issue</secondary></indexterm>
  <para>
  The reason <computeroutput>WowView</computeroutput> works is because its
  <computeroutput>activate</computeroutput> method
  has the <computeroutput>unguarded</computeroutput> option specified on its
    method statement. Try commenting "UNGUARDED"<indexterm><primary>Unguarded</primary></indexterm>
    out and running the exercise without it.
  </para>
  <para>As a general rule, event handling methods such as
    <computeroutput>okClicked</computeroutput> should be unguarded. Indeed, <computeroutput>WowView</computeroutput> runs happily if the "unguarded"
    option is moved to the <computeroutput>okClicked</computeroutput> method statement - or
    indeed if it's on both method statements.</para>
  <para>
  In the next chapter, we leave "words of wisdom", and start building a more realistic application.
  </para>
</section>

</chapter>

