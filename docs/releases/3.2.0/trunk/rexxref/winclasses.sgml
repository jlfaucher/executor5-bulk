<!--#########################################################################
    #
    # Description: Open Object Rexx: Reference SGML file.
    #
    # Copyright (c) 2005-2007, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<section id="winclasses"><title>The Windows Specific Classes</title>
<para>This section describes the Windows-specific classes supplied with
ooRexx.</para>

<section id="clsWinMenuObject"><title>The Windows MenuObject Class</title>
<indexterm><primary>MenuObject class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>MenuObject class</secondary></indexterm>
<para>The MenuObject class provides methods to query, manipulate, and  interact
with the menu or submenu of a window.</para>
<para>Access to MenuObjects requires that the following directive
appear in the Rexx program.</para>
<programlisting>
::requires 'winsystm.cls'
</programlisting>
<para><emphasis role="bold">Methods the MenuObject Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>findItem</para></listitem>
<listitem><para>findSubmenu</para></listitem>
<listitem><para>idOf</para></listitem>
<listitem><para>isMenu</para></listitem>
<listitem><para>items</para></listitem>
<listitem><para>processItem</para></listitem>
<listitem><para>submenu</para></listitem>
<listitem><para>textOf(id)</para></listitem>
<listitem><para>textOf(position)</para></listitem></itemizedlist>

<section id="ismenumo"><title>isMenu</title>
<indexterm><primary>isMenu method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isMenu method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isMenu------------------------------------------------------><
]]>
</programlisting>

<para>Returns 1 if the associated window is a menu, otherwise 0.</para>
</section>

<section id="itemsmo"><title>items</title>
<indexterm><primary>items method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>items method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-items-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the number of menu items contained in the associated menu.</para>
</section>

<section id="idofmo"><title>idOf</title>
<indexterm><primary>idOf method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>idOf method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-idOf--(--position--)----------------------------------------><
]]>
</programlisting>

<para>Returns the ID of the menu item at the specified
<emphasis role="italic">position</emphasis>, starting with 0.</para>
</section>

<section id="textofpositionmo"><title>textOf(position)</title>
<indexterm><primary>textOf(position) method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>textOf(position) method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-textOf--(--position--)--------------------------------------><
]]>
</programlisting>

<para>Returns the text of the menu item at the specified
<emphasis role="italic">position</emphasis>, starting
with 0. A mnemonic (underscored letter) is represented by a leading ampersand
(&amp;). If the menu item contains an accelerator, it is separated by a tab.
</para>
</section>

<section id="textofidmo"><title>textOf(id)</title>
<indexterm><primary>textOf(id) method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>textOf(id) method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-textOf--(--id--)--------------------------------------------><
]]>
</programlisting>

<para>Returns the text of menu item <emphasis role="italic">id</emphasis>.
A mnemonic is represented by a leading ampersand (&amp;). If the menu item
contains an accelerator, it is separated by a tab.</para>
</section>

<section id="submenumo"><title>submenu</title>
<indexterm><primary>submenu method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>submenu method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-submenu--(--position--)-------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the MenuObject class that is associated with the
submenu at the specified <emphasis role="italic">position</emphasis>,
starting with 0. If no submenu
exists at this position, the .Nil object is returned.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
sub = menu~submenu(5)
    if sub \= .Nil then do
         say "Items:" sub~items
    end
</programlisting>
</section>

<section id="findsubmenumo"><title>findSubmenu</title>
<indexterm><primary>findSubmenu method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>findSubmenu method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-findSubmenu--(--label--)------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the MenuObject class that is associated with the
submenu with the specified <emphasis role="italic">label</emphasis>.
If the associated menu does not
contain such a submenu, the .Nil object is returned.</para>
</section>

<section id="finditemmo"><title>findItem</title>
<indexterm><primary>findItem method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>findItem method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-findItem--(--label--)---------------------------------------><
]]>
</programlisting>

<para>Returns the ID of the menu item <emphasis role="italic">label</emphasis>.
If the specified label
does not include an accelerator, the comparison excludes the accelerators
of the menu items. If no menu item is found that matches the specified label,
0 is returned.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
f = menu~findItem("&amp;Tools" || "9"x || "Ctrl+T")
    if f \= 0 then menu~processItem(f)
</programlisting>
</section>

<section id="processitemmo"><title>processItem</title>
<indexterm><primary>processItem method</primary>
<secondary>of MenuObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>processItem method</secondary>
<tertiary>of MenuObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-processItem--(--id--)---------------------------------------><
]]>
</programlisting>

<para>Selects the menu item <emphasis role="italic">id</emphasis>. This causes
a WM_COMMAND to be sent to the window owning the menu.</para>
</section>
</section>

<section id="clsWinOLEObject"><title>The Windows OLEObject Class</title>
<indexterm><primary>OLEObject class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>OLEObject class</secondary></indexterm>
<para>This class provides support for OLE automation. OLE (Object Linking and
Embedding) is an implementation of COM (Component Object Model). OLE automation
makes it possible for one application to manipulate objects implemented in
another application, or to expose objects so they can be manipulated.</para>
<para>An automation client is an application that can manipulate exposed objects
belonging to another application. An automation server is an application that
exposes the objects. The OLEObject class enables Rexx to be an OLE automation
client. Note that the OLE acronym has now been replaced by ActiveX.</para>
<para>Applications can provide OLE objects, and OLE objects that support
automation can be used by a Rexx script to remotely control the object through
the supplied methods. This lets you write a Rexx script that, for example,
starts a Web browser, navigates to a certain page, and changes the display mode
of the browser.</para>
<para>Every application that supports OLE places a unique identifier in the
registry. This identifier is called the class ID (CLSID) of the OLE object. It
consists of several hexadecimal numbers separated by the minus symbol.</para>
<para><emphasis role="bold">Example:</emphasis> CLSID of
<trademark class="registered">Microsoft</trademark> Internet Explorer
(Version 5.00.2014.0216):</para>
<programlisting>
"{0002DF01-0000-0000-C000-000000000046}"
</programlisting>
<para>The CLSID number can prove inconvenient when you want to create or access
a certain object, so a corresponding easy-to-remember entry is provided in
the registry, and this entry is mapped to the CLSID. This entry is called
the ProgID (the program ID), and is a string containing words separated by
periods.</para>
<para><emphasis role="bold">Example:</emphasis> ProgID of Microsoft Internet
Explorer: <computeroutput>"InternetExplorer.Application"</computeroutput></para>
<para>To find the ProgID of an application, you can use the sample
script <computeroutput>OLEINFO.REX</computeroutput> or the Microsoft OLEViewer,
or you can consult
the documentation of the application or search the registry manually.</para>
<para>The OLEObject class is a built-in class.</para>
<para>Several sample programs are provided in the Object
Rexx installation directory under Samples\OLE.</para>
<itemizedlist>
<listitem><para>The APPS directory contains 13 examples of how to use Rexx to
remote-control other applications.</para></listitem>
<listitem><para>The OLEINFO directory is a sample Rexx application that can be
used to browse through the information an OLE object provides.</para></listitem>
<listitem><para>In the ADSI directory there are eight examples of how to use
the Active Directory Services Interface with the Rexx OLE interface.</para>
</listitem>
<listitem><para>The METHINFO directory contains a very basic example of how to
access the information an OLE object provides.</para></listitem>
<listitem><para>Finally, the WMI directory contains five examples of how to
work with the Windows Management Instrumentation.</para></listitem>
</itemizedlist>
<para><emphasis role="bold">Methods available to the OLEObject class:</emphasis>
</para>
<simplelist>
<member>dispatch</member>
<member>init</member>
<member>getConstant</member>
<member>getKnownEvents</member>
<member>getKnownMethods</member>
<member>getObject(Class method)</member>
<member>getOutParameters</member>
<member>unknown</member>
</simplelist>

<note><title>Note</title>
<para>The Rexx OLE object acts as a proxy to the
real OLE object. The OLE object has its own methods, depending on its individual
implementation; its methods are accessed transparently through the method
mechanism <link linkend="oleobunk">unknown</link>.</para></note>

<section id="oledispatch"><title>dispatch</title>
<indexterm><primary>dispatch method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>dispatch method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>

<programlisting>
<![CDATA[
>>-dispatch(methodname--+------------+--)----------------------><
                        |  +------+  |
                        |  V      |  |
                        +----,arg-+--+
]]>
</programlisting>

<para>
Dispatches a method with the optionally supplied arguments.
</para>
</section>

<section id="oleobjinit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
                    +-, "NOEVENTS"---+
>>-init(-+-ProgID-+-+----------------+-)-----------------------><
         +-CLSID--+ +-, "WITHEVENTS"-+
]]>
</programlisting>

<para>Instantiates an OLE object of the given ProgID or CLSID. If the creation
fails, an error will be raised (see list of
<link linkend="ERR92">OLE specific errors</link>.</para>
<para>The optional parameter "events" defines whether events are to be used or
not. Allowed values for events are <computeroutput>&apos;NOEVENTS&apos;</computeroutput>
(the default) and <computeroutput>&apos;WITHEVENTS&apos;</computeroutput>.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
myOLEObject = .OLEObject~new("InternetExplorer.Application")
</programlisting>
</section>

<section id="oleobgetcon"><title>getConstant</title>
<indexterm><primary>getConstant method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getConstant</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getConstant(-+--------------+-)-----------------------------><
                +-ConstantName-+
]]>
</programlisting>

<para>Retrieves the value of a constant that is associated with this
OLE object. If no constant of that name exists, the .Nil object will be returned.
You can also omit the name of the constant; this returns a stem with all known
constants and their values. In this case the constant names will be prefixed
with a "!" symbol.</para>
<para><emphasis role="bold">Example 1:</emphasis></para>
<programlisting>
myExcel = .OLEObject~new("Excel.Application")
say "xlCenter has the value" myExcel~getConstant("xlCenter")
myExcel~quit
exit
</programlisting>
<para>Possible output:</para>
<programlisting>
xlCenter has the value -4108
</programlisting>
<para><emphasis role="bold">Example 2:</emphasis></para>
<programlisting>
myExcel = .OLEObject~new("Excel.Application")
constants. = myExcel~getConstant
myExcel~quit

do i over constants.
  say i"="constants.i
end
</programlisting>
<para>Possible output:</para>
<programlisting>
!XLFORMULA=5
!XLMOVE=2
!XLTEXTMAC=19
...
</programlisting>
</section>

<section id="oleobgetknev"><title>getKnownEvents</title>
<indexterm><primary>getKnownEvents method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getKnownEvents method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getKnownEvents----------------------------------------------><
]]>
</programlisting>

<para>Returns a stem with information on the events that the OLE object can
create. It collects this information from the type library of the object. A
type library provides the names, types, and arguments of the provided methods.
</para>
<para>The stem provides the following information:</para>

<table frame="all">
<title>Stem Information</title>
<tgroup cols="2">
<tbody>
<row>
<entry>stem.0</entry>
<entry>The number of events.</entry>
</row>
<row>
<entry>stem.n.!NAME</entry>
<entry>Name of n-th event.</entry>
</row>
<row>
<entry>stem.n.!DOC</entry>
<entry>Description of n-th event (if available).</entry>
</row>
<row>
<entry>stem.n.!PARAMS.0</entry>
<entry>Number of parameters for n-th event.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!NAME</entry>
<entry>Name of i-th parameter of n-th event.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!TYPE</entry>
<entry>Type of i-th parameter of n-th event.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!FLAGS</entry>
<entry>Flags of i-th parameter of n-th event; can be "in",
"out", "opt", or any combination of these.</entry>
</row>
</tbody>
</tgroup>
</table>
<para>If no information is available, the .NIL object is returned and this OLE
object does not have any events.</para>
<para><emphasis role="bold">Example script:</emphasis></para>
<programlisting>
myIE = .OLEObject~new("InternetExplorer.Application","NOEVENTS")
events. = myIE~getKnownEvents

if events. == .nil then
  say "Sorry, this object does not have any events."
else do
  say "The following events may occur:"
  do i = 1 to events.0
    say events.i.!NAME
  end
end

exit
</programlisting>
<para><emphasis role="bold">Sample output:</emphasis></para>
<programlisting>
The following events may occur:
ONTHEATERMODE
ONFULLSCREEN
ONSTATUSBAR
...
</programlisting>
<para>For an example of how to use events, see examples OLE\APPS\SAMP12.REX
and OLE\APPS\SAMP13.REX in the SAMPLES directory.</para>
</section>

<section id="oleobgetknme"><title>getKnownMethods</title>
<indexterm><primary>getKnownMethods method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getKnownMethods method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getKnownMethods---------------------------------------------><
]]>
</programlisting>

<para>Returns a stem with information on the methods that the OLE object
supplies. It collects this information from the type library of the object. A
type library provides the names, types, and arguments of the provided methods.
Parts of the supplied information have only informational character as you
cannot use them directly.</para>
<para>The stem provides the following information:</para>

<table frame="all">
<title>Stem Information</title>
<tgroup cols="2">
<tbody>
<row>
<entry>stem.0</entry>
<entry>The number of methods.</entry>
</row>
<row>
<entry>stem.!LIBNAME</entry>
<entry>Name of the type library that describes this object.</entry>
</row>
<row>
<entry>stem.!LIBDOC</entry>
<entry>A help string describing the type library. Only set
when the string is available.</entry>
</row>
<row>
<entry>stem.!COCLASSNAME</entry>
<entry>COM class name of this object.</entry>
</row>
<row>
<entry>stem.!COCLASSDOC</entry>
<entry>A string describing the COM class. Only set
when the string is supplied by the type library.</entry>
</row>
<row>
<entry>stem.n.!NAME</entry>
<entry>The name of the n-th method.</entry>
</row>
<row>
<entry>stem.n.!DOC</entry>
<entry>A help string for the n-th method. If this information
is not supplied in the type library this value will not be set.</entry>
</row>
<row>
<entry>stem.n.!INVKIND</entry>
<entry>A number that represents the invocation kind of the
method: 1 = normal method call, 2 =
<computeroutput>property get</computeroutput>, 4 = <computeroutput>property
put</computeroutput>. A normal method call is used with brackets; for a
<computeroutput>property
get</computeroutput> only the name is to be specified; and a
<computeroutput>property set</computeroutput> uses
the "=" symbol, as in these examples:
<computeroutput>object~methodCall(a,b,c)</computeroutput>
<computeroutput>object~propertyPut="Hello"</computeroutput>
<computeroutput>say object~propertyGet</computeroutput></entry>
</row>
<row>
<entry>stem.n.!RETTYPE</entry>
<entry>The return type of the n-th method. The return type
will be automatically converted to a Rexx object (see
<link linkend="oleobtypconv">Type Conversion</link> in
the description of the UNKNOWN method of the OLEObject class).</entry>
</row>
<row>
<entry>stem.n.!MEMID</entry>
<entry>The MemberID of the n-th method. This is only used internally
to call the method.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.0</entry>
<entry>The number of parameters of the n-th method.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!NAME</entry>
<entry>The name of the i-th parameter of the n-th method.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!TYPE</entry>
<entry>The type of the i-th parameter of the n-th method.</entry>
</row>
<row>
<entry>stem.n.!PARAMS.i.!FLAGS</entry>
<entry>The flags of the i-th parameter of the n-th method;
can be "in", "out", "opt", or any combination of these (for example: "[in,
opt]").</entry>
</row>
</tbody>
</tgroup>
</table>
<para>If no information is available, the .NIL object is returned.</para>

<note><title>Note</title>
<para>An object might provide additional methods that cannot be
retrieved for display but that can be invoked. In these cases, consult the
documentation of those objects.</para></note>
<para>There are mechanisms to 'hide' methods from the user, because these methods
can only be used internally. It might happen that these are not hidden properly
and will get displayed. Be careful with methods like:</para>
<simplelist>
<member>AddRef</member>
<member>GetTypeInfoCount</member>
<member>GetTypeInfo</member>
<member>GetIDsOfNames</member>
<member>QueryInterface</member>
<member>Release</member>
</simplelist>
<para><emphasis role="bold">Example script:</emphasis></para>
<programlisting>
myOLEObject = .OLEObject~new("InternetExplorer.Application")
methods. = myOLEObject~getKnownMethods

if methods. == .nil then
  say "Sorry, no information on the methods available!"
else do
  say "The following methods are available to this OLE object:"
  do i = 1 to methods.0
    say methods.i.!NAME
  end
end

exit
</programlisting>
<para><emphasis role="bold">Sample output:</emphasis></para>
<programlisting>
The following methods are available to this OLE object:
GoBack
GoForward
GoHome
...
</programlisting>
</section>

<section id="oleobgetob"><title>getObject</title>
<indexterm><primary>getObject method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getObject method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getObject(Moniker-+--------+-)------------------------------><
                     +-,class-+
]]>
</programlisting>

<para>This is a class method that allows you to obtain an OLE object through
the use of a so-called moniker or nickname (a string). A moniker is used to
find out which object has to be created or, if it is already running, addressed.
The moniker itself tells OLE which type of object is required. The optional
parameter class can be used to specify a subclass of OLEObject, and can be
used to obtain an OLE object that supports events (the
<computeroutput>&apos;WITHEVENTS&apos;</computeroutput> option
will be used in this case).  This method is similar to the
<computeroutput>Init</computeroutput> method
where you have to specify a ProgID or CLSID.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
/* create a Word.Document by opening a certain file */
myOLEObject = .OLEObject~GetObject("C:\DOCS\HELLOWORLD.DOC")
</programlisting>
</section>

<section id="oleobgetoutpar"><title>getOutParameters</title>
<indexterm><primary>getOutParameters method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getOutParameters method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getOutParameters--------------------------------------------><
]]>
</programlisting>

<para>Returns an array containing the results of the single
<computeroutput>out</computeroutput> parameters
of the OLE object, or the .NIL object if it does not have any.
<computeroutput>Out</computeroutput> parameters
are arguments to the OLE object that are filled in by the OLE object. As this
is not possible in Rexx due to data encapsulation, the results are placed
in the array mentioned above.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<para>Consider an OLE object method with the following signature:</para>
<programlisting>
aMethod([in] A, [in] B, [out] sumAB)
</programlisting>
<para>The resulting <computeroutput>out</computeroutput> parameter of the
method invocation will be placed in the <computeroutput>out</computeroutput>
array at position one; the "normal" return
value gets processed as usual. In this case the method will return the .NIL
object:</para>
<programlisting>
resultTest = myOLEObject~aMethod(1, 2, .NIL)
say "Invocation result  :" resultTest
say "Result in out array:" myOLEObject~getOutParameters~at(1)
</programlisting>
<para>The output of this sample script will be:</para>
<programlisting>
The NIL object
3
</programlisting>
<para><computeroutput>Out</computeroutput> parameters are placed in the
<computeroutput>out</computeroutput> array in order
from left to right. If the above OLE method looked like this:</para>
<programlisting>
aMethod([in] A, [in] B, [out] sumAB, [out] productAB),
</programlisting>
<para>then the <computeroutput>out</computeroutput> array would contain the sum
of A and B at position one, and the product at position two.</para>
</section>

<section id="oleobunk"><title>unknown</title>
<indexterm><primary>unknown method</primary>
<secondary>of OLEObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>unknown method</secondary>
<tertiary>of OLEObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-unknown(messagename--+----------------+--)------------------><
                        +--,messageargs--+
]]>
</programlisting>

<para>The <computeroutput>unknown</computeroutput> message is the central
mechanism through which methods of the OLE object are called.</para>
<para>For further information, see
<link linkend="unkno">Defining an unknown Method</link>.</para>
<para>You can invoke the methods of the real OLE object by simply stating their
names to the Rexx (proxy) OLE object like this:</para>
<programlisting>
myOLEObject~OLEMethodName
</programlisting>
<para>This calls the method <computeroutput>"OLEMethodName"</computeroutput>
of the real OLE object
for any message that does not exist for the Rexx OLE object by dispatching
the call to the real OLE object.</para>
<para>If an OLE object offers a method with a name that is identical to one
that is defined for <computeroutput>OLEObject</computeroutput>, you must call
<computeroutput>unknown</computeroutput> directly, like this:</para>
<programlisting>
msgs = .array~of("Hello","World")
val = myOLEObject~unknown("Unknown",msgs)
</programlisting>
<para>This invokes the method <computeroutput>"unknown"</computeroutput>
of the OLE object with two arguments, <computeroutput>"Hello"</computeroutput>
and <computeroutput>"World"</computeroutput>.</para>
<para>Parameters for the OLE object are used in the usual way, with the
exception of so-called <computeroutput>"out"</computeroutput> parameters.
<computeroutput>Out</computeroutput> parameters will be
filled in by the OLE object itself. As this is not possible in Rexx due to
data encapsulation, a special method,
<link linkend="oleobgetoutpar">getOutParameters</link>,
has to be used. Specify the .Nil object for any
<computeroutput>Out</computeroutput> parameters
when invoking this method.</para>
</section>

<section id="oleobtypconv"><title>Type Conversion</title>
<indexterm><primary>Type conversion</primary></indexterm>
<para>Unlike Rexx, OLE uses strict typing of data. Conversion to and from these
types is done automatically, if conversion is possible. OLE types are called
variants, because they are stored in one structure that
gets flagged with the type it represents. The following is a list of all variant
types valid for use with OLE Automation and the Rexx objects that they are
converted from or into.</para>

<table frame="all">
<title>OLE/Rexx Types</title>
<tgroup cols="2">
<thead>
<row>
<entry>VARIANT type</entry>
<entry>Rexx object</entry>
</row>
</thead>
<tbody>
<row>
<entry>VT_EMPTY</entry>
<entry>.NIL</entry>
</row>
<row>
<entry>VT_NULL</entry>
<entry>.NIL</entry>
</row>
<row>
<entry>VT_ERROR</entry>
<entry>.NIL</entry>
</row>
<row>
<entry>VT_I1</entry>
<entry>Rexx string (a whole number)</entry>
</row>
<row>
<entry>VT_I2</entry>
<entry>Rexx string (a whole number)</entry>
</row>
<row>
<entry>VT_I4</entry>
<entry>Rexx string (a whole number)</entry>
</row>
<row>
<entry>VT_I8</entry>
<entry>Rexx string (a whole number)</entry>
</row>
<row>
<entry>VT_UI1</entry>
<entry>Rexx string (a whole, positive number)</entry>
</row>
<row>
<entry>VT_UI2</entry>
<entry>Rexx string (a whole, positive number)</entry>
</row>
<row>
<entry>VT_UI4</entry>
<entry>Rexx string (a whole, positive number)</entry>
</row>
<row>
<entry>VT_UI8</entry>
<entry>Rexx string (a whole, positive number)</entry>
</row>
<row>
<entry>VT_INT</entry>
<entry>Rexx string (a whole number)</entry>
</row>
<row>
<entry>VT_UINT</entry>
<entry>Rexx string (a whole, positive number)</entry>
</row>
<row>
<entry>VT_DECIMAL</entry>
<entry>Rexx string (a decimal number)</entry>
</row>
<row>
<entry>VT_R4</entry>
<entry>Rexx string (a real number)</entry>
</row>
<row>
<entry>VT_R8</entry>
<entry>Rexx string (a real number)</entry>
</row>
<row>
<entry>VT_CY</entry>
<entry>Rexx string (currency, a fixed-point number with 15 digits to
the left of the decimal point and 4 digits to the right)</entry>
</row>
<row>
<entry>VT_DATE</entry>
<entry>Rexx string (a date)</entry>
</row>
<row>
<entry>VT_BSTR</entry>
<entry>Rexx string</entry>
</row>
<row>
<entry>VT_DISPATCH Rexx</entry>
<entry>OLEObject</entry>
</row>
<row>
<entry>VT_BOOL</entry>
<entry>.TRUE or .FALSE</entry>
</row>
<row>
<entry>VT_VARIANT</entry>
<entry>Any Rexx object that can be represented as a VARIANT</entry>
</row>
<row>
<entry>VT_UNKNOWN</entry>
<entry>OLEObject</entry>
</row>
<row>
<entry>VT_ARRAY *</entry>
<entry>Rexx Array</entry>
</row>
<row>
<entry>VT_BYREF *</entry>
<entry>Any Rexx object</entry>
</row>
</tbody>
</tgroup>
</table>
<para>* VT_ARRY and VT_BYREF are combined with any of the other variant types
and never used alone. VT_ARRAY and another variant type are used for a SAFEARRAY
datatype, an array of the other variant type.  VT_BYREF and another variant type
are used to pass the other variant type to or from an OLE object by reference.
The programmer need not worry about this passing by reference, the OLE support
handles this transparently.</para>
</section>
</section>

<section id="clsWinOLEVariant"><title>The Windows OLEVariant Class</title>
<indexterm><primary>OLEVariant Class</primary></indexterm>

<para>
The OLEVariant class enhances the support for OLE Automation provided by the
<link linkend="clsWinOLEObject">OLEObject class</link> and is used in conjunction with
that class.  An OLEVariant object is used as a parameter in a method call of
an OLEObject object.  In the OLEObject's role as a proxy for a OLE / COM
object, the parameters in method calls are forwarded on to the actual OLE /
COM object.  (OLE / COM objects will be referred to simply as COM objects.)
</para>
<para>
There are two areas where the OLEVariant adds to the capabilities of
OLEObject method calls.</para>
<itemizedlist>
<listitem><para>Parameters forwarded on to COM objects must be converted to and from
the proper datatypes.  This conversion is done automatically (see
<link linkend="oleobtypconv">OLEObject Type Conversion</link>.)
Occasionally this automatic conversion is
incorrect.  The OLEVariant allows the ooRexx programmer to override the
automatic conversion by specifying how the conversion should be done.
</para></listitem>
<listitem><para>COM objects can return data to the caller in "out" parameters ([OUT]
parameters.)  The OLEVariant can be used to transport this returned data
back to the calling ooRexx program.
</para></listitem>
</itemizedlist>
<para>
In general, the automatic type conversion in the OLE support uses type
libraries to determine how to format the parameters being sent to an OLE
object in a method call.  The information in a type library specifies the
variant type an ooRexx object, used as a parameter, needs to be converted
to.  Type libraries also detail how a parameter is to be flagged when it is
sent to the COM object.
</para>
<para>
However, COM objects are not required to supply type libraries.  When there
is no type library, ooRexx uses an educated guess to determine this
information.  On rare occasions this guess is wrong and the method call
fails.  In theses cases, if the ooRexx programmer knows what the correct
information is, the programmer can use an OLEVariant to specify this
information.  The programmer can supply either or both of these pieces of
information by specifying the variant type for the converted ooRexx object
and the parameter flags.
</para>
<para>
The following is a real world example where the automatic conversion in the
OLE support does not work and shows how the OLEVariant is used to specify
the correct conversion.  The snippet comes from code to automate a CICS
client.  In this case the variant type that the ooRexx object needs to be
converted to is specified.  The parameter flags are omitted.  The fourth
parameter to the ~link method call is the parameter where the default
conversion was failing.
</para>
<programlisting>
  connect  = .OLEObject~new("Ccl.Connect")
  flow     = .OLEObject~new("Ccl.Flow")
  buffer   = .OLEObject~new("Ccl.Buffer")

  uow      = .OLEVariant~New(.nil, VT_DISPATCH)
  ...
  connect~link(flow, "FOO", buffer, uow)
</programlisting>
<note><para>
It is extremely rare that the OLE support fails to do the right thing
with its automatic conversion.  99.999% of the time the ooRexx programmer
does not need to use an OLEVariant object to specify the type conversion.
This use of the OLEVariant is provided for those few times when it is
necessary to override the default conversion.  Furthermore, if the ooRexx
programmer does not know what variant type to specify, this usage will not
be much help.  Normally the ooRexx programmer would know what type to
specify through the documentation for the COM class the programmer is using.
</para></note>
<para>
The next example shows how the OLEVariant can be used to transport the data
returned in an "out" parameter back to the calling ooRexx program.  This
usage will be more common and does not require that the ooRexx have a lot of
detailed knowledge of the COM object.  Obviously, the programmer does need
to know that the parameter is an out parameter.  This example comes from
updating a MS Access database where the number of records affected by the
update is returned in an "out" parameter.  Here the out parameter is the
second parameter in the ~execute method call.
</para>
<programlisting>
  sql = "update myTable set id=id*3 where id > 7"
  param = .OLEVariant~new(0)
  conn~execute(sql, param)
  count = param~!varValue_
  say count "record(s) were affected."
</programlisting>
<para>
Finally an example where the OLE support does not use the correct parameter
flags for the method call.  The Windows Management Instrumentation,
Win32_Process COM class does not supply a type library.  The fourth
parameter in the ~create method call is an "out" parameter.  That
information is known by the ooRexx programmer through the documentation of
the class.  However, without a type library, ooRexx has no way to know that.
Here the variant type specification is omitted (signaling ooRexx to go
ahead and use its automatic conversion) and the parameter flags are
specified.  Since this an out parameter, the OLEVariant object is also used
to transport the returned data back to the calling program.
</para>
<programlisting>
  objProcess = .oleObject~getObject("WinMgmts:Win32_Process")

  param = .OLEVariant~new( 0, , "IN,OUT" )
  ret = objProcess~create('notepad.exe', .nil, .nil, param)
  if ret == 0 then do
    pid = param~!varValue_
    say 'The notepad process was created and its PID is' pid
  end
</programlisting>
<para>
<emphasis role="bold">Methods available to the OLEVariant class</emphasis>
</para>
<simplelist>
<member>new</member>
<member>!varValue_</member>
<member>!varValue_=</member>
<member>!varType_</member>
<member>!varType_=</member>
<member>!paramFlags_</member>
<member>!paramFlags_=</member>
</simplelist>
<note><para>
A possible future enhancement of the OLEVariant class requires that
its method names be unique, which is the reason for the method name style.
In normal usage the ooRexx programmer would only be concerned with the new
and the !varValue methods.  Therefore the slightly unorthodox method names
should not present a problem.
</para></note>

<section id="olevarnew"><title>new Class method</title>
<programlisting>
<![CDATA[
>>-new(valueObject-+----------+--+-------------+-)-------------><
                   +-,varType-+  +-,paramFlags-+
]]>
</programlisting>
<para>
Instantiates a new OLEVariant object to be used as a parameter in an
OLEObject method call.  The first argument is the ooRexx object to be
converted to a variant type for the method call.  It is the object to be
used in the method call.  This argument is required.  The varType and
paramFlags arguments are optional.
</para>
<para>
The varType argument is used to specify the type of the variant that the
valueObject is to be converted to.  If this argument is omitted or is .nil
then ooRexx will use the default conversion for the valueObject.  If it is
not omitted it must be a valid OLE Automation variant type and ooRexx will
attempt to convert the valueObject to this variant type.
</para>
<para>
The valid variant type symbols are listed in Table
<link linkend="oleobtypconv">OLE/Rexx Types</link>.
In addition any of those symbols can be combined with the
VT_BYREF or the VT_ARRAY symbol.  When symbols are combined a comma is used
to separate the two symbols.  This of course necessitates that the argument
be quoted.  Case does not matter for this argument.  For example vt_bool,
VT_bool, or VT_BOOL are all treated the same.
</para>
<para>
The paramFlags argument is used to specify the flags for the parameter.  The
flags are separated by a comma.  Although any combination of valid
PARAMFLAGS as defined for OLE Automation will be accepted, in practice the
ooRexx programmer will probably only need to use "IN,OUT" for this argument.
</para>
<para>
The PARAMFLAGS defined for OLE Automation:
</para>
<simplelist>
<member>PARAMFLAG_NONE</member>
<member>PARAMFLAG_FIN</member>
<member>PARAMFLAG_FOUT</member>
<member>PARAMFLAG_FLCID</member>
<member>PARAMFLAG_FRETVAL</member>
<member>PARAMFLAG_FOPT</member>
<member>PARAMFLAG_FHASDEFAULT</member>
<member>PARAMFLAG_FHASCUSTDATA</member>
</simplelist>
<para>
The ooRexx programmer should only use the last portion of the symbol.  I.e.,
NONE, IN, OUT, LCID, RETVAL, OPT, HASDEFAULT, or HASCUSTOMDATA.  Case also
does not matter for this argument and "in,out" is equivalent to "IN,OUT"
</para>
<para>
If the paramFlags argument is omitted or .nil, (the normal case,) ooRexx
will determine the flags for the parameter through its default mechanism.
If the argument is not omitted, ooRexx will use the specified flags
unconditionally.
</para>
<note><para>
If either the varType or paramFlags arguments are used, and not the
.nil object, they must be valid variant types or param flags for OLE
Automation.  If they are not valid, a syntax error will be raised.
</para></note>
<programlisting>
manager = .oleObject~new("com.sun.star.ServiceManager", "WITHEVENTS")
cf = manager~createInstance("com.sun.star.reflection.CoreReflection")
...
classSize = .cf~forName("com.sun.star.awt.Size")

param = .OLEVariant~new(.nil, "VT_DISPATCH,VT_BYREF", "IN,OUT")

retVal = classSize~createObject(param)
</programlisting>
</section>

<section><title>!VARVALUE_</title>

<programlisting>
<![CDATA[
>>-!VARVALUE_--------------------------------------------------><
]]>
</programlisting>
<para>
Returns the value object set within an instance of an OLEVariant.  If the
parameter in a COM method call that the OLEVariant was used for is an "out"
parameter, than the value object of the instance will be the data returned
by the COM object.  Otherwise, the value object is that set by the ooRexx
programmer.
</para>
<programlisting>
manager = .oleObject~new("com.sun.star.ServiceManager", "WITHEVENTS")
cf = manager~createInstance("com.sun.star.reflection.CoreReflection")
...
classSize = .cf~forName("com.sun.star.awt.Size")

param = .OLEVariant~new(.nil, "VT_DISPATCH,VT_BYREF", "IN,OUT")

retVal = classSize~createObject(param)
size = param~!varValue_
</programlisting>
</section>

<section><title>!VARVALUE_=</title>

<programlisting>
<![CDATA[
>>-!VARVALUE_=-------------------------------------------------><
]]>
</programlisting>
<para>
Sets the value object an instance of an OLEVariant contains.
</para>
</section>

<section><title>!VARTYPE_</title>

<programlisting>
<![CDATA[
>>-!VARTYPE_---------------------------------------------------><
]]>
</programlisting>
<para>
Returns the variant type specification of the OLEVariant instance.
</para>
</section>

<section><title>!VARTYPE_=</title>

<programlisting>
<![CDATA[
>>-!VARTYPE_=--------------------------------------------------><
]]>
</programlisting>
<para>
Sets the variant type specification of an OLEVariant instance.  This serves
the same purpose as the second argument to the
<link linkend="olevarnew">new method</link>
and follows the same rules as specified in the documentation of the
new method.  I.e., the value must be a valid variant type used in OLE
Automation, or .nil.  If not a syntax error is raised.
</para>
</section>

<section><title>!PARAMFLAGS_</title>

<programlisting>
<![CDATA[
>>-!PARAMFLAGS_------------------------------------------------><
]]>
</programlisting>
<para>
Returns the parameter flags specification of the OLEVariant instance.
</para>
</section>

<section><title>!PARAMFLAGS_=</title>

<programlisting>
<![CDATA[
>>-!PARAMFLAGS_=-----------------------------------------------><
]]>
</programlisting>
<para>
Sets the flags specification of an OLEVariant instance.  This serves the
same purpose as the third argument to the
<link linkend="olevarnew">new method</link>
and follows the same rules as specified in the documentation of the new
method.  I.e., the value must be a valid combination of PARAMFLAG types as
documented for use in OLE Automation, or .nil.  If not a syntax error is
raised.
</para>
</section>
</section>

<section id="clsWinClipboard"><title>The WindowsClipboard Class</title>
<indexterm><primary>WindowsClipboard class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsClipboard class</secondary></indexterm>
<para>The WindowsClipboard class provides methods to access the data in the
Windows clipboard.</para>
<para>The WindowsClipboard class is not a built-in class. It is defined
in the WINSYSTM.CLS file. This means, you must use a
::requires statement to activate its functionality, as follows:</para>
<programlisting>
<![CDATA[
::requires "WINSYSTM.CLS"
]]>
</programlisting>
<para><emphasis role="bold">Methods the WindowsClipboard Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>copy</para></listitem>
<listitem><para>makeArray</para></listitem>
<listitem><para>paste</para></listitem>
<listitem><para>empty</para></listitem>
<listitem><para>isDataAvailable</para></listitem></itemizedlist>

<section id="copywc"><title>copy</title>
<indexterm><primary>copy method</primary>
<secondary>of WindowsClipboard class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>copy method</secondary>
<tertiary>of WindowsClipboard class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-copy--(--text--)--------------------------------------------><
]]>
</programlisting>

<para>Empties the clipboard and copies the specified text to it.</para>
</section>

<section id="mkarwc"><title>makeArray</title>
<indexterm><primary>makeArray method</primary>
<secondary>of WindowsClipboard class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>makeArray method</secondary>
<tertiary>of WindowsClipboard class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-makeArray---------------------------------------------------><
]]>
</programlisting>

<para>If the content of the clipboard is a string with newline characters
in it, makeArray can be used to split up the string into individual
lines. An array is returned containing those lines.</para>
</section>

<section id="pastewc"><title>paste</title>
<indexterm><primary>paste method</primary>
<secondary>of WindowsClipboard class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>paste method</secondary>
<tertiary>of WindowsClipboard class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-paste-------------------------------------------------------><
]]>
</programlisting>

<para>Retrieves the text data stored on the clipboard.</para>
</section>

<section id="emptywc"><title>empty</title>
<indexterm><primary>empty method</primary>
<secondary>of WindowsClipboard class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>empty method</secondary>
<tertiary>of WindowsClipboard class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-empty-------------------------------------------------------><
]]>
</programlisting>

<para>Empties the clipboard.</para>
</section>

<section id="isdataavailablewc"><title>isDataAvailable</title>
<indexterm><primary>isDataAvailable method</primary>
<secondary>of WindowsClipboard class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isDataAvailable method</secondary>
<tertiary>of WindowsClipboard class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isDataAvailable---------------------------------------------><
]]>
</programlisting>

<para>Returns 1 if the text data is available on the clipboard. If no data is
available, 0 is returned.</para>
</section>
</section>

<section id="clsWinEventLog"><title>The WindowsEventLog Class</title>
<indexterm><primary>WindowsEventLog class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsEventLog class</secondary></indexterm>
<para>Object Rexx provides a class for interaction with the Windows NT event
log. You can use this class to read, write, and clear event-log
records. This class is specifically for Windows NT systems and might not be
available on other systems.</para>
<para>The WindowsEventLog class is not a built-in class; it is defined in the
file <computeroutput>WINSYSTM.CLS</computeroutput>. Use a
<computeroutput>::requires</computeroutput> statement to activate
its function: </para>
<programlisting>
::requires "winsystm.cls"
</programlisting>
<para>A sample program <computeroutput>EventLog.REX</computeroutput>
is provided in the <computeroutput>ooRexx\SAMPLES</computeroutput> directory.
</para>
<para><emphasis role="bold">Methods the WindowsEventLog Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>init</para></listitem>
<listitem><para>open</para></listitem>
<listitem><para>close</para></listitem>
<listitem><para>read</para></listitem>
<listitem><para>write</para></listitem>
<listitem><para>clear</para></listitem>
<listitem><para>getNumber</para></listitem></itemizedlist>

<section id="initwel"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-init--------------------------------------------------------><
]]>
</programlisting>

<para>Creates an instance of the WindowsEventLog class and loads the required
function package.</para>
</section>

<section id="openwel"><title>open</title>
<indexterm><primary>open method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>open method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-open-+---------------------------------+--------------------><
        +-(--+-----------------------+--)-+
             +-server--+-----------+-+
                       +-,--source-+
]]>
</programlisting>

<para>Opens the specified event log.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>server</term>
<listitem><para>The UNC (universal naming convention) name of the server on which
the event log is to be opened. If this argument is not specified, the log is
opened at the local machine.
</para></listitem></varlistentry>
<varlistentry><term>source</term>
<listitem><para>The name of the source of the event log. It must be a subkey of
a log file entry under the EventLog key in the registry. If, for example, the
registry looks as follows:
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
      EventLog
        Application
          WinApp1
        Security
          WinApp2
        System
</programlisting>
&quot;Application&quot;, &quot;Security&quot;, &quot;System&quot;,
&quot;WinApp1&quot;, and &quot;WinApp2&quot; are valid sources.
If the source is not found, the &quot;Application
Log&quot; is used.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example opens the Application log on the local
machine:</para>
<programlisting>
rc = event_log1~open
rc = event_log~open(,"Application")
</programlisting>
<para>The following example
opens the System log on SERVER01:</para>
<programlisting>
rc = event_log~open("\\SERVER01","System")
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>

<section id="closewel"><title>close</title>
<indexterm><primary>close method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>close method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-close-------------------------------------------------------><
]]>
</programlisting>

<para>Closes an open event log.</para>
</section>

<section id="readwel"><title>read</title>
<indexterm><primary>read method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>read method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-read--+---------------------------------------------------+-->
         |    +-FORWARDS--+                                  |
         +-(--+-----------+--,--+--------+--,--+--------+--,-+
              +-BACKWARDS-+     +-server-+     +-source-+

>--+--------------------------+--------------------------------><
   +-+-------+--,--+-----+--)-+
     +-start-+     +-num-+
]]>
</programlisting>

<para>Reads event log records. If the event log was not opened with the OPEN
method, the event log specified by the <emphasis role="italic">server</emphasis>
and <emphasis role="italic">source</emphasis> is
opened and closed after processing.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>server</term>
<listitem><para>The UNC (universal naming convention) name of the server on which
the event log is to be opened. If this argument is not specified, the log is
opened at the local machine.</para>
<para>This argument is only used if the event log was not
opened before.</para>
</listitem></varlistentry>
<varlistentry><term>source</term>
<listitem><para>The name of the source of the event log. It must be a subkey of
a log file entry under the EventLog key in the registry. If, for example, the
registry looks as follows:
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
      EventLog
        Application
          WinApp1
        Security
          WinApp2
        System
</programlisting>
&quot;Application&quot;, &quot;Security&quot;, &quot;System&quot;,
&quot;WinApp1&quot;, and &quot;WinApp2&quot; are valid sources. If the source is
not found, the &quot;Application Log&quot; is used.</para>
<para>This argument is only used if the event log was not opened
before.</para>
</listitem></varlistentry>
<varlistentry><term>start</term>
<listitem><para>The record number of the event log record to be started.
The oldest record is always the first record regardless of the direction
specified.
</para></listitem></varlistentry>
<varlistentry><term>num</term>
<listitem><para>The number of the event log record to be read.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>
<programlisting>
evl = .WindowsEventLog~new

if evl~InitCode \= 0 then exit

say " reading complete System log forwards without opening it before "

events = evl~read("FORWARDS", ,"System")

if events \= .nil then
  call DisplayRecords
else
  say "==> Error reading complete System event log"

evl~deinstall

exit 0   /* leave program */

DisplayRecords:

say evl~Events~items "records read"

do i=1 to evl~Events~items
  say "============================================================="
  temp = evl~Events[i]
  parse var temp type date time "&apos;" sourcename"&apos;" id,
  userid computer "&apos;" string "&apos;" "&apos;" data "&apos;"
  say "Type	: "type
  say "Date	: "date
  say "Time	: "time
  say "Source	: "sourcename
  say "ID	: "id
  say "UserId	: "userid
  say "Computer : "computer
  say "Detail	: "string
  say "Data 	: "data
end
return

::requires "winsystm.cls"
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="writewel"><title>write</title>
<indexterm><primary>write method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>write method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-write--+-------------------------------------------------------------+-->
          |                                  +-1--+     +-0--------+    |
          +-(--+--------+--,--+--------+--,--+----+--,--+----------+--,-+
               +-server-+     +-source-+     +-0--+     +-category-+
                                             +-2--+
                                             +-4--+
                                             +-8--+
                                             +-10-+

>--+---------------------------------------+-------------------><
   | +-0--.                                |
   +-+----+--,--+------+--,--+--------+--)-+
     +-id-+     +-data-+     +-string-+
]]>
</programlisting>

<para>Reads event log records. If the event log was not opened with the Open
method, the event log specified by the <emphasis role="italic">server</emphasis>
and <emphasis role="italic">source</emphasis> is
opened and closed after processing.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>server</term>
<listitem><para>The UNC (universal naming convention) name of the server on
which the event log is to be opened. If this argument is not specified, the
log is opened at the local machine.
</para></listitem></varlistentry>
<varlistentry><term>source</term>
<listitem><para>The name of the source of the event log. It must be a subkey of
a log file entry under the EventLog key in the registry. If, for example, the
registry looks as follows:
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
      EventLog
        Application
          WinApp1
        Security
          WinApp2
        System
</programlisting>
&quot;Application&quot;, &quot;Security&quot;, &quot;System&quot;,
&quot;WinApp1&quot;, and &quot;WinApp2&quot; are valid sources. If the source
is not found, the &quot;Application Log&quot; is used.
</para></listitem></varlistentry>
<varlistentry><term>type</term>
<listitem><para>The type of the events to be logged. It can be one of the
numbers listed in the syntax diagram:
<variablelist>
<varlistentry><term>0</term>
<listitem><para>SUCCESS
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>ERROR, which is the default
</para></listitem></varlistentry>
<varlistentry><term>2</term>
<listitem><para>WARNING
</para></listitem></varlistentry>
<varlistentry><term>4</term>
<listitem><para>INFORMATION
</para></listitem></varlistentry>
<varlistentry><term>8</term>
<listitem><para>AUDIT SUCCESS
</para></listitem></varlistentry>
<varlistentry><term>10</term>
<listitem><para>AUDIT FAILURE
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>category</term>
<listitem><para>The event category. This is source-specific information that
can have any value. The default is 0.
</para></listitem></varlistentry>
<varlistentry><term>id</term>
<listitem><para>The event identifier specifying the message that, together with
the event, is an entry in the message file associated with the event source.
The default is 0.
</para></listitem></varlistentry>
<varlistentry><term>data</term>
<listitem><para>The binary data. This is source-specific information and can
be omitted.
</para></listitem></varlistentry>
<varlistentry><term>string</term>
<listitem><para>The strings merged into the message.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example writes the strings and the data to the
system log. &quot;MyApplication&quot; must be a subkey of a log file entry
under the EventLog key in the registry. If the source name cannot be found,
event logging uses the Application log file.</para>
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
        EventLog
        Application
        Security
          System
            MyApplication
	    </programlisting>
<programlisting>
evl~Write(,"MyApplication", , , ,"1A 1B 1C 0000 00"x, ,
"First String", "Second String")
</programlisting>
<para>See the <computeroutput>EventLog.REX</computeroutput> for
more examples.</para>
</listitem></varlistentry>
</variablelist>
</section>

<section id="clearwel"><title>clear</title>
<indexterm><primary>clear method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>clear method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-clear-+------------------------------------------------------------+-><
         +-(--+--------------------------------------------------+--)-+
              +-server--+--------------------------------------+-+
                        +-,--+--------+--+-------------------+-+
                             +-source-+  +-,--backupFileName-+
]]>
</programlisting>

<para>Clears the specified event log and, optionally, saves a copy of the
current log file as a backup file. If the event log was not opened with the
Open method, the event log specified by the
<emphasis role="italic">server</emphasis> and
<emphasis role="italic">source</emphasis> is opened.
The event log is closed after it is cleared.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>server</term>
<listitem><para>The UNC (universal naming convention) name of the server on
which the event log is to be opened. If this argument is not specified, the
log is opened at the local machine.</para>
<para>This argument is only used if the event log was not
opened before.</para>
</listitem></varlistentry>
<varlistentry><term>source</term>
<listitem><para>The name of the source of the event log. It must be a subkey
of a log file entry under the EventLog key in the registry. If, for example,
the registry looks as follows:
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
      EventLog
        Application
          WinApp1
        Security
          WinApp2
        System
</programlisting>
&quot;Application&quot;, &quot;Security&quot;, &quot;System&quot;,
&quot;WinApp1&quot;, and &quot;WinApp2&quot; are valid sources. If the source
is not found, the &quot;Application Log&quot; is used.</para>
<para>This argument is only used if the event log was not opened
before.</para>
</listitem></varlistentry>
<varlistentry><term>backupFileName</term>
<listitem><para>The name of a file to which the copy of the current event log
file is to be written. If this file already exists, the function fails.
The file can reside on a remote server. </para>
<para>If you omit this argument, the current event
log file is not backed up but cleared.</para>
</listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example creates a backup of the Application event log
of the local machine and clears it:</para>
<programlisting>
event_log~CLEAR(, ,"e:\evlbackup\application.evt")
</programlisting>
<para>The following example creates a backup of the System event log on
the server \\SERVER01 and clears it:</para>
<programlisting>
event_log~CLEAR("\\SERVER01","System","e:\evlbackup\system_server01.evt")
</programlisting>
<para>The following example clears the Application log on the local
machine without a backup:</para>
<programlisting>
event_log~CLEAR
</programlisting>
</listitem></varlistentry>
</variablelist>
</section>

<section id="getnumberwel"><title>getNumber</title>
<indexterm><primary>getNumber method</primary>
<secondary>of WindowsEventLog class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getNumber method</secondary>
<tertiary>of WindowsEventLog class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getNumber-+---------------------------------+---------------><
             +-(--+-----------------------+--)-+
                  +-server--+-----------+-+
                            +-,--source-+
]]>
</programlisting>

<para>Retrieves the number of records in the specified event log. If the event
log was not opened with the Open method, the event log specified by the
<emphasis role="italic">server</emphasis> and
<emphasis role="italic">source</emphasis> is opened and closed after processing.
</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>server</term>
<listitem><para>The UNC (universal naming convention) name of the server on
which the event log is to be opened. If this argument is not specified, the log
is opened at the local machine.</para>
<para>This argument is only used if the event log was not
opened before.</para>
</listitem></varlistentry>
<varlistentry><term>source</term>
<listitem><para>The name of the source of the event log. It must be a subkey of
a log file entry under the EventLog key in the registry. If, for example, the
registry looks as follows:
<programlisting>
HKEY_LOCAL_MACHINE
  System
    CurrentControlSet
      Services
      EventLog
        Application
          WinApp1
        Security
          WinApp2
        System
</programlisting>
&quot;Application&quot;, &quot;Security&quot;, &quot;System&quot;,
&quot;WinApp1&quot;, and &quot;WinApp2&quot; are valid sources. If the source
is not found, the &quot;Application Log&quot; is used.</para>
<para>This argument is only used if the event log was not opened
before.</para>
</listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="bold">Example:</emphasis></term>
<listitem><para>The following example returns the number of event log records
in the Application log of the local machine:
<programlisting>
num = event_log~getNumber
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>
</section>

<section id="clsWinManager"><title>The WindowsManager Class</title>
<indexterm><primary>WindowsManager class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsManager class</secondary></indexterm>
<para>The WindowsManager class provides methods to query, manipulate, and
interact with windows on your desktop. This class is specifically for
Windows NT and Windows 2000 systems and might not be available on
other systems.</para>
<para>The WindowsManager class is not a built-in class; it is defined in the
file <computeroutput>WINSYSTM.CLS</computeroutput>. Use a
<computeroutput>::requires</computeroutput> statement to activate
its function: </para>
<programlisting>
::requires "winsystm.cls"
</programlisting>
<para><emphasis role="bold">Methods the WindowsManager Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>find</para></listitem>
<listitem><para>foregroundWindow</para></listitem>
<listitem><para>windowAtPosition</para></listitem>
<listitem><para>consoleTitle</para></listitem>
<listitem><para>consoleTitle=</para></listitem>
<listitem><para>sendTextToWindow</para></listitem>
<listitem><para>pushButtonInWindow</para></listitem>
<listitem><para>processWindowCommand</para></listitem>
<listitem><para>broadcastSettingChanged</para></listitem></itemizedlist>

<section id="findwm"><title>find</title>
<indexterm><primary>find method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>find method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-find--(--title--)-------------------------------------------><
]]>
</programlisting>

<para>Searches for a top-level window (not a child window) on your desktop with
the specified <emphasis role="italic">title</emphasis>.</para>
<para>If this window already exists, an instance of the WindowObject class is
returned. Otherwise, .Nil is returned.</para>
</section>

<section id="foregroundwindowwm"><title>foregroundWindow</title>
<indexterm><primary>foregroundWindow method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>foregroundWindow method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-foregroundWindow--------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class that is associated with the
current foreground window.</para>
</section>

<section id="windowatpositionwm"><title>windowAtPosition</title>
<indexterm><primary>windowAtPosition method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>windowAtPosition method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-windowAtPosition--(--x--,--y--)-----------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class that is associated with the
window at the specified position (<emphasis role="italic">x,y</emphasis>). The
coordinates are specified
in screen pixels. This method does not retrieve hidden or disabled windows.
If you are interested in a particular child window, use method
<link linkend="childatpositionwo">childAtPosition</link>.</para>
</section>

<section id="consoletitlewm"><title>consoleTitle</title>
<indexterm><primary>consoleTitle method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>consoleTitle method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-consoleTitle------------------------------------------------><
]]>
</programlisting>

<para>Returns the title of the current console.</para>
</section>

<section id="consoletitlenewwm"><title>consoleTitle=</title>
<indexterm><primary>consoleTitle= method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>consoleTitle= method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-consoleTitle=title------------------------------------------><
]]>
</programlisting>

<para>Sets the title of the current console.</para>
</section>

<section id="sendtexttowindowwm"><title>sendTextToWindow</title>
<indexterm><primary>sendTextToWindow method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendTextToWindow method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendTextToWindow--(--title--,--text--)----------------------><
]]>
</programlisting>

<para>Sends a case-sensitive <emphasis role="italic">text</emphasis> to the
window with the specified <emphasis role="italic">title.</emphasis>.</para>
</section>

<section id="pushbuttoninwindowwm"><title>pushButtonInWindow</title>
<indexterm><primary>pushButtonInWindow method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>pushButtonInWindow method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-pushButtonInWindow--(--title--,--text--)--------------------><
]]>
</programlisting>

<para>Selects the button with label <emphasis role="italic">text</emphasis>
in the window with the specified <emphasis role="italic">title</emphasis>.
If the button's label contains a mnemonic (underscored letter),
you must specify an ampersand (&amp;) in front of it. You can also use this
method to select radio buttons and to check or uncheck check boxes.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
winmgr~pushButtonInWindow("Testwindow","List &amp;Employees")
</programlisting>
</section>

<section id="processmenucommandwm"><title>processMenuCommand</title>
<indexterm><primary>processMenuCommand method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>processMenuCommand method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-processMenuCommand--(--+-------+--,--+-------+--,------------>
                          +-title-+     +-popup-+

   +-,-------+
   V         |
>----submenu-+--,--menuItem--)---------------------------------><
]]>
</programlisting>

<para>Selects an item of the menu or submenu of the specified window
<emphasis role="italic">title</emphasis>. You can specify as many submenus as
necessary to get to the required item.</para>
</section>

<section id="broadcastsettingchanged"><title>broadcastSettingChanged</title>
<indexterm><primary>broadcastSettingChanged method</primary>
<secondary>of WindowsManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>broadcastSettingChanged method</secondary>
<tertiary>of WindowsManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-broadcastSettingChanged--+-----------+----------------------><
                            +-(timeOut)-+
]]>
</programlisting>

<para>Causes the Windows operating system to send a message, (the
WM_SETTINGCHANGE message,) to every top-level window on the Desktop informing
them that a system-wide setting has changed.  Well-written applications will
then reload any system settings that they use.</para>
<para>An example of one use for this might be an installer program setting an
environment variable, such as the PATH.  Then a call to broadcastSettingChanged
would cause all open applications to update their reference to the environment,
without the necessity of a reboot.</para>
<para>There are two variations of calling this method.  When called with no
arguments, the message is broadcast and returns immediately.  When called with
the time out parameter, the message is broadcast and does not return until
every window on the Desktop has acknowledged the message, or timed out.</para>
<para>The problem with using a time out and waiting for acknowledgment is that,
if a window is not responding, or several windows are slow to respond, it
may take a very long time to return.  The problem with not using a time out
and returning immediately is that the caller will have no way of knowing when
every window has received the message.  Generally this is not a problem, but
it is up to the programmer to decide how she wants to use this method.</para>
<para>The time out value is specified in milliseconds.  For each window, the
operating system will wait up to the time out for a response before going
on to the next window.  Typically a time out value of 5000 (5 seconds) is
used, and this is the default.</para>
<para>The single optional argument is:</para>
<variablelist>
<varlistentry><term><emphasis role="italic">timeOut</emphasis></term>
<listitem><para>The time, in milliseconds, to wait for each window to
acknowledge it received the setting changed message. Specifying 0 or a negative
number will cause the default time out of 5000 to be used.  (5000 is a typical
value used by applications.)
</para></listitem></varlistentry>
</variablelist>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The setting changed message was broadcast successfully.  If no
time out argument was used, then this is all it means.  If a time out value was
used, then all top-level windows have acknowledged receiving the message.
</para></listitem></varlistentry>
<varlistentry><term>-1</term>
<listitem><para>The setting changed message was broadcast, but one or more
windows timed out.  This return can only happen when the time out parameter
is used.
</para></listitem></varlistentry>
<varlistentry><term>-x</term>
<listitem><para>A number less than -1 indicates a system error occurred.
This value is the negation of the system error code.  I.e., if the return is
-1400, the system error code was 1400.  System error codes can be looked up in
the MSDN library or the Windows Platform SDK.  Microsoft makes these references
available on the Internet.
</para></listitem></varlistentry>
<varlistentry><term>+x</term>
<listitem><para>A number greater than 0 would be a window result of broadcasting
the setting changed message and would not be an error.  It is unlikely that this
would occur.
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
ret = winmgr~broadcastSettingChanged(1000)
</programlisting>
</section>
</section>

<section id="clsWinObject"><title>The WindowObject Class</title>
<indexterm><primary>WindowsObject class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsObject class</secondary></indexterm>
<para>The WindowObject class provides methods to query, manipulate, and
interact with a particular window or one of its child windows.</para>
<para>Access to WindowObjects requires that the following directive
appear in the Rexx program.</para>
<programlisting>
::requires 'winsystm.cls'
</programlisting>
<para>The WindowsObject class is designed to be primarily used in conjucture
with the <link linkend="clsWinManager">WindowsManager</link> class.  The
WindowsManager class will obtain the handle of an actual window and instantiate
a WindowObject instance.  Because of this, the WindowObject does not regiser the
C functions that are required for it to behave correctly. (The WindowsManager
class has already registered the functions.)  Therefore, if the programmer uses
the WindowObject outside of the context of the WindowsManager, she needs to
ensure that the C functions get registered before using an instance of the
WindowObject.
</para>
<para>There are a couple of approaches that could be used here.  Perhaps the
simplest is to instantiate a WindowsManager object prior to using a WindowObject
instance.  The WindowsManage instance does not have to be used, the act of
creating a new object causes the C functions to be registered.  The following
code snippet comes from an ooDialog program.  The following code does not work,
because the C functions needed by a WindowObject will not have benn registered:
</para>
<programlisting>
<![CDATA[

::method Cancel

   handle = self~get()
   winObj = .WindowObject~new(handle)
   state = winObj~state~translate

   -- Do not save the size/position if the dialog is Minimized or Maximized
   if state~wordPos('MINIMIZED') = 0 & state~wordPos('ZOOMED') = 0 then
   ...
return self~ok:super
]]>
</programlisting>

<para>The following is a simple way to fix this situation:</para>
<programlisting>
<![CDATA[

::method Cancel

   unusedObj = .WindowsManager~new

   handle = self~get()
   winObj = .WindowObject~new(handle)
   state = winObj~state~translate

   -- Do not save the size/position if the dialog is Minimized or Maximized
   if state~wordPos('MINIMIZED') = 0 & state~wordPos('ZOOMED') = 0 then
   ...
return self~ok:super
]]>
</programlisting>

<para>The programmer can also load the C functions herself to get the correct
behavior from the WindowObject:</para>
<programlisting>
<![CDATA[

::method Cancel

   if RxFuncQuery("InstWinSysFuncs") \= 0 then do
      if RxFuncAdd("InstWinSysFuncs","RXWINSYS.DLL","InstWinSysFuncs") = 0 then
         InstWinSysFuncs()
      else
         return self~ok:super   -- Unexpected error, just quit
   end

   -- Okay, we have the needed C functions, continue.

   handle = self~get()
   winObj = .WindowObject~new(handle)
   state = winObj~state~translate

   -- Do not save the size/position if the dialog is Minimized or Maximized
   if state~wordPos('MINIMIZED') = 0 & state~wordPos('ZOOMED') = 0 then
   ...
return self~ok:super
]]>
</programlisting>

<para><emphasis role="bold">Methods the WindowObject Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>assocWindow</para></listitem>
<listitem><para>childAtPosition</para></listitem>
<listitem><para>coordinates</para></listitem>
<listitem><para>disable</para></listitem>
<listitem><para>enable</para></listitem>
<listitem><para>enumerateChildren</para></listitem>
<listitem><para>findChild</para></listitem>
<listitem><para>first</para></listitem>
<listitem><para>firstChild</para></listitem>
<listitem><para>focusItem</para></listitem>
<listitem><para>focusNextItem</para></listitem>
<listitem><para>focusPreviousItem</para></listitem>
<listitem><para>handle</para></listitem>
<listitem><para>hide</para></listitem>
<listitem><para>id</para></listitem>
<listitem><para>isMenu</para></listitem>
<listitem><para>last</para></listitem>
<listitem><para>maximize</para></listitem>
<listitem><para>menu</para></listitem>
<listitem><para>minimize</para></listitem>
<listitem><para>moveTo</para></listitem>
<listitem><para>next</para></listitem>
<listitem><para>owner</para></listitem>
<listitem><para>previous</para></listitem>
<listitem><para>processMenuCommand</para></listitem>
<listitem><para>pushButton</para></listitem>
<listitem><para>resize</para></listitem>
<listitem><para>restore</para></listitem>
<listitem><para>sendChar</para></listitem>
<listitem><para>sendCommand</para></listitem>
<listitem><para>sendKey</para></listitem>
<listitem><para>sendKeyDown</para></listitem>
<listitem><para>sendKeyUp</para></listitem>
<listitem><para>sendMenuCommand</para></listitem>
<listitem><para>sendMessage</para></listitem>
<listitem><para>sendMouseClick</para></listitem>
<listitem><para>sendSyscommand</para></listitem>
<listitem><para>sendText</para></listitem>
<listitem><para>state</para></listitem>
<listitem><para>systemMenu</para></listitem>
<listitem><para>title</para></listitem>
<listitem><para>title=</para></listitem>
<listitem><para>toForeground</para></listitem>
<listitem><para>wclass</para></listitem></itemizedlist>

<section id="assocwindowwo"><title>assocWindow</title>
<indexterm><primary>assocWindow method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>assocWindow method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-assocWindow--(--handle--)-----------------------------------><
]]>
</programlisting>

<para>Assigns a new window <emphasis role="italic">handle</emphasis> to the
WindowObject instance.</para>
</section>

<section id="handlewo"><title>handle</title>
<indexterm><primary>handle method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>handle method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-handle------------------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the associated window.</para>
</section>

<section id="titlewo"><title>title</title>
<indexterm><primary>title method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>title method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-title-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the title of the window.</para>
</section>

<section id="titlenewwo"><title>title=</title>
<indexterm><primary>title= method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>title= method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-title=newTitle----------------------------------------------><
]]>
</programlisting>

<para>Sets a new title for the window.</para>
</section>

<section id="wclasswo"><title>wclass</title>
<indexterm><primary>wclass method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>wclass method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-wclass------------------------------------------------------><
]]>
</programlisting>

<para>Returns the class of the window associated with the WindowObject instance.
</para>
</section>

<section id="idwo"><title>id</title>
<indexterm><primary>id method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>id method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-id----------------------------------------------------------><
]]>
</programlisting>

<para>Returns the numeric ID of the window.</para>
</section>

<section id="coordinateswo"><title>coordinates</title>
<indexterm><primary>coordinates method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>coordinates method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-coordinates-------------------------------------------------><
]]>
</programlisting>

<para>Returns the upper left and the lower right corner positions of the window
in the format &quot;left,top,right,bottom&quot;.</para>
</section>

<section id="statewo"><title>state</title>
<indexterm><primary>state method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>state method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-state-------------------------------------------------------><
]]>
</programlisting>

<para>Returns information about the window state. The returned state can contain
one or more of the following constants:</para>
<itemizedlist>
<listitem><para>&quot;Enabled&quot; or &quot;Disabled&quot;</para></listitem>
<listitem><para>&quot;Visible&quot; or &quot;Invisible&quot;</para></listitem>
<listitem><para>&quot;Zoomed&quot; or &quot;Minimized&quot;</para></listitem>
<listitem><para>&quot;Foreground&quot;</para></listitem></itemizedlist>
</section>

<section id="restorewo"><title>restore</title>
<indexterm><primary>restore method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>restore method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-restore-----------------------------------------------------><
]]>
</programlisting>

<para>Activates and displays the associated window. If the window is minimized
or maximized, it is restored to its original size and position.</para>
</section>

<section id="hidewo"><title>hide</title>
<indexterm><primary>hide method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>hide method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-hide--------------------------------------------------------><
]]>
</programlisting>

<para>Hides the associated window and activates another window.</para>
</section>

<section id="minimizewo"><title>minimize</title>
<indexterm><primary>minimize method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>minimize method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-minimize----------------------------------------------------><
]]>
</programlisting>

<para>Minimizes the associated window and activates the next higher-level
window.</para>
</section>

<section id="maximizewo"><title>maximize</title>
<indexterm><primary>maximize method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>maximize method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-maximize----------------------------------------------------><
]]>
</programlisting>

<para>Maximizes the associated window.</para>
</section>

<section id="resizewo"><title>resize</title>
<indexterm><primary>resize method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>resize method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-resize--(--width--,--height--)------------------------------><
]]>
</programlisting>

<para>Resizes the associated window to the specified width and height. The width
and height are specified in screen coordinates.</para>
</section>

<section id="enablewo"><title>enable</title>
<indexterm><primary>enable method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>enable method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-enable------------------------------------------------------><
]]>
</programlisting>

<para>Enables the associated window if it was disabled.</para>
</section>

<section id="disablewo"><title>disable</title>
<indexterm><primary>disable method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>disable method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-disable-----------------------------------------------------><
]]>
</programlisting>

<para>Disables the associated window.</para>
</section>

<section id="movetowo"><title>moveTo</title>
<indexterm><primary>moveTo method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>moveTo method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-moveTo--(--x--,--y--)---------------------------------------><
]]>
</programlisting>

<para>Moves the associated window to the specified position
(<emphasis role="italic">x,y</emphasis>). Specify
the new position in screen pixels.</para>
</section>

<section id="toforegroundwo"><title>toForeground</title>
<indexterm><primary>toForeground method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>toForeground method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-toForeground------------------------------------------------><
]]>
</programlisting>

<para>Makes the associated window the foreground window.</para>
</section>

<section id="focusnextitemwo"><title>focusNextItem</title>
<indexterm><primary>focusNextItem method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>focusNextItem method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-focusNextItem-----------------------------------------------><
]]>
</programlisting>

<para>Sets the input focus to the next child window of the associated window.
</para>
</section>

<section id="focuspreviousitemwo"><title>focusPreviousItem</title>
<indexterm><primary>focusPreviousItem method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>focusPreviousItem method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-focusPreviousItem-------------------------------------------><
]]>
</programlisting>

<para>Sets the input focus to the previous child window of the associated
window.</para>
</section>

<section id="focusitemwo"><title>focusItem</title>
<indexterm><primary>focusItem method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>focusItem method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-focusItem--(--wndObject--)----------------------------------><
]]>
</programlisting>

<para>Sets the input focus to the child window associated with the specified
WindowObject instance <emphasis role="italic">wndObject</emphasis>.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<para>The following example sets the input focus to the last child window:
</para>
<programlisting>
 dlg = wndmgr~find("TestDialog")
    if dlg \= .Nil then do
        fChild = dlg~firstChild
        lChild = fChild~last
        dlg~focusItem(lChild)
    end
</programlisting>
</section>

<section id="findchildwo"><title>findChild</title>
<indexterm><primary>findChild method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>findChild method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-findChild--(--label--)--------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the child
window with the specified <emphasis role="italic">label</emphasis>. If the
associated window does not
own such a window, the .Nil object is returned.</para>
</section>

<section id="childatpositionwo"><title>childAtPosition</title>
<indexterm><primary>childAtPosition method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>childAtPosition method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-childAtPosition--(--x--,--y--)------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the child
window at the specified client position (<emphasis role="italic">x,y</emphasis>).
The coordinates that are relative to the upper left corner of the associated
window must be specified
in screen pixels. To retrieve top-level windows,
use method <link linkend="windowatpositionwm">windowAtPosition</link>.</para>
</section>

<section id="nextwo"><title>next</title>
<indexterm><primary>next method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>next method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-next--------------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the next
window of the same level as the associated window. If the associated window
is the last window of a level, the .Nil object is returned.</para>
</section>

<section id="previouswo"><title>previous</title>
<indexterm><primary>previous method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>previous method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-previous----------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the previous
window of the same level as the associated window. If the associated window
is the first window of a level, the .Nil object is returned.</para>
</section>

<section id="firstwo"><title>first</title>
<indexterm><primary>first method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>first method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-first-------------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the first
window of the same level as the associated window.</para>
</section>

<section id="lastwo"><title>last</title>
<indexterm><primary>last method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>last method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-last--------------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the last
window of the same level as the associated window.</para>
</section>

<section id="ownerwo"><title>owner</title>
<indexterm><primary>owner method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>owner method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-owner-------------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the window
that owns the associated window (parent). If the associated window is a
top-level window, the .Nil object is returned.</para>
</section>

<section id="firstchildwo"><title>firstChild</title>
<indexterm><primary>firstChild method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>firstChild method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-firstChild--------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the WindowObject class associated with the first
child window of the associated window. If no child window exists, the .NIL
object is returned.</para>
</section>

<section id="enumeratechildrenwo"><title>enumerateChildren</title>
<indexterm><primary>enumerateChildren method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>enumerateChildren method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-enumerateChildren-------------------------------------------><
]]>
</programlisting>

<para>Returns a stem that stores information about the
child windows of the associated
window. &quot;Stem.0&quot; contains the number of child windows. The returned
stem contains as many records as child windows. The first record is stored
at &quot;Stem.1&quot; continued by increments of 1. Each record contains the
following entries, where each entry starts with an exclamation mark (!):</para>
<variablelist>
<varlistentry><term>!Handle</term>
<listitem><para>The handle of the window.
</para></listitem></varlistentry>
<varlistentry><term>!Title</term>
<listitem><para>
</para></listitem></varlistentry>
<varlistentry><term>!Class</term>
<listitem><para>The window class.
</para></listitem></varlistentry>
<varlistentry><term>!State</term>
<listitem><para>
</para></listitem></varlistentry>
<varlistentry><term>!Coordinates</term>
<listitem><para>
</para></listitem></varlistentry>
<varlistentry><term>!Children</term>
<listitem><para>1 if the window has child windows, 0 if is has none.
</para></listitem></varlistentry>
<varlistentry><term>!Id</term>
<listitem><para>
</para></listitem></varlistentry>
</variablelist>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
      wo = winmgr~find("TestDialog")
        enum. = wo~enumerateChildren
        do i = 1 to enum.0   /* number of children */
           say "---"
           say "Handle:" enum.i.!Handle
           say "Title:" enum.i.!Title
           say "Class:" enum.i.!Class
           say "Id:" enum.i.!Id
           say "Children:" enum.i.!Children
           say "State:" enum.i.!State
           say "Rect:" enum.i.!Coordinates
        end
</programlisting>
</section>

<section id="sendmessagewo"><title>sendMessage</title>
<indexterm><primary>sendMessage method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendMessage method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendMessage--(--message--,--wParam--,--lParam--)------------><
]]>
</programlisting>

<para>Sends a message to the associated window.</para>
</section>

<section id="sendcommandwo"><title>sendCommand</title>
<indexterm><primary>sendCommand method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendCommand method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendCommand--(--command--)----------------------------------><
]]>
</programlisting>

<para>Sends a WM_COMMAND message to the associated window. WM_COMMAND is
sent, for example, when a button is pressed, where
<emphasis role="italic">command</emphasis> is the button ID.</para>
</section>

<section id="sendmenucommandwo"><title>sendMenuCommand</title>
<indexterm><primary>sendMenuCommand method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendMenuCommand method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendMenuCommand--(--id--)-----------------------------------><
]]>
</programlisting>

<para>Selects the menu item <emphasis role="italic">id</emphasis> of the
associated window. Method <link linkend="idofmo">idOf</link> returns the
ID of a menu item.</para>
</section>

<section id="sendmouseclickwo"><title>sendMouseClick</title>
<indexterm><primary>sendMouseClick method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendMouseClick method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
                      +-"LEFT"---+     +-"DBLCLK"-+
>>-sendMouseClick--(--+-"RIGHT"--+--,--+-"UP"-----+----,--x--,--y-->
                      +-"MIDDLE"-+     +-"DOWN"---+

>--+-----------------------------+--)--------------------------><
   |       +----------------+    |
   |       V                |    |
   +-,--"----+-LEFTDOWN---+-+--"-+
             +-RIGHTDOWN--+
             +-MIDDLEDOWN-+
             +-SHIFT------+
             +-CONTROL----+
]]>
</programlisting>

<para>Simulates a mouse click event in the associated window.</para>
<para>Arguments:</para>
<para>The arguments are:</para>
<variablelist>
<varlistentry><term><emphasis role="italic">which</emphasis></term>
<listitem><para>Specifies which mouse button is simulated. LEFT is the default.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="italic">kind</emphasis></term>
<listitem><para>Selects the simulated mouse action. DBLCLK is the default.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="italic">x,y</emphasis></term>
<listitem><para>Specifies the coordinates of the mouse click event, in screen
coordinates, relative to the upper left corner of the window.
</para></listitem></varlistentry>
<varlistentry><term><emphasis role="italic">ext</emphasis></term>
<listitem><para>Can be one or more of the following strings:
<variablelist>
<varlistentry><term>LEFTDOWN</term>
<listitem><para>Simulates the pressed left mouse button.
</para></listitem></varlistentry>
<varlistentry><term>RIGHTDOWN</term>
<listitem><para>Simulates the pressed right mouse button.
</para></listitem></varlistentry>
<varlistentry><term>MIDDLEDOWN</term>
<listitem><para>Simulates the pressed middle mouse button.
</para></listitem></varlistentry>
<varlistentry><term>SHIFT</term>
<listitem><para>Simulates the pressed Shift key.
</para></listitem></varlistentry>
<varlistentry><term>CONTROL</term>
<listitem><para>Simulates the pressed Control key.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="sendsyscommandwo"><title>sendSyscommand</title>
<indexterm><primary>sendSyscommand method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendSyscommand method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendSyscommand--(--"--+-SIZE--------+--"--)-----------------><
                         +-MOVE--------+
                         +-MINIMIZE----+
                         +-MAXIMIZE----+
                         +-NEXTWINDOW--+
                         +-PREVWINDOW--+
                         +-CLOSE-------+
                         +-VSCROLL-----+
                         +-HSCROLL-----+
                         +-ARRANGE-----+
                         +-RESTORE-----+
                         +-TASKLIST----+
                         +-SCREENSAVE--+
                         +-CONTEXTHELP-+
]]>
</programlisting>

<para>Sends a WM_SYSCOMMAND message to the associated window. These messages
are normally sent when the user selects a command in the Window menu.</para>
<para>Argument:</para>
<para>The only argument is:</para>
<variablelist>
<varlistentry><term><emphasis role="italic">command</emphasis></term>
<listitem><para>One of the commands listed in the syntax diagram:
<variablelist>
<varlistentry><term>SIZE</term>
<listitem><para>Puts the window in size mode.
</para></listitem></varlistentry>
<varlistentry><term>MOVE</term>
<listitem><para>Puts the window in move mode.
</para></listitem></varlistentry>
<varlistentry><term>MINIMIZE</term>
<listitem><para>Minimizes the window.
</para></listitem></varlistentry>
<varlistentry><term>MAXIMIZE</term>
<listitem><para>Maximizes the window.
</para></listitem></varlistentry>
<varlistentry><term>NEXTWINDOW</term>
<listitem><para>Moves to the next window.
</para></listitem></varlistentry>
<varlistentry><term>PREVWINDOW</term>
<listitem><para>Moves to the previous window.
</para></listitem></varlistentry>
<varlistentry><term>CLOSE</term>
<listitem><para>Closes the window.
</para></listitem></varlistentry>
<varlistentry><term>VSCROLL</term>
<listitem><para>Scrolls vertically.
</para></listitem></varlistentry>
<varlistentry><term>HSCROLL</term>
<listitem><para>Scrolls horizontally.
</para></listitem></varlistentry>
<varlistentry><term>ARRANGE</term>
<listitem><para>Arranges the window.
</para></listitem></varlistentry>
<varlistentry><term>RESTORE</term>
<listitem><para>Restores the window to its normal position and size.
</para></listitem></varlistentry>
<varlistentry><term>TASKLIST</term>
<listitem><para>Activates the Start menu.
</para></listitem></varlistentry>
<varlistentry><term>SCREENSAVE</term>
<listitem><para>Executes the screen-saver application specified in the [boot]
section of the SYSTEM.INI file.
</para></listitem></varlistentry>
<varlistentry><term>CONTEXTHELP</term>
<listitem><para>Changes the cursor to a question mark with a pointer. If the
user then clicks on a control in the dialog box, the control receives a
WM_HELP message.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="pushbuttonwo"><title>pushButton</title>
<indexterm><primary>pushButton method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>PushButton method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-pushButton--(--label--)-------------------------------------><
]]>
</programlisting>

<para>Selects the button with the specified
<emphasis role="italic">label</emphasis> within the associated
window and sends the corresponding WM_COMMAND message. If the button's
label contains a mnemonic (underscored letter), you must specify an ampersand
(&amp;) in front of it. You can also use this method to select radio buttons
and check or uncheck check boxes.</para>
</section>

<section id="sendkeywo"><title>sendKey</title>
<indexterm><primary>sendKey method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendKey method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendKey--(--keyName--+------------------------+--)----------><
                        +-,--+-----+--+--------+-+
                             +-alt-+  +-,--ext-+
]]>
</programlisting>

<para>Sends all messages (CHAR, KEYDOWN, and KEYUP) that would be sent by
pressing a specific key on the keyboard. Character keys (a to z) are not
case-sensitive.</para>
<para>If the <emphasis role="italic">alt</emphasis> argument is 1, the Alt key
flag is set, which is equal
to pressing the specified key together with the Alt key.</para>
<para>The <emphasis role="italic">Ext</emphasis> argument must be 1 if the key
is an extended key, such as a right Ctrl or a right Shift.</para>
<para>For a list of key names, refer to
<link linkend="virtualkeys">Symbolic Names for Virtual Keys</link>.</para>
</section>

<section id="sendcharwo"><title>sendChar</title>
<indexterm><primary>sendChar method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendChar method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendChar--(--character--+--------+--)-----------------------><
                           +-,--alt-+
]]>
</programlisting>

<para>Sends a WM_CHAR message to the associated window. If the
<emphasis role="italic">alt</emphasis> argument
is 1, a pressed Alt key is simulated.</para>
</section>

<section id="sendkeydownwo"><title>sendKeyDown</title>
<indexterm><primary>sendKeyDown method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendKeyDown method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendKeyDown--(--keyName--+--------+--)----------------------><
                            +-,--ext-+
]]>
</programlisting>

<para>Sends a WM_KEYDOWN message to the associated window. The
<emphasis role="italic">ext</emphasis> argument
must be 1 if the key is an extended key, such as a right Ctrl or a right Shift.
</para>
<para>For a list of key names, refer to
<link linkend="virtualkeys">Symbolic Names for Virtual Keys</link>.</para>
</section>

<section id="sendkeyupwo"><title>sendKeyUp</title>
<indexterm><primary>sendKeyUp method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendKeyUp method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendKeyUp--(--keyName--+--------+--)------------------------><
                          +-,--ext-+
]]>
</programlisting>

<para>Sends a WM_KEYUP message to the associated window. The
<emphasis role="italic">ext</emphasis> argument
must be 1 if the key is an extended key, such as a right Ctrl or a right Shift.
</para>
<para>For a list of key names, refer to
<link linkend="virtualkeys">Symbolic Names for Virtual Keys</link>.</para>
</section>

<section id="sendtextwo"><title>sendText</title>
<indexterm><primary>sendText method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>sendText method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-sendText--(--text--)----------------------------------------><
]]>
</programlisting>

<para>Sends a (case-sensitive) text to the associated window by sending a
sequence of WM_CHAR, WM_KEYDOWN, and WM_KEYUP messages.</para>
</section>

<section id="menuwo"><title>menu</title>
<indexterm><primary>menu method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>menu method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-menu--------------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the MenuObject class that refers to the menu of
the associated window.</para>
</section>

<section id="systemmenuwo"><title>systemMenu</title>
<indexterm><primary>systemMenu method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>systemMenu method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-systemMenu--------------------------------------------------><
]]>
</programlisting>

<para>Returns an instance of the MenuObject class that refers to the system
menu of the associated window.</para>
</section>

<section id="ismenuwo"><title>isMenu</title>
<indexterm><primary>isMenu method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>isMenu method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-isMenu------------------------------------------------------><
]]>
</programlisting>

<para>Returns 1 if the associated window is a menu, otherwise 0.</para>
</section>

<section id="processmenucommandwo"><title>processMenuCommand</title>
<indexterm><primary>processMenuCommand method</primary>
<secondary>of WindowsObject class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>ProcessMenuCommand method</secondary>
<tertiary>of WindowsObject class</tertiary></indexterm>
<programlisting>
<![CDATA[
                                       +-,-------+
                                       V         |
>>-processMenuCommand--(--+------+--,----submenu-+--,--menuItem--)-><
                          +-menu-+
]]>
</programlisting>

<para>Selects an item of the menu or submenu of the associated window. You can
specify as many submenus as necessary to get to the required item.</para>
</section>
</section>

<section id="clsWinProgramManager"><title>The WindowsProgramManager Class</title>
<indexterm><primary>WindowsProgramManager class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsProgramManager class</secondary></indexterm>
<para>Object Rexx provides a class for interaction with the Windows Program
Manager. You can use this class to create program groups and shortcuts to
access your programs. This class is specifically for Windows systems
and may not be available on other systems.</para>
<para>The WindowsProgramManager class is defined in the file WINSYSTM.CLS. Use
a <computeroutput>::requires</computeroutput> statement to activate its
function: </para>
<programlisting>
::requires "winsystm.cls"
</programlisting>
<para>A sample program <computeroutput>DESKTOP.REX</computeroutput> is provided
in the <computeroutput>ooRexx\SAMPLES</computeroutput> directory.</para>
<para>Methods of the WindowsProgramManager class are:</para>

<table frame="all">
<title>Methods Available to the WindowsProgramManager Class</title>
<tgroup cols="2">
<thead>
<row>
<entry>Method...</entry>
<entry>...link</entry>
</row>
</thead>
<tbody>
<row>
<entry>addDeskTopIcon</entry>
<entry><link linkend="adddesktopicon">addDesktopIcon</link></entry>
</row>
<row>
<entry>addGroup</entry>
<entry><link linkend="wpadgr">addGroup</link></entry>
</row>
<row>
<entry>addItem</entry>
<entry><link linkend="wpadit">addItem</link></entry>
</row>
<row>
<entry>addShortCut</entry>
<entry><link linkend="addshortcut">addShortCut</link></entry>
</row>
<row>
<entry>deleteDesktopIcon</entry>
<entry><link linkend="deldskic">deleteDesktopIcon</link></entry>
</row>
<row>
<entry>deleteGroup</entry>
<entry><link linkend="wpdegr">deleteGroup</link></entry>
</row>
<row>
<entry>deleteItem</entry>
<entry><link linkend="wpdeit">deleteItem</link></entry>
</row>
<row>
<entry>init</entry>
<entry><link linkend="wpinit">init</link></entry>
</row>
<row>
<entry>showGroup</entry>
<entry><link linkend="wpshgr">showGroup</link></entry>
</row>
</tbody>
</tgroup>
</table>

<section id="adddesktopicon"><title>addDesktopIcon</title>
<indexterm><primary>addDesktopIcon method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>AddDesktopIcon method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addDesktopIcon--(--name--,--program--+--------------------------------+-->
                                        |                     +-0------+ |
                                        +-,--+----------+--,--+--------+-+
                                             +-iconfile-+     +-iconnr-+

>--+--------------------------------------------------------------------------+-)-><
   |                 +-"PERSONAL"-+                           +-"NORMAL"----+ |
   +-,-+---------+-,-+------------+-,-+------+-,-+--------+-,-+-------------+-+
       +-workdir-+   +-"COMMON"---+   +-args-+   +-hotkey-+   +-"MAXIMIZED"-+
                                                              +-"MINIMIZED"-+
]]>
</programlisting>

<para>Adds a shortcut to the Windows desktop. A sample program
<computeroutput>DESKICON.REX</computeroutput> is provided in the
<computeroutput>ooRexx\SAMPLES</computeroutput> directory.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>name</term>
<listitem><para>The name of the shortcut, displayed below the icon.
</para></listitem></varlistentry>
<varlistentry><term>program</term>
<listitem><para>The program file launched by the shortcut.
</para></listitem></varlistentry>
<varlistentry><term>iconfile</term>
<listitem><para>The name of the icon used for the shortcut. If not specified,
the icon of <emphasis role="italic">program</emphasis> is used.
</para></listitem></varlistentry>
<varlistentry><term>iconnr</term>
<listitem><para>The number of the icon within the
<emphasis role="italic">iconfile</emphasis>. The default is 0.
</para></listitem></varlistentry>
<varlistentry><term>workdir</term>
<listitem><para>The working directory of the shortcut.
</para></listitem></varlistentry>
<varlistentry><term>location</term>
<listitem><para>Either of the following locations:
<variablelist>
<varlistentry><term>&quot;PERSONAL&quot;</term>
<listitem><para>The shortcut is personal and displayed only on the desktop of
the user.</para></listitem></varlistentry>
<varlistentry><term>&quot;COMMON&quot;</term>
<listitem><para>The shortcut is common to all users and displayed on the
desktop of all users.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>args</term>
<listitem><para>The arguments passed to the program that the shortcut refers to.
</para></listitem></varlistentry>
<varlistentry><term>hotkey</term>
<listitem><para>The virtual key to be used as a hotkey to open the shortcut.
For a list of the key names, see
<link linkend="virtualkeys">Symbolic Names for Virtual Keys</link>.
</para></listitem></varlistentry>
<varlistentry><term>run</term>
<listitem><para>Specifies one of the options listed in the syntax diagram. The
default is &quot;NORMAL&quot;.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="addshortcut"><title>addShortCut</title>
<indexterm><primary>addShortCut method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addShortCut method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addShortCut--(--name--,--program--------------------------------------->

>--+---------------------------------------------------------------------->
   |                  +-0------+
   +-,-+----------+-,-+--------+-,-+---------+-,-+------+-,-+--------+-,-->
       +-iconfile-+   +-iconnr-+   +-workdir-+   +-args-+   +-hotkey-+

>-------------------+--)-------------------------------------------------><
    +-"NORMAL"----+ |
>---+-------------+-+
    +-"MAXIMIZED"-+
    +-"MINIMIZED"-+
]]>
</programlisting>

<para>Creates a shortcut within the specified folder.</para>
<variablelist>
<varlistentry><term>Arguments:</term>
<listitem><para>The arguments are:
<variablelist>
<varlistentry><term>name</term>
<listitem><para>The full name of the shortcut.
</para></listitem></varlistentry>
<varlistentry><term>program</term>
<listitem><para>The program file launched by the shortcut.
</para></listitem></varlistentry>
<varlistentry><term>iconfile</term>
<listitem><para>The name of the icon used for the shortcut. If not specified,
the icon of <emphasis role="italic">program</emphasis> is used.
</para></listitem></varlistentry>
<varlistentry><term>iconnr</term>
<listitem><para>The number of the icon within the
<emphasis role="italic">iconfile</emphasis>. The default is
0.
</para></listitem></varlistentry>
<varlistentry><term>workdir</term>
<listitem><para>The working directory of the shortcut.
</para></listitem></varlistentry>
<varlistentry><term>args</term>
<listitem><para>The arguments passed to the program that the shortcut refers to.
</para></listitem></varlistentry>
<varlistentry><term>hotkey</term>
<listitem><para>The virtual key to be used as a hotkey to open the shortcut.
For a list of the key names, see
<link linkend="virtualkeys">Symbolic Names for Virtual Keys</link>.
</para></listitem></varlistentry>
<varlistentry><term>run</term>
<listitem><para>Specifies one of the options listed in the syntax diagram.
The default is &quot;NORMAL&quot;.
</para></listitem></varlistentry>
</variablelist>
</para></listitem></varlistentry>
<varlistentry><term>Example:</term>
<listitem><para>The following example creates a shortcut named
&quot;My NotePad&quot;
to the Notepad editor within the directory c:\temp:
<programlisting>
pm = .WindowsProgramManager~new
	if pm~InitCode \= 0 then exit
	pm~addShortCut("c:\temp\My Notepad","%SystemRoot%\system32\notepad.exe")
	::requires "winsystm.cls"
</programlisting>
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="wpadgr"><title>addGroup</title>
<indexterm><primary>addGroup method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addGroup method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addGroup(-group-)-------------------------------------------><
]]>
</programlisting>

<para>Adds a program group to the Programs group of the desktop. If the group
already exists, it is opened. The <emphasis role="italic">group</emphasis>
argument specifies the name of the program group to be added. Example:</para>
<programlisting>
addGroup("Object Rexx Redbook")
</programlisting>

<note><title>Note</title>
<para>The name that you specify for the
<emphasis role="italic">group</emphasis> argument
must not contain any brackets or parenthesis. Otherwise, this method fails.
</para></note>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The method was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="wpadit"><title>addItem</title>
<indexterm><primary>addItem method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>addItem method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-addItem--(--shortcut,program--------------------------------->

>--+------------------------------------------------------+----->
   +-,--+----------+--+---------------------------------+-+
        +-iconfile-+  +-,--+------------+--+----------+-+
                           +-iconnumber-+  +-,workdir-+

>--)-----------------------------------------------------------><
]]>
</programlisting>

<para>Adds a shortcut to a program group. The shortcut is placed into the last
group used with either AddGroup or ShowGroup. Example: </para>
<programlisting>
AddItem("OODialog Samples", ,
"rexx oodialog\samples\sample.rex", ,
"oodialog\samples\oodialog.ico")
</programlisting>

<note><title>Note</title>
<para>The name that you specify for the <emphasis role="italic">group</emphasis>
argument must not contain characters that are not valid, such as brackets or
parenthesis. Otherwise, this method fails. Some characters are changed,
for example / to _.</para></note>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The method was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="deldskic"><title>deleteDesktopIcon</title>
<indexterm><primary>deleteDesktopIcon method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>deleteDesktopIcon method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>

<programlisting>
<![CDATA[
                                   +-"PERSONAL"-+
>>-deleteDesktopIcon--(--name--,---+------------+-)------------><
                                   +-"COMMON"---+
]]>
</programlisting>

<para>Deletes a shortcut from the Windows desktop that was previously
created with AddDesktopIcon.</para>

<para>The arguments are:</para>

<variablelist>
<varlistentry><term><emphasis>name</emphasis></term>
<listitem><para>The name of the shortcut to be deleted.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>location</emphasis></term>
<listitem><para>Either of the following locations:</para>
<variablelist>
<varlistentry><term><emphasis>"PERSONAL"</emphasis></term>
<listitem><para>The shortcut was previously created with AddDesktopIcon
and the location option "PERSONAL". This is the default.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>"COMMON"</emphasis></term>
<listitem><para>The shortcut was previously created with AddDesktopIcon
and the location option "COMMON".
</para></listitem></varlistentry>
</variablelist>
</listitem></varlistentry>
</variablelist>

<para><emphasis role="bold">Return codes:</emphasis></para>

<variablelist>
<varlistentry><term><emphasis>0</emphasis></term>
<listitem><para>Shortcut deleted successfully.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>2</emphasis></term>
<listitem><para>Shortcut not found.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>3</emphasis></term>
<listitem><para>Path to shortcut not found.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>5</emphasis></term>
<listitem><para>Access denied or busy.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>26</emphasis></term>
<listitem><para>Not a DOS disk.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>32</emphasis></term>
<listitem><para>Sharing violation.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>36</emphasis></term>
<listitem><para>Sharing buffer exceeded.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>87</emphasis></term>
<listitem><para>Does not exist.
</para></listitem></varlistentry>
<varlistentry><term><emphasis>206</emphasis></term>
<listitem><para>Shortcut name exceeds range error.
</para></listitem></varlistentry>
</variablelist>

<note><title>Note:</title>
<para>Return code 2 is also returned when a "PERSONAL" should be
deleted that was previously created with "COMMON" and vice
versa.</para></note>

<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
<![CDATA[
pm = .WindowsProgramManager~new
if pm~InitCode \= 0 then exit

rc = pm~deleteDesktopIcon("MyNotepad1", ,
     "%SystemRoot%\system32\notepad.exe")
if rc \= 0 then do
  say "Error deleting shortcut: My Notepad 1"
  exit
end

exit

::requires "winsystm.cls"
]]>
</programlisting>

</section>

<section id="wpdegr"><title>deleteGroup</title>
<indexterm><primary>deleteGroup method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>deleteGroup method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-deleteGroup(-group-)----------------------------------------><
]]>
</programlisting>

<para>Deletes a program group from the desktop. The
<emphasis role="italic">group</emphasis> argument specifies
the name of the program group to be deleted.</para>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The method was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="wpdeit"><title>deleteItem</title>
<indexterm><primary>deleteItem method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>deleteItem method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-deleteItem(shortcut)----------------------------------------><
]]>
</programlisting>

<para>Deletes a shortcut from a program group.</para>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The method was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="wpinit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-init--------------------------------------------------------><
]]>
</programlisting>

<para>Creates an instance of the WindowsProgramManager class and loads the
required function package.</para>
</section>

<section id="wpshgr"><title>showGroup</title>
<indexterm><primary>showGroup method</primary>
<secondary>of WindowsProgramManager class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>showGroup method</secondary>
<tertiary>of WindowsProgramManager class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-showGroup(-group,-+-----+-)---------------------------------><
                     +-MIN-+
                     +-MAX-+
]]>
</programlisting>

<para>Opens a program group. The
<emphasis role="italic">group</emphasis> argument specifies the name of
the program group to be opened. If MIN or MAX is specified, the program group
is opened minimized or maximized.</para>
<para>Return value:</para>
<variablelist>
<varlistentry><term>0</term>
<listitem><para>The method was successful.
</para></listitem></varlistentry>
<varlistentry><term>1</term>
<listitem><para>The method failed.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="virtualkeys"><title>Symbolic Names for Virtual Keys</title>
<indexterm><primary>virtual keys</primary></indexterm>
<para><link linkend="t000033">Table 3</link> shows the symbolic names and the
keyboard equivalents for the virtual keys used by Object Rexx.</para>

<table id="t000033" frame="all">
<title>Symbolic Names for Virtual Keys</title>
<tgroup cols="2">
<thead>
<row>
<entry>Symbolic Name</entry>
<entry>Mouse or Keyboard Equivalent</entry>
</row>
</thead>
<tbody>
<row>
<entry>LBUTTON</entry>
<entry>Left mouse button</entry>
</row>
<row>
<entry>RBUTTON</entry>
<entry>Right mouse button</entry>
</row>
<row>
<entry>CANCEL</entry>
<entry>Control-break processing</entry>
</row>
<row>
<entry>MBUTTON</entry>
<entry>Middle mouse button (three-button mouse)</entry>
</row>
<row>
<entry>BACK</entry>
<entry>BACKSPACE key</entry>
</row>
<row>
<entry>TAB</entry>
<entry>TAB key</entry>
</row>
<row>
<entry>CLEAR</entry>
<entry>CLEAR key</entry>
</row>
<row>
<entry>RETURN</entry>
<entry>ENTER key</entry>
</row>
<row>
<entry>SHIFT</entry>
<entry>SHIFT key</entry>
</row>
<row>
<entry>CONTROL</entry>
<entry>CRTL key</entry>
</row>
<row>
<entry>MENU</entry>
<entry>ALT key</entry>
</row>
<row>
<entry>PAUSE</entry>
<entry>PAUSE key</entry>
</row>
<row>
<entry>CAPITAL</entry>
<entry>CAPS LOCK key</entry>
</row>
<row>
<entry>ESCAPE</entry>
<entry>ESC key</entry>
</row>
<row>
<entry>SPACE</entry>
<entry>SPACEBAR</entry>
</row>
<row>
<entry>PRIOR</entry>
<entry>PAGE UP key</entry>
</row>
<row>
<entry>NEXT</entry>
<entry>PAGE DOWN key</entry>
</row>
<row>
<entry>END</entry>
<entry>END key</entry>
</row>
<row>
<entry>HOME</entry>
<entry>HOME key</entry>
</row>
<row>
<entry>LEFT</entry>
<entry>LEFT ARROW key</entry>
</row>
<row>
<entry>UP</entry>
<entry>UP ARROW key</entry>
</row>
<row>
<entry>RIGHT</entry>
<entry>RIGHT ARROW key</entry>
</row>
<row>
<entry>DOWN</entry>
<entry>DOWN ARROW key</entry>
</row>
<row>
<entry>SELECT</entry>
<entry>SELECT key</entry>
</row>
<row>
<entry>EXECUTE</entry>
<entry>EXECUTE key</entry>
</row>
<row>
<entry>SNAPSHOT</entry>
<entry>PRINT SCREEN key</entry>
</row>
<row>
<entry>INSERT</entry>
<entry>INS key</entry>
</row>
<row>
<entry>DELETE</entry>
<entry>DEL key</entry>
</row>
<row>
<entry>HELP</entry>
<entry>HELP key</entry>
</row>
<row>
<entry>0</entry>
<entry>0 key</entry>
</row>
<row>
<entry>1</entry>
<entry>1 key</entry>
</row>
<row>
<entry>2</entry>
<entry>2 key</entry>
</row>
<row>
<entry>3</entry>
<entry>3 key</entry>
</row>
<row>
<entry>4</entry>
<entry>4 key</entry>
</row>
<row>
<entry>5</entry>
<entry>5 key</entry>
</row>
<row>
<entry>6</entry>
<entry>6 key</entry>
</row>
<row>
<entry>7</entry>
<entry>7 key</entry>
</row>
<row>
<entry>8</entry>
<entry>8 key</entry>
</row>
<row>
<entry>9</entry>
<entry>9 key</entry>
</row>
<row>
<entry>A</entry>
<entry>A key</entry>
</row>
<row>
<entry>B</entry>
<entry>B key</entry>
</row>
<row>
<entry>C</entry>
<entry>C key</entry>
</row>
<row>
<entry>D</entry>
<entry>D key</entry>
</row>
<row>
<entry>E</entry>
<entry>E key</entry>
</row>
<row>
<entry>F</entry>
<entry>F key</entry>
</row>
<row>
<entry>G</entry>
<entry>G key</entry>
</row>
<row>
<entry>H</entry>
<entry>H key</entry>
</row>
<row>
<entry>I</entry>
<entry>I key</entry>
</row>
<row>
<entry>J</entry>
<entry>J key</entry>
</row>
<row>
<entry>K</entry>
<entry>K key</entry>
</row>
<row>
<entry>L</entry>
<entry>L key</entry>
</row>
<row>
<entry>M</entry>
<entry>M key</entry>
</row>
<row>
<entry>N</entry>
<entry>N key</entry>
</row>
<row>
<entry>O</entry>
<entry>O key</entry>
</row>
<row>
<entry>Q</entry>
<entry>Q key</entry>
</row>
<row>
<entry>R</entry>
<entry>R key</entry>
</row>
<row>
<entry>S</entry>
<entry>S key</entry>
</row>
<row>
<entry>T</entry>
<entry>T key</entry>
</row>
<row>
<entry>U</entry>
<entry>U key</entry>
</row>
<row>
<entry>V</entry>
<entry>V key</entry>
</row>
<row>
<entry>W</entry>
<entry>W key</entry>
</row>
<row>
<entry>X</entry>
<entry>X key</entry>
</row>
<row>
<entry>Y</entry>
<entry>Y key</entry>
</row>
<row>
<entry>Z</entry>
<entry>Z key</entry>
</row>
<row>
<entry>NUMPAD0</entry>
<entry>Numeric keypad 0 key</entry>
</row>
<row>
<entry>NUMPAD1</entry>
<entry>Numeric keypad 1 key</entry>
</row>
<row>
<entry>NUMPAD2</entry>
<entry>Numeric keypad 2 key</entry>
</row>
<row>
<entry>NUMPAD3</entry>
<entry>Numeric keypad 3 key</entry>
</row>
<row>
<entry>NUMPAD4</entry>
<entry>Numeric keypad 4 key</entry>
</row>
<row>
<entry>NUMPAD5</entry>
<entry>Numeric keypad 5 key</entry>
</row>
<row>
<entry>NUMPAD6</entry>
<entry>Numeric keypad 6 key</entry>
</row>
<row>
<entry>NUMPAD7</entry>
<entry>Numeric keypad 7 key</entry>
</row>
<row>
<entry>NUMPAD8</entry>
<entry>Numeric keypad 8 key</entry>
</row>
<row>
<entry>NUMPAD9</entry>
<entry>Numeric keypad 9 key</entry>
</row>
<row>
<entry>MULTIPLY</entry>
<entry>Multiply key</entry>
</row>
<row>
<entry>ADD</entry>
<entry>Add key</entry>
</row>
<row>
<entry>SEPARATOR</entry>
<entry>Separator key</entry>
</row>
<row>
<entry>SUBTRACT</entry>
<entry>Subtract key</entry>
</row>
<row>
<entry>DECIMAL</entry>
<entry>Decimal key</entry>
</row>
<row>
<entry>DIVIDE</entry>
<entry>Divide key</entry>
</row>
<row>
<entry>F1</entry>
<entry>F1 key</entry>
</row>
<row>
<entry>F2</entry>
<entry>F2 key</entry>
</row>
<row>
<entry>F3</entry>
<entry>F3 key</entry>
</row>
<row>
<entry>F4</entry>
<entry>F4 key</entry>
</row>
<row>
<entry>F5</entry>
<entry>F5 key</entry>
</row>
<row>
<entry>F6</entry>
<entry>F6 key</entry>
</row>
<row>
<entry>F7</entry>
<entry>F7 key</entry>
</row>
<row>
<entry>F8</entry>
<entry>F8 key</entry>
</row>
<row>
<entry>F9</entry>
<entry>F9 key</entry>
</row>
<row>
<entry>F10</entry>
<entry>F10 key</entry>
</row>
<row>
<entry>F11</entry>
<entry>F11 key</entry>
</row>
<row>
<entry>F12</entry>
<entry>F12 key</entry>
</row>
<row>
<entry>F13</entry>
<entry>F13 key</entry>
</row>
<row>
<entry>F14</entry>
<entry>F14 key</entry>
</row>
<row>
<entry>F15</entry>
<entry>F15 key</entry>
</row>
<row>
<entry>F16</entry>
<entry>F16 key</entry>
</row>
<row>
<entry>F17</entry>
<entry>F17 key</entry>
</row>
<row>
<entry>F18</entry>
<entry>F18 key</entry>
</row>
<row>
<entry>F19</entry>
<entry>F19 key</entry>
</row>
<row>
<entry>F20</entry>
<entry>F20 key</entry>
</row>
<row>
<entry>F21</entry>
<entry>F21 key</entry>
</row>
<row>
<entry>F22</entry>
<entry>F22 key</entry>
</row>
<row>
<entry>F23</entry>
<entry>F23 key</entry>
</row>
<row>
<entry>F24</entry>
<entry>F24 key</entry>
</row>
<row>
<entry>NUMLOCK</entry>
<entry>NUM LOCK key</entry>
</row>
<row>
<entry>SCROLL</entry>
<entry>SCROLL LOCK key</entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>

<section id="clsWinRegistry"><title>The WindowsRegistry Class</title>
<indexterm><primary>WindowsRegistry class</primary></indexterm>
<indexterm><primary>class</primary>
<secondary>WindowsProgramManager class</secondary></indexterm>
<para>Object Rexx provides a class for interaction with the WindowsRegistry.
You can use this class to query the registry and modify, add, and delete entries.
This class is specifically for Windows systems and may not be available
on other systems.</para>
<para>The WindowsRegistry class is not a built-in class; it is defined in the
file WINSYSTM.CLS.</para>
<para>Use a <computeroutput>::requires</computeroutput> statement to activate
its function: </para>
<programlisting>
::requires "winsystm.cls"
</programlisting>
<para>A sample program, <computeroutput>REGISTRY.REX</computeroutput>, is
provided in the <computeroutput>ooRexx\SAMPLES</computeroutput> directory
</para>
<para><emphasis role="bold">Methods the WindowsRegistry Class Defines</emphasis>
</para>
<itemizedlist>
<listitem><para>classes_root</para></listitem>
<listitem><para>classes_root=</para></listitem>
<listitem><para>close</para></listitem>
<listitem><para>create</para></listitem>
<listitem><para>current_key</para></listitem>
<listitem><para>current_key=</para></listitem>
<listitem><para>current_user</para></listitem>
<listitem><para>current_user=</para></listitem>
<listitem><para>delete</para></listitem>
<listitem><para>deleteValue</para></listitem>
<listitem><para>flush</para></listitem>
<listitem><para>getValue</para></listitem>
<listitem><para>init</para></listitem>
<listitem><para>list</para></listitem>
<listitem><para>listValues</para></listitem>
<listitem><para>load</para></listitem>
<listitem><para>local_machine</para></listitem>
<listitem><para>local_machine=</para></listitem>
<listitem><para>open</para></listitem>
<listitem><para>query</para></listitem>
<listitem><para>replace</para></listitem>
<listitem><para>restore</para></listitem>
<listitem><para>save</para></listitem>
<listitem><para>setValue</para></listitem>
<listitem><para>unload</para></listitem>
<listitem><para>users</para></listitem>
<listitem><para>users=</para></listitem></itemizedlist>

<section id="wrclro"><title>classes_root</title>
<indexterm><primary>classes_root method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>classes_root method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-classes_root------------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the root key HKEY_CLASSES_ROOT.</para>
</section>

<section id="wrclroe"><title>classes_root=</title>
<indexterm><primary>classes_root= method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>classes_root= method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-classes_root=-----------------------------------------------><
]]>
</programlisting>

<para>This method is used by INIT to set the attribute CLASSES_ROOT to
HKEY_CLASSES_ROOT. Do not modify this attribute.</para>
</section>

<section id="wrclse"><title>close</title>
<indexterm><primary>close method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>close method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-close(-+------------+-)-------------------------------------><
          +-key_handle-+
]]>
</programlisting>

<para>Closes a previously opened key specified by its handle. Example:</para>
<programlisting>
rg~close(objectrexxkey)
</programlisting>
<para>It can take several seconds before all data is written to disk. You can
use FLUSH to empty the cache.</para>
<para>If <emphasis role="italic">key_handle</emphasis> is omitted,
CURRENT_KEY is closed.</para>
</section>

<section id="wrconn"><title>connect</title>
<indexterm><primary>connect method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>connect method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-connect(-key,computer-)-------------------------------------><
]]>
</programlisting>

<para>Opens a key on a remote computer. This is supported only for
HKEY_LOCAL_MACHINE and HKEY_USERS.</para>
</section>

<section id="wrcrt"><title>create</title>
<indexterm><primary>create method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>create method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-create(-+--------+-,subkey)---------------------------------><
           +-parent-+
]]>
</programlisting>

<para>Adds a new named subkey to the registry and returns its handle. The
parent key handle <emphasis role="italic">parent</emphasis> can be a root key
or a key retrieved using OPEN. If the <emphasis role="italic">parent</emphasis>
key is omitted, CURRENT_KEY is used. Example:</para>
<programlisting>
newkey = rg~create(rg~local_machine,"MyOwnKey")
</programlisting>
</section>

<section id="wrcuky"><title>current_key</title>
<indexterm><primary>current_key method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>current_key method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-current_key-------------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the current key. The current key is set by INIT,
CREATE, and OPEN. It is used as a default value if the key is omitted in other
methods.</para>
</section>

<section id="wrcukye"><title>current_key=</title>
<indexterm><primary>current_key= method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>current_key= method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-current_key=------------------------------------------------><
]]>
</programlisting>

<para>Sets the handle of the current key.</para>
</section>

<section id="wrcuus"><title>current_user</title>
<indexterm><primary>current_user method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>current_user method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-current_user------------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the root key HKEY_CURRENT_USER.</para>
</section>

<section id="wrcuuse"><title>current_user=</title>
<indexterm><primary>current_user= method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>current_user= method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-current_user=-----------------------------------------------><
]]>
</programlisting>

<para>This method is used by INIT to set the attribute CURRENT_USER to
HKEY_CURRENT_USER. Do not modify this attribute.</para>
</section>

<section id="wrdele"><title>delete</title>
<indexterm><primary>delete method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>delete method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-delete(-+------------+-,subkeyname)-------------------------><
           +-key_handle-+
]]>
</programlisting>

<para>Deletes a given named subkey of an open key specified by its handle and
all its subkeys and values. If <emphasis role="italic">key_handle</emphasis>
is omitted, CURRENT_KEY is used.</para>
</section>

<section id="wrdeva"><title>deleteValue</title>
<indexterm><primary>deleteValue method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>deleteValue method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-deleteValue(-+------------+-+--------+-)--------------------><
                +-key_handle-+ +-,value-+
]]>
</programlisting>

<para>Deletes the named value for a given key. If
<emphasis role="italic">key_handle</emphasis> is omitted,
CURRENT_KEY is used. If <emphasis role="italic">value</emphasis>
is blank or omitted, the default value is deleted.</para>
</section>

<section id="wrflus"><title>flush</title>
<indexterm><primary>flush method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>flush method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-flush(-+------------+-)-------------------------------------><
          +-key_handle-+
]]>
</programlisting>

<para>Forces the system to write the cache buffer of a given key to disk. If
<emphasis role="italic">key_handle</emphasis> is omitted, CURRENT_KEY is
flushed.</para>
</section>

<section id="wrgtva"><title>getValue</title>
<indexterm><primary>getValue method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>getValue method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-getValue(-+------------+-+--------+-)-----------------------><
             +-key_handle-+ +-,value-+
]]>
</programlisting>

<para>Retrieves the data and type for a named value of a given key. The result
is a compound variable with suffixes data and type. If
<emphasis role="italic">key_handle</emphasis> is
omitted, CURRENT_KEY is used. If named <emphasis role="italic">value</emphasis>
is blank or omitted, the default value is retrieved. Example: </para>
<programlisting>
myval. = rg~getvalue(,"filesystem")        /* current key */
say "Type is" myval.type
if myval.type = "NORMAL" then say "Value is" myval.data
myval. = rg~getvalue(mykey)
say "my default value is:" myval.data
myval. = rg~getvalue(mykey,"")
say "my default value is:" myval.data
</programlisting>
<para>Possible types: NORMAL, EXPAND, MULTI, NUMBER, BINARY, NONE,
OTHER.</para>
</section>

<section id="wrinit"><title>init</title>
<indexterm><primary>init method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>init method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-init--------------------------------------------------------><
]]>
</programlisting>

<para>Creates an instance of the WindowsRegistry class and loads the required
external function package. The current key is set to HKEY_LOCAL_MACHINE.</para>
</section>

<section id="wrlist"><title>list</title>
<indexterm><primary>list method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>list method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-list(-+------------+-,stem.)--------------------------------><
         +-key_handle-+
]]>
</programlisting>

<para>Retrieves the list of subkeys for a given key in a stem variable. The name
of the stem variable must include the period. The keys are returned as stem.1,
stem.2, and so on. Example: </para>
<programlisting>
rg~LIST(objectrexxkey,orexxkeys.)
do i over orexxkeys.
say orexxkeys.i
end
</programlisting>
</section>

<section id="wrliva"><title>listValues</title>
<indexterm><primary>listValues method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>listValues method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-listValues(-+------------+-,variable.)----------------------><
               +-key_handle-+
]]>
</programlisting>

<para>Retrieves all value entries of a given key into a compound variable. The
name of the variable must include the period. The suffixes of the compound
variable are numbered starting with 1, and for each number the three values
are the name (var.i.name), the data (var.i.data), and the type (var.i.type).
The type is NORMAL for alphabetic values, EXPAND for expandable strings such
as a path, NONE for no specified type, MULTI for multiple strings, NUMBER
for a 4-byte value, and BINARY for any data format.</para>
<para>If <emphasis role="italic">key_handle</emphasis> is omitted, the values
of CURRENT_KEY are listed.</para>
<para><emphasis role="bold">Example:</emphasis></para>
<programlisting>
qstem. = rg~QUERY(objectrexxkey)
rg~LISTVALUES(objectrexxkey,lv.)
do i=1 to qstem.values
say "name of value:" lv.i.name "(type="lv.i.type")"
if lv.i.type = "NORMAL" then
say "data of value:" lv.i.data
end
</programlisting>
</section>

<section id="wrload"><title>load</title>
<indexterm><primary>load method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>load method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-load(-+------------+-,subkeyname, filename)-----------------><
         +-key_handle-+
]]>
</programlisting>

<para>Load creates a named subkey under the open key key_handle and loads
registry data from the file filename (created by
<link linkend="wrsave">SAVE</link>) and stores the
data under the newly created subkey.</para>
<para>key_handle can only be HKEY_USERS or HKEY_LOCAL_MACHINE.
Registry information is stored in the form of a hive - a discrete body
of keys, subkeys, and values that is rooted at the top of the registry
hierarchy. A hive is backed by a single file.</para>
<para>If <emphasis role="italic">key_handle</emphasis> is omitted, the subkey
is created under HKEY_LOCAL_MACHINE.</para>
<para>Use <link linkend="wrunld">UNLOAD</link> to delete the subkey and to
unlock the registry data file filename.</para>
</section>

<section id="wrloma"><title>local_machine</title>
<indexterm><primary>local_machine method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>local_machine method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-local_machine-----------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the root key HKEY_LOCAL_MACHINE.</para>
</section>

<section id="wrlomae"><title>local_machine=</title>
<indexterm><primary>local_machine= method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>local_machine= method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-local_machine=----------------------------------------------><
]]>
</programlisting>

<para>This method is used by INIT to set the attribute LOCAL_MACHINE to
HKEY_LOCAL_MACHINE. Do not modify this attribute.</para>
</section>

<section id="wropen"><title>open</title>
<indexterm><primary>open method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>open method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-open(-+---------------+-,subkey-+--------------+-)----------><
         +-parent_handle-+         +-,-| access |-+

access:

   +-ALL-+
|--+-----+------------------------------------------------------>

   +--------------------------------------------------------------+
   V                                                              |
>----+-------+-+------+-+-------+-+---------+-+--------+-+------+-+--|
     +-WRITE-+ +-READ-+ +-QUERY-+ +-EXECUTE-+ +-NOTIFY-+ +-LINK-+
]]>
</programlisting>

<para>Opens a named subkey and return its handle. See
<link linkend="wrcrt">CREATE</link> for
more information about <emphasis role="italic">parent_handle</emphasis>.
Possible values for <emphasis role="italic">access</emphasis> are:</para>
<variablelist>
<varlistentry><term>ALL</term>
<listitem><para>Default
</para></listitem></varlistentry>
<varlistentry><term>WRITE</term>
<listitem><para>Create subkeys, set values
</para></listitem></varlistentry>
<varlistentry><term>READ</term>
<listitem><para>Query subkeys and values
</para></listitem></varlistentry>
<varlistentry><term>QUERY</term>
<listitem><para>Values
</para></listitem></varlistentry>
<varlistentry><term>EXECUTE</term>
<listitem><para>Key access, no subkey access
</para></listitem></varlistentry>
<varlistentry><term>NOTIFY</term>
<listitem><para>Change notification
</para></listitem></varlistentry>
<varlistentry><term>LINK</term>
<listitem><para>Create symbolic links
</para></listitem></varlistentry>
</variablelist><para> More than one value can be specified separated by blanks.
</para>
<para>Notice that on Windows NT some keys require certain access
rights and do not allow to open the key with all but only with certain access
values.</para>
</section>

<section id="wrquer"><title>query</title>
<indexterm><primary>query method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>query method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-query--(--+------------+--)---------------------------------><
             +-key_handle-+
]]>
</programlisting>

<para>Retrieves information about a given key in a compound variable. The
values returned are <emphasis role="italic">class</emphasis> (class name),
<emphasis role="italic">subkeys</emphasis> (number of subkeys)
<emphasis role="italic">values</emphasis> (number of value entries),
<emphasis role="italic">date</emphasis> and
<emphasis role="italic">time</emphasis> of
last modification. If <emphasis role="italic">key_handle</emphasis> is omitted,
CURRENT_KEY is queried. Example:</para>
<programlisting>
myquery. = rg~query(objectrexxkey)
say "class="myquery.class "at" myquery.date
say "subkeys="myquery.subkeys "values="myquery.values
</programlisting>
</section>

<section id="wrrepl"><title>replace</title>
<indexterm><primary>replace method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>replace method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-replace(-+------------+-,-+------------+-,newfilename,oldfilename-)-><
            +-key_handle-+   +-subkeyname-+
]]>
</programlisting>

<para>Replaces the backup file of a key or subkey with a new file. Key must be
an immediate descendant of HKEY_LOCAL_MACHINE or HKEY_USERS. If
<emphasis role="italic">key_handle</emphasis> is omitted, the backup file of
CURRENT_KEY is replaced. The values in the new file become active when the
system is restarted. If <emphasis role="italic">subkeyname</emphasis> is
omitted, the key and all its subkeys will be replaced.</para>
</section>

<section id="wrrest"><title>restore</title>
<indexterm><primary>restore method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>restore method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-restore(-+------------+-,filename-+-------------+-)---------><
            +-key_handle-+           +-,"VOLATILE"-+
]]>
</programlisting>

<para>Restores a key from a file. If
<emphasis role="italic">key_handle</emphasis> is omitted, CURRENT_KEY
is restored. Example:</para>
<programlisting>
rg~restore(objectrexxkey,"\objrexx\orexx")
</programlisting>
<para>The VOLATILE keyword creates a new memory-only set of registry
information that is valid only until the system is restarted.</para>
</section>

<section id="wrsave"><title>save</title>
<indexterm><primary>save method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>save method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-save(-+------------+-,filename)-----------------------------><
         +-key_handle-+
]]>
</programlisting>

<para>Saves the entries of a given key into a file. If
<emphasis role="italic">key_handle</emphasis> is
omitted, CURRENT_KEY is saved. Example: </para>
<programlisting>
rg~SAVE(objectrexxkey,"\objrexx\orexx")
</programlisting>
<para>On a FAT system, do not use a file extension in
<emphasis role="italic">filename</emphasis>.</para>
</section>

<section id="wrstva"><title>setValue</title>
<indexterm><primary>setValue method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>setValue method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-setValue(-+------------+-,-+------+-,value-+---------+-)----><
             +-key_handle-+   +-name-+        +-,NORMAL-+
                                              +-,EXPAND-+
                                              +-,MULTI--+
                                              +-,NUMBER-+
                                              +-,BINARY-+
                                              +-,NONE---+
]]>
</programlisting>

<para>Sets a named value of a given key. If
<emphasis role="italic">name</emphasis> is blank or omitted,
the default value is set. Examples: </para>
<programlisting>
rg~SETVALUE(objectrexxkey, ,"My default","NORMAL")
rg~SETVALUE(objectrexxkey,"Product_Name","Object Rexx")
rg~SETVALUE(objectrexxkey,"VERSION","1.0")
</programlisting>
</section>

<section id="wrunld"><title>unload</title>
<indexterm><primary>unload method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>unload method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-unload(-+------------+-,subkey)-----------------------------><
           +-key_handle-+
]]>
</programlisting>

<para>Removes a named subkey (created with <link linkend="wrload">LOAD</link>)
and its dependents from the registry, but does not modify the file containing
the registry information. If <emphasis role="italic">key_handle</emphasis>
is omitted, the subkey under CURRENT_KEY is unloaded. Unload also unlocks the
registry information file.</para>
</section>

<section id="wruse"><title>users</title>
<indexterm><primary>users method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>users method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-users-------------------------------------------------------><
]]>
</programlisting>

<para>Returns the handle of the root key HKEY_USERS.</para>
</section>

<section id="wrusee"><title>users=</title>
<indexterm><primary>users= method</primary>
<secondary>of WindowsRegistry class</secondary></indexterm>
<indexterm><primary>method</primary>
<secondary>users= method</secondary>
<tertiary>of WindowsRegistry class</tertiary></indexterm>
<programlisting>
<![CDATA[
>>-users=------------------------------------------------------><
]]>
</programlisting>

<para>This method is used by INIT to set the attribute USERS to HKEY_USERS. Do
not modify this attribute.</para>
</section>
</section>

</section>

