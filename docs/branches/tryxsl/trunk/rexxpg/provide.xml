<!--#########################################################################
    #
    # Description: Open Object Rexx: Programming Guide SGML file.
    #
    # Copyright (c) 2005-2007, Rexx Language Association. All rights reserved.
    # Portions Copyright (c) 2004, IBM Corporation. All rights reserved.
    #
    # This program and the accompanying materials are made available under
    # the terms of the Common Public License v1.0 which accompanies this
    # distribution. A copy is also available at the following address:
    # http://www.oorexx.org/license.html
    #
    # Redistribution and use in source and binary forms, with or
    # without modification, are permitted provided that the following
    # conditions are met:
    #
    # Redistributions of source code must retain the above copyright
    # notice, this list of conditions and the following disclaimer.
    # Redistributions in binary form must reproduce the above copyright
    # notice, this list of conditions and the following disclaimer in
    # the documentation and/or other materials provided with the distribution.
    #
    # Neither the name of Rexx Language Association nor the names
    # of its contributors may be used to endorse or promote products
    # derived from this software without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
    # TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Author(s):
    #      W. David Ashley <dashley@us.ibm.com>
    #
    #########################################################################
-->
<chapter id="provide"><title>The Basics of Classes</title>
<para>Similar objects in Rexx are grouped into classes, forming a hierarchy.
Rexx gives you a basic class hierarchy to start with. All of the classes in
the hierarchy are described in detail in the
<citetitle pubwork="book">Open Object Rexx: Reference</citetitle>.
The following list shows the classes Rexx provides (there may be others
in the system). The classes indented are subclasses. Classes in the list that
are described later in this chapter are printed in bold:</para>
<indexterm><primary>classes</primary>
<secondary>Alarm class</secondary></indexterm>
<indexterm><primary>classes</primary>
<secondary>Class class</secondary></indexterm>
<indexterm><primary>classes</primary>
<secondary>collection classes</secondary></indexterm>
<indexterm><primary>classes</primary>
<secondary>Message class</secondary></indexterm>
<indexterm><primary>classes</primary>
<secondary>Monitor class</secondary></indexterm>
<indexterm><primary>classes</primary>
<secondary>Stem class</secondary></indexterm>
<indexterm><primary>classes</primary>
<secondary>Stream class</secondary></indexterm>
<indexterm><primary>classes</primary>
<secondary>String class</secondary></indexterm>
<indexterm><primary>classes</primary>
<secondary>Supplier class</secondary></indexterm>
<indexterm><primary>classes</primary>
<secondary>provided by Rexx</secondary></indexterm>
<indexterm><primary>collection classes</primary></indexterm>
<programlisting>
    Object
    Alarm
    Class
    Collection classes
        Array
        List
        Queue
        Table
        Set
        Directory
        Relation
        Bag
    Message
    Method
    Monitor
    Stem
    Stream
    String
    Supplier
</programlisting>

<section id="progcl"><title>Rexx Classes for Programming</title>
<para>The classes Rexx supplies provide the starting point for object-oriented
programming. Some key classes that you are likely to work with are described
in the following sections.</para>

<section id="alarmcl"><title>The Alarm Class</title>
<para>The Alarm class is used to create objects with timing and notification capability.
An alarm object is able to send a message to an object at any time in the
future, and until then, you can cancel the alarm.</para>
</section>

<section id="colcl"><title>The Collection Classes</title>
<para>The collection classes are
used to manipulate collections of objects. A collection is an object that
contains a number of <emphasis role="italic">items</emphasis>, which can be
any objects. These manipulations might include counting objects, organizing
them, or assigning them a supplier (for example, to indicate that a specific
assortment of baked goods is supplied by the Pie-by-Night Bakery).</para>
<para>Rexx includes classes, for example, for arrays, lists, queues, tables,
and directories. Each item stored in a Rexx collection has an associated index
that you can use to retrieve the item from the collection with the AT or []
(left and right bracket) methods, and each collection defines its own acceptable
index types: </para>
<variablelist>
<varlistentry><term>Array</term>
<listitem><para>A sequenced collection of objects ordered by whole-number indexes.
</para></listitem></varlistentry>
<varlistentry><term>List</term>
<listitem><para>A sequenced collection that lets you add new items at any position in
the sequence. A list generates and returns an index value for each item placed
in the list. The returned index remains valid until the item is removed from
the list.
</para></listitem></varlistentry>
<varlistentry><term>Queue</term>
<listitem><para>A sequenced collection of items ordered as a queue. You can remove items
from the head of the queue and add items at either its tail or its head. Queues
index the items with whole-number indexes, in the order in which the items
would be removed. The current head of the queue has index 1, the item after
the head item has index 2, up to the number of items in the queue.
</para></listitem></varlistentry>
<varlistentry><term>Table</term>
<listitem><para>A collection of indexes that can be any object. For example, string
objects, array objects, alarm objects, or any user-created object can be a
table index.  The Table class determines an index match by using the == comparison
method to test for strict equality. A table contains no duplicate indexes.
</para></listitem></varlistentry>
<varlistentry><term>Directory</term>
<listitem><para>A collection of character string indexes. Indexes are compared using
the string == comparison method to test for strict equality.
</para></listitem></varlistentry>
<varlistentry><term>Relation</term>
<listitem><para>A collection of indexes that can be any object (as with the Table class).
A relation can contain duplicate indexes.
</para></listitem></varlistentry>
<varlistentry><term>Set</term>
<listitem><para>A collection where the indexes are equal to the values. Set indexes
can be any object (as with the Table class) and each index is unique.
</para></listitem></varlistentry>
<varlistentry><term>Bag</term>
<listitem><para>A collection where the index is equal to the value. Bag indexes can
be any object (as with the Table class) and each index can appear more than
once.
</para></listitem></varlistentry>
</variablelist>
</section>

<section id="msgcl"><title>The Message Class</title>
<indexterm><primary>classes</primary>
<secondary>Message class</secondary></indexterm>
<para>To manipulate message
objects, you use the Message class. Methods created
for this class are used, for example, to send a message, to notify the sender
object when an error occurs or when message processing is complete, to return
the results of that processing to the sender or to some other object, or to
process the message object concurrently with the sender object.</para>
</section>

<section id="moncl"><title>The Monitor Class</title>
<indexterm><primary>classes</primary>
<secondary>Monitor class</secondary></indexterm>
<para>The Monitor class provides a way to forward messages to a specified destination.
Monitor methods let you initialize a monitor object, specify a destination
object or use a previously specified one, and obtain the name of the current
destination object.</para>
</section>

<section id="stemcl"><title>The Stem Class</title>
<indexterm><primary>classes</primary>
<secondary>Stem class</secondary></indexterm>
<para>A stem is a symbol that
must start with a letter and end with a period, like &quot;FRED.&quot; or &quot;A.&quot;.
The value of a stem is a stem object by default. A stem object is a collection
of unique indexes that are character strings. Stem objects are automatically
created when a Rexx stem variable or Rexx compound variable is used. In addition
to the items assigned to the collection indexes, a stem object also has a
default value that is used for all uninitialized indexes of the collection.
You can assign a default value to a stem object and later retrieve this value.</para>
</section>

<section id="streacl"><title>The Stream Class</title>
<indexterm><primary>classes</primary>
<secondary>Stream class</secondary></indexterm>
<para>Input and output streams
let Rexx communicate with external objects, such as people, files, queues,
serial interfaces, displays, and networks. In programming there are many stream
actions that can be coded as methods for manipulating the various stream objects.
These methods and objects are organized in the Stream class.</para>
<para>The methods are used to open streams for reading or writing, close streams
at the end of an operation, move the line-read or line-write position within
a file stream, or get information about a stream. Methods are also provided
to get character strings from a stream or send them to a stream, count characters
in a stream, flush buffered data to a stream, query path specifications, time
stamps, size, and other information from a stream, or do any other I/O stream
manipulation (see <link linkend="rexio">Input and Output</link> for examples).</para>
</section>

<section id="strincl"><title>The String Class</title>
<indexterm><primary>strings</primary></indexterm>
<indexterm><primary>classes</primary>
<secondary>String class</secondary></indexterm>
<para>Strings are data values that can have
any length and contain any characters. They are subject to logical operations
like AND, OR, exclusive OR, and logical NOT. Strings can be concatenated,
copied, reversed, joined, and split. When strings are numeric, there is the
need to perform arithmetic operations on them or find their absolute value
or convert them from binary to hexadecimal, and vice versa. All this and more
can be accomplished using the String class of objects.</para>
</section>

<section id="supplcl"><title>The Supplier Class</title>
<indexterm><primary>classes</primary>
<secondary>Supplier class</secondary></indexterm>
<para>Some collections
have suppliers: a bakery, for example, can supply certain breads, cookies,
cakes and pies; a financial report can supply certain data, statistics, tables,
and reports. The  Supplier class is used to enumerate
items that a collection contained when the supplier was created. For example,
this class contains methods to verify if an item is available from a supplier
(Does the Pie-by-Night Bakery sell chocolate cake?). Another method returns
the index of the current item in a collection (What is the position of the
apple pie record?). Others return the current collection item in a collection
object, and the next item in the collection.</para>
</section>
</section>

<section id="orgcl"><title>Rexx Classes for Organizing Objects</title>
<para>Rexx provides several key classes that form the basis for building class
hierarchies.</para>

<section id="objcl"><title>The Object Class</title>
<para>Because the topmost class in the hierarchy, or the root class,
is the Object class, everything below it is an object.
To interact with each other, objects require their own actions, called methods.
These methods, which encode actions that are needed by all objects, belong
to the Object class.</para>
<para>Every other class in the hierarchy inherits the methods of the root class.
Inheritance is the handing down of methods from a &quot;parent&quot;
class--called a superclass--to
all of its &quot;descendent&quot; classes--called subclasses. Finally,
instances acquire methods from their classes. Any method created for the Object
class is automatically made available to every other class in the hierarchy.</para>
</section>

<section id="classcl"><title>The Class Class</title>
<para>The Class class is used for generating new classes. If a class is like a
factory for producing instances, Class is like a factory
for producing factories. Class is the parent of every
new class in the hierarchy, and these all inherit Class-like characteristics.
Class-like characteristics are methods and related variables, which reside
in Class, to be used by all classes.</para>
<para>A class that can be used to create another class is called a
<indexterm><primary>metaclasses</primary></indexterm>
metaclass. The Class class
is unique among Rexx classes in that it is the only metaclass that Rexx provides
(see <link linkend="meta">Metaclasses</link>).
As such, the Class's methods not only make
new classes, they make methods for use by the new class and its instances.
They also make methods that only the new class itself can use, but not its
instances. These are called class methods. They give
a new class some power that is denied to its instances.</para>
<para>Because each instance of Class is another class, that class inherits the
Class's instance methods as class methods.  Thus if Class generates a
Pizza factory instance, the factory-running actions (Class's instance methods)
become the class methods of
the Pizza factory. Factory operations are class methods, and any new methods
created to manipulate pizzas would be instance methods:</para>

<figure><title>How Subclasses Inherit Instance Methods from the Class Class</title>
<indexterm><primary>inheritance</primary></indexterm>
<mediaobject>
<imageobject>
<imagedata fileref="rxoq0s02.jpg" scale="75" />
</imageobject>
</mediaobject>
</figure>

<para>As a programmer, you typically create classes by using directives, rather
than the methods of the Class class. In particular,
you'll use the ::CLASS directive, described later in this section. The
::CLASS directive is a kind of Rexx clause that allows class definitions to
be saved permanently, in a file, where they can be reused by other programs.
Creating classes by using Class methods sent as messages is not recommended
if permanency or reuse is required. At any rate, directives have class-creating
powers similar to the Class methods.</para>
</section>
</section>

<section id="bigpict"><title>Rexx Classes: The Big Picture</title>
<indexterm><primary>classes</primary>
<secondary>provided by Rexx</secondary></indexterm>
<para>The following are the supplied Rexx classes.</para>

<figure float="1">
<title id="meths1">Classes and Inheritance (part 1 of 7)</title>
<mediaobject>
<imageobject>
<imagedata fileref="ooRexxClasses1.png" align="left" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths2">Classes and Inheritance (part 2 of 7)</title>
<mediaobject>
<imageobject>
<imagedata fileref="ooRexxClasses2.png" align="left" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths3">Classes and Inheritance (part 3 of 7)</title>
<mediaobject>
<imageobject>
<imagedata fileref="ooRexxClasses3.png" align="left" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths4">Classes and Inheritance (part 4 of 7)</title>
<mediaobject>
<imageobject>
<imagedata fileref="ooRexxClasses4.png" align="left" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths5">Classes and Inheritance (part 5 of 7)</title>
<mediaobject>
<imageobject>
<imagedata fileref="ooRexxClasses5.png" align="left" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths6">Classes and Inheritance (part 6 of 7)</title>
<mediaobject>
<imageobject>
<imagedata fileref="ooRexxClasses6.png" align="left" scale="90" />
</imageobject>
</mediaobject>
</figure>

<figure float="1">
<title id="meths7">Classes and Inheritance (part 7 of 7)</title>
<mediaobject>
<imageobject>
<imagedata fileref="ooRexxClasses7.png" align="left" scale="90" />
</imageobject>
</mediaobject>
</figure>
</section>

<section id="created"><title>Creating Your Own Classes Using Directives</title>
<indexterm><primary>directives</primary>
<secondary>creating classes with</secondary></indexterm>
<para> By analyzing your problem in terms of objects, you
can determine what classes need to be created.  You can create a class using
messages or directives. Directives are a new kind of Rexx clause, and they
are preferred over messages because the code is easier to read and understand,
especially in large programs. They also provide an easy way for you to save
your class definitions and share them with others using the PUBLIC option.</para>

<section id="whatdir"><title>What Are Directives?</title>
<indexterm><primary>directives</primary>
<secondary>definition</secondary></indexterm>
<indexterm><primary>Rexx</primary>
<secondary>directives</secondary></indexterm>
<indexterm><primary>creating classes</primary></indexterm>
<indexterm><primary>classes</primary>
<secondary>creating with directives</secondary></indexterm>
<para>A Rexx program is made up of one or more executable units. Directives
separate these units, which themselves are Rexx programs.
Rexx processes all directives first to set up any classes, methods, or routines
needed by the program. Then it runs any code that exists before the first
directive. The first directive in a program marks the end of the executable
part of the program. A directive is a kind of clause that begins with a double-colon
(::) and is non-executable (a directive cannot appear in the expression of
an INTERPRET instruction, for example).</para>
</section>

<section id="rexdir"><title>The Directives Rexx Provides</title>
<indexterm><primary>directives</primary></indexterm>

<para>The following is a short summary of all the Rexx directives. See the
<citetitle pubwork="book">Open Object Rexx: Reference</citetitle>
for more details on, or examples of, any of these Rexx directives.</para>

<section id="clasdir"><title>The ::CLASS Directive</title>
<indexterm><primary>directives</primary>
<secondary>::CLASS</secondary></indexterm>
<para>You use the ::CLASS directive to create a class. Programs can then use
the new class by specifying it as a Rexx environment symbol (the class name
preceded by a period) in the program. For example, in
<link linkend="sample">A Sample Program Using Directives</link>,
the Savings class is created using the ::CLASS directive. A program can then
use the new class by specifying it as an environment symbol, &quot;.savings&quot;.</para>
<para>The new class that you create acquires any methods defined by subsequent
::METHOD directives within the program, until either another ::CLASS directive
or the end of the program is reached.</para>
<para>You can use the ::CLASS directive's SUBCLASS option to make the new
class the subclass of another. In
<link linkend="sample">A Sample Program Using Directives</link>, the Savings class
is made a subclass of the Account class. A subclass inherits instance and
class methods from its specified superclass; in the sample, Savings inherits
from Account.</para>
<para>Additional ::CLASS directive options are available for: </para>
<itemizedlist>
<listitem><para>Inheriting instance methods from a specified metaclass
as class methods of the new class (the METACLASS option).
For more information on metaclasses, see
<link linkend="meta">Metaclasses</link>.</para></listitem>
<listitem><para>Making the new class available to programs outside its containing Rexx
program (the PUBLIC option). The outside program must refer to the new class
by using a ::REQUIRES directive.</para></listitem>
<listitem><para>Subclassing the new class to a mixin class in order to inherit its instance
and class methods (the MIXINCLASS option).</para></listitem>
<listitem><para>Adding the instance and class methods of a mixin class to the new class,
without subclassing it (the INHERIT option).</para></listitem></itemizedlist>
<para>When you create a new class, it is always a subclass of an existing class.
If you do not specify the SUBCLASS or MIXINCLASS option on the ::CLASS directive,
the superclass for the new class is the Object class.</para>
<para>Your class definition can be in a file of its own, with no executable code
preceding it. For example, when you define classes and methods to be shared
by several programs, you put the executable code in another file and refer
to the class file using a ::REQUIRES directive.</para>
<para>Rexx processes ::CLASS directives in the order in which they appear, unless
there is a dependency on some later directive's processing. You cannot
create two classes that have the same class name in one program. If several
programs contain classes with the same name, the last ::CLASS directive processed
is used.</para>
</section>

<section id="methdir"><title>The ::METHOD Directive</title>
<indexterm><primary>directives</primary>
<secondary>::METHOD</secondary></indexterm>
<para>The ::CLASS directive is usually followed by a ::METHOD directive, which
is used to create a method for that class and define the method's attributes.
The next directive in the program, or the end of the program, ends the method.</para>
<para>Some classes you define have an INIT method. INIT is called whenever a
NEW message is sent to a class. The INIT method must contain whatever code
is needed to initialize the object.</para>
<para>It is not required that a ::METHOD directive be preceded by a ::CLASS directive.
However, without it the method is only accessible by the executable part of
the program through Rexx's .METHODS environment symbol. This symbol identifies
a directory of methods that you can refer to by name. For each method name
only one method directive can appear that is not associated with a class.</para>
<para>The ::METHOD directive can be used for: </para>
<itemizedlist>
<listitem><para>Creating a class method for the most-recent ::CLASS
directive (the CLASS option).</para></listitem>
<listitem><para>Creating a private method; that is, a method that
works like a subroutine and can only be activated by the object it belongs
to--otherwise the method is public by default, and any sender can activate
it.</para></listitem>
<listitem><para>Creating a method that can be called while other methods are active on
the same object, as described in
<link linkend="activat">Activating Methods</link> (the UNGUARDED option).
</para></listitem>
<listitem><para>Creating the instance methods
<emphasis role="italic">method_name</emphasis> and
<emphasis role="italic">method_name</emphasis>= for the preceding ::CLASS
directive (the ATTRIBUTE option).</para></listitem>
</itemizedlist>
</section>

<section id="routdir"><title>The ::ROUTINE Directive</title>
<indexterm><primary>directives</primary>
<secondary>::ROUTINE</secondary></indexterm>
<para>You use the ::ROUTINE directive to create a named routine within a program.
The ::ROUTINE directive starts the named routine and another directive (or
the end of the program) ends the routine.</para>
<para>The ::ROUTINE directive is useful for defining lower-level routines that
are called by several methods. These methods might be in unrelated classes
or in different applications. You use ::ROUTINE when you have a utility that
you do not want to appear as a method.</para>
<para>The ::ROUTINE directive includes a PUBLIC option for making the routine
available to programs outside its containing Rexx program. The outside program
must reference the routine by using a ::REQUIRES directive.</para>
<para>Only one ::ROUTINE directive can appear for a routine name within a program.</para>
</section>

<section id="requdir"><title>The ::REQUIRES Directive</title>
<indexterm><primary>directives</primary>
<secondary>::REQUIRES</secondary></indexterm>
<para>You use the ::REQUIRES directive when a program needs access to the classes
and objects of another program. This directive has the following form: </para>
<indexterm><primary>directives</primary>
<secondary>::REQUIRES example</secondary></indexterm>
<programlisting>
<![CDATA[
::REQUIRES program_name
]]>
</programlisting>
<para>The ::REQUIRES directive must precede all other directives, and the order
of the ::REQUIRES directives determines the search order for the classes and
routines defined in the named programs.</para>
<para>Local routine or class definitions within a program override routines or
classes of the same name in programs that are accessed through ::REQUIRES
directives. Another directive (or the end of the program) must follow a ::REQUIRES
directive.</para>
</section>
</section>

<section id="howdir"><title>How Directives Are Processed</title>
<indexterm><primary>directives</primary>
<secondary>order of processing</secondary></indexterm>
<para>You place a directive (and its method code) after the
program code. When you run a program containing directives, Rexx: </para>
<orderedlist>
<listitem><para>Processes the directives first, to set up the program's classes, methods,
and routines.</para></listitem>
<listitem><para>Runs any program code preceding the first directive. This code can use
any classes, methods, and routines set up by the directives. </para>
<para>Once Rexx
has processed the code preceding the directive, any public classes and objects
the program defines are available to programs having the appropriate ::REQUIRES
directive.</para></listitem></orderedlist>
</section>

<section id="sample"><title>A Sample Program Using Directives</title>
<indexterm><primary>directives</primary>
<secondary>sample program</secondary></indexterm>
<para>Here is a program that uses directives to create new classes and methods: </para>
<programlisting>
<![CDATA[
asav = .savings~new              /* executable code begins */
say asav~type                    /* executable code        */
asav~name= "John Smith"          /* executable code ends   */

::class Account                  /* directives begin ...   */

  ::method "TYPE"
    return "an account"

  ::method "NAME="
    expose name
    use arg name

::class Savings subclass Account

  ::method "TYPE"
    return "a savings account"   /* ... directives end     */
]]>
</programlisting>
<para>The preceding program uses the
::CLASS directive to create two classes, the Account class and its Savings
<indexterm><primary>SUBCLASS option</primary></indexterm>
subclass. In the <computeroutput>::class Account</computeroutput>
expression, the ::CLASS directive
precedes the name of the new class, Account.</para>
<para>The example program also uses the ::METHOD directive to create TYPE and
NAME= methods for Account. In the
<computeroutput>::method "TYPE"</computeroutput> expression, the
::METHOD directive precedes the method name, and is immediately followed by
the code for the method. Methods for any new class follow its ::CLASS directive
in the program, and precede the next ::CLASS directive.</para>
<para>In the <computeroutput>::method "NAME="</computeroutput>
method, the USE ARG instruction retrieves the argument.
<indexterm><primary>USE ARG instruction</primary></indexterm>
<indexterm><primary>EXPOSE instruction</primary></indexterm>
<indexterm><primary>variables</primary>
<secondary>exposing</secondary></indexterm>
The EXPOSE instruction, which must immediately follow the ::METHOD directive,
makes the value (here, &quot;John Smith&quot;) available for use by other methods.
A variable in an EXPOSE instruction is called an object
variable.</para>
<para>You do not have to associate object variables with a specific object. Rexx
keeps track of object variables for you. Whenever you send a message to savings
account Asav, which points to the Name object, Rexx knows what internal object
value to use. If you assign another value to Asav (such as &quot;Mary Smith&quot;),
Rexx deletes the object that was associated with Asav (&quot;John Smith&quot;)
as part of its normal garbage-collection operations.</para>
<para>In the Savings subclass, a second TYPE method is created that supersedes
the TYPE method Savings would otherwise have inherited from Account. Note
that the directives appear after the program code.</para>
</section>

<section id="dire"><title>Another Sample Program</title>
<indexterm><primary>directives</primary>
<secondary>sample program</secondary></indexterm>
<para>A directive is nonexecutable code that begins with a double colon (::)
and follows the program code. The ::CLASS directive creates a class; in this
example, the Dinosaur class. The sample provides two methods for the Dinosaur
class, INIT and DIET. These are added to the Dinosaur class using the ::METHOD
<indexterm><primary>INIT method</primary></indexterm>
directives. After the line containing the ::METHOD directive, the code for
the method is specified. Methods are ended either by the start of the next
directive or by the end of the program.</para>
<para>Because directives must follow the executable code in your program, you
put that code first. In this case, the executable code creates a new dinosaur,
Dino, that is an instance of the Dinosaur class. Rexx then runs the INIT method.
Rexx runs any INIT method automatically whenever the NEW message is received.
Here the INIT method is used to identify the type of dinosaur. Then the program
runs the DIET method to determine whether the dinosaur eats meat or vegetables.
Rexx saves the information returned by INIT and DIET as variables in the Dino
object.</para>
<para>In the example, the Dinosaur class and its two methods are defined following
the executable program code: </para>
<programlisting>
<![CDATA[
dino=.dinosaur~new         /* Create a new dinosaur instance and
                                            /* initialize variables */
dino~diet                  /* Run the DIET method          */
exit
]]>
 </programlisting>

<programlisting>
<![CDATA[
::class Dinosaur           /* Create the Dinosaur class  */

  ::method init            /* Create the INIT method     */
    expose type
    say "Enter a type of dinosaur."
    pull type
    return

  ::method diet            /* Create the DIET method     */
    expose type
    select
    when type="T-REX" then string="Meat-eater"
    when type="TYRANNOSAUR" then string="Meat-eater"
    when type="TYRANNOSAURUS REX" then string="Meat-eater"
    when type="DILOPHOSAUR" then string="Meat-eater"
    when type="VELICORAPTOR" then string="Meat-eater"
    when type="RAPTOR" then string="Meat-eater"
    when type="ALLOSAUR" then string="Meat-eater"
    when type="BRONTOSAUR" then string="Plant-eater"
    when type="BRACHIOSAUR" then string="Plant-eater"
    when type="STEGOSAUR" then string="Plant-eater"
    otherwise string="Type of dinosaur or diet unknown"
    end
    say string
    return 0
]]>
</programlisting>
</section>
</section>

<section id="createm"><title>Creating Classes Using Messages</title>
<indexterm><primary>creating classes</primary></indexterm>
<indexterm><primary>classes</primary>
<secondary>creating with messages</secondary></indexterm>
<indexterm><primary>messages</primary>
<secondary>creating classes with</secondary></indexterm>
<para>You can create a class using messages as well as directives.
Though classes are available only to the program that creates them, there
are occasions when this is useful and public availability is not required.
The following sections demonstrate the message technique using the Savings
Account example previously shown with directives.</para>

<section id="definec"><title>Defining a New Class</title>
<para>To define a new class using messages, you send a SUBCLASS message to the
new class's superclass. That is, you send the message to the class that
precedes the new class in the hierarchy. To define a subclass of the Object
class called Account, you enter: </para>
<programlisting>
<![CDATA[
account = .object~subclass("Account")
]]>
</programlisting>
<para>Here, <computeroutput>.object</computeroutput> is a reference to the
Rexx Object class. <computeroutput>.object</computeroutput> is an environment
symbol indicating the intention to create
a new class that is a subclass of the Object class. Environment symbols represent
objects in a directory of public objects, called the Environment
object. These public objects are available to all other objects, and
include all the classes that Rexx provides. Environment symbols begin with
a period and are followed by the class name. Thus the Object class is represented
by <computeroutput>.object,</computeroutput> the Alarm class by
<computeroutput>.alarm,</computeroutput> the Array class
by <computeroutput>.array,</computeroutput> and so on.</para>
<para>The twiddle (~) is the &quot;message send&quot; symbol,
<computeroutput>subclass</computeroutput> is a method of Class, and the string
identifier in parentheses is an
argument of SUBCLASS that names the new class, Account.</para>
</section>

<section id="definem"><title>Adding a Method to a Class</title>
<para>You use the DEFINE method to define methods for your new class. To define
a TYPE method and a NAME= method, you enter: </para>
<programlisting>
<![CDATA[
account~define("TYPE", "return ""an account""")
account~define("NAME=", "expose name; use arg name")
]]>
</programlisting>
</section>

<section id="defines"><title>Defining a Subclass of the New Class</title>
<para>Using the SUBCLASS method, you can define a subclass for your new class
and then a method for that subclass. To define a Savings subclass for the
Account class, and a TYPE method for Savings, you enter: </para>
<programlisting>
<![CDATA[
savings = account~subclass("Savings Account")
savings~define("TYPE", "return ""a savings account""")
]]>
</programlisting>
</section>

<section id="definei"><title>Defining an Instance</title>
<para>You use the NEW method to define an instance of the new class,
and then call methods that the instance inherited from its superclass. To
define an instance of the Savings class named &quot;John Smith,&quot; and send
John Smith the TYPE and NAME= messages to call the related methods, you enter: </para>
<programlisting>
<![CDATA[
newaccount = savings~new
say newaccount~type
newaccount~name = "John Smith"
]]>
</programlisting>
</section>
</section>

<section id="types"><title>Types of Classes</title>
<para>In Rexx there are three class types: </para>
<itemizedlist>
<listitem><para>Object classes</para></listitem>
<listitem><para>Abstract classes</para></listitem>
<listitem><para>Mixin classes</para></listitem></itemizedlist>
<para>An object class (the default) can create instances
of the object in response to receiving a NEW or ENHANCED message. An abstract
class serves mainly to organize other classes in the hierarchy
and define their message interface. A mixin class,
through multiple inheritance, is an additional superclass to a class. The
mixin class typically possesses methods useful to the class that inherits
it, but these must be specifically added because they
lie outside the class's normal line of inheritance.</para>
<para>The following sections explain these class types in more detail.</para>

<section id="objcla"><title>Object Classes</title>
<indexterm><primary>object classes</primary></indexterm>
<indexterm><primary>classes</primary>
<secondary>object</secondary></indexterm>
<para>An object class creates instances and
provides  methods that these instances can use. At the time of its creation,
an instance acquires all instance methods of the class it belongs to. If a
class adds new methods later, existing instances do not acquire them. Instances
created after the new methods do acquire them.</para>
<para>Because classes define methods for their instances, and methods define
the variables that instances use, object classes are factories for creating
Rexx instances. The Array class is an example of an object class.</para>
</section>

<section id="abscla"><title>Abstract Classes</title>
<indexterm><primary>abstract classes, definition</primary></indexterm>
<indexterm><primary>classes</primary>
<secondary>abstract</secondary></indexterm>
<para>An abstract class defines methods
its subclasses can inherit, but typically has no instances. Rather, it serves
to organize other classes in the hierarchy. An abstract class can be used
to &quot;filter out&quot; a group of shared methods from a number of subclasses,
so they do not have to exist in two places.</para>
<para>An abstract class pushes common elements further up the hierarchy, thus
providing a higher level of organization. By filtering out and moving common
methods upwards, the abstract class refines the message interface for its
subclasses. This lays the groundwork for polymorphism, creating well-defined
interfaces for users of the hierarchy. Abstract classes inherit the instance
methods of the Class class.</para>
<para>You can create a new abstract class like an object class. You use a simple
::CLASS directive; no options are required. While abstract classes are not
intended for creating instances, Rexx does not prevent you from doing so.</para>
</section>

<section id="mixin"><title>Mixin Classes</title>
<indexterm><primary>mixin classes</primary></indexterm>
<indexterm><primary>classes</primary>
<secondary>mixin</secondary></indexterm>
<para>The mixin class lets you optionally add a set of instance and class methods to one or
more other classes using inheritance. You use mixins to extend the scope of
a class beyond the usual lines of inheritance defined by the hierarchy. This
is like widening a class's inheritance to accept methods from a sibling
or cousin, as well as a parent. When a class inherits from more than just
its parent superclass, it is called multiple inheritance.</para>
<para>You can add mixin methods to a class by using the INHERIT option on the
::CLASS directive. The class to be inherited must be a mixin class. During
class creation and multiple inheritance, subclasses inherit both class and
instance methods from their superclasses.</para>
<para>A mixin's first non-mixin superclass is its base
<indexterm><primary>SUBCLASS option</primary></indexterm>
class. Any subclass of a mixin's base class can directly or indirectly
inherit a mixin; other classes cannot.</para>
<para>To create a new mixin class, you use the ::CLASS directive with the MIXINCLASS
option. A mixin class is also an object class and can create its own instances.</para>
</section>
</section>

<section id="meta"><title>Metaclasses</title>
<indexterm><primary>metaclasses</primary></indexterm>
<indexterm><primary>classes</primary>
<secondary>metaclass</secondary></indexterm>
<para>A metaclass is
a class you can use to create another class. Rexx provides just one metaclass,
the Class class. A class is a factory for creating instances, and the Class
class is a factory for creating factories. Whenever you create a new factory,
or class, the new class is an instance
of Class. The instance methods of Class provide the
operations needed to run the new factories. These instance methods are inherited
by the new factory as its class methods.</para>
<para>The classes Rexx provides do not permit changes or additions to their method
definitions. As a result, all new factories inherit these unchangeable actions
from the Class class, and thus operate the same way. So if you want to create
a new class--a new factory--that behaves
differently from the others, you can do either of the following: </para>
<itemizedlist>
<listitem><para>Write additional class methods for the new class, using
the ::METHOD directive with the CLASS option</para></listitem>
<listitem><para>Use a metaclass</para></listitem></itemizedlist>
<para>If you plan to create many factories with the same operational changes,
you use the metaclass.</para>
<para>Any metaclass you create is
a subclass of the Class class. To make your own metaclass, specify
<computeroutput>class</computeroutput> as a SUBCLASS option in the ::CLASS
directive: </para>
<programlisting>
<![CDATA[
/* Create a new metaclass  */
::class your_metaclass subclass class
]]>
</programlisting>
<para>The instance methods of
<emphasis role="italic">your_metaclass</emphasis> becomes the class methods
for any new class created using
<emphasis role="italic">your_metaclass.</emphasis> For example, you
could create a metaclass called InstanceCounter that includes instance methods
for tracking how many instances the class creates: </para>
<programlisting>
<![CDATA[
/* Create a new metaclass that counts its instances        */
::class InstanceCounter subclass class
  ::method init
  ...
]]>
</programlisting>
<para>Instead of having to add instance-counting class methods to other new classes
you write, you can make InstanceCounter their metaclass. When you create the
new class, you specify InstanceCounter as a METACLASS option in the ::CLASS
directive. Creating a Point class might look like this: </para>
<programlisting>
<![CDATA[
/* Create a public Point class using the InstanceCounter metaclass  */
::class point public metaclass InstanceCounter
  ::method init
  ...
]]>
</programlisting>
<para>The instance methods in your new InstanceCounter metaclass become the class
methods of the Point class, and any other classes that you create in the future
using a similar directive. Here is a complete example: </para>
<programlisting>
<![CDATA[
/* A metaclass example */

a = .point~new(1,1)                   /* Create point instances       */
say "Created point instance" a        /* a, b, and c.                 */
b = .point~new(2,2)
say "Created point instance" b
c = .point~new(3,3)
say "Created point instance" c

                                      /* Ask the Point class how many */
                                      /* instances it has created.    */
say "The point class has created" .point~instances "instances."

                                      /* Create a new metaclass that  */
                                      /* counts its instances.        */
::class InstanceCounter subclass class
  ::method init                       /* Create an INIT method to     */
    expose instanceCount              /* initialize instanceCount.    */
    instanceCount = 0                 /* Forward INIT to superclass.  */

    .message~new(self, .array~of("INIT",super), "a", arg(1,"A"))~send

  ::method new                        /* Create a NEW instance method.*/
    expose instanceCount              /* Create a new instance.       */
    instanceCount = instanceCount + 1 /* Bump the count.              */

                                      /* Forward NEW to superclass.   */
    return .message~new(self, .array~of("NEW",super), "a", arg(1,"A"))~send


  ::method instances                  /* Create an INSTANCES method.  */
    expose instanceCount              /* Return the instance count.   */
    return instanceCount

                                      /* Create Point class using     */
                                      /* InstanceCounter metaclass.   */
::class point public metaclass InstanceCounter
  ::method init                       /* Create an INIT method.       */
    expose xVal yVal                  /* Set object variables         */
    use arg xVal, yVal                /* as passed on NEW.            */

  ::method string                     /* Create a STRING method.      */
    expose xVal yVal                  /* Use object variables         */
    return "("xVal","yVal")"          /* to return string value.      */
]]>
</programlisting>
</section>
</chapter>
